{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/dba6216caa71796f25831908035cd9eb0fb54715",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/dba6216caa71796f25831908035cd9eb0fb54715/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/dba6216caa71796f25831908035cd9eb0fb54715/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/dba6216caa71796f25831908035cd9eb0fb54715/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 205,
          "old_api": "length",
          "new_api": "to_utf8",
          "old_text": "put.length() }",
          "new_text": "coder->to_utf8(input));",
          "old_line_content": "        StringBuilder builder { input.length() };",
          "new_line_content": "        auto decoded_input = TRY(decoder->to_utf8(input));",
          "content_same": false
        },
        {
          "line": 209,
          "old_api": "try_append",
          "new_api": "bytes",
          "old_text": "coder->process(input, [&builder, &last_was_carriage_return](u32 code_point) -> ErrorOr<void> {\n            // Replace any U+000D CARRIAGE RETURN (CR) code points,\n            // U+000C FORM FEED (FF) code points,\n            // or pairs of U+000D CARRIAGE RETURN (CR) followed by U+000A LINE FEED (LF)\n            // in input by a single U+000A LINE FEED (LF) code point.\n            if (code_point == '\\r') {\n                if (last_was_carriage_return) {\n                    TRY(builder.try_append('\\n'));\n                } else {\n                    last_was_carriage_return = true;\n                }\n            } else {\n                if (last_was_carriage_return)\n                    TRY(builder.try_append('\\n'));\n\n                if (code_point == '\\n') {\n                    if (!last_was_carriage_return)\n                        TRY(builder.try_append('\\n'));\n\n                } else if (code_point == '\\f') {\n                    TRY(builder.try_append('\\n'));\n                    // Replace any U+0000 NULL or surrogate code points in input with U+FFFD REPLACEMENT CHARACTER (ï¿½).\n                } else if (code_point == 0x00 || (code_point >= 0xD800 && code_point <= 0xDFFF)) {\n                    TRY(builder.try_append_code_point(REPLACEMENT_CHARACTER));\n                } else {\n                    TRY(builder.try_append_code_point(code_point));\n                }\n\n                last_was_carriage_return = false;\n            }\n            return {};\n        }));\n ",
          "new_text": "coded_input.bytes()) ",
          "old_line_content": "        TRY(decoder->process(input, [&builder, &last_was_carriage_return](u32 code_point) -> ErrorOr<void> {",
          "new_line_content": "            for (auto byte : decoded_input.bytes()) {",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": "end",
          "new_api": "ume_a_token",
          "old_text": "f8_view.end())\n  ",
          "new_text": "ume_a_token());\n ",
          "old_line_content": "    if (m_utf8_iterator == m_utf8_view.end())",
          "new_line_content": "        auto token = TRY(consume_a_token());",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": "set",
          "new_api": "end",
          "old_text": "es.set(i, *it);\n  ",
          "new_text": "f8_view.end(); ++",
          "old_line_content": "        values.set(i, *it);",
          "new_line_content": "    for (size_t i = 0; i < offset && it != m_utf8_view.end(); ++i)",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": "set",
          "new_api": "end",
          "old_text": "es.set(i, *it);\n  ",
          "new_text": "f8_view.end(); ++",
          "old_line_content": "        values.set(i, *it);",
          "new_line_content": "    for (size_t i = 0; i < 2 && it != m_utf8_view.end(); ++i) {",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": "_code_point",
          "new_api": "end",
          "old_text": "_code_point();\n  ",
          "new_text": "f8_view.end(); ++",
          "old_line_content": "    twin.first = next_code_point();",
          "new_line_content": "    for (size_t i = 0; i < 3 && it != m_utf8_view.end(); ++i) {",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": "_code_point",
          "new_api": "set",
          "old_text": "_code_point();\n\n ",
          "new_text": "es.set(i, *it);\n  ",
          "old_line_content": "    twin.second = peek_code_point();",
          "new_line_content": "        values.set(i, *it);",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": "_twin",
          "new_api": "nsume_current_input_code_point",
          "old_text": "_twin();\n  ",
          "new_text": "nsume_current_input_code_point();\n  ",
          "old_line_content": "    auto next_two = peek_twin();",
          "new_line_content": "    reconsume_current_input_code_point();",
          "content_same": false
        },
        {
          "line": 387,
          "old_api": "_code_point",
          "new_api": "(representation);",
          "old_text": "_code_point();\n\n ",
          "new_text": "(representation);\n  ",
          "old_line_content": "    auto input = next_code_point();",
          "new_line_content": "    token.m_representation = move(representation);",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": "_code_point",
          "new_api": "scii_hex_digit",
          "old_text": "_code_point();\n  ",
          "new_text": "scii_hex_digit(input)) {\n",
          "old_line_content": "            (void)next_code_point();",
          "new_line_content": "    if (is_ascii_hex_digit(input)) {",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": "string_view",
          "new_api": "append_code_point",
          "old_text": "der.string_view()).va",
          "new_text": "der.append_code_point(input);\n\n ",
          "old_line_content": "        auto unhexed = AK::StringUtils::convert_to_uint_from_hex<u32>(builder.string_view()).value_or(0);",
          "new_line_content": "        builder.append_code_point(input);",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "ater_than_maximum_allowed_code_point",
          "new_api": "_code_point",
          "old_text": "ater_than_maximum_allowed_code_point(unhexed)) {\n  ",
          "new_text": "_code_point()) &&",
          "old_line_content": "        if (unhexed == 0 || is_unicode_surrogate(unhexed) || is_greater_than_maximum_allowed_code_point(unhexed)) {",
          "new_line_content": "        while (is_ascii_hex_digit(peek_code_point()) && counter++ < 5) {",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": "e",
          "new_api": ");",
          "old_text": "e(start_byte_offset)));\n      ",
          "new_text": ");\n        ",
          "old_line_content": "            return create_value_token(Token::Type::Function, move(string), TRY(input_since(start_byte_offset)));",
          "new_line_content": "            auto maybe_whitespace = peek_twin();",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": "e",
          "new_api": "phe",
          "old_text": "e(start_byte_offset)));\n    }\n",
          "new_text": "phe(next_two.second)))) {\n    ",
          "old_line_content": "        return create_value_token(Token::Type::Function, move(string), TRY(input_since(start_byte_offset)));",
          "new_line_content": "        if (is_quotation_mark(next_two.first) || is_apostrophe(next_two.first) || (is_whitespace(next_two.first) && (is_quotation_mark(next_two.second) || is_apostrophe(next_two.second)))) {",
          "content_same": false
        },
        {
          "line": 514,
          "old_api": ");\n    if (",
          "new_api": "point",
          "old_text": ");\n    if (",
          "new_text": "point());\n    }\n\n",
          "old_line_content": "    auto maybe_number = peek_twin();",
          "new_line_content": "        repr.append_code_point(next_code_point());",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": "igit",
          "new_api": ");\n    if (",
          "old_text": "igit(digit))\n        ",
          "new_text": ");\n    if (",
          "old_line_content": "            if (!is_ascii_digit(digit))",
          "new_line_content": "    auto maybe_number = peek_twin();",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "igit",
          "new_api": "point",
          "old_text": "igit(maybe_exp.third))\n        ",
          "new_text": "point();\n        ",
          "old_line_content": "        && (((is_plus_sign(maybe_exp.second) || is_hyphen_minus(maybe_exp.second)) && is_ascii_digit(maybe_exp.third))",
          "new_line_content": "            auto digit = peek_code_point();",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": "minus",
          "new_api": "point",
          "old_text": "minus(maybe_exp.second)) {\n      ",
          "new_text": "point());\n       ",
          "old_line_content": "        if (is_plus_sign(maybe_exp.second) || is_hyphen_minus(maybe_exp.second)) {",
          "new_line_content": "            repr.append_code_point(next_code_point());",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": "point",
          "new_api": "et",
          "old_text": "point());\n       ",
          "new_text": "et();\n    if (",
          "old_line_content": "            repr.append_code_point(next_code_point());",
          "new_line_content": "    auto maybe_exp = peek_triplet();",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "point",
          "new_api": "_exp.first))",
          "old_text": "point());\n       ",
          "new_text": "_exp.first))\n        ",
          "old_line_content": "            repr.append_code_point(next_code_point());",
          "new_line_content": "    if ((is_E(maybe_exp.first) || is_e(maybe_exp.first))",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": "igit",
          "new_api": "point",
          "old_text": "igit(digits))\n        ",
          "new_text": "point());\n       ",
          "old_line_content": "            if (!is_ascii_digit(digits))",
          "new_line_content": "                repr.append_code_point(next_code_point());",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": "release_value",
          "new_api": "g_view",
          "old_text": "number<double>(AK::TrimWhitespace::No).release_value();\n}\n\n// ht",
          "new_text": "g_view());\n\n    //",
          "old_line_content": "    return string.to_number<double>(AK::TrimWhitespace::No).release_value();",
          "new_line_content": "    auto value = convert_a_string_to_a_number(repr.string_view());",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": "nput_stream_twin",
          "new_api": "point",
          "old_text": "nput_stream_twin())) {\n     ",
          "new_text": "point();\n\n       ",
          "old_line_content": "        if (is_valid_escape_sequence(start_of_input_stream_twin())) {",
          "new_line_content": "        auto input = next_code_point();",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": "caped_code_point",
          "new_api": "ut))",
          "old_text": "caped_code_point()));\n      ",
          "new_text": "ut))\n        ",
          "old_line_content": "            TRY(result.try_append_code_point(consume_escaped_code_point()));",
          "new_line_content": "        if (is_eof(input))",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "current_input_code_point",
          "new_api": "_append_code_point",
          "old_text": "current_input_code_point();\n        ",
          "new_text": "_append_code_point(input));\n       ",
          "old_line_content": "        reconsume_current_input_code_point();",
          "new_line_content": "            TRY(result.try_append_code_point(input));",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": "(input)) {",
          "new_api": "h_whitespace_as_possible",
          "old_text": "(input)) {\n          ",
          "new_text": "h_whitespace_as_possible();\n\n    auto ma",
          "old_line_content": "        if (is_right_paren(input)) {",
          "new_line_content": "    consume_as_much_whitespace_as_possible();",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": "input)) {",
          "new_api": "(input)) {",
          "old_text": "input)) {\n          ",
          "new_text": "(input)) {\n          ",
          "old_line_content": "        if (is_whitespace(input)) {",
          "new_line_content": "        if (is_right_paren(input)) {",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": "h_whitespace_as_possible",
          "new_api": "}",
          "old_text": "h_whitespace_as_possible();\n\n           ",
          "new_text": "        }\n\n ",
          "old_line_content": "            consume_as_much_whitespace_as_possible();",
          "new_line_content": "            return make_token();",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "t",
          "new_api": "{",
          "old_text": "t();\n\n           ",
          "new_text": " {\n          ",
          "old_line_content": "            input = peek_code_point();",
          "new_line_content": "        if (is_eof(input)) {",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": "(input)) {",
          "new_api": "r",
          "old_text": "(input)) {\n          ",
          "new_text": "r();\n            ",
          "old_line_content": "            if (is_right_paren(input)) {",
          "new_line_content": "            log_parse_error();",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": "t",
          "new_api": "}",
          "old_text": "t();\n            ",
          "new_text": "        }\n\n ",
          "old_line_content": "                (void)next_code_point();",
          "new_line_content": "            return make_token();",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": "{",
          "new_api": "input)) {",
          "old_text": " {\n          ",
          "new_text": "input)) {\n          ",
          "old_line_content": "            if (is_eof(input)) {",
          "new_line_content": "        if (is_whitespace(input)) {",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": "r",
          "new_api": "h_whitespace_as_possible",
          "old_text": "r();\n            ",
          "new_text": "h_whitespace_as_possible();\n\n           ",
          "old_line_content": "                log_parse_error();",
          "new_line_content": "            consume_as_much_whitespace_as_possible();",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": "en",
          "new_api": "(input)) {",
          "old_text": "en(Token::Type::BadUrl);\n            ",
          "new_text": "(input)) {\n          ",
          "old_line_content": "            auto bad_url_token = create_new_token(Token::Type::BadUrl);",
          "new_line_content": "            if (is_right_paren(input)) {",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": "art_byte_offset));",
          "new_api": "t",
          "old_text": "art_byte_offset));\n           ",
          "new_text": "t();\n            ",
          "old_line_content": "            bad_url_token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "                (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": ");",
          "new_api": "art_byte_offset));",
          "old_text": ");\n              ",
          "new_text": "art_byte_offset));\n           ",
          "old_line_content": "                log_parse_error();",
          "new_line_content": "            bad_url_token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": "nce",
          "new_api": ");\n\n    // Consume a",
          "old_text": "nce());\n        VERIFY(!uni",
          "new_text": ");\n\n    // Consume a ",
          "old_line_content": "        auto unit = TRY(consume_an_ident_sequence());",
          "new_line_content": "    auto start_byte_offset = current_byte_offset();",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": "/ 3. Retur",
          "new_api": "// If the nex",
          "old_text": "/ 3. Retur",
          "new_text": "\n    // If the nex",
          "old_line_content": "        token.m_value = move(unit);",
          "new_line_content": "    auto number = consume_a_number();",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "_offset));\n        return toke",
          "new_api": "// 1. C",
          "old_text": "_offset));\n        return toke",
          "new_text": "       // 1. C",
          "old_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "    if (would_start_an_ident_sequence(peek_triplet())) {",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": "_offset));\n    return token;\n}",
          "new_api": "(void)nex",
          "old_text": "_offset));\n    return token;\n}",
          "new_text": "        (void)nex",
          "old_line_content": "    token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "    if (is_percent(peek_code_point())) {",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "rst))\n        // If the se",
          "new_api": "second))\n            return t",
          "old_text": "rst))\n        // If the se",
          "new_text": "second))\n            return t",
          "old_line_content": "    if (is_full_stop(values.first))",
          "new_line_content": "        if (is_ascii_digit(values.second))",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": "first))\n        // Return tr",
          "new_api": "third))\n            return t",
          "old_text": "first))\n        // Return tr",
          "new_text": "third))\n            return t",
          "old_line_content": "    if (is_ascii_digit(values.first))",
          "new_line_content": "        if (is_full_stop(values.second) && is_ascii_digit(values.third))",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": "ues.first)) {\n        // If the",
          "new_api": "return",
          "old_text": "ues.first)) {\n        // If the ",
          "new_text": "            return ",
          "old_line_content": "    if (is_reverse_solidus(values.first)) {",
          "new_line_content": "        if (is_ident_start_code_point(values.second) || is_hyphen_minus(values.second) || is_valid_escape_sequence(values.to_twin_23()))",
          "content_same": false
        },
        {
          "line": 968,
          "old_api": "// Thi",
          "new_api": "_offset));\n        return toke",
          "old_text": "       // Thi",
          "new_text": "_offset));\n        return toke",
          "old_line_content": "        if (is_eof(input)) {",
          "new_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "t_code_point",
          "new_api": "// EOF",
          "old_text": "t_code_point();\n            auto bad",
          "new_text": " // EOF\n    ",
          "old_line_content": "            reconsume_current_input_code_point();",
          "new_line_content": "            return make_token();",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": "cont",
          "new_api": "// Thi",
          "old_text": "              cont",
          "new_text": "           // Thi",
          "old_line_content": "            if (is_eof(next_input))",
          "new_line_content": "        if (is_newline(input)) {",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": ") {\n                (v",
          "new_api": "::Type::BadString);\n            bad_stri",
          "old_text": ") {\n                (v",
          "new_text": "::Type::BadString);\n            bad_stri",
          "old_line_content": "            if (is_newline(next_input)) {",
          "new_line_content": "            auto bad_string_token = create_new_token(Token::Type::BadString);",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": "cont",
          "new_api": "_offset));\n            return",
          "old_text": "             cont",
          "new_text": "_offset));\n            return ",
          "old_line_content": "                (void)next_code_point();",
          "new_line_content": "            bad_string_token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": "t",
          "new_api": "if (is_e",
          "old_text": "t(escaped);\n            continue;\n",
          "new_text": "         if (is_e",
          "old_line_content": "            builder.append_code_point(escaped);",
          "new_line_content": "            auto next_input = peek_code_point();",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": "input);\n    }\n}\n\n// https://www.",
          "new_api": "cont",
          "old_text": "input);\n    }\n}\n\n// https://www.",
          "new_text": "             cont",
          "old_line_content": "        builder.append_code_point(input);",
          "new_line_content": "                (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "nd)) {\n            (void)next",
          "new_api": "return;\n\n    (v",
          "old_text": "nd)) {\n            (void)next",
          "new_text": "\n        return;\n\n    (v",
          "old_line_content": "        if (is_asterisk(twin_inner.first) && is_solidus(twin_inner.second)) {",
          "new_line_content": "    if (!(is_solidus(twin.first) && is_asterisk(twin.second)))",
          "content_same": false
        },
        {
          "line": 1072,
          "old_api": "{\n        dbgln_if(CSS_T",
          "new_api": "whitespace\n    i",
          "old_text": "{\n        dbgln_if(CSS_T",
          "new_text": " whitespace\n    i",
          "old_line_content": "    if (is_quotation_mark(input)) {",
          "new_line_content": "    auto input = next_code_point();",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": ");\n    }\n\n    // U+0023 NUM",
          "new_api": "dbgln_if(CSS_T",
          "old_text": ");\n    }\n\n    // U+0023 NUM",
          "new_text": "      dbgln_if(CSS_T",
          "old_line_content": "        return consume_string_token(input);",
          "new_line_content": "    if (is_whitespace(input)) {",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": "dbgln_if(CSS_T",
          "new_api": "pe::Whitespace);\n        token.m_represen",
          "old_text": "       dbgln_if(CSS_T",
          "new_text": "pe::Whitespace);\n        token.m_represen",
          "old_line_content": "    if (is_number_sign(input)) {",
          "new_line_content": "        auto token = create_new_token(Token::Type::Whitespace);",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "UG, \"is number sign\");\n\n        // If the next",
          "new_api": "set));\n        return token;",
          "old_text": "UG, \"is number sign\");\n\n        // If the next ",
          "new_text": "set));\n        return token;\n ",
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is number sign\");",
          "new_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": "is_ident_co",
          "new_api": "{\n        dbgln_if(CSS_T",
          "old_text": "is_ident_co",
          "new_text": "{\n        dbgln_if(CSS_T",
          "old_line_content": "        auto maybe_escape = peek_twin();",
          "new_line_content": "    if (is_quotation_mark(input)) {",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": "token.m_h",
          "new_api": "UG, \"is number sign\");\n\n        // If the next",
          "old_text": "     token.m_h",
          "new_text": "UG, \"is number sign\");\n\n        // If the next ",
          "old_line_content": "            if (would_start_an_ident_sequence(peek_triplet()))",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is number sign\");",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": "token.m_value =",
          "new_api": "auto maybe_escap",
          "old_text": "            token.m_value =",
          "new_text": " auto maybe_escap",
          "old_line_content": "            auto name = TRY(consume_an_ident_sequence());",
          "new_line_content": "        auto next_input = peek_code_point();",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": "Return th",
          "new_api": "is_ident_co",
          "old_text": " Return th",
          "new_text": "is_ident_co",
          "old_line_content": "            token.m_value = move(name);",
          "new_line_content": "        auto maybe_escape = peek_twin();",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": "));\n    }\n\n    // U+0027 APOST",
          "new_api": "token.m_h",
          "old_text": "));\n    }\n\n    // U+0027 APOST",
          "new_text": "     token.m_h",
          "old_line_content": "        return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "new_line_content": "            if (would_start_an_ident_sequence(peek_triplet()))",
          "content_same": false
        },
        {
          "line": 1110,
          "old_api": "dbgln_if(CSS_TOKEN",
          "new_api": "token.m_value =",
          "old_text": "  dbgln_if(CSS_TOKEN",
          "new_text": "            token.m_value =",
          "old_line_content": "    if (is_apostrophe(input)) {",
          "new_line_content": "            auto name = TRY(consume_an_ident_sequence());",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": "\"is apostrophe\");\n        // Consume a string",
          "new_api": "Return th",
          "old_text": "\"is apostrophe\");\n        // Consume a string ",
          "new_text": " Return th",
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is apostrophe\");",
          "new_line_content": "            token.m_value = move(name);",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": "dbgln_if(CSS_TOKEN",
          "new_api": "}\n\n    // U+0028 LEFT PA",
          "old_text": "   dbgln_if(CSS_TOKEN",
          "new_text": "   }\n\n    // U+0028 LEFT PA",
          "old_line_content": "    if (is_right_paren(input)) {",
          "new_line_content": "        return consume_string_token(input);",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": ");\n        return token;\n    }",
          "new_api": "dbgln_if(CSS_TOKEN",
          "old_text": ");\n        return token;\n    }",
          "new_text": "  dbgln_if(CSS_TOKEN",
          "old_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "    if (is_left_paren(input)) {",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": "))) {\n            reconsume_cur",
          "new_api": "dbgln_if(CSS_TOKEN",
          "old_text": "))) {\n            reconsume_cur",
          "new_text": "   dbgln_if(CSS_TOKEN",
          "old_line_content": "        if (would_start_a_number(start_of_input_stream_triplet())) {",
          "new_line_content": "    if (is_right_paren(input)) {",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": "oint",
          "new_api": "\"is right paren\");\n        // Return a <)-token",
          "old_text": "oint();\n            return consume_a",
          "new_text": "\"is right paren\");\n        // Return a <)-token",
          "old_line_content": "            reconsume_current_input_code_point();",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is right paren\");",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": "ln_if",
          "new_api": "\"is plus sign\");\n        // If the input stre",
          "old_text": "ln_if(CSS_TOKEN",
          "new_text": "\"is plus sign\");\n        // If the input stre",
          "old_line_content": "    if (is_comma(input)) {",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is plus sign\");",
          "content_same": false
        },
        {
          "line": 1152,
          "old_api": "Comma);\n        token.m_representati",
          "new_api": "))) {\n            reconsume_cur",
          "old_text": "Comma);\n        token.m_representati",
          "new_text": "))) {\n            reconsume_cur",
          "old_line_content": "        Token token = create_new_token(Token::Type::Comma);",
          "new_line_content": "        if (would_start_a_number(start_of_input_stream_triplet())) {",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": ");\n        return token;\n    }",
          "new_api": "oint",
          "old_text": ");\n        return token;\n    }",
          "new_text": "oint();\n            return consume_a",
          "old_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "            reconsume_current_input_code_point();",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": "dbgln_if(CSS_TOKEN",
          "new_api": "));\n    }\n\n    // U+002C COMMA",
          "old_text": "    dbgln_if(CSS_TOKEN",
          "new_text": "));\n    }\n\n    // U+002C COMMA",
          "old_line_content": "    if (is_hyphen_minus(input)) {",
          "new_line_content": "        return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": "))) {\n            reconsume_cur",
          "new_api": "ln_if",
          "old_text": "))) {\n            reconsume_cur",
          "new_text": "ln_if(CSS_TOKEN",
          "old_line_content": "        if (would_start_a_number(start_of_input_stream_triplet())) {",
          "new_line_content": "    if (is_comma(input)) {",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": "oint",
          "new_api": "\"is comma\");\n        // Return a <comma-t",
          "old_text": "oint();\n            return consume_a",
          "new_text": "\"is comma\");\n        // Return a <comma-t",
          "old_line_content": "            reconsume_current_input_code_point();",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is comma\");",
          "content_same": false
        },
        {
          "line": 1171,
          "old_api": "(void)next_code_",
          "new_api": "dbgln_if(CSS_TOKEN",
          "old_text": " (void)next_code_",
          "new_text": "    dbgln_if(CSS_TOKEN",
          "old_line_content": "            (void)next_code_point();",
          "new_line_content": "    if (is_hyphen_minus(input)) {",
          "content_same": false
        },
        {
          "line": 1172,
          "old_api": "Token token = c",
          "new_api": "\"is hyphen minus\");\n        // If the input stre",
          "old_text": "  Token token = c",
          "new_text": "\"is hyphen minus\");\n        // If the input stre",
          "old_line_content": "            (void)next_code_point();",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is hyphen minus\");",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": ");\n            return token;",
          "new_api": "))) {\n            reconsume_cur",
          "old_text": ");\n            return token;\n ",
          "new_text": "))) {\n            reconsume_cur",
          "old_line_content": "            token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "        if (would_start_a_number(start_of_input_stream_triplet())) {",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": "oint",
          "new_api": "phen_minus",
          "old_text": "oint();\n            return consume_a",
          "new_text": "phen_minus(",
          "old_line_content": "            reconsume_current_input_code_point();",
          "new_line_content": "        auto next_twin = peek_twin();",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": "}\n\n        // Otherw",
          "new_api": ".second)) {\n            (void)next_cod",
          "old_text": "\n        }\n\n        // Otherw",
          "new_text": ".second)) {\n            (void)next_cod",
          "old_line_content": "            return consume_an_ident_like_token();",
          "new_line_content": "        if (is_hyphen_minus(next_twin.first) && is_greater_than_sign(next_twin.second)) {",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": "));\n    }\n\n    // U+002E FULL",
          "new_api": "CDC);\n            token.m_represen",
          "old_text": "));\n    }\n\n    // U+002E FULL ",
          "new_text": "CDC);\n            token.m_represen",
          "old_line_content": "        return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "new_line_content": "            Token token = create_new_token(Token::Type::CDC);",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": "))) {\n            reconsume_cur",
          "new_api": "oint",
          "old_text": "))) {\n            reconsume_cur",
          "new_text": "oint();\n            return consume_a",
          "old_line_content": "        if (would_start_a_number(start_of_input_stream_triplet())) {",
          "new_line_content": "            reconsume_current_input_code_point();",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": "oint",
          "new_api": "}\n\n        // Otherw",
          "old_text": "oint();\n            return consume_a",
          "new_text": "\n        }\n\n        // Otherw",
          "old_line_content": "            reconsume_current_input_code_point();",
          "new_line_content": "            return consume_an_ident_like_token();",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": "ln_if",
          "new_api": "\"is full stop\");\n        // If the input stre",
          "old_text": "ln_if(CSS_TOKEN",
          "new_text": "\"is full stop\");\n        // If the input stre",
          "old_line_content": "    if (is_colon(input)) {",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is full stop\");",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": "Colon);\n        token.m_representati",
          "new_api": "))) {\n            reconsume_cur",
          "old_text": "Colon);\n        token.m_representati",
          "new_text": "))) {\n            reconsume_cur",
          "old_line_content": "        Token token = create_new_token(Token::Type::Colon);",
          "new_line_content": "        if (would_start_a_number(start_of_input_stream_triplet())) {",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": ");\n        return token;\n    }",
          "new_api": "oint",
          "old_text": ");\n        return token;\n    }",
          "new_text": "oint();\n            return consume_a",
          "old_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "            reconsume_current_input_code_point();",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": "dbgln_if(CSS_TOKEN",
          "new_api": "));\n    }\n\n    // U+003A COLON",
          "old_text": " dbgln_if(CSS_TOKEN",
          "new_text": "));\n    }\n\n    // U+003A COLON",
          "old_line_content": "    if (is_semicolon(input)) {",
          "new_line_content": "        return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": ");\n        return token;\n    }",
          "new_api": "ln_if",
          "old_text": ");\n        return token;\n    }",
          "new_text": "ln_if(CSS_TOKEN",
          "old_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "    if (is_colon(input)) {",
          "content_same": false
        },
        {
          "line": 1227,
          "old_api": "_exclamation_m",
          "new_api": "dbgln_if(CSS_TOKEN",
          "old_text": "_exclamation_m",
          "new_text": " dbgln_if(CSS_TOKEN",
          "old_line_content": "        auto maybe_cdo = peek_triplet();",
          "new_line_content": "    if (is_semicolon(input)) {",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": "d)) {\n            (void)next_cod",
          "new_api": "\"is semicolon\");\n        // Return a <semicol",
          "old_text": "d)) {\n            (void)next_cod",
          "new_text": "\"is semicolon\");\n        // Return a <semicol",
          "old_line_content": "        if (is_exclamation_mark(maybe_cdo.first) && is_hyphen_minus(maybe_cdo.second) && is_hyphen_minus(maybe_cdo.third)) {",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is semicolon\");",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": "(void)next_code_",
          "new_api": "Semicolon);\n        token.m_representati",
          "old_text": " (void)next_code_",
          "new_text": "Semicolon);\n        token.m_representati",
          "old_line_content": "            (void)next_code_point();",
          "new_line_content": "        Token token = create_new_token(Token::Type::Semicolon);",
          "content_same": false
        },
        {
          "line": 1231,
          "old_api": "Token token = c",
          "new_api": ");\n        return token;\n    }",
          "old_text": "  Token token = c",
          "new_text": ");\n        return token;\n    }",
          "old_line_content": "            (void)next_code_point();",
          "new_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": "if",
          "new_api": "(void)next_code_",
          "old_text": "if(CSS_TOKEN",
          "new_text": " (void)next_code_",
          "old_line_content": "    if (is_at(input)) {",
          "new_line_content": "            (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": "\"is at\");\n        // If the next 3 inp",
          "new_api": "Token token = c",
          "old_text": "\"is at\");\n        // If the next 3 inp",
          "new_text": "  Token token = c",
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is at\");",
          "new_line_content": "            (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": "auto name = T",
          "new_api": ");\n            return token;",
          "old_text": " auto name = T",
          "new_text": ");\n            return token;\n ",
          "old_line_content": "        if (would_start_an_ident_sequence(peek_triplet())) {",
          "new_line_content": "            token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 1257,
          "old_api": "{\n        dbgln_if(CSS_TOKEN",
          "new_api": "\"is at\");\n        // If the next 3 inp",
          "old_text": " {\n        dbgln_if(CSS_TOKEN",
          "new_text": "\"is at\");\n        // If the next 3 inp",
          "old_line_content": "    if (is_open_square_bracket(input)) {",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is at\");",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": "OpenSquare);\n        token.m_representati",
          "new_api": "auto name = T",
          "old_text": "OpenSquare);\n        token.m_representati",
          "new_text": " auto name = T",
          "old_line_content": "        Token token = create_new_token(Token::Type::OpenSquare);",
          "new_line_content": "        if (would_start_an_ident_sequence(peek_triplet())) {",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": ");\n        return token;\n    }",
          "new_api": "return create_v",
          "old_text": ");\n        return token;\n    }",
          "new_text": "            return create_v",
          "old_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "            auto name = TRY(consume_an_ident_sequence());",
          "content_same": false
        },
        {
          "line": 1266,
          "old_api": "dbgln_if(CSS_TOKEN",
          "new_api": "));\n    }\n\n    // U+005B LEFT",
          "old_text": "       dbgln_if(CSS_TOKEN",
          "new_text": "));\n    }\n\n    // U+005B LEFT ",
          "old_line_content": "    if (is_reverse_solidus(input)) {",
          "new_line_content": "        return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "content_same": false
        },
        {
          "line": 1270,
          "old_api": "{\n            reconsume_cur",
          "new_api": "{\n        dbgln_if(CSS_TOKEN",
          "old_text": " {\n            reconsume_cur",
          "new_text": " {\n        dbgln_if(CSS_TOKEN",
          "old_line_content": "        if (is_valid_escape_sequence(start_of_input_stream_twin())) {",
          "new_line_content": "    if (is_open_square_bracket(input)) {",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": "oint",
          "new_api": "\"is open square\");\n        // Return a <[-token",
          "old_text": "oint();\n            return consume_a",
          "new_text": "\"is open square\");\n        // Return a <[-token",
          "old_line_content": "            reconsume_current_input_code_point();",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is open square\");",
          "content_same": false
        },
        {
          "line": 1283,
          "old_api": "\"is closed square\");\n        // Return a <]-token",
          "new_api": "{\n            reconsume_cur",
          "old_text": "\"is closed square\");\n        // Return a <]-token",
          "new_text": " {\n            reconsume_cur",
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is closed square\");",
          "new_line_content": "        if (is_valid_escape_sequence(start_of_input_stream_twin())) {",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": "CloseSquare);\n        token.m_representati",
          "new_api": "}\n\n        // Otherw",
          "old_text": "CloseSquare);\n        token.m_representati",
          "new_text": "\n        }\n\n        // Otherw",
          "old_line_content": "        Token token = create_new_token(Token::Type::CloseSquare);",
          "new_line_content": "            return consume_an_ident_like_token();",
          "content_same": false
        },
        {
          "line": 1291,
          "old_api": "{\n        dbgln_if(CSS_TOKEN",
          "new_api": "));\n    }\n\n    // U+005D RIGHT",
          "old_text": "{\n        dbgln_if(CSS_TOKEN",
          "new_text": "));\n    }\n\n    // U+005D RIGHT",
          "old_line_content": "    if (is_open_curly_bracket(input)) {",
          "new_line_content": "        return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": ");\n        return token;\n    }",
          "new_api": ")) {\n        dbgln_if(CSS_TOKEN",
          "old_text": ");\n        return token;\n    }",
          "new_text": ")) {\n        dbgln_if(CSS_TOKEN",
          "old_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "    if (is_closed_square_bracket(input)) {",
          "content_same": false
        },
        {
          "line": 1304,
          "old_api": ");\n        return token;\n    }",
          "new_api": "{\n        dbgln_if(CSS_TOKEN",
          "old_text": ");\n        return token;\n    }",
          "new_text": "{\n        dbgln_if(CSS_TOKEN",
          "old_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "    if (is_open_curly_bracket(input)) {",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": "}\n\n    // name-start cod",
          "new_api": ") {\n        dbgln_if(CSS_TOKEN",
          "old_text": " }\n\n    // name-start cod",
          "new_text": ") {\n        dbgln_if(CSS_TOKEN",
          "old_line_content": "        return consume_a_numeric_token();",
          "new_line_content": "    if (is_closed_curly_bracket(input)) {",
          "content_same": false
        },
        {
          "line": 1317,
          "old_api": "t)) {\n        dbgln_if(CSS_TOKEN",
          "new_api": ");\n        return token;\n    }",
          "old_text": "t)) {\n        dbgln_if(CSS_TOKEN",
          "new_text": ");\n        return token;\n    }",
          "old_line_content": "    if (is_ident_start_code_point(input)) {",
          "new_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": "turn an <EOF-",
          "new_api": "oint",
          "old_text": "turn an <EOF-",
          "new_text": "oint();\n        return consume_a_num",
          "old_line_content": "    if (is_eof(input)) {",
          "new_line_content": "        reconsume_current_input_code_point();",
          "content_same": false
        },
        {
          "line": 1331,
          "old_api": "\"is delimiter\");\n    // Return a <delim-token",
          "new_api": "\"is name start\");\n        // Reconsume the cur",
          "old_text": "\"is delimiter\");\n    // Return a <delim-token",
          "new_text": "\"is name start\");\n        // Reconsume the cur",
          "old_line_content": "    dbgln_if(CSS_TOKENIZER_DEBUG, \"is delimiter\");",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is name start\");",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": "));\n}\n\nsize_t Tokenizer::curre",
          "new_api": "oint",
          "old_text": "));\n}\n\nsize_t Tokenizer::curre",
          "new_text": "oint();\n        return consume_an_id",
          "old_line_content": "    return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "new_line_content": "        reconsume_current_input_code_point();",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": "r<String> Tokenizer",
          "new_api": "turn an <EOF-",
          "old_text": "r<String> Tokenizer",
          "new_text": "turn an <EOF-",
          "old_line_content": "    return m_utf8_iterator.ptr() - m_utf8_view.bytes();",
          "new_line_content": "    if (is_eof(input)) {",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 512,
          "old_api": null,
          "new_api": "minus",
          "old_text": null,
          "new_text": "minus(next_input)) {\n      ",
          "old_line_content": "",
          "new_line_content": "    if (is_plus_sign(next_input) || is_hyphen_minus(next_input)) {",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": null,
          "new_api": "igit",
          "old_text": null,
          "new_text": "igit(digits))\n        ",
          "old_line_content": "",
          "new_line_content": "        if (!is_ascii_digit(digits))",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": null,
          "new_api": "point",
          "old_text": null,
          "new_text": "point());\n    }\n\n",
          "old_line_content": "",
          "new_line_content": "        repr.append_code_point(next_code_point());",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": null,
          "new_api": "solidus",
          "old_text": null,
          "new_text": "solidus(twi",
          "old_line_content": "",
          "new_line_content": "    auto twin = peek_twin();",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": null,
          "new_api": "igit",
          "old_text": null,
          "new_text": "igit(maybe_number.second)) {\n      ",
          "old_line_content": "                break;",
          "new_line_content": "    if (is_full_stop(maybe_number.first) && is_ascii_digit(maybe_number.second)) {",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": null,
          "new_api": "id)next_code_poin",
          "old_text": null,
          "new_text": "id)next_code_poin",
          "old_line_content": "            goto start;",
          "new_line_content": "    (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": null,
          "new_api": "r (;;) {",
          "old_text": null,
          "new_text": "r (;;) {\n        ",
          "old_line_content": "        }",
          "new_line_content": "    (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": null,
          "new_api": "point",
          "old_text": null,
          "new_text": "point());\n       ",
          "old_line_content": "        }",
          "new_line_content": "        repr.append_code_point(next_code_point());",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": null,
          "new_api": "point",
          "old_text": null,
          "new_text": "point());\n\n      ",
          "old_line_content": "    }",
          "new_line_content": "        repr.append_code_point(next_code_point());",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": null,
          "new_api": "s_eof",
          "old_text": null,
          "new_text": "s_eof(twin_",
          "old_line_content": "    }",
          "new_line_content": "        auto twin_inner = peek_twin();",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": null,
          "new_api": "{\n            log_parse_",
          "old_text": null,
          "new_text": " {\n            log_parse_",
          "old_line_content": "}",
          "new_line_content": "        if (is_eof(twin_inner.first) || is_eof(twin_inner.second)) {",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": null,
          "new_api": "return;",
          "old_text": null,
          "new_text": "     return;\n    ",
          "old_line_content": "",
          "new_line_content": "            log_parse_error();",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": null,
          "new_api": "nd)) {\n            (void)next",
          "old_text": null,
          "new_text": "nd)) {\n            (void)next",
          "old_line_content": "    // This section describes how to consume a token from a stream of code points.",
          "new_line_content": "        if (is_asterisk(twin_inner.first) && is_solidus(twin_inner.second)) {",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": null,
          "new_api": "(void)next_c",
          "old_text": null,
          "new_text": "     (void)next_c",
          "old_line_content": "    // It will return a single token of any type.",
          "new_line_content": "            (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 1053,
          "old_api": null,
          "new_api": "goto start;",
          "old_text": null,
          "new_text": "     goto start;\n",
          "old_line_content": "",
          "new_line_content": "            (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": null,
          "new_api": "// https://www.",
          "old_text": null,
          "new_text": "\n\n// https://www.",
          "old_line_content": "    // Consume the next input code point.",
          "new_line_content": "        (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": null,
          "new_api": "igit",
          "old_text": null,
          "new_text": "igit(maybe_exp.third))\n        ",
          "old_line_content": "        }",
          "new_line_content": "        && (((is_plus_sign(maybe_exp.second) || is_hyphen_minus(maybe_exp.second)) && is_ascii_digit(maybe_exp.third))",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": null,
          "new_api": "igit",
          "old_text": null,
          "new_text": "igit(maybe_exp.second)))) {\n    ",
          "old_line_content": "",
          "new_line_content": "            || (is_ascii_digit(maybe_exp.second)))) {",
          "content_same": false
        },
        {
          "line": 556,
          "old_api": null,
          "new_api": "minus",
          "old_text": null,
          "new_text": "minus(maybe_exp.second)) {\n      ",
          "old_line_content": "",
          "new_line_content": "        if (is_plus_sign(maybe_exp.second) || is_hyphen_minus(maybe_exp.second)) {",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": null,
          "new_api": "igit",
          "old_text": null,
          "new_text": "igit(maybe_exp.third)) {\n      ",
          "old_line_content": "        // 4. While the next input code point is a digit, consume it and append it to repr.",
          "new_line_content": "            if (is_ascii_digit(maybe_exp.third)) {",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": null,
          "new_api": "point",
          "old_text": null,
          "new_text": "point());\n       ",
          "old_line_content": "        for (;;) {",
          "new_line_content": "                repr.append_code_point(next_code_point());",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": null,
          "new_api": "/ Consume the next",
          "old_text": null,
          "new_text": "/ Consume the next",
          "old_line_content": "        return token;",
          "new_line_content": "    consume_comments();",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": null,
          "new_api": "auto input = next_co",
          "old_text": null,
          "new_text": " auto input = next_co",
          "old_line_content": "    // U+0022 QUOTATION MARK (\")",
          "new_line_content": "    auto start_byte_offset = current_byte_offset();",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": null,
          "new_api": "igit",
          "old_text": null,
          "new_text": "igit(maybe_exp.second)) {\n      ",
          "old_line_content": "",
          "new_line_content": "        } else if (is_ascii_digit(maybe_exp.second)) {",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": null,
          "new_api": "point",
          "old_text": null,
          "new_text": "point());\n       ",
          "old_line_content": "        }",
          "new_line_content": "            repr.append_code_point(next_code_point());",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": null,
          "new_api": "UG, \"is whitespace\");\n        // Consume as mu",
          "old_text": null,
          "new_text": "UG, \"is whitespace\");\n        // Consume as mu",
          "old_line_content": "    }",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is whitespace\");",
          "content_same": false
        },
        {
          "line": 1078,
          "old_api": null,
          "new_api": "_as_possible",
          "old_text": null,
          "new_text": "_as_possible();\n        auto token = cre",
          "old_line_content": "    // U+0023 NUMBER SIGN (#)",
          "new_line_content": "        consume_as_much_whitespace_as_possible();",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "point",
          "old_text": null,
          "new_text": "point();\n        ",
          "old_line_content": "        return Number { Number::Type::IntegerWithExplicitSign, value };",
          "new_line_content": "            auto digits = peek_code_point();",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": null,
          "new_api": "igit",
          "old_text": null,
          "new_text": "igit(digits))\n        ",
          "old_line_content": "    return Number { type, value };",
          "new_line_content": "            if (!is_ascii_digit(digits))",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": null,
          "new_api": "UG, \"is quotation mark\");\n        // Consume a str",
          "old_text": null,
          "new_text": "UG, \"is quotation mark\");\n        // Consume a str",
          "old_line_content": "",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is quotation mark\");",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": null,
          "new_api": "point",
          "old_text": null,
          "new_text": "point());\n       ",
          "old_line_content": "// https://www.w3.org/TR/css-syntax-3/#convert-string-to-number",
          "new_line_content": "            repr.append_code_point(next_code_point());",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": null,
          "new_api": ");\n    }\n\n    // U+0023 NUM",
          "old_text": null,
          "new_text": ");\n    }\n\n    // U+0023 NUM",
          "old_line_content": "            // 1. Create a <hash-token>.",
          "new_line_content": "        return consume_string_token(input);",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": null,
          "new_api": "dbgln_if(CSS_T",
          "old_text": null,
          "new_text": "       dbgln_if(CSS_T",
          "old_line_content": "            //    type flag to \"id\".",
          "new_line_content": "    if (is_number_sign(input)) {",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": null,
          "new_api": "aybe_escape)) {\n            // 1. Crea",
          "old_text": null,
          "new_text": "aybe_escape)) {\n            // 1. Crea",
          "old_line_content": "            // 4. Return the <hash-token>.",
          "new_line_content": "        if (is_ident_code_point(next_input) || is_valid_escape_sequence(maybe_escape)) {",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": null,
          "new_api": "pe::Hash);\n\n            // 2. If th",
          "old_text": null,
          "new_text": "pe::Hash);\n\n            // 2. If th",
          "old_line_content": "            return token;",
          "new_line_content": "            auto token = create_new_token(Token::Type::Hash);",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": null,
          "new_api": "release_value",
          "old_text": null,
          "new_text": "number<double>(AK::TrimWhitespace::No).release_value();\n}\n\n// ht",
          "old_line_content": "    // calling this algorithm.",
          "new_line_content": "    return string.to_number<double>(AK::TrimWhitespace::No).release_value();",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": null,
          "new_api": ");\n            return token;",
          "old_text": null,
          "new_text": ");\n            return token;\n ",
          "old_line_content": "    }",
          "new_line_content": "            token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": null,
          "new_api": "));\n    }\n\n    // U+0027 APOST",
          "old_text": null,
          "new_text": "));\n    }\n\n    // U+0027 APOST",
          "old_line_content": "        // Return a <(-token>.",
          "new_line_content": "        return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "content_same": false
        },
        {
          "line": 1123,
          "old_api": null,
          "new_api": "dbgln_if(CSS_TOKEN",
          "old_text": null,
          "new_text": "  dbgln_if(CSS_TOKEN",
          "old_line_content": "    }",
          "new_line_content": "    if (is_apostrophe(input)) {",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": null,
          "new_api": "\"is apostrophe\");\n        // Consume a string",
          "old_text": null,
          "new_text": "\"is apostrophe\");\n        // Consume a string ",
          "old_line_content": "",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is apostrophe\");",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": null,
          "new_api": "\"is left paren\");\n        // Return a <(-token",
          "old_text": null,
          "new_text": "\"is left paren\");\n        // Return a <(-token",
          "old_line_content": "        return token;",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is left paren\");",
          "content_same": false
        },
        {
          "line": 620,
          "old_api": null,
          "new_api": "ode_point",
          "old_text": null,
          "new_text": "ode_point(input)) {\n      ",
          "old_line_content": "        // anything else",
          "new_line_content": "        if (is_ident_code_point(input)) {",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": null,
          "new_api": "OpenParen);\n        token.m_representati",
          "old_text": null,
          "new_text": "OpenParen);\n        token.m_representati",
          "old_line_content": "",
          "new_line_content": "        Token token = create_new_token(Token::Type::OpenParen);",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": null,
          "new_api": ");\n        return token;\n    }",
          "old_text": null,
          "new_text": ");\n        return token;\n    }",
          "old_line_content": "    // U+002B PLUS SIGN (+)",
          "new_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": null,
          "new_api": "nput_stream_twin",
          "old_text": null,
          "new_text": "nput_stream_twin())) {\n     ",
          "old_line_content": "}",
          "new_line_content": "        if (is_valid_escape_sequence(start_of_input_stream_twin())) {",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": null,
          "new_api": "caped_code_point",
          "old_text": null,
          "new_text": "caped_code_point()));\n      ",
          "old_line_content": "// https://www.w3.org/TR/css-syntax-3/#consume-url-token",
          "new_line_content": "            TRY(result.try_append_code_point(consume_escaped_code_point()));",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": null,
          "new_api": "CloseParen);\n        token.m_representati",
          "old_text": null,
          "new_text": "CloseParen);\n        token.m_representati",
          "old_line_content": "        }",
          "new_line_content": "        Token token = create_new_token(Token::Type::CloseParen);",
          "content_same": false
        },
        {
          "line": 1143,
          "old_api": null,
          "new_api": ");\n        return token;\n    }",
          "old_text": null,
          "new_text": ");\n        return token;\n    }",
          "old_line_content": "",
          "new_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": null,
          "new_api": "current_input_code_point",
          "old_text": null,
          "new_text": "current_input_code_point();\n        ",
          "old_line_content": "    // Note: This algorithm assumes that the initial \"url(\" has already been consumed.",
          "new_line_content": "        reconsume_current_input_code_point();",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": null,
          "new_api": "dbgln_if(CSS_TOKEN",
          "old_text": null,
          "new_text": " dbgln_if(CSS_TOKEN",
          "old_line_content": "    // U+002C COMMA (,)",
          "new_line_content": "    if (is_plus_sign(input)) {",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": null,
          "new_api": "fly_string_without_validation",
          "old_text": null,
          "new_text": "fly_string_without_validation();\n}\n\n// ht",
          "old_line_content": "    // shouldnât be called directly otherwise.",
          "new_line_content": "    return result.to_fly_string_without_validation();",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": null,
          "new_api": "}\n\n        // Otherw",
          "old_text": null,
          "new_text": "     }\n\n        // Otherw",
          "old_line_content": "        return token;",
          "new_line_content": "            return consume_a_numeric_token();",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": null,
          "new_api": "Comma);\n        token.m_representati",
          "old_text": null,
          "new_text": "Comma);\n        token.m_representati",
          "old_line_content": "        }",
          "new_line_content": "        Token token = create_new_token(Token::Type::Comma);",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": null,
          "new_api": ");\n        return token;\n    }",
          "old_text": null,
          "new_text": ");\n        return token;\n    }",
          "old_line_content": "",
          "new_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": null,
          "new_api": "ffset",
          "old_text": null,
          "new_text": "ffset();\n    auto tok",
          "old_line_content": "    // 3. Repeatedly consume the next input code point from the stream:",
          "new_line_content": "    auto start_byte_offset = current_byte_offset();",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": null,
          "new_api": "en",
          "old_text": null,
          "new_text": "en(Token::Type::Url);\n    StringBu",
          "old_line_content": "    for (;;) {",
          "new_line_content": "    auto token = create_new_token(Token::Type::Url);",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": null,
          "new_api": "_view",
          "old_text": null,
          "new_text": "_view()));\n        to",
          "old_line_content": "        }",
          "new_line_content": "        token.m_value = TRY(FlyString::from_utf8(builder.string_view()));",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "art_byte_offset));\n        ret",
          "old_text": null,
          "new_text": "art_byte_offset));\n        ret",
          "old_line_content": "",
          "new_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "oint",
          "old_text": null,
          "new_text": "oint();\n            return consume_a",
          "old_line_content": "            return token;",
          "new_line_content": "            reconsume_current_input_code_point();",
          "content_same": false
        },
        {
          "line": 1177,
          "old_api": null,
          "new_api": "}\n\n        // Otherw",
          "old_text": null,
          "new_text": "     }\n\n        // Otherw",
          "old_line_content": "        }",
          "new_line_content": "            return consume_a_numeric_token();",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": null,
          "new_api": "t",
          "old_text": null,
          "new_text": "t();\n\n        // ",
          "old_line_content": "        }",
          "new_line_content": "        auto input = next_code_point();",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": null,
          "new_api": "(void)next_code_",
          "old_text": null,
          "new_text": " (void)next_code_",
          "old_line_content": "        }",
          "new_line_content": "            (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": null,
          "new_api": "Token token = c",
          "old_text": null,
          "new_text": "  Token token = c",
          "old_line_content": "",
          "new_line_content": "            (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": null,
          "new_api": ");\n            return token;",
          "old_text": null,
          "new_text": ");\n            return token;\n ",
          "old_line_content": "    }",
          "new_line_content": "            token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": null,
          "new_api": "))) {\n            reconsume_cur",
          "old_text": null,
          "new_text": "))) {\n            reconsume_cur",
          "old_line_content": "        // consume a numeric token, and return it.",
          "new_line_content": "        if (would_start_an_ident_sequence(start_of_input_stream_triplet())) {",
          "content_same": false
        },
        {
          "line": 1200,
          "old_api": null,
          "new_api": "));\n    }\n\n    // U+002E FULL",
          "old_text": null,
          "new_text": "));\n    }\n\n    // U+002E FULL ",
          "old_line_content": "        // Otherwise, return a <delim-token> with its value set to the current input code point.",
          "new_line_content": "        return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": null,
          "new_api": "t",
          "old_text": null,
          "new_text": "t();\n\n           ",
          "old_line_content": "            // otherwise, consume the remnants of a bad url, create a <bad-url-token>, and return it.",
          "new_line_content": "            input = peek_code_point();",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": null,
          "new_api": "dbgln_if(CSS_TOKEN",
          "old_text": null,
          "new_text": " dbgln_if(CSS_TOKEN",
          "old_line_content": "    // U+003A COLON (:)",
          "new_line_content": "    if (is_full_stop(input)) {",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "            ",
          "old_line_content": "            return bad_url_token;",
          "new_line_content": "                return make_token();",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": null,
          "new_api": "}\n\n        // Otherw",
          "old_text": null,
          "new_text": "     }\n\n        // Otherw",
          "old_line_content": "        return token;",
          "new_line_content": "            return consume_a_numeric_token();",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": null,
          "new_api": "{",
          "old_text": null,
          "new_text": " {\n          ",
          "old_line_content": "        // U+0022 QUOTATION MARK (\")",
          "new_line_content": "            if (is_eof(input)) {",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": null,
          "new_api": "t",
          "old_text": null,
          "new_text": "t();\n            ",
          "old_line_content": "        // U+0027 APOSTROPHE (')",
          "new_line_content": "                (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": null,
          "new_api": "r",
          "old_text": null,
          "new_text": "r();\n            ",
          "old_line_content": "        // U+0028 LEFT PARENTHESIS (()",
          "new_line_content": "                log_parse_error();",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "            ",
          "old_line_content": "        // non-printable code point",
          "new_line_content": "                return make_token();",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": null,
          "new_api": "\"is colon\");\n        // Return a <colon-t",
          "old_text": null,
          "new_text": "\"is colon\");\n        // Return a <colon-t",
          "old_line_content": "        return token;",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is colon\");",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": null,
          "new_api": "Colon);\n        token.m_representati",
          "old_text": null,
          "new_text": "Colon);\n        token.m_representati",
          "old_line_content": "",
          "new_line_content": "        Token token = create_new_token(Token::Type::Colon);",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": null,
          "new_api": ");\n        return token;\n    }",
          "old_text": null,
          "new_text": ");\n        return token;\n    }",
          "old_line_content": "    // U+003C LESS-THAN SIGN (<)",
          "new_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": null,
          "new_api": "le",
          "old_text": null,
          "new_text": "le(input)) {\n          ",
          "old_line_content": "                // consume an escaped code point and append the returned code point to the <url-token>âs value.",
          "new_line_content": "        if (is_quotation_mark(input) || is_apostrophe(input) || is_left_paren(input) || is_non_printable(input)) {",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": null,
          "new_api": "r",
          "old_text": null,
          "new_text": "r();\n            ",
          "old_line_content": "                continue;",
          "new_line_content": "            log_parse_error();",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": null,
          "new_api": "mnants_of_a_bad_url",
          "old_text": null,
          "new_text": "mnants_of_a_bad_url();\n            ",
          "old_line_content": "            } else {",
          "new_line_content": "            consume_the_remnants_of_a_bad_url();",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": null,
          "new_api": "bytes",
          "old_text": null,
          "new_text": "] {\n            for (auto byte : decoded_input.bytes()) {\n                if (byte == '\\r' || byte == '\\f')\n                    return true;\n            }\n            return false;\n        }();\n",
          "old_line_content": "        // To filter code points from a stream of (unfiltered) code points input:",
          "new_line_content": "        bool const contains_cr_or_ff = [&] {",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": null,
          "new_api": "en",
          "old_text": null,
          "new_text": "en(Token::Type::BadUrl);\n            ",
          "old_line_content": "                // Otherwise, this is a parse error.",
          "new_line_content": "            auto bad_url_token = create_new_token(Token::Type::BadUrl);",
          "content_same": false
        },
        {
          "line": 1236,
          "old_api": null,
          "new_api": "dbgln_if(CSS_TOKEN",
          "old_text": null,
          "new_text": "      dbgln_if(CSS_TOKEN",
          "old_line_content": "        }",
          "new_line_content": "    if (is_less_than_sign(input)) {",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": null,
          "new_api": "\"is less than\");\n        // If the next 3 inp",
          "old_text": null,
          "new_text": "\"is less than\");\n        // If the next 3 inp",
          "old_line_content": "",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is less than\");",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": null,
          "new_api": "idus",
          "old_text": null,
          "new_text": "idus(input)) {\n          ",
          "old_line_content": "                return bad_url_token;",
          "new_line_content": "        if (is_reverse_solidus(input)) {",
          "content_same": false
        },
        {
          "line": 728,
          "old_api": null,
          "new_api": "_stream_twin",
          "old_text": null,
          "new_text": "_stream_twin())) {\n         ",
          "old_line_content": "        }",
          "new_line_content": "            if (is_valid_escape_sequence(start_of_input_stream_twin())) {",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": null,
          "new_api": "_exclamation_m",
          "old_text": null,
          "new_text": "_exclamation_m",
          "old_line_content": "    }",
          "new_line_content": "        auto maybe_cdo = peek_triplet();",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": null,
          "new_api": "code_point",
          "old_text": null,
          "new_text": "code_point());\n             ",
          "old_line_content": "        // anything else",
          "new_line_content": "                builder.append_code_point(consume_escaped_code_point());",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "put.length() }",
          "old_line_content": "                }",
          "new_line_content": "        StringBuilder builder { input.length() };",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": null,
          "new_api": "d)) {\n            (void)next_cod",
          "old_text": null,
          "new_text": "d)) {\n            (void)next_cod",
          "old_line_content": "",
          "new_line_content": "        if (is_exclamation_mark(maybe_cdo.first) && is_hyphen_minus(maybe_cdo.second) && is_hyphen_minus(maybe_cdo.third)) {",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": null,
          "new_api": "(void)next_code_",
          "old_text": null,
          "new_text": " (void)next_code_",
          "old_line_content": "    // U+0040 COMMERCIAL AT (@)",
          "new_line_content": "            (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": null,
          "new_api": ");",
          "old_text": null,
          "new_text": ");\n              ",
          "old_line_content": "}",
          "new_line_content": "                log_parse_error();",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": null,
          "new_api": "code_points",
          "old_text": null,
          "new_text": "coded_input.code_points()) ",
          "old_line_content": "",
          "new_line_content": "        for (auto code_point : decoded_input.code_points()) {",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": null,
          "new_api": "ants_of_a_bad_url",
          "old_text": null,
          "new_text": "ants_of_a_bad_url();\n              ",
          "old_line_content": "// https://www.w3.org/TR/css-syntax-3/#consume-remnants-of-bad-url",
          "new_line_content": "                consume_the_remnants_of_a_bad_url();",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": null,
          "new_api": "(Token::Type::BadUrl);",
          "old_text": null,
          "new_text": "(Token::Type::BadUrl);\n              ",
          "old_line_content": "void Tokenizer::consume_the_remnants_of_a_bad_url()",
          "new_line_content": "                auto bad_url_token = create_new_token(Token::Type::BadUrl);",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": null,
          "new_api": "t_byte_offset));",
          "old_text": null,
          "new_text": "t_byte_offset));\n             ",
          "old_line_content": "{",
          "new_line_content": "                bad_url_token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": null,
          "new_api": "CDO);\n            token.m_represen",
          "old_text": null,
          "new_text": "CDO);\n            token.m_represen",
          "old_line_content": "        // an <at-keyword-token> with its value set to the returned value, and return it.",
          "new_line_content": "            Token token = create_new_token(Token::Type::CDO);",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": null,
          "new_api": "));\n    }\n\n    // U+0040 COMME",
          "old_text": null,
          "new_text": "));\n    }\n\n    // U+0040 COMME",
          "old_line_content": "        // Otherwise, return a <delim-token> with its value set to the current input code point.",
          "new_line_content": "        return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": null,
          "new_api": "try_append",
          "old_text": null,
          "new_text": "ilder.try_append('\\n'));",
          "old_line_content": "                    // Replace any U+0000 NULL or surrogate code points in input with U+FFFD REPLACEMENT CHARACTER (ï¿½).",
          "new_line_content": "                    TRY(builder.try_append('\\n'));",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": null,
          "new_api": "if",
          "old_text": null,
          "new_text": "if(CSS_TOKEN",
          "old_line_content": "    // U+005B LEFT SQUARE BRACKET ([)",
          "new_line_content": "    if (is_at(input)) {",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "e_point",
          "old_text": null,
          "new_text": "e_point(input);\n    }\n}\n\n// http",
          "old_line_content": "    for (;;) {",
          "new_line_content": "        builder.append_code_point(input);",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": null,
          "new_api": "try_append",
          "old_text": null,
          "new_text": "ilder.try_append('\\n'));",
          "old_line_content": "",
          "new_line_content": "                    TRY(builder.try_append('\\n'));",
          "content_same": false
        },
        {
          "line": 1262,
          "old_api": null,
          "new_api": "));\n        }\n\n        // Othe",
          "old_text": null,
          "new_text": "));\n        }\n\n        // Othe",
          "old_line_content": "        return token;",
          "new_line_content": "            return create_value_token(Token::Type::AtKeyword, move(name), TRY(input_since(start_byte_offset)));",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": null,
          "new_api": "try_append",
          "old_text": null,
          "new_text": "ilder.try_append('\\n'));",
          "old_line_content": "        }));",
          "new_line_content": "                        TRY(builder.try_append('\\n'));",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": null,
          "new_api": "try_append",
          "old_text": null,
          "new_text": "ilder.try_append('\\n'));",
          "old_line_content": "",
          "new_line_content": "                    TRY(builder.try_append('\\n'));",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": null,
          "new_api": "try_append_code_point",
          "old_text": null,
          "new_text": "der.try_append_code_point(REPLACEMENT_CHARACTER));\n ",
          "old_line_content": "}",
          "new_line_content": "                    TRY(builder.try_append_code_point(REPLACEMENT_CHARACTER));",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": null,
          "new_api": "// U+0029",
          "old_text": null,
          "new_text": "        // U+0029",
          "old_line_content": "            // the <bad-url-token>. This is otherwise identical to the \"anything else\" clause.",
          "new_line_content": "        auto input = next_code_point();",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": null,
          "new_api": "try_append_code_point",
          "old_text": null,
          "new_text": "der.try_append_code_point(code_point));\n ",
          "old_line_content": "Tokenizer::Tokenizer(String decoded_input)",
          "new_line_content": "                    TRY(builder.try_append_code_point(code_point));",
          "content_same": false
        },
        {
          "line": 1273,
          "old_api": null,
          "new_api": "OpenSquare);\n        token.m_representati",
          "old_text": null,
          "new_text": "OpenSquare);\n        token.m_representati",
          "old_line_content": "        }",
          "new_line_content": "        Token token = create_new_token(Token::Type::OpenSquare);",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": null,
          "new_api": ");\n        return token;\n    }",
          "old_text": null,
          "new_text": ");\n        return token;\n    }",
          "old_line_content": "",
          "new_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": null,
          "new_api": ")) {\n            // R",
          "old_text": null,
          "new_text": ")) {\n            // R",
          "old_line_content": "        // anything else",
          "new_line_content": "        if (is_eof(input) || is_right_paren(input)) {",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": null,
          "new_api": "to_string_without_validation",
          "old_text": null,
          "new_text": "der.to_string_without_validation();\n  ",
          "old_line_content": "",
          "new_line_content": "        return builder.to_string_without_validation();",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": null,
          "new_api": "dbgln_if(CSS_TOKEN",
          "old_text": null,
          "new_text": "       dbgln_if(CSS_TOKEN",
          "old_line_content": "    }",
          "new_line_content": "    if (is_reverse_solidus(input)) {",
          "content_same": false
        },
        {
          "line": 1280,
          "old_api": null,
          "new_api": "\"is reverse solidus\");\n        // If the input stre",
          "old_text": null,
          "new_text": "\"is reverse solidus\");\n        // If the input stre",
          "old_line_content": "",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is reverse solidus\");",
          "content_same": false
        },
        {
          "line": 257,
          "old_api": null,
          "new_api": "er_code_points",
          "old_text": null,
          "new_text": "er_code_points(input, encoding)) };",
          "old_line_content": "    Vector<Token> tokens;",
          "new_line_content": "    Tokenizer tokenizer { TRY(filter_code_points(input, encoding)) };",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": null,
          "new_api": "tokenize",
          "old_text": null,
          "new_text": "nizer.tokenize();\n}\n",
          "old_line_content": "    for (;;) {",
          "new_line_content": "    return tokenizer.tokenize();",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": null,
          "new_api": "m_twin",
          "old_text": null,
          "new_text": "m_twin())) {\n            // ",
          "old_line_content": "{",
          "new_line_content": "        if (is_valid_escape_sequence(start_of_input_stream_twin())) {",
          "content_same": false
        },
        {
          "line": 1284,
          "old_api": null,
          "new_api": "oint",
          "old_text": null,
          "new_text": "oint();\n            return consume_a",
          "old_line_content": "        // Return a <]-token>.",
          "new_line_content": "            reconsume_current_input_code_point();",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": null,
          "new_api": "_point",
          "old_text": null,
          "new_text": "_point();\n        }\n\n       ",
          "old_line_content": "}",
          "new_line_content": "            (void)consume_escaped_code_point();",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": null,
          "new_api": "(decoded_input))",
          "old_text": null,
          "new_text": "(decoded_input))\n  ",
          "old_line_content": "        token.m_end_position = m_position;",
          "new_line_content": "    : m_decoded_input(move(decoded_input))",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "f8_view.begin())\n{\n",
          "old_line_content": "",
          "new_line_content": "    , m_utf8_iterator(m_utf8_view.begin())",
          "content_same": false
        },
        {
          "line": 1290,
          "old_api": null,
          "new_api": "urn create_value_",
          "old_text": null,
          "new_text": "urn create_value_",
          "old_line_content": "    // U+007B LEFT CURLY BRACKET ({)",
          "new_line_content": "        log_parse_error();",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": null,
          "new_api": "{\n        (void)n",
          "old_text": null,
          "new_text": "{\n        (void)n",
          "old_line_content": "{",
          "new_line_content": "    while (is_whitespace(peek_code_point())) {",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": null,
          "new_api": "}\n}\n\nvoid Toke",
          "old_text": null,
          "new_text": "   }\n}\n\nvoid Toke",
          "old_line_content": "    // This section describes how to consume a numeric token from a stream of code points.",
          "new_line_content": "        (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": null,
          "new_api": "\"is closed square\");\n        // Return a <]-token",
          "old_text": null,
          "new_text": "\"is closed square\");\n        // Return a <]-token",
          "old_line_content": "        return token;",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is closed square\");",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": null,
          "new_api": "CloseSquare);\n        token.m_representati",
          "old_text": null,
          "new_text": "CloseSquare);\n        token.m_representati",
          "old_line_content": "",
          "new_line_content": "        Token token = create_new_token(Token::Type::CloseSquare);",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": null,
          "new_api": ");\n        return token;\n    }",
          "old_text": null,
          "new_text": ");\n        return token;\n    }",
          "old_line_content": "    // U+007D RIGHT CURLY BRACKET (})",
          "new_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": null,
          "new_api": "try_append",
          "old_text": null,
          "new_text": "ns.try_append(token));\n\n",
          "old_line_content": "    ++m_utf8_iterator;",
          "new_line_content": "        TRY(tokens.try_append(token));",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": null,
          "new_api": "is",
          "old_text": null,
          "new_text": "n.is(Token::Type::EndOfFile)) {\n",
          "old_line_content": "",
          "new_line_content": "        if (token.is(Token::Type::EndOfFile)) {",
          "content_same": false
        },
        {
          "line": 1305,
          "old_api": null,
          "new_api": "\"is open curly\");\n        // Return a <{-token",
          "old_text": null,
          "new_text": "\"is open curly\");\n        // Return a <{-token",
          "old_line_content": "        return token;",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is open curly\");",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": null,
          "new_api": "OpenCurly);\n        token.m_representati",
          "old_text": null,
          "new_text": "OpenCurly);\n        token.m_representati",
          "old_line_content": "",
          "new_line_content": "        Token token = create_new_token(Token::Type::OpenCurly);",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": null,
          "new_api": ");\n        return token;\n    }",
          "old_text": null,
          "new_text": ");\n        return token;\n    }",
          "old_line_content": "    // digit",
          "new_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "f8_view.end())\n  ",
          "old_line_content": "",
          "new_line_content": "    if (m_utf8_iterator == m_utf8_view.end())",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": null,
          "new_api": "\"is closed curly\");\n        // Return a <}-token",
          "old_text": null,
          "new_text": "\"is closed curly\");\n        // Return a <}-token",
          "old_line_content": "    }",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is closed curly\");",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": null,
          "new_api": "CloseCurly);\n        token.m_representati",
          "old_text": null,
          "new_text": "CloseCurly);\n        token.m_representati",
          "old_line_content": "    // name-start code point",
          "new_line_content": "        Token token = create_new_token(Token::Type::CloseCurly);",
          "content_same": false
        },
        {
          "line": 293,
          "old_api": null,
          "new_api": "ewline",
          "old_text": null,
          "new_text": "ewline(code_point)) {\n",
          "old_line_content": "    auto it = m_utf8_iterator;",
          "new_line_content": "    if (is_newline(code_point)) {",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": null,
          "new_api": "en::Type::Dimension);\n        token.m_nu",
          "old_text": null,
          "new_text": "en::Type::Dimension);\n        token.m_nu",
          "old_line_content": "",
          "new_line_content": "        auto token = create_new_token(Token::Type::Dimension);",
          "content_same": false
        },
        {
          "line": 1322,
          "old_api": null,
          "new_api": "dbgln_if(CSS_TOKEN",
          "old_text": null,
          "new_text": "   dbgln_if(CSS_TOKEN",
          "old_line_content": "    }",
          "new_line_content": "    if (is_ascii_digit(input)) {",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": null,
          "new_api": "\"is digit\");\n        // Reconsume the cur",
          "old_text": null,
          "new_text": "\"is digit\");\n        // Reconsume the cur",
          "old_line_content": "",
          "new_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is digit\");",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": null,
          "new_api": "n_if",
          "old_text": null,
          "new_text": "n_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Next code_point: {:d}\", code_point);\n  ",
          "old_line_content": "}",
          "new_line_content": "    dbgln_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Next code_point: {:d}\", code_point);",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": null,
          "new_api": "nce",
          "old_text": null,
          "new_text": "nce());\n        VERIFY(!uni",
          "old_line_content": "",
          "new_line_content": "        auto unit = TRY(consume_an_ident_sequence());",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": null,
          "new_api": "// NOTE: We",
          "old_text": null,
          "new_text": "    // NOTE: We",
          "old_line_content": "        // Create a <percentage-token> with the same value as number, and return it.",
          "new_line_content": "        VERIFY(!unit.is_empty());",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": null,
          "new_api": "}\n\n    // name-start cod",
          "old_text": null,
          "new_text": " }\n\n    // name-start cod",
          "old_line_content": "        // Return an <EOF-token>.",
          "new_line_content": "        return consume_a_numeric_token();",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "/ 3. Retur",
          "old_text": null,
          "new_text": "/ 3. Retur",
          "old_line_content": "        token.m_number_value = number;",
          "new_line_content": "        token.m_value = move(unit);",
          "content_same": false
        },
        {
          "line": 1330,
          "old_api": null,
          "new_api": "t)) {\n        dbgln_if(CSS_TOKEN",
          "old_text": null,
          "new_text": "t)) {\n        dbgln_if(CSS_TOKEN",
          "old_line_content": "    // anything else",
          "new_line_content": "    if (is_ident_start_code_point(input)) {",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": null,
          "new_api": "_offset));\n        return toke",
          "old_text": null,
          "new_text": "_offset));\n        return toke",
          "old_line_content": "    }",
          "new_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "f8_view.end())\n  ",
          "old_line_content": "    }",
          "new_line_content": "    if (it == m_utf8_view.end())",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": null,
          "new_api": "}\n\n    // EOF\n    if (is",
          "old_text": null,
          "new_text": "\n    }\n\n    // EOF\n    if (is",
          "old_line_content": "}",
          "new_line_content": "        return consume_an_ident_like_token();",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": null,
          "new_api": "n_if",
          "old_text": null,
          "new_text": "n_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Peek code_point: {:d}\", *m_prev_utf8_iterator);\n  ",
          "old_line_content": "    return values;",
          "new_line_content": "    dbgln_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Peek code_point: {:d}\", *m_prev_utf8_iterator);",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": null,
          "new_api": "// Create a",
          "old_text": null,
          "new_text": "      // Create a",
          "old_line_content": "    return token;",
          "new_line_content": "        (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": null,
          "new_api": "::Type::Percentage);\n        token.m_numb",
          "old_text": null,
          "new_text": "::Type::Percentage);\n        token.m_numb",
          "old_line_content": "// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number",
          "new_line_content": "        auto token = create_new_token(Token::Type::Percentage);",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": null,
          "new_api": "// anything else",
          "old_text": null,
          "new_text": " // anything else\n",
          "old_line_content": "",
          "new_line_content": "        return create_eof_token();",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": null,
          "new_api": "_offset));\n        return toke",
          "old_text": null,
          "new_text": "_offset));\n        return toke",
          "old_line_content": "{",
          "new_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "es.set(i, *it);\n  ",
          "old_line_content": "        ++it;",
          "new_line_content": "        values.set(i, *it);",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": null,
          "new_api": "\"is delimiter\");\n    // Return a <delim-token",
          "old_text": null,
          "new_text": "\"is delimiter\");\n    // Return a <delim-token",
          "old_line_content": "}",
          "new_line_content": "    dbgln_if(CSS_TOKENIZER_DEBUG, \"is delimiter\");",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": null,
          "new_api": "));\n}\n\nsize_t Tokenizer::curre",
          "old_text": null,
          "new_text": "));\n}\n\nsize_t Tokenizer::curre",
          "old_line_content": "}",
          "new_line_content": "    return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": null,
          "new_api": "n_if",
          "old_text": null,
          "new_text": "n_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Peek twin: {:d},{:d}\", values.first, values.second);\n  ",
          "old_line_content": "    return values;",
          "new_line_content": "    dbgln_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Peek twin: {:d},{:d}\", values.first, values.second);",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": null,
          "new_api": "::Type::Number);\n    token.m_number_v",
          "old_text": null,
          "new_text": "::Type::Number);\n    token.m_number_v",
          "old_line_content": "    // code points, in that order.",
          "new_line_content": "    auto token = create_new_token(Token::Type::Number);",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": null,
          "new_api": "_offset));\n    return token;\n}",
          "old_text": null,
          "new_text": "_offset));\n    return token;\n}",
          "old_line_content": "    // Note: This algorithm will not consume any additional code points.",
          "new_line_content": "    token.m_representation = TRY(input_since(start_byte_offset));",
          "content_same": false
        },
        {
          "line": 1351,
          "old_api": null,
          "new_api": "r<String> Tokenizer",
          "old_text": null,
          "new_text": "r<String> Tokenizer",
          "old_line_content": "",
          "new_line_content": "    return m_utf8_iterator.ptr() - m_utf8_view.bytes();",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": null,
          "new_api": ");\n}\n\n}",
          "old_text": null,
          "new_text": ");\n}\n\n}\n",
          "old_line_content": "",
          "new_line_content": "    return m_decoded_input.substring_from_byte_offset_with_shared_superstring(offset, current_byte_offset() - offset);",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": null,
          "new_api": "n_if",
          "old_text": null,
          "new_text": "n_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Peek triplet: {:d},{:d},{:d}\", values.first, values.second, values.third);\n  ",
          "old_line_content": "}",
          "new_line_content": "    dbgln_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Peek triplet: {:d},{:d},{:d}\", values.first, values.second, values.third);",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": null,
          "new_api": "_code_point",
          "old_text": null,
          "new_text": "_code_point();\n  ",
          "old_line_content": "    triplet.second = next_two.first;",
          "new_line_content": "    twin.first = next_code_point();",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": null,
          "new_api": "_code_point",
          "old_text": null,
          "new_text": "_code_point();\n\n ",
          "old_line_content": "    triplet.third = next_two.second;",
          "new_line_content": "    twin.second = peek_code_point();",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": null,
          "new_api": ".first)) {\n        // If the",
          "old_text": null,
          "new_text": ".first)) {\n        // If the ",
          "old_line_content": "",
          "new_line_content": "    if (is_plus_sign(values.first) || is_hyphen_minus(values.first)) {",
          "content_same": false
        },
        {
          "line": 354,
          "old_api": null,
          "new_api": "nsume_current_input_code_point",
          "old_text": null,
          "new_text": "nsume_current_input_code_point();\n  ",
          "old_line_content": "    return token;",
          "new_line_content": "    reconsume_current_input_code_point();",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": null,
          "new_api": "_code_point",
          "old_text": null,
          "new_text": "_code_point();\n  ",
          "old_line_content": "}",
          "new_line_content": "    triplet.first = next_code_point();",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": null,
          "new_api": "_twin",
          "old_text": null,
          "new_text": "_twin();\n  ",
          "old_line_content": "",
          "new_line_content": "    auto next_two = peek_twin();",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": null,
          "new_api": "rst))\n        // If the se",
          "old_text": null,
          "new_text": "rst))\n        // If the se",
          "old_line_content": "",
          "new_line_content": "    if (is_full_stop(values.first))",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": null,
          "new_api": "second);\n\n    // digit\n    if",
          "old_text": null,
          "new_text": "second);\n\n    // digit\n    if",
          "old_line_content": "bool Tokenizer::is_valid_escape_sequence(U32Twin values)",
          "new_line_content": "        return is_ascii_digit(values.second);",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": null,
          "new_api": "first))\n        // Return tr",
          "old_text": null,
          "new_text": "first))\n        // Return tr",
          "old_line_content": "    // The algorithm described here can be called explicitly with two code points,",
          "new_line_content": "    if (is_ascii_digit(values.first))",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": null,
          "new_api": "te_new_token",
          "old_text": null,
          "new_text": "te_new_token(type);\n  ",
          "old_line_content": "",
          "new_line_content": "    auto token = create_new_token(type);",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": null,
          "new_api": "(value);",
          "old_text": null,
          "new_text": "(value);\n  ",
          "old_line_content": "// https://www.w3.org/TR/css-syntax-3/#consume-escaped-code-point",
          "new_line_content": "    token.m_value = move(value);",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": null,
          "new_api": "(representation);",
          "old_text": null,
          "new_text": "(representation);\n  ",
          "old_line_content": "u32 Tokenizer::consume_escaped_code_point()",
          "new_line_content": "    token.m_representation = move(representation);",
          "content_same": false
        },
        {
          "line": 385,
          "old_api": null,
          "new_api": "te_new_token",
          "old_text": null,
          "new_text": "te_new_token(type);\n  ",
          "old_line_content": "",
          "new_line_content": "    auto token = create_new_token(type);",
          "content_same": false
        },
        {
          "line": 386,
          "old_api": null,
          "new_api": "ng::from_code_point(value);",
          "old_text": null,
          "new_text": "ng::from_code_point(value);\n  ",
          "old_line_content": "    // Consume the next input code point.",
          "new_line_content": "    token.m_value = String::from_code_point(value);",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": null,
          "new_api": "ues.first))\n        return false",
          "old_text": null,
          "new_text": "ues.first))\n        return false",
          "old_line_content": "{",
          "new_line_content": "    if (!is_reverse_solidus(values.first))",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": null,
          "new_api": "nd))\n        return false",
          "old_text": null,
          "new_text": "nd))\n        return false",
          "old_line_content": "    // points in question are the current input code point and the next two input code",
          "new_line_content": "    if (is_newline(values.second))",
          "content_same": false
        },
        {
          "line": 400,
          "old_api": null,
          "new_api": "_code_point",
          "old_text": null,
          "new_text": "_code_point();\n\n ",
          "old_line_content": "",
          "new_line_content": "    auto input = next_code_point();",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": null,
          "new_api": ".first)) {\n        // If the",
          "old_text": null,
          "new_text": ".first)) {\n        // If the ",
          "old_line_content": "    }",
          "new_line_content": "    if (is_hyphen_minus(values.first)) {",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": null,
          "new_api": "_code_point",
          "old_text": null,
          "new_text": "_code_point());\n ",
          "old_line_content": "            return REPLACEMENT_CHARACTER;",
          "new_line_content": "            builder.append_code_point(next_code_point());",
          "content_same": false
        },
        {
          "line": 415,
          "old_api": null,
          "new_api": "_code_point",
          "old_text": null,
          "new_text": "_code_point())) {",
          "old_line_content": "        return unhexed;",
          "new_line_content": "        if (is_whitespace(peek_code_point())) {",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": null,
          "new_api": "_code_point",
          "old_text": null,
          "new_text": "_code_point();\n  ",
          "old_line_content": "    }",
          "new_line_content": "            (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": null,
          "new_api": "string_view",
          "old_text": null,
          "new_text": "der.string_view()).va",
          "old_line_content": "        // This is a parse error. Return U+FFFD REPLACEMENT CHARACTER (ï¿½).",
          "new_line_content": "        auto unhexed = AK::StringUtils::convert_to_uint_from_hex<u32>(builder.string_view()).value_or(0);",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": null,
          "new_api": "int",
          "old_text": null,
          "new_text": "int(values.first)) {\n        // Return ",
          "old_line_content": "",
          "new_line_content": "    if (is_ident_start_code_point(values.first)) {",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": null,
          "new_api": "ater_than_maximum_allowed_code_point",
          "old_text": null,
          "new_text": "ater_than_maximum_allowed_code_point(unhexed)) {\n  ",
          "old_line_content": "    }",
          "new_line_content": "        if (unhexed == 0 || is_unicode_surrogate(unhexed) || is_greater_than_maximum_allowed_code_point(unhexed)) {",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "ues.first)) {\n        // If the",
          "old_text": null,
          "new_text": "ues.first)) {\n        // If the ",
          "old_line_content": "// https://www.w3.org/TR/css-syntax-3/#consume-string-token",
          "new_line_content": "    if (is_reverse_solidus(values.first)) {",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": null,
          "new_api": "return",
          "old_text": null,
          "new_text": "            return ",
          "old_line_content": "{",
          "new_line_content": "        if (is_valid_escape_sequence(values.to_twin_12()))",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": null,
          "new_api": "(input)) {",
          "old_text": null,
          "new_text": "(input)) {\n  ",
          "old_line_content": "{",
          "new_line_content": "    if (is_eof(input)) {",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": null,
          "new_api": "e_error",
          "old_text": null,
          "new_text": "e_error();\n      ",
          "old_line_content": "    // It returns an <ident-token>, <function-token>, <url-token>, or <bad-url-token>.",
          "new_line_content": "        log_parse_error();",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": null,
          "new_api": "byte_offset",
          "old_text": null,
          "new_text": "byte_offset();\n    au",
          "old_line_content": "            }",
          "new_line_content": "    auto start_byte_offset = current_byte_offset();",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": null,
          "new_api": "an_ident_sequence",
          "old_text": null,
          "new_text": "an_ident_sequence());\n\n    ",
          "old_line_content": "",
          "new_line_content": "    auto string = TRY(consume_an_ident_sequence());",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": null,
          "new_api": "auto token = cre",
          "old_text": null,
          "new_text": "\n    auto token = cre",
          "old_line_content": "",
          "new_line_content": "    auto start_byte_offset = current_byte_offset();",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "::Type::String);\n    StringBuilder bu",
          "old_text": null,
          "new_text": "::Type::String);\n    StringBuilder bu",
          "old_line_content": "        // ending code point",
          "new_line_content": "    auto token = create_new_token(Token::Type::String);",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": null,
          "new_api": "point",
          "old_text": null,
          "new_text": "point())) {\n     ",
          "old_line_content": "        // If the next one or two input code points are U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('),",
          "new_line_content": "    if (Infra::is_ascii_case_insensitive_match(string, \"url\"sv) && is_left_paren(peek_code_point())) {",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": null,
          "new_api": "point",
          "old_text": null,
          "new_text": "point();\n\n       ",
          "old_line_content": "        // or whitespace followed by U+0022 QUOTATION MARK (\") or U+0027 APOSTROPHE ('), then create a",
          "new_line_content": "        (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": null,
          "new_api": ");\n        token.m_re",
          "old_text": null,
          "new_text": ");\n        token.m_re",
          "old_line_content": "        // EOF",
          "new_line_content": "        token.m_value = TRY(FlyString::from_utf8(builder.string_view()));",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": null,
          "new_api": "ace",
          "old_text": null,
          "new_text": "ace(maybe_whitespace.second))) {\n     ",
          "old_line_content": "        }",
          "new_line_content": "            if (!(is_whitespace(maybe_whitespace.first) && is_whitespace(maybe_whitespace.second))) {",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": null,
          "new_api": "// ending c",
          "old_text": null,
          "new_text": "      // ending c",
          "old_line_content": "        // newline",
          "new_line_content": "        auto input = next_code_point();",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": null,
          "new_api": "point",
          "old_text": null,
          "new_text": "point();\n        ",
          "old_line_content": "    }",
          "new_line_content": "            (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": null,
          "new_api": "// Thi",
          "old_text": null,
          "new_text": "       // Thi",
          "old_line_content": "            return bad_string_token;",
          "new_line_content": "        if (is_eof(input)) {",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": null,
          "new_api": ");",
          "old_text": null,
          "new_text": ");\n        ",
          "old_line_content": "        // Create a <function-token> with its value set to string and return it.",
          "new_line_content": "        auto next_two = peek_twin();",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": null,
          "new_api": "return m",
          "old_text": null,
          "new_text": "         return m",
          "old_line_content": "",
          "new_line_content": "            log_parse_error();",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": null,
          "new_api": "e",
          "old_text": null,
          "new_text": "e(start_byte_offset)));\n      ",
          "old_line_content": "    }",
          "new_line_content": "            return create_value_token(Token::Type::Function, move(string), TRY(input_since(start_byte_offset)));",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": null,
          "new_api": "}\n\n        /",
          "old_text": null,
          "new_text": "}\n\n        /",
          "old_line_content": "        // U+005C REVERSE SOLIDUS (\\)",
          "new_line_content": "            return make_token();",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": null,
          "new_api": "url_token",
          "old_text": null,
          "new_text": "url_token();\n    }\n\n ",
          "old_line_content": "}",
          "new_line_content": "        return consume_a_url_token();",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": null,
          "new_api": "t_code_point",
          "old_text": null,
          "new_text": "t_code_point();\n            auto bad",
          "old_line_content": "            // Otherwise, if the next input code point is a newline, consume it.",
          "new_line_content": "            reconsume_current_input_code_point();",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": null,
          "new_api": "point",
          "old_text": null,
          "new_text": "point())) {\n     ",
          "old_line_content": "{",
          "new_line_content": "    if (is_left_paren(peek_code_point())) {",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": null,
          "new_api": "point",
          "old_text": null,
          "new_text": "point();\n\n       ",
          "old_line_content": "    // This section describes how to consume a number from a stream of code points.",
          "new_line_content": "        (void)next_code_point();",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": null,
          "new_api": "e",
          "old_text": null,
          "new_text": "e(start_byte_offset)));\n    }\n",
          "old_line_content": "    // Note: This algorithm does not do the verification of the first few code points",
          "new_line_content": "        return create_value_token(Token::Type::Function, move(string), TRY(input_since(start_byte_offset)));",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": null,
          "new_api": "ut)) {\n            // If",
          "old_text": null,
          "new_text": "ut)) {\n            // If ",
          "old_line_content": "            // point and append the returned code point to the <string-token>âs value.",
          "new_line_content": "        if (is_reverse_solidus(input)) {",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": null,
          "new_api": "e",
          "old_text": null,
          "new_text": "e(start_byte_offset)));\n}\n\n// ",
          "old_line_content": "    // Execute the following steps in order:",
          "new_line_content": "    return create_value_token(Token::Type::Ident, move(string), TRY(input_since(start_byte_offset)));",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": null,
          "new_api": "cont",
          "old_text": null,
          "new_text": "              cont",
          "old_line_content": "            continue;",
          "new_line_content": "            if (is_eof(next_input))",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": null,
          "new_api": ") {\n                (v",
          "old_text": null,
          "new_text": ") {\n                (v",
          "old_line_content": "        // Append the current input code point to the <string-token>âs value.",
          "new_line_content": "            if (is_newline(next_input)) {",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": null,
          "new_api": "nt",
          "old_text": null,
          "new_text": "nt();\n            builder.ap",
          "old_line_content": "{",
          "new_line_content": "            auto escaped = consume_escaped_code_point();",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": null,
          "new_api": "t",
          "old_text": null,
          "new_text": "t(escaped);\n            continue;\n",
          "old_line_content": "    // This section describes how to consume comments from a stream of code points.",
          "new_line_content": "            builder.append_code_point(escaped);",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": null,
          "new_api": "input);\n    }\n}\n\n// https://www.",
          "old_text": null,
          "new_text": "input);\n    }\n}\n\n// https://www.",
          "old_line_content": "    // followed by a U+002F SOLIDUS (/), or up to an EOF code point. Return to the start of this step.",
          "new_line_content": "        builder.append_code_point(input);",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": null,
          "new_api": "point",
          "old_text": null,
          "new_text": "point();\n    if (",
          "old_line_content": "    }",
          "new_line_content": "    auto next_input = peek_code_point();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1024,
          "old_api": "solidus",
          "new_api": null,
          "old_text": "solidus(twi",
          "new_text": null,
          "old_line_content": "    auto twin = peek_twin();",
          "new_line_content": "void Tokenizer::consume_comments()",
          "content_same": false
        },
        {
          "line": 1025,
          "old_api": "return;\n\n    (v",
          "new_api": null,
          "old_text": "\n        return;\n\n    (v",
          "new_text": null,
          "old_line_content": "    if (!(is_solidus(twin.first) && is_asterisk(twin.second)))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 515,
          "old_api": "igit",
          "new_api": null,
          "old_text": "igit(maybe_number.second)) {\n      ",
          "new_text": null,
          "old_line_content": "    if (is_full_stop(maybe_number.first) && is_ascii_digit(maybe_number.second)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": "id)next_code_poin",
          "new_api": null,
          "old_text": "id)next_code_poin",
          "new_text": null,
          "old_line_content": "    (void)next_code_point();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": "r (;;) {",
          "new_api": null,
          "old_text": "r (;;) {\n        ",
          "new_text": null,
          "old_line_content": "    (void)next_code_point();",
          "new_line_content": "start:",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": "point",
          "new_api": null,
          "old_text": "point());\n       ",
          "new_text": null,
          "old_line_content": "        repr.append_code_point(next_code_point());",
          "new_line_content": "    for (;;) {",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": "s_eof",
          "new_api": null,
          "old_text": "s_eof(twin_",
          "new_text": null,
          "old_line_content": "        auto twin_inner = peek_twin();",
          "new_line_content": "    // followed by a U+002F SOLIDUS (/), or up to an EOF code point. Return to the start of this step.",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": "{\n            log_parse_",
          "new_api": null,
          "old_text": " {\n            log_parse_",
          "new_text": null,
          "old_line_content": "        if (is_eof(twin_inner.first) || is_eof(twin_inner.second)) {",
          "new_line_content": "    //",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": "return;",
          "new_api": null,
          "old_text": "     return;\n    ",
          "new_text": null,
          "old_line_content": "            log_parse_error();",
          "new_line_content": "    // If the preceding paragraph ended by consuming an EOF code point, this is a parse error.",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": "point",
          "new_api": null,
          "old_text": "point();\n        ",
          "new_text": null,
          "old_line_content": "            auto digit = peek_code_point();",
          "new_line_content": "    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": "(void)next_c",
          "new_api": null,
          "old_text": "     (void)next_c",
          "new_text": null,
          "old_line_content": "            (void)next_code_point();",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": "goto start;",
          "new_api": null,
          "old_text": "     goto start;\n",
          "new_text": null,
          "old_line_content": "            (void)next_code_point();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": "point",
          "new_api": null,
          "old_text": "point());\n       ",
          "new_text": null,
          "old_line_content": "            repr.append_code_point(next_code_point());",
          "new_line_content": "        // 2. Append them to repr.",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": "// https://www.",
          "new_api": null,
          "old_text": "\n\n// https://www.",
          "new_text": null,
          "old_line_content": "        (void)next_code_point();",
          "new_line_content": "    for (;;) {",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "et",
          "new_api": null,
          "old_text": "et();\n    if (",
          "new_text": null,
          "old_line_content": "    auto maybe_exp = peek_triplet();",
          "new_line_content": "        // 4. While the next input code point is a digit, consume it and append it to repr.",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "_exp.first))",
          "new_api": null,
          "old_text": "_exp.first))\n        ",
          "new_text": null,
          "old_line_content": "    if ((is_E(maybe_exp.first) || is_e(maybe_exp.first))",
          "new_line_content": "        for (;;) {",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": "/ Consume the next",
          "new_api": null,
          "old_text": "/ Consume the next",
          "new_text": null,
          "old_line_content": "    consume_comments();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": "igit",
          "new_api": null,
          "old_text": "igit(maybe_exp.third)) {\n      ",
          "new_text": null,
          "old_line_content": "            if (is_ascii_digit(maybe_exp.third)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "point",
          "new_api": null,
          "old_text": "point());\n       ",
          "new_text": null,
          "old_line_content": "                repr.append_code_point(next_code_point());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": "point",
          "new_api": null,
          "old_text": "point());\n       ",
          "new_text": null,
          "old_line_content": "                repr.append_code_point(next_code_point());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": "point",
          "new_api": null,
          "old_text": "point());\n       ",
          "new_text": null,
          "old_line_content": "                repr.append_code_point(next_code_point());",
          "new_line_content": "    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E) or",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": "auto input = next_co",
          "new_api": null,
          "old_text": " auto input = next_co",
          "new_text": null,
          "old_line_content": "    auto start_byte_offset = current_byte_offset();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": "igit",
          "new_api": null,
          "old_text": "igit(maybe_exp.second)) {\n      ",
          "new_text": null,
          "old_line_content": "        } else if (is_ascii_digit(maybe_exp.second)) {",
          "new_line_content": "    // or U+002B PLUS SIGN (+), followed by a digit, then:",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": "whitespace\n    i",
          "new_api": null,
          "old_text": " whitespace\n    i",
          "new_text": null,
          "old_line_content": "    auto input = next_code_point();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": "dbgln_if(CSS_T",
          "new_api": null,
          "old_text": "      dbgln_if(CSS_T",
          "new_text": null,
          "old_line_content": "    if (is_whitespace(input)) {",
          "new_line_content": "ErrorOr<Token> Tokenizer::consume_a_token()",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "UG, \"is whitespace\");\n        // Consume as mu",
          "new_api": null,
          "old_text": "UG, \"is whitespace\");\n        // Consume as mu",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is whitespace\");",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": "_as_possible",
          "new_api": null,
          "old_text": "_as_possible();\n        auto token = cre",
          "new_text": null,
          "old_line_content": "        consume_as_much_whitespace_as_possible();",
          "new_line_content": "    // It will return a single token of any type.",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": "pe::Whitespace);\n        token.m_represen",
          "new_api": null,
          "old_text": "pe::Whitespace);\n        token.m_represen",
          "new_text": null,
          "old_line_content": "        auto token = create_new_token(Token::Type::Whitespace);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": "set));\n        return token;",
          "new_api": null,
          "old_text": "set));\n        return token;\n ",
          "new_text": null,
          "old_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "    // Consume comments.",
          "content_same": false
        },
        {
          "line": 1073,
          "old_api": "UG, \"is quotation mark\");\n        // Consume a str",
          "new_api": null,
          "old_text": "UG, \"is quotation mark\");\n        // Consume a str",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is quotation mark\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": "g_view",
          "new_api": null,
          "old_text": "g_view());\n\n    //",
          "new_text": null,
          "old_line_content": "    auto value = convert_a_string_to_a_number(repr.string_view());",
          "new_line_content": "        type = Number::Type::Number;",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": "auto maybe_escap",
          "new_api": null,
          "old_text": " auto maybe_escap",
          "new_text": null,
          "old_line_content": "        auto next_input = peek_code_point();",
          "new_line_content": "    // U+0022 QUOTATION MARK (\")",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": "aybe_escape)) {\n            // 1. Crea",
          "new_api": null,
          "old_text": "aybe_escape)) {\n            // 1. Crea",
          "new_text": null,
          "old_line_content": "        if (is_ident_code_point(next_input) || is_valid_escape_sequence(maybe_escape)) {",
          "new_line_content": "        // Consume a string token and return it.",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": "pe::Hash);\n\n            // 2. If th",
          "new_api": null,
          "old_text": "pe::Hash);\n\n            // 2. If th",
          "new_text": null,
          "old_line_content": "            auto token = create_new_token(Token::Type::Hash);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": ");\n            return token;",
          "new_api": null,
          "old_text": ");\n            return token;\n ",
          "new_text": null,
          "old_line_content": "            token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "            // 1. Create a <hash-token>.",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": "point",
          "new_api": null,
          "old_text": "point();\n\n       ",
          "new_text": null,
          "old_line_content": "        auto input = next_code_point();",
          "new_line_content": "    // It returns a string containing the largest name that can be formed from adjacent",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": "}\n\n    // U+0028 LEFT PA",
          "new_api": null,
          "old_text": "   }\n\n    // U+0028 LEFT PA",
          "new_text": null,
          "old_line_content": "        return consume_string_token(input);",
          "new_line_content": "            // 4. Return the <hash-token>.",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "ut))",
          "new_api": null,
          "old_text": "ut))\n        ",
          "new_text": null,
          "old_line_content": "        if (is_eof(input))",
          "new_line_content": "    //",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": "dbgln_if(CSS_TOKEN",
          "new_api": null,
          "old_text": "  dbgln_if(CSS_TOKEN",
          "new_text": null,
          "old_line_content": "    if (is_left_paren(input)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": "\"is left paren\");\n        // Return a <(-token",
          "new_api": null,
          "old_text": "\"is left paren\");\n        // Return a <(-token",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is left paren\");",
          "new_line_content": "        // Otherwise, return a <delim-token> with its value set to the current input code point.",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": "ode_point",
          "new_api": null,
          "old_text": "ode_point(input)) {\n      ",
          "new_text": null,
          "old_line_content": "        if (is_ident_code_point(input)) {",
          "new_line_content": "    // calling this algorithm.",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": "OpenParen);\n        token.m_representati",
          "new_api": null,
          "old_text": "OpenParen);\n        token.m_representati",
          "new_text": null,
          "old_line_content": "        Token token = create_new_token(Token::Type::OpenParen);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": "_append_code_point",
          "new_api": null,
          "old_text": "_append_code_point(input));\n       ",
          "new_text": null,
          "old_line_content": "            TRY(result.try_append_code_point(input));",
          "new_line_content": "    // Let result initially be an empty string.",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": ");\n        return token;\n    }",
          "new_api": null,
          "old_text": ");\n        return token;\n    }",
          "new_text": null,
          "old_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": "\"is right paren\");\n        // Return a <)-token",
          "new_api": null,
          "old_text": "\"is right paren\");\n        // Return a <)-token",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is right paren\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": "CloseParen);\n        token.m_representati",
          "new_api": null,
          "old_text": "CloseParen);\n        token.m_representati",
          "new_text": null,
          "old_line_content": "        Token token = create_new_token(Token::Type::CloseParen);",
          "new_line_content": "    // U+0028 LEFT PARENTHESIS (()",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": "dbgln_if(CSS_TOKEN",
          "new_api": null,
          "old_text": " dbgln_if(CSS_TOKEN",
          "new_text": null,
          "old_line_content": "    if (is_plus_sign(input)) {",
          "new_line_content": "        return token;",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": "\"is plus sign\");\n        // If the input stre",
          "new_api": null,
          "old_text": "\"is plus sign\");\n        // If the input stre",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is plus sign\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": "fly_string_without_validation",
          "new_api": null,
          "old_text": "fly_string_without_validation();\n}\n\n// ht",
          "new_text": null,
          "old_line_content": "    return result.to_fly_string_without_validation();",
          "new_line_content": "        // the stream starts with a valid escape",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "}\n\n        // Otherw",
          "new_api": null,
          "old_text": "     }\n\n        // Otherw",
          "new_text": null,
          "old_line_content": "            return consume_a_numeric_token();",
          "new_line_content": "        // Return a <)-token>.",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": "));\n    }\n\n    // U+002C COMMA",
          "new_api": null,
          "old_text": "));\n    }\n\n    // U+002C COMMA",
          "new_text": null,
          "old_line_content": "        return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": "\"is comma\");\n        // Return a <comma-t",
          "new_api": null,
          "old_text": "\"is comma\");\n        // Return a <comma-t",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is comma\");",
          "new_line_content": "        // If the input stream starts with a number, reconsume the current input code point,",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "ffset",
          "new_api": null,
          "old_text": "ffset();\n    auto tok",
          "new_text": null,
          "old_line_content": "    auto start_byte_offset = current_byte_offset();",
          "new_line_content": "// https://www.w3.org/TR/css-syntax-3/#consume-url-token",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "en",
          "new_api": null,
          "old_text": "en(Token::Type::Url);\n    StringBu",
          "new_text": null,
          "old_line_content": "    auto token = create_new_token(Token::Type::Url);",
          "new_line_content": "ErrorOr<Token> Tokenizer::consume_a_url_token()",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "h_whitespace_as_possible",
          "new_api": null,
          "old_text": "h_whitespace_as_possible();\n\n    auto ma",
          "new_text": null,
          "old_line_content": "    consume_as_much_whitespace_as_possible();",
          "new_line_content": "    //",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "\"is hyphen minus\");\n        // If the input stre",
          "new_api": null,
          "old_text": "\"is hyphen minus\");\n        // If the input stre",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is hyphen minus\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "_view",
          "new_api": null,
          "old_text": "_view()));\n        to",
          "new_text": null,
          "old_line_content": "        token.m_value = TRY(FlyString::from_utf8(builder.string_view()));",
          "new_line_content": "    // like url(foo). A quoted value, like url(\"foo\"), is parsed as a <function-token>.",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": "art_byte_offset));\n        ret",
          "new_api": null,
          "old_text": "art_byte_offset));\n        ret",
          "new_text": null,
          "old_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "    // Consume an ident-like token automatically handles this distinction; this algorithm",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "}\n\n        // Otherw",
          "new_api": null,
          "old_text": "     }\n\n        // Otherw",
          "new_text": null,
          "old_line_content": "            return consume_a_numeric_token();",
          "new_line_content": "        // Return a <comma-token>.",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": "t",
          "new_api": null,
          "old_text": "t();\n\n        // ",
          "new_text": null,
          "old_line_content": "        auto input = next_code_point();",
          "new_line_content": "    StringBuilder builder;",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": "phen_minus",
          "new_api": null,
          "old_text": "phen_minus(",
          "new_text": null,
          "old_line_content": "        auto next_twin = peek_twin();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": ".second)) {\n            (void)next_cod",
          "new_api": null,
          "old_text": ".second)) {\n            (void)next_cod",
          "new_text": null,
          "old_line_content": "        if (is_hyphen_minus(next_twin.first) && is_greater_than_sign(next_twin.second)) {",
          "new_line_content": "    // U+002D HYPHEN-MINUS (-)",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": "}",
          "new_api": null,
          "old_text": "        }\n\n ",
          "new_text": null,
          "old_line_content": "            return make_token();",
          "new_line_content": "    auto make_token = [&]() -> ErrorOr<Token> {",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": "CDC);\n            token.m_represen",
          "new_api": null,
          "old_text": "CDC);\n            token.m_represen",
          "new_text": null,
          "old_line_content": "            Token token = create_new_token(Token::Type::CDC);",
          "new_line_content": "        // consume a numeric token, and return it.",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": "{",
          "new_api": null,
          "old_text": " {\n          ",
          "new_text": null,
          "old_line_content": "        if (is_eof(input)) {",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": "r",
          "new_api": null,
          "old_text": "r();\n            ",
          "new_text": null,
          "old_line_content": "            log_parse_error();",
          "new_line_content": "    // 3. Repeatedly consume the next input code point from the stream:",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "}",
          "new_api": null,
          "old_text": "        }\n\n ",
          "new_text": null,
          "old_line_content": "            return make_token();",
          "new_line_content": "    for (;;) {",
          "content_same": false
        },
        {
          "line": 1181,
          "old_api": "))) {\n            reconsume_cur",
          "new_api": null,
          "old_text": "))) {\n            reconsume_cur",
          "new_text": null,
          "old_line_content": "        if (would_start_an_ident_sequence(start_of_input_stream_triplet())) {",
          "new_line_content": "        // GREATER-THAN SIGN (->), consume them and return a <CDC-token>.",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "dbgln_if(CSS_TOKEN",
          "new_api": null,
          "old_text": " dbgln_if(CSS_TOKEN",
          "new_text": null,
          "old_line_content": "    if (is_full_stop(input)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": "\"is full stop\");\n        // If the input stre",
          "new_api": null,
          "old_text": "\"is full stop\");\n        // If the input stre",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is full stop\");",
          "new_line_content": "        // Otherwise, if the input stream starts with an identifier, reconsume the current",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": "",
          "new_api": null,
          "old_text": "            ",
          "new_text": null,
          "old_line_content": "                return make_token();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": "}\n\n        // Otherw",
          "new_api": null,
          "old_text": "     }\n\n        // Otherw",
          "new_text": null,
          "old_line_content": "            return consume_a_numeric_token();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "t",
          "new_api": null,
          "old_text": "t();\n            ",
          "new_text": null,
          "old_line_content": "                (void)next_code_point();",
          "new_line_content": "            // Consume as much whitespace as possible.",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": "",
          "new_api": null,
          "old_text": "            ",
          "new_text": null,
          "old_line_content": "                return make_token();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": "));\n    }\n\n    // U+003A COLON",
          "new_api": null,
          "old_text": "));\n    }\n\n    // U+003A COLON",
          "new_text": null,
          "old_line_content": "        return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": "mnants_of_a_bad_url",
          "new_api": null,
          "old_text": "mnants_of_a_bad_url();\n            ",
          "new_text": null,
          "old_line_content": "            consume_the_remnants_of_a_bad_url();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1206,
          "old_api": "\"is colon\");\n        // Return a <colon-t",
          "new_api": null,
          "old_text": "\"is colon\");\n        // Return a <colon-t",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is colon\");",
          "new_line_content": "        // If the input stream starts with a number, reconsume the current input code point,",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": "le",
          "new_api": null,
          "old_text": "le(input)) {\n          ",
          "new_text": null,
          "old_line_content": "        if (is_quotation_mark(input) || is_apostrophe(input) || is_left_paren(input) || is_non_printable(input)) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": "\"is semicolon\");\n        // Return a <semicol",
          "new_api": null,
          "old_text": "\"is semicolon\");\n        // Return a <semicol",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is semicolon\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": "r",
          "new_api": null,
          "old_text": "r();\n            ",
          "new_text": null,
          "old_line_content": "            log_parse_error();",
          "new_line_content": "            // otherwise, consume the remnants of a bad url, create a <bad-url-token>, and return it.",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": "Semicolon);\n        token.m_representati",
          "new_api": null,
          "old_text": "Semicolon);\n        token.m_representati",
          "new_text": null,
          "old_line_content": "        Token token = create_new_token(Token::Type::Semicolon);",
          "new_line_content": "    // U+003A COLON (:)",
          "content_same": false
        },
        {
          "line": 1223,
          "old_api": "dbgln_if(CSS_TOKEN",
          "new_api": null,
          "old_text": "      dbgln_if(CSS_TOKEN",
          "new_text": null,
          "old_line_content": "    if (is_less_than_sign(input)) {",
          "new_line_content": "        return token;",
          "content_same": false
        },
        {
          "line": 1224,
          "old_api": "\"is less than\");\n        // If the next 3 inp",
          "new_api": null,
          "old_text": "\"is less than\");\n        // If the next 3 inp",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is less than\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": "idus",
          "new_api": null,
          "old_text": "idus(input)) {\n          ",
          "new_text": null,
          "old_line_content": "        if (is_reverse_solidus(input)) {",
          "new_line_content": "        // U+0027 APOSTROPHE (')",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": "_stream_twin",
          "new_api": null,
          "old_text": "_stream_twin())) {\n         ",
          "new_text": null,
          "old_line_content": "            if (is_valid_escape_sequence(start_of_input_stream_twin())) {",
          "new_line_content": "        // non-printable code point",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "code_point",
          "new_api": null,
          "old_text": "code_point());\n             ",
          "new_text": null,
          "old_line_content": "                builder.append_code_point(consume_escaped_code_point());",
          "new_line_content": "            // This is a parse error. Consume the remnants of a bad url, create a <bad-url-token>, and return it.",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": "(void)next_code_",
          "new_api": null,
          "old_text": " (void)next_code_",
          "new_text": null,
          "old_line_content": "            (void)next_code_point();",
          "new_line_content": "        // Return a <semicolon-token>.",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": "CDO);\n            token.m_represen",
          "new_api": null,
          "old_text": "CDO);\n            token.m_represen",
          "new_text": null,
          "old_line_content": "            Token token = create_new_token(Token::Type::CDO);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": ");\n            return token;",
          "new_api": null,
          "old_text": ");\n            return token;\n ",
          "new_text": null,
          "old_line_content": "            token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": "ants_of_a_bad_url",
          "new_api": null,
          "old_text": "ants_of_a_bad_url();\n              ",
          "new_text": null,
          "old_line_content": "                consume_the_remnants_of_a_bad_url();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "(Token::Type::BadUrl);",
          "new_api": null,
          "old_text": "(Token::Type::BadUrl);\n              ",
          "new_text": null,
          "old_line_content": "                auto bad_url_token = create_new_token(Token::Type::BadUrl);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "t_byte_offset));",
          "new_api": null,
          "old_text": "t_byte_offset));\n             ",
          "new_text": null,
          "old_line_content": "                bad_url_token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "        // U+005C REVERSE SOLIDUS (\\)",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": "));\n    }\n\n    // U+0040 COMME",
          "new_api": null,
          "old_text": "));\n    }\n\n    // U+0040 COMME",
          "new_text": null,
          "old_line_content": "        return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "new_line_content": "        // U+002D HYPHEN-MINUS (!--), consume them and return a <CDO-token>.",
          "content_same": false
        },
        {
          "line": 216,
          "old_api": "try_append",
          "new_api": null,
          "old_text": "ilder.try_append('\\n'));",
          "new_text": null,
          "old_line_content": "                    TRY(builder.try_append('\\n'));",
          "new_line_content": "            return decoded_input;",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": "e_point",
          "new_api": null,
          "old_text": "e_point(input);\n    }\n}\n\n// http",
          "new_text": null,
          "old_line_content": "        builder.append_code_point(input);",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 222,
          "old_api": "try_append",
          "new_api": null,
          "old_text": "ilder.try_append('\\n'));",
          "new_text": null,
          "old_line_content": "                    TRY(builder.try_append('\\n'));",
          "new_line_content": "        // To filter code points from a stream of (unfiltered) code points input:",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": "return create_v",
          "new_api": null,
          "old_text": "            return create_v",
          "new_text": null,
          "old_line_content": "            auto name = TRY(consume_an_ident_sequence());",
          "new_line_content": "            return token;",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": "));\n        }\n\n        // Othe",
          "new_api": null,
          "old_text": "));\n        }\n\n        // Othe",
          "new_text": null,
          "old_line_content": "            return create_value_token(Token::Type::AtKeyword, move(name), TRY(input_since(start_byte_offset)));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 226,
          "old_api": "try_append",
          "new_api": null,
          "old_text": "ilder.try_append('\\n'));",
          "new_text": null,
          "old_line_content": "                        TRY(builder.try_append('\\n'));",
          "new_line_content": "            // or pairs of U+000D CARRIAGE RETURN (CR) followed by U+000A LINE FEED (LF)",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": "try_append",
          "new_api": null,
          "old_text": "ilder.try_append('\\n'));",
          "new_text": null,
          "old_line_content": "                    TRY(builder.try_append('\\n'));",
          "new_line_content": "                if (last_was_carriage_return) {",
          "content_same": false
        },
        {
          "line": 1253,
          "old_api": "));\n    }\n\n    // U+005B LEFT",
          "new_api": null,
          "old_text": "));\n    }\n\n    // U+005B LEFT ",
          "new_text": null,
          "old_line_content": "        return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": "try_append_code_point",
          "new_api": null,
          "old_text": "der.try_append_code_point(REPLACEMENT_CHARACTER));\n ",
          "new_text": null,
          "old_line_content": "                    TRY(builder.try_append_code_point(REPLACEMENT_CHARACTER));",
          "new_line_content": "                    last_was_carriage_return = true;",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": "try_append_code_point",
          "new_api": null,
          "old_text": "der.try_append_code_point(code_point));\n ",
          "new_text": null,
          "old_line_content": "                    TRY(builder.try_append_code_point(code_point));",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": "// U+0029",
          "new_api": null,
          "old_text": "        // U+0029",
          "new_text": null,
          "old_line_content": "        auto input = next_code_point();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1258,
          "old_api": "\"is open square\");\n        // Return a <[-token",
          "new_api": null,
          "old_text": "\"is open square\");\n        // Return a <[-token",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is open square\");",
          "new_line_content": "        // If the next 3 input code points would start an ident sequence, consume an ident sequence, create",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": ")) {\n            // R",
          "new_api": null,
          "old_text": ")) {\n            // R",
          "new_text": null,
          "old_line_content": "        if (is_eof(input) || is_right_paren(input)) {",
          "new_line_content": "void Tokenizer::consume_the_remnants_of_a_bad_url()",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": "to_string_without_validation",
          "new_api": null,
          "old_text": "der.to_string_without_validation();\n  ",
          "new_text": null,
          "old_line_content": "        return builder.to_string_without_validation();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1267,
          "old_api": "\"is reverse solidus\");\n        // If the input stre",
          "new_api": null,
          "old_text": "\"is reverse solidus\");\n        // If the input stre",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is reverse solidus\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": "er_code_points",
          "new_api": null,
          "old_text": "er_code_points(input, encoding)) };",
          "new_text": null,
          "old_line_content": "    Tokenizer tokenizer { TRY(filter_code_points(input, encoding)) };",
          "new_line_content": "                    // Replace any U+0000 NULL or surrogate code points in input with U+FFFD REPLACEMENT CHARACTER (ï¿½).",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": "tokenize",
          "new_api": null,
          "old_text": "nizer.tokenize();\n}\n",
          "new_text": null,
          "old_line_content": "    return tokenizer.tokenize();",
          "new_line_content": "                } else if (code_point == 0x00 || (code_point >= 0xD800 && code_point <= 0xDFFF)) {",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": "m_twin",
          "new_api": null,
          "old_text": "m_twin())) {\n            // ",
          "new_text": null,
          "old_line_content": "        if (is_valid_escape_sequence(start_of_input_stream_twin())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": "_point",
          "new_api": null,
          "old_text": "_point();\n        }\n\n       ",
          "new_text": null,
          "old_line_content": "            (void)consume_escaped_code_point();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": "(decoded_input))",
          "new_api": null,
          "old_text": "(decoded_input))\n  ",
          "new_text": null,
          "old_line_content": "    : m_decoded_input(move(decoded_input))",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": "}\n\n        // Otherw",
          "new_api": null,
          "old_text": "\n        }\n\n        // Otherw",
          "new_text": null,
          "old_line_content": "            return consume_an_ident_like_token();",
          "new_line_content": "        // Return a <[-token>.",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": "begin",
          "new_api": null,
          "old_text": "f8_view.begin())\n{\n",
          "new_text": null,
          "old_line_content": "    , m_utf8_iterator(m_utf8_view.begin())",
          "new_line_content": "                last_was_carriage_return = false;",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": "urn create_value_",
          "new_api": null,
          "old_text": "urn create_value_",
          "new_text": null,
          "old_line_content": "        log_parse_error();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": "));\n    }\n\n    // U+005D RIGHT",
          "new_api": null,
          "old_text": "));\n    }\n\n    // U+005D RIGHT",
          "new_text": null,
          "old_line_content": "        return create_value_token(Token::Type::Delim, input, TRY(input_since(start_byte_offset)));",
          "new_line_content": "    // U+005C REVERSE SOLIDUS (\\)",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "{\n        (void)n",
          "new_api": null,
          "old_text": "{\n        (void)n",
          "new_text": null,
          "old_line_content": "    while (is_whitespace(peek_code_point())) {",
          "new_line_content": "            // Consume an escaped code point.",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": "}\n}\n\nvoid Toke",
          "new_api": null,
          "old_text": "   }\n}\n\nvoid Toke",
          "new_text": null,
          "old_line_content": "        (void)next_code_point();",
          "new_line_content": "            // This allows an escaped right parenthesis (\"\\)\") to be encountered without ending",
          "content_same": false
        },
        {
          "line": 260,
          "old_api": "ume_a_token",
          "new_api": null,
          "old_text": "ume_a_token());\n ",
          "new_text": null,
          "old_line_content": "        auto token = TRY(consume_a_token());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": ")) {\n        dbgln_if(CSS_TOKEN",
          "new_api": null,
          "old_text": ")) {\n        dbgln_if(CSS_TOKEN",
          "new_text": null,
          "old_line_content": "    if (is_closed_square_bracket(input)) {",
          "new_line_content": "        // consume an ident-like token, and return it.",
          "content_same": false
        },
        {
          "line": 1286,
          "old_api": ");\n        return token;\n    }",
          "new_api": null,
          "old_text": ");\n        return token;\n    }",
          "new_text": null,
          "old_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 263,
          "old_api": "try_append",
          "new_api": null,
          "old_text": "ns.try_append(token));\n\n",
          "new_text": null,
          "old_line_content": "        TRY(tokens.try_append(token));",
          "new_line_content": "    , m_utf8_view(m_decoded_input)",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": "is",
          "new_api": null,
          "old_text": "n.is(Token::Type::EndOfFile)) {\n",
          "new_text": null,
          "old_line_content": "        if (token.is(Token::Type::EndOfFile)) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1292,
          "old_api": "\"is open curly\");\n        // Return a <{-token",
          "new_api": null,
          "old_text": "\"is open curly\");\n        // Return a <{-token",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is open curly\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1294,
          "old_api": "OpenCurly);\n        token.m_representati",
          "new_api": null,
          "old_text": "OpenCurly);\n        token.m_representati",
          "new_text": null,
          "old_line_content": "        Token token = create_new_token(Token::Type::OpenCurly);",
          "new_line_content": "    // U+005D RIGHT SQUARE BRACKET (])",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": ");\n\n    // Consume a",
          "new_api": null,
          "old_text": ");\n\n    // Consume a ",
          "new_text": null,
          "old_line_content": "    auto start_byte_offset = current_byte_offset();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": ") {\n        dbgln_if(CSS_TOKEN",
          "new_api": null,
          "old_text": ") {\n        dbgln_if(CSS_TOKEN",
          "new_text": null,
          "old_line_content": "    if (is_closed_curly_bracket(input)) {",
          "new_line_content": "        return token;",
          "content_same": false
        },
        {
          "line": 1301,
          "old_api": "\"is closed curly\");\n        // Return a <}-token",
          "new_api": null,
          "old_text": "\"is closed curly\");\n        // Return a <}-token",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is closed curly\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "// If the nex",
          "new_api": null,
          "old_text": "\n    // If the nex",
          "new_text": null,
          "old_line_content": "    auto number = consume_a_number();",
          "new_line_content": "    m_utf8_iterator = m_prev_utf8_iterator;",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": "CloseCurly);\n        token.m_representati",
          "new_api": null,
          "old_text": "CloseCurly);\n        token.m_representati",
          "new_text": null,
          "old_line_content": "        Token token = create_new_token(Token::Type::CloseCurly);",
          "new_line_content": "    // U+007B LEFT CURLY BRACKET ({)",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": "ewline",
          "new_api": null,
          "old_text": "ewline(code_point)) {\n",
          "new_text": null,
          "old_line_content": "    if (is_newline(code_point)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": "// 1. C",
          "new_api": null,
          "old_text": "       // 1. C",
          "new_text": null,
          "old_line_content": "    if (would_start_an_ident_sequence(peek_triplet())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "en::Type::Dimension);\n        token.m_nu",
          "new_api": null,
          "old_text": "en::Type::Dimension);\n        token.m_nu",
          "new_text": null,
          "old_line_content": "        auto token = create_new_token(Token::Type::Dimension);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": "dbgln_if(CSS_TOKEN",
          "new_api": null,
          "old_text": "   dbgln_if(CSS_TOKEN",
          "new_text": null,
          "old_line_content": "    if (is_ascii_digit(input)) {",
          "new_line_content": "        return token;",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": "\"is digit\");\n        // Reconsume the cur",
          "new_api": null,
          "old_text": "\"is digit\");\n        // Reconsume the cur",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is digit\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": "n_if",
          "new_api": null,
          "old_text": "n_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Next code_point: {:d}\", code_point);\n  ",
          "new_text": null,
          "old_line_content": "    dbgln_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Next code_point: {:d}\", code_point);",
          "new_line_content": "        return TOKENIZER_EOF;",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": "oint",
          "new_api": null,
          "old_text": "oint();\n        return consume_a_num",
          "new_text": null,
          "old_line_content": "        reconsume_current_input_code_point();",
          "new_line_content": "    // U+007D RIGHT CURLY BRACKET (})",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "// NOTE: We",
          "new_api": null,
          "old_text": "    // NOTE: We",
          "new_text": null,
          "old_line_content": "        VERIFY(!unit.is_empty());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": "end",
          "new_api": null,
          "old_text": "f8_view.end(); ++",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < offset && it != m_utf8_view.end(); ++i)",
          "new_line_content": "        m_position.line++;",
          "content_same": false
        },
        {
          "line": 1318,
          "old_api": "\"is name start\");\n        // Reconsume the cur",
          "new_api": null,
          "old_text": "\"is name start\");\n        // Reconsume the cur",
          "new_text": null,
          "old_line_content": "        dbgln_if(CSS_TOKENIZER_DEBUG, \"is name start\");",
          "new_line_content": "        return token;",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": "end",
          "new_api": null,
          "old_text": "f8_view.end())\n  ",
          "new_text": null,
          "old_line_content": "    if (it == m_utf8_view.end())",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": "oint",
          "new_api": null,
          "old_text": "oint();\n        return consume_an_id",
          "new_text": null,
          "old_line_content": "        reconsume_current_input_code_point();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": "n_if",
          "new_api": null,
          "old_text": "n_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Peek code_point: {:d}\", *m_prev_utf8_iterator);\n  ",
          "new_text": null,
          "old_line_content": "    dbgln_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Peek code_point: {:d}\", *m_prev_utf8_iterator);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "(void)nex",
          "new_api": null,
          "old_text": "        (void)nex",
          "new_text": null,
          "old_line_content": "    if (is_percent(peek_code_point())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": "// Create a",
          "new_api": null,
          "old_text": "      // Create a",
          "new_text": null,
          "old_line_content": "        (void)next_code_point();",
          "new_line_content": "        // 2. Consume an ident sequence. Set the <dimension-token>âs unit to the returned value.",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": "}\n\n    // EOF\n    if (is",
          "new_api": null,
          "old_text": "\n    }\n\n    // EOF\n    if (is",
          "new_text": null,
          "old_line_content": "        return consume_an_ident_like_token();",
          "new_line_content": "    // digit",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "::Type::Percentage);\n        token.m_numb",
          "new_api": null,
          "old_text": "::Type::Percentage);\n        token.m_numb",
          "new_text": null,
          "old_line_content": "        auto token = create_new_token(Token::Type::Percentage);",
          "new_line_content": "        // NOTE: We intentionally store this in the `value`, to save space.",
          "content_same": false
        },
        {
          "line": 1327,
          "old_api": "// anything else",
          "new_api": null,
          "old_text": " // anything else\n",
          "new_text": null,
          "old_line_content": "        return create_eof_token();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "_offset));\n        return toke",
          "new_api": null,
          "old_text": "_offset));\n        return toke",
          "new_text": null,
          "old_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": "end",
          "new_api": null,
          "old_text": "f8_view.end(); ++",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < 2 && it != m_utf8_view.end(); ++i) {",
          "new_line_content": "    auto it = m_utf8_iterator;",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "n_if",
          "new_api": null,
          "old_text": "n_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Peek twin: {:d},{:d}\", values.first, values.second);\n  ",
          "new_text": null,
          "old_line_content": "    dbgln_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Peek twin: {:d},{:d}\", values.first, values.second);",
          "new_line_content": "        return TOKENIZER_EOF;",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": "::Type::Number);\n    token.m_number_v",
          "new_api": null,
          "old_text": "::Type::Number);\n    token.m_number_v",
          "new_text": null,
          "old_line_content": "    auto token = create_new_token(Token::Type::Number);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": "end",
          "new_api": null,
          "old_text": "f8_view.end(); ++",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < 3 && it != m_utf8_view.end(); ++i) {",
          "new_line_content": "    auto it = m_utf8_iterator;",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": ");\n}\n\n}",
          "new_api": null,
          "old_text": ");\n}\n\n}\n",
          "new_text": null,
          "old_line_content": "    return m_decoded_input.substring_from_byte_offset_with_shared_superstring(offset, current_byte_offset() - offset);",
          "new_line_content": "    // anything else",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "n_if",
          "new_api": null,
          "old_text": "n_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Peek triplet: {:d},{:d},{:d}\", values.first, values.second, values.third);\n  ",
          "new_text": null,
          "old_line_content": "    dbgln_if(CSS_TOKENIZER_DEBUG, \"(Tokenizer) Peek triplet: {:d},{:d},{:d}\", values.first, values.second, values.third);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": "nsume_current_input_code_point",
          "new_api": null,
          "old_text": "nsume_current_input_code_point();\n  ",
          "new_text": null,
          "old_line_content": "    reconsume_current_input_code_point();",
          "new_line_content": "    auto it = m_utf8_iterator;",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": ".first)) {\n        // If the",
          "new_api": null,
          "old_text": ".first)) {\n        // If the ",
          "new_text": null,
          "old_line_content": "    if (is_plus_sign(values.first) || is_hyphen_minus(values.first)) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": "second))\n            return t",
          "new_api": null,
          "old_text": "second))\n            return t",
          "new_text": null,
          "old_line_content": "        if (is_ascii_digit(values.second))",
          "new_line_content": "    // The algorithm described here can be called explicitly with three code points,",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": "third))\n            return t",
          "new_api": null,
          "old_text": "third))\n            return t",
          "new_text": null,
          "old_line_content": "        if (is_full_stop(values.second) && is_ascii_digit(values.third))",
          "new_line_content": "    // Note: This algorithm will not consume any additional code points.",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": "nsume_current_input_code_point",
          "new_api": null,
          "old_text": "nsume_current_input_code_point();\n  ",
          "new_text": null,
          "old_line_content": "    reconsume_current_input_code_point();",
          "new_line_content": "    U32Twin twin;",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": "_code_point",
          "new_api": null,
          "old_text": "_code_point();\n  ",
          "new_text": null,
          "old_line_content": "    triplet.first = next_code_point();",
          "new_line_content": "    // FIXME: Reconsuming just to read the current code point again is weird.",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": "second);\n\n    // digit\n    if",
          "new_api": null,
          "old_text": "second);\n\n    // digit\n    if",
          "new_text": null,
          "old_line_content": "        return is_ascii_digit(values.second);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": "te_new_token",
          "new_api": null,
          "old_text": "te_new_token(Token::Type::EndOfFile);\n}\n",
          "new_text": null,
          "old_line_content": "    return create_new_token(Token::Type::EndOfFile);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": "te_new_token",
          "new_api": null,
          "old_text": "te_new_token(type);\n  ",
          "new_text": null,
          "old_line_content": "    auto token = create_new_token(type);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "(value);",
          "new_api": null,
          "old_text": "(value);\n  ",
          "new_text": null,
          "old_line_content": "    token.m_value = move(value);",
          "new_line_content": "    Token token = {};",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": "(representation);",
          "new_api": null,
          "old_text": "(representation);\n  ",
          "new_text": null,
          "old_line_content": "    token.m_representation = move(representation);",
          "new_line_content": "    token.m_type = type;",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": "ues.first))\n        return false",
          "new_api": null,
          "old_text": "ues.first))\n        return false",
          "new_text": null,
          "old_line_content": "    if (!is_reverse_solidus(values.first))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": "ng::from_code_point(value);",
          "new_api": null,
          "old_text": "ng::from_code_point(value);\n  ",
          "new_text": null,
          "old_line_content": "    token.m_value = String::from_code_point(value);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": "(representation);",
          "new_api": null,
          "old_text": "(representation);\n  ",
          "new_text": null,
          "old_line_content": "    token.m_representation = move(representation);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": "nd))\n        return false",
          "new_api": null,
          "old_text": "nd))\n        return false",
          "new_text": null,
          "old_line_content": "    if (is_newline(values.second))",
          "new_line_content": "    // This section describes how to check if two code points are a valid escape.",
          "content_same": false
        },
        {
          "line": 390,
          "old_api": "scii_hex_digit",
          "new_api": null,
          "old_text": "scii_hex_digit(input)) {\n",
          "new_text": null,
          "old_line_content": "    if (is_ascii_hex_digit(input)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": "append_code_point",
          "new_api": null,
          "old_text": "der.append_code_point(input);\n\n ",
          "new_text": null,
          "old_line_content": "        builder.append_code_point(input);",
          "new_line_content": "    // This section describes how to consume an escaped code point.",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": "_code_point",
          "new_api": null,
          "old_text": "_code_point()) &&",
          "new_text": null,
          "old_line_content": "        while (is_ascii_hex_digit(peek_code_point()) && counter++ < 5) {",
          "new_line_content": "    // It will return a code point.",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": "_code_point",
          "new_api": null,
          "old_text": "_code_point());\n ",
          "new_text": null,
          "old_line_content": "            builder.append_code_point(next_code_point());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": ".first)) {\n        // If the",
          "new_api": null,
          "old_text": ".first)) {\n        // If the ",
          "new_text": null,
          "old_line_content": "    if (is_hyphen_minus(values.first)) {",
          "new_line_content": "bool Tokenizer::would_start_an_ident_sequence(U32Triplet values)",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": "return",
          "new_api": null,
          "old_text": "            return ",
          "new_text": null,
          "old_line_content": "        if (is_ident_start_code_point(values.second) || is_hyphen_minus(values.second) || is_valid_escape_sequence(values.to_twin_23()))",
          "new_line_content": "    // The algorithm described here can be called explicitly with three code points, or",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": "_code_point",
          "new_api": null,
          "old_text": "_code_point())) {",
          "new_text": null,
          "old_line_content": "        if (is_whitespace(peek_code_point())) {",
          "new_line_content": "    // hex digit",
          "content_same": false
        },
        {
          "line": 919,
          "old_api": "int",
          "new_api": null,
          "old_text": "int(values.first)) {\n        // Return ",
          "new_text": null,
          "old_line_content": "    if (is_ident_start_code_point(values.first)) {",
          "new_line_content": "    // Look at the first code point:",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": "return",
          "new_api": null,
          "old_text": "            return ",
          "new_text": null,
          "old_line_content": "        if (is_valid_escape_sequence(values.to_twin_12()))",
          "new_line_content": "        // Otherwise, return false.",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": "(input)) {",
          "new_api": null,
          "old_text": "(input)) {\n  ",
          "new_text": null,
          "old_line_content": "    if (is_eof(input)) {",
          "new_line_content": "        // Interpret the hex digits as a hexadecimal number.",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": "e_error",
          "new_api": null,
          "old_text": "e_error();\n      ",
          "new_text": null,
          "old_line_content": "        log_parse_error();",
          "new_line_content": "        // If this number is zero, or is for a surrogate, or is greater than the maximum allowed",
          "content_same": false
        },
        {
          "line": 437,
          "old_api": "byte_offset",
          "new_api": null,
          "old_text": "byte_offset();\n    au",
          "new_text": null,
          "old_line_content": "    auto start_byte_offset = current_byte_offset();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 438,
          "old_api": "an_ident_sequence",
          "new_api": null,
          "old_text": "an_ident_sequence());\n\n    ",
          "new_text": null,
          "old_line_content": "    auto string = TRY(consume_an_ident_sequence());",
          "new_line_content": "    // anything else",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": "auto token = cre",
          "new_api": null,
          "old_text": "\n    auto token = cre",
          "new_text": null,
          "old_line_content": "    auto start_byte_offset = current_byte_offset();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 950,
          "old_api": "::Type::String);\n    StringBuilder bu",
          "new_api": null,
          "old_text": "::Type::String);\n    StringBuilder bu",
          "new_text": null,
          "old_line_content": "    auto token = create_new_token(Token::Type::String);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": "point",
          "new_api": null,
          "old_text": "point())) {\n     ",
          "new_text": null,
          "old_line_content": "    if (Infra::is_ascii_case_insensitive_match(string, \"url\"sv) && is_left_paren(peek_code_point())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": "point",
          "new_api": null,
          "old_text": "point();\n\n       ",
          "new_text": null,
          "old_line_content": "        (void)next_code_point();",
          "new_line_content": "// https://www.w3.org/TR/css-syntax-3/#consume-ident-like-token",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": ");\n        token.m_re",
          "new_api": null,
          "old_text": ");\n        token.m_re",
          "new_text": null,
          "old_line_content": "        token.m_value = TRY(FlyString::from_utf8(builder.string_view()));",
          "new_line_content": "    // This section describes how to consume a string token from a stream of code points.",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": "_offset));\n        return toke",
          "new_api": null,
          "old_text": "_offset));\n        return toke",
          "new_text": null,
          "old_line_content": "        token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "    // It returns either a <string-token> or <bad-string-token>.",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": ");",
          "new_api": null,
          "old_text": ");\n        ",
          "new_text": null,
          "old_line_content": "            auto maybe_whitespace = peek_twin();",
          "new_line_content": "    // It returns an <ident-token>, <function-token>, <url-token>, or <bad-url-token>.",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": "ace",
          "new_api": null,
          "old_text": "ace(maybe_whitespace.second))) {\n     ",
          "new_text": null,
          "old_line_content": "            if (!(is_whitespace(maybe_whitespace.first) && is_whitespace(maybe_whitespace.second))) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": "// ending c",
          "new_api": null,
          "old_text": "      // ending c",
          "new_text": null,
          "old_line_content": "        auto input = next_code_point();",
          "new_line_content": "    // Initially create a <string-token> with its value set to the empty string.",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": "point",
          "new_api": null,
          "old_text": "point();\n        ",
          "new_text": null,
          "old_line_content": "            (void)next_code_point();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": "// EOF",
          "new_api": null,
          "old_text": " // EOF\n    ",
          "new_text": null,
          "old_line_content": "            return make_token();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": ");",
          "new_api": null,
          "old_text": ");\n        ",
          "new_text": null,
          "old_line_content": "        auto next_two = peek_twin();",
          "new_line_content": "        // While the next two input code points are whitespace, consume the next input code point.",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "phe",
          "new_api": null,
          "old_text": "phe(next_two.second)))) {\n    ",
          "new_text": null,
          "old_line_content": "        if (is_quotation_mark(next_two.first) || is_apostrophe(next_two.first) || (is_whitespace(next_two.first) && (is_quotation_mark(next_two.second) || is_apostrophe(next_two.second)))) {",
          "new_line_content": "        for (;;) {",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": "return m",
          "new_api": null,
          "old_text": "         return m",
          "new_text": null,
          "old_line_content": "            log_parse_error();",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": "}\n\n        /",
          "new_api": null,
          "old_text": "}\n\n        /",
          "new_text": null,
          "old_line_content": "            return make_token();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": "// Thi",
          "new_api": null,
          "old_text": "           // Thi",
          "new_text": null,
          "old_line_content": "        if (is_newline(input)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": "url_token",
          "new_api": null,
          "old_text": "url_token();\n    }\n\n ",
          "new_text": null,
          "old_line_content": "        return consume_a_url_token();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": "::Type::BadString);\n            bad_stri",
          "new_api": null,
          "old_text": "::Type::BadString);\n            bad_stri",
          "new_text": null,
          "old_line_content": "            auto bad_string_token = create_new_token(Token::Type::BadString);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": "point",
          "new_api": null,
          "old_text": "point())) {\n     ",
          "new_text": null,
          "old_line_content": "    if (is_left_paren(peek_code_point())) {",
          "new_line_content": "        // If the next one or two input code points are U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('),",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "point",
          "new_api": null,
          "old_text": "point();\n\n       ",
          "new_text": null,
          "old_line_content": "        (void)next_code_point();",
          "new_line_content": "        // or whitespace followed by U+0022 QUOTATION MARK (\") or U+0027 APOSTROPHE ('), then create a",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": "_offset));\n            return",
          "new_api": null,
          "old_text": "_offset));\n            return ",
          "new_text": null,
          "old_line_content": "            bad_string_token.m_representation = TRY(input_since(start_byte_offset));",
          "new_line_content": "        // EOF",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": "ut)) {\n            // If",
          "new_api": null,
          "old_text": "ut)) {\n            // If ",
          "new_text": null,
          "old_line_content": "        if (is_reverse_solidus(input)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": "if (is_e",
          "new_api": null,
          "old_text": "         if (is_e",
          "new_text": null,
          "old_line_content": "            auto next_input = peek_code_point();",
          "new_line_content": "        // newline",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": "e",
          "new_api": null,
          "old_text": "e(start_byte_offset)));\n}\n\n// ",
          "new_text": null,
          "old_line_content": "    return create_value_token(Token::Type::Ident, move(string), TRY(input_since(start_byte_offset)));",
          "new_line_content": "        // Otherwise, consume a url token, and return it.",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "nt",
          "new_api": null,
          "old_text": "nt();\n            builder.ap",
          "new_text": null,
          "old_line_content": "            auto escaped = consume_escaped_code_point();",
          "new_line_content": "            // If the next input code point is EOF, do nothing.",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "point",
          "new_api": null,
          "old_text": "point();\n    if (",
          "new_text": null,
          "old_line_content": "    auto next_input = peek_code_point();",
          "new_line_content": "    // Note: This algorithm does not do the verification of the first few code points",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": "minus",
          "new_api": null,
          "old_text": "minus(next_input)) {\n      ",
          "new_text": null,
          "old_line_content": "    if (is_plus_sign(next_input) || is_hyphen_minus(next_input)) {",
          "new_line_content": "    // that are necessary to ensure a number can be obtained from the stream. Ensure",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "point",
          "new_api": null,
          "old_text": "point());\n    }\n\n",
          "new_text": null,
          "old_line_content": "        repr.append_code_point(next_code_point());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "point",
          "new_api": null,
          "old_text": "point();\n        ",
          "new_text": null,
          "old_line_content": "        auto digits = peek_code_point();",
          "new_line_content": "    Number::Type type = Number::Type::Integer;",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "igit",
          "new_api": null,
          "old_text": "igit(digits))\n        ",
          "new_text": null,
          "old_line_content": "        if (!is_ascii_digit(digits))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": "point",
          "new_api": null,
          "old_text": "point());\n    }\n\n",
          "new_text": null,
          "old_line_content": "        repr.append_code_point(next_code_point());",
          "new_line_content": "    bool has_explicit_sign = false;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 109,
      "total_additions": 218,
      "total_deletions": 215,
      "total_api_changes": 542
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 18,
        "api_related_lines": 542,
        "non_api_lines": 12,
        "non_api_line_numbers": [
          206,
          207,
          239,
          210,
          211,
          212,
          213,
          214,
          215,
          217,
          218,
          253
        ]
      }
    },
    "api_calls_before": 483,
    "api_calls_after": 486,
    "diff_info": {
      "added_lines": 16,
      "removed_lines": 3,
      "total_diff_lines": 42
    }
  }
}