{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/9e9924115f68c0cf7c24697510ed07b726529983",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/9e9924115f68c0cf7c24697510ed07b726529983/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/9e9924115f68c0cf7c24697510ed07b726529983/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/9e9924115f68c0cf7c24697510ed07b726529983/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 933,
          "old_api": "dmesgln",
          "new_api": "is_inode",
          "old_text": "dmesgln(\"MM: no physical pages available\")",
          "new_text": "for_each_vmobject([&](auto& vmobject) {\n            if (!vmobject.is_inode())\n                return IterationDecision::Continue;\n            auto& inode_vmobject = static_cast<InodeVMObject&>(vmobject);\n            // FIXME: It seems excessive to release *all* clean pages from the inode when we only need one.\n            if (auto released_page_count = inode_vmobject.release_all_clean_pages()) {\n                dbgln(\"MM: Clean inode release saved the day! Released {} pages from InodeVMObject\", released_page_count);\n                page = find_free_physical_page(false);\n                VERIFY(page);\n                return IterationDecision::Break;\n            }\n            return IterationDecision::Continue;\n        })",
          "old_line_content": "            dmesgln(\"MM: no physical pages available\");",
          "new_line_content": "        for_each_vmobject([&](auto& vmobject) {",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "quickmap_page",
          "new_api": "dbgln",
          "old_text": "quickmap_page(*page)",
          "new_text": "dbgln(\"MM: Clean inode release saved the day! Released {} pages from InodeVMObject\", released_page_count)",
          "old_line_content": "        auto* ptr = quickmap_page(*page);",
          "new_line_content": "                dbgln(\"MM: Clean inode release saved the day! Released {} pages from InodeVMObject\", released_page_count);",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "memset",
          "new_api": "find_free_physical_page",
          "old_text": "memset(ptr, 0, PAGE_SIZE)",
          "new_text": "find_free_physical_page(false)",
          "old_line_content": "        memset(ptr, 0, PAGE_SIZE);",
          "new_line_content": "                page = find_free_physical_page(false);",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "unquickmap_page",
          "new_api": "VERIFY",
          "old_text": "unquickmap_page()",
          "new_text": "VERIFY(page)",
          "old_line_content": "        unquickmap_page();",
          "new_line_content": "                VERIFY(page);",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "static_cast<size_t>(PAGE_SIZE)",
          "new_api": "quickmap_page",
          "old_text": "static_cast<size_t>(PAGE_SIZE)",
          "new_text": "quickmap_page(*page)",
          "old_line_content": "    size_t page_count = ceil_div(size, static_cast<size_t>(PAGE_SIZE));",
          "new_line_content": "        auto* ptr = quickmap_page(*page);",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": "take_contiguous_free_pages",
          "new_api": "release_nonnull",
          "old_text": "physical_region.take_contiguous_free_pages(page_count)",
          "new_text": "page.release_nonnull()",
          "old_line_content": "        auto physical_pages = physical_region.take_contiguous_free_pages(page_count);",
          "new_line_content": "    return page.release_nonnull();",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": "address_space",
          "new_api": "as_ptr",
          "old_text": "process.address_space()",
          "new_text": "cleanup_region->vaddr().as_ptr()",
          "old_line_content": "    enter_address_space(process.address_space());",
          "new_line_content": "                memset(cleanup_region->vaddr().as_ptr(), 0, PAGE_SIZE * page_count);",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": "Processor::flush_tlb(page_directory, vaddr, page_count)",
          "new_api": "VERIFY",
          "old_text": "Processor::flush_tlb(page_directory, vaddr, page_count)",
          "new_text": "VERIFY(current_thread != nullptr)",
          "old_line_content": "    Processor::flush_tlb(page_directory, vaddr, page_count);",
          "new_line_content": "    VERIFY(current_thread != nullptr);",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "get",
          "new_api": "Processor::flush_tlb_local(vaddr, page_count)",
          "old_text": "pd_paddr.get()",
          "new_text": "Processor::flush_tlb_local(vaddr, page_count)",
          "old_line_content": "    if (pte.physical_page_base() != pd_paddr.get()) {",
          "new_line_content": "    Processor::flush_tlb_local(vaddr, page_count);",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": "VirtualAddress",
          "new_api": "get",
          "old_text": "VirtualAddress(KERNEL_QUICKMAP_PD)",
          "new_text": "pd_paddr.get()",
          "old_line_content": "            flush_tlb_local(VirtualAddress(KERNEL_QUICKMAP_PD));",
          "new_line_content": "    if (pte.physical_page_base() != pd_paddr.get()) {",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": "is_locked_by_current_processor",
          "new_api": "VirtualAddress",
          "old_text": "s_mm_lock.is_locked_by_current_processor()",
          "new_text": "VirtualAddress(KERNEL_QUICKMAP_PD)",
          "old_line_content": "    VERIFY(s_mm_lock.is_locked_by_current_processor());",
          "new_line_content": "        flush_tlb_local(VirtualAddress(KERNEL_QUICKMAP_PD));",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "set_writable",
          "new_api": "VirtualAddress",
          "old_text": "pte.set_writable(true)",
          "new_text": "VirtualAddress(KERNEL_QUICKMAP_PD)",
          "old_line_content": "        pte.set_writable(true);",
          "new_line_content": "            flush_tlb_local(VirtualAddress(KERNEL_QUICKMAP_PD));",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": "VirtualAddress",
          "new_api": "get",
          "old_text": "VirtualAddress(KERNEL_QUICKMAP_PT)",
          "new_text": "pt_paddr.get()",
          "old_line_content": "            flush_tlb_local(VirtualAddress(KERNEL_QUICKMAP_PT));",
          "new_line_content": "    if (pte.physical_page_base() != pt_paddr.get()) {",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": "VERIFY_INTERRUPTS_DISABLED",
          "new_api": "VirtualAddress",
          "old_text": "VERIFY_INTERRUPTS_DISABLED()",
          "new_text": "VirtualAddress(KERNEL_QUICKMAP_PT)",
          "old_line_content": "    VERIFY_INTERRUPTS_DISABLED();",
          "new_line_content": "        flush_tlb_local(VirtualAddress(KERNEL_QUICKMAP_PT));",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": "get",
          "new_api": "VirtualAddress",
          "old_text": "vaddr.get()",
          "new_text": "VirtualAddress(KERNEL_QUICKMAP_PT)",
          "old_line_content": "    u32 pte_idx = (vaddr.get() - KERNEL_PT1024_BASE) / PAGE_SIZE;",
          "new_line_content": "            flush_tlb_local(VirtualAddress(KERNEL_QUICKMAP_PT));",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": "flush_tlb_local",
          "new_api": "VERIFY_INTERRUPTS_DISABLED",
          "old_text": "flush_tlb_local(vaddr)",
          "new_text": "VERIFY_INTERRUPTS_DISABLED()",
          "old_line_content": "        flush_tlb_local(vaddr);",
          "new_line_content": "    VERIFY_INTERRUPTS_DISABLED();",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": "as_ptr",
          "new_api": "get_data",
          "old_text": "vaddr.as_ptr()",
          "new_text": "get_data()",
          "old_line_content": "    return vaddr.as_ptr();",
          "new_line_content": "    auto& mm_data = get_data();",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": "get_data",
          "new_api": "get",
          "old_text": "get_data()",
          "new_text": "physical_address.get()",
          "old_line_content": "    auto& mm_data = get_data();",
          "new_line_content": "    if (pte.physical_page_base() != physical_address.get()) {",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": "is_locked",
          "new_api": "get",
          "old_text": "mm_data.m_quickmap_in_use.is_locked()",
          "new_text": "physical_address.get()",
          "old_line_content": "    VERIFY(mm_data.m_quickmap_in_use.is_locked());",
          "new_line_content": "        pte.set_physical_page_base(physical_address.get());",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": "Processor::current_id()",
          "new_api": "set_present",
          "old_text": "Processor::current_id()",
          "new_text": "pte.set_present(true)",
          "old_line_content": "    VirtualAddress vaddr(KERNEL_QUICKMAP_PER_CPU_BASE + Processor::current_id() * PAGE_SIZE);",
          "new_line_content": "        pte.set_present(true);",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": "get",
          "new_api": "set_writable",
          "old_text": "vaddr.get()",
          "new_text": "pte.set_writable(true)",
          "old_line_content": "    u32 pte_idx = (vaddr.get() - KERNEL_PT1024_BASE) / PAGE_SIZE;",
          "new_line_content": "        pte.set_writable(true);",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": "clear",
          "new_api": "flush_tlb_local",
          "old_text": "pte.clear()",
          "new_text": "flush_tlb_local(vaddr)",
          "old_line_content": "    pte.clear();",
          "new_line_content": "        flush_tlb_local(vaddr);",
          "content_same": false
        },
        {
          "line": 1090,
          "old_api": "unlock",
          "new_api": "as_ptr",
          "old_text": "mm_data.m_quickmap_in_use.unlock(mm_data.m_quickmap_prev_flags)",
          "new_text": "vaddr.as_ptr()",
          "old_line_content": "    mm_data.m_quickmap_in_use.unlock(mm_data.m_quickmap_prev_flags);",
          "new_line_content": "    return vaddr.as_ptr();",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": "get_lock",
          "new_api": "VERIFY_INTERRUPTS_DISABLED",
          "old_text": "space.get_lock().is_locked_by_current_processor()",
          "new_text": "VERIFY_INTERRUPTS_DISABLED()",
          "old_line_content": "    VERIFY(space.get_lock().is_locked_by_current_processor());",
          "new_line_content": "    VERIFY_INTERRUPTS_DISABLED();",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": "is_user_address",
          "new_api": "get_data",
          "old_text": "is_user_address(vaddr)",
          "new_text": "get_data()",
          "old_line_content": "    if (!is_user_address(vaddr))",
          "new_line_content": "    auto& mm_data = get_data();",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": "find_user_region_from_vaddr_no_lock",
          "new_api": "get",
          "old_text": "find_user_region_from_vaddr_no_lock(space, vaddr)",
          "new_text": "vaddr.get()",
          "old_line_content": "    auto* region = find_user_region_from_vaddr_no_lock(space, vaddr);",
          "new_line_content": "    u32 pte_idx = (vaddr.get() - KERNEL_PT1024_BASE) / PAGE_SIZE;",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": "get_lock",
          "new_api": "remove",
          "old_text": "m_region_tree.get_lock()",
          "new_text": "m_region_tree.remove(region)",
          "old_line_content": "    SpinlockLocker tree_locker(m_region_tree.get_lock());",
          "new_line_content": "    m_region_tree.remove(region);",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": "size",
          "new_api": "dbgln",
          "old_text": "region.size()",
          "new_text": "dbgln(\"Kernel regions:\")",
          "old_line_content": "            region.size(),",
          "new_line_content": "    dbgln(\"Kernel regions:\");",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": "is_syscall_region",
          "new_api": "dbgln",
          "old_text": "region.is_syscall_region()",
          "new_text": "dbgln(\"BEGIN{}         END{}        SIZE{}       ACCESS NAME\",\n        addr_padding, addr_padding, addr_padding)",
          "old_line_content": "            region.is_syscall_region() ? 'C' : ' ',",
          "new_line_content": "    dbgln(\"BEGIN{}         END{}        SIZE{}       ACCESS NAME\",",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": "get_lock",
          "new_api": "size",
          "old_text": "kernel_page_directory().get_lock()",
          "new_text": "region.size()",
          "old_line_content": "    SpinlockLocker page_lock(kernel_page_directory().get_lock());",
          "new_line_content": "            region.vaddr().offset(region.size() - 1).get(),",
          "content_same": false
        },
        {
          "line": 1147,
          "old_api": "kernel_page_directory",
          "new_api": "is_readable",
          "old_text": "kernel_page_directory()",
          "new_text": "region.is_readable()",
          "old_line_content": "    auto* pte = ensure_pte(kernel_page_directory(), vaddr);",
          "new_line_content": "            region.is_readable() ? 'R' : ' ',",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": "VERIFY",
          "new_api": "is_writable",
          "old_text": "VERIFY(pte)",
          "new_text": "region.is_writable()",
          "old_line_content": "    VERIFY(pte);",
          "new_line_content": "            region.is_writable() ? 'W' : ' ',",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": "is_writable",
          "new_api": "is_executable",
          "old_text": "pte->is_writable()",
          "new_text": "region.is_executable()",
          "old_line_content": "    if (pte->is_writable() == writable)",
          "new_line_content": "            region.is_executable() ? 'X' : ' ',",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": "set_writable",
          "new_api": "is_stack",
          "old_text": "pte->set_writable(writable)",
          "new_text": "region.is_stack()",
          "old_line_content": "    pte->set_writable(writable);",
          "new_line_content": "            region.is_stack() ? 'T' : ' ',",
          "content_same": false
        },
        {
          "line": 1152,
          "old_api": "kernel_page_directory",
          "new_api": "is_syscall_region",
          "old_text": "kernel_page_directory()",
          "new_text": "region.is_syscall_region()",
          "old_line_content": "    flush_tlb(&kernel_page_directory(), vaddr);",
          "new_line_content": "            region.is_syscall_region() ? 'C' : ' ',",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": "VERIFY",
          "new_api": "is_writable",
          "old_text": "VERIFY(m_page_count > 0)",
          "new_text": "pte->is_writable()",
          "old_line_content": "    VERIFY(m_page_count > 0);",
          "new_line_content": "    if (pte->is_writable() == writable)",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": "allocate_committed_physical_page",
          "new_api": "set_writable",
          "old_text": "MM.allocate_committed_physical_page({}, MemoryManager::ShouldZeroFill::Yes)",
          "new_text": "pte->set_writable(writable)",
          "old_line_content": "    return MM.allocate_committed_physical_page({}, MemoryManager::ShouldZeroFill::Yes);",
          "new_line_content": "    pte->set_writable(writable);",
          "content_same": false
        },
        {
          "line": 1179,
          "old_api": "memcpy",
          "new_api": "allocate_committed_physical_page",
          "old_text": "memcpy(page_buffer, quickmapped_page, PAGE_SIZE)",
          "new_text": "MM.allocate_committed_physical_page({}, MemoryManager::ShouldZeroFill::Yes)",
          "old_line_content": "    memcpy(page_buffer, quickmapped_page, PAGE_SIZE);",
          "new_line_content": "    return MM.allocate_committed_physical_page({}, MemoryManager::ShouldZeroFill::Yes);",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": "move",
          "new_api": "uncommit_physical_pages",
          "old_text": "move(vmobject)",
          "new_text": "MM.uncommit_physical_pages({}, 1)",
          "old_line_content": "    auto region = TRY(Memory::Region::create_unplaced(move(vmobject), 0, {}, Memory::Region::Access::ReadWriteExecute));",
          "new_line_content": "    MM.uncommit_physical_pages({}, 1);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1024,
          "old_api": null,
          "new_api": "get_data",
          "old_text": null,
          "new_text": "get_data()",
          "old_line_content": "        // possible that this PD was mapped on a different CPU and we don't",
          "new_line_content": "    auto& mm_data = get_data();",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "region.name()",
          "old_line_content": "}",
          "new_line_content": "            region.name());",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": null,
          "new_api": "paddr",
          "old_text": null,
          "new_text": "directory.m_directory_pages[pdpt_index]->paddr()",
          "old_line_content": "        if (mm_data.m_last_quickmap_pd != pd_paddr)",
          "new_line_content": "    auto pd_paddr = directory.m_directory_pages[pdpt_index]->paddr();",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "pd_paddr.get()",
          "old_line_content": "    }",
          "new_line_content": "        pte.set_physical_page_base(pd_paddr.get());",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": null,
          "new_api": "set_present",
          "old_text": null,
          "new_text": "pte.set_present(true)",
          "old_line_content": "    mm_data.m_last_quickmap_pd = pd_paddr;",
          "new_line_content": "        pte.set_present(true);",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": null,
          "new_api": "set_writable",
          "old_text": null,
          "new_text": "pte.set_writable(true)",
          "old_line_content": "    return (PageDirectoryEntry*)KERNEL_QUICKMAP_PD;",
          "new_line_content": "        pte.set_writable(true);",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": null,
          "new_api": "set_user_allowed",
          "old_text": null,
          "new_text": "pte.set_user_allowed(false)",
          "old_line_content": "}",
          "new_line_content": "        pte.set_user_allowed(false);",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "region.size()",
          "old_line_content": "    SpinlockLocker lock(s_mm_lock);",
          "new_line_content": "            region.size(),",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": null,
          "new_api": "get_lock",
          "old_text": null,
          "new_text": "kernel_page_directory().get_lock()",
          "old_line_content": "}",
          "new_line_content": "    SpinlockLocker page_lock(kernel_page_directory().get_lock());",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": null,
          "new_api": "kernel_page_directory",
          "old_text": null,
          "new_text": "kernel_page_directory()",
          "old_line_content": "NonnullRefPtr<PhysicalPage> CommittedPhysicalPageSet::take_one()",
          "new_line_content": "    auto* pte = ensure_pte(kernel_page_directory(), vaddr);",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": null,
          "new_api": "VERIFY",
          "old_text": null,
          "new_text": "VERIFY(pte)",
          "old_line_content": "{",
          "new_line_content": "    VERIFY(pte);",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": null,
          "new_api": "kernel_page_directory",
          "old_text": null,
          "new_text": "kernel_page_directory()",
          "old_line_content": "}",
          "new_line_content": "    flush_tlb(&kernel_page_directory(), vaddr);",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": null,
          "new_api": "is_locked_by_current_processor",
          "old_text": null,
          "new_text": "s_mm_lock.is_locked_by_current_processor()",
          "old_line_content": "        // possible that this PT was mapped on a different CPU and we don't",
          "new_line_content": "    VERIFY(s_mm_lock.is_locked_by_current_processor());",
          "content_same": false
        },
        {
          "line": 1050,
          "old_api": null,
          "new_api": "get_data",
          "old_text": null,
          "new_text": "get_data()",
          "old_line_content": "        // broadcast the flush. If so, we still need to flush the TLB.",
          "new_line_content": "    auto& mm_data = get_data();",
          "content_same": false
        },
        {
          "line": 1177,
          "old_api": null,
          "new_api": "VERIFY",
          "old_text": null,
          "new_text": "VERIFY(m_page_count > 0)",
          "old_line_content": "    SpinlockLocker locker(s_mm_lock);",
          "new_line_content": "    VERIFY(m_page_count > 0);",
          "content_same": false
        },
        {
          "line": 1053,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "pt_paddr.get()",
          "old_line_content": "    }",
          "new_line_content": "        pte.set_physical_page_base(pt_paddr.get());",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": null,
          "new_api": "set_present",
          "old_text": null,
          "new_text": "pte.set_present(true)",
          "old_line_content": "    mm_data.m_last_quickmap_pt = pt_paddr;",
          "new_line_content": "        pte.set_present(true);",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": null,
          "new_api": "set_writable",
          "old_text": null,
          "new_text": "pte.set_writable(true)",
          "old_line_content": "    return (PageTableEntry*)KERNEL_QUICKMAP_PT;",
          "new_line_content": "        pte.set_writable(true);",
          "content_same": false
        },
        {
          "line": 1056,
          "old_api": null,
          "new_api": "set_user_allowed",
          "old_text": null,
          "new_text": "pte.set_user_allowed(false)",
          "old_line_content": "}",
          "new_line_content": "        pte.set_user_allowed(false);",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": null,
          "new_api": "VERIFY",
          "old_text": null,
          "new_text": "VERIFY(m_page_count > 0)",
          "old_line_content": "{",
          "new_line_content": "    VERIFY(m_page_count > 0);",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": null,
          "new_api": "is_inode",
          "old_text": null,
          "new_text": "vmobject.is_inode()",
          "old_line_content": "            return ENOMEM;",
          "new_line_content": "            if (!vmobject.is_inode())",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "static_cast<InodeVMObject&>(vmobject)",
          "old_text": null,
          "new_text": "static_cast<InodeVMObject&>(vmobject)",
          "old_line_content": "    }",
          "new_line_content": "            auto& inode_vmobject = static_cast<InodeVMObject&>(vmobject);",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": null,
          "new_api": "quickmap_page",
          "old_text": null,
          "new_text": "quickmap_page(physical_page)",
          "old_line_content": "",
          "new_line_content": "    auto* quickmapped_page = quickmap_page(physical_page);",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "release_all_clean_pages",
          "old_text": null,
          "new_text": "inode_vmobject.release_all_clean_pages()",
          "old_line_content": "    if (should_zero_fill == ShouldZeroFill::Yes) {",
          "new_line_content": "            if (auto released_page_count = inode_vmobject.release_all_clean_pages()) {",
          "content_same": false
        },
        {
          "line": 1193,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(page_buffer, quickmapped_page, PAGE_SIZE)",
          "old_line_content": "ErrorOr<NonnullOwnPtr<Region>> MemoryManager::allocate_unbacked_region_anywhere(size_t size, size_t alignment)",
          "new_line_content": "    memcpy(page_buffer, quickmapped_page, PAGE_SIZE);",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": null,
          "new_api": "unquickmap_page",
          "old_text": null,
          "new_text": "unquickmap_page()",
          "old_line_content": "{",
          "new_line_content": "    unquickmap_page();",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": null,
          "new_api": "Memory::AnonymousVMObject::try_create_for_physical_range(address, size)",
          "old_text": null,
          "new_text": "Memory::AnonymousVMObject::try_create_for_physical_range(address, size)",
          "old_line_content": "",
          "new_line_content": "    auto vmobject = TRY(Memory::AnonymousVMObject::try_create_for_physical_range(address, size));",
          "content_same": false
        },
        {
          "line": 1200,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(vmobject)",
          "old_line_content": "}",
          "new_line_content": "    auto region = TRY(Memory::Region::create_unplaced(move(vmobject), 0, {}, Memory::Region::Access::ReadWriteExecute));",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "address.get()",
          "old_line_content": "",
          "new_line_content": "    Memory::VirtualRange range { VirtualAddress { (FlatPtr)address.get() }, size };",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": null,
          "new_api": "dmesgln",
          "old_text": null,
          "new_text": "dmesgln(\"MM: no physical pages available\")",
          "old_line_content": "}",
          "new_line_content": "            dmesgln(\"MM: no physical pages available\");",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": null,
          "new_api": "is_locked_by_current_processor",
          "old_text": null,
          "new_text": "s_mm_lock.is_locked_by_current_processor()",
          "old_line_content": "    }",
          "new_line_content": "    VERIFY(s_mm_lock.is_locked_by_current_processor());",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": null,
          "new_api": "lock",
          "old_text": null,
          "new_text": "mm_data.m_quickmap_in_use.lock()",
          "old_line_content": "}",
          "new_line_content": "    mm_data.m_quickmap_prev_flags = mm_data.m_quickmap_in_use.lock();",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": null,
          "new_api": "kernel_page_directory",
          "old_text": null,
          "new_text": "MM.kernel_page_directory()",
          "old_line_content": "",
          "new_line_content": "    TRY(region->map(MM.kernel_page_directory()));",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": null,
          "new_api": "Processor::current_id()",
          "old_text": null,
          "new_text": "Processor::current_id()",
          "old_line_content": "void MemoryManager::unquickmap_page()",
          "new_line_content": "    VirtualAddress vaddr(KERNEL_QUICKMAP_PER_CPU_BASE + Processor::current_id() * PAGE_SIZE);",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "vaddr.get()",
          "old_line_content": "{",
          "new_line_content": "    u32 pte_idx = (vaddr.get() - KERNEL_PT1024_BASE) / PAGE_SIZE;",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": null,
          "new_api": "Region::create_unbacked()",
          "old_text": null,
          "new_text": "Region::create_unbacked()",
          "old_line_content": "",
          "new_line_content": "    auto region = TRY(Region::create_unbacked());",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(ptr, 0, PAGE_SIZE)",
          "old_line_content": "",
          "new_line_content": "        memset(ptr, 0, PAGE_SIZE);",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": null,
          "new_api": "unquickmap_page",
          "old_text": null,
          "new_text": "unquickmap_page()",
          "old_line_content": "    // We need to make sure we don't touch pages that we have committed to",
          "new_line_content": "        unquickmap_page();",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": null,
          "new_api": "place_anywhere",
          "old_text": null,
          "new_text": "m_region_tree.place_anywhere(*region, RandomizeVirtualAddress::No, size, alignment)",
          "old_line_content": "",
          "new_line_content": "    TRY(m_region_tree.place_anywhere(*region, RandomizeVirtualAddress::No, size, alignment));",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": null,
          "new_api": "set_user_allowed",
          "old_text": null,
          "new_text": "pte.set_user_allowed(false)",
          "old_line_content": "    auto& pte = ((PageTableEntry*)boot_pd_kernel_pt1023)[pte_idx];",
          "new_line_content": "        pte.set_user_allowed(false);",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": null,
          "new_api": "VERIFY",
          "old_text": null,
          "new_text": "VERIFY(!(size % PAGE_SIZE))",
          "old_line_content": "            // it's safe to just unlock here and have MM.allocate_kernel_region do the right thing.",
          "new_line_content": "    VERIFY(!(size % PAGE_SIZE));",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": null,
          "new_api": "static_cast<size_t>(PAGE_SIZE)",
          "old_text": null,
          "new_text": "static_cast<size_t>(PAGE_SIZE)",
          "old_line_content": "",
          "new_line_content": "    size_t page_count = ceil_div(size, static_cast<size_t>(PAGE_SIZE));",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": null,
          "new_api": "is_locked_by_current_processor",
          "old_text": null,
          "new_text": "s_mm_lock.is_locked_by_current_processor()",
          "old_line_content": "",
          "new_line_content": "    VERIFY(s_mm_lock.is_locked_by_current_processor());",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": null,
          "new_api": "is_locked",
          "old_text": null,
          "new_text": "mm_data.m_quickmap_in_use.is_locked()",
          "old_line_content": "        return false;",
          "new_line_content": "    VERIFY(mm_data.m_quickmap_in_use.is_locked());",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": null,
          "new_api": "Processor::current_id()",
          "old_text": null,
          "new_text": "Processor::current_id()",
          "old_line_content": "",
          "new_line_content": "    VirtualAddress vaddr(KERNEL_QUICKMAP_PER_CPU_BASE + Processor::current_id() * PAGE_SIZE);",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": null,
          "new_api": "take_contiguous_free_pages",
          "old_text": null,
          "new_text": "physical_region.take_contiguous_free_pages(page_count)",
          "old_line_content": "            return physical_pages;",
          "new_line_content": "        auto physical_pages = physical_region.take_contiguous_free_pages(page_count);",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "physical_pages.is_empty()",
          "old_line_content": "        }",
          "new_line_content": "        if (!physical_pages.is_empty()) {",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "pte.clear()",
          "old_line_content": "}",
          "new_line_content": "    pte.clear();",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": null,
          "new_api": "flush_tlb_local",
          "old_text": null,
          "new_text": "flush_tlb_local(vaddr)",
          "old_line_content": "",
          "new_line_content": "    flush_tlb_local(vaddr);",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": null,
          "new_api": "unlock",
          "old_text": null,
          "new_text": "mm_data.m_quickmap_in_use.unlock(mm_data.m_quickmap_prev_flags)",
          "old_line_content": "bool MemoryManager::validate_user_stack(AddressSpace& space, VirtualAddress vaddr) const",
          "new_line_content": "    mm_data.m_quickmap_in_use.unlock(mm_data.m_quickmap_prev_flags);",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": null,
          "new_api": "unlock",
          "old_text": null,
          "new_text": "mm_lock.unlock()",
          "old_line_content": "}",
          "new_line_content": "            mm_lock.unlock();",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": null,
          "new_api": "get_lock",
          "old_text": null,
          "new_text": "space.get_lock().is_locked_by_current_processor()",
          "old_line_content": "",
          "new_line_content": "    VERIFY(space.get_lock().is_locked_by_current_processor());",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": null,
          "new_api": "paddr",
          "old_text": null,
          "new_text": "physical_pages[0].paddr()",
          "old_line_content": "{",
          "new_line_content": "                auto cleanup_region = TRY(MM.allocate_kernel_region(physical_pages[0].paddr(), PAGE_SIZE * page_count, \"MemoryManager Allocation Sanitization\"sv, Region::Access::Read | Region::Access::Write));",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": null,
          "new_api": "is_user_address",
          "old_text": null,
          "new_text": "is_user_address(vaddr)",
          "old_line_content": "{",
          "new_line_content": "    if (!is_user_address(vaddr))",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": null,
          "new_api": "find_user_region_from_vaddr_no_lock",
          "old_text": null,
          "new_text": "find_user_region_from_vaddr_no_lock(space, vaddr)",
          "old_line_content": "}",
          "new_line_content": "    auto* region = find_user_region_from_vaddr_no_lock(space, vaddr);",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": null,
          "new_api": "is_stack",
          "old_text": null,
          "new_text": "region->is_stack()",
          "old_line_content": "",
          "new_line_content": "    return region && region->is_user() && region->is_stack();",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": null,
          "new_api": "dmesgln",
          "old_text": null,
          "new_text": "dmesgln(\"MM: no contiguous physical pages available\")",
          "old_line_content": "",
          "new_line_content": "    dmesgln(\"MM: no contiguous physical pages available\");",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": null,
          "new_api": "get_lock",
          "old_text": null,
          "new_text": "space.get_lock()",
          "old_line_content": "    char const* addr_padding = \"\";",
          "new_line_content": "    SpinlockLocker lock(space.get_lock());",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": null,
          "new_api": "validate_user_stack_no_lock",
          "old_text": null,
          "new_text": "validate_user_stack_no_lock(space, vaddr)",
          "old_line_content": "#else",
          "new_line_content": "    return validate_user_stack_no_lock(space, vaddr);",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": null,
          "new_api": "address_space",
          "old_text": null,
          "new_text": "process.address_space()",
          "old_line_content": "{",
          "new_line_content": "    enter_address_space(process.address_space());",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": null,
          "new_api": "is_kernel",
          "old_text": null,
          "new_text": "region.is_kernel()",
          "old_line_content": "    SpinlockLocker lock(s_mm_lock);",
          "new_line_content": "    VERIFY(region.is_kernel());",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": null,
          "new_api": "Thread::current()",
          "old_text": null,
          "new_text": "Thread::current()",
          "old_line_content": "{",
          "new_line_content": "    auto* current_thread = Thread::current();",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": null,
          "new_api": "page_directory",
          "old_text": null,
          "new_text": "space.page_directory().cr3()",
          "old_line_content": "PageDirectoryEntry* MemoryManager::quickmap_pd(PageDirectory& directory, size_t pdpt_index)",
          "new_line_content": "    current_thread->regs().cr3 = space.page_directory().cr3();",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": null,
          "new_api": "page_directory",
          "old_text": null,
          "new_text": "space.page_directory()",
          "old_line_content": "{",
          "new_line_content": "    activate_page_directory(space.page_directory(), current_thread);",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": null,
          "new_api": "get_lock",
          "old_text": null,
          "new_text": "m_region_tree.get_lock()",
          "old_line_content": "}",
          "new_line_content": "    SpinlockLocker tree_locker(m_region_tree.get_lock());",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": null,
          "new_api": "regions",
          "old_text": null,
          "new_text": "m_region_tree.regions()",
          "old_line_content": "",
          "new_line_content": "    for (auto const& region : m_region_tree.regions()) {",
          "content_same": false
        },
        {
          "line": 1143,
          "old_api": null,
          "new_api": "vaddr",
          "old_text": null,
          "new_text": "dbgln(\"{:p} -- {:p} {:p} {:c}{:c}{:c}{:c}{:c}{:c} {}\",\n            region.vaddr().get(),\n            region.vaddr().offset(region.size() - 1).get(),\n            region.size(),\n            region.is_readable() ? 'R' : ' ',\n            region.is_writable() ? 'W' : ' ',\n            region.is_executable() ? 'X' : ' ',\n            region.is_shared() ? 'S' : ' ',\n            region.is_stack() ? 'T' : ' ',\n            region.is_syscall_region() ? 'C' : ' ',\n            region.name())",
          "old_line_content": "void MemoryManager::set_page_writable_direct(VirtualAddress vaddr, bool writable)",
          "new_line_content": "        dbgln(\"{:p} -- {:p} {:p} {:c}{:c}{:c}{:c}{:c}{:c} {}\",",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": null,
          "new_api": "vaddr",
          "old_text": null,
          "new_text": "region.vaddr().get()",
          "old_line_content": "{",
          "new_line_content": "            region.vaddr().get(),",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": null,
          "new_api": "Processor::flush_tlb(page_directory, vaddr, page_count)",
          "old_text": null,
          "new_text": "Processor::flush_tlb(page_directory, vaddr, page_count)",
          "old_line_content": "        // Because we must continue to hold the MM lock while we use this",
          "new_line_content": "    Processor::flush_tlb(page_directory, vaddr, page_count);",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": null,
          "new_api": "is_shared",
          "old_text": null,
          "new_text": "region.is_shared()",
          "old_line_content": "        return;",
          "new_line_content": "            region.is_shared() ? 'S' : ' ',",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": null,
          "new_api": "is_locked_by_current_processor",
          "old_text": null,
          "new_text": "s_mm_lock.is_locked_by_current_processor()",
          "old_line_content": "        // Even though we don't allow this to be called concurrently, it's",
          "new_line_content": "    VERIFY(s_mm_lock.is_locked_by_current_processor());",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1158,
          "old_api": "uncommit_physical_pages",
          "new_api": null,
          "old_text": "MM.uncommit_physical_pages({}, m_page_count)",
          "new_text": null,
          "old_line_content": "        MM.uncommit_physical_pages({}, m_page_count);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": "get_data",
          "new_api": null,
          "old_text": "get_data()",
          "new_text": null,
          "old_line_content": "    auto& mm_data = get_data();",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "get",
          "new_api": null,
          "old_text": "pt_paddr.get()",
          "new_text": null,
          "old_line_content": "    if (pte.physical_page_base() != pt_paddr.get()) {",
          "new_line_content": "        // possible that this PD was mapped on a different CPU and we don't",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": "get",
          "new_api": null,
          "old_text": "pt_paddr.get()",
          "new_text": null,
          "old_line_content": "        pte.set_physical_page_base(pt_paddr.get());",
          "new_line_content": "        // broadcast the flush. If so, we still need to flush the TLB.",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": "set_present",
          "new_api": null,
          "old_text": "pte.set_present(true)",
          "new_text": null,
          "old_line_content": "        pte.set_present(true);",
          "new_line_content": "        if (mm_data.m_last_quickmap_pd != pd_paddr)",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": "set_user_allowed",
          "new_api": null,
          "old_text": "pte.set_user_allowed(false)",
          "new_text": null,
          "old_line_content": "        pte.set_user_allowed(false);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": "VERIFY",
          "new_api": null,
          "old_text": "VERIFY(m_page_count > 0)",
          "new_text": null,
          "old_line_content": "    VERIFY(m_page_count > 0);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": "VirtualAddress",
          "new_api": null,
          "old_text": "VirtualAddress(KERNEL_QUICKMAP_PT)",
          "new_text": null,
          "old_line_content": "        flush_tlb_local(VirtualAddress(KERNEL_QUICKMAP_PT));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1178,
          "old_api": "quickmap_page",
          "new_api": null,
          "old_text": "quickmap_page(physical_page)",
          "new_text": null,
          "old_line_content": "    auto* quickmapped_page = quickmap_page(physical_page);",
          "new_line_content": "    --m_page_count;",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": "unquickmap_page",
          "new_api": null,
          "old_text": "unquickmap_page()",
          "new_text": null,
          "old_line_content": "    unquickmap_page();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": "Memory::AnonymousVMObject::try_create_for_physical_range(address, size)",
          "new_api": null,
          "old_text": "Memory::AnonymousVMObject::try_create_for_physical_range(address, size)",
          "new_text": null,
          "old_line_content": "    auto vmobject = TRY(Memory::AnonymousVMObject::try_create_for_physical_range(address, size));",
          "new_line_content": "    --m_page_count;",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": "get",
          "new_api": null,
          "old_text": "address.get()",
          "new_text": null,
          "old_line_content": "    Memory::VirtualRange range { VirtualAddress { (FlatPtr)address.get() }, size };",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1061,
          "old_api": "is_locked_by_current_processor",
          "new_api": null,
          "old_text": "s_mm_lock.is_locked_by_current_processor()",
          "new_text": null,
          "old_line_content": "    VERIFY(s_mm_lock.is_locked_by_current_processor());",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": "get_data",
          "new_api": null,
          "old_text": "get_data()",
          "new_text": null,
          "old_line_content": "    auto& mm_data = get_data();",
          "new_line_content": "        // Even though we don't allow this to be called concurrently, it's",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "lock",
          "new_api": null,
          "old_text": "mm_data.m_quickmap_in_use.lock()",
          "new_text": null,
          "old_line_content": "    mm_data.m_quickmap_prev_flags = mm_data.m_quickmap_in_use.lock();",
          "new_line_content": "        // possible that this PT was mapped on a different CPU and we don't",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": "kernel_page_directory",
          "new_api": null,
          "old_text": "MM.kernel_page_directory()",
          "new_text": null,
          "old_line_content": "    TRY(region->map(MM.kernel_page_directory()));",
          "new_line_content": "void MemoryManager::copy_physical_page(PhysicalPage& physical_page, u8 page_buffer[PAGE_SIZE])",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": "Processor::current_id()",
          "new_api": null,
          "old_text": "Processor::current_id()",
          "new_text": null,
          "old_line_content": "    VirtualAddress vaddr(KERNEL_QUICKMAP_PER_CPU_BASE + Processor::current_id() * PAGE_SIZE);",
          "new_line_content": "        if (mm_data.m_last_quickmap_pt != pt_paddr)",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": "Region::create_unbacked()",
          "new_api": null,
          "old_text": "Region::create_unbacked()",
          "new_text": null,
          "old_line_content": "    auto region = TRY(Region::create_unbacked());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": "place_anywhere",
          "new_api": null,
          "old_text": "m_region_tree.place_anywhere(*region, RandomizeVirtualAddress::No, size, alignment)",
          "new_text": null,
          "old_line_content": "    TRY(m_region_tree.place_anywhere(*region, RandomizeVirtualAddress::No, size, alignment));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1069,
          "old_api": "get",
          "new_api": null,
          "old_text": "physical_address.get()",
          "new_text": null,
          "old_line_content": "    if (pte.physical_page_base() != physical_address.get()) {",
          "new_line_content": "    return (PageTableEntry*)KERNEL_QUICKMAP_PT;",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": "get",
          "new_api": null,
          "old_text": "physical_address.get()",
          "new_text": null,
          "old_line_content": "        pte.set_physical_page_base(physical_address.get());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": "set_present",
          "new_api": null,
          "old_text": "pte.set_present(true)",
          "new_text": null,
          "old_line_content": "        pte.set_present(true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1072,
          "old_api": "set_writable",
          "new_api": null,
          "old_text": "pte.set_writable(true)",
          "new_text": null,
          "old_line_content": "        pte.set_writable(true);",
          "new_line_content": "u8* MemoryManager::quickmap_page(PhysicalAddress const& physical_address)",
          "content_same": false
        },
        {
          "line": 1073,
          "old_api": "set_user_allowed",
          "new_api": null,
          "old_text": "pte.set_user_allowed(false)",
          "new_text": null,
          "old_line_content": "        pte.set_user_allowed(false);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": "release_nonnull",
          "new_api": null,
          "old_text": "page.release_nonnull()",
          "new_text": null,
          "old_line_content": "    return page.release_nonnull();",
          "new_line_content": "        if (!page) {",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": "VERIFY",
          "new_api": null,
          "old_text": "VERIFY(!(size % PAGE_SIZE))",
          "new_text": null,
          "old_line_content": "    VERIFY(!(size % PAGE_SIZE));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "VERIFY_INTERRUPTS_DISABLED",
          "new_api": null,
          "old_text": "VERIFY_INTERRUPTS_DISABLED()",
          "new_text": null,
          "old_line_content": "    VERIFY_INTERRUPTS_DISABLED();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "is_locked_by_current_processor",
          "new_api": null,
          "old_text": "s_mm_lock.is_locked_by_current_processor()",
          "new_text": null,
          "old_line_content": "    VERIFY(s_mm_lock.is_locked_by_current_processor());",
          "new_line_content": "    auto& pte = ((PageTableEntry*)boot_pd_kernel_pt1023)[pte_idx];",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "physical_pages.is_empty()",
          "new_text": null,
          "old_line_content": "        if (!physical_pages.is_empty()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": "flush_tlb_local",
          "new_api": null,
          "old_text": "flush_tlb_local(vaddr)",
          "new_text": null,
          "old_line_content": "    flush_tlb_local(vaddr);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": "unlock",
          "new_api": null,
          "old_text": "mm_lock.unlock()",
          "new_text": null,
          "old_line_content": "            mm_lock.unlock();",
          "new_line_content": "    SpinlockLocker mm_lock(s_mm_lock);",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": "paddr",
          "new_api": null,
          "old_text": "physical_pages[0].paddr()",
          "new_text": null,
          "old_line_content": "                auto cleanup_region = TRY(MM.allocate_kernel_region(physical_pages[0].paddr(), PAGE_SIZE * page_count, \"MemoryManager Allocation Sanitization\"sv, Region::Access::Read | Region::Access::Write));",
          "new_line_content": "    // We need to make sure we don't touch pages that we have committed to",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": "as_ptr",
          "new_api": null,
          "old_text": "cleanup_region->vaddr().as_ptr()",
          "new_text": null,
          "old_line_content": "                memset(cleanup_region->vaddr().as_ptr(), 0, PAGE_SIZE * page_count);",
          "new_line_content": "    if (m_system_memory_info.physical_pages_uncommitted < page_count)",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "is_stack",
          "new_api": null,
          "old_text": "region->is_stack()",
          "new_text": null,
          "old_line_content": "    return region && region->is_user() && region->is_stack();",
          "new_line_content": "    auto& pte = ((PageTableEntry*)boot_pd_kernel_pt1023)[pte_idx];",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "dmesgln",
          "new_api": null,
          "old_text": "dmesgln(\"MM: no contiguous physical pages available\")",
          "new_text": null,
          "old_line_content": "    dmesgln(\"MM: no contiguous physical pages available\");",
          "new_line_content": "            // region is constructed or destructed. Since we are now done enumerating anyway,",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": "get_lock",
          "new_api": null,
          "old_text": "space.get_lock()",
          "new_text": null,
          "old_line_content": "    SpinlockLocker lock(space.get_lock());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": "validate_user_stack_no_lock",
          "new_api": null,
          "old_text": "validate_user_stack_no_lock(space, vaddr)",
          "new_text": null,
          "old_line_content": "    return validate_user_stack_no_lock(space, vaddr);",
          "new_line_content": "bool MemoryManager::validate_user_stack_no_lock(AddressSpace& space, VirtualAddress vaddr) const",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": "is_kernel",
          "new_api": null,
          "old_text": "region.is_kernel()",
          "new_text": null,
          "old_line_content": "    VERIFY(region.is_kernel());",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": "remove",
          "new_api": null,
          "old_text": "m_region_tree.remove(region)",
          "new_text": null,
          "old_line_content": "    m_region_tree.remove(region);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "Thread::current()",
          "new_api": null,
          "old_text": "Thread::current()",
          "new_text": null,
          "old_line_content": "    auto* current_thread = Thread::current();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": "VERIFY",
          "new_api": null,
          "old_text": "VERIFY(current_thread != nullptr)",
          "new_text": null,
          "old_line_content": "    VERIFY(current_thread != nullptr);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"Kernel regions:\")",
          "new_text": null,
          "old_line_content": "    dbgln(\"Kernel regions:\");",
          "new_line_content": "bool MemoryManager::validate_user_stack(AddressSpace& space, VirtualAddress vaddr) const",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": "page_directory",
          "new_api": null,
          "old_text": "space.page_directory().cr3()",
          "new_text": null,
          "old_line_content": "    current_thread->regs().cr3 = space.page_directory().cr3();",
          "new_line_content": "    return ENOMEM;",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": "page_directory",
          "new_api": null,
          "old_text": "space.page_directory()",
          "new_text": null,
          "old_line_content": "    activate_page_directory(space.page_directory(), current_thread);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"BEGIN{}         END{}        SIZE{}       ACCESS NAME\",\n        addr_padding, addr_padding, addr_padding)",
          "new_text": null,
          "old_line_content": "    dbgln(\"BEGIN{}         END{}        SIZE{}       ACCESS NAME\",",
          "new_line_content": "void MemoryManager::unregister_kernel_region(Region& region)",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "Processor::flush_tlb_local(vaddr, page_count)",
          "new_api": null,
          "old_text": "Processor::flush_tlb_local(vaddr, page_count)",
          "new_text": null,
          "old_line_content": "    Processor::flush_tlb_local(vaddr, page_count);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": "regions",
          "new_api": null,
          "old_text": "m_region_tree.regions()",
          "new_text": null,
          "old_line_content": "    for (auto const& region : m_region_tree.regions()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": "vaddr",
          "new_api": null,
          "old_text": "dbgln(\"{:p} -- {:p} {:p} {:c}{:c}{:c}{:c}{:c}{:c} {}\",\n            region.vaddr().get(),\n            region.vaddr().offset(region.size() - 1).get(),\n            region.size(),\n            region.is_readable() ? 'R' : ' ',\n            region.is_writable() ? 'W' : ' ',\n            region.is_executable() ? 'X' : ' ',\n            region.is_shared() ? 'S' : ' ',\n            region.is_stack() ? 'T' : ' ',\n            region.is_syscall_region() ? 'C' : ' ',\n            region.name())",
          "new_text": null,
          "old_line_content": "        dbgln(\"{:p} -- {:p} {:p} {:c}{:c}{:c}{:c}{:c}{:c} {}\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": "vaddr",
          "new_api": null,
          "old_text": "region.vaddr().get()",
          "new_text": null,
          "old_line_content": "            region.vaddr().get(),",
          "new_line_content": "void MemoryManager::dump_kernel_regions()",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": "size",
          "new_api": null,
          "old_text": "region.size()",
          "new_text": null,
          "old_line_content": "            region.vaddr().offset(region.size() - 1).get(),",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": "is_readable",
          "new_api": null,
          "old_text": "region.is_readable()",
          "new_text": null,
          "old_line_content": "            region.is_readable() ? 'R' : ' ',",
          "new_line_content": "#if ARCH(I386)",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": "is_writable",
          "new_api": null,
          "old_text": "region.is_writable()",
          "new_text": null,
          "old_line_content": "            region.is_writable() ? 'W' : ' ',",
          "new_line_content": "    char const* addr_padding = \"\";",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": "is_executable",
          "new_api": null,
          "old_text": "region.is_executable()",
          "new_text": null,
          "old_line_content": "            region.is_executable() ? 'X' : ' ',",
          "new_line_content": "#else",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": "is_shared",
          "new_api": null,
          "old_text": "region.is_shared()",
          "new_text": null,
          "old_line_content": "            region.is_shared() ? 'S' : ' ',",
          "new_line_content": "    char const* addr_padding = \"        \";",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": "is_locked_by_current_processor",
          "new_api": null,
          "old_text": "s_mm_lock.is_locked_by_current_processor()",
          "new_text": null,
          "old_line_content": "    VERIFY(s_mm_lock.is_locked_by_current_processor());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": "get_data",
          "new_api": null,
          "old_text": "get_data()",
          "new_text": null,
          "old_line_content": "    auto& mm_data = get_data();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1137,
          "old_api": "is_stack",
          "new_api": null,
          "old_text": "region.is_stack()",
          "new_text": null,
          "old_line_content": "            region.is_stack() ? 'T' : ' ',",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "paddr",
          "new_api": null,
          "old_text": "directory.m_directory_pages[pdpt_index]->paddr()",
          "new_text": null,
          "old_line_content": "    auto pd_paddr = directory.m_directory_pages[pdpt_index]->paddr();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": "name",
          "new_api": null,
          "old_text": "region.name()",
          "new_text": null,
          "old_line_content": "            region.name());",
          "new_line_content": "        addr_padding, addr_padding, addr_padding);",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": "get",
          "new_api": null,
          "old_text": "pd_paddr.get()",
          "new_text": null,
          "old_line_content": "        pte.set_physical_page_base(pd_paddr.get());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": "set_present",
          "new_api": null,
          "old_text": "pte.set_present(true)",
          "new_text": null,
          "old_line_content": "        pte.set_present(true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": "set_writable",
          "new_api": null,
          "old_text": "pte.set_writable(true)",
          "new_text": null,
          "old_line_content": "        pte.set_writable(true);",
          "new_line_content": "void MemoryManager::flush_tlb(PageDirectory const* page_directory, VirtualAddress vaddr, size_t page_count)",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": "set_user_allowed",
          "new_api": null,
          "old_text": "pte.set_user_allowed(false)",
          "new_text": null,
          "old_line_content": "        pte.set_user_allowed(false);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": "VirtualAddress",
          "new_api": null,
          "old_text": "VirtualAddress(KERNEL_QUICKMAP_PD)",
          "new_text": null,
          "old_line_content": "        flush_tlb_local(VirtualAddress(KERNEL_QUICKMAP_PD));",
          "new_line_content": "PageDirectoryEntry* MemoryManager::quickmap_pd(PageDirectory& directory, size_t pdpt_index)",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 39,
      "total_additions": 71,
      "total_deletions": 64,
      "total_api_changes": 174
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 14,
        "api_related_lines": 174,
        "non_api_lines": 7,
        "non_api_line_numbers": [
          932,
          935,
          937,
          942,
          943,
          944,
          945
        ]
      }
    },
    "api_calls_before": 612,
    "api_calls_after": 619,
    "diff_info": {
      "added_lines": 14,
      "removed_lines": 0,
      "total_diff_lines": 26
    }
  }
}