{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/57cc248883c69a7d7944b57a5c0ac2355658e165",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/57cc248883c69a7d7944b57a5c0ac2355658e165/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/57cc248883c69a7d7944b57a5c0ac2355658e165/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/57cc248883c69a7d7944b57a5c0ac2355658e165/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 139,
          "old_api": "modulus",
          "new_api": "prime2",
          "old_text": "m_private_key.modulus()",
          "new_text": "m_private_key.prime2().is_zero()",
          "old_line_content": "    auto exp = NumberTheory::ModularPower(in_integer, m_private_key.private_exponent(), m_private_key.modulus());",
          "new_line_content": "    if (m_private_key.prime1().is_zero() || m_private_key.prime2().is_zero()) {",
          "content_same": false
        },
        {
          "line": 140,
          "old_api": "export_data",
          "new_api": "modulus",
          "old_text": "exp.export_data(out)",
          "new_text": "m_private_key.modulus()",
          "old_line_content": "    auto size = exp.export_data(out);",
          "new_line_content": "        m = NumberTheory::ModularPower(in_integer, m_private_key.private_exponent(), m_private_key.modulus());",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": "length",
          "new_api": "prime1",
          "old_text": "m_private_key.length()",
          "new_text": "m_private_key.prime1()",
          "old_line_content": "    auto align = m_private_key.length();",
          "new_line_content": "        auto m1 = NumberTheory::ModularPower(in_integer, m_private_key.exponent1(), m_private_key.prime1());",
          "content_same": false
        },
        {
          "line": 147,
          "old_api": "size",
          "new_api": "VERIFY",
          "old_text": "out.size()",
          "new_text": "VERIFY(m1 >= m2)",
          "old_line_content": "    out = out.slice(out.size() - aligned_size, aligned_size);",
          "new_line_content": "        VERIFY(m1 >= m2);",
          "content_same": false
        },
        {
          "line": 153,
          "old_api": "modulus",
          "new_api": "export_data",
          "old_text": "m_private_key.modulus()",
          "new_text": "m.export_data(out)",
          "old_line_content": "    auto exp = NumberTheory::ModularPower(in_integer, m_private_key.private_exponent(), m_private_key.modulus());",
          "new_line_content": "    auto size = m.export_data(out);",
          "content_same": false
        },
        {
          "line": 154,
          "old_api": "export_data",
          "new_api": "length",
          "old_text": "exp.export_data(out)",
          "new_text": "m_private_key.length()",
          "old_line_content": "    auto size = exp.export_data(out);",
          "new_line_content": "    auto align = m_private_key.length();",
          "content_same": false
        },
        {
          "line": 175,
          "old_api": "Certificate::parse_private_key_info(decoder, {})",
          "new_api": "size",
          "old_text": "Certificate::parse_private_key_info(decoder, {})",
          "new_text": "out.size()",
          "old_line_content": "            auto maybe_key = Certificate::parse_private_key_info(decoder, {});",
          "new_line_content": "    out = out.slice(out.size() - size, size);",
          "content_same": false
        },
        {
          "line": 189,
          "old_api": "parse_rsa_key",
          "new_api": "error",
          "old_text": "parse_rsa_key(decoded_bytes, true, {})",
          "new_text": "maybe_key.error()",
          "old_line_content": "    auto maybe_key = parse_rsa_key(decoded_bytes, true, {});",
          "new_line_content": "                dbgln(\"Failed to parse private key info: {}\", maybe_key.error());",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": "is_error",
          "new_api": "VERIFY_NOT_REACHED",
          "old_text": "maybe_key.is_error()",
          "new_text": "VERIFY_NOT_REACHED()",
          "old_line_content": "    if (maybe_key.is_error()) {",
          "new_line_content": "                VERIFY_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": "decode_pem",
          "new_api": "parse_rsa_key",
          "old_text": "decode_pem(bytes)",
          "new_text": "parse_rsa_key(decoded_bytes, true, {})",
          "old_line_content": "        auto decoded = decode_pem(bytes);",
          "new_line_content": "    auto maybe_key = parse_rsa_key(decoded_bytes, true, {});",
          "content_same": false
        },
        {
          "line": 206,
          "old_api": "Certificate::parse_subject_public_key_info(decoder, {})",
          "new_api": "release_value",
          "old_text": "Certificate::parse_subject_public_key_info(decoder, {})",
          "new_text": "maybe_key.release_value()",
          "old_line_content": "            auto maybe_key = Certificate::parse_subject_public_key_info(decoder, {});",
          "new_line_content": "    m_private_key = maybe_key.release_value().private_key;",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": "parse_rsa_key",
          "new_api": "error",
          "old_text": "parse_rsa_key(decoded_bytes, false, {})",
          "new_text": "maybe_key.error()",
          "old_line_content": "    auto maybe_key = parse_rsa_key(decoded_bytes, false, {});",
          "new_line_content": "                dbgln(\"Failed to parse subject public key info: {}\", maybe_key.error());",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": "is_error",
          "new_api": "VERIFY_NOT_REACHED",
          "old_text": "maybe_key.is_error()",
          "new_text": "VERIFY_NOT_REACHED()",
          "old_line_content": "    if (maybe_key.is_error()) {",
          "new_line_content": "                VERIFY_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": "size",
          "new_api": "parse_rsa_key",
          "old_text": "in.size()",
          "new_text": "parse_rsa_key(decoded_bytes, false, {})",
          "old_line_content": "    if (in.size() > mod_len - 11) {",
          "new_line_content": "    auto maybe_key = parse_rsa_key(decoded_bytes, false, {});",
          "content_same": false
        },
        {
          "line": 233,
          "old_api": "dbgln",
          "new_api": "is_error",
          "old_text": "dbgln(\"message too long :(\")",
          "new_text": "maybe_key.is_error()",
          "old_line_content": "        dbgln(\"message too long :(\");",
          "new_line_content": "    if (maybe_key.is_error()) {",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": "trim",
          "new_api": "error",
          "old_text": "out.trim(0)",
          "new_text": "maybe_key.error()",
          "old_line_content": "        out = out.trim(0);",
          "new_line_content": "        dbgln(\"Failed to parse RSA public key: {}\", maybe_key.error());",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": "size",
          "new_api": "release_value",
          "old_text": "out.size()",
          "new_text": "maybe_key.release_value()",
          "old_line_content": "    if (out.size() < mod_len) {",
          "new_line_content": "    m_public_key = maybe_key.release_value().public_key;",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": "size",
          "new_api": "modulus",
          "old_text": "in.size()",
          "new_text": "m_public_key.modulus().trimmed_length()",
          "old_line_content": "    auto ps_length = mod_len - in.size() - 3;",
          "new_line_content": "    auto mod_len = (m_public_key.modulus().trimmed_length() * sizeof(u32) * 8 + 7) / 8;",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": "resize",
          "new_api": "size",
          "old_text": "ps.resize(ps_length)",
          "new_text": "in.size()",
          "old_line_content": "    ps.resize(ps_length);",
          "new_line_content": "    if (in.size() > mod_len - 11) {",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": "fill_with_random",
          "new_api": "trim",
          "old_text": "fill_with_random(ps)",
          "new_text": "out.trim(0)",
          "old_line_content": "    fill_with_random(ps);",
          "new_line_content": "        out = out.trim(0);",
          "content_same": false
        },
        {
          "line": 256,
          "old_api": "overwrite",
          "new_api": "resize",
          "old_text": "out.overwrite(0, paddings, 2)",
          "new_text": "ps.resize(ps_length)",
          "old_line_content": "    out.overwrite(0, paddings, 2);",
          "new_line_content": "    ps.resize(ps_length);",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": "overwrite",
          "new_api": "fill_with_random",
          "old_text": "out.overwrite(2 + ps_length, paddings, 1)",
          "new_text": "fill_with_random(ps)",
          "old_line_content": "    out.overwrite(2 + ps_length, paddings, 1);",
          "new_line_content": "    fill_with_random(ps);",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": "modulus",
          "new_api": "overwrite",
          "old_text": "m_public_key.modulus().trimmed_length()",
          "new_text": "out.overwrite(0, paddings, 2)",
          "old_line_content": "    auto mod_len = (m_public_key.modulus().trimmed_length() * sizeof(u32) * 8 + 7) / 8;",
          "new_line_content": "    out.overwrite(0, paddings, 2);",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": "size",
          "new_api": "data",
          "old_text": "in.size()",
          "new_text": "ps.data()",
          "old_line_content": "    if (in.size() != mod_len) {",
          "new_line_content": "    out.overwrite(2, ps.data(), ps_length);",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": "size",
          "new_api": "overwrite",
          "old_text": "in.size()",
          "new_text": "out.overwrite(2 + ps_length, paddings, 1)",
          "old_line_content": "        dbgln(\"decryption error: wrong amount of data: {}\", in.size());",
          "new_line_content": "    out.overwrite(2 + ps_length, paddings, 1);",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "trim",
          "new_api": "size",
          "old_text": "out.trim(0)",
          "new_text": "in.size()",
          "old_line_content": "        out = out.trim(0);",
          "new_line_content": "    out.overwrite(3 + ps_length, in.data(), in.size());",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "dbgln",
          "new_api": "RSA::output_size()",
          "old_text": "dbgln(\"invalid padding byte 1 : {}\", out[1])",
          "new_text": "RSA::output_size()",
          "old_line_content": "        dbgln(\"invalid padding byte 1 : {}\", out[1]);",
          "new_line_content": "    if (out.size() < RSA::output_size()) {",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 263,
          "old_api": null,
          "new_api": "get_random<u8>()",
          "old_text": null,
          "new_text": "get_random<u8>()",
          "old_line_content": "",
          "new_line_content": "            ps[i] = get_random<u8>();",
          "content_same": false
        },
        {
          "line": 136,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "in.size()",
          "old_line_content": "    // FIXME: Actually use the private key properly",
          "new_line_content": "    auto in_integer = UnsignedBigInteger::import_data(in.data(), in.size());",
          "content_same": false
        },
        {
          "line": 143,
          "old_api": null,
          "new_api": "prime2",
          "old_text": null,
          "new_text": "m_private_key.prime2()",
          "old_line_content": "    auto aligned_size = (size + align - 1) / align * align;",
          "new_line_content": "        auto m2 = NumberTheory::ModularPower(in_integer, m_private_key.exponent2(), m_private_key.prime2());",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "in.size()",
          "old_line_content": "        return;",
          "new_line_content": "    out = out.trim(3 + ps_length + in.size()); // should be a single block",
          "content_same": false
        },
        {
          "line": 145,
          "old_api": null,
          "new_api": "prime1",
          "old_text": null,
          "new_text": "m_private_key.prime1()",
          "old_line_content": "    for (auto i = size; i < aligned_size; ++i)",
          "new_line_content": "            m1 = m1.plus(m_private_key.prime1());",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "out.size()",
          "old_line_content": "",
          "new_line_content": "    dbgln_if(CRYPTO_DEBUG, \"padded output size: {} buffer size: {}\", 3 + ps_length + in.size(), out.size());",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": null,
          "new_api": "RSA::encrypt(out, out)",
          "old_text": null,
          "new_text": "RSA::encrypt(out, out)",
          "old_line_content": "",
          "new_line_content": "    RSA::encrypt(out, out);",
          "content_same": false
        },
        {
          "line": 149,
          "old_api": null,
          "new_api": "prime1",
          "old_text": null,
          "new_text": "m_private_key.prime1()",
          "old_line_content": "",
          "new_line_content": "        auto h = NumberTheory::Mod(m1.minus(m2).multiplied_by(m_private_key.coefficient()), m_private_key.prime1());",
          "content_same": false
        },
        {
          "line": 150,
          "old_api": null,
          "new_api": "prime2",
          "old_text": null,
          "new_text": "m_private_key.prime2()",
          "old_line_content": "void RSA::sign(ReadonlyBytes in, Bytes& out)",
          "new_line_content": "        m = m2.plus(h.multiplied_by(m_private_key.prime2()));",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": null,
          "new_api": "modulus",
          "old_text": null,
          "new_text": "m_public_key.modulus().trimmed_length()",
          "old_line_content": "        return;",
          "new_line_content": "    auto mod_len = (m_public_key.modulus().trimmed_length() * sizeof(u32) * 8 + 7) / 8;",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "in.size()",
          "old_line_content": "    }",
          "new_line_content": "    if (in.size() != mod_len) {",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "in.size()",
          "old_line_content": "",
          "new_line_content": "        dbgln(\"decryption error: wrong amount of data: {}\", in.size());",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": null,
          "new_api": "trim",
          "old_text": null,
          "new_text": "out.trim(0)",
          "old_line_content": "    if (out[0] != 0x00) {",
          "new_line_content": "        out = out.trim(0);",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "out.size()",
          "old_line_content": "void RSA::verify(ReadonlyBytes in, Bytes& out)",
          "new_line_content": "        out[out.size() - i - 1] = 0; // zero the non-aligned values",
          "content_same": false
        },
        {
          "line": 159,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "out.size()",
          "old_line_content": "{",
          "new_line_content": "    out = out.slice(out.size() - aligned_size, aligned_size);",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": null,
          "new_api": "RSA::decrypt(in, out)",
          "old_text": null,
          "new_text": "RSA::decrypt(in, out)",
          "old_line_content": "",
          "new_line_content": "    RSA::decrypt(in, out);",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "out.size()",
          "old_line_content": "        return;",
          "new_line_content": "        dbgln(\"decryption error: not enough data after decryption: {}\", out.size());",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": null,
          "new_api": "trim",
          "old_text": null,
          "new_text": "out.trim(0)",
          "old_line_content": "    }",
          "new_line_content": "        out = out.trim(0);",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "in.size()",
          "old_line_content": "}",
          "new_line_content": "    auto in_integer = UnsignedBigInteger::import_data(in.data(), in.size());",
          "content_same": false
        },
        {
          "line": 165,
          "old_api": null,
          "new_api": "modulus",
          "old_text": null,
          "new_text": "m_private_key.modulus()",
          "old_line_content": "",
          "new_line_content": "    auto exp = NumberTheory::ModularPower(in_integer, m_private_key.private_exponent(), m_private_key.modulus());",
          "content_same": false
        },
        {
          "line": 166,
          "old_api": null,
          "new_api": "export_data",
          "old_text": null,
          "new_text": "exp.export_data(out)",
          "old_line_content": "void RSA::import_private_key(ReadonlyBytes bytes, bool pem)",
          "new_line_content": "    auto size = exp.export_data(out);",
          "content_same": false
        },
        {
          "line": 167,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "out.size()",
          "old_line_content": "{",
          "new_line_content": "    out = out.slice(out.size() - size, size);",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"invalid padding byte 0 : {}\", out[0])",
          "old_line_content": "",
          "new_line_content": "        dbgln(\"invalid padding byte 0 : {}\", out[0]);",
          "content_same": false
        },
        {
          "line": 172,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "in.size()",
          "old_line_content": "            decoded_bytes = decoded.data;",
          "new_line_content": "    auto in_integer = UnsignedBigInteger::import_data(in.data(), in.size());",
          "content_same": false
        },
        {
          "line": 173,
          "old_api": null,
          "new_api": "modulus",
          "old_text": null,
          "new_text": "m_public_key.modulus()",
          "old_line_content": "        } else if (decoded.type == PEMType::PrivateKey) {",
          "new_line_content": "    auto exp = NumberTheory::ModularPower(in_integer, m_public_key.public_exponent(), m_public_key.modulus());",
          "content_same": false
        },
        {
          "line": 174,
          "old_api": null,
          "new_api": "export_data",
          "old_text": null,
          "new_text": "exp.export_data(out)",
          "old_line_content": "            ASN1::Decoder decoder(decoded.data);",
          "new_line_content": "    auto size = exp.export_data(out);",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"invalid padding byte 1 : {}\", out[1])",
          "old_line_content": "",
          "new_line_content": "        dbgln(\"invalid padding byte 1 : {}\", out[1]);",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "out.size()",
          "old_line_content": "        return;",
          "new_line_content": "    while (offset < out.size() && out[offset])",
          "content_same": false
        },
        {
          "line": 182,
          "old_api": null,
          "new_api": "decode_pem",
          "old_text": null,
          "new_text": "decode_pem(bytes)",
          "old_line_content": "            return;",
          "new_line_content": "        auto decoded = decode_pem(bytes);",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"garbage data, no zero to split padding\")",
          "old_line_content": "}",
          "new_line_content": "        dbgln(\"garbage data, no zero to split padding\");",
          "content_same": false
        },
        {
          "line": 187,
          "old_api": null,
          "new_api": "Certificate::parse_private_key_info(decoder, {})",
          "old_text": null,
          "new_text": "Certificate::parse_private_key_info(decoder, {})",
          "old_line_content": "    }",
          "new_line_content": "            auto maybe_key = Certificate::parse_private_key_info(decoder, {});",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": null,
          "new_api": "is_error",
          "old_text": null,
          "new_text": "maybe_key.is_error()",
          "old_line_content": "",
          "new_line_content": "            if (maybe_key.is_error()) {",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"PS too small\")",
          "old_line_content": "{",
          "new_line_content": "        dbgln(\"PS too small\");",
          "content_same": false
        },
        {
          "line": 193,
          "old_api": null,
          "new_api": "release_value",
          "old_text": null,
          "new_text": "maybe_key.release_value()",
          "old_line_content": "    }",
          "new_line_content": "            m_private_key = maybe_key.release_value().rsa;",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "out.size()",
          "old_line_content": "",
          "new_line_content": "    out = out.slice(offset, out.size() - offset);",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"Expected a PEM encoded private key\")",
          "old_line_content": "",
          "new_line_content": "            dbgln(\"Expected a PEM encoded private key\");",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": null,
          "new_api": "VERIFY_NOT_REACHED",
          "old_text": null,
          "new_text": "VERIFY_NOT_REACHED()",
          "old_line_content": "void RSA::import_public_key(ReadonlyBytes bytes, bool pem)",
          "new_line_content": "            VERIFY_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"FIXME: RSA_PKCS_EME::sign\")",
          "old_line_content": "",
          "new_line_content": "    dbgln(\"FIXME: RSA_PKCS_EME::sign\");",
          "content_same": false
        },
        {
          "line": 202,
          "old_api": null,
          "new_api": "is_error",
          "old_text": null,
          "new_text": "maybe_key.is_error()",
          "old_line_content": "        if (decoded.type == PEMType::RSAPublicKey) {",
          "new_line_content": "    if (maybe_key.is_error()) {",
          "content_same": false
        },
        {
          "line": 203,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "maybe_key.error()",
          "old_line_content": "            decoded_bytes = decoded.data;",
          "new_line_content": "        dbgln(\"Failed to parse RSA private key: {}\", maybe_key.error());",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": null,
          "new_api": "VERIFY_NOT_REACHED",
          "old_text": null,
          "new_text": "VERIFY_NOT_REACHED()",
          "old_line_content": "        } else if (decoded.type == PEMType::PublicKey) {",
          "new_line_content": "        VERIFY_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"FIXME: RSA_PKCS_EME::verify\")",
          "old_line_content": "",
          "new_line_content": "    dbgln(\"FIXME: RSA_PKCS_EME::verify\");",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": null,
          "new_api": "decode_pem",
          "old_text": null,
          "new_text": "decode_pem(bytes)",
          "old_line_content": "            return;",
          "new_line_content": "        auto decoded = decode_pem(bytes);",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": null,
          "new_api": "Certificate::parse_subject_public_key_info(decoder, {})",
          "old_text": null,
          "new_text": "Certificate::parse_subject_public_key_info(decoder, {})",
          "old_line_content": "    }",
          "new_line_content": "            auto maybe_key = Certificate::parse_subject_public_key_info(decoder, {});",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": null,
          "new_api": "is_error",
          "old_text": null,
          "new_text": "maybe_key.is_error()",
          "old_line_content": "",
          "new_line_content": "            if (maybe_key.is_error()) {",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": null,
          "new_api": "release_value",
          "old_text": null,
          "new_text": "maybe_key.release_value()",
          "old_line_content": "    }",
          "new_line_content": "            m_public_key = maybe_key.release_value().rsa;",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"Expected a PEM encoded public key\")",
          "old_line_content": "",
          "new_line_content": "            dbgln(\"Expected a PEM encoded public key\");",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": null,
          "new_api": "VERIFY_NOT_REACHED",
          "old_text": null,
          "new_text": "VERIFY_NOT_REACHED()",
          "old_line_content": "void RSA_PKCS1_EME::encrypt(ReadonlyBytes in, Bytes& out)",
          "new_line_content": "            VERIFY_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": null,
          "new_api": "VERIFY_NOT_REACHED",
          "old_text": null,
          "new_text": "VERIFY_NOT_REACHED()",
          "old_line_content": "        return;",
          "new_line_content": "        VERIFY_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": null,
          "new_api": "dbgln_if",
          "old_text": null,
          "new_text": "dbgln_if(CRYPTO_DEBUG, \"key size: {}\", mod_len)",
          "old_line_content": "    Vector<u8, 8096> ps;",
          "new_line_content": "    dbgln_if(CRYPTO_DEBUG, \"key size: {}\", mod_len);",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"message too long :(\")",
          "old_line_content": "",
          "new_line_content": "        dbgln(\"message too long :(\");",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "out.size()",
          "old_line_content": "    for (size_t i = 0; i < ps_length; ++i) {",
          "new_line_content": "    if (out.size() < mod_len) {",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"output buffer too small\")",
          "old_line_content": "        while (!ps[i])",
          "new_line_content": "        dbgln(\"output buffer too small\");",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "in.size()",
          "old_line_content": "    u8 paddings[] { 0x00, 0x02 };",
          "new_line_content": "    auto ps_length = mod_len - in.size() - 3;",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 257,
          "old_api": "data",
          "new_api": null,
          "old_text": "ps.data()",
          "new_text": null,
          "old_line_content": "    out.overwrite(2, ps.data(), ps_length);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": "size",
          "new_api": null,
          "old_text": "in.size()",
          "new_text": null,
          "old_line_content": "    out.overwrite(3 + ps_length, in.data(), in.size());",
          "new_line_content": "    // since fill_with_random can create zeros (shocking!)",
          "content_same": false
        },
        {
          "line": 260,
          "old_api": "size",
          "new_api": null,
          "old_text": "in.size()",
          "new_text": null,
          "old_line_content": "    out = out.trim(3 + ps_length + in.size()); // should be a single block",
          "new_line_content": "    // we have to go through and un-zero the zeros",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": "size",
          "new_api": null,
          "old_text": "out.size()",
          "new_text": null,
          "old_line_content": "    dbgln_if(CRYPTO_DEBUG, \"padded output size: {} buffer size: {}\", 3 + ps_length + in.size(), out.size());",
          "new_line_content": "        while (!ps[i])",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": "RSA::encrypt(out, out)",
          "new_api": null,
          "old_text": "RSA::encrypt(out, out)",
          "new_text": null,
          "old_line_content": "    RSA::encrypt(out, out);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": "size",
          "new_api": null,
          "old_text": "in.size()",
          "new_text": null,
          "old_line_content": "    auto in_integer = UnsignedBigInteger::import_data(in.data(), in.size());",
          "new_line_content": "    UnsignedBigInteger m;",
          "content_same": false
        },
        {
          "line": 146,
          "old_api": "size",
          "new_api": null,
          "old_text": "out.size()",
          "new_text": null,
          "old_line_content": "        out[out.size() - i - 1] = 0; // zero the non-aligned values",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": "RSA::decrypt(in, out)",
          "new_api": null,
          "old_text": "RSA::decrypt(in, out)",
          "new_text": null,
          "old_line_content": "    RSA::decrypt(in, out);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": "RSA::output_size()",
          "new_api": null,
          "old_text": "RSA::output_size()",
          "new_text": null,
          "old_line_content": "    if (out.size() < RSA::output_size()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": "size",
          "new_api": null,
          "old_text": "out.size()",
          "new_text": null,
          "old_line_content": "        dbgln(\"decryption error: not enough data after decryption: {}\", out.size());",
          "new_line_content": "void RSA_PKCS1_EME::decrypt(ReadonlyBytes in, Bytes& out)",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": "trim",
          "new_api": null,
          "old_text": "out.trim(0)",
          "new_text": null,
          "old_line_content": "        out = out.trim(0);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 152,
          "old_api": "size",
          "new_api": null,
          "old_text": "in.size()",
          "new_text": null,
          "old_line_content": "    auto in_integer = UnsignedBigInteger::import_data(in.data(), in.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 155,
          "old_api": "size",
          "new_api": null,
          "old_text": "out.size()",
          "new_text": null,
          "old_line_content": "    out = out.slice(out.size() - size, size);",
          "new_line_content": "    auto aligned_size = (size + align - 1) / align * align;",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"invalid padding byte 0 : {}\", out[0])",
          "new_text": null,
          "old_line_content": "        dbgln(\"invalid padding byte 0 : {}\", out[0]);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 160,
          "old_api": "size",
          "new_api": null,
          "old_text": "in.size()",
          "new_text": null,
          "old_line_content": "    auto in_integer = UnsignedBigInteger::import_data(in.data(), in.size());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": "modulus",
          "new_api": null,
          "old_text": "m_public_key.modulus()",
          "new_text": null,
          "old_line_content": "    auto exp = NumberTheory::ModularPower(in_integer, m_public_key.public_exponent(), m_public_key.modulus());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 162,
          "old_api": "export_data",
          "new_api": null,
          "old_text": "exp.export_data(out)",
          "new_text": null,
          "old_line_content": "    auto size = exp.export_data(out);",
          "new_line_content": "void RSA::sign(ReadonlyBytes in, Bytes& out)",
          "content_same": false
        },
        {
          "line": 163,
          "old_api": "size",
          "new_api": null,
          "old_text": "out.size()",
          "new_text": null,
          "old_line_content": "    out = out.slice(out.size() - size, size);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": "size",
          "new_api": null,
          "old_text": "out.size()",
          "new_text": null,
          "old_line_content": "    while (offset < out.size() && out[offset])",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": "size",
          "new_api": null,
          "old_text": "out.size()",
          "new_text": null,
          "old_line_content": "    if (offset == out.size()) {",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 170,
          "old_api": "decode_pem",
          "new_api": null,
          "old_text": "decode_pem(bytes)",
          "new_text": null,
          "old_line_content": "        auto decoded = decode_pem(bytes);",
          "new_line_content": "void RSA::verify(ReadonlyBytes in, Bytes& out)",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"garbage data, no zero to split padding\")",
          "new_text": null,
          "old_line_content": "        dbgln(\"garbage data, no zero to split padding\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 176,
          "old_api": "is_error",
          "new_api": null,
          "old_text": "maybe_key.is_error()",
          "new_text": null,
          "old_line_content": "            if (maybe_key.is_error()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 177,
          "old_api": "error",
          "new_api": null,
          "old_text": "maybe_key.error()",
          "new_text": null,
          "old_line_content": "                dbgln(\"Failed to parse private key info: {}\", maybe_key.error());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 178,
          "old_api": "VERIFY_NOT_REACHED",
          "new_api": null,
          "old_text": "VERIFY_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "                VERIFY_NOT_REACHED();",
          "new_line_content": "void RSA::import_private_key(ReadonlyBytes bytes, bool pem)",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"PS too small\")",
          "new_text": null,
          "old_line_content": "        dbgln(\"PS too small\");",
          "new_line_content": "    size_t offset = 2;",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": "release_value",
          "new_api": null,
          "old_text": "maybe_key.release_value()",
          "new_text": null,
          "old_line_content": "            m_private_key = maybe_key.release_value().rsa;",
          "new_line_content": "    if (pem) {",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"Expected a PEM encoded private key\")",
          "new_text": null,
          "old_line_content": "            dbgln(\"Expected a PEM encoded private key\");",
          "new_line_content": "            decoded_bytes = decoded.data;",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": "VERIFY_NOT_REACHED",
          "new_api": null,
          "old_text": "VERIFY_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "            VERIFY_NOT_REACHED();",
          "new_line_content": "        } else if (decoded.type == PEMType::PrivateKey) {",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"FIXME: RSA_PKCS_EME::sign\")",
          "new_text": null,
          "old_line_content": "    dbgln(\"FIXME: RSA_PKCS_EME::sign\");",
          "new_line_content": "    ++offset;",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"FIXME: RSA_PKCS_EME::verify\")",
          "new_text": null,
          "old_line_content": "    dbgln(\"FIXME: RSA_PKCS_EME::verify\");",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 191,
          "old_api": "error",
          "new_api": null,
          "old_text": "maybe_key.error()",
          "new_text": null,
          "old_line_content": "        dbgln(\"Failed to parse RSA private key: {}\", maybe_key.error());",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": "VERIFY_NOT_REACHED",
          "new_api": null,
          "old_text": "VERIFY_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "        VERIFY_NOT_REACHED();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 194,
          "old_api": "release_value",
          "new_api": null,
          "old_text": "maybe_key.release_value()",
          "new_text": null,
          "old_line_content": "    m_private_key = maybe_key.release_value().private_key;",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": "is_error",
          "new_api": null,
          "old_text": "maybe_key.is_error()",
          "new_text": null,
          "old_line_content": "            if (maybe_key.is_error()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": "error",
          "new_api": null,
          "old_text": "maybe_key.error()",
          "new_text": null,
          "old_line_content": "                dbgln(\"Failed to parse subject public key info: {}\", maybe_key.error());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 209,
          "old_api": "VERIFY_NOT_REACHED",
          "new_api": null,
          "old_text": "VERIFY_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "                VERIFY_NOT_REACHED();",
          "new_line_content": "void RSA::import_public_key(ReadonlyBytes bytes, bool pem)",
          "content_same": false
        },
        {
          "line": 212,
          "old_api": "release_value",
          "new_api": null,
          "old_text": "maybe_key.release_value()",
          "new_text": null,
          "old_line_content": "            m_public_key = maybe_key.release_value().rsa;",
          "new_line_content": "    if (pem) {",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"Expected a PEM encoded public key\")",
          "new_text": null,
          "old_line_content": "            dbgln(\"Expected a PEM encoded public key\");",
          "new_line_content": "            decoded_bytes = decoded.data;",
          "content_same": false
        },
        {
          "line": 216,
          "old_api": "VERIFY_NOT_REACHED",
          "new_api": null,
          "old_text": "VERIFY_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "            VERIFY_NOT_REACHED();",
          "new_line_content": "        } else if (decoded.type == PEMType::PublicKey) {",
          "content_same": false
        },
        {
          "line": 222,
          "old_api": "error",
          "new_api": null,
          "old_text": "maybe_key.error()",
          "new_text": null,
          "old_line_content": "        dbgln(\"Failed to parse RSA public key: {}\", maybe_key.error());",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": "VERIFY_NOT_REACHED",
          "new_api": null,
          "old_text": "VERIFY_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "        VERIFY_NOT_REACHED();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 225,
          "old_api": "release_value",
          "new_api": null,
          "old_text": "maybe_key.release_value()",
          "new_text": null,
          "old_line_content": "    m_public_key = maybe_key.release_value().public_key;",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": "modulus",
          "new_api": null,
          "old_text": "m_public_key.modulus().trimmed_length()",
          "new_text": null,
          "old_line_content": "    auto mod_len = (m_public_key.modulus().trimmed_length() * sizeof(u32) * 8 + 7) / 8;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": "dbgln_if",
          "new_api": null,
          "old_text": "dbgln_if(CRYPTO_DEBUG, \"key size: {}\", mod_len)",
          "new_text": null,
          "old_line_content": "    dbgln_if(CRYPTO_DEBUG, \"key size: {}\", mod_len);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"output buffer too small\")",
          "new_text": null,
          "old_line_content": "        dbgln(\"output buffer too small\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": "get_random<u8>()",
          "new_api": null,
          "old_text": "get_random<u8>()",
          "new_text": null,
          "old_line_content": "            ps[i] = get_random<u8>();",
          "new_line_content": "        return;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 27,
      "total_additions": 54,
      "total_deletions": 47,
      "total_api_changes": 128
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 18,
        "api_related_lines": 128,
        "non_api_lines": 5,
        "non_api_line_numbers": [
          137,
          141,
          144,
          148,
          151
        ]
      }
    },
    "api_calls_before": 162,
    "api_calls_after": 183,
    "diff_info": {
      "added_lines": 16,
      "removed_lines": 4,
      "total_diff_lines": 34
    }
  }
}