{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/2ec043c4db309c571660f06e30d52301a1d188d5",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/2ec043c4db309c571660f06e30d52301a1d188d5/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/2ec043c4db309c571660f06e30d52301a1d188d5/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/2ec043c4db309c571660f06e30d52301a1d188d5/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1030,
          "old_api": "ple_offset * reference_fra",
          "new_api": "ce_frame_width), re",
          "old_text": "ple_offset * reference_fra",
          "new_text": "ce_frame_width), re",
          "old_line_content": "        horizontal_convolution_unscaled(bit_depth, intermediate_buffer.data(), width, intermediate_height, reference_start - (sample_offset * reference_frame_width), reference_frame_width, block_context.interpolation_filter, reference_subpixel_x);",
          "new_line_content": "            vertical_convolution_unscaled(bit_depth, block_buffer.data(), width, height, reference_start - (sample_offset * reference_frame_width), reference_frame_width, block_context.interpolation_filter, reference_subpixel_y);",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": "width",
          "new_api": "block_context.frame_cont",
          "old_text": "e_size.width() - x",
          "new_text": "block_context.frame_cont",
          "old_line_content": "        return frame_buffer[row * frame_size.width() + column];",
          "new_line_content": "    auto& frame_buffer = get_output_buffer(plane);",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": "] > NONE.\n    // −",
          "new_api": "width",
          "old_text": " ] > NONE.\n    // −",
          "new_text": "e_size.width() - x",
          "old_line_content": "    auto height_in_frame_buffer = min(height, frame_size.height() - y);",
          "new_line_content": "        return frame_buffer[row * frame_size.width() + column];",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": "dc_q",
          "new_api": "ock_context.column, x, y, width, height, block_index, second_predicted_span));\n\n    for (auto i = 0u; i < height_in_frame_buffer; i++) {\n        for (auto j = 0u; j <",
          "old_text": "dc_q(u8 bit_depth, u8 b)\n{\n    // The function d",
          "new_text": "ock_context.column, x, y, width, height, block_index, second_predicted_span));\n\n    for (auto i = 0u; i < height_in_frame_buffer; i++) {\n        for (auto j = 0u; j <",
          "old_line_content": "            frame_buffer_at(y + i, x + j) = rounded_right_shift(predicted_buffer_at(predicted_span, i, j) + predicted_buffer_at(second_predicted_span, i, j), 1);",
          "new_line_content": "    TRY(predict_inter_block(plane, block_context, ReferenceIndex::Secondary, block_context.row, block_context.column, x, y, width, height, block_index, second_predicted_span));",
          "content_same": false
        },
        {
          "line": 1273,
          "old_api": "auto width_in_frame_b",
          "new_api": "rame[ plane ][ y + i ][ x + j ] is set equal to Clip1( CurrFrame[ plane ][ y + i ][",
          "old_text": "   auto width_in_frame_b",
          "new_text": "rame[ plane ][ y + i ][ x + j ] is set equal to Clip1( CurrFrame[ plane ][ y + i ][",
          "old_line_content": "    auto& current_buffer = get_output_buffer(plane);",
          "new_line_content": "    TRY(inverse_transform_2d<log2_of_block_size>(block_context, dequantized, transform_set));",
          "content_same": false
        },
        {
          "line": 1280,
          "old_api": "_size + j];",
          "new_api": "for (auto j =",
          "old_text": "_size + j];\n      ",
          "new_text": "      for (auto j =",
          "old_line_content": "            auto index = (transform_block_y + i) * frame_size.width() + transform_block_x + j;",
          "new_line_content": "    auto height_in_frame_buffer = min(block_size, frame_size.height() - transform_block_y);",
          "content_same": false
        },
        {
          "line": 1392,
          "old_api": ").\n    for",
          "new_api": "t equal to T.\n    Array<Intermediate, block_size> data_c",
          "old_text": ").\n    for ",
          "new_text": "t equal to T.\n    Array<Intermediate, block_size> data_c",
          "old_line_content": "    AK::TypedTransfer<Intermediate>::copy(data_copy.data(), data.data(), block_size);",
          "new_line_content": "        return DecoderError::corrupted(\"Block size was out of range\"sv);",
          "content_same": false
        },
        {
          "line": 1396,
          "old_api": "rOr<void> Decoder::inverse_",
          "new_api": ").\n    for",
          "old_text": "rOr<void> Decoder::inverse_",
          "new_text": ").\n    for ",
          "old_line_content": "        data[i] = data_copy[brev<log2_of_block_size>(i)];",
          "new_line_content": "    AK::TypedTransfer<Intermediate>::copy(data_copy.data(), data.data(), block_size);",
          "content_same": false
        },
        {
          "line": 1416,
          "old_api": "16, 1 ),",
          "new_api": "onstexpr",
          "old_text": "16, 1 ), ",
          "new_text": "onstexpr ",
          "old_line_content": "    constexpr u8 eighth_block_size = quarter_block_size >> 1;",
          "new_line_content": "    constexpr u8 half_block_size = block_size >> 1;",
          "content_same": false
        },
        {
          "line": 1603,
          "old_api": "// (8.7.1.1) The inverse as",
          "new_api": "/ T[ 2 ] = Round2( s2, 14 )",
          "old_text": "// (8.7.1.1) The inverse as",
          "new_text": "/ T[ 2 ] = Round2( s2, 14 )",
          "old_line_content": "    data[2] = rounded_right_shift(s2, 14);",
          "new_line_content": "    data[0] = rounded_right_shift(s0, 14);",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": "f an intermediate array nam",
          "new_api": "/ T[ 3 ] = Round2( s3, 14 )",
          "old_text": "f an intermediate array nam",
          "new_text": "/ T[ 3 ] = Round2( s3, 14 )",
          "old_line_content": "    data[3] = rounded_right_shift(s3, 14);",
          "new_line_content": "    data[1] = rounded_right_shift(s1, 14);",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": ".3.\n    for (auto i = 0u;",
          "new_api": "30-8*i, 1 ) for i = 0..3.\n    for (auto i = 0u; i < 4; i++)\n        butter",
          "old_text": ".3.\n    for (auto i = 0u; ",
          "new_text": " 30-8*i, 1 ) for i = 0..3.\n    for (auto i = 0u; i < 4; i++)\n        butter",
          "old_line_content": "        butterfly_rotation(data, high_precision_temp.span(), 2 * i, 1 + (2 * i), 30 - (8 * i), true);",
          "new_line_content": "    inverse_asymmetric_discrete_sine_transform_input_array_permutation<3>(data);",
          "content_same": false
        },
        {
          "line": 1673,
          "old_api": "for (auto i = 0u; i < 2; i",
          "new_api": ".3.\n    for (auto i = 0u;",
          "old_text": "for (auto i = 0u; i < 2; i",
          "new_text": ".3.\n    for (auto i = 0u; ",
          "old_line_content": "        hadamard_rotation(high_precision_temp.span(), data, i, 4 + i);",
          "new_line_content": "        butterfly_rotation(data, high_precision_temp.span(), 2 * i, 1 + (2 * i), 30 - (8 * i), true);",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": "0..1.\n    for (auto i = 0u",
          "new_api": "for (auto i = 0u; i < 2; i",
          "old_text": "0..1.\n    for (auto i = 0u",
          "new_text": "for (auto i = 0u; i < 2; i",
          "old_line_content": "        butterfly_rotation(data, high_precision_temp.span(), 4 + (3 * i), 5 + i, 24 - (16 * i), true);",
          "new_line_content": "        hadamard_rotation(high_precision_temp.span(), data, i, 4 + i);",
          "content_same": false
        },
        {
          "line": 1684,
          "old_api": "for (auto i = 0u; i < 2; i++)\n        butterfly",
          "new_api": "i = 0u; i < 2; i++)",
          "old_text": "  for (auto i = 0u; i < 2; i++)\n        butterfly",
          "new_text": "i = 0u; i < 2; i++)\n      ",
          "old_line_content": "        hadamard_rotation_in_place(data, i, 2 + i, false);",
          "new_line_content": "        hadamard_rotation(high_precision_temp.span(), data, 4 + i, 6 + i);",
          "content_same": false
        },
        {
          "line": 1688,
          "old_api": "permutation process specified in section 8.7.1.5 with the input vari",
          "new_api": "for (auto i = 0u; i < 2; i++)\n        butterfly",
          "old_text": " permutation process specified in section 8.7.1.5 with the input vari",
          "new_text": "  for (auto i = 0u; i < 2; i++)\n        butterfly",
          "old_line_content": "        butterfly_rotation_in_place(data, 2 + (4 * i), 3 + (4 * i), 16, true);",
          "new_line_content": "        hadamard_rotation_in_place(data, i, 2 + i, false);",
          "content_same": false
        },
        {
          "line": 1692,
          "old_api": "to -T[ 1+2*i ] for i = 0..3.\n    for (auto i = 0u; i < 4; i++) {\n        aut",
          "new_api": "permutation process specified in section 8.7.1.5 with the input vari",
          "old_text": "to -T[ 1+2*i ] for i = 0..3.\n    for (auto i = 0u; i < 4; i++) {\n        aut",
          "new_text": " permutation process specified in section 8.7.1.5 with the input vari",
          "old_line_content": "    inverse_asymmetric_discrete_sine_transform_output_array_permutation<3>(data);",
          "new_line_content": "        butterfly_rotation_in_place(data, 2 + (4 * i), 3 + (4 * i), 16, true);",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": "7.\n    for (auto i = 0u; i",
          "new_api": "31-4*i, 1 ) for i = 0..7.\n    for (auto i = 0u; i < 8; i++)\n        butter",
          "old_text": "7.\n    for (auto i = 0u; i",
          "new_text": " 31-4*i, 1 ) for i = 0..7.\n    for (auto i = 0u; i < 8; i++)\n        butter",
          "old_line_content": "        butterfly_rotation(data, high_precision_temp.span(), 2 * i, 1 + (2 * i), 31 - (4 * i), true);",
          "new_line_content": "    inverse_asymmetric_discrete_sine_transform_input_array_permutation<4>(data);",
          "content_same": false
        },
        {
          "line": 1728,
          "old_api": "+i ) for i = 0..3.\n    for",
          "new_api": "for (auto i = 0u; i < 4;",
          "old_text": "+i ) for i = 0..3.\n    for",
          "new_text": "  for (auto i = 0u; i < 4;",
          "old_line_content": "        butterfly_rotation(data, high_precision_temp.span(), 8 + (2 * i), 9 + (2 * i), 128 + 28 - (16 * i), true);",
          "new_line_content": "        hadamard_rotation(high_precision_temp.span(), data, i, 8 + i);",
          "content_same": false
        },
        {
          "line": 1735,
          "old_api": "i = 0..1, for j = 0..1.\n    for (auto i = 0u; i <",
          "new_api": "i = 0u; i < 4; i++)",
          "old_text": "i = 0..1, for j = 0..1.\n    for (auto i = 0u; i <",
          "new_text": " i = 0u; i < 4; i++)\n     ",
          "old_line_content": "        hadamard_rotation_in_place(data, i, 4 + i, false);",
          "new_line_content": "        hadamard_rotation(high_precision_temp.span(), data, 8 + i, 12 + i);",
          "content_same": false
        },
        {
          "line": 1744,
          "old_api": "for i = 0..1, for j = 0..1",
          "new_api": "4+8*j+i, 6+8*j+i ) for i",
          "old_text": "for i = 0..1, for j = 0..1",
          "new_text": " 4+8*j+i, 6+8*j+i ) for i ",
          "old_line_content": "            hadamard_rotation(high_precision_temp.span(), data, 4 + (8 * j) + i, 6 + (8 * j) + i);",
          "new_line_content": "            butterfly_rotation(data, high_precision_temp.span(), 4 + (8 * i) + (3 * j), 5 + (8 * i) + j, 24 - (16 * j), true);",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": "// 11. Invoke the ADST output array permutation process specified in section 8.7.1.5 with the input var",
          "new_api": "*i, 48+64*(i^j), 0 ) for i = 0..1, for j = 0..1.\n    for (auto i = 0u",
          "old_text": "    // 11. Invoke the ADST output array permutation process specified in section 8.7.1.5 with the input var",
          "new_text": "*i, 48+64*(i^j), 0 ) for i = 0..1, for j = 0..1.\n    for (auto i = 0u",
          "old_line_content": "            butterfly_rotation_in_place(data, 2 + (4 * j) + (8 * i), 3 + (4 * j) + (8 * i), 48 + (64 * (i ^ j)), false);",
          "new_line_content": "            hadamard_rotation_in_place(data, (8 * j) + i, 2 + (8 * j) + i, false);",
          "content_same": false
        },
        {
          "line": 1757,
          "old_api": "equal to -T[ 1+12*j+2*i ] for i = 0..1, for j = 0..1.\n    for (auto i = 0u;",
          "new_api": "// 11. Invoke the ADST output array permutation process specified in section 8.7.1.5 with the input var",
          "old_text": "equal to -T[ 1+12*j+2*i ] for i = 0..1, for j = 0..1.\n    for (auto i = 0u; ",
          "new_text": "    // 11. Invoke the ADST output array permutation process specified in section 8.7.1.5 with the input var",
          "old_line_content": "    inverse_asymmetric_discrete_sine_transform_output_array_permutation<4>(data);",
          "new_line_content": "            butterfly_rotation_in_place(data, 2 + (4 * j) + (8 * i), 3 + (4 * j) + (8 * i), 48 + (64 * (i ^ j)), false);",
          "content_same": false
        },
        {
          "line": 1927,
          "old_api": "_config.subsampling_y, height);\n                }",
          "new_api": "decoded_size",
          "old_text": "_config.subsampling_y, height);\n                }\n\n               ",
          "new_text": ".decoded_size(plane > 0).wid",
          "old_line_content": "                    width = y_size_to_uv_size(frame_context.color_config.subsampling_x, width);",
          "new_line_content": "                auto width = frame_context.size().width();",
          "content_same": false
        },
        {
          "line": 1928,
          "old_api": "get_output_buffer",
          "new_api": "> 0) {\n                    wi",
          "old_text": "get_output_buffer(plane);\n                auto& frame_store_buffer ",
          "new_text": "> 0) {\n                    wi",
          "old_line_content": "                    height = y_size_to_uv_size(frame_context.color_config.subsampling_y, height);",
          "new_line_content": "                auto height = frame_context.size().height();",
          "content_same": false
        },
        {
          "line": 1931,
          "old_api": "tore_width = width + MV_",
          "new_api": "_config.subsampling_y, height);\n                }",
          "old_text": "tore_width = width + MV_",
          "new_text": "_config.subsampling_y, height);\n                }\n\n               ",
          "old_line_content": "                auto const& original_buffer = get_output_buffer(plane);",
          "new_line_content": "                    width = y_size_to_uv_size(frame_context.color_config.subsampling_x, width);",
          "content_same": false
        },
        {
          "line": 1935,
          "old_api": "width * height);\n                for (auto destination_y = 0u; destination_y < fra",
          "new_api": "tore_width = width + MV_",
          "old_text": " width * height);\n                for (auto destination_y = 0u; destination_y < fra",
          "new_text": "tore_width = width + MV_",
          "old_line_content": "                frame_store_buffer.resize_and_keep_capacity(frame_store_width * frame_store_height);",
          "new_line_content": "                auto const& original_buffer = get_output_buffer(plane);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1034,
          "old_api": null,
          "new_api": "ple_offset * reference_fra",
          "old_text": null,
          "new_text": "ple_offset * reference_fra",
          "old_line_content": "",
          "new_line_content": "        horizontal_convolution_unscaled(bit_depth, intermediate_buffer.data(), width, intermediate_height, reference_start - (sample_offset * reference_frame_width), reference_frame_width, block_context.interpolation_filter, reference_subpixel_x);",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "ce_subpixel_y);\n        re",
          "old_text": null,
          "new_text": "ce_subpixel_y);\n        re",
          "old_line_content": "    // NOTE: Accumulators below are 32-bit to allow high bit-depth videos to decode without overflows.",
          "new_line_content": "        vertical_convolution_unscaled(bit_depth, block_buffer.data(), width, height, intermediate_buffer.data(), width, block_context.interpolation_filter, reference_subpixel_y);",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": null,
          "new_api": "set equal to copyT[ 4*(c^b) + 2",
          "old_text": null,
          "new_text": "set equal to copyT[ 4*(c^b) + 2",
          "old_line_content": "        for (auto a = 0u; a < 2; a++)",
          "new_line_content": "        VERIFY(log2_of_block_size == 3);",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": null,
          "new_api": "destination++;",
          "old_text": null,
          "new_text": "                  destination++;\n          ",
          "old_line_content": "                source += source_end_skip;",
          "new_line_content": "                    *destination = clip_1(bit_depth, rounded_right_shift(accumulated_samples, 7));",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": null,
          "new_api": "3377;\n    c",
          "old_text": null,
          "new_text": "3377;\n    c",
          "old_line_content": "    const i64 sinpi_4_9 = 15212;",
          "new_line_content": "    VERIFY(data.size() == 4);",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": null,
          "new_api": "scan_subpixel += scale_x;",
          "old_text": null,
          "new_text": "               scan_subpixel += scale_x;\n  ",
          "old_line_content": "            source += source_stride;",
          "new_line_content": "                *destination = clip_1(bit_depth, rounded_right_shift(accumulated_samples, 7));",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": null,
          "new_api": "}\n            subpixel_y += scal",
          "old_text": null,
          "new_text": "           }\n            subpixel_y += scal",
          "old_line_content": "        }",
          "new_line_content": "                *destination = clip_1(bit_depth, rounded_right_shift(accumulated_samples, 7));",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": null,
          "new_api": "ple_offset * reference_fra",
          "old_text": null,
          "new_text": "ple_offset * reference_fra",
          "old_line_content": "}",
          "new_line_content": "    horizontal_convolution_scaled(bit_depth, intermediate_buffer.data(), width, intermediate_height, reference_start - (sample_offset * reference_frame_width), reference_frame_width, block_context.interpolation_filter, offset_scaled_block_x & SUBPEL_MASK, scaled_step_x);",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": null,
          "new_api": "ce_subpixel_y, scaled_step",
          "old_text": null,
          "new_text": "ce_subpixel_y, scaled_step",
          "old_line_content": "",
          "new_line_content": "    vertical_convolution_scaled(bit_depth, block_buffer.data(), width, height, intermediate_buffer.data(), width, block_context.interpolation_filter, reference_subpixel_y, scaled_step_y);",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": null,
          "new_api": "// (8.7.1.1) The inverse as",
          "old_text": null,
          "new_text": "// (8.7.1.1) The inverse as",
          "old_line_content": "    // (8.7.1.1) The inverse asymmetric discrete sine transforms also make use of an intermediate array named S.",
          "new_line_content": "    data[2] = rounded_right_shift(s2, 14);",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": null,
          "new_api": "f an intermediate array nam",
          "old_text": null,
          "new_text": "f an intermediate array nam",
          "old_line_content": "    // BitDepth bits of precision is enough to avoid overflow.",
          "new_line_content": "    data[3] = rounded_right_shift(s3, 14);",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": null,
          "new_api": "_context, ReferenceIndex::Primary, block_con",
          "old_text": null,
          "new_text": "_context, ReferenceIndex::Primary, block_con",
          "old_line_content": "    };",
          "new_line_content": "    auto predicted_span = predicted_buffer.span().trim(width * height);",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": null,
          "new_api": "block_context.column, x, y, width, height, block_index, predicted_span));\n    auto predicted_buffer_at = [&](Span<u16> buffer, u32 row, u32 column) -> u16& {",
          "old_text": null,
          "new_text": "block_context.column, x, y, width, height, block_index, predicted_span));\n    auto predicted_buffer_at = [&](Span<u16> buffer, u32 row, u32 column) -> u16& {",
          "old_line_content": "",
          "new_line_content": "    TRY(predict_inter_block(plane, block_context, ReferenceIndex::Primary, block_context.row, block_context.column, x, y, width, height, block_index, predicted_span));",
          "content_same": false
        },
        {
          "line": 1624,
          "old_api": null,
          "new_api": "ce[index_a];",
          "old_text": null,
          "new_text": "ce[index_a];",
          "old_line_content": "    D b = source[index_b];",
          "new_line_content": "    auto cos = cos64(angle);",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": null,
          "new_api": "[index_b];",
          "old_text": null,
          "new_text": "[index_b];\n ",
          "old_line_content": "    // 1. S[ a ] is set equal to T[ a ] * cos64( angle ) - T[ b ] * sin64( angle ).",
          "new_line_content": "    auto sin = sin64(angle);",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": null,
          "new_api": "ze",
          "old_text": null,
          "new_text": "ze(plane > 0);\n    auto",
          "old_line_content": "    };",
          "new_line_content": "    VERIFY(!frame_buffer.is_empty());",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": null,
          "new_api": "2 row, u32 column) -> u16& {\n        return frame_b",
          "old_text": null,
          "new_text": "2 row, u32 column) -> u16& {\n        return frame_b",
          "old_line_content": "",
          "new_line_content": "    auto frame_size = block_context.frame_context.decoded_size(plane > 0);",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": null,
          "new_api": "ht",
          "old_text": null,
          "new_text": "ht() - y);\n\n    //",
          "old_line_content": "    // − If isCompound is equal to 0, CurrFrame[ plane ][ y + i ][ x + j ] is set equal to preds[ 0 ][ i ][ j ] for i = 0..h-1",
          "new_line_content": "    auto width_in_frame_buffer = min(width, frame_size.width() - x);",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": null,
          "new_api": "] > NONE.\n    // −",
          "old_text": null,
          "new_text": " ] > NONE.\n    // −",
          "old_line_content": "    // and j = 0..w-1.",
          "new_line_content": "    auto height_in_frame_buffer = min(height, frame_size.height() - y);",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": null,
          "new_api": "nd rounding.\n// Spec defines the source array as",
          "old_text": null,
          "new_text": "nd rounding.\n// Spec defines the source array as",
          "old_line_content": "// Spec defines the source array as S, and the destination array as T.",
          "new_line_content": "        swap(destination[index_a], destination[index_b]);",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": null,
          "new_api": ") {\n            for (auto j",
          "old_text": null,
          "new_text": ") {\n            for (auto j",
          "old_line_content": "        }",
          "new_line_content": "    if (!block_context.is_compound()) {",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": null,
          "new_api": "Otherwise, CurrFrame[ plane ][ y + i ][",
          "old_text": null,
          "new_text": " Otherwise, CurrFrame[ plane ][ y + i ][ ",
          "old_line_content": "    }",
          "new_line_content": "                frame_buffer_at(y + i, x + j) = predicted_buffer_at(predicted_span, i, j);",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": null,
          "new_api": "n[index_b] = rounded_right_shi",
          "old_text": null,
          "new_text": "n[index_b] = rounded_right_shi",
          "old_line_content": "",
          "new_line_content": "    destination[index_a] = rounded_right_shift(a + b, 14);",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": null,
          "new_api": "ock_context, ReferenceIndex::Secondary, block_conte",
          "old_text": null,
          "new_text": "ock_context, ReferenceIndex::Secondary, block_conte",
          "old_line_content": "        for (auto j = 0u; j < width_in_frame_buffer; j++)",
          "new_line_content": "    auto second_predicted_span = second_predicted_buffer.span().trim(width * height);",
          "content_same": false
        },
        {
          "line": 1652,
          "old_api": null,
          "new_api": "form_8",
          "old_text": null,
          "new_text": "form_8(Span<Intermediate> data",
          "old_line_content": "{",
          "new_line_content": "    destination[index_b] = rounded_right_shift(a - b, 14);",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": null,
          "new_api": "dc_q",
          "old_text": null,
          "new_text": "dc_q(u8 bit_depth, u8 b)\n{\n    // The function d",
          "old_line_content": "}",
          "new_line_content": "            frame_buffer_at(y + i, x + j) = rounded_right_shift(predicted_buffer_at(predicted_span, i, j) + predicted_buffer_at(second_predicted_span, i, j), 1);",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": null,
          "new_api": "sion array",
          "old_text": null,
          "new_text": "sion array ",
          "old_line_content": "    // (8.7.1.1) NOTE - The values in array S require higher precision to avoid overflow. Using signed integers with",
          "new_line_content": "    VERIFY(data.size() == 8);",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": null,
          "new_api": "17, 18,",
          "old_text": null,
          "new_text": " 17, 18, ",
          "old_line_content": "    };",
          "new_line_content": "    constexpr u16 dc_qlookup[3][256] = {",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": null,
          "new_api": "b ) is specified as",
          "old_text": null,
          "new_text": " b ) is specified as ",
          "old_line_content": "{",
          "new_line_content": "    return dc_qlookup[(bit_depth - 8) >> 1][clip_3<u8>(0, 255, b)];",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": null,
          "new_api": ", 19, 20,",
          "old_text": null,
          "new_text": ", 19, 20,",
          "old_line_content": "    };",
          "new_line_content": "    constexpr u16 ac_qlookup[3][256] = {",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": null,
          "new_api": "0..1.\n    for (auto i = 0u",
          "old_text": null,
          "new_text": "0..1.\n    for (auto i = 0u",
          "old_line_content": "",
          "new_line_content": "        butterfly_rotation(data, high_precision_temp.span(), 4 + (3 * i), 5 + i, 24 - (16 * i), true);",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": null,
          "new_api": "native_quantizer_feat",
          "old_text": null,
          "new_text": "native_quantizer_feat",
          "old_line_content": "{",
          "new_line_content": "    return ac_qlookup[(bit_depth - 8) >> 1][clip_3<u8>(0, 255, b)];",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": null,
          "new_api": "to -T[ 1+2*i ] for i = 0..3.\n    for (auto i = 0u; i < 4; i++) {\n        aut",
          "old_text": null,
          "new_text": "to -T[ 1+2*i ] for i = 0..3.\n    for (auto i = 0u; i < 4; i++) {\n        aut",
          "old_line_content": "        auto index = 1 + (2 * i);",
          "new_line_content": "    inverse_asymmetric_discrete_sine_transform_output_array_permutation<3>(data);",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": null,
          "new_api": "tizer_index;\n}\n\nu16 Deco",
          "old_text": null,
          "new_text": "tizer_index;\n}\n\nu16 Deco",
          "old_line_content": "    return base_quantizer_index;",
          "new_line_content": "        return clip_3<u8>(0, 255, data);",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": null,
          "new_api": "ision array",
          "old_text": null,
          "new_text": "ision array",
          "old_line_content": "    // (8.7.1.1) The inverse asymmetric discrete sine transforms also make use of an intermediate array named S.",
          "new_line_content": "    VERIFY(data.size() == 16);",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": null,
          "new_api": "{\n    // NOTE: Delta is selec",
          "old_text": null,
          "new_text": "{\n    // NOTE: Delta is selec",
          "old_line_content": "{",
          "new_line_content": "    return dc_q(bit_depth, static_cast<u8>(base + delta));",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": null,
          "new_api": "7.\n    for (auto i = 0u; i",
          "old_text": null,
          "new_text": "7.\n    for (auto i = 0u; i",
          "old_line_content": "",
          "new_line_content": "        butterfly_rotation(data, high_precision_temp.span(), 2 * i, 1 + (2 * i), 31 - (4 * i), true);",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": null,
          "new_api": "nst& block_context, u32 trans",
          "old_text": null,
          "new_text": "nst& block_context, u32 trans",
          "old_line_content": "{",
          "new_line_content": "    return ac_q(bit_depth, static_cast<u8>(base + delta));",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": null,
          "new_api": "+i ) for i = 0..3.\n    for",
          "old_text": null,
          "new_text": "+i ) for i = 0..3.\n    for",
          "old_line_content": "",
          "new_line_content": "        butterfly_rotation(data, high_precision_temp.span(), 8 + (2 * i), 9 + (2 * i), 128 + 28 - (16 * i), true);",
          "content_same": false
        },
        {
          "line": 1227,
          "old_api": null,
          "new_api": "break;\n    case 3:\n        return reconstruct_templated<3>(plane, block_context, transform_b",
          "old_text": null,
          "new_text": "       break;\n    case 3:\n        return reconstruct_templated<3>(plane, block_context, transform_b",
          "old_line_content": "        break;",
          "new_line_content": "        return reconstruct_templated<2>(plane, block_context, transform_block_x, transform_block_y, transform_set);",
          "content_same": false
        },
        {
          "line": 1739,
          "old_api": null,
          "new_api": "i = 0..1, for j = 0..1.\n    for (auto i = 0u; i <",
          "old_text": null,
          "new_text": "i = 0..1, for j = 0..1.\n    for (auto i = 0u; i <",
          "old_line_content": "        for (auto j = 0u; j < 2; j++)",
          "new_line_content": "        hadamard_rotation_in_place(data, i, 4 + i, false);",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": null,
          "new_api": "break;\n    case 4:\n        return reconstruct_templated<4>(plane, block_context, transform_b",
          "old_text": null,
          "new_text": "       break;\n    case 4:\n        return reconstruct_templated<4>(plane, block_context, transform_b",
          "old_line_content": "        break;",
          "new_line_content": "        return reconstruct_templated<3>(plane, block_context, transform_block_x, transform_block_y, transform_set);",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": null,
          "new_api": "break;\n    case 5:\n        return reconstruct_templated<5>(plane, block_context, transform_b",
          "old_text": null,
          "new_text": "       break;\n    case 5:\n        return reconstruct_templated<5>(plane, block_context, transform_b",
          "old_line_content": "        break;",
          "new_line_content": "        return reconstruct_templated<4>(plane, block_context, transform_block_x, transform_block_y, transform_set);",
          "content_same": false
        },
        {
          "line": 1236,
          "old_api": null,
          "new_api": "break;\n    default:\n        VERIFY_NOT_REACHED();\n    }\n}\n\ntemplate<u8 log2_of_block_size>\nD",
          "old_text": null,
          "new_text": "       break;\n    default:\n        VERIFY_NOT_REACHED();\n    }\n}\n\ntemplate<u8 log2_of_block_size>\nD",
          "old_line_content": "    }",
          "new_line_content": "        return reconstruct_templated<5>(plane, block_context, transform_block_x, transform_block_y, transform_set);",
          "content_same": false
        },
        {
          "line": 1748,
          "old_api": null,
          "new_api": "for i = 0..1, for j = 0..1",
          "old_text": null,
          "new_text": "for i = 0..1, for j = 0..1",
          "old_line_content": "        for (auto j = 0u; j < 2; j++)",
          "new_line_content": "            hadamard_rotation(high_precision_temp.span(), data, 4 + (8 * j) + i, 6 + (8 * j) + i);",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": null,
          "new_api": "ct_templated",
          "old_text": null,
          "new_text": "ct_templated(u8 plan",
          "old_line_content": "template<u8 log2_of_block_size>",
          "new_line_content": "        VERIFY_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": null,
          "new_api": "fying the",
          "old_text": null,
          "new_text": "fying the",
          "old_line_content": "    // 1. Dequant[ i ][ j ] is set equal to ( Tokens[ i * n0 + j ] * get_ac_quant( plane ) ) / dqDenom",
          "new_line_content": "    constexpr Intermediate dq_denominator = log2_of_block_size == 5 ? 2 : 1;",
          "content_same": false
        },
        {
          "line": 1761,
          "old_api": null,
          "new_api": "equal to -T[ 1+12*j+2*i ] for i = 0..1, for j = 0..1.\n    for (auto i = 0u;",
          "old_text": null,
          "new_text": "equal to -T[ 1+12*j+2*i ] for i = 0..1, for j = 0..1.\n    for (auto i = 0u; ",
          "old_line_content": "        for (auto j = 0u; j < 2; j++) {",
          "new_line_content": "    inverse_asymmetric_discrete_sine_transform_output_array_permutation<4>(data);",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": null,
          "new_api": "okens[ i",
          "old_text": null,
          "new_text": "okens[ i ",
          "old_line_content": "    Array<Intermediate, block_size * block_size> dequantized;",
          "new_line_content": "    constexpr auto block_size = 1u << log2_of_block_size;",
          "content_same": false
        },
        {
          "line": 1258,
          "old_api": null,
          "new_api": "ntized[i] = (tokens_raw[i] * ac_quan",
          "old_text": null,
          "new_text": "ntized[i] = (tokens_raw[i] * ac_quan",
          "old_line_content": "",
          "new_line_content": "    auto const* tokens_raw = block_context.residual_tokens.data();",
          "content_same": false
        },
        {
          "line": 1259,
          "old_api": null,
          "new_api": "// 2. Dequan",
          "old_text": null,
          "new_text": "\n\n    // 2. Dequan",
          "old_line_content": "    // 2. Dequant[ 0 ][ 0 ] is set equal to ( Tokens[ 0 ] * get_dc_quant( plane ) ) / dqDenom",
          "new_line_content": "    for (u32 i = 0; i < dequantized.size(); i++) {",
          "content_same": false
        },
        {
          "line": 1780,
          "old_api": null,
          "new_api": "if constexpr (log2_of_block_size == 2) {\n        // −",
          "old_text": null,
          "new_text": "   if constexpr (log2_of_block_size == 2) {\n        // −",
          "old_line_content": "        // − If n is equal to 2, invoke the Inverse ADST4 process specified in section 8.7.1.6.",
          "new_line_content": "        return DecoderError::corrupted(\"Block size was out of range\"sv);",
          "content_same": false
        },
        {
          "line": 1785,
          "old_api": null,
          "new_api": "3) {\n        // − Otherwise if n is equal to 3, i",
          "old_text": null,
          "new_text": " 3) {\n        // − Otherwise if n is equal to 3, i",
          "old_line_content": "        // − Otherwise if n is equal to 3, invoke the Inverse ADST8 process specified in section 8.7.1.7.",
          "new_line_content": "        inverse_asymmetric_discrete_sine_transform_4(data);",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": null,
          "new_api": "auto width_in_frame_b",
          "old_text": null,
          "new_text": "   auto width_in_frame_b",
          "old_line_content": "",
          "new_line_content": "    auto& current_buffer = get_output_buffer(plane);",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "frame_size.width() - transform_block_x);\n    auto h",
          "old_line_content": "    for (auto i = 0u; i < height_in_frame_buffer; i++) {",
          "new_line_content": "    auto frame_size = block_context.frame_context.decoded_size(plane > 0);",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": null,
          "new_api": "height",
          "old_text": null,
          "new_text": "height() - transfo",
          "old_line_content": "        for (auto j = 0u; j < width_in_frame_buffer; j++) {",
          "new_line_content": "    auto width_in_frame_buffer = min(block_size, frame_size.width() - transform_block_x);",
          "content_same": false
        },
        {
          "line": 1790,
          "old_api": null,
          "new_api": "T16 process specified in section 8.7.1.8.\n    retu",
          "old_text": null,
          "new_text": "T16 process specified in section 8.7.1.8.\n    retu",
          "old_line_content": "}",
          "new_line_content": "        return inverse_asymmetric_discrete_sine_transform_8(data);",
          "content_same": false
        },
        {
          "line": 1793,
          "old_api": null,
          "new_api": "d> Decoder::inverse_transform_2d(BlockContext const",
          "old_text": null,
          "new_text": "d> Decoder::inverse_transform_2d(BlockContext const",
          "old_line_content": "ALWAYS_INLINE DecoderErrorOr<void> Decoder::inverse_transform_2d(BlockContext const& block_context, Span<Intermediate> dequantized, TransformSet transform_set)",
          "new_line_content": "    return inverse_asymmetric_discrete_sine_transform_16(data);",
          "content_same": false
        },
        {
          "line": 1284,
          "old_api": null,
          "new_api": "_size + j];",
          "old_text": null,
          "new_text": "_size + j];\n      ",
          "old_line_content": "    }",
          "new_line_content": "            auto index = (transform_block_y + i) * frame_size.width() + transform_block_x + j;",
          "content_same": false
        },
        {
          "line": 1286,
          "old_api": null,
          "new_api": "}\n    }\n\n    return {};\n}\n\ninline DecoderErrorOr<void> Decoder::inverse_walsh_hadamard_trans",
          "old_text": null,
          "new_text": "\n        }\n    }\n\n    return {};\n}\n\ninline DecoderErrorOr<void> Decoder::inverse_walsh_hadamard_trans",
          "old_line_content": "    return {};",
          "new_line_content": "            current_buffer[index] = clip_1(block_context.frame_context.color_config.bit_depth, current_buffer[index] + dequantized_value);",
          "content_same": false
        },
        {
          "line": 1805,
          "old_api": null,
          "new_api": "pan<Inter",
          "old_text": null,
          "new_text": "pan<Inter",
          "old_line_content": "",
          "new_line_content": "    constexpr auto block_size = 1u << log2_of_block_size;",
          "content_same": false
        },
        {
          "line": 1808,
          "old_api": null,
          "new_api": "o i = 0u; i < block_size; i++) {",
          "old_text": null,
          "new_text": "o i = 0u; i < block_size; i++) {\n",
          "old_line_content": "        // 1. Set T[ j ] equal to Dequant[ i ][ j ] for j = 0..(n0-1).",
          "new_line_content": "    Span<Intermediate> row = row_array.span().trim(block_size);",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": null,
          "new_api": "ine i32 Decoder::cos64(u8 angle)\n{\n    const i32",
          "old_text": null,
          "new_text": "ine i32 Decoder::cos64(u8 angle)\n{\n    const i32 ",
          "old_line_content": "",
          "new_line_content": "        return DecoderError::corrupted(\"Block size was not 4\"sv);",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": null,
          "new_api": "3] = { 16384, 16364, 16305, 162",
          "old_text": null,
          "new_text": "3] = { 16384, 16364, 16305, 162",
          "old_line_content": "{",
          "new_line_content": "    return DecoderError::not_implemented();",
          "content_same": false
        },
        {
          "line": 1819,
          "old_api": null,
          "new_api": "_set.second_transform) {\n        case TransformType::DCT:",
          "old_text": null,
          "new_text": "_set.second_transform) {\n        case TransformType::DCT:\n  ",
          "old_line_content": "        case TransformType::DCT:",
          "new_line_content": "            TRY(inverse_walsh_hadamard_transform(row, log2_of_block_size, 2));",
          "content_same": false
        },
        {
          "line": 1827,
          "old_api": null,
          "new_api": "process as specified in section 8.7.1.3 with the input variable n.",
          "old_text": null,
          "new_text": "process as specified in section 8.7.1.3 with the input variable n.\n         ",
          "old_line_content": "        case TransformType::ADST:",
          "new_line_content": "            TRY(inverse_discrete_cosine_transform_array_permutation<log2_of_block_size>(row));",
          "content_same": false
        },
        {
          "line": 1829,
          "old_api": null,
          "new_api": "// 4. Otherwise (TxType is equal to DCT_ADST or TxTy",
          "old_text": null,
          "new_text": "      // 4. Otherwise (TxType is equal to DCT_ADST or TxTy",
          "old_line_content": "            //    process as specified in section 8.7.1.9 with input variable n.",
          "new_line_content": "            TRY(inverse_discrete_cosine_transform<log2_of_block_size>(row));",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": null,
          "new_api": "turn DecoderError::corrupted(\"Unknown tx_type\"sv);\n        }",
          "old_text": null,
          "new_text": "turn DecoderError::corrupted(\"Unknown tx_type\"sv);\n        }\n\n     ",
          "old_line_content": "        }",
          "new_line_content": "            TRY(inverse_asymmetric_discrete_sine_transform<log2_of_block_size>(row));",
          "content_same": false
        },
        {
          "line": 1837,
          "old_api": null,
          "new_api": "(n0-1).\n        for (auto j = 0u; j < block_",
          "old_text": null,
          "new_text": "(n0-1).\n        for (auto j = 0u; j < block_",
          "old_line_content": "        for (auto j = 0u; j < block_size; j++)",
          "new_line_content": "            return DecoderError::corrupted(\"Unknown tx_type\"sv);",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": null,
          "new_api": "line void Decoder:",
          "old_text": null,
          "new_text": "line void Decoder:",
          "old_line_content": "inline void Decoder::butterfly_rotation_in_place(Span<Intermediate> data, size_t index_a, size_t index_b, u8 angle, bool flip)",
          "new_line_content": "    return cos64(angle - 32u);",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": null,
          "new_api": "gle ) - T[ b",
          "old_text": null,
          "new_text": "gle ) - T[ b",
          "old_line_content": "    // 2. The variable y is set equal to T[ a ] * sin64( angle ) + T[ b ] * cos64( angle ).",
          "new_line_content": "    auto cos = cos64(angle);",
          "content_same": false
        },
        {
          "line": 1335,
          "old_api": null,
          "new_api": ").\n    i64",
          "old_text": null,
          "new_text": " ).\n    i64 ",
          "old_line_content": "    i64 rotated_b = data[index_a] * sin + data[index_b] * cos;",
          "new_line_content": "    auto sin = sin64(angle);",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": null,
          "new_api": "r (auto j = 0u; j < block_size; j++)",
          "old_text": null,
          "new_text": "r (auto j = 0u; j < block_size; j++)",
          "old_line_content": "        // 1. Set T[ i ] equal to Dequant[ i ][ j ] for i = 0..(n0-1).",
          "new_line_content": "    auto column = column_array.span().trim(block_size);",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": null,
          "new_api": "] = rounded_right_shift(rotated_b,",
          "old_text": null,
          "new_text": "] = rounded_right_shift(rotated_b,",
          "old_line_content": "    // The function B( a ,b, angle, 1 ) performs a butterfly rotation and flip specified by the following ordered steps:",
          "new_line_content": "    data[index_a] = rounded_right_shift(rotated_a, 14);",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": null,
          "new_api": "tion and flip specified by the fol",
          "old_text": null,
          "new_text": "tion and flip specified by the fol",
          "old_line_content": "    // 2. The contents of T[ a ] and T[ b ] are exchanged.",
          "new_line_content": "    data[index_b] = rounded_right_shift(rotated_b, 14);",
          "content_same": false
        },
        {
          "line": 1857,
          "old_api": null,
          "new_api": "orm_set.first_transform) {\n        case TransformType::DCT:",
          "old_text": null,
          "new_text": "orm_set.first_transform) {\n        case TransformType::DCT:\n   ",
          "old_line_content": "        case TransformType::DCT:",
          "new_line_content": "            TRY(inverse_walsh_hadamard_transform(column, log2_of_block_size, 2));",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": null,
          "new_api": "es saved into the array T by this",
          "old_text": null,
          "new_text": "es saved into the array T by this ",
          "old_line_content": "    // Note: Since bounds checks just ensure that we will not have resulting values that will overflow, it's non-fatal",
          "new_line_content": "        swap(data[index_a], data[index_b]);",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": null,
          "new_api": "CT process as specified in section 8.7.1.3 with the input variable n.",
          "old_text": null,
          "new_text": "CT process as specified in section 8.7.1.3 with the input variable n.\n         ",
          "old_line_content": "        case TransformType::ADST:",
          "new_line_content": "            TRY(inverse_discrete_cosine_transform_array_permutation<log2_of_block_size>(column));",
          "content_same": false
        },
        {
          "line": 1867,
          "old_api": null,
          "new_api": "// 4. Otherwise (TxType is equal to ADST_DCT or TxTy",
          "old_text": null,
          "new_text": "         // 4. Otherwise (TxType is equal to ADST_DCT or TxTy",
          "old_line_content": "            //    process as specified in section 8.7.1.9 with input variable n.",
          "new_line_content": "            TRY(inverse_discrete_cosine_transform<log2_of_block_size>(column));",
          "content_same": false
        },
        {
          "line": 1872,
          "old_api": null,
          "new_api": "VERIFY_NOT_REACHED();\n        }\n\n        // 5. If Lossless is equal t",
          "old_text": null,
          "new_text": " VERIFY_NOT_REACHED();\n        }\n\n        // 5. If Lossless is equal t",
          "old_line_content": "        }",
          "new_line_content": "            TRY(inverse_asymmetric_discrete_sine_transform<log2_of_block_size>(column));",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": null,
          "new_api": "e following ordered st",
          "old_text": null,
          "new_text": "e following ordered st",
          "old_line_content": "    // 1. The variable x is set equal to T[ a ].",
          "new_line_content": "        swap(index_a, index_b);",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": null,
          "new_api": "0..(n0-1).\n        f",
          "old_text": null,
          "new_text": "0..(n0-1).\n        f",
          "old_line_content": "        for (auto i = 0u; i < block_size; i++)",
          "new_line_content": "            VERIFY_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 1887,
          "old_api": null,
          "new_api": "eference_frames",
          "old_text": null,
          "new_text": "eference_frames(FrameContext c",
          "old_line_content": "",
          "new_line_content": "                dequantized[index] = rounded_right_shift(dequantized[index], min(6, log2_of_block_size + 2));",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": null,
          "new_api": "on of the",
          "old_text": null,
          "new_text": "on of the",
          "old_line_content": "    if (log2_of_block_size < 2 || log2_of_block_size > 5)",
          "new_line_content": "    constexpr u8 block_size = 1 << log2_of_block_size;",
          "content_same": false
        },
        {
          "line": 1905,
          "old_api": null,
          "new_api": "mes[i];\n\n            // − RefFrameWidth[ i ] is set equ",
          "old_text": null,
          "new_text": "mes[i];\n\n            // − RefFrameWidth[ i ] is set equ",
          "old_line_content": "            // − RefFrameHeight[ i ] is set equal to FrameHeight.",
          "new_line_content": "        if (frame_context.should_update_reference_frame_at_index(i)) {",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": null,
          "new_api": "mpling_x = frame_con",
          "old_text": null,
          "new_text": "mpling_x = frame_con",
          "old_line_content": "            reference_frame.subsampling_y = frame_context.color_config.subsampling_y;",
          "new_line_content": "            reference_frame.size = frame_context.size();",
          "content_same": false
        },
        {
          "line": 1400,
          "old_api": null,
          "new_api": "rOr<void> Decoder::inverse_",
          "old_text": null,
          "new_text": "rOr<void> Decoder::inverse_",
          "old_line_content": "",
          "new_line_content": "        data[i] = data_copy[brev<log2_of_block_size>(i)];",
          "content_same": false
        },
        {
          "line": 1411,
          "old_api": null,
          "new_api": "riable n1",
          "old_text": null,
          "new_text": "riable n1",
          "old_line_content": "    // 2.2. The variable n1 is set equal to 1<<(n-1).",
          "new_line_content": "    constexpr u8 block_size = 1 << log2_of_block_size;",
          "content_same": false
        },
        {
          "line": 1929,
          "old_api": null,
          "new_api": "ntext.color_config.subsampling_x, width);",
          "old_text": null,
          "new_text": "ntext.color_config.subsampling_x, width);\n   ",
          "old_line_content": "                }",
          "new_line_content": "                auto stride = frame_context.decoded_size(plane > 0).width();",
          "content_same": false
        },
        {
          "line": 1418,
          "old_api": null,
          "new_api": ").\n    co",
          "old_text": null,
          "new_text": ").\n    co",
          "old_line_content": "    // 2.5 If n is equal to 2, invoke B( 0, 1, 16, 1 ), otherwise recursively invoke the inverse DCT defined in this",
          "new_line_content": "    constexpr u8 quarter_block_size = half_block_size >> 1;",
          "content_same": false
        },
        {
          "line": 1420,
          "old_api": null,
          "new_api": "16, 1 ),",
          "old_text": null,
          "new_text": "16, 1 ), ",
          "old_line_content": "    if constexpr (log2_of_block_size == 2)",
          "new_line_content": "    constexpr u8 eighth_block_size = quarter_block_size >> 1;",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": null,
          "new_api": "get_output_buffer",
          "old_text": null,
          "new_text": "get_output_buffer(plane);\n                auto& frame_store_buffer ",
          "old_line_content": "                auto& frame_store_buffer = reference_frame.frame_planes[plane];",
          "new_line_content": "                    height = y_size_to_uv_size(frame_context.color_config.subsampling_y, height);",
          "content_same": false
        },
        {
          "line": 1425,
          "old_api": null,
          "new_api": "log2_of_block_size - 1>(data));\n\n    // 2.6 Invok",
          "old_text": null,
          "new_text": "log2_of_block_size - 1>(data));\n\n    // 2.6 Invok",
          "old_line_content": "    // 2.6 Invoke B( n1+i, n0-1-i, 32-brev( 5, n1+i), 0 ) for i = 0..(n2-1).",
          "new_line_content": "        butterfly_rotation_in_place(data, 0, 1, 16, true);",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": null,
          "new_api": "rev",
          "old_text": null,
          "new_text": "rev( 5, n1+i), 0 ) for i = 0..(n2-1).\n    for (auto i = 0u; i <",
          "old_line_content": "        auto index = half_block_size + i;",
          "new_line_content": "        TRY(inverse_discrete_cosine_transform<log2_of_block_size - 1>(data));",
          "content_same": false
        },
        {
          "line": 1939,
          "old_api": null,
          "new_api": "width * height);\n                for (auto destination_y = 0u; destination_y < fra",
          "old_text": null,
          "new_text": " width * height);\n                for (auto destination_y = 0u; destination_y < fra",
          "old_line_content": "                    // Offset the source row by the motion vector border and then clamp it to the range of 0...height.",
          "new_line_content": "                frame_store_buffer.resize_and_keep_capacity(frame_store_width * frame_store_height);",
          "content_same": false
        },
        {
          "line": 1941,
          "old_api": null,
          "new_api": "on_y++) {",
          "old_text": null,
          "new_text": "on_y++) {\n            ",
          "old_line_content": "                    // inter-prediction.",
          "new_line_content": "                VERIFY(original_buffer.size() >= width * height);",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": null,
          "new_api": "ock_size >= 3)",
          "old_text": null,
          "new_text": "ock_size >= 3)",
          "old_line_content": "    if constexpr (log2_of_block_size >= 3) {",
          "new_line_content": "        butterfly_rotation_in_place(data, index, block_size - 1 - i, 32 - brev<5>(index), false);",
          "content_same": false
        },
        {
          "line": 1946,
          "old_api": null,
          "new_api": "[source_y * stride];\n                    auto* destination = &frame_store_b",
          "old_text": null,
          "new_text": "[source_y * stride];\n                    auto* destination = &frame_store_b",
          "old_line_content": "                }",
          "new_line_content": "                    auto source_y = min(destination_y >= MV_BORDER ? destination_y - MV_BORDER : 0, height - 1);",
          "content_same": false
        },
        {
          "line": 1949,
          "old_api": null,
          "new_api": "auto destination_y = 0u; destination_y < frame_store_height; destination_y++) {",
          "old_text": null,
          "new_text": "auto destination_y = 0u; destination_y < frame_store_height; destination_y++) {\n            ",
          "old_line_content": "                    // Stretch the leftmost samples out into the border.",
          "new_line_content": "                    AK::TypedTransfer<RemoveReference<decltype(*destination)>>::copy(destination, source, width);",
          "content_same": false
        },
        {
          "line": 1441,
          "old_api": null,
          "new_api": "ual to 5:\n    if constexpr (log2_of_block_size == 5)",
          "old_text": null,
          "new_text": "ual to 5:\n    if constexpr (log2_of_block_size == 5) ",
          "old_line_content": "",
          "new_line_content": "                hadamard_rotation_in_place(data, index, index + 1, j);",
          "content_same": false
        },
        {
          "line": 1454,
          "old_api": null,
          "new_api": "nvoke H( n1+n3*j+i, n1+n2-5+n3*j-i, j&1 ) for i = 0..1, j = 0..3",
          "old_text": null,
          "new_text": "nvoke H( n1+n3*j+i, n1+n2-5+n3*j-i, j&1 ) for i = 0..1, j = 0..3",
          "old_line_content": "        // b. Invoke H( n1+n3*j+i, n1+n2-5+n3*j-i, j&1 ) for i = 0..1, j = 0..3.",
          "new_line_content": "                butterfly_rotation_in_place(data, index_a, index_b, angle, true);",
          "content_same": false
        },
        {
          "line": 1972,
          "old_api": null,
          "new_api": "block_contexts",
          "old_text": null,
          "new_text": "2d(frame_context.block_contexts()));",
          "old_line_content": "        // − PrevMvs[ row ][ col ][ list ][ comp ] is set equal to Mvs[ row ][ col ][ list ][ comp ] for row = 0..MiRows-1,",
          "new_line_content": "    if (!frame_context.shows_existing_frame()) {",
          "content_same": false
        },
        {
          "line": 1973,
          "old_api": null,
          "new_api": "row = 0..MiRows-1,\n        //",
          "old_text": null,
          "new_text": " row = 0..MiRows-1,\n        //",
          "old_line_content": "        // for col = 0..MiCols-1, for list = 0..1, for comp = 0..1.",
          "new_line_content": "        DECODER_TRY_ALLOC(m_parser->m_previous_block_contexts.try_resize_to_match_other_vector2d(frame_context.block_contexts()));",
          "content_same": false
        },
        {
          "line": 1463,
          "old_api": null,
          "new_api": "If n is greater than or equal to 4:\n    if constexpr (log2_of_b",
          "old_text": null,
          "new_text": " If n is greater than or equal to 4:\n    if constexpr (log2_of_b",
          "old_line_content": "",
          "new_line_content": "                hadamard_rotation_in_place(data, index_a, index_b, (j & 1) != 0);",
          "content_same": false
        },
        {
          "line": 1984,
          "old_api": null,
          "new_api": "copy_to",
          "old_text": null,
          "new_text": "k_contexts().copy_to(m_parser->m_pre",
          "old_line_content": "                persistent_context.segment_id = 0;",
          "new_line_content": "        bool keep_segment_ids = !frame_context.shows_existing_frame() && frame_context.segmentation_enabled && frame_context.use_full_segment_id_tree;",
          "content_same": false
        },
        {
          "line": 1985,
          "old_api": null,
          "new_api": "sistent_context = PersistentBlockContext(context);\n            if (!keep_segment_ids)\n                persistent_context.segment_id = 0;\n            return persistent_context;\n        });\n    }\n\n    return {};\n}\n\n}",
          "old_text": null,
          "new_text": "sistent_context = PersistentBlockContext(context);\n            if (!keep_segment_ids)\n                persistent_context.segment_id = 0;\n            return persistent_context;\n        });\n    }\n\n    return {};\n}\n\n}\n",
          "old_line_content": "            return persistent_context;",
          "new_line_content": "        frame_context.block_contexts().copy_to(m_parser->m_previous_block_contexts, [keep_segment_ids](FrameBlockContext context) {",
          "content_same": false
        },
        {
          "line": 1986,
          "old_api": null,
          "new_api": "tent_context;\n        });\n    }",
          "old_text": null,
          "new_text": "tent_context;\n        });\n    }",
          "old_line_content": "        });",
          "new_line_content": "            auto persistent_context = PersistentBlockContext(context);",
          "content_same": false
        },
        {
          "line": 1475,
          "old_api": null,
          "new_api": "// b. Invoke H( n1+n2*j+i, n1+n2-1+n2*j-i, j&1 ) for i = 0..(2n-7), j =",
          "old_text": null,
          "new_text": " // b. Invoke H( n1+n2*j+i, n1+n2-1+n2*j-i, j&1 ) for i = 0..(2n-7), j =",
          "old_line_content": "        // b. Invoke H( n1+n2*j+i, n1+n2-1+n2*j-i, j&1 ) for i = 0..(2n-7), j = 0..1.",
          "new_line_content": "                butterfly_rotation_in_place(data, index_a, index_b, 24 + (48 * j), true);",
          "content_same": false
        },
        {
          "line": 1484,
          "old_api": null,
          "new_api": "If n is greater than or equal to 3:\n    if constexpr (log2_of_b",
          "old_text": null,
          "new_text": " If n is greater than or equal to 3:\n    if constexpr (log2_of_b",
          "old_line_content": "",
          "new_line_content": "                hadamard_rotation_in_place(data, index_a, index_b, (j & 1) != 0);",
          "content_same": false
        },
        {
          "line": 973,
          "old_api": null,
          "new_api": "memc",
          "old_text": null,
          "new_text": "               memc",
          "old_line_content": "                reference_scan_line += reference_frame_width;",
          "new_line_content": "            auto* destination_scan_line = block_buffer.data();",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": null,
          "new_api": "_scan_line));\n                reference_scan_line += reference_frame_width;",
          "old_text": null,
          "new_text": "_scan_line));\n                reference_scan_line += reference_frame_width;\n              ",
          "old_line_content": "",
          "new_line_content": "                memcpy(destination_scan_line, reference_scan_line, width * sizeof(*destination_scan_line));",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": null,
          "new_api": "1-i, 0 ) for i = 0..(n1-1).\n    for (auto i = 0u; i < half_bl",
          "old_text": null,
          "new_text": "1-i, 0 ) for i = 0..(n1-1).\n    for (auto i = 0u; i < half_bl",
          "old_line_content": "    // 7. Invoke H( i, n0-1-i, 0 ) for i = 0..(n1-1).",
          "new_line_content": "            butterfly_rotation_in_place(data, index_a, index_b, 16, true);",
          "content_same": false
        },
        {
          "line": 1501,
          "old_api": null,
          "new_api": "ck_size>\ninline void Decoder::inverse_asymmetric_discrete_sine",
          "old_text": null,
          "new_text": "ck_size>\ninline void Decoder::inverse_asymmetric_discrete_sine",
          "old_line_content": "",
          "new_line_content": "        hadamard_rotation_in_place(data, i, block_size - 1 - i, false);",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": null,
          "new_api": "}\n\n                    *destination = clip_1(bit_depth,",
          "old_text": null,
          "new_text": "        }\n\n                    *destination = clip_1(bit_depth, ",
          "old_line_content": "                    source++;",
          "new_line_content": "                        accumulated_samples += static_cast<i16>(subpel_filters[filter][subpixel_x][t] * sample);",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": null,
          "new_api": "destination++;",
          "old_text": null,
          "new_text": "                  destination++;\n          ",
          "old_line_content": "                source += source_end_skip;",
          "new_line_content": "                    *destination = clip_1(bit_depth, rounded_right_shift(accumulated_samples, 7));",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": null,
          "new_api": "// We ca",
          "old_text": null,
          "new_text": " // We ca",
          "old_line_content": "    // A temporary array named copyT is set equal to T.",
          "new_line_content": "    constexpr auto block_size = 1u << log2_of_block_size;",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": null,
          "new_api": "2 * i ] fo",
          "old_text": null,
          "new_text": " 2 * i ] fo",
          "old_line_content": "    for (auto i = 0u; i < block_size; i += 2) {",
          "new_line_content": "    AK::TypedTransfer<Intermediate>::copy(data_copy.data(), data.data(), block_size);",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": null,
          "new_api": "ock_context.interpo",
          "old_text": null,
          "new_text": "ock_context.interpo",
          "old_line_content": "        auto vertical_convolution_unscaled = [](auto bit_depth, auto* destination, auto width, auto height, auto const* source, auto source_stride, auto filter, auto subpixel_y) {",
          "new_line_content": "            horizontal_convolution_unscaled(bit_depth, block_buffer.data(), width, height, reference_start, reference_frame_width, block_context.interpolation_filter, reference_subpixel_x);",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": null,
          "new_api": "scan_column += source_stride;\n                    }",
          "old_text": null,
          "new_text": "            scan_column += source_stride;\n                    }\n",
          "old_line_content": "                    source++;",
          "new_line_content": "                        accumulated_samples += static_cast<i16>(subpel_filters[filter][subpixel_y][t] * sample);",
          "content_same": false
        },
        {
          "line": 1533,
          "old_api": null,
          "new_api": ") {",
          "old_text": null,
          "new_text": ") {\n       ",
          "old_line_content": "        // − If n is equal to 4,",
          "new_line_content": "    AK::TypedTransfer<Intermediate>::copy(data_copy.data(), data.data(), block_size);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1026,
          "old_api": "ce_frame_width), re",
          "new_api": null,
          "old_text": "ce_frame_width), re",
          "new_text": null,
          "old_line_content": "            vertical_convolution_unscaled(bit_depth, block_buffer.data(), width, height, reference_start - (sample_offset * reference_frame_width), reference_frame_width, block_context.interpolation_filter, reference_subpixel_y);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1542,
          "old_api": "set equal to copyT[ 4*(c^b) + 2",
          "new_api": null,
          "old_text": "set equal to copyT[ 4*(c^b) + 2",
          "new_text": null,
          "old_line_content": "        VERIFY(log2_of_block_size == 3);",
          "new_line_content": "                for (auto c = 0u; c < 2; c++)",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": "ce_subpixel_y);\n        re",
          "new_api": null,
          "old_text": "ce_subpixel_y);\n        re",
          "new_text": null,
          "old_line_content": "        vertical_convolution_unscaled(bit_depth, block_buffer.data(), width, height, intermediate_buffer.data(), width, block_context.interpolation_filter, reference_subpixel_y);",
          "new_line_content": "            return {};",
          "content_same": false
        },
        {
          "line": 1555,
          "old_api": "3377;\n    c",
          "new_api": null,
          "old_text": "3377;\n    c",
          "new_text": null,
          "old_line_content": "    VERIFY(data.size() == 4);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "scan_subpixel += scale_x;",
          "new_api": null,
          "old_text": "               scan_subpixel += scale_x;\n  ",
          "new_text": null,
          "old_line_content": "                *destination = clip_1(bit_depth, rounded_right_shift(accumulated_samples, 7));",
          "new_line_content": "                    auto sample = scan_line[t];",
          "content_same": false
        },
        {
          "line": 1072,
          "old_api": "}\n            subpixel_y += scal",
          "new_api": null,
          "old_text": "           }\n            subpixel_y += scal",
          "new_text": null,
          "old_line_content": "                *destination = clip_1(bit_depth, rounded_right_shift(accumulated_samples, 7));",
          "new_line_content": "                    accumulated_samples += subpel_filters[filter][subpixel_y & SUBPEL_MASK][t] * sample;",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": "ple_offset * reference_fra",
          "new_api": null,
          "old_text": "ple_offset * reference_fra",
          "new_text": null,
          "old_line_content": "    horizontal_convolution_scaled(bit_depth, intermediate_buffer.data(), width, intermediate_height, reference_start - (sample_offset * reference_frame_width), reference_frame_width, block_context.interpolation_filter, offset_scaled_block_x & SUBPEL_MASK, scaled_step_x);",
          "new_line_content": "            subpixel_y += scale_y;",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "ce_subpixel_y, scaled_step",
          "new_api": null,
          "old_text": "ce_subpixel_y, scaled_step",
          "new_text": null,
          "old_line_content": "    vertical_convolution_scaled(bit_depth, block_buffer.data(), width, height, intermediate_buffer.data(), width, block_context.interpolation_filter, reference_subpixel_y, scaled_step_y);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": "/ T[ 2 ] = Round2( s2, 14 )",
          "new_api": null,
          "old_text": "/ T[ 2 ] = Round2( s2, 14 )",
          "new_text": null,
          "old_line_content": "    data[0] = rounded_right_shift(s0, 14);",
          "new_line_content": "    // s3 = x0 + x1 - x3",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": "/ T[ 3 ] = Round2( s3, 14 )",
          "new_api": null,
          "old_text": "/ T[ 3 ] = Round2( s3, 14 )",
          "new_text": null,
          "old_line_content": "    data[1] = rounded_right_shift(s1, 14);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "_context, ReferenceIndex::Primary, block_con",
          "new_api": null,
          "old_text": "_context, ReferenceIndex::Primary, block_con",
          "new_text": null,
          "old_line_content": "    auto predicted_span = predicted_buffer.span().trim(width * height);",
          "new_line_content": "    // The prediction arrays are formed by the following ordered steps:",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": "block_context.column, x, y, width, height, block_index, predicted_span));\n    auto predicted_buffer_at = [&](Span<u16> buffer, u32 row, u32 column) -> u16& {",
          "new_api": null,
          "old_text": "block_context.column, x, y, width, height, block_index, predicted_span));\n    auto predicted_buffer_at = [&](Span<u16> buffer, u32 row, u32 column) -> u16& {",
          "new_text": null,
          "old_line_content": "    TRY(predict_inter_block(plane, block_context, ReferenceIndex::Primary, block_context.row, block_context.column, x, y, width, height, block_index, predicted_span));",
          "new_line_content": "    // 1. The variable refList is set equal to 0.",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": "ce[index_a];",
          "new_api": null,
          "old_text": "ce[index_a];",
          "new_text": null,
          "old_line_content": "    auto cos = cos64(angle);",
          "new_line_content": "template<typename S, typename D>",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": "[index_b];",
          "new_api": null,
          "old_text": "[index_b];\n ",
          "new_text": null,
          "old_line_content": "    auto sin = sin64(angle);",
          "new_line_content": "inline void Decoder::butterfly_rotation(Span<S> source, Span<D> destination, size_t index_a, size_t index_b, u8 angle, bool flip)",
          "content_same": false
        },
        {
          "line": 1110,
          "old_api": "block_context.frame_cont",
          "new_api": null,
          "old_text": "block_context.frame_cont",
          "new_text": null,
          "old_line_content": "    auto& frame_buffer = get_output_buffer(plane);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": "ze",
          "new_api": null,
          "old_text": "ze(plane > 0);\n    auto",
          "new_text": null,
          "old_line_content": "    VERIFY(!frame_buffer.is_empty());",
          "new_line_content": "    // 6. If isCompound is equal to 1, then the variable refList is set equal to 1 and steps 2, 3, 4 and 5 are repeated",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": "2 row, u32 column) -> u16& {\n        return frame_b",
          "new_api": null,
          "old_text": "2 row, u32 column) -> u16& {\n        return frame_b",
          "new_text": null,
          "old_line_content": "    auto frame_size = block_context.frame_context.decoded_size(plane > 0);",
          "new_line_content": "    // to form the prediction for the second reference.",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": "ht",
          "new_api": null,
          "old_text": "ht() - y);\n\n    //",
          "new_text": null,
          "old_line_content": "    auto width_in_frame_buffer = min(width, frame_size.width() - x);",
          "new_line_content": "    auto frame_buffer_at = [&](u32 row, u32 column) -> u16& {",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": "nd rounding.\n// Spec defines the source array as",
          "new_api": null,
          "old_text": "nd rounding.\n// Spec defines the source array as",
          "new_text": null,
          "old_line_content": "        swap(destination[index_a], destination[index_b]);",
          "new_line_content": "    // The function SB( a, b, angle, 1 ) performs a butterfly rotation and flip according to the following ordered steps:",
          "content_same": false
        },
        {
          "line": 1123,
          "old_api": ") {\n            for (auto j",
          "new_api": null,
          "old_text": ") {\n            for (auto j",
          "new_text": null,
          "old_line_content": "    if (!block_context.is_compound()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": "Otherwise, CurrFrame[ plane ][ y + i ][",
          "new_api": null,
          "old_text": " Otherwise, CurrFrame[ plane ][ y + i ][ ",
          "new_text": null,
          "old_line_content": "                frame_buffer_at(y + i, x + j) = predicted_buffer_at(predicted_span, i, j);",
          "new_line_content": "    // and j = 0..w-1.",
          "content_same": false
        },
        {
          "line": 1646,
          "old_api": "n[index_b] = rounded_right_shi",
          "new_api": null,
          "old_text": "n[index_b] = rounded_right_shi",
          "new_text": null,
          "old_line_content": "    destination[index_a] = rounded_right_shift(a + b, 14);",
          "new_line_content": "    // Keep the source buffer's precision until rounding.",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": "ock_context, ReferenceIndex::Secondary, block_conte",
          "new_api": null,
          "old_text": "ock_context, ReferenceIndex::Secondary, block_conte",
          "new_text": null,
          "old_line_content": "    auto second_predicted_span = second_predicted_buffer.span().trim(width * height);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": "ock_context.column, x, y, width, height, block_index, second_predicted_span));\n\n    for (auto i = 0u; i < height_in_frame_buffer; i++) {\n        for (auto j = 0u; j <",
          "new_api": null,
          "old_text": "ock_context.column, x, y, width, height, block_index, second_predicted_span));\n\n    for (auto i = 0u; i < height_in_frame_buffer; i++) {\n        for (auto j = 0u; j <",
          "new_text": null,
          "old_line_content": "    TRY(predict_inter_block(plane, block_context, ReferenceIndex::Secondary, block_context.row, block_context.column, x, y, width, height, block_index, second_predicted_span));",
          "new_line_content": "    // − Otherwise, CurrFrame[ plane ][ y + i ][ x + j ] is set equal to Round2( preds[ 0 ][ i ][ j ] + preds[ 1 ][ i ][ j ], 1 )",
          "content_same": false
        },
        {
          "line": 1648,
          "old_api": "form_8",
          "new_api": null,
          "old_text": "form_8(Span<Intermediate> data",
          "new_text": null,
          "old_line_content": "    destination[index_b] = rounded_right_shift(a - b, 14);",
          "new_line_content": "    S b = source[index_b];",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": "sion array",
          "new_api": null,
          "old_text": "sion array ",
          "new_text": null,
          "old_line_content": "    VERIFY(data.size() == 8);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": "17, 18,",
          "new_api": null,
          "old_text": " 17, 18, ",
          "new_text": null,
          "old_line_content": "    constexpr u16 dc_qlookup[3][256] = {",
          "new_line_content": "inline u16 dc_q(u8 bit_depth, u8 b)",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": "30-8*i, 1 ) for i = 0..3.\n    for (auto i = 0u; i < 4; i++)\n        butter",
          "new_api": null,
          "old_text": " 30-8*i, 1 ) for i = 0..3.\n    for (auto i = 0u; i < 4; i++)\n        butter",
          "new_text": null,
          "old_line_content": "    inverse_asymmetric_discrete_sine_transform_input_array_permutation<3>(data);",
          "new_line_content": "    // The following ordered steps apply:",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": "b ) is specified as",
          "new_api": null,
          "old_text": " b ) is specified as ",
          "new_text": null,
          "old_line_content": "    return dc_qlookup[(bit_depth - 8) >> 1][clip_3<u8>(0, 255, b)];",
          "new_line_content": "        { 4, 9, 10, 13, 15, 17, 20, 22, 25, 28, 31, 34, 37, 40, 43, 47, 50, 53, 57, 60, 64, 68, 71, 75, 78, 82, 86, 90, 93, 97, 101, 105, 109, 113, 116, 120, 124, 128, 132, 136, 140, 143, 147, 151, 155, 159, 163, 166, 170, 174, 178, 182, 185, 189, 193, 197, 200, 204, 208, 212, 215, 219, 223, 226, 230, 233, 237, 241, 244, 248, 251, 255, 259, 262, 266, 269, 273, 276, 280, 283, 287, 290, 293, 297, 300, 304, 307, 310, 314, 317, 321, 324, 327, 331, 334, 337, 343, 350, 356, 362, 369, 375, 381, 387, 394, 400, 406, 412, 418, 424, 430, 436, 442, 448, 454, 460, 466, 472, 478, 484, 490, 499, 507, 516, 525, 533, 542, 550, 559, 567, 576, 584, 592, 601, 609, 617, 625, 634, 644, 655, 666, 676, 687, 698, 708, 718, 729, 739, 749, 759, 770, 782, 795, 807, 819, 831, 844, 856, 868, 880, 891, 906, 920, 933, 947, 961, 975, 988, 1001, 1015, 1030, 1045, 1061, 1076, 1090, 1105, 1120, 1137, 1153, 1170, 1186, 1202, 1218, 1236, 1253, 1271, 1288, 1306, 1323, 1342, 1361, 1379, 1398, 1416, 1436, 1456, 1476, 1496, 1516, 1537, 1559, 1580, 1601, 1624, 1647, 1670, 1692, 1717, 1741, 1766, 1791, 1817, 1844, 1871, 1900, 1929, 1958, 1990, 2021, 2054, 2088, 2123, 2159, 2197, 2236, 2276, 2319, 2363, 2410, 2458, 2508, 2561, 2616, 2675, 2737, 2802, 2871, 2944, 3020, 3102, 3188, 3280, 3375, 3478, 3586, 3702, 3823, 3953, 4089, 4236, 4394, 4559, 4737, 4929, 5130, 5347 },",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": ", 19, 20,",
          "new_api": null,
          "old_text": ", 19, 20,",
          "new_text": null,
          "old_line_content": "    constexpr u16 ac_qlookup[3][256] = {",
          "new_line_content": "inline u16 ac_q(u8 bit_depth, u8 b)",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": "i = 0u; i < 2; i++)",
          "new_api": null,
          "old_text": "i = 0u; i < 2; i++)\n      ",
          "new_text": null,
          "old_line_content": "        hadamard_rotation(high_precision_temp.span(), data, 4 + i, 6 + i);",
          "new_line_content": "    for (auto i = 0u; i < 2; i++)",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": "native_quantizer_feat",
          "new_api": null,
          "old_text": "native_quantizer_feat",
          "new_text": null,
          "old_line_content": "    return ac_qlookup[(bit_depth - 8) >> 1][clip_3<u8>(0, 255, b)];",
          "new_line_content": "        { 4, 9, 11, 13, 16, 18, 21, 24, 27, 30, 33, 37, 40, 44, 48, 51, 55, 59, 63, 67, 71, 75, 79, 83, 88, 92, 96, 100, 105, 109, 114, 118, 122, 127, 131, 136, 140, 145, 149, 154, 158, 163, 168, 172, 177, 181, 186, 190, 195, 199, 204, 208, 213, 217, 222, 226, 231, 235, 240, 244, 249, 253, 258, 262, 267, 271, 275, 280, 284, 289, 293, 297, 302, 306, 311, 315, 319, 324, 328, 332, 337, 341, 345, 349, 354, 358, 362, 367, 371, 375, 379, 384, 388, 392, 396, 401, 409, 417, 425, 433, 441, 449, 458, 466, 474, 482, 490, 498, 506, 514, 523, 531, 539, 547, 555, 563, 571, 579, 588, 596, 604, 616, 628, 640, 652, 664, 676, 688, 700, 713, 725, 737, 749, 761, 773, 785, 797, 809, 825, 841, 857, 873, 889, 905, 922, 938, 954, 970, 986, 1002, 1018, 1038, 1058, 1078, 1098, 1118, 1138, 1158, 1178, 1198, 1218, 1242, 1266, 1290, 1314, 1338, 1362, 1386, 1411, 1435, 1463, 1491, 1519, 1547, 1575, 1603, 1631, 1663, 1695, 1727, 1759, 1791, 1823, 1859, 1895, 1931, 1967, 2003, 2039, 2079, 2119, 2159, 2199, 2239, 2283, 2327, 2371, 2415, 2459, 2507, 2555, 2603, 2651, 2703, 2755, 2807, 2859, 2915, 2971, 3027, 3083, 3143, 3203, 3263, 3327, 3391, 3455, 3523, 3591, 3659, 3731, 3803, 3876, 3952, 4028, 4104, 4184, 4264, 4348, 4432, 4516, 4604, 4692, 4784, 4876, 4972, 5068, 5168, 5268, 5372, 5476, 5584, 5692, 5804, 5916, 6032, 6148, 6268, 6388, 6512, 6640, 6768, 6900, 7036, 7172, 7312 },",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": "tizer_index;\n}\n\nu16 Deco",
          "new_api": null,
          "old_text": "tizer_index;\n}\n\nu16 Deco",
          "new_text": null,
          "old_line_content": "        return clip_3<u8>(0, 255, data);",
          "new_line_content": "            data += base_quantizer_index;",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": "ision array",
          "new_api": null,
          "old_text": "ision array",
          "new_text": null,
          "old_line_content": "    VERIFY(data.size() == 16);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": "{\n    // NOTE: Delta is selec",
          "new_api": null,
          "old_text": "{\n    // NOTE: Delta is selec",
          "new_text": null,
          "old_line_content": "    return dc_q(bit_depth, static_cast<u8>(base + delta));",
          "new_line_content": "    // The function get_dc_quant( plane ) returns the quantizer value for the dc coefficient for a particular plane and",
          "content_same": false
        },
        {
          "line": 1717,
          "old_api": "31-4*i, 1 ) for i = 0..7.\n    for (auto i = 0u; i < 8; i++)\n        butter",
          "new_api": null,
          "old_text": " 31-4*i, 1 ) for i = 0..7.\n    for (auto i = 0u; i < 8; i++)\n        butter",
          "new_text": null,
          "old_line_content": "    inverse_asymmetric_discrete_sine_transform_input_array_permutation<4>(data);",
          "new_line_content": "    // The following ordered steps apply:",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": "nst& block_context, u32 trans",
          "new_api": null,
          "old_text": "nst& block_context, u32 trans",
          "new_text": null,
          "old_line_content": "    return ac_q(bit_depth, static_cast<u8>(base + delta));",
          "new_line_content": "    // The function get_ac_quant( plane ) returns the quantizer value for the ac coefficient for a particular plane and",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": "for (auto i = 0u; i < 4;",
          "new_api": null,
          "old_text": "  for (auto i = 0u; i < 4;",
          "new_text": null,
          "old_line_content": "        hadamard_rotation(high_precision_temp.span(), data, i, 8 + i);",
          "new_line_content": "    for (auto i = 0u; i < 8; i++)",
          "content_same": false
        },
        {
          "line": 1731,
          "old_api": "i = 0u; i < 4; i++)",
          "new_api": null,
          "old_text": " i = 0u; i < 4; i++)\n     ",
          "new_text": null,
          "old_line_content": "        hadamard_rotation(high_precision_temp.span(), data, 8 + i, 12 + i);",
          "new_line_content": "    for (auto i = 0u; i < 4; i++)",
          "content_same": false
        },
        {
          "line": 1223,
          "old_api": "break;\n    case 3:\n        return reconstruct_templated<3>(plane, block_context, transform_b",
          "new_api": null,
          "old_text": "       break;\n    case 3:\n        return reconstruct_templated<3>(plane, block_context, transform_b",
          "new_text": null,
          "old_line_content": "        return reconstruct_templated<2>(plane, block_context, transform_block_x, transform_block_y, transform_set);",
          "new_line_content": "    // The variable n (specifying the base 2 logarithm of the width of the transform block) is set equal to 2 + txSz.",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": "break;\n    case 4:\n        return reconstruct_templated<4>(plane, block_context, transform_b",
          "new_api": null,
          "old_text": "       break;\n    case 4:\n        return reconstruct_templated<4>(plane, block_context, transform_b",
          "new_text": null,
          "old_line_content": "        return reconstruct_templated<3>(plane, block_context, transform_block_x, transform_block_y, transform_set);",
          "new_line_content": "    case 2:",
          "content_same": false
        },
        {
          "line": 1740,
          "old_api": "4+8*j+i, 6+8*j+i ) for i",
          "new_api": null,
          "old_text": " 4+8*j+i, 6+8*j+i ) for i ",
          "new_text": null,
          "old_line_content": "            butterfly_rotation(data, high_precision_temp.span(), 4 + (8 * i) + (3 * j), 5 + (8 * i) + j, 24 - (16 * j), true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": "break;\n    case 5:\n        return reconstruct_templated<5>(plane, block_context, transform_b",
          "new_api": null,
          "old_text": "       break;\n    case 5:\n        return reconstruct_templated<5>(plane, block_context, transform_b",
          "new_text": null,
          "old_line_content": "        return reconstruct_templated<4>(plane, block_context, transform_block_x, transform_block_y, transform_set);",
          "new_line_content": "    case 3:",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": "break;\n    default:\n        VERIFY_NOT_REACHED();\n    }\n}\n\ntemplate<u8 log2_of_block_size>\nD",
          "new_api": null,
          "old_text": "       break;\n    default:\n        VERIFY_NOT_REACHED();\n    }\n}\n\ntemplate<u8 log2_of_block_size>\nD",
          "new_text": null,
          "old_line_content": "        return reconstruct_templated<5>(plane, block_context, transform_block_x, transform_block_y, transform_set);",
          "new_line_content": "    case 4:",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": "ct_templated",
          "new_api": null,
          "old_text": "ct_templated(u8 plan",
          "new_text": null,
          "old_line_content": "        VERIFY_NOT_REACHED();",
          "new_line_content": "    case 5:",
          "content_same": false
        },
        {
          "line": 1749,
          "old_api": "*i, 48+64*(i^j), 0 ) for i = 0..1, for j = 0..1.\n    for (auto i = 0u",
          "new_api": null,
          "old_text": "*i, 48+64*(i^j), 0 ) for i = 0..1, for j = 0..1.\n    for (auto i = 0u",
          "new_text": null,
          "old_line_content": "            hadamard_rotation_in_place(data, (8 * j) + i, 2 + (8 * j) + i, false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "fying the",
          "new_api": null,
          "old_text": "fying the",
          "new_text": null,
          "old_line_content": "    constexpr Intermediate dq_denominator = log2_of_block_size == 5 ? 2 : 1;",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": "okens[ i",
          "new_api": null,
          "old_text": "okens[ i ",
          "new_text": null,
          "old_line_content": "    constexpr auto block_size = 1u << log2_of_block_size;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": "ntized[i] = (tokens_raw[i] * ac_quan",
          "new_api": null,
          "old_text": "ntized[i] = (tokens_raw[i] * ac_quan",
          "new_text": null,
          "old_line_content": "    auto const* tokens_raw = block_context.residual_tokens.data();",
          "new_line_content": "    //    for i = 0..(n0-1), for j = 0..(n0-1)",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": "// 2. Dequan",
          "new_api": null,
          "old_text": "\n\n    // 2. Dequan",
          "new_text": null,
          "old_line_content": "    for (u32 i = 0; i < dequantized.size(); i++) {",
          "new_line_content": "    Array<Intermediate, block_size * block_size> dequantized;",
          "content_same": false
        },
        {
          "line": 1776,
          "old_api": "if constexpr (log2_of_block_size == 2) {\n        // −",
          "new_api": null,
          "old_text": "   if constexpr (log2_of_block_size == 2) {\n        // −",
          "new_text": null,
          "old_line_content": "        return DecoderError::corrupted(\"Block size was out of range\"sv);",
          "new_line_content": "    // 8.7.1.9 Inverse ADST Process",
          "content_same": false
        },
        {
          "line": 1269,
          "old_api": "rame[ plane ][ y + i ][ x + j ] is set equal to Clip1( CurrFrame[ plane ][ y + i ][",
          "new_api": null,
          "old_text": "rame[ plane ][ y + i ][ x + j ] is set equal to Clip1( CurrFrame[ plane ][ y + i ][",
          "new_text": null,
          "old_line_content": "    TRY(inverse_transform_2d<log2_of_block_size>(block_context, dequantized, transform_set));",
          "new_line_content": "    // to allow these bounds to be violated. Therefore, we can avoid the performance cost here.",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": "3) {\n        // − Otherwise if n is equal to 3, i",
          "new_api": null,
          "old_text": " 3) {\n        // − Otherwise if n is equal to 3, i",
          "new_text": null,
          "old_line_content": "        inverse_asymmetric_discrete_sine_transform_4(data);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": "width",
          "new_api": null,
          "old_text": "frame_size.width() - transform_block_x);\n    auto h",
          "new_text": null,
          "old_line_content": "    auto frame_size = block_context.frame_context.decoded_size(plane > 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1275,
          "old_api": "height",
          "new_api": null,
          "old_text": "height() - transfo",
          "new_text": null,
          "old_line_content": "    auto width_in_frame_buffer = min(block_size, frame_size.width() - transform_block_x);",
          "new_line_content": "    // 4. CurrFrame[ plane ][ y + i ][ x + j ] is set equal to Clip1( CurrFrame[ plane ][ y + i ][ x + j ] + Dequant[ i ][ j ] )",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": "for (auto j =",
          "new_api": null,
          "old_text": "      for (auto j =",
          "new_text": null,
          "old_line_content": "    auto height_in_frame_buffer = min(block_size, frame_size.height() - transform_block_y);",
          "new_line_content": "    //    for i = 0..(n0-1) and j = 0..(n0-1).",
          "content_same": false
        },
        {
          "line": 1786,
          "old_api": "T16 process specified in section 8.7.1.8.\n    retu",
          "new_api": null,
          "old_text": "T16 process specified in section 8.7.1.8.\n    retu",
          "new_text": null,
          "old_line_content": "        return inverse_asymmetric_discrete_sine_transform_8(data);",
          "new_line_content": "        return {};",
          "content_same": false
        },
        {
          "line": 1789,
          "old_api": "d> Decoder::inverse_transform_2d(BlockContext const",
          "new_api": null,
          "old_text": "d> Decoder::inverse_transform_2d(BlockContext const",
          "new_text": null,
          "old_line_content": "    return inverse_asymmetric_discrete_sine_transform_16(data);",
          "new_line_content": "        // − Otherwise if n is equal to 3, invoke the Inverse ADST8 process specified in section 8.7.1.7.",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": "}\n    }\n\n    return {};\n}\n\ninline DecoderErrorOr<void> Decoder::inverse_walsh_hadamard_trans",
          "new_api": null,
          "old_text": "\n        }\n    }\n\n    return {};\n}\n\ninline DecoderErrorOr<void> Decoder::inverse_walsh_hadamard_trans",
          "new_text": null,
          "old_line_content": "            current_buffer[index] = clip_1(block_context.frame_context.color_config.bit_depth, current_buffer[index] + dequantized_value);",
          "new_line_content": "    for (auto i = 0u; i < height_in_frame_buffer; i++) {",
          "content_same": false
        },
        {
          "line": 1801,
          "old_api": "pan<Inter",
          "new_api": null,
          "old_text": "pan<Inter",
          "new_text": null,
          "old_line_content": "    constexpr auto block_size = 1u << log2_of_block_size;",
          "new_line_content": "    // This process performs a 2D inverse transform for an array of size 2^n by 2^n stored in the 2D array Dequant.",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": "o i = 0u; i < block_size; i++) {",
          "new_api": null,
          "old_text": "o i = 0u; i < block_size; i++) {\n",
          "new_text": null,
          "old_line_content": "    Span<Intermediate> row = row_array.span().trim(block_size);",
          "new_line_content": "    // 1. Set the variable n0 (block_size) equal to 1 << n.",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": "ine i32 Decoder::cos64(u8 angle)\n{\n    const i32",
          "new_api": null,
          "old_text": "ine i32 Decoder::cos64(u8 angle)\n{\n    const i32 ",
          "new_text": null,
          "old_line_content": "        return DecoderError::corrupted(\"Block size was not 4\"sv);",
          "new_line_content": "    (void)shift;",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": "3] = { 16384, 16364, 16305, 162",
          "new_api": null,
          "old_text": "3] = { 16384, 16364, 16305, 162",
          "new_text": null,
          "old_line_content": "    return DecoderError::not_implemented();",
          "new_line_content": "    // This process does an in-place transform of the array T (of length 4) by the following ordered steps:",
          "content_same": false
        },
        {
          "line": 1815,
          "old_api": "_set.second_transform) {\n        case TransformType::DCT:",
          "new_api": null,
          "old_text": "_set.second_transform) {\n        case TransformType::DCT:\n  ",
          "new_text": null,
          "old_line_content": "            TRY(inverse_walsh_hadamard_transform(row, log2_of_block_size, 2));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1823,
          "old_api": "process as specified in section 8.7.1.3 with the input variable n.",
          "new_api": null,
          "old_text": "process as specified in section 8.7.1.3 with the input variable n.\n         ",
          "new_text": null,
          "old_line_content": "            TRY(inverse_discrete_cosine_transform_array_permutation<log2_of_block_size>(row));",
          "new_line_content": "        case TransformType::DCT:",
          "content_same": false
        },
        {
          "line": 1825,
          "old_api": "// 4. Otherwise (TxType is equal to DCT_ADST or TxTy",
          "new_api": null,
          "old_text": "      // 4. Otherwise (TxType is equal to DCT_ADST or TxTy",
          "new_text": null,
          "old_line_content": "            TRY(inverse_discrete_cosine_transform<log2_of_block_size>(row));",
          "new_line_content": "            // follows:",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": "turn DecoderError::corrupted(\"Unknown tx_type\"sv);\n        }",
          "new_api": null,
          "old_text": "turn DecoderError::corrupted(\"Unknown tx_type\"sv);\n        }\n\n     ",
          "new_text": null,
          "old_line_content": "            TRY(inverse_asymmetric_discrete_sine_transform<log2_of_block_size>(row));",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": "(n0-1).\n        for (auto j = 0u; j < block_",
          "new_api": null,
          "old_text": "(n0-1).\n        for (auto j = 0u; j < block_",
          "new_text": null,
          "old_line_content": "            return DecoderError::corrupted(\"Unknown tx_type\"sv);",
          "new_line_content": "            //    process as specified in section 8.7.1.9 with input variable n.",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": "line void Decoder:",
          "new_api": null,
          "old_text": "line void Decoder:",
          "new_text": null,
          "old_line_content": "    return cos64(angle - 32u);",
          "new_line_content": "inline i32 Decoder::sin64(u8 angle)",
          "content_same": false
        },
        {
          "line": 1330,
          "old_api": "gle ) - T[ b",
          "new_api": null,
          "old_text": "gle ) - T[ b",
          "new_text": null,
          "old_line_content": "    auto cos = cos64(angle);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1331,
          "old_api": ").\n    i64",
          "new_api": null,
          "old_text": " ).\n    i64 ",
          "new_text": null,
          "old_line_content": "    auto sin = sin64(angle);",
          "new_line_content": "// (8.7.1.1) The function B( a, b, angle, 0 ) performs a butterfly rotation.",
          "content_same": false
        },
        {
          "line": 1842,
          "old_api": "r (auto j = 0u; j < block_size; j++)",
          "new_api": null,
          "old_text": "r (auto j = 0u; j < block_size; j++)",
          "new_text": null,
          "old_line_content": "    auto column = column_array.span().trim(block_size);",
          "new_line_content": "            dequantized[i * block_size + j] = row[j];",
          "content_same": false
        },
        {
          "line": 1337,
          "old_api": "] = rounded_right_shift(rotated_b,",
          "new_api": null,
          "old_text": "] = rounded_right_shift(rotated_b,",
          "new_text": null,
          "old_line_content": "    data[index_a] = rounded_right_shift(rotated_a, 14);",
          "new_line_content": "    i64 rotated_a = data[index_a] * cos - data[index_b] * sin;",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": "tion and flip specified by the fol",
          "new_api": null,
          "old_text": "tion and flip specified by the fol",
          "new_text": null,
          "old_line_content": "    data[index_b] = rounded_right_shift(rotated_b, 14);",
          "new_line_content": "    i64 rotated_b = data[index_a] * sin + data[index_b] * cos;",
          "content_same": false
        },
        {
          "line": 1853,
          "old_api": "orm_set.first_transform) {\n        case TransformType::DCT:",
          "new_api": null,
          "old_text": "orm_set.first_transform) {\n        case TransformType::DCT:\n   ",
          "new_text": null,
          "old_line_content": "            TRY(inverse_walsh_hadamard_transform(column, log2_of_block_size, 2));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": "es saved into the array T by this",
          "new_api": null,
          "old_text": "es saved into the array T by this ",
          "new_text": null,
          "old_line_content": "        swap(data[index_a], data[index_b]);",
          "new_line_content": "    // The function B( a ,b, angle, 1 ) performs a butterfly rotation and flip specified by the following ordered steps:",
          "content_same": false
        },
        {
          "line": 1861,
          "old_api": "CT process as specified in section 8.7.1.3 with the input variable n.",
          "new_api": null,
          "old_text": "CT process as specified in section 8.7.1.3 with the input variable n.\n         ",
          "new_text": null,
          "old_line_content": "            TRY(inverse_discrete_cosine_transform_array_permutation<log2_of_block_size>(column));",
          "new_line_content": "        case TransformType::DCT:",
          "content_same": false
        },
        {
          "line": 1863,
          "old_api": "// 4. Otherwise (TxType is equal to ADST_DCT or TxTy",
          "new_api": null,
          "old_text": "         // 4. Otherwise (TxType is equal to ADST_DCT or TxTy",
          "new_text": null,
          "old_line_content": "            TRY(inverse_discrete_cosine_transform<log2_of_block_size>(column));",
          "new_line_content": "            // follows:",
          "content_same": false
        },
        {
          "line": 1868,
          "old_api": "VERIFY_NOT_REACHED();\n        }\n\n        // 5. If Lossless is equal t",
          "new_api": null,
          "old_text": " VERIFY_NOT_REACHED();\n        }\n\n        // 5. If Lossless is equal t",
          "new_text": null,
          "old_line_content": "            TRY(inverse_asymmetric_discrete_sine_transform<log2_of_block_size>(column));",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 1359,
          "old_api": "e following ordered st",
          "new_api": null,
          "old_text": "e following ordered st",
          "new_text": null,
          "old_line_content": "        swap(index_a, index_b);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": "0..(n0-1).\n        f",
          "new_api": null,
          "old_text": "0..(n0-1).\n        f",
          "new_text": null,
          "old_line_content": "            VERIFY_NOT_REACHED();",
          "new_line_content": "            //    process as specified in section 8.7.1.9 with input variable n.",
          "content_same": false
        },
        {
          "line": 1883,
          "old_api": "eference_frames",
          "new_api": null,
          "old_text": "eference_frames(FrameContext c",
          "new_text": null,
          "old_line_content": "                dequantized[index] = rounded_right_shift(dequantized[index], min(6, log2_of_block_size + 2));",
          "new_line_content": "        //    for i = 0..(n0-1).",
          "content_same": false
        },
        {
          "line": 1383,
          "old_api": "on of the",
          "new_api": null,
          "old_text": "on of the",
          "new_text": null,
          "old_line_content": "    constexpr u8 block_size = 1 << log2_of_block_size;",
          "new_line_content": "inline DecoderErrorOr<void> Decoder::inverse_discrete_cosine_transform_array_permutation(Span<Intermediate> data)",
          "content_same": false
        },
        {
          "line": 1388,
          "old_api": "t equal to T.\n    Array<Intermediate, block_size> data_c",
          "new_api": null,
          "old_text": "t equal to T.\n    Array<Intermediate, block_size> data_c",
          "new_text": null,
          "old_line_content": "        return DecoderError::corrupted(\"Block size was out of range\"sv);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1901,
          "old_api": "mes[i];\n\n            // − RefFrameWidth[ i ] is set equ",
          "new_api": null,
          "old_text": "mes[i];\n\n            // − RefFrameWidth[ i ] is set equ",
          "new_text": null,
          "old_line_content": "        if (frame_context.should_update_reference_frame_at_index(i)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": "mpling_x = frame_con",
          "new_api": null,
          "old_text": "mpling_x = frame_con",
          "new_text": null,
          "old_line_content": "            reference_frame.size = frame_context.size();",
          "new_line_content": "            auto& reference_frame = m_parser->m_reference_frames[i];",
          "content_same": false
        },
        {
          "line": 1407,
          "old_api": "riable n1",
          "new_api": null,
          "old_text": "riable n1",
          "new_text": null,
          "old_line_content": "    constexpr u8 block_size = 1 << log2_of_block_size;",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1923,
          "old_api": "decoded_size",
          "new_api": null,
          "old_text": ".decoded_size(plane > 0).wid",
          "new_text": null,
          "old_line_content": "                auto width = frame_context.size().width();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1412,
          "old_api": "onstexpr",
          "new_api": null,
          "old_text": "onstexpr ",
          "new_text": null,
          "old_line_content": "    constexpr u8 half_block_size = block_size >> 1;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1924,
          "old_api": "> 0) {\n                    wi",
          "new_api": null,
          "old_text": "> 0) {\n                    wi",
          "new_text": null,
          "old_line_content": "                auto height = frame_context.size().height();",
          "new_line_content": "            // FIXME: Frame width is not equal to the buffer's stride. If we store the stride of the buffer with the reference",
          "content_same": false
        },
        {
          "line": 1414,
          "old_api": ").\n    co",
          "new_api": null,
          "old_text": ").\n    co",
          "new_text": null,
          "old_line_content": "    constexpr u8 quarter_block_size = half_block_size >> 1;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1925,
          "old_api": "ntext.color_config.subsampling_x, width);",
          "new_api": null,
          "old_text": "ntext.color_config.subsampling_x, width);\n   ",
          "new_text": null,
          "old_line_content": "                auto stride = frame_context.decoded_size(plane > 0).width();",
          "new_line_content": "            //        frame, we can just copy the framebuffer data instead. Alternatively, we should crop the output framebuffer.",
          "content_same": false
        },
        {
          "line": 1421,
          "old_api": "log2_of_block_size - 1>(data));\n\n    // 2.6 Invok",
          "new_api": null,
          "old_text": "log2_of_block_size - 1>(data));\n\n    // 2.6 Invok",
          "new_text": null,
          "old_line_content": "        butterfly_rotation_in_place(data, 0, 1, 16, true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1423,
          "old_api": "rev",
          "new_api": null,
          "old_text": "rev( 5, n1+i), 0 ) for i = 0..(n2-1).\n    for (auto i = 0u; i <",
          "new_text": null,
          "old_line_content": "        TRY(inverse_discrete_cosine_transform<log2_of_block_size - 1>(data));",
          "new_line_content": "    // section with the variable n set equal to n - 1.",
          "content_same": false
        },
        {
          "line": 1937,
          "old_api": "on_y++) {",
          "new_api": null,
          "old_text": "on_y++) {\n            ",
          "new_text": null,
          "old_line_content": "                VERIFY(original_buffer.size() >= width * height);",
          "new_line_content": "                auto frame_store_width = width + MV_BORDER * 2;",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": "ock_size >= 3)",
          "new_api": null,
          "old_text": "ock_size >= 3)",
          "new_text": null,
          "old_line_content": "        butterfly_rotation_in_place(data, index, block_size - 1 - i, 32 - brev<5>(index), false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": "[source_y * stride];\n                    auto* destination = &frame_store_b",
          "new_api": null,
          "old_text": "[source_y * stride];\n                    auto* destination = &frame_store_b",
          "new_text": null,
          "old_line_content": "                    auto source_y = min(destination_y >= MV_BORDER ? destination_y - MV_BORDER : 0, height - 1);",
          "new_line_content": "                for (auto destination_y = 0u; destination_y < frame_store_height; destination_y++) {",
          "content_same": false
        },
        {
          "line": 1945,
          "old_api": "auto destination_y = 0u; destination_y < frame_store_height; destination_y++) {",
          "new_api": null,
          "old_text": "auto destination_y = 0u; destination_y < frame_store_height; destination_y++) {\n            ",
          "new_text": null,
          "old_line_content": "                    AK::TypedTransfer<RemoveReference<decltype(*destination)>>::copy(destination, source, width);",
          "new_line_content": "                    // inter-prediction.",
          "content_same": false
        },
        {
          "line": 1437,
          "old_api": "ual to 5:\n    if constexpr (log2_of_block_size == 5)",
          "new_api": null,
          "old_text": "ual to 5:\n    if constexpr (log2_of_block_size == 5) ",
          "new_text": null,
          "old_line_content": "                hadamard_rotation_in_place(data, index, index + 1, j);",
          "new_line_content": "        // a. Invoke H( n1+4*i+2*j, n1+1+4*i+2*j, j ) for i = 0..(n3-1), j = 0..1.",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": "nvoke H( n1+n3*j+i, n1+n2-5+n3*j-i, j&1 ) for i = 0..1, j = 0..3",
          "new_api": null,
          "old_text": "nvoke H( n1+n3*j+i, n1+n2-5+n3*j-i, j&1 ) for i = 0..1, j = 0..3",
          "new_text": null,
          "old_line_content": "                butterfly_rotation_in_place(data, index_a, index_b, angle, true);",
          "new_line_content": "            for (auto j = 0u; j < 2; j++) {",
          "content_same": false
        },
        {
          "line": 1968,
          "old_api": "block_contexts",
          "new_api": null,
          "old_text": "2d(frame_context.block_contexts()));",
          "new_text": null,
          "old_line_content": "    if (!frame_context.shows_existing_frame()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1969,
          "old_api": "row = 0..MiRows-1,\n        //",
          "new_api": null,
          "old_text": " row = 0..MiRows-1,\n        //",
          "new_text": null,
          "old_line_content": "        DECODER_TRY_ALLOC(m_parser->m_previous_block_contexts.try_resize_to_match_other_vector2d(frame_context.block_contexts()));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1459,
          "old_api": "If n is greater than or equal to 4:\n    if constexpr (log2_of_b",
          "new_api": null,
          "old_text": " If n is greater than or equal to 4:\n    if constexpr (log2_of_b",
          "new_text": null,
          "old_line_content": "                hadamard_rotation_in_place(data, index_a, index_b, (j & 1) != 0);",
          "new_line_content": "        for (auto i = 0u; i < 2; i++) {",
          "content_same": false
        },
        {
          "line": 1980,
          "old_api": "copy_to",
          "new_api": null,
          "old_text": "k_contexts().copy_to(m_parser->m_pre",
          "new_text": null,
          "old_line_content": "        bool keep_segment_ids = !frame_context.shows_existing_frame() && frame_context.segmentation_enabled && frame_context.use_full_segment_id_tree;",
          "new_line_content": "        // SegmentIds[ row ][ col ] for row = 0..MiRows-1, for col = 0..MiCols-1:",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": "sistent_context = PersistentBlockContext(context);\n            if (!keep_segment_ids)\n                persistent_context.segment_id = 0;\n            return persistent_context;\n        });\n    }\n\n    return {};\n}\n\n}",
          "new_api": null,
          "old_text": "sistent_context = PersistentBlockContext(context);\n            if (!keep_segment_ids)\n                persistent_context.segment_id = 0;\n            return persistent_context;\n        });\n    }\n\n    return {};\n}\n\n}\n",
          "new_text": null,
          "old_line_content": "        frame_context.block_contexts().copy_to(m_parser->m_previous_block_contexts, [keep_segment_ids](FrameBlockContext context) {",
          "new_line_content": "        //   − show_existing_frame is equal to 0,",
          "content_same": false
        },
        {
          "line": 1982,
          "old_api": "tent_context;\n        });\n    }",
          "new_api": null,
          "old_text": "tent_context;\n        });\n    }",
          "new_text": null,
          "old_line_content": "            auto persistent_context = PersistentBlockContext(context);",
          "new_line_content": "        //   − segmentation_enabled is equal to 1,",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": "// b. Invoke H( n1+n2*j+i, n1+n2-1+n2*j-i, j&1 ) for i = 0..(2n-7), j =",
          "new_api": null,
          "old_text": " // b. Invoke H( n1+n2*j+i, n1+n2-1+n2*j-i, j&1 ) for i = 0..(2n-7), j =",
          "new_text": null,
          "old_line_content": "                butterfly_rotation_in_place(data, index_a, index_b, 24 + (48 * j), true);",
          "new_line_content": "        for (auto i = 0u; i <= (log2_of_block_size == 5); i++) {",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": "If n is greater than or equal to 3:\n    if constexpr (log2_of_b",
          "new_api": null,
          "old_text": " If n is greater than or equal to 3:\n    if constexpr (log2_of_b",
          "new_text": null,
          "old_line_content": "                hadamard_rotation_in_place(data, index_a, index_b, (j & 1) != 0);",
          "new_line_content": "        for (auto i = 0u; i < (2 * log2_of_block_size) - 6u; i++) {",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": "memc",
          "new_api": null,
          "old_text": "               memc",
          "new_text": null,
          "old_line_content": "            auto* destination_scan_line = block_buffer.data();",
          "new_line_content": "    if (unscaled_x && unscaled_y && bit_depth == 8) {",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": "_scan_line));\n                reference_scan_line += reference_frame_width;",
          "new_api": null,
          "old_text": "_scan_line));\n                reference_scan_line += reference_frame_width;\n              ",
          "new_text": null,
          "old_line_content": "                memcpy(destination_scan_line, reference_scan_line, width * sizeof(*destination_scan_line));",
          "new_line_content": "            auto const* reference_scan_line = &reference_frame_buffer[reference_block_y * reference_frame_width + reference_block_x];",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": "1-i, 0 ) for i = 0..(n1-1).\n    for (auto i = 0u; i < half_bl",
          "new_api": null,
          "old_text": "1-i, 0 ) for i = 0..(n1-1).\n    for (auto i = 0u; i < half_bl",
          "new_text": null,
          "old_line_content": "            butterfly_rotation_in_place(data, index_a, index_b, 16, true);",
          "new_line_content": "        // a. Invoke B( n0-n3-1-i, n1+n3+i, 16, 1 ) for i = 0..(n3-1).",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": "ck_size>\ninline void Decoder::inverse_asymmetric_discrete_sine",
          "new_api": null,
          "old_text": "ck_size>\ninline void Decoder::inverse_asymmetric_discrete_sine",
          "new_text": null,
          "old_line_content": "        hadamard_rotation_in_place(data, i, block_size - 1 - i, false);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": "destination++;",
          "new_api": null,
          "old_text": "                  destination++;\n          ",
          "new_text": null,
          "old_line_content": "                    *destination = clip_1(bit_depth, rounded_right_shift(accumulated_samples, 7));",
          "new_line_content": "                        auto sample = source[t];",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": "// We ca",
          "new_api": null,
          "old_text": " // We ca",
          "new_text": null,
          "old_line_content": "    constexpr auto block_size = 1u << log2_of_block_size;",
          "new_line_content": "template<u8 log2_of_block_size>",
          "content_same": false
        },
        {
          "line": 1512,
          "old_api": "2 * i ] fo",
          "new_api": null,
          "old_text": " 2 * i ] fo",
          "new_text": null,
          "old_line_content": "    AK::TypedTransfer<Intermediate>::copy(data_copy.data(), data.data(), block_size);",
          "new_line_content": "    // We can iterate by 2 at a time instead of taking half block size.",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "ock_context.interpo",
          "new_api": null,
          "old_text": "ock_context.interpo",
          "new_text": null,
          "old_line_content": "            horizontal_convolution_unscaled(bit_depth, block_buffer.data(), width, height, reference_start, reference_frame_width, block_context.interpolation_filter, reference_subpixel_x);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1529,
          "old_api": ") {",
          "new_api": null,
          "old_text": ") {\n       ",
          "new_text": null,
          "old_line_content": "    AK::TypedTransfer<Intermediate>::copy(data_copy.data(), data.data(), block_size);",
          "new_line_content": "    auto block_size = 1u << log2_of_block_size;",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": "destination++;",
          "new_api": null,
          "old_text": "                  destination++;\n          ",
          "new_text": null,
          "old_line_content": "                    *destination = clip_1(bit_depth, rounded_right_shift(accumulated_samples, 7));",
          "new_line_content": "                        auto sample = *scan_column;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 27,
      "total_additions": 120,
      "total_deletions": 118,
      "total_api_changes": 265
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 15,
        "api_related_lines": 265,
        "non_api_lines": 13,
        "non_api_line_numbers": [
          962,
          963,
          964,
          965,
          966,
          967,
          968,
          1011,
          1014,
          1015,
          986,
          989,
          990
        ]
      }
    },
    "api_calls_before": 523,
    "api_calls_after": 525,
    "diff_info": {
      "added_lines": 11,
      "removed_lines": 7,
      "total_diff_lines": 48
    }
  }
}