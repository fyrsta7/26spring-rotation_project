{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/ebe47de0b2e0f35397cf137ae565b8042d81ccd2",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/ebe47de0b2e0f35397cf137ae565b8042d81ccd2/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/ebe47de0b2e0f35397cf137ae565b8042d81ccd2/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/ebe47de0b2e0f35397cf137ae565b8042d81ccd2/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 166,
          "old_api": "pitch",
          "new_api": "height",
          "old_text": "m_target->pitch()",
          "new_text": "rect.height()",
          "old_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "new_line_content": "    for (int i = 0; i < rect.height(); ++i) {",
          "content_same": false
        },
        {
          "line": 170,
          "old_api": "height",
          "new_api": "value",
          "old_text": "cell_size.height()",
          "new_text": "color_dark.value()",
          "old_line_content": "            int cell_row = i / cell_size.height();",
          "new_line_content": "            dst[j] = ((cell_row % 2) ^ (cell_col % 2)) ? color_light.value() : color_dark.value();",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": "fill_rect",
          "new_api": "translation",
          "old_text": "fill_rect(a_rect, gradient_start)",
          "new_text": "translation()",
          "old_line_content": "    return fill_rect(a_rect, gradient_start);",
          "new_line_content": "    auto rect = a_rect.translated(translation());",
          "content_same": false
        },
        {
          "line": 183,
          "old_api": "translation",
          "new_api": "is_empty",
          "old_text": "translation()",
          "new_text": "clipped_rect.is_empty()",
          "old_line_content": "    auto rect = a_rect.translated(translation());",
          "new_line_content": "    if (clipped_rect.is_empty())",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": "primary_offset_for_orientation",
          "new_api": "left",
          "old_text": "rect.primary_offset_for_orientation(orientation)",
          "new_text": "clipped_rect.left()",
          "old_line_content": "    int offset = clipped_rect.primary_offset_for_orientation(orientation) - rect.primary_offset_for_orientation(orientation);",
          "new_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.top()) + clipped_rect.left();",
          "content_same": false
        },
        {
          "line": 191,
          "old_api": "pitch",
          "new_api": "primary_size_for_orientation",
          "old_text": "m_target->pitch()",
          "new_text": "rect.primary_size_for_orientation(orientation)",
          "old_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "new_line_content": "    float increment = (1.0 / ((rect.primary_size_for_orientation(orientation)) / 255.0));",
          "content_same": false
        },
        {
          "line": 193,
          "old_api": "primary_size_for_orientation",
          "new_api": "red",
          "old_text": "rect.primary_size_for_orientation(orientation)",
          "new_text": "gradient_start.red()",
          "old_line_content": "    float increment = (1.0 / ((rect.primary_size_for_orientation(orientation)) / 255.0));",
          "new_line_content": "    int r2 = gradient_start.red();",
          "content_same": false
        },
        {
          "line": 195,
          "old_api": "red",
          "new_api": "blue",
          "old_text": "gradient_start.red()",
          "new_text": "gradient_start.blue()",
          "old_line_content": "    int r2 = gradient_start.red();",
          "new_line_content": "    int b2 = gradient_start.blue();",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": "green",
          "new_api": "red",
          "old_text": "gradient_start.green()",
          "new_text": "gradient_end.red()",
          "old_line_content": "    int g2 = gradient_start.green();",
          "new_line_content": "    int r1 = gradient_end.red();",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": "blue",
          "new_api": "green",
          "old_text": "gradient_start.blue()",
          "new_text": "gradient_end.green()",
          "old_line_content": "    int b2 = gradient_start.blue();",
          "new_line_content": "    int g1 = gradient_end.green();",
          "content_same": false
        },
        {
          "line": 198,
          "old_api": "red",
          "new_api": "blue",
          "old_text": "gradient_end.red()",
          "new_text": "gradient_end.blue()",
          "old_line_content": "    int r1 = gradient_end.red();",
          "new_line_content": "    int b1 = gradient_end.blue();",
          "content_same": false
        },
        {
          "line": 203,
          "old_api": "height",
          "new_api": "width",
          "old_text": "clipped_rect.height()",
          "new_text": "clipped_rect.width()",
          "old_line_content": "        for (int i = clipped_rect.height() - 1; i >= 0; --i) {",
          "new_line_content": "            for (int j = 0; j < clipped_rect.width(); ++j) {",
          "content_same": false
        },
        {
          "line": 256,
          "old_api": "translation",
          "new_api": "is_empty",
          "old_text": "translation()",
          "new_text": "clipped_rect.is_empty()",
          "old_line_content": "    Rect rect = a_rect.translated(translation());",
          "new_line_content": "    if (clipped_rect.is_empty())",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": "bottom",
          "new_api": "width",
          "old_text": "clipped_rect.bottom()",
          "new_text": "clipped_rect.width()",
          "old_line_content": "    if (rect.top() >= clipped_rect.top() && rect.top() <= clipped_rect.bottom()) {",
          "new_line_content": "        int width = rough ? min(rect.width() - 2, clipped_rect.width()) : clipped_rect.width();",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": "x",
          "new_api": "value",
          "old_text": "clipped_rect.x()",
          "new_text": "color.value()",
          "old_line_content": "        int start_x = rough ? max(rect.x() + 1, clipped_rect.x()) : clipped_rect.x();",
          "new_line_content": "        fast_u32_fill(m_target->scanline(rect.top()) + start_x, color.value(), width);",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": "bottom",
          "new_api": "width",
          "old_text": "clipped_rect.bottom()",
          "new_text": "clipped_rect.width()",
          "old_line_content": "    if (rect.bottom() >= clipped_rect.top() && rect.bottom() <= clipped_rect.bottom()) {",
          "new_line_content": "        int width = rough ? min(rect.width() - 2, clipped_rect.width()) : clipped_rect.width();",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "x",
          "new_api": "value",
          "old_text": "clipped_rect.x()",
          "new_text": "color.value()",
          "old_line_content": "        int start_x = rough ? max(rect.x() + 1, clipped_rect.x()) : clipped_rect.x();",
          "new_line_content": "        fast_u32_fill(m_target->scanline(rect.bottom()) + start_x, color.value(), width);",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": "scanline",
          "new_api": "value",
          "old_text": "m_target->scanline(y)",
          "new_text": "color.value()",
          "old_line_content": "            auto* bits = m_target->scanline(y);",
          "new_line_content": "            bits[rect.right()] = color.value();",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "scanline",
          "new_api": "value",
          "old_text": "m_target->scanline(y)",
          "new_text": "color.value()",
          "old_line_content": "            auto* bits = m_target->scanline(y);",
          "new_line_content": "                bits[rect.left()] = color.value();",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": "translation",
          "new_api": "is_empty",
          "old_text": "translation()",
          "new_text": "clipped_rect.is_empty()",
          "old_line_content": "    auto rect = Rect(p, bitmap.size()).translated(translation());",
          "new_line_content": "    if (clipped_rect.is_empty())",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": "is_empty",
          "new_api": "top",
          "old_text": "clipped_rect.is_empty()",
          "new_text": "rect.top()",
          "old_line_content": "    if (clipped_rect.is_empty())",
          "new_line_content": "    const int first_row = clipped_rect.top() - rect.top();",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "top",
          "new_api": "left",
          "old_text": "rect.top()",
          "new_text": "rect.left()",
          "old_line_content": "    const int first_row = clipped_rect.top() - rect.top();",
          "new_line_content": "    const int first_column = clipped_rect.left() - rect.left();",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": "top",
          "new_api": "left",
          "old_text": "rect.top()",
          "new_text": "rect.left()",
          "old_line_content": "    const int last_row = clipped_rect.bottom() - rect.top();",
          "new_line_content": "    const int last_column = clipped_rect.right() - rect.left();",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": "left",
          "new_api": "x",
          "old_text": "rect.left()",
          "new_text": "clipped_rect.x()",
          "old_line_content": "    const int first_column = clipped_rect.left() - rect.left();",
          "new_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": "left",
          "new_api": "pitch",
          "old_text": "rect.left()",
          "new_text": "m_target->pitch()",
          "old_line_content": "    const int last_column = clipped_rect.right() - rect.left();",
          "new_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": "x",
          "new_api": "width",
          "old_text": "clipped_rect.x()",
          "new_text": "bitmap.width()",
          "old_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "new_line_content": "    const char* bitmap_row = &bitmap.bits()[first_row * bitmap.width() + first_column];",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": "pitch",
          "new_api": "width",
          "old_text": "m_target->pitch()",
          "new_text": "bitmap.width()",
          "old_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "new_line_content": "    const size_t bitmap_skip = bitmap.width();",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": "translation",
          "new_api": "is_empty",
          "old_text": "translation()",
          "new_text": "clipped_rect.is_empty()",
          "old_line_content": "    auto dst_rect = Rect(p, bitmap.size()).translated(translation());",
          "new_line_content": "    if (clipped_rect.is_empty())",
          "content_same": false
        },
        {
          "line": 328,
          "old_api": "is_empty",
          "new_api": "top",
          "old_text": "clipped_rect.is_empty()",
          "new_text": "dst_rect.top()",
          "old_line_content": "    if (clipped_rect.is_empty())",
          "new_line_content": "    const int first_row = clipped_rect.top() - dst_rect.top();",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": "top",
          "new_api": "left",
          "old_text": "dst_rect.top()",
          "new_text": "dst_rect.left()",
          "old_line_content": "    const int first_row = clipped_rect.top() - dst_rect.top();",
          "new_line_content": "    const int first_column = clipped_rect.left() - dst_rect.left();",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": "top",
          "new_api": "left",
          "old_text": "dst_rect.top()",
          "new_text": "dst_rect.left()",
          "old_line_content": "    const int last_row = clipped_rect.bottom() - dst_rect.top();",
          "new_line_content": "    const int last_column = clipped_rect.right() - dst_rect.left();",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": "left",
          "new_api": "x",
          "old_text": "dst_rect.left()",
          "new_text": "clipped_rect.x()",
          "old_line_content": "    const int first_column = clipped_rect.left() - dst_rect.left();",
          "new_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": "left",
          "new_api": "pitch",
          "old_text": "dst_rect.left()",
          "new_text": "m_target->pitch()",
          "old_line_content": "    const int last_column = clipped_rect.right() - dst_rect.left();",
          "new_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": "swap",
          "new_api": "clip_rect",
          "old_text": "swap(p1, p2)",
          "new_text": "clip_rect()",
          "old_line_content": "        swap(p1, p2);",
          "new_line_content": "    auto clip = clip_rect();",
          "content_same": false
        },
        {
          "line": 362,
          "old_api": "bottom",
          "new_api": "top",
          "old_text": "clip.bottom()",
          "new_text": "clip.top()",
          "old_line_content": "    if (p0.y() >= clip.bottom())",
          "new_line_content": "    if (p2.y() < clip.top())",
          "content_same": false
        },
        {
          "line": 369,
          "old_api": "y",
          "new_api": "x",
          "old_text": "p1.y()",
          "new_text": "p0.x()",
          "old_line_content": "    float dx12 = (float)(p2.x() - p1.x()) / (p2.y() - p1.y());",
          "new_line_content": "    float x01 = p0.x();",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "x",
          "new_api": "y",
          "old_text": "p0.x()",
          "new_text": "p0.y()",
          "old_line_content": "    float x02 = p0.x();",
          "new_line_content": "    int top = p0.y();",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": "y",
          "new_api": "top",
          "old_text": "p0.y()",
          "new_text": "clip.top()",
          "old_line_content": "    int top = p0.y();",
          "new_line_content": "        x01 += dx01 * (clip.top() - top);",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": "bottom",
          "new_api": "right",
          "old_text": "clip.bottom()",
          "new_text": "clip.right()",
          "old_line_content": "    for (int y = top; y < p1.y() && y < clip.bottom(); ++y) {",
          "new_line_content": "        int end = x01 > x02 ? min((int)x01, clip.right()) : min((int)x02, clip.right());",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": "left",
          "new_api": "scanline",
          "old_text": "clip.left()",
          "new_text": "m_target->scanline(y)",
          "old_line_content": "        int start = x01 > x02 ? max((int)x02, clip.left()) : max((int)x01, clip.left());",
          "new_line_content": "        auto* scanline = m_target->scanline(y);",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": "x",
          "new_api": "y",
          "old_text": "p1.x()",
          "new_text": "p1.y()",
          "old_line_content": "    float x12 = p1.x();",
          "new_line_content": "    top = p1.y();",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": "y",
          "new_api": "top",
          "old_text": "p1.y()",
          "new_text": "clip.top()",
          "old_line_content": "    top = p1.y();",
          "new_line_content": "        x02 += dx02 * (clip.top() - top);",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": "bottom",
          "new_api": "right",
          "old_text": "clip.bottom()",
          "new_text": "clip.right()",
          "old_line_content": "    for (int y = top; y < p2.y() && y < clip.bottom(); ++y) {",
          "new_line_content": "        int end = x12 > x02 ? min((int)x12, clip.right()) : min((int)x02, clip.right());",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": "left",
          "new_api": "scanline",
          "old_text": "clip.left()",
          "new_text": "m_target->scanline(y)",
          "old_line_content": "        int start = x12 > x02 ? max((int)x02, clip.left()) : max((int)x12, clip.left());",
          "new_line_content": "        auto* scanline = m_target->scanline(y);",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": "translation",
          "new_api": "is_empty",
          "old_text": "translation()",
          "new_text": "clipped_rect.is_empty()",
          "old_line_content": "    auto dst_rect = Rect(dst_rect_raw.location(), dst_rect_raw.size()).translated(translation());",
          "new_line_content": "    if (clipped_rect.is_empty())",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": "is_empty",
          "new_api": "top",
          "old_text": "clipped_rect.is_empty()",
          "new_text": "dst_rect.top()",
          "old_line_content": "    if (clipped_rect.is_empty())",
          "new_line_content": "    const int first_row = (clipped_rect.top() - dst_rect.top());",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": "top",
          "new_api": "left",
          "old_text": "dst_rect.top()",
          "new_text": "dst_rect.left()",
          "old_line_content": "    const int first_row = (clipped_rect.top() - dst_rect.top());",
          "new_line_content": "    const int first_column = (clipped_rect.left() - dst_rect.left());",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": "top",
          "new_api": "x",
          "old_text": "dst_rect.top()",
          "new_text": "clipped_rect.x()",
          "old_line_content": "    const int last_row = (clipped_rect.bottom() - dst_rect.top());",
          "new_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "left",
          "new_api": "pitch",
          "old_text": "dst_rect.left()",
          "new_text": "m_target->pitch()",
          "old_line_content": "    const int first_column = (clipped_rect.left() - dst_rect.left());",
          "new_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": "pitch",
          "new_api": "left",
          "old_text": "m_target->pitch()",
          "new_text": "src_rect.left()",
          "old_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "new_line_content": "    int x_start = first_column + src_rect.left();",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": "left",
          "new_api": "top",
          "old_text": "src_rect.left()",
          "new_text": "src_rect.top()",
          "old_line_content": "    int x_start = first_column + src_rect.left();",
          "new_line_content": "        int sr = (row + src_rect.top()) * vscale;",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": "width",
          "new_api": "size",
          "old_text": "clipped_rect.width()",
          "new_text": "source.size().width()",
          "old_line_content": "        for (int x = x_start; x < clipped_rect.width() + x_start; ++x) {",
          "new_line_content": "            if (sx < source.size().width() && sx >= 0)",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": "rect",
          "new_api": "state",
          "old_text": "source.rect()",
          "new_text": "state()",
          "old_line_content": "    Rect safe_src_rect = Rect::intersection(src_rect, source.rect());",
          "new_line_content": "    dst_rect.move_by(state().translation);",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": "size",
          "new_api": "clip_rect",
          "old_text": "safe_src_rect.size()",
          "new_text": "clip_rect()",
          "old_line_content": "    Rect dst_rect(position, safe_src_rect.size());",
          "new_line_content": "    auto clipped_rect = Rect::intersection(dst_rect, clip_rect());",
          "content_same": false
        },
        {
          "line": 457,
          "old_api": "state",
          "new_api": "is_empty",
          "old_text": "state()",
          "new_text": "clipped_rect.is_empty()",
          "old_line_content": "    dst_rect.move_by(state().translation);",
          "new_line_content": "    if (clipped_rect.is_empty())",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "is_empty",
          "new_api": "top",
          "old_text": "clipped_rect.is_empty()",
          "new_text": "dst_rect.top()",
          "old_line_content": "    if (clipped_rect.is_empty())",
          "new_line_content": "    const int first_row = clipped_rect.top() - dst_rect.top();",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": "top",
          "new_api": "left",
          "old_text": "dst_rect.top()",
          "new_text": "dst_rect.left()",
          "old_line_content": "    const int first_row = clipped_rect.top() - dst_rect.top();",
          "new_line_content": "    const int first_column = clipped_rect.left() - dst_rect.left();",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": "top",
          "new_api": "left",
          "old_text": "dst_rect.top()",
          "new_text": "dst_rect.left()",
          "old_line_content": "    const int last_row = clipped_rect.bottom() - dst_rect.top();",
          "new_line_content": "    const int last_column = clipped_rect.right() - dst_rect.left();",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": "left",
          "new_api": "x",
          "old_text": "dst_rect.left()",
          "new_text": "clipped_rect.x()",
          "old_line_content": "    const int first_column = clipped_rect.left() - dst_rect.left();",
          "new_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": "x",
          "new_api": "pitch",
          "old_text": "clipped_rect.x()",
          "new_text": "m_target->pitch()",
          "old_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "new_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "left",
          "new_api": "pitch",
          "old_text": "src_rect.left()",
          "new_text": "source.pitch()",
          "old_line_content": "    const RGBA32* src = source.scanline(src_rect.top() + first_row) + src_rect.left() + first_column;",
          "new_line_content": "    const unsigned src_skip = source.pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": "Color::from_rgb(src[x])",
          "new_api": "Color::from_rgb(dst[x])",
          "old_text": "Color::from_rgb(src[x])",
          "new_text": "Color::from_rgb(dst[x])",
          "old_line_content": "            Color src_color_with_alpha = Color::from_rgb(src[x]);",
          "new_line_content": "            Color dst_color = Color::from_rgb(dst[x]);",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": "set_alpha",
          "new_api": "blend",
          "old_text": "src_color_with_alpha.set_alpha(alpha)",
          "new_text": "dst_color.blend(src_color_with_alpha).value()",
          "old_line_content": "            src_color_with_alpha.set_alpha(alpha);",
          "new_line_content": "            dst[x] = dst_color.blend(src_color_with_alpha).value();",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "rect",
          "new_api": "clip_rect",
          "old_text": "source.rect()",
          "new_text": "clip_rect()",
          "old_line_content": "    Rect safe_src_rect = src_rect.intersected(source.rect());",
          "new_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": "translation",
          "new_api": "is_empty",
          "old_text": "translation()",
          "new_text": "clipped_rect.is_empty()",
          "old_line_content": "    auto dst_rect = Rect(position, safe_src_rect.size()).translated(translation());",
          "new_line_content": "    if (clipped_rect.is_empty())",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "is_empty",
          "new_api": "top",
          "old_text": "clipped_rect.is_empty()",
          "new_text": "dst_rect.top()",
          "old_line_content": "    if (clipped_rect.is_empty())",
          "new_line_content": "    const int first_row = clipped_rect.top() - dst_rect.top();",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": "top",
          "new_api": "left",
          "old_text": "dst_rect.top()",
          "new_text": "dst_rect.left()",
          "old_line_content": "    const int first_row = clipped_rect.top() - dst_rect.top();",
          "new_line_content": "    const int first_column = clipped_rect.left() - dst_rect.left();",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": "top",
          "new_api": "left",
          "old_text": "dst_rect.top()",
          "new_text": "dst_rect.left()",
          "old_line_content": "    const int last_row = clipped_rect.bottom() - dst_rect.top();",
          "new_line_content": "    const int last_column = clipped_rect.right() - dst_rect.left();",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": "left",
          "new_api": "x",
          "old_text": "dst_rect.left()",
          "new_text": "clipped_rect.x()",
          "old_line_content": "    const int first_column = clipped_rect.left() - dst_rect.left();",
          "new_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": "x",
          "new_api": "pitch",
          "old_text": "clipped_rect.x()",
          "new_text": "m_target->pitch()",
          "old_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "new_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "left",
          "new_api": "pitch",
          "old_text": "src_rect.left()",
          "new_text": "source.pitch()",
          "old_line_content": "    const RGBA32* src = source.scanline(src_rect.top() + first_row) + src_rect.left() + first_column;",
          "new_line_content": "    const size_t src_skip = source.pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "alpha",
          "new_api": "Color::from_rgba(src[x])",
          "old_text": "Color::from_rgba(src[x]).alpha()",
          "new_text": "Color::from_rgba(src[x])",
          "old_line_content": "            u8 alpha = Color::from_rgba(src[x]).alpha();",
          "new_line_content": "                dst[x] = filter(Color::from_rgba(src[x])).value();",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": "translation",
          "new_api": "is_empty",
          "old_text": "translation()",
          "new_text": "clipped_rect.is_empty()",
          "old_line_content": "    auto dst_rect = a_dst_rect.translated(translation());",
          "new_line_content": "    if (clipped_rect.is_empty())",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "is_empty",
          "new_api": "top",
          "old_text": "clipped_rect.is_empty()",
          "new_text": "dst_rect.top()",
          "old_line_content": "    if (clipped_rect.is_empty())",
          "new_line_content": "    const int first_row = (clipped_rect.top() - dst_rect.top());",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": "top",
          "new_api": "left",
          "old_text": "dst_rect.top()",
          "new_text": "dst_rect.left()",
          "old_line_content": "    const int first_row = (clipped_rect.top() - dst_rect.top());",
          "new_line_content": "    const int first_column = (clipped_rect.left() - dst_rect.left());",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "top",
          "new_api": "x",
          "old_text": "dst_rect.top()",
          "new_text": "clipped_rect.x()",
          "old_line_content": "    const int last_row = (clipped_rect.bottom() - dst_rect.top());",
          "new_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": "left",
          "new_api": "pitch",
          "old_text": "dst_rect.left()",
          "new_text": "m_target->pitch()",
          "old_line_content": "    const int first_column = (clipped_rect.left() - dst_rect.left());",
          "new_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "pitch",
          "new_api": "format",
          "old_text": "m_target->pitch()",
          "new_text": "source.format()",
          "old_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "new_line_content": "    if (source.format() == BitmapFormat::RGB32 || source.format() == BitmapFormat::RGBA32) {",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": "left",
          "new_api": "top",
          "old_text": "a_dst_rect.left()",
          "new_text": "a_dst_rect.top()",
          "old_line_content": "        int x_start = first_column + a_dst_rect.left();",
          "new_line_content": "            const RGBA32* sl = source.scanline((row + a_dst_rect.top())",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": "top",
          "new_api": "width",
          "old_text": "a_dst_rect.top()",
          "new_text": "clipped_rect.width()",
          "old_line_content": "            const RGBA32* sl = source.scanline((row + a_dst_rect.top())",
          "new_line_content": "            for (int x = x_start; x < clipped_rect.width() + x_start; ++x) {",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": "translation",
          "new_api": "is_empty",
          "old_text": "translation()",
          "new_text": "clipped_rect.is_empty()",
          "old_line_content": "    auto dst_rect = Rect(position, src_rect.size()).translated(translation());",
          "new_line_content": "    if (clipped_rect.is_empty())",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": "is_empty",
          "new_api": "top",
          "old_text": "clipped_rect.is_empty()",
          "new_text": "dst_rect.top()",
          "old_line_content": "    if (clipped_rect.is_empty())",
          "new_line_content": "    const int first_row = (clipped_rect.top() - dst_rect.top());",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "top",
          "new_api": "left",
          "old_text": "dst_rect.top()",
          "new_text": "dst_rect.left()",
          "old_line_content": "    const int first_row = (clipped_rect.top() - dst_rect.top());",
          "new_line_content": "    const int first_column = (clipped_rect.left() - dst_rect.left());",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": "top",
          "new_api": "x",
          "old_text": "dst_rect.top()",
          "new_text": "clipped_rect.x()",
          "old_line_content": "    const int last_row = (clipped_rect.bottom() - dst_rect.top());",
          "new_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": "left",
          "new_api": "pitch",
          "old_text": "dst_rect.left()",
          "new_text": "m_target->pitch()",
          "old_line_content": "    const int first_column = (clipped_rect.left() - dst_rect.left());",
          "new_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": "pitch",
          "new_api": "format",
          "old_text": "m_target->pitch()",
          "new_text": "source.format()",
          "old_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "new_line_content": "    if (source.format() == BitmapFormat::RGB32 || source.format() == BitmapFormat::RGBA32) {",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": "left",
          "new_api": "top",
          "old_text": "src_rect.left()",
          "new_text": "src_rect.top()",
          "old_line_content": "        int x_start = first_column + src_rect.left();",
          "new_line_content": "            int sr = row - offset.y() + src_rect.top();",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "scanline",
          "new_api": "x",
          "old_text": "source.scanline(sr)",
          "new_text": "offset.x()",
          "old_line_content": "            const RGBA32* sl = source.scanline(sr);",
          "new_line_content": "                int sx = x - offset.x();",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": "width",
          "new_api": "size",
          "old_text": "clipped_rect.width()",
          "new_text": "source.size().width()",
          "old_line_content": "            for (int x = x_start; x < clipped_rect.width() + x_start; ++x) {",
          "new_line_content": "                if (sx < source.size().width() && sx >= 0)",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": "has_alpha_channel",
          "new_api": "translation",
          "old_text": "source.has_alpha_channel()",
          "new_text": "translation()",
          "old_line_content": "    ASSERT(source.has_alpha_channel());",
          "new_line_content": "    auto dst_rect = Rect(position, safe_src_rect.size()).translated(translation());",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "rect",
          "new_api": "clip_rect",
          "old_text": "source.rect()",
          "new_text": "clip_rect()",
          "old_line_content": "    Rect safe_src_rect = src_rect.intersected(source.rect());",
          "new_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": "translation",
          "new_api": "is_empty",
          "old_text": "translation()",
          "new_text": "clipped_rect.is_empty()",
          "old_line_content": "    auto dst_rect = Rect(position, safe_src_rect.size()).translated(translation());",
          "new_line_content": "    if (clipped_rect.is_empty())",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": "is_empty",
          "new_api": "top",
          "old_text": "clipped_rect.is_empty()",
          "new_text": "dst_rect.top()",
          "old_line_content": "    if (clipped_rect.is_empty())",
          "new_line_content": "    const int first_row = clipped_rect.top() - dst_rect.top();",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": "top",
          "new_api": "left",
          "old_text": "dst_rect.top()",
          "new_text": "dst_rect.left()",
          "old_line_content": "    const int first_row = clipped_rect.top() - dst_rect.top();",
          "new_line_content": "    const int first_column = clipped_rect.left() - dst_rect.left();",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": "top",
          "new_api": "left",
          "old_text": "dst_rect.top()",
          "new_text": "dst_rect.left()",
          "old_line_content": "    const int last_row = clipped_rect.bottom() - dst_rect.top();",
          "new_line_content": "    const int last_column = clipped_rect.right() - dst_rect.left();",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": "left",
          "new_api": "x",
          "old_text": "dst_rect.left()",
          "new_text": "clipped_rect.x()",
          "old_line_content": "    const int first_column = clipped_rect.left() - dst_rect.left();",
          "new_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": "x",
          "new_api": "pitch",
          "old_text": "clipped_rect.x()",
          "new_text": "m_target->pitch()",
          "old_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "new_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": "left",
          "new_api": "pitch",
          "old_text": "src_rect.left()",
          "new_text": "source.pitch()",
          "old_line_content": "    const RGBA32* src = source.scanline(src_rect.top() + first_row) + src_rect.left() + first_column;",
          "new_line_content": "    const size_t src_skip = source.pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": "blit_with_opacity",
          "new_api": "blit_with_alpha",
          "old_text": "blit_with_opacity(position, source, src_rect, opacity)",
          "new_text": "blit_with_alpha(position, source, src_rect)",
          "old_line_content": "        return blit_with_opacity(position, source, src_rect, opacity);",
          "new_line_content": "        return blit_with_alpha(position, source, src_rect);",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "has_alpha_channel",
          "new_api": "rect",
          "old_text": "source.has_alpha_channel()",
          "new_text": "source.rect()",
          "old_line_content": "    if (source.has_alpha_channel())",
          "new_line_content": "    auto safe_src_rect = src_rect.intersected(source.rect());",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "blit_with_alpha",
          "new_api": "rect",
          "old_text": "blit_with_alpha(position, source, src_rect)",
          "new_text": "source.rect().contains(safe_src_rect)",
          "old_line_content": "        return blit_with_alpha(position, source, src_rect);",
          "new_line_content": "    ASSERT(source.rect().contains(safe_src_rect));",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": "rect",
          "new_api": "translation",
          "old_text": "source.rect()",
          "new_text": "translation()",
          "old_line_content": "    auto safe_src_rect = src_rect.intersected(source.rect());",
          "new_line_content": "    auto dst_rect = Rect(position, safe_src_rect.size()).translated(translation());",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": "rect",
          "new_api": "clip_rect",
          "old_text": "source.rect().contains(safe_src_rect)",
          "new_text": "clip_rect()",
          "old_line_content": "    ASSERT(source.rect().contains(safe_src_rect));",
          "new_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": "translation",
          "new_api": "is_empty",
          "old_text": "translation()",
          "new_text": "clipped_rect.is_empty()",
          "old_line_content": "    auto dst_rect = Rect(position, safe_src_rect.size()).translated(translation());",
          "new_line_content": "    if (clipped_rect.is_empty())",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": "is_empty",
          "new_api": "top",
          "old_text": "clipped_rect.is_empty()",
          "new_text": "dst_rect.top()",
          "old_line_content": "    if (clipped_rect.is_empty())",
          "new_line_content": "    const int first_row = clipped_rect.top() - dst_rect.top();",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": "top",
          "new_api": "left",
          "old_text": "dst_rect.top()",
          "new_text": "dst_rect.left()",
          "old_line_content": "    const int first_row = clipped_rect.top() - dst_rect.top();",
          "new_line_content": "    const int first_column = clipped_rect.left() - dst_rect.left();",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": "top",
          "new_api": "x",
          "old_text": "dst_rect.top()",
          "new_text": "clipped_rect.x()",
          "old_line_content": "    const int last_row = clipped_rect.bottom() - dst_rect.top();",
          "new_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": "left",
          "new_api": "pitch",
          "old_text": "dst_rect.left()",
          "new_text": "m_target->pitch()",
          "old_line_content": "    const int first_column = clipped_rect.left() - dst_rect.left();",
          "new_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": "pitch",
          "new_api": "format",
          "old_text": "m_target->pitch()",
          "new_text": "source.format()",
          "old_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "new_line_content": "    if (source.format() == BitmapFormat::RGB32 || source.format() == BitmapFormat::RGBA32) {",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "format",
          "new_api": "pitch",
          "old_text": "source.format()",
          "new_text": "source.pitch()",
          "old_line_content": "    if (source.format() == BitmapFormat::RGB32 || source.format() == BitmapFormat::RGBA32) {",
          "new_line_content": "        const size_t src_skip = source.pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": "pitch",
          "new_api": "width",
          "old_text": "source.pitch()",
          "new_text": "clipped_rect.width()",
          "old_line_content": "        const size_t src_skip = source.pitch() / sizeof(RGBA32);",
          "new_line_content": "            fast_u32_copy(dst, src, clipped_rect.width());",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": "format",
          "new_api": "pitch",
          "old_text": "source.format()",
          "new_text": "source.pitch()",
          "old_line_content": "    if (source.format() == BitmapFormat::Indexed8) {",
          "new_line_content": "        const size_t src_skip = source.pitch();",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": "pitch",
          "new_api": "width",
          "old_text": "source.pitch()",
          "new_text": "clipped_rect.width()",
          "old_line_content": "        const size_t src_skip = source.pitch();",
          "new_line_content": "            for (int i = 0; i < clipped_rect.width(); ++i)",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": "y",
          "new_api": "get_pixel",
          "old_text": "dst_rect.y()",
          "new_text": "get_pixel(source, x, y)",
          "old_line_content": "        int dst_y = dst_rect.y() + y * vfactor;",
          "new_line_content": "            auto src_pixel = get_pixel(source, x, y);",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": "get_pixel",
          "new_api": "scanline",
          "old_text": "get_pixel(source, x, y)",
          "new_text": "target.scanline(dst_y + yo)",
          "old_line_content": "            auto src_pixel = get_pixel(source, x, y);",
          "new_line_content": "                auto* scanline = (Color*)target.scanline(dst_y + yo);",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": "height",
          "new_api": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 2, 2, get_pixel)",
          "old_text": "src_rect.height()",
          "new_text": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 2, 2, get_pixel)",
          "old_line_content": "        int vfactor = dst_rect.height() / src_rect.height();",
          "new_line_content": "            return do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 2, 2, get_pixel);",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 2, 2, get_pixel)",
          "new_api": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 3, 3, get_pixel)",
          "old_text": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 2, 2, get_pixel)",
          "new_text": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 3, 3, get_pixel)",
          "old_line_content": "            return do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 2, 2, get_pixel);",
          "new_line_content": "            return do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 3, 3, get_pixel);",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 3, 3, get_pixel)",
          "new_api": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 4, 4, get_pixel)",
          "old_text": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 3, 3, get_pixel)",
          "new_text": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 4, 4, get_pixel)",
          "old_line_content": "            return do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 3, 3, get_pixel);",
          "new_line_content": "            return do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 4, 4, get_pixel);",
          "content_same": false
        },
        {
          "line": 704,
          "old_api": "bottom",
          "new_api": "right",
          "old_text": "clipped_rect.bottom()",
          "new_text": "clipped_rect.right()",
          "old_line_content": "    for (int y = clipped_rect.top(); y <= clipped_rect.bottom(); ++y) {",
          "new_line_content": "        for (int x = clipped_rect.left(); x <= clipped_rect.right(); ++x) {",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": "scanline",
          "new_api": "x",
          "old_text": "target.scanline(y)",
          "new_text": "dst_rect.x()",
          "old_line_content": "        auto* scanline = (Color*)target.scanline(y);",
          "new_line_content": "            auto scaled_x = ((x - dst_rect.x()) * hscale) >> 16;",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": "right",
          "new_api": "y",
          "old_text": "clipped_rect.right()",
          "new_text": "dst_rect.y()",
          "old_line_content": "        for (int x = clipped_rect.left(); x <= clipped_rect.right(); ++x) {",
          "new_line_content": "            auto scaled_y = ((y - dst_rect.y()) * vscale) >> 16;",
          "content_same": false
        },
        {
          "line": 707,
          "old_api": "x",
          "new_api": "get_pixel",
          "old_text": "dst_rect.x()",
          "new_text": "get_pixel(source, scaled_x, scaled_y)",
          "old_line_content": "            auto scaled_x = ((x - dst_rect.x()) * hscale) >> 16;",
          "new_line_content": "            auto src_pixel = get_pixel(source, scaled_x, scaled_y);",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": "location",
          "new_api": "rect",
          "old_text": "dst_rect.location()",
          "new_text": "source.rect()",
          "old_line_content": "        return blit(dst_rect.location(), source, src_rect);",
          "new_line_content": "    auto safe_src_rect = src_rect.intersected(source.rect());",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "rect",
          "new_api": "state",
          "old_text": "source.rect()",
          "new_text": "state()",
          "old_line_content": "    auto safe_src_rect = src_rect.intersected(source.rect());",
          "new_line_content": "    dst_rect.move_by(state().translation);",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": "rect",
          "new_api": "clip_rect",
          "old_text": "source.rect().contains(safe_src_rect)",
          "new_text": "clip_rect()",
          "old_line_content": "    ASSERT(source.rect().contains(safe_src_rect));",
          "new_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": "state",
          "new_api": "is_empty",
          "old_text": "state()",
          "new_text": "clipped_rect.is_empty()",
          "old_line_content": "    dst_rect.move_by(state().translation);",
          "new_line_content": "    if (clipped_rect.is_empty())",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "height",
          "new_api": "has_alpha_channel",
          "old_text": "dst_rect.height()",
          "new_text": "source.has_alpha_channel()",
          "old_line_content": "    int vscale = (src_rect.height() << 16) / dst_rect.height();",
          "new_line_content": "    if (source.has_alpha_channel()) {",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": "format",
          "new_api": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGB32>)",
          "old_text": "source.format()",
          "new_text": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGB32>)",
          "old_line_content": "        switch (source.format()) {",
          "new_line_content": "            do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGB32>);",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": "format",
          "new_api": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGB32>)",
          "old_text": "source.format()",
          "new_text": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGB32>)",
          "old_line_content": "        switch (source.format()) {",
          "new_line_content": "            do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGB32>);",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "x",
          "new_api": "glyph_width",
          "old_text": "point.x()",
          "new_text": "font.glyph_width('x')",
          "old_line_content": "            point.x(),",
          "new_line_content": "            font.glyph_width('x'),",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "y",
          "new_api": "glyph_height",
          "old_text": "point.y()",
          "new_text": "font.glyph_height()",
          "old_line_content": "            point.y(),",
          "new_line_content": "            font.glyph_height()",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": "glyph_height",
          "new_api": "rect",
          "old_text": "font.glyph_height()",
          "new_text": "emoji.rect()",
          "old_line_content": "            font.glyph_height()",
          "new_line_content": "        draw_scaled_bitmap(dst_rect, emoji, emoji.rect());",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": "dbg",
          "new_api": "draw_glyph",
          "old_text": "dbg()",
          "new_text": "draw_glyph(point, '?', font, color)",
          "old_line_content": "        dbg() << \"Failed to find an emoji for codepoint \" << codepoint;",
          "new_line_content": "        draw_glyph(point, '?', font, color);",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": "width",
          "new_api": "glyph_spacing",
          "old_text": "font.width(final_text)",
          "new_text": "font.glyph_spacing()",
          "old_line_content": "        int text_width = font.width(final_text);",
          "new_line_content": "            int glyph_spacing = font.glyph_spacing();",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": "glyph_spacing",
          "new_api": "width",
          "old_text": "font.glyph_spacing()",
          "new_text": "font.width(\"...\")",
          "old_line_content": "            int glyph_spacing = font.glyph_spacing();",
          "new_line_content": "            int new_width = font.width(\"...\");",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": "width",
          "new_api": "end",
          "old_text": "font.width(\"...\")",
          "new_text": "final_text.end()",
          "old_line_content": "            int new_width = font.width(\"...\");",
          "new_line_content": "                for (auto it = final_text.begin(); it != final_text.end(); ++it) {",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "end",
          "new_api": "glyph_or_emoji_width",
          "old_text": "final_text.end()",
          "new_text": "font.glyph_or_emoji_width(codepoint)",
          "old_line_content": "                for (auto it = final_text.begin(); it != final_text.end(); ++it) {",
          "new_line_content": "                    int glyph_width = font.glyph_or_emoji_width(codepoint);",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": "width",
          "new_api": "byte_offset_of",
          "old_text": "rect.width()",
          "new_text": "final_text.byte_offset_of(it)",
          "old_line_content": "                    if (width_with_this_glyph_included > rect.width())",
          "new_line_content": "                    byte_offset = final_text.byte_offset_of(it);",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": "substring_view",
          "new_api": "to_string",
          "old_text": "final_text.substring_view(0, byte_offset).as_string()",
          "new_text": "builder.to_string()",
          "old_line_content": "                builder.append(final_text.substring_view(0, byte_offset).as_string());",
          "new_line_content": "                elided_text = builder.to_string();",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": "byte_offset_of",
          "new_api": "append",
          "old_text": "text.byte_offset_of(it)",
          "new_text": "lines.append(line)",
          "old_line_content": "            int byte_offset = text.byte_offset_of(it);",
          "new_line_content": "            lines.append(line);",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": "byte_length",
          "new_api": "append",
          "old_text": "text.byte_length()",
          "new_text": "lines.append(line)",
          "old_line_content": "    if (start_of_current_line != text.byte_length()) {",
          "new_line_content": "        lines.append(line);",
          "content_same": false
        },
        {
          "line": 910,
          "old_api": "width",
          "new_api": "set_width",
          "old_text": "font.width(line)",
          "new_text": "bounding_rect.set_width(line_width)",
          "old_line_content": "        auto line_width = font.width(line);",
          "new_line_content": "            bounding_rect.set_width(line_width);",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": "size",
          "new_api": "width",
          "old_text": "lines.size()",
          "new_text": "bounding_rect.width()",
          "old_line_content": "    for (size_t i = 0; i < lines.size(); ++i) {",
          "new_line_content": "        Rect line_rect { bounding_rect.x(), bounding_rect.y() + static_cast<int>(i) * line_height, bounding_rect.width(), line_height };",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": "width",
          "new_api": "draw_text_line",
          "old_text": "bounding_rect.width()",
          "new_text": "draw_text_line(line_rect, line, font, alignment, color, elision)",
          "old_line_content": "        Rect line_rect { bounding_rect.x(), bounding_rect.y() + static_cast<int>(i) * line_height, bounding_rect.width(), line_height };",
          "new_line_content": "        draw_text_line(line_rect, line, font, alignment, color, elision);",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": "contains",
          "new_api": "value",
          "old_text": "clip_rect().contains(point)",
          "new_text": "color.value()",
          "old_line_content": "    if (!clip_rect().contains(point))",
          "new_line_content": "    m_target->scanline(point.y())[point.x()] = color.value();",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": "draw_op",
          "new_api": "x",
          "old_text": "draw_op()",
          "new_text": "position.x()",
          "old_line_content": "    ASSERT(draw_op() == DrawOp::Copy);",
          "new_line_content": "        return set_pixel_with_draw_op(m_target->scanline(position.y())[position.x()], color);",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": "x",
          "new_api": "state",
          "old_text": "position.x()",
          "new_text": "state()",
          "old_line_content": "        return set_pixel_with_draw_op(m_target->scanline(position.y())[position.x()], color);",
          "new_line_content": "    fill_rect(rect.translated(-state().translation), color);",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": "x",
          "new_api": "right",
          "old_text": "point2.x()",
          "new_text": "clip_rect.right()",
          "old_line_content": "    if (point1.x() == point2.x()) {",
          "new_line_content": "        if (x < clip_rect.left() || x > clip_rect.right())",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "right",
          "new_api": "y",
          "old_text": "clip_rect.right()",
          "new_text": "point2.y()",
          "old_line_content": "        if (x < clip_rect.left() || x > clip_rect.right())",
          "new_line_content": "        if (point1.y() > point2.y())",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": "y",
          "new_api": "bottom",
          "old_text": "point2.y()",
          "new_text": "clip_rect.bottom()",
          "old_line_content": "        if (point1.y() > point2.y())",
          "new_line_content": "        if (point1.y() > clip_rect.bottom())",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": "bottom",
          "new_api": "top",
          "old_text": "clip_rect.bottom()",
          "new_text": "clip_rect.top()",
          "old_line_content": "        if (point1.y() > clip_rect.bottom())",
          "new_line_content": "        if (point2.y() < clip_rect.top())",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": "draw_pixel",
          "new_api": "min",
          "old_text": "draw_pixel({ x, y }, color, thickness)",
          "new_text": "min(y + thickness * 2, max_y)",
          "old_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "new_line_content": "                draw_pixel({ x, min(y + thickness * 2, max_y) }, color, thickness);",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": "y",
          "new_api": "bottom",
          "old_text": "point2.y()",
          "new_text": "clip_rect.bottom()",
          "old_line_content": "    if (point1.y() == point2.y()) {",
          "new_line_content": "        if (y < clip_rect.top() || y > clip_rect.bottom())",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": "bottom",
          "new_api": "x",
          "old_text": "clip_rect.bottom()",
          "new_text": "point2.x()",
          "old_line_content": "        if (y < clip_rect.top() || y > clip_rect.bottom())",
          "new_line_content": "        if (point1.x() > point2.x())",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "x",
          "new_api": "right",
          "old_text": "point2.x()",
          "new_text": "clip_rect.right()",
          "old_line_content": "        if (point1.x() > point2.x())",
          "new_line_content": "        if (point1.x() > clip_rect.right())",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": "right",
          "new_api": "left",
          "old_text": "clip_rect.right()",
          "new_text": "clip_rect.left()",
          "old_line_content": "        if (point1.x() > clip_rect.right())",
          "new_line_content": "        if (point2.x() < clip_rect.left())",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": "draw_pixel",
          "new_api": "min",
          "old_text": "draw_pixel({ x, y }, color, thickness)",
          "new_text": "min(x + thickness * 2, max_x)",
          "old_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "new_line_content": "                draw_pixel({ min(x + thickness * 2, max_x), y }, color, thickness);",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "ASSERT",
          "new_api": "x",
          "old_text": "ASSERT(style == LineStyle::Solid)",
          "new_text": "point1.x()",
          "old_line_content": "    ASSERT(style == LineStyle::Solid);",
          "new_line_content": "    const double adx = abs(point2.x() - point1.x());",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": "swap",
          "new_api": "y",
          "old_text": "swap(point1, point2)",
          "new_text": "point2.y()",
          "old_line_content": "            swap(point1, point2);",
          "new_line_content": "        if (point1.y() > point2.y())",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": "fabs",
          "new_api": "x",
          "old_text": "fabs(dy / dx)",
          "new_text": "point2.x()",
          "old_line_content": "        const double delta_error = fabs(dy / dx);",
          "new_line_content": "        for (int x = point1.x(); x <= point2.x(); ++x) {",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": "y",
          "new_api": "contains",
          "old_text": "point1.y()",
          "new_text": "clip_rect.contains(x, y)",
          "old_line_content": "        int y = point1.y();",
          "new_line_content": "            if (clip_rect.contains(x, y))",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": "x",
          "new_api": "draw_pixel",
          "old_text": "point2.x()",
          "new_text": "draw_pixel({ x, y }, color, thickness)",
          "old_line_content": "        for (int x = point1.x(); x <= point2.x(); ++x) {",
          "new_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": "fabs",
          "new_api": "y",
          "old_text": "fabs(dx / dy)",
          "new_text": "point2.y()",
          "old_line_content": "        const double delta_error = fabs(dx / dy);",
          "new_line_content": "        for (int y = point1.y(); y <= point2.y(); ++y) {",
          "content_same": false
        },
        {
          "line": 1072,
          "old_api": "x",
          "new_api": "contains",
          "old_text": "point1.x()",
          "new_text": "clip_rect.contains(x, y)",
          "old_line_content": "        int x = point1.x();",
          "new_line_content": "            if (clip_rect.contains(x, y))",
          "content_same": false
        },
        {
          "line": 1073,
          "old_api": "y",
          "new_api": "draw_pixel",
          "old_text": "point2.y()",
          "new_text": "draw_pixel({ x, y }, color, thickness)",
          "old_line_content": "        for (int y = point1.y(); y <= point2.y(); ++y) {",
          "new_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": "constexpr",
          "new_api": "x",
          "old_text": "constexpr",
          "new_text": "p2.x()",
          "old_line_content": "    constexpr static int tolerance = 15;",
          "new_line_content": "    auto p1x = 3 * control.x() - 2 * p1.x() - p2.x();",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": "callback",
          "new_api": "split_quadratic_bezier_curve",
          "old_text": "callback(p1, p2)",
          "new_text": "split_quadratic_bezier_curve(control_point, p1, p2, callback)",
          "old_line_content": "        callback(p1, p2);",
          "new_line_content": "        split_quadratic_bezier_curve(control_point, p1, p2, callback);",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": "split_lines",
          "new_api": "size",
          "old_text": "path.split_lines()",
          "new_text": "segments.size()",
          "old_line_content": "    const auto& segments = path.split_lines();",
          "new_line_content": "    if (segments.size() == 0)",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": "size",
          "new_api": "quick_sort",
          "old_text": "active_list.size()",
          "new_text": "quick_sort(active_list, [](const auto& line0, const auto& line1) {\n                return line1.x < line0.x;\n            })",
          "old_line_content": "        if (active_list.size()) {",
          "new_line_content": "            quick_sort(active_list, [](const auto& line0, const auto& line1) {",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": "dbg",
          "new_api": "draw_line",
          "old_text": "dbg()",
          "new_text": "draw_line(from, to, color, 1)",
          "old_line_content": "                        dbg() << \"y=\" << scanline << \": \" << winding_number << \" at \" << i << \": \" << from << \" -- \" << to;",
          "new_line_content": "                        draw_line(from, to, color, 1);",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": "last",
          "new_api": "Point",
          "old_text": "active_list.last()",
          "new_text": "Point(active_list[0].x, scanline)",
          "old_line_content": "                active_list.last().x -= active_list.last().inverse_slope;",
          "new_line_content": "                auto point = Point(active_list[0].x, scanline);",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": "size",
          "new_api": "remove",
          "old_text": "active_list.size()",
          "new_text": "active_list.remove(i)",
          "old_line_content": "        for (size_t i = 0, count = active_list.size(); i < count; ++i) {",
          "new_line_content": "                active_list.remove(i);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1024,
          "old_api": null,
          "new_api": "draw_pixel",
          "old_text": null,
          "new_text": "draw_pixel({ x, y }, color, thickness)",
          "old_line_content": "        } else if (style == LineStyle::Dashed) {",
          "new_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "content_same": false
        },
        {
          "line": 513,
          "old_api": null,
          "new_api": "lightened",
          "old_text": null,
          "new_text": "blit_filtered(position, source, src_rect, [](Color src) {\n        return src.lightened();\n    })",
          "old_line_content": "void Painter::blit_brightened(const Point& position, const Gfx::Bitmap& source, const Rect& src_rect)",
          "new_line_content": "    return blit_filtered(position, source, src_rect, [](Color src) {",
          "content_same": false
        },
        {
          "line": 514,
          "old_api": null,
          "new_api": "lightened",
          "old_text": null,
          "new_text": "src.lightened()",
          "old_line_content": "{",
          "new_line_content": "        return src.lightened();",
          "content_same": false
        },
        {
          "line": 1025,
          "old_api": null,
          "new_api": "min",
          "old_text": null,
          "new_text": "min(x + thickness, max_x)",
          "old_line_content": "            for (int x = min_x; x <= max_x; x += thickness * 6) {",
          "new_line_content": "                draw_pixel({ min(x + thickness, max_x), y }, color, thickness);",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": null,
          "new_api": "draw_pixel",
          "old_text": null,
          "new_text": "draw_pixel({ x, y }, color, thickness)",
          "old_line_content": "        } else {",
          "new_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": null,
          "new_api": "to_grayscale",
          "old_text": null,
          "new_text": "blit_filtered(position, source, src_rect, [](Color src) {\n        return src.to_grayscale().lightened();\n    })",
          "old_line_content": "void Painter::blit_dimmed(const Point& position, const Gfx::Bitmap& source, const Rect& src_rect)",
          "new_line_content": "    return blit_filtered(position, source, src_rect, [](Color src) {",
          "content_same": false
        },
        {
          "line": 521,
          "old_api": null,
          "new_api": "to_grayscale",
          "old_text": null,
          "new_text": "src.to_grayscale().lightened()",
          "old_line_content": "{",
          "new_line_content": "        return src.to_grayscale().lightened();",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": null,
          "new_api": "ASSERT",
          "old_text": null,
          "new_text": "ASSERT(style == LineStyle::Solid)",
          "old_line_content": "",
          "new_line_content": "    ASSERT(style == LineStyle::Solid);",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": null,
          "new_api": "translation",
          "old_text": null,
          "new_text": "translation()",
          "old_line_content": "void Painter::draw_tiled_bitmap(const Rect& a_dst_rect, const Gfx::Bitmap& source)",
          "new_line_content": "    auto dst_rect = a_dst_rect.translated(translation());",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": null,
          "new_api": "clip_rect",
          "old_text": null,
          "new_text": "clip_rect()",
          "old_line_content": "{",
          "new_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "point1.y()",
          "old_line_content": "",
          "new_line_content": "    const double ady = abs(point2.y() - point1.y());",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": null,
          "new_api": "x",
          "old_text": null,
          "new_text": "point2.x()",
          "old_line_content": "",
          "new_line_content": "        if (point1.x() > point2.x())",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": null,
          "new_api": "swap",
          "old_text": null,
          "new_text": "swap(point1, point2)",
          "old_line_content": "    if (adx > ady) {",
          "new_line_content": "            swap(point1, point2);",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "dst_rect.top()",
          "old_line_content": "        return;",
          "new_line_content": "    const int last_row = (clipped_rect.bottom() - dst_rect.top());",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": null,
          "new_api": "swap",
          "old_text": null,
          "new_text": "swap(point1, point2)",
          "old_line_content": "    } else {",
          "new_line_content": "            swap(point1, point2);",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": null,
          "new_api": "left",
          "old_text": null,
          "new_text": "a_dst_rect.left()",
          "old_line_content": "",
          "new_line_content": "        int x_start = first_column + a_dst_rect.left();",
          "content_same": false
        },
        {
          "line": 1050,
          "old_api": null,
          "new_api": "x",
          "old_text": null,
          "new_text": "point1.x()",
          "old_line_content": "",
          "new_line_content": "    const double dx = point2.x() - point1.x();",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "point1.y()",
          "old_line_content": "    // FIXME: Implement clipping below.",
          "new_line_content": "    const double dy = point2.y() - point1.y();",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "source.size().height()",
          "old_line_content": "        for (int row = first_row; row <= last_row; ++row) {",
          "new_line_content": "                % source.size().height());",
          "content_same": false
        },
        {
          "line": 1056,
          "old_api": null,
          "new_api": "fabs",
          "old_text": null,
          "new_text": "fabs(dy / dx)",
          "old_line_content": "    if (dx > dy) {",
          "new_line_content": "        const double delta_error = fabs(dy / dx);",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "point1.y()",
          "old_line_content": "        const double y_step = dy == 0 ? 0 : (dy > 0 ? 1 : -1);",
          "new_line_content": "        int y = point1.y();",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": null,
          "new_api": "ASSERT_NOT_REACHED",
          "old_text": null,
          "new_text": "ASSERT_NOT_REACHED()",
          "old_line_content": "    }",
          "new_line_content": "    ASSERT_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 1069,
          "old_api": null,
          "new_api": "fabs",
          "old_text": null,
          "new_text": "fabs(dx / dy)",
          "old_line_content": "    } else {",
          "new_line_content": "        const double delta_error = fabs(dx / dy);",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": null,
          "new_api": "translation",
          "old_text": null,
          "new_text": "translation()",
          "old_line_content": "    const Point& offset)",
          "new_line_content": "    auto dst_rect = Rect(position, src_rect.size()).translated(translation());",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": null,
          "new_api": "clip_rect",
          "old_text": null,
          "new_text": "clip_rect()",
          "old_line_content": "{",
          "new_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": null,
          "new_api": "x",
          "old_text": null,
          "new_text": "point1.x()",
          "old_line_content": "        const double x_step = dx == 0 ? 0 : (dx > 0 ? 1 : -1);",
          "new_line_content": "        int x = point1.x();",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "dst_rect.top()",
          "old_line_content": "        return;",
          "new_line_content": "    const int last_row = (clipped_rect.bottom() - dst_rect.top());",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": null,
          "new_api": "left",
          "old_text": null,
          "new_text": "src_rect.left()",
          "old_line_content": "",
          "new_line_content": "        int x_start = first_column + src_rect.left();",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "source.size().height()",
          "old_line_content": "        for (int row = first_row; row <= last_row; ++row) {",
          "new_line_content": "            if (sr >= source.size().height() || sr < 0) {",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": null,
          "new_api": "scanline",
          "old_text": null,
          "new_text": "source.scanline(sr)",
          "old_line_content": "                continue;",
          "new_line_content": "            const RGBA32* sl = source.scanline(sr);",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "clipped_rect.width()",
          "old_line_content": "            }",
          "new_line_content": "            for (int x = x_start; x < clipped_rect.width() + x_start; ++x) {",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": null,
          "new_api": "Painter::for_each_line_segment_on_bezier_curve(po1_midpoint, p1, new_segment, callback)",
          "old_text": null,
          "new_text": "Painter::for_each_line_segment_on_bezier_curve(po1_midpoint, p1, new_segment, callback)",
          "old_line_content": "    new_segment /= 2;",
          "new_line_content": "    Painter::for_each_line_segment_on_bezier_curve(po1_midpoint, p1, new_segment, callback);",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": null,
          "new_api": "Painter::for_each_line_segment_on_bezier_curve(po2_midpoint, new_segment, p2, callback)",
          "old_text": null,
          "new_text": "Painter::for_each_line_segment_on_bezier_curve(po2_midpoint, new_segment, p2, callback)",
          "old_line_content": "",
          "new_line_content": "    Painter::for_each_line_segment_on_bezier_curve(po2_midpoint, new_segment, p2, callback);",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": null,
          "new_api": "ASSERT_NOT_REACHED",
          "old_text": null,
          "new_text": "ASSERT_NOT_REACHED()",
          "old_line_content": "    }",
          "new_line_content": "    ASSERT_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "static bool can_approximate_bezier_curve(const FloatPoint& p1, const FloatPoint& p2, const FloatPoint& control)",
          "new_line_content": "    constexpr static int tolerance = 15;",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "p2.y()",
          "old_line_content": "",
          "new_line_content": "    auto p1y = 3 * control.y() - 2 * p1.y() - p2.y();",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": null,
          "new_api": "has_alpha_channel",
          "old_text": null,
          "new_text": "source.has_alpha_channel()",
          "old_line_content": "void Painter::blit_with_alpha(const Point& position, const Gfx::Bitmap& source, const Rect& src_rect)",
          "new_line_content": "    ASSERT(source.has_alpha_channel());",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": null,
          "new_api": "rect",
          "old_text": null,
          "new_text": "source.rect()",
          "old_line_content": "{",
          "new_line_content": "    Rect safe_src_rect = src_rect.intersected(source.rect());",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "dst_rect.top()",
          "old_line_content": "        return;",
          "new_line_content": "    const int last_row = clipped_rect.bottom() - dst_rect.top();",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": null,
          "new_api": "max",
          "old_text": null,
          "new_text": "max(p1y, p2y)",
          "old_line_content": "    p2y = p2y * p2y;",
          "new_line_content": "    return max(p1x, p2x) + max(p1y, p2y) <= tolerance;",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": null,
          "new_api": "can_approximate_bezier_curve",
          "old_text": null,
          "new_text": "can_approximate_bezier_curve(p1, p2, control_point)",
          "old_line_content": "void Painter::for_each_line_segment_on_bezier_curve(const FloatPoint& control_point, const FloatPoint& p1, const FloatPoint& p2, Function<void(const FloatPoint&, const FloatPoint&)>& callback)",
          "new_line_content": "    if (can_approximate_bezier_curve(p1, p2, control_point)) {",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": null,
          "new_api": "callback",
          "old_text": null,
          "new_text": "callback(p1, p2)",
          "old_line_content": "{",
          "new_line_content": "        callback(p1, p2);",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": null,
          "new_api": "alpha",
          "old_text": null,
          "new_text": "Color::from_rgba(src[x]).alpha()",
          "old_line_content": "    for (int row = first_row; row <= last_row; ++row) {",
          "new_line_content": "            u8 alpha = Color::from_rgba(src[x]).alpha();",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": null,
          "new_api": "for_each_line_segment_on_bezier_curve",
          "old_text": null,
          "new_text": "for_each_line_segment_on_bezier_curve(control_point, p1, p2, callback)",
          "old_line_content": "void Painter::for_each_line_segment_on_bezier_curve(const FloatPoint& control_point, const FloatPoint& p1, const FloatPoint& p2, Function<void(const FloatPoint&, const FloatPoint&)>&& callback)",
          "new_line_content": "    for_each_line_segment_on_bezier_curve(control_point, p1, p2, callback);",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": null,
          "new_api": "Color::from_rgba(src[x])",
          "old_text": null,
          "new_text": "Color::from_rgba(src[x])",
          "old_line_content": "                continue;",
          "new_line_content": "                dst[x] = Color::from_rgba(dst[x]).blend(Color::from_rgba(src[x])).value();",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "p2.y()",
          "old_line_content": "void Painter::draw_quadratic_bezier_curve(const Point& control_point, const Point& p1, const Point& p2, Color color, int thickness, LineStyle style)",
          "new_line_content": "    for_each_line_segment_on_bezier_curve(FloatPoint(control_point.x(), control_point.y()), FloatPoint(p1.x(), p1.y()), FloatPoint(p2.x(), p2.y()), [&](const FloatPoint& p1, const FloatPoint& p2) {",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "p2.y()",
          "old_line_content": "{",
          "new_line_content": "        draw_line(Point(p1.x(), p1.y()), Point(p2.x(), p2.y()), color, thickness, style);",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": null,
          "new_api": "blit_with_opacity",
          "old_text": null,
          "new_text": "blit_with_opacity(position, source, src_rect, opacity)",
          "old_line_content": "{",
          "new_line_content": "        return blit_with_opacity(position, source, src_rect, opacity);",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": null,
          "new_api": "has_alpha_channel",
          "old_text": null,
          "new_text": "source.has_alpha_channel()",
          "old_line_content": "    if (opacity < 1.0f)",
          "new_line_content": "    if (source.has_alpha_channel())",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": null,
          "new_api": "location",
          "old_text": null,
          "new_text": "m_clip_origin.location()",
          "old_line_content": "void Painter::add_clip_rect(const Rect& rect)",
          "new_line_content": "    state().clip_rect.intersect(rect.translated(m_clip_origin.location()));",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": null,
          "new_api": "rect",
          "old_text": null,
          "new_text": "m_target->rect()",
          "old_line_content": "{",
          "new_line_content": "    state().clip_rect.intersect(m_target->rect());",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": null,
          "new_api": "state",
          "old_text": null,
          "new_text": "state()",
          "old_line_content": "void Painter::clear_clip_rect()",
          "new_line_content": "    state().clip_rect = m_clip_origin;",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "dst_rect.top()",
          "old_line_content": "        return;",
          "new_line_content": "    const int last_row = clipped_rect.bottom() - dst_rect.top();",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": null,
          "new_api": "save",
          "old_text": null,
          "new_text": "m_painter.save()",
          "old_line_content": "    : m_painter(painter)",
          "new_line_content": "    m_painter.save();",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": null,
          "new_api": "left",
          "old_text": null,
          "new_text": "src_rect.left()",
          "old_line_content": "",
          "new_line_content": "        const RGBA32* src = source.scanline(src_rect.top() + first_row) + src_rect.left() + first_column;",
          "content_same": false
        },
        {
          "line": 1155,
          "old_api": null,
          "new_api": "restore",
          "old_text": null,
          "new_text": "m_painter.restore()",
          "old_line_content": "PainterStateSaver::~PainterStateSaver()",
          "new_line_content": "    m_painter.restore();",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": null,
          "new_api": "segments",
          "old_text": null,
          "new_text": "path.segments()",
          "old_line_content": "    FloatPoint cursor;",
          "new_line_content": "    for (auto& segment : path.segments()) {",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": null,
          "new_api": "format",
          "old_text": null,
          "new_text": "source.format()",
          "old_line_content": "    }",
          "new_line_content": "    if (source.format() == BitmapFormat::Indexed8) {",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": null,
          "new_api": "left",
          "old_text": null,
          "new_text": "src_rect.left()",
          "old_line_content": "",
          "new_line_content": "        const u8* src = source.bits(src_rect.top() + first_row) + src_rect.left() + first_column;",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": null,
          "new_api": "ASSERT_NOT_REACHED",
          "old_text": null,
          "new_text": "ASSERT_NOT_REACHED()",
          "old_line_content": "        switch (segment.type) {",
          "new_line_content": "            ASSERT_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": null,
          "new_api": "palette_color",
          "old_text": null,
          "new_text": "source.palette_color(src[i]).value()",
          "old_line_content": "        for (int row = first_row; row <= last_row; ++row) {",
          "new_line_content": "                dst[i] = source.palette_color(src[i]).value();",
          "content_same": false
        },
        {
          "line": 1171,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "segment.point.y()",
          "old_line_content": "            break;",
          "new_line_content": "            draw_line(Point(cursor.x(), cursor.y()), Point(segment.point.x(), segment.point.y()), color, thickness);",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": null,
          "new_api": "ASSERT_NOT_REACHED",
          "old_text": null,
          "new_text": "ASSERT_NOT_REACHED()",
          "old_line_content": "    }",
          "new_line_content": "    ASSERT_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "segment.through.has_value()",
          "old_line_content": "            break;",
          "new_line_content": "            ASSERT(segment.through.has_value());",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "segment.point.y()",
          "old_line_content": "        case Path::Segment::Type::QuadraticBezierCurveTo:",
          "new_line_content": "            draw_quadratic_bezier_curve(Point(segment.through.value().x(), segment.through.value().y()), Point(cursor.x(), cursor.y()), Point(segment.point.x(), segment.point.y()), color, thickness);",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": null,
          "new_api": "rect",
          "old_text": null,
          "new_text": "source.rect().bottom()",
          "old_line_content": "ALWAYS_INLINE static void do_draw_integer_scaled_bitmap(Gfx::Bitmap& target, const Rect& dst_rect, const Gfx::Bitmap& source, int hfactor, int vfactor, GetPixel get_pixel)",
          "new_line_content": "    for (int y = source.rect().top(); y <= source.rect().bottom(); ++y) {",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "dst_rect.y()",
          "old_line_content": "{",
          "new_line_content": "        int dst_y = dst_rect.y() + y * vfactor;",
          "content_same": false
        },
        {
          "line": 159,
          "old_api": null,
          "new_api": "clip_rect",
          "old_text": null,
          "new_text": "clip_rect()",
          "old_line_content": "void Painter::fill_rect_with_checkerboard(const Rect& a_rect, const Size& cell_size, Color color_dark, Color color_light)",
          "new_line_content": "    auto rect = a_rect.translated(translation()).intersected(clip_rect());",
          "content_same": false
        },
        {
          "line": 160,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "rect.is_empty()",
          "old_line_content": "{",
          "new_line_content": "    if (rect.is_empty())",
          "content_same": false
        },
        {
          "line": 163,
          "old_api": null,
          "new_api": "left",
          "old_text": null,
          "new_text": "rect.left()",
          "old_line_content": "        return;",
          "new_line_content": "    RGBA32* dst = m_target->scanline(rect.top()) + rect.left();",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": null,
          "new_api": "pitch",
          "old_text": null,
          "new_text": "m_target->pitch()",
          "old_line_content": "",
          "new_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": null,
          "new_api": "x",
          "old_text": null,
          "new_text": "dst_rect.x()",
          "old_line_content": "            for (int yo = 0; yo < vfactor; ++yo) {",
          "new_line_content": "                int dst_x = dst_rect.x() + x * hfactor;",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": null,
          "new_api": "blend",
          "old_text": null,
          "new_text": "scanline[dst_x + xo].blend(src_pixel)",
          "old_line_content": "                for (int xo = 0; xo < hfactor; ++xo) {",
          "new_line_content": "                        scanline[dst_x + xo] = scanline[dst_x + xo].blend(src_pixel);",
          "content_same": false
        },
        {
          "line": 167,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "rect.width()",
          "old_line_content": "",
          "new_line_content": "        for (int j = 0; j < rect.width(); ++j) {",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": null,
          "new_api": "split_lines",
          "old_text": null,
          "new_text": "path.split_lines()",
          "old_line_content": "void Painter::fill_path(Path& path, Color color, WindingRule winding_rule)",
          "new_line_content": "    const auto& segments = path.split_lines();",
          "content_same": false
        },
        {
          "line": 1193,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "segments.size()",
          "old_line_content": "",
          "new_line_content": "    active_list.ensure_capacity(segments.size());",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": null,
          "new_api": "first",
          "old_text": null,
          "new_text": "segments.first()",
          "old_line_content": "",
          "new_line_content": "    auto first_y = segments.first().maximum_y;",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": null,
          "new_api": "last",
          "old_text": null,
          "new_text": "segments.last()",
          "old_line_content": "    // first, grab the segments for the very first scanline",
          "new_line_content": "    auto last_y = segments.last().minimum_y;",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": null,
          "new_api": "height",
          "old_text": null,
          "new_text": "src_rect.height()",
          "old_line_content": "ALWAYS_INLINE static void do_draw_scaled_bitmap(Gfx::Bitmap& target, const Rect& dst_rect, const Rect& clipped_rect, const Gfx::Bitmap& source, const Rect& src_rect, int hscale, int vscale, GetPixel get_pixel)",
          "new_line_content": "    if (dst_rect == clipped_rect && !(dst_rect.width() % src_rect.width()) && !(dst_rect.height() % src_rect.height())) {",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": null,
          "new_api": "fill_rect",
          "old_text": null,
          "new_text": "fill_rect(a_rect, gradient_start)",
          "old_line_content": "{",
          "new_line_content": "    return fill_rect(a_rect, gradient_start);",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "src_rect.width()",
          "old_line_content": "{",
          "new_line_content": "        int hfactor = dst_rect.width() / src_rect.width();",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "active_list.append(segment)",
          "old_line_content": "        if (segment.maximum_y != scanline)",
          "new_line_content": "        active_list.append(segment);",
          "content_same": false
        },
        {
          "line": 182,
          "old_api": null,
          "new_api": "clip_rect",
          "old_text": null,
          "new_text": "clip_rect()",
          "old_line_content": "#endif",
          "new_line_content": "    auto clipped_rect = Rect::intersection(rect, clip_rect());",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": null,
          "new_api": "primary_offset_for_orientation",
          "old_text": null,
          "new_text": "rect.primary_offset_for_orientation(orientation)",
          "old_line_content": "        return;",
          "new_line_content": "    int offset = clipped_rect.primary_offset_for_orientation(orientation) - rect.primary_offset_for_orientation(orientation);",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": null,
          "new_api": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, hfactor, vfactor, get_pixel)",
          "old_text": null,
          "new_text": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, hfactor, vfactor, get_pixel)",
          "old_line_content": "        if (hfactor == 4 && vfactor == 4)",
          "new_line_content": "        return do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, hfactor, vfactor, get_pixel);",
          "content_same": false
        },
        {
          "line": 189,
          "old_api": null,
          "new_api": "pitch",
          "old_text": null,
          "new_text": "m_target->pitch()",
          "old_line_content": "",
          "new_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": null,
          "new_api": "bottom",
          "old_text": null,
          "new_text": "clipped_rect.bottom()",
          "old_line_content": "    }",
          "new_line_content": "    for (int y = clipped_rect.top(); y <= clipped_rect.bottom(); ++y) {",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": null,
          "new_api": "scanline",
          "old_text": null,
          "new_text": "target.scanline(y)",
          "old_line_content": "",
          "new_line_content": "        auto* scanline = (Color*)target.scanline(y);",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": null,
          "new_api": "ASSERT_NOT_REACHED",
          "old_text": null,
          "new_text": "ASSERT_NOT_REACHED()",
          "old_line_content": "            return winding_number % 2 == 0;",
          "new_line_content": "        ASSERT_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 194,
          "old_api": null,
          "new_api": "green",
          "old_text": null,
          "new_text": "gradient_start.green()",
          "old_line_content": "",
          "new_line_content": "    int g2 = gradient_start.green();",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": null,
          "new_api": "blend",
          "old_text": null,
          "new_text": "scanline[x].blend(src_pixel)",
          "old_line_content": "",
          "new_line_content": "                scanline[x] = scanline[x].blend(src_pixel);",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": null,
          "new_api": "height",
          "old_text": null,
          "new_text": "clipped_rect.height()",
          "old_line_content": "",
          "new_line_content": "        for (int i = clipped_rect.height() - 1; i >= 0; --i) {",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": null,
          "new_api": "dy_relative_to",
          "old_text": null,
          "new_text": "from.dy_relative_to(to)",
          "old_line_content": "",
          "new_line_content": "            if (from.dy_relative_to(to) < 0)",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "Color(\n                    r1 / 255.0 * c + r2 / 255.0 * (255 - c),\n                    g1 / 255.0 * c + g2 / 255.0 * (255 - c),\n                    b1 / 255.0 * c + b2 / 255.0 * (255 - c))\n                             .value()",
          "old_line_content": "            float c = offset * increment;",
          "new_line_content": "                dst[j] = Color(",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "src_rect.size()",
          "old_line_content": "{",
          "new_line_content": "    if (dst_rect.size() == src_rect.size())",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "location",
          "old_text": null,
          "new_text": "dst_rect.location()",
          "old_line_content": "    auto dst_rect = a_dst_rect;",
          "new_line_content": "        return blit(dst_rect.location(), source, src_rect);",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": null,
          "new_api": "ASSERT_NOT_REACHED",
          "old_text": null,
          "new_text": "ASSERT_NOT_REACHED()",
          "old_line_content": "        }",
          "new_line_content": "        ASSERT_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": null,
          "new_api": "rect",
          "old_text": null,
          "new_text": "source.rect().contains(safe_src_rect)",
          "old_line_content": "",
          "new_line_content": "    ASSERT(source.rect().contains(safe_src_rect));",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "active_list.size()",
          "old_line_content": "",
          "new_line_content": "        if (active_list.size()) {",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": null,
          "new_api": "height",
          "old_text": null,
          "new_text": "clipped_rect.height()",
          "old_line_content": "    } else {",
          "new_line_content": "        for (int i = clipped_rect.height() - 1; i >= 0; --i) {",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "dst_rect.width()",
          "old_line_content": "        return;",
          "new_line_content": "    int hscale = (src_rect.width() << 16) / dst_rect.width();",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "height",
          "old_text": null,
          "new_text": "dst_rect.height()",
          "old_line_content": "",
          "new_line_content": "    int vscale = (src_rect.height() << 16) / dst_rect.height();",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "clipped_rect.width()",
          "old_line_content": "                g1 / 255.0 * c + g2 / 255.0 * (255 - c),",
          "new_line_content": "            for (int j = 0; j < clipped_rect.width(); ++j) {",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "color.value()",
          "old_line_content": "                b1 / 255.0 * c + b2 / 255.0 * (255 - c));",
          "new_line_content": "                dst[j] = color.value();",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": null,
          "new_api": "format",
          "old_text": null,
          "new_text": "source.format()",
          "old_line_content": "",
          "new_line_content": "        switch (source.format()) {",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": null,
          "new_api": "String::format(\"%d\", (int)scanline)",
          "old_text": null,
          "new_text": "String::format(\"%d\", (int)scanline)",
          "old_line_content": "#ifdef FILL_PATH_DEBUG",
          "new_line_content": "                draw_text(Rect(active_list.last().x - 20, scanline, 20, 10), String::format(\"%d\", (int)scanline));",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "active_list.size()",
          "old_line_content": "#endif",
          "new_line_content": "            if (active_list.size() > 1) {",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": null,
          "new_api": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGBA32>)",
          "old_text": null,
          "new_text": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGBA32>)",
          "old_line_content": "            break;",
          "new_line_content": "            do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGBA32>);",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": null,
          "new_api": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Indexed8>)",
          "old_text": null,
          "new_text": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Indexed8>)",
          "old_line_content": "            break;",
          "new_line_content": "            do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Indexed8>);",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": null,
          "new_api": "fill_rect_with_gradient",
          "old_text": null,
          "new_text": "fill_rect_with_gradient(Orientation::Horizontal, a_rect, gradient_start, gradient_end)",
          "old_line_content": "void Painter::fill_rect_with_gradient(const Rect& a_rect, Color gradient_start, Color gradient_end)",
          "new_line_content": "    return fill_rect_with_gradient(Orientation::Horizontal, a_rect, gradient_start, gradient_end);",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": null,
          "new_api": "fabs",
          "old_text": null,
          "new_text": "fabs(current.x - previous.x)",
          "old_line_content": "                    auto& current = active_list[i];",
          "new_line_content": "                    int int_distance = fabs(current.x - previous.x);",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Invalid>)",
          "old_text": null,
          "new_text": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Invalid>)",
          "old_line_content": "            break;",
          "new_line_content": "            do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Invalid>);",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "void Painter::draw_ellipse_intersecting(const Rect& rect, Color color, int thickness)",
          "new_line_content": "    constexpr int number_samples = 100; // FIXME: dynamically work out the number of samples based upon the rect size",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": null,
          "new_api": "format",
          "old_text": null,
          "new_text": "source.format()",
          "old_line_content": "        }",
          "new_line_content": "        switch (source.format()) {",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": null,
          "new_api": "center",
          "old_text": null,
          "new_text": "rect.center().x()",
          "old_line_content": "",
          "new_line_content": "        return (cos(theta) * rect.width() / sqrt(2)) + rect.center().x();",
          "content_same": false
        },
        {
          "line": 1264,
          "old_api": null,
          "new_api": "is_inside_shape",
          "old_text": null,
          "new_text": "is_inside_shape(winding_number)",
          "old_line_content": "                    }",
          "new_line_content": "                    if (int_distance == 1 && is_inside_shape(winding_number)) {",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": null,
          "new_api": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGBA32>)",
          "old_text": null,
          "new_text": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGBA32>)",
          "old_line_content": "            break;",
          "new_line_content": "            do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGBA32>);",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": null,
          "new_api": "center",
          "old_text": null,
          "new_text": "rect.center().y()",
          "old_line_content": "",
          "new_line_content": "        return (sin(theta) * rect.height() / sqrt(2)) + rect.center().y();",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": null,
          "new_api": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Indexed8>)",
          "old_text": null,
          "new_text": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Indexed8>)",
          "old_line_content": "            break;",
          "new_line_content": "            do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Indexed8>);",
          "content_same": false
        },
        {
          "line": 1270,
          "old_api": null,
          "new_api": "is_inside_shape",
          "old_text": null,
          "new_text": "is_inside_shape(winding_number)",
          "old_line_content": "                    }",
          "new_line_content": "                    if (is_inside_shape(winding_number)) {",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": null,
          "new_api": "ellipse_y",
          "old_text": null,
          "new_text": "ellipse_y(theta + increment)",
          "old_line_content": "",
          "new_line_content": "        draw_line({ ellipse_x(theta), ellipse_y(theta) }, { ellipse_x(theta + increment), ellipse_y(theta + increment) }, color, thickness);",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Invalid>)",
          "old_text": null,
          "new_text": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Invalid>)",
          "old_line_content": "            break;",
          "new_line_content": "            do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Invalid>);",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": null,
          "new_api": "dbg",
          "old_text": null,
          "new_text": "dbg()",
          "old_line_content": "                        // inside the shape",
          "new_line_content": "                        dbg() << \"y=\" << scanline << \": \" << winding_number << \" at \" << i << \": \" << from << \" -- \" << to;",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": null,
          "new_api": "translation",
          "old_text": null,
          "new_text": "translation()",
          "old_line_content": "void Painter::draw_rect(const Rect& a_rect, Color color, bool rough)",
          "new_line_content": "    Rect rect = a_rect.translated(translation());",
          "content_same": false
        },
        {
          "line": 255,
          "old_api": null,
          "new_api": "clip_rect",
          "old_text": null,
          "new_text": "clip_rect()",
          "old_line_content": "{",
          "new_line_content": "    auto clipped_rect = rect.intersected(clip_rect());",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": null,
          "new_api": "font",
          "old_text": null,
          "new_text": "font()",
          "old_line_content": "FLATTEN void Painter::draw_glyph(const Point& point, char ch, Color color)",
          "new_line_content": "    draw_glyph(point, ch, font(), color);",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "clipped_rect.top()",
          "old_line_content": "        return;",
          "new_line_content": "    int min_y = clipped_rect.top();",
          "content_same": false
        },
        {
          "line": 260,
          "old_api": null,
          "new_api": "bottom",
          "old_text": null,
          "new_text": "clipped_rect.bottom()",
          "old_line_content": "",
          "new_line_content": "    int max_y = clipped_rect.bottom();",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": null,
          "new_api": "glyph_bitmap",
          "old_text": null,
          "new_text": "font.glyph_bitmap(ch)",
          "old_line_content": "FLATTEN void Painter::draw_glyph(const Point& point, char ch, const Font& font, Color color)",
          "new_line_content": "    draw_bitmap(point, font.glyph_bitmap(ch), color);",
          "content_same": false
        },
        {
          "line": 263,
          "old_api": null,
          "new_api": "x",
          "old_text": null,
          "new_text": "clipped_rect.x()",
          "old_line_content": "",
          "new_line_content": "        int start_x = rough ? max(rect.x() + 1, clipped_rect.x()) : clipped_rect.x();",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": null,
          "new_api": "is_fixed_width",
          "old_text": null,
          "new_text": "font.is_fixed_width()",
          "old_line_content": "void Painter::draw_emoji(const Point& point, const Gfx::Bitmap& emoji, const Font& font)",
          "new_line_content": "    if (!font.is_fixed_width())",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": null,
          "new_api": "rect",
          "old_text": null,
          "new_text": "emoji.rect()",
          "old_line_content": "{",
          "new_line_content": "        blit(point, emoji, emoji.rect());",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": null,
          "new_api": "bottom",
          "old_text": null,
          "new_text": "clipped_rect.bottom()",
          "old_line_content": "        ++min_y;",
          "new_line_content": "    if (rect.bottom() >= clipped_rect.top() && rect.bottom() <= clipped_rect.bottom()) {",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": null,
          "new_api": "x",
          "old_text": null,
          "new_text": "clipped_rect.x()",
          "old_line_content": "    }",
          "new_line_content": "        int start_x = rough ? max(rect.x() + 1, clipped_rect.x()) : clipped_rect.x();",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": null,
          "new_api": "x",
          "old_text": null,
          "new_text": "point.x()",
          "old_line_content": "    else {",
          "new_line_content": "            point.x(),",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "point.y()",
          "old_line_content": "        Rect dst_rect {",
          "new_line_content": "            point.y(),",
          "content_same": false
        },
        {
          "line": 1293,
          "old_api": null,
          "new_api": "increment_winding",
          "old_text": null,
          "new_text": "increment_winding(winding_number, from, to)",
          "old_line_content": "",
          "new_line_content": "                        increment_winding(winding_number, from, to);",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": null,
          "new_api": "last",
          "old_text": null,
          "new_text": "active_list.last()",
          "old_line_content": "                    active_list[i - 1].x -= active_list[i - 1].inverse_slope;",
          "new_line_content": "                active_list.last().x -= active_list.last().inverse_slope;",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": null,
          "new_api": "left",
          "old_text": null,
          "new_text": "clipped_rect.left()",
          "old_line_content": "    }",
          "new_line_content": "    bool draw_left_side = rect.left() >= clipped_rect.left();",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": null,
          "new_api": "right",
          "old_text": null,
          "new_text": "clipped_rect.right()",
          "old_line_content": "",
          "new_line_content": "    bool draw_right_side = rect.right() == clipped_rect.right();",
          "content_same": false
        },
        {
          "line": 1301,
          "old_api": null,
          "new_api": "draw_line",
          "old_text": null,
          "new_text": "draw_line(point, point, color)",
          "old_line_content": "            } else {",
          "new_line_content": "                draw_line(point, point, color);",
          "content_same": false
        },
        {
          "line": 1304,
          "old_api": null,
          "new_api": "first",
          "old_text": null,
          "new_text": "active_list.first()",
          "old_line_content": "",
          "new_line_content": "                active_list.first().x -= active_list.first().inverse_slope;",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": null,
          "new_api": "scanline",
          "old_text": null,
          "new_text": "m_target->scanline(y)",
          "old_line_content": "        // Specialized loop when drawing both sides.",
          "new_line_content": "            auto* bits = m_target->scanline(y);",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "color.value()",
          "old_line_content": "        for (int y = min_y; y <= max_y; ++y) {",
          "new_line_content": "            bits[rect.left()] = color.value();",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": null,
          "new_api": "draw_glyph",
          "old_text": null,
          "new_text": "draw_glyph(point, (char)codepoint, font, color)",
          "old_line_content": "    if (codepoint < 256) {",
          "new_line_content": "        draw_glyph(point, (char)codepoint, font, color);",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "active_list.size()",
          "old_line_content": "        --scanline;",
          "new_line_content": "        for (size_t i = 0, count = active_list.size(); i < count; ++i) {",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": null,
          "new_api": "scanline",
          "old_text": null,
          "new_text": "m_target->scanline(y)",
          "old_line_content": "    } else {",
          "new_line_content": "            auto* bits = m_target->scanline(y);",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": null,
          "new_api": "Emoji::emoji_for_codepoint(codepoint)",
          "old_text": null,
          "new_text": "Emoji::emoji_for_codepoint(codepoint)",
          "old_line_content": "",
          "new_line_content": "    auto* emoji = Emoji::emoji_for_codepoint(codepoint);",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": null,
          "new_api": "dbg",
          "old_text": null,
          "new_text": "dbg()",
          "old_line_content": "    if (emoji == nullptr) {",
          "new_line_content": "        dbg() << \"Failed to find an emoji for codepoint \" << codepoint;",
          "content_same": false
        },
        {
          "line": 1317,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "segments.size()",
          "old_line_content": "            }",
          "new_line_content": "        for (size_t j = last_active_segment; j < segments.size(); ++j, ++last_active_segment) {",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": null,
          "new_api": "draw_emoji",
          "old_text": null,
          "new_text": "draw_emoji(point, *emoji, font)",
          "old_line_content": "    }",
          "new_line_content": "    draw_emoji(point, *emoji, font);",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": null,
          "new_api": "translation",
          "old_text": null,
          "new_text": "translation()",
          "old_line_content": "void Painter::draw_bitmap(const Point& p, const CharacterBitmap& bitmap, Color color)",
          "new_line_content": "    auto rect = Rect(p, bitmap.size()).translated(translation());",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": null,
          "new_api": "clip_rect",
          "old_text": null,
          "new_text": "clip_rect()",
          "old_line_content": "{",
          "new_line_content": "    auto clipped_rect = rect.intersected(clip_rect());",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "active_list.append(segment)",
          "old_line_content": "                continue;",
          "new_line_content": "            active_list.append(segment);",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "rect.top()",
          "old_line_content": "        return;",
          "new_line_content": "    const int last_row = clipped_rect.bottom() - rect.top();",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "font.width(final_text)",
          "old_line_content": "    String elided_text;",
          "new_line_content": "        int text_width = font.width(final_text);",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "rect.width()",
          "old_line_content": "    if (elision == TextElision::Right) {",
          "new_line_content": "        if (font.width(final_text) > rect.width()) {",
          "content_same": false
        },
        {
          "line": 1331,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "segments.size()",
          "old_line_content": "    size_t i { 0 };",
          "new_line_content": "        draw_line(Point(segment.from.x(), segment.from.y()), Point(segment.to.x(), segment.to.y()), Color::from_hsv(++i / segments.size() * 255, 255, 255), 1);",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "color.value()",
          "old_line_content": "            char fc = bitmap_row[j];",
          "new_line_content": "                dst[j] = color.value();",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "rect.width()",
          "old_line_content": "                    //       we don't have to worry about spacing.",
          "new_line_content": "                    if (width_with_this_glyph_included > rect.width())",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": null,
          "new_api": "translation",
          "old_text": null,
          "new_text": "translation()",
          "old_line_content": "void Painter::draw_bitmap(const Point& p, const GlyphBitmap& bitmap, Color color)",
          "new_line_content": "    auto dst_rect = Rect(p, bitmap.size()).translated(translation());",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": null,
          "new_api": "clip_rect",
          "old_text": null,
          "new_text": "clip_rect()",
          "old_line_content": "{",
          "new_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": null,
          "new_api": "substring_view",
          "old_text": null,
          "new_text": "final_text.substring_view(0, byte_offset).as_string()",
          "old_line_content": "                }",
          "new_line_content": "                builder.append(final_text.substring_view(0, byte_offset).as_string());",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "builder.append(\"...\")",
          "old_line_content": "                StringBuilder builder;",
          "new_line_content": "                builder.append(\"...\");",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "dst_rect.top()",
          "old_line_content": "        return;",
          "new_line_content": "    const int last_row = clipped_rect.bottom() - dst_rect.top();",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": null,
          "new_api": "bit_at",
          "old_text": null,
          "new_text": "bitmap.bit_at(j + first_column, row)",
          "old_line_content": "    for (int row = first_row; row <= last_row; ++row) {",
          "new_line_content": "            if (bitmap.bit_at(j + first_column, row))",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "color.value()",
          "old_line_content": "        for (int j = 0; j <= (last_column - first_column); ++j) {",
          "new_line_content": "                dst[j] = color.value();",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "font.width(final_text)",
          "old_line_content": "    case TextAlignment::TopRight:",
          "new_line_content": "        rect.set_x(rect.right() - font.width(final_text));",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "font.width(final_text)",
          "old_line_content": "    case TextAlignment::Center: {",
          "new_line_content": "        shrunken_rect.set_width(font.width(final_text));",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": null,
          "new_api": "center_within",
          "old_text": null,
          "new_text": "shrunken_rect.center_within(rect)",
          "old_line_content": "        auto shrunken_rect = rect;",
          "new_line_content": "        shrunken_rect.center_within(rect);",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "color.value()",
          "old_line_content": "void Painter::draw_triangle(const Point& a, const Point& b, const Point& c, Color color)",
          "new_line_content": "    RGBA32 rgba = color.value();",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": null,
          "new_api": "ASSERT_NOT_REACHED",
          "old_text": null,
          "new_text": "ASSERT_NOT_REACHED()",
          "old_line_content": "    }",
          "new_line_content": "        ASSERT_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 352,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "p1.y()",
          "old_line_content": "    Point p2(c);",
          "new_line_content": "    if (p0.y() > p1.y())",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": null,
          "new_api": "swap",
          "old_text": null,
          "new_text": "swap(p0, p1)",
          "old_line_content": "",
          "new_line_content": "        swap(p0, p1);",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": null,
          "new_api": "location",
          "old_text": null,
          "new_text": "rect.location()",
          "old_line_content": "    }",
          "new_line_content": "    auto point = rect.location();",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": null,
          "new_api": "glyph_spacing",
          "old_text": null,
          "new_text": "font.glyph_spacing()",
          "old_line_content": "",
          "new_line_content": "    int space_width = font.glyph_width(' ') + font.glyph_spacing();",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": null,
          "new_api": "move_by",
          "old_text": null,
          "new_text": "point.move_by(space_width, 0)",
          "old_line_content": "    for (u32 codepoint : final_text) {",
          "new_line_content": "            point.move_by(space_width, 0);",
          "content_same": false
        },
        {
          "line": 360,
          "old_api": null,
          "new_api": "bottom",
          "old_text": null,
          "new_text": "clip.bottom()",
          "old_line_content": "",
          "new_line_content": "    if (p0.y() >= clip.bottom())",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": null,
          "new_api": "draw_glyph_or_emoji",
          "old_text": null,
          "new_text": "draw_glyph_or_emoji(point, codepoint, font, color)",
          "old_line_content": "            continue;",
          "new_line_content": "        draw_glyph_or_emoji(point, codepoint, font, color);",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": null,
          "new_api": "glyph_spacing",
          "old_text": null,
          "new_text": "font.glyph_spacing()",
          "old_line_content": "        }",
          "new_line_content": "        point.move_by(font.glyph_or_emoji_width(codepoint) + font.glyph_spacing(), 0);",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "p0.y()",
          "old_line_content": "        return;",
          "new_line_content": "    float dx01 = (float)(p1.x() - p0.x()) / (p1.y() - p0.y());",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "p0.y()",
          "old_line_content": "",
          "new_line_content": "    float dx02 = (float)(p2.x() - p0.x()) / (p2.y() - p0.y());",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": null,
          "new_api": "font",
          "old_text": null,
          "new_text": "font()",
          "old_line_content": "void Painter::draw_text(const Rect& rect, const StringView& text, TextAlignment alignment, Color color, TextElision elision)",
          "new_line_content": "    draw_text(rect, text, font(), alignment, color, elision);",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": null,
          "new_api": "x",
          "old_text": null,
          "new_text": "p0.x()",
          "old_line_content": "",
          "new_line_content": "    float x02 = p0.x();",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "clip.top()",
          "old_line_content": "",
          "new_line_content": "    if (top < clip.top()) {",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "text.end()",
          "old_line_content": "",
          "new_line_content": "    for (auto it = text.begin(); it != text.end(); ++it) {",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": null,
          "new_api": "bottom",
          "old_text": null,
          "new_text": "clip.bottom()",
          "old_line_content": "    }",
          "new_line_content": "    for (int y = top; y < p1.y() && y < clip.bottom(); ++y) {",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": null,
          "new_api": "left",
          "old_text": null,
          "new_text": "clip.left()",
          "old_line_content": "",
          "new_line_content": "        int start = x01 > x02 ? max((int)x02, clip.left()) : max((int)x01, clip.left());",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": null,
          "new_api": "byte_offset_of",
          "old_text": null,
          "new_text": "text.byte_offset_of(it)",
          "old_line_content": "        u32 codepoint = *it;",
          "new_line_content": "            int byte_offset = text.byte_offset_of(it);",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": null,
          "new_api": "substring_view",
          "old_text": null,
          "new_text": "text.substring_view(start_of_current_line, byte_offset - start_of_current_line)",
          "old_line_content": "        if (codepoint == '\\n') {",
          "new_line_content": "            Utf8View line = text.substring_view(start_of_current_line, byte_offset - start_of_current_line);",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": null,
          "new_api": "byte_length",
          "old_text": null,
          "new_text": "text.byte_length()",
          "old_line_content": "    }",
          "new_line_content": "    if (start_of_current_line != text.byte_length()) {",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": null,
          "new_api": "byte_length",
          "old_text": null,
          "new_text": "text.byte_length()",
          "old_line_content": "",
          "new_line_content": "        Utf8View line = text.substring_view(start_of_current_line, text.byte_length() - start_of_current_line);",
          "content_same": false
        },
        {
          "line": 390,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "p0.y()",
          "old_line_content": "    }",
          "new_line_content": "    x02 = p0.x() + dx02 * (p1.y() - p0.y());",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": null,
          "new_api": "x",
          "old_text": null,
          "new_text": "p1.x()",
          "old_line_content": "",
          "new_line_content": "    float x12 = p1.x();",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": null,
          "new_api": "glyph_height",
          "old_text": null,
          "new_text": "font.glyph_height()",
          "old_line_content": "",
          "new_line_content": "    int line_height = font.glyph_height() + line_spacing;",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "lines.size()",
          "old_line_content": "    static const int line_spacing = 4;",
          "new_line_content": "    Rect bounding_rect { 0, 0, 0, (static_cast<int>(lines.size()) * line_height) - line_spacing };",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "clip.top()",
          "old_line_content": "",
          "new_line_content": "    if (top < clip.top()) {",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "font.width(line)",
          "old_line_content": "",
          "new_line_content": "        auto line_width = font.width(line);",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "bounding_rect.width()",
          "old_line_content": "    for (auto& line : lines) {",
          "new_line_content": "        if (line_width > bounding_rect.width())",
          "content_same": false
        },
        {
          "line": 400,
          "old_api": null,
          "new_api": "bottom",
          "old_text": null,
          "new_text": "clip.bottom()",
          "old_line_content": "    }",
          "new_line_content": "    for (int y = top; y < p2.y() && y < clip.bottom(); ++y) {",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": null,
          "new_api": "left",
          "old_text": null,
          "new_text": "clip.left()",
          "old_line_content": "",
          "new_line_content": "        int start = x12 > x02 ? max((int)x02, clip.left()) : max((int)x12, clip.left());",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": null,
          "new_api": "location",
          "old_text": null,
          "new_text": "rect.location()",
          "old_line_content": "    switch (alignment) {",
          "new_line_content": "        bounding_rect.set_location(rect.location());",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "rect.y()",
          "old_line_content": "        break;",
          "new_line_content": "        bounding_rect.set_location({ (rect.right() + 1) - bounding_rect.width(), rect.y() });",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": null,
          "new_api": "height",
          "old_text": null,
          "new_text": "bounding_rect.height()",
          "old_line_content": "        break;",
          "new_line_content": "        bounding_rect.set_location({ rect.x(), rect.center().y() - (bounding_rect.height() / 2) });",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": null,
          "new_api": "height",
          "old_text": null,
          "new_text": "bounding_rect.height()",
          "old_line_content": "        break;",
          "new_line_content": "        bounding_rect.set_location({ (rect.right() + 1) - bounding_rect.width(), rect.center().y() - (bounding_rect.height() / 2) });",
          "content_same": false
        },
        {
          "line": 414,
          "old_api": null,
          "new_api": "translation",
          "old_text": null,
          "new_text": "translation()",
          "old_line_content": "void Painter::blit_scaled(const Rect& dst_rect_raw, const Gfx::Bitmap& source, const Rect& src_rect, float hscale, float vscale)",
          "new_line_content": "    auto dst_rect = Rect(dst_rect_raw.location(), dst_rect_raw.size()).translated(translation());",
          "content_same": false
        },
        {
          "line": 415,
          "old_api": null,
          "new_api": "clip_rect",
          "old_text": null,
          "new_text": "clip_rect()",
          "old_line_content": "{",
          "new_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": null,
          "new_api": "center_within",
          "old_text": null,
          "new_text": "bounding_rect.center_within(rect)",
          "old_line_content": "        break;",
          "new_line_content": "        bounding_rect.center_within(rect);",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": null,
          "new_api": "ASSERT_NOT_REACHED",
          "old_text": null,
          "new_text": "ASSERT_NOT_REACHED()",
          "old_line_content": "        break;",
          "new_line_content": "        ASSERT_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "dst_rect.top()",
          "old_line_content": "        return;",
          "new_line_content": "    const int last_row = (clipped_rect.bottom() - dst_rect.top());",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "lines.size()",
          "old_line_content": "    }",
          "new_line_content": "    for (size_t i = 0; i < lines.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "intersect",
          "old_text": null,
          "new_text": "line_rect.intersect(rect)",
          "old_line_content": "        auto& line = lines[i];",
          "new_line_content": "        line_rect.intersect(rect);",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "source.size().height()",
          "old_line_content": "    for (int row = first_row; row <= last_row; ++row) {",
          "new_line_content": "        if (sr >= source.size().height() || sr < 0) {",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": null,
          "new_api": "scanline",
          "old_text": null,
          "new_text": "source.scanline(sr)",
          "old_line_content": "            continue;",
          "new_line_content": "        const RGBA32* sl = source.scanline(sr);",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "clipped_rect.width()",
          "old_line_content": "        }",
          "new_line_content": "        for (int x = x_start; x < clipped_rect.width() + x_start; ++x) {",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": null,
          "new_api": "state",
          "old_text": null,
          "new_text": "state()",
          "old_line_content": "{",
          "new_line_content": "    point.move_by(state().translation);",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "clip_rect().contains(point)",
          "old_line_content": "    auto point = p;",
          "new_line_content": "    if (!clip_rect().contains(point))",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": null,
          "new_api": "draw_op",
          "old_text": null,
          "new_text": "draw_op()",
          "old_line_content": "ALWAYS_INLINE void Painter::set_pixel_with_draw_op(u32& pixel, const Color& color)",
          "new_line_content": "    if (draw_op() == DrawOp::Copy)",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "color.value()",
          "old_line_content": "{",
          "new_line_content": "        pixel = color.value();",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": null,
          "new_api": "has_alpha_channel",
          "old_text": null,
          "new_text": "m_target->has_alpha_channel()",
          "old_line_content": "void Painter::blit_with_opacity(const Point& position, const Gfx::Bitmap& source, const Rect& src_rect, float opacity)",
          "new_line_content": "    ASSERT(!m_target->has_alpha_channel());",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": null,
          "new_api": "draw_op",
          "old_text": null,
          "new_text": "draw_op()",
          "old_line_content": "void Painter::draw_pixel(const Point& position, Color color, int thickness)",
          "new_line_content": "    ASSERT(draw_op() == DrawOp::Copy);",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": null,
          "new_api": "blit",
          "old_text": null,
          "new_text": "blit(position, source, src_rect)",
          "old_line_content": "        return;",
          "new_line_content": "        return blit(position, source, src_rect);",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "translated",
          "old_text": null,
          "new_text": "position.translated(-(thickness / 2), -(thickness / 2))",
          "old_line_content": "    if (thickness == 1)",
          "new_line_content": "    Rect rect { position.translated(-(thickness / 2), -(thickness / 2)), { thickness, thickness } };",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": null,
          "new_api": "rect",
          "old_text": null,
          "new_text": "source.rect()",
          "old_line_content": "    u8 alpha = 255 * opacity;",
          "new_line_content": "    Rect safe_src_rect = Rect::intersection(src_rect, source.rect());",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "safe_src_rect.size()",
          "old_line_content": "",
          "new_line_content": "    Rect dst_rect(position, safe_src_rect.size());",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": null,
          "new_api": "clip_rect",
          "old_text": null,
          "new_text": "this->clip_rect()",
          "old_line_content": "void Painter::draw_line(const Point& p1, const Point& p2, Color color, int thickness, LineStyle style)",
          "new_line_content": "    auto clip_rect = this->clip_rect();",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "dst_rect.top()",
          "old_line_content": "        return;",
          "new_line_content": "    const int last_row = clipped_rect.bottom() - dst_rect.top();",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": null,
          "new_api": "state",
          "old_text": null,
          "new_text": "state()",
          "old_line_content": "",
          "new_line_content": "    point1.move_by(state().translation);",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": null,
          "new_api": "state",
          "old_text": null,
          "new_text": "state()",
          "old_line_content": "",
          "new_line_content": "    point2.move_by(state().translation);",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": null,
          "new_api": "x",
          "old_text": null,
          "new_text": "point2.x()",
          "old_line_content": "",
          "new_line_content": "    if (point1.x() == point2.x()) {",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": null,
          "new_api": "x",
          "old_text": null,
          "new_text": "point1.x()",
          "old_line_content": "    // Special case: vertical line.",
          "new_line_content": "        const int x = point1.x();",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": null,
          "new_api": "Color::from_rgb(src[x])",
          "old_text": null,
          "new_text": "Color::from_rgb(src[x])",
          "old_line_content": "    for (int row = first_row; row <= last_row; ++row) {",
          "new_line_content": "            Color src_color_with_alpha = Color::from_rgb(src[x]);",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": null,
          "new_api": "set_alpha",
          "old_text": null,
          "new_text": "src_color_with_alpha.set_alpha(alpha)",
          "old_line_content": "        for (int x = 0; x <= (last_column - first_column); ++x) {",
          "new_line_content": "            src_color_with_alpha.set_alpha(alpha);",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": null,
          "new_api": "swap",
          "old_text": null,
          "new_text": "swap(point1, point2)",
          "old_line_content": "            return;",
          "new_line_content": "            swap(point1, point2);",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": null,
          "new_api": "bottom",
          "old_text": null,
          "new_text": "clip_rect.bottom()",
          "old_line_content": "            return;",
          "new_line_content": "        int max_y = min(point2.y(), clip_rect.bottom());",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": null,
          "new_api": "draw_pixel",
          "old_text": null,
          "new_text": "draw_pixel({ x, y }, color, thickness)",
          "old_line_content": "        if (style == LineStyle::Dotted) {",
          "new_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": null,
          "new_api": "rect",
          "old_text": null,
          "new_text": "source.rect()",
          "old_line_content": "void Painter::blit_filtered(const Point& position, const Gfx::Bitmap& source, const Rect& src_rect, Function<Color(Color)> filter)",
          "new_line_content": "    Rect safe_src_rect = src_rect.intersected(source.rect());",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": null,
          "new_api": "translation",
          "old_text": null,
          "new_text": "translation()",
          "old_line_content": "{",
          "new_line_content": "    auto dst_rect = Rect(position, safe_src_rect.size()).translated(translation());",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": null,
          "new_api": "draw_pixel",
          "old_text": null,
          "new_text": "draw_pixel({ x, y }, color, thickness)",
          "old_line_content": "        } else if (style == LineStyle::Dashed) {",
          "new_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": null,
          "new_api": "min",
          "old_text": null,
          "new_text": "min(y + thickness, max_y)",
          "old_line_content": "            for (int y = min_y; y <= max_y; y += thickness * 6) {",
          "new_line_content": "                draw_pixel({ x, min(y + thickness, max_y) }, color, thickness);",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "dst_rect.top()",
          "old_line_content": "        return;",
          "new_line_content": "    const int last_row = clipped_rect.bottom() - dst_rect.top();",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": null,
          "new_api": "draw_pixel",
          "old_text": null,
          "new_text": "draw_pixel({ x, y }, color, thickness)",
          "old_line_content": "        } else {",
          "new_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "point2.y()",
          "old_line_content": "",
          "new_line_content": "    if (point1.y() == point2.y()) {",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "point1.y()",
          "old_line_content": "    // Special case: horizontal line.",
          "new_line_content": "        const int y = point1.y();",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": null,
          "new_api": "alpha",
          "old_text": null,
          "new_text": "Color::from_rgba(src[x]).alpha()",
          "old_line_content": "    for (int row = first_row; row <= last_row; ++row) {",
          "new_line_content": "            u8 alpha = Color::from_rgba(src[x]).alpha();",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": null,
          "new_api": "swap",
          "old_text": null,
          "new_text": "swap(point1, point2)",
          "old_line_content": "            return;",
          "new_line_content": "            swap(point1, point2);",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": null,
          "new_api": "Color::from_rgba(src[x])",
          "old_text": null,
          "new_text": "Color::from_rgba(src[x])",
          "old_line_content": "                continue;",
          "new_line_content": "                dst[x] = Color::from_rgba(dst[x]).blend(filter(Color::from_rgba(src[x]))).value();",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": null,
          "new_api": "right",
          "old_text": null,
          "new_text": "clip_rect.right()",
          "old_line_content": "            return;",
          "new_line_content": "        int max_x = min(point2.x(), clip_rect.right());",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": null,
          "new_api": "draw_pixel",
          "old_text": null,
          "new_text": "draw_pixel({ x, y }, color, thickness)",
          "old_line_content": "        if (style == LineStyle::Dotted) {",
          "new_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 515,
          "old_api": "lightened",
          "new_api": null,
          "old_text": "blit_filtered(position, source, src_rect, [](Color src) {\n        return src.lightened();\n    })",
          "new_text": null,
          "old_line_content": "    return blit_filtered(position, source, src_rect, [](Color src) {",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": "lightened",
          "new_api": null,
          "old_text": "src.lightened()",
          "new_text": null,
          "old_line_content": "        return src.lightened();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": "min",
          "new_api": null,
          "old_text": "min(x + thickness, max_x)",
          "new_text": null,
          "old_line_content": "                draw_pixel({ min(x + thickness, max_x), y }, color, thickness);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": "min",
          "new_api": null,
          "old_text": "min(x + thickness * 2, max_x)",
          "new_text": null,
          "old_line_content": "                draw_pixel({ min(x + thickness * 2, max_x), y }, color, thickness);",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": "draw_pixel",
          "new_api": null,
          "old_text": "draw_pixel({ x, y }, color, thickness)",
          "new_text": null,
          "old_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": "to_grayscale",
          "new_api": null,
          "old_text": "blit_filtered(position, source, src_rect, [](Color src) {\n        return src.to_grayscale().lightened();\n    })",
          "new_text": null,
          "old_line_content": "    return blit_filtered(position, source, src_rect, [](Color src) {",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": "to_grayscale",
          "new_api": null,
          "old_text": "src.to_grayscale().lightened()",
          "new_text": null,
          "old_line_content": "        return src.to_grayscale().lightened();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": "x",
          "new_api": null,
          "old_text": "point1.x()",
          "new_text": null,
          "old_line_content": "    const double adx = abs(point2.x() - point1.x());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "y",
          "new_api": null,
          "old_text": "point1.y()",
          "new_text": null,
          "old_line_content": "    const double ady = abs(point2.y() - point1.y());",
          "new_line_content": "    if (adx > ady) {",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "clip_rect()",
          "new_text": null,
          "old_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": "x",
          "new_api": null,
          "old_text": "point2.x()",
          "new_text": null,
          "old_line_content": "        if (point1.x() > point2.x())",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": "y",
          "new_api": null,
          "old_text": "point2.y()",
          "new_text": null,
          "old_line_content": "        if (point1.y() > point2.y())",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": "x",
          "new_api": null,
          "old_text": "clipped_rect.x()",
          "new_text": null,
          "old_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1048,
          "old_api": "swap",
          "new_api": null,
          "old_text": "swap(point1, point2)",
          "new_text": null,
          "old_line_content": "            swap(point1, point2);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "format",
          "new_api": null,
          "old_text": "source.format()",
          "new_text": null,
          "old_line_content": "    if (source.format() == BitmapFormat::RGB32 || source.format() == BitmapFormat::RGBA32) {",
          "new_line_content": "        for (int row = first_row; row <= last_row; ++row) {",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": "x",
          "new_api": null,
          "old_text": "point1.x()",
          "new_text": null,
          "old_line_content": "    const double dx = point2.x() - point1.x();",
          "new_line_content": "    double error = 0;",
          "content_same": false
        },
        {
          "line": 1053,
          "old_api": "y",
          "new_api": null,
          "old_text": "point1.y()",
          "new_text": null,
          "old_line_content": "    const double dy = point2.y() - point1.y();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": "width",
          "new_api": null,
          "old_text": "clipped_rect.width()",
          "new_text": null,
          "old_line_content": "            for (int x = x_start; x < clipped_rect.width() + x_start; ++x) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "size",
          "new_api": null,
          "old_text": "source.size().width()",
          "new_text": null,
          "old_line_content": "                dst[x - x_start] = sl[x % source.size().width()];",
          "new_line_content": "            dst += dst_skip;",
          "content_same": false
        },
        {
          "line": 1061,
          "old_api": "contains",
          "new_api": null,
          "old_text": "clip_rect.contains(x, y)",
          "new_text": null,
          "old_line_content": "            if (clip_rect.contains(x, y))",
          "new_line_content": "            error += delta_error;",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": "draw_pixel",
          "new_api": null,
          "old_text": "draw_pixel({ x, y }, color, thickness)",
          "new_text": null,
          "old_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "new_line_content": "            if (error >= 0.5) {",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": "ASSERT_NOT_REACHED",
          "new_api": null,
          "old_text": "ASSERT_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "    ASSERT_NOT_REACHED();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "clip_rect()",
          "new_text": null,
          "old_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": "contains",
          "new_api": null,
          "old_text": "clip_rect.contains(x, y)",
          "new_text": null,
          "old_line_content": "            if (clip_rect.contains(x, y))",
          "new_line_content": "            error += delta_error;",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": "draw_pixel",
          "new_api": null,
          "old_text": "draw_pixel({ x, y }, color, thickness)",
          "new_text": null,
          "old_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "new_line_content": "            if (error >= 0.5) {",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "x",
          "new_api": null,
          "old_text": "clipped_rect.x()",
          "new_text": null,
          "old_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": "format",
          "new_api": null,
          "old_text": "source.format()",
          "new_text": null,
          "old_line_content": "    if (source.format() == BitmapFormat::RGB32 || source.format() == BitmapFormat::RGBA32) {",
          "new_line_content": "        for (int row = first_row; row <= last_row; ++row) {",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "top",
          "new_api": null,
          "old_text": "src_rect.top()",
          "new_text": null,
          "old_line_content": "            int sr = row - offset.y() + src_rect.top();",
          "new_line_content": "                dst += dst_skip;",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": "size",
          "new_api": null,
          "old_text": "source.size().height()",
          "new_text": null,
          "old_line_content": "            if (sr >= source.size().height() || sr < 0) {",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": "x",
          "new_api": null,
          "old_text": "offset.x()",
          "new_text": null,
          "old_line_content": "                int sx = x - offset.x();",
          "new_line_content": "                    dst[x - x_start] = sl[sx];",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": "size",
          "new_api": null,
          "old_text": "source.size().width()",
          "new_text": null,
          "old_line_content": "                if (sx < source.size().width() && sx >= 0)",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": "Painter::for_each_line_segment_on_bezier_curve(po1_midpoint, p1, new_segment, callback)",
          "new_api": null,
          "old_text": "Painter::for_each_line_segment_on_bezier_curve(po1_midpoint, p1, new_segment, callback)",
          "new_text": null,
          "old_line_content": "    Painter::for_each_line_segment_on_bezier_curve(po1_midpoint, p1, new_segment, callback);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": "Painter::for_each_line_segment_on_bezier_curve(po2_midpoint, new_segment, p2, callback)",
          "new_api": null,
          "old_text": "Painter::for_each_line_segment_on_bezier_curve(po2_midpoint, new_segment, p2, callback)",
          "new_text": null,
          "old_line_content": "    Painter::for_each_line_segment_on_bezier_curve(po2_midpoint, new_segment, p2, callback);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": "ASSERT_NOT_REACHED",
          "new_api": null,
          "old_text": "ASSERT_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "    ASSERT_NOT_REACHED();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": "x",
          "new_api": null,
          "old_text": "p1.x()",
          "new_text": null,
          "old_line_content": "    auto p2x = 3 * control.x() - 2 * p2.x() - p1.x();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": "y",
          "new_api": null,
          "old_text": "p1.y()",
          "new_text": null,
          "old_line_content": "    auto p2y = 3 * control.y() - 2 * p2.y() - p1.y();",
          "new_line_content": "    p1x = p1x * p1x;",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "clip_rect()",
          "new_text": null,
          "old_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": "max",
          "new_api": null,
          "old_text": "max(p1y, p2y)",
          "new_text": null,
          "old_line_content": "    return max(p1x, p2x) + max(p1y, p2y) <= tolerance;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": "pitch",
          "new_api": null,
          "old_text": "m_target->pitch()",
          "new_text": null,
          "old_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": "pitch",
          "new_api": null,
          "old_text": "source.pitch()",
          "new_text": null,
          "old_line_content": "    const size_t src_skip = source.pitch() / sizeof(RGBA32);",
          "new_line_content": "    for (int row = first_row; row <= last_row; ++row) {",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": "can_approximate_bezier_curve",
          "new_api": null,
          "old_text": "can_approximate_bezier_curve(p1, p2, control_point)",
          "new_text": null,
          "old_line_content": "    if (can_approximate_bezier_curve(p1, p2, control_point)) {",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": "split_quadratic_bezier_curve",
          "new_api": null,
          "old_text": "split_quadratic_bezier_curve(control_point, p1, p2, callback)",
          "new_text": null,
          "old_line_content": "        split_quadratic_bezier_curve(control_point, p1, p2, callback);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "alpha",
          "new_api": null,
          "old_text": "Color::from_rgba(src[x]).alpha()",
          "new_text": null,
          "old_line_content": "            u8 alpha = Color::from_rgba(src[x]).alpha();",
          "new_line_content": "                dst[x] = src[x];",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": "for_each_line_segment_on_bezier_curve",
          "new_api": null,
          "old_text": "for_each_line_segment_on_bezier_curve(control_point, p1, p2, callback)",
          "new_text": null,
          "old_line_content": "    for_each_line_segment_on_bezier_curve(control_point, p1, p2, callback);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 617,
          "old_api": "Color::from_rgba(src[x])",
          "new_api": null,
          "old_text": "Color::from_rgba(src[x])",
          "new_text": null,
          "old_line_content": "                dst[x] = Color::from_rgba(dst[x]).blend(Color::from_rgba(src[x])).value();",
          "new_line_content": "        dst += dst_skip;",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": "y",
          "new_api": null,
          "old_text": "p2.y()",
          "new_text": null,
          "old_line_content": "    for_each_line_segment_on_bezier_curve(FloatPoint(control_point.x(), control_point.y()), FloatPoint(p1.x(), p1.y()), FloatPoint(p2.x(), p2.y()), [&](const FloatPoint& p1, const FloatPoint& p2) {",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": "y",
          "new_api": null,
          "old_text": "p2.y()",
          "new_text": null,
          "old_line_content": "        draw_line(Point(p1.x(), p1.y()), Point(p2.x(), p2.y()), color, thickness, style);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": "location",
          "new_api": null,
          "old_text": "m_clip_origin.location()",
          "new_text": null,
          "old_line_content": "    state().clip_rect.intersect(rect.translated(m_clip_origin.location()));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "rect",
          "new_api": null,
          "old_text": "m_target->rect()",
          "new_text": null,
          "old_line_content": "    state().clip_rect.intersect(m_target->rect());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "clip_rect()",
          "new_text": null,
          "old_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": "state",
          "new_api": null,
          "old_text": "state()",
          "new_text": null,
          "old_line_content": "    state().clip_rect = m_clip_origin;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": "x",
          "new_api": null,
          "old_text": "clipped_rect.x()",
          "new_text": null,
          "old_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1152,
          "old_api": "save",
          "new_api": null,
          "old_text": "m_painter.save()",
          "new_text": null,
          "old_line_content": "    m_painter.save();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "left",
          "new_api": null,
          "old_text": "src_rect.left()",
          "new_text": null,
          "old_line_content": "        const RGBA32* src = source.scanline(src_rect.top() + first_row) + src_rect.left() + first_column;",
          "new_line_content": "        for (int row = first_row; row <= last_row; ++row) {",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": "restore",
          "new_api": null,
          "old_text": "m_painter.restore()",
          "new_text": null,
          "old_line_content": "    m_painter.restore();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": "width",
          "new_api": null,
          "old_text": "clipped_rect.width()",
          "new_text": null,
          "old_line_content": "            fast_u32_copy(dst, src, clipped_rect.width());",
          "new_line_content": "            src += src_skip;",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "segments",
          "new_api": null,
          "old_text": "path.segments()",
          "new_text": null,
          "old_line_content": "    for (auto& segment : path.segments()) {",
          "new_line_content": "        case Path::Segment::Type::Invalid:",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": "left",
          "new_api": null,
          "old_text": "src_rect.left()",
          "new_text": null,
          "old_line_content": "        const u8* src = source.bits(src_rect.top() + first_row) + src_rect.left() + first_column;",
          "new_line_content": "        for (int row = first_row; row <= last_row; ++row) {",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": "ASSERT_NOT_REACHED",
          "new_api": null,
          "old_text": "ASSERT_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "            ASSERT_NOT_REACHED();",
          "new_line_content": "        case Path::Segment::Type::MoveTo:",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": "width",
          "new_api": null,
          "old_text": "clipped_rect.width()",
          "new_text": null,
          "old_line_content": "            for (int i = 0; i < clipped_rect.width(); ++i)",
          "new_line_content": "            dst += dst_skip;",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "palette_color",
          "new_api": null,
          "old_text": "source.palette_color(src[i]).value()",
          "new_text": null,
          "old_line_content": "                dst[i] = source.palette_color(src[i]).value();",
          "new_line_content": "            src += src_skip;",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": "y",
          "new_api": null,
          "old_text": "segment.point.y()",
          "new_text": null,
          "old_line_content": "            draw_line(Point(cursor.x(), cursor.y()), Point(segment.point.x(), segment.point.y()), color, thickness);",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 153,
          "old_api": "value",
          "new_api": null,
          "old_text": "color_a.value()",
          "new_text": null,
          "old_line_content": "                dst[j] = (j & 1) ? color_b.value() : color_a.value();",
          "new_line_content": "        dst += dst_skip;",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": "ASSERT_NOT_REACHED",
          "new_api": null,
          "old_text": "ASSERT_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "    ASSERT_NOT_REACHED();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1177,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "segment.through.has_value()",
          "new_text": null,
          "old_line_content": "            ASSERT(segment.through.has_value());",
          "new_line_content": "            cursor = segment.point;",
          "content_same": false
        },
        {
          "line": 1178,
          "old_api": "y",
          "new_api": null,
          "old_text": "segment.point.y()",
          "new_text": null,
          "old_line_content": "            draw_quadratic_bezier_curve(Point(segment.through.value().x(), segment.through.value().y()), Point(cursor.x(), cursor.y()), Point(segment.point.x(), segment.point.y()), color, thickness);",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "clip_rect()",
          "new_text": null,
          "old_line_content": "    auto rect = a_rect.translated(translation()).intersected(clip_rect());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 162,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "rect.is_empty()",
          "new_text": null,
          "old_line_content": "    if (rect.is_empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": "rect",
          "new_api": null,
          "old_text": "source.rect().right()",
          "new_text": null,
          "old_line_content": "        for (int x = source.rect().left(); x <= source.rect().right(); ++x) {",
          "new_line_content": "            for (int yo = 0; yo < vfactor; ++yo) {",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": "scanline",
          "new_api": null,
          "old_text": "target.scanline(dst_y + yo)",
          "new_text": null,
          "old_line_content": "                auto* scanline = (Color*)target.scanline(dst_y + yo);",
          "new_line_content": "                for (int xo = 0; xo < hfactor; ++xo) {",
          "content_same": false
        },
        {
          "line": 165,
          "old_api": "left",
          "new_api": null,
          "old_text": "rect.left()",
          "new_text": null,
          "old_line_content": "    RGBA32* dst = m_target->scanline(rect.top()) + rect.left();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": "x",
          "new_api": null,
          "old_text": "dst_rect.x()",
          "new_text": null,
          "old_line_content": "                int dst_x = dst_rect.x() + x * hfactor;",
          "new_line_content": "                    if constexpr (has_alpha_channel)",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "size",
          "new_api": null,
          "old_text": "segments.size()",
          "new_text": null,
          "old_line_content": "    if (segments.size() == 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": "blend",
          "new_api": null,
          "old_text": "scanline[dst_x + xo].blend(src_pixel)",
          "new_text": null,
          "old_line_content": "                        scanline[dst_x + xo] = scanline[dst_x + xo].blend(src_pixel);",
          "new_line_content": "                        scanline[dst_x + xo] = src_pixel;",
          "content_same": false
        },
        {
          "line": 171,
          "old_api": "width",
          "new_api": null,
          "old_text": "cell_size.width()",
          "new_text": null,
          "old_line_content": "            int cell_col = j / cell_size.width();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 172,
          "old_api": "value",
          "new_api": null,
          "old_text": "color_dark.value()",
          "new_text": null,
          "old_line_content": "            dst[j] = ((cell_row % 2) ^ (cell_col % 2)) ? color_light.value() : color_dark.value();",
          "new_line_content": "        dst += dst_skip;",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": "size",
          "new_api": null,
          "old_text": "segments.size()",
          "new_text": null,
          "old_line_content": "    active_list.ensure_capacity(segments.size());",
          "new_line_content": "    // first, grab the segments for the very first scanline",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": "first",
          "new_api": null,
          "old_text": "segments.first()",
          "new_text": null,
          "old_line_content": "    auto first_y = segments.first().maximum_y;",
          "new_line_content": "    auto scanline = first_y;",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": "last",
          "new_api": null,
          "old_text": "segments.last()",
          "new_text": null,
          "old_line_content": "    auto last_y = segments.last().minimum_y;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": "width",
          "new_api": null,
          "old_text": "src_rect.width()",
          "new_text": null,
          "old_line_content": "        int hfactor = dst_rect.width() / src_rect.width();",
          "new_line_content": "        if (hfactor == 2 && vfactor == 2)",
          "content_same": false
        },
        {
          "line": 1207,
          "old_api": "append",
          "new_api": null,
          "old_text": "active_list.append(segment)",
          "new_text": null,
          "old_line_content": "        active_list.append(segment);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "clip_rect()",
          "new_text": null,
          "old_line_content": "    auto clipped_rect = Rect::intersection(rect, clip_rect());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "clipped_rect.is_empty()",
          "new_text": null,
          "old_line_content": "    if (clipped_rect.is_empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 4, 4, get_pixel)",
          "new_api": null,
          "old_text": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 4, 4, get_pixel)",
          "new_text": null,
          "old_line_content": "            return do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, 4, 4, get_pixel);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, hfactor, vfactor, get_pixel)",
          "new_api": null,
          "old_text": "do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, hfactor, vfactor, get_pixel)",
          "new_text": null,
          "old_line_content": "        return do_draw_integer_scaled_bitmap<has_alpha_channel>(target, dst_rect, source, hfactor, vfactor, get_pixel);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": "left",
          "new_api": null,
          "old_text": "clipped_rect.left()",
          "new_text": null,
          "old_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.top()) + clipped_rect.left();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": "ASSERT_NOT_REACHED",
          "new_api": null,
          "old_text": "ASSERT_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "        ASSERT_NOT_REACHED();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": "y",
          "new_api": null,
          "old_text": "dst_rect.y()",
          "new_text": null,
          "old_line_content": "            auto scaled_y = ((y - dst_rect.y()) * vscale) >> 16;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": "get_pixel",
          "new_api": null,
          "old_text": "get_pixel(source, scaled_x, scaled_y)",
          "new_text": null,
          "old_line_content": "            auto src_pixel = get_pixel(source, scaled_x, scaled_y);",
          "new_line_content": "            if constexpr (has_alpha_channel) {",
          "content_same": false
        },
        {
          "line": 199,
          "old_api": "green",
          "new_api": null,
          "old_text": "gradient_end.green()",
          "new_text": null,
          "old_line_content": "    int g1 = gradient_end.green();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": "blue",
          "new_api": null,
          "old_text": "gradient_end.blue()",
          "new_text": null,
          "old_line_content": "    int b1 = gradient_end.blue();",
          "new_line_content": "    if (orientation == Orientation::Horizontal) {",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": "blend",
          "new_api": null,
          "old_text": "scanline[x].blend(src_pixel)",
          "new_text": null,
          "old_line_content": "                scanline[x] = scanline[x].blend(src_pixel);",
          "new_line_content": "                scanline[x] = src_pixel;",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": "dy_relative_to",
          "new_api": null,
          "old_text": "from.dy_relative_to(to)",
          "new_text": null,
          "old_line_content": "            if (from.dy_relative_to(to) < 0)",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 205,
          "old_api": "width",
          "new_api": null,
          "old_text": "clipped_rect.width()",
          "new_text": null,
          "old_line_content": "            for (int j = 0; j < clipped_rect.width(); ++j) {",
          "new_line_content": "                    r1 / 255.0 * c + r2 / 255.0 * (255 - c),",
          "content_same": false
        },
        {
          "line": 206,
          "old_api": "value",
          "new_api": null,
          "old_text": "Color(\n                    r1 / 255.0 * c + r2 / 255.0 * (255 - c),\n                    g1 / 255.0 * c + g2 / 255.0 * (255 - c),\n                    b1 / 255.0 * c + b2 / 255.0 * (255 - c))\n                             .value()",
          "new_text": null,
          "old_line_content": "                dst[j] = Color(",
          "new_line_content": "                    g1 / 255.0 * c + g2 / 255.0 * (255 - c),",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": "size",
          "new_api": null,
          "old_text": "src_rect.size()",
          "new_text": null,
          "old_line_content": "    if (dst_rect.size() == src_rect.size())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": "ASSERT_NOT_REACHED",
          "new_api": null,
          "old_text": "ASSERT_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "        ASSERT_NOT_REACHED();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 728,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "clip_rect()",
          "new_text": null,
          "old_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": "height",
          "new_api": null,
          "old_text": "clipped_rect.height()",
          "new_text": null,
          "old_line_content": "        for (int i = clipped_rect.height() - 1; i >= 0; --i) {",
          "new_line_content": "                r1 / 255.0 * c + r2 / 255.0 * (255 - c),",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "clipped_rect.is_empty()",
          "new_text": null,
          "old_line_content": "    if (clipped_rect.is_empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": "quick_sort",
          "new_api": null,
          "old_text": "quick_sort(active_list, [](const auto& line0, const auto& line1) {\n                return line1.x < line0.x;\n            })",
          "new_text": null,
          "old_line_content": "            quick_sort(active_list, [](const auto& line0, const auto& line1) {",
          "new_line_content": "            });",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": "width",
          "new_api": null,
          "old_text": "dst_rect.width()",
          "new_text": null,
          "old_line_content": "    int hscale = (src_rect.width() << 16) / dst_rect.width();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 222,
          "old_api": "width",
          "new_api": null,
          "old_text": "clipped_rect.width()",
          "new_text": null,
          "old_line_content": "            for (int j = 0; j < clipped_rect.width(); ++j) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": "value",
          "new_api": null,
          "old_text": "color.value()",
          "new_text": null,
          "old_line_content": "                dst[j] = color.value();",
          "new_line_content": "            c += increment;",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": "has_alpha_channel",
          "new_api": null,
          "old_text": "source.has_alpha_channel()",
          "new_text": null,
          "old_line_content": "    if (source.has_alpha_channel()) {",
          "new_line_content": "        case BitmapFormat::RGB32:",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": "String::format(\"%d\", (int)scanline)",
          "new_api": null,
          "old_text": "String::format(\"%d\", (int)scanline)",
          "new_text": null,
          "old_line_content": "                draw_text(Rect(active_list.last().x - 20, scanline, 20, 10), String::format(\"%d\", (int)scanline));",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGB32>)",
          "new_api": null,
          "old_text": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGB32>)",
          "new_text": null,
          "old_line_content": "            do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGB32>);",
          "new_line_content": "        case BitmapFormat::RGBA32:",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": "size",
          "new_api": null,
          "old_text": "active_list.size()",
          "new_text": null,
          "old_line_content": "                for (size_t i = 1; i < active_list.size(); ++i) {",
          "new_line_content": "                    auto& current = active_list[i];",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGBA32>)",
          "new_api": null,
          "old_text": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGBA32>)",
          "new_text": null,
          "old_line_content": "            do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGBA32>);",
          "new_line_content": "        case BitmapFormat::Indexed8:",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Indexed8>)",
          "new_api": null,
          "old_text": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Indexed8>)",
          "new_text": null,
          "old_line_content": "            do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Indexed8>);",
          "new_line_content": "        default:",
          "content_same": false
        },
        {
          "line": 233,
          "old_api": "fill_rect_with_gradient",
          "new_api": null,
          "old_text": "fill_rect_with_gradient(Orientation::Horizontal, a_rect, gradient_start, gradient_end)",
          "new_text": null,
          "old_line_content": "    return fill_rect_with_gradient(Orientation::Horizontal, a_rect, gradient_start, gradient_end);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": "fabs",
          "new_api": null,
          "old_text": "fabs(current.x - previous.x)",
          "new_text": null,
          "old_line_content": "                    int int_distance = fabs(current.x - previous.x);",
          "new_line_content": "                    Point to(current.x, scanline);",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Invalid>)",
          "new_api": null,
          "old_text": "do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Invalid>)",
          "new_text": null,
          "old_line_content": "            do_draw_scaled_bitmap<true>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Invalid>);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "    constexpr int number_samples = 100; // FIXME: dynamically work out the number of samples based upon the rect size",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGB32>)",
          "new_api": null,
          "old_text": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGB32>)",
          "new_text": null,
          "old_line_content": "            do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGB32>);",
          "new_line_content": "        case BitmapFormat::RGBA32:",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": "center",
          "new_api": null,
          "old_text": "rect.center().x()",
          "new_text": null,
          "old_line_content": "        return (cos(theta) * rect.width() / sqrt(2)) + rect.center().x();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1266,
          "old_api": "is_inside_shape",
          "new_api": null,
          "old_text": "is_inside_shape(winding_number)",
          "new_text": null,
          "old_line_content": "                    if (int_distance == 1 && is_inside_shape(winding_number)) {",
          "new_line_content": "                        // while they do not intersect, they connect together",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGBA32>)",
          "new_api": null,
          "old_text": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGBA32>)",
          "new_text": null,
          "old_line_content": "            do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::RGBA32>);",
          "new_line_content": "        case BitmapFormat::Indexed8:",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": "center",
          "new_api": null,
          "old_text": "rect.center().y()",
          "new_text": null,
          "old_line_content": "        return (sin(theta) * rect.height() / sqrt(2)) + rect.center().y();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Indexed8>)",
          "new_api": null,
          "old_text": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Indexed8>)",
          "new_text": null,
          "old_line_content": "            do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Indexed8>);",
          "new_line_content": "        default:",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": "is_inside_shape",
          "new_api": null,
          "old_text": "is_inside_shape(winding_number)",
          "new_text": null,
          "old_line_content": "                    if (is_inside_shape(winding_number)) {",
          "new_line_content": "                        // inside the shape",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": "ellipse_y",
          "new_api": null,
          "old_text": "ellipse_y(theta + increment)",
          "new_text": null,
          "old_line_content": "        draw_line({ ellipse_x(theta), ellipse_y(theta) }, { ellipse_x(theta + increment), ellipse_y(theta + increment) }, color, thickness);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Invalid>)",
          "new_api": null,
          "old_text": "do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Invalid>)",
          "new_text": null,
          "old_line_content": "            do_draw_scaled_bitmap<false>(*m_target, dst_rect, clipped_rect, source, src_rect, hscale, vscale, get_pixel<BitmapFormat::Invalid>);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": "draw_line",
          "new_api": null,
          "old_text": "draw_line(from, to, color, 1)",
          "new_text": null,
          "old_line_content": "                        draw_line(from, to, color, 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 257,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "clip_rect()",
          "new_text": null,
          "old_line_content": "    auto clipped_rect = rect.intersected(clip_rect());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "clipped_rect.is_empty()",
          "new_text": null,
          "old_line_content": "    if (clipped_rect.is_empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "font",
          "new_api": null,
          "old_text": "font()",
          "new_text": null,
          "old_line_content": "    draw_glyph(point, ch, font(), color);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": "top",
          "new_api": null,
          "old_text": "clipped_rect.top()",
          "new_text": null,
          "old_line_content": "    int min_y = clipped_rect.top();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "glyph_bitmap",
          "new_api": null,
          "old_text": "font.glyph_bitmap(ch)",
          "new_text": null,
          "old_line_content": "    draw_bitmap(point, font.glyph_bitmap(ch), color);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": "width",
          "new_api": null,
          "old_text": "clipped_rect.width()",
          "new_text": null,
          "old_line_content": "        int width = rough ? min(rect.width() - 2, clipped_rect.width()) : clipped_rect.width();",
          "new_line_content": "        ++min_y;",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "value",
          "new_api": null,
          "old_text": "color.value()",
          "new_text": null,
          "old_line_content": "        fast_u32_fill(m_target->scanline(rect.top()) + start_x, color.value(), width);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": "is_fixed_width",
          "new_api": null,
          "old_text": "font.is_fixed_width()",
          "new_text": null,
          "old_line_content": "    if (!font.is_fixed_width())",
          "new_line_content": "    else {",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "rect",
          "new_api": null,
          "old_text": "emoji.rect()",
          "new_text": null,
          "old_line_content": "        blit(point, emoji, emoji.rect());",
          "new_line_content": "        Rect dst_rect {",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": "increment_winding",
          "new_api": null,
          "old_text": "increment_winding(winding_number, from, to)",
          "new_text": null,
          "old_line_content": "                        increment_winding(winding_number, from, to);",
          "new_line_content": "                    // update the x coord",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "width",
          "new_api": null,
          "old_text": "clipped_rect.width()",
          "new_text": null,
          "old_line_content": "        int width = rough ? min(rect.width() - 2, clipped_rect.width()) : clipped_rect.width();",
          "new_line_content": "        --max_y;",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": "value",
          "new_api": null,
          "old_text": "color.value()",
          "new_text": null,
          "old_line_content": "        fast_u32_fill(m_target->scanline(rect.bottom()) + start_x, color.value(), width);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": "glyph_width",
          "new_api": null,
          "old_text": "font.glyph_width('x')",
          "new_text": null,
          "old_line_content": "            font.glyph_width('x'),",
          "new_line_content": "        };",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": "left",
          "new_api": null,
          "old_text": "clipped_rect.left()",
          "new_text": null,
          "old_line_content": "    bool draw_left_side = rect.left() >= clipped_rect.left();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": "right",
          "new_api": null,
          "old_text": "clipped_rect.right()",
          "new_text": null,
          "old_line_content": "    bool draw_right_side = rect.right() == clipped_rect.right();",
          "new_line_content": "    if (draw_left_side && draw_right_side) {",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": "rect",
          "new_api": null,
          "old_text": "emoji.rect()",
          "new_text": null,
          "old_line_content": "        draw_scaled_bitmap(dst_rect, emoji, emoji.rect());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": "Point",
          "new_api": null,
          "old_text": "Point(active_list[0].x, scanline)",
          "new_text": null,
          "old_line_content": "                auto point = Point(active_list[0].x, scanline);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": "draw_line",
          "new_api": null,
          "old_text": "draw_line(point, point, color)",
          "new_text": null,
          "old_line_content": "                draw_line(point, point, color);",
          "new_line_content": "                // update the x coord",
          "content_same": false
        },
        {
          "line": 1306,
          "old_api": "first",
          "new_api": null,
          "old_text": "active_list.first()",
          "new_text": null,
          "old_line_content": "                active_list.first().x -= active_list.first().inverse_slope;",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "value",
          "new_api": null,
          "old_text": "color.value()",
          "new_text": null,
          "old_line_content": "            bits[rect.left()] = color.value();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": "value",
          "new_api": null,
          "old_text": "color.value()",
          "new_text": null,
          "old_line_content": "            bits[rect.right()] = color.value();",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "draw_glyph",
          "new_api": null,
          "old_text": "draw_glyph(point, (char)codepoint, font, color)",
          "new_text": null,
          "old_line_content": "        draw_glyph(point, (char)codepoint, font, color);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": "Emoji::emoji_for_codepoint(codepoint)",
          "new_api": null,
          "old_text": "Emoji::emoji_for_codepoint(codepoint)",
          "new_text": null,
          "old_line_content": "    auto* emoji = Emoji::emoji_for_codepoint(codepoint);",
          "new_line_content": "#ifdef EMOJI_DEBUG",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": "remove",
          "new_api": null,
          "old_text": "active_list.remove(i)",
          "new_text": null,
          "old_line_content": "                active_list.remove(i);",
          "new_line_content": "                --i;",
          "content_same": false
        },
        {
          "line": 293,
          "old_api": "value",
          "new_api": null,
          "old_text": "color.value()",
          "new_text": null,
          "old_line_content": "                bits[rect.right()] = color.value();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "draw_glyph",
          "new_api": null,
          "old_text": "draw_glyph(point, '?', font, color)",
          "new_text": null,
          "old_line_content": "        draw_glyph(point, '?', font, color);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": "size",
          "new_api": null,
          "old_text": "segments.size()",
          "new_text": null,
          "old_line_content": "        for (size_t j = last_active_segment; j < segments.size(); ++j, ++last_active_segment) {",
          "new_line_content": "            if (segment.maximum_y < scanline)",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "draw_emoji",
          "new_api": null,
          "old_text": "draw_emoji(point, *emoji, font)",
          "new_text": null,
          "old_line_content": "    draw_emoji(point, *emoji, font);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "clip_rect()",
          "new_text": null,
          "old_line_content": "    auto clipped_rect = rect.intersected(clip_rect());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": "append",
          "new_api": null,
          "old_text": "active_list.append(segment)",
          "new_text": null,
          "old_line_content": "            active_list.append(segment);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": "width",
          "new_api": null,
          "old_text": "rect.width()",
          "new_text": null,
          "old_line_content": "        if (font.width(final_text) > rect.width()) {",
          "new_line_content": "            int byte_offset = 0;",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "width",
          "new_api": null,
          "old_text": "bitmap.width()",
          "new_text": null,
          "old_line_content": "    const char* bitmap_row = &bitmap.bits()[first_row * bitmap.width() + first_column];",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": "width",
          "new_api": null,
          "old_text": "bitmap.width()",
          "new_text": null,
          "old_line_content": "    const size_t bitmap_skip = bitmap.width();",
          "new_line_content": "    for (int row = first_row; row <= last_row; ++row) {",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": "size",
          "new_api": null,
          "old_text": "segments.size()",
          "new_text": null,
          "old_line_content": "        draw_line(Point(segment.from.x(), segment.from.y()), Point(segment.to.x(), segment.to.y()), Color::from_hsv(++i / segments.size() * 255, 255, 255), 1);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": "glyph_or_emoji_width",
          "new_api": null,
          "old_text": "font.glyph_or_emoji_width(codepoint)",
          "new_text": null,
          "old_line_content": "                    int glyph_width = font.glyph_or_emoji_width(codepoint);",
          "new_line_content": "                    //       but since we are here because the last glyph does not actually fit on the line,",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": "value",
          "new_api": null,
          "old_text": "color.value()",
          "new_text": null,
          "old_line_content": "                dst[j] = color.value();",
          "new_line_content": "        bitmap_row += bitmap_skip;",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": "byte_offset_of",
          "new_api": null,
          "old_text": "final_text.byte_offset_of(it)",
          "new_text": null,
          "old_line_content": "                    byte_offset = final_text.byte_offset_of(it);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "clip_rect()",
          "new_text": null,
          "old_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "append",
          "new_api": null,
          "old_text": "builder.append(\"...\")",
          "new_text": null,
          "old_line_content": "                builder.append(\"...\");",
          "new_line_content": "                final_text = Utf8View { elided_text };",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": "to_string",
          "new_api": null,
          "old_text": "builder.to_string()",
          "new_text": null,
          "old_line_content": "                elided_text = builder.to_string();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 334,
          "old_api": "x",
          "new_api": null,
          "old_text": "clipped_rect.x()",
          "new_text": null,
          "old_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": "pitch",
          "new_api": null,
          "old_text": "m_target->pitch()",
          "new_text": null,
          "old_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "new_line_content": "    for (int row = first_row; row <= last_row; ++row) {",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": "bit_at",
          "new_api": null,
          "old_text": "bitmap.bit_at(j + first_column, row)",
          "new_text": null,
          "old_line_content": "            if (bitmap.bit_at(j + first_column, row))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": "value",
          "new_api": null,
          "old_text": "color.value()",
          "new_text": null,
          "old_line_content": "                dst[j] = color.value();",
          "new_line_content": "        dst += dst_skip;",
          "content_same": false
        },
        {
          "line": 853,
          "old_api": "width",
          "new_api": null,
          "old_text": "font.width(final_text)",
          "new_text": null,
          "old_line_content": "        rect.set_x(rect.right() - font.width(final_text));",
          "new_line_content": "    case TextAlignment::Center: {",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": "width",
          "new_api": null,
          "old_text": "font.width(final_text)",
          "new_text": null,
          "old_line_content": "        shrunken_rect.set_width(font.width(final_text));",
          "new_line_content": "        rect = shrunken_rect;",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "center_within",
          "new_api": null,
          "old_text": "shrunken_rect.center_within(rect)",
          "new_text": null,
          "old_line_content": "        shrunken_rect.center_within(rect);",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": "value",
          "new_api": null,
          "old_text": "color.value()",
          "new_text": null,
          "old_line_content": "    RGBA32 rgba = color.value();",
          "new_line_content": "    Point p0(a);",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": "ASSERT_NOT_REACHED",
          "new_api": null,
          "old_text": "ASSERT_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "        ASSERT_NOT_REACHED();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": "location",
          "new_api": null,
          "old_text": "rect.location()",
          "new_text": null,
          "old_line_content": "    auto point = rect.location();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "glyph_spacing",
          "new_api": null,
          "old_text": "font.glyph_spacing()",
          "new_text": null,
          "old_line_content": "    int space_width = font.glyph_width(' ') + font.glyph_spacing();",
          "new_line_content": "    for (u32 codepoint : final_text) {",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": "y",
          "new_api": null,
          "old_text": "p2.y()",
          "new_text": null,
          "old_line_content": "    if (p1.y() > p2.y())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": "move_by",
          "new_api": null,
          "old_text": "point.move_by(space_width, 0)",
          "new_text": null,
          "old_line_content": "            point.move_by(space_width, 0);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "clip_rect()",
          "new_text": null,
          "old_line_content": "    auto clip = clip_rect();",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "draw_glyph_or_emoji",
          "new_api": null,
          "old_text": "draw_glyph_or_emoji(point, codepoint, font, color)",
          "new_text": null,
          "old_line_content": "        draw_glyph_or_emoji(point, codepoint, font, color);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": "glyph_spacing",
          "new_api": null,
          "old_text": "font.glyph_spacing()",
          "new_text": null,
          "old_line_content": "        point.move_by(font.glyph_or_emoji_width(codepoint) + font.glyph_spacing(), 0);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": "top",
          "new_api": null,
          "old_text": "clip.top()",
          "new_text": null,
          "old_line_content": "    if (p2.y() < clip.top())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 368,
          "old_api": "y",
          "new_api": null,
          "old_text": "p0.y()",
          "new_text": null,
          "old_line_content": "    float dx02 = (float)(p2.x() - p0.x()) / (p2.y() - p0.y());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": "font",
          "new_api": null,
          "old_text": "font()",
          "new_text": null,
          "old_line_content": "    draw_text(rect, text, font(), alignment, color, elision);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": "x",
          "new_api": null,
          "old_text": "p0.x()",
          "new_text": null,
          "old_line_content": "    float x01 = p0.x();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": "top",
          "new_api": null,
          "old_text": "clip.top()",
          "new_text": null,
          "old_line_content": "        x02 += dx02 * (clip.top() - top);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": "top",
          "new_api": null,
          "old_text": "clip.top()",
          "new_text": null,
          "old_line_content": "        top = clip.top();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": "end",
          "new_api": null,
          "old_text": "text.end()",
          "new_text": null,
          "old_line_content": "    for (auto it = text.begin(); it != text.end(); ++it) {",
          "new_line_content": "        if (codepoint == '\\n') {",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": "substring_view",
          "new_api": null,
          "old_text": "text.substring_view(start_of_current_line, byte_offset - start_of_current_line)",
          "new_text": null,
          "old_line_content": "            Utf8View line = text.substring_view(start_of_current_line, byte_offset - start_of_current_line);",
          "new_line_content": "            start_of_current_line = byte_offset + 1;",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": "right",
          "new_api": null,
          "old_text": "clip.right()",
          "new_text": null,
          "old_line_content": "        int end = x01 > x02 ? min((int)x01, clip.right()) : min((int)x02, clip.right());",
          "new_line_content": "        for (int x = start; x < end; x++) {",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": "scanline",
          "new_api": null,
          "old_text": "m_target->scanline(y)",
          "new_text": null,
          "old_line_content": "        auto* scanline = m_target->scanline(y);",
          "new_line_content": "            scanline[x] = rgba;",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": "append",
          "new_api": null,
          "old_text": "lines.append(line)",
          "new_text": null,
          "old_line_content": "            lines.append(line);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": "byte_length",
          "new_api": null,
          "old_text": "text.byte_length()",
          "new_text": null,
          "old_line_content": "        Utf8View line = text.substring_view(start_of_current_line, text.byte_length() - start_of_current_line);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": "append",
          "new_api": null,
          "old_text": "lines.append(line)",
          "new_text": null,
          "old_line_content": "        lines.append(line);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 392,
          "old_api": "y",
          "new_api": null,
          "old_text": "p0.y()",
          "new_text": null,
          "old_line_content": "    x02 = p0.x() + dx02 * (p1.y() - p0.y());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": "glyph_height",
          "new_api": null,
          "old_text": "font.glyph_height()",
          "new_text": null,
          "old_line_content": "    int line_height = font.glyph_height() + line_spacing;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "size",
          "new_api": null,
          "old_text": "lines.size()",
          "new_text": null,
          "old_line_content": "    Rect bounding_rect { 0, 0, 0, (static_cast<int>(lines.size()) * line_height) - line_spacing };",
          "new_line_content": "    for (auto& line : lines) {",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": "top",
          "new_api": null,
          "old_text": "clip.top()",
          "new_text": null,
          "old_line_content": "        x12 += dx12 * (clip.top() - top);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 399,
          "old_api": "top",
          "new_api": null,
          "old_text": "clip.top()",
          "new_text": null,
          "old_line_content": "        top = clip.top();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": "width",
          "new_api": null,
          "old_text": "bounding_rect.width()",
          "new_text": null,
          "old_line_content": "        if (line_width > bounding_rect.width())",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": "set_width",
          "new_api": null,
          "old_text": "bounding_rect.set_width(line_width)",
          "new_text": null,
          "old_line_content": "            bounding_rect.set_width(line_width);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": "right",
          "new_api": null,
          "old_text": "clip.right()",
          "new_text": null,
          "old_line_content": "        int end = x12 > x02 ? min((int)x12, clip.right()) : min((int)x02, clip.right());",
          "new_line_content": "        for (int x = start; x < end; x++) {",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": "scanline",
          "new_api": null,
          "old_text": "m_target->scanline(y)",
          "new_text": null,
          "old_line_content": "        auto* scanline = m_target->scanline(y);",
          "new_line_content": "            scanline[x] = rgba;",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": "location",
          "new_api": null,
          "old_text": "rect.location()",
          "new_text": null,
          "old_line_content": "        bounding_rect.set_location(rect.location());",
          "new_line_content": "    case TextAlignment::TopRight:",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "y",
          "new_api": null,
          "old_text": "rect.y()",
          "new_text": null,
          "old_line_content": "        bounding_rect.set_location({ (rect.right() + 1) - bounding_rect.width(), rect.y() });",
          "new_line_content": "    case TextAlignment::CenterLeft:",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": "height",
          "new_api": null,
          "old_text": "bounding_rect.height()",
          "new_text": null,
          "old_line_content": "        bounding_rect.set_location({ rect.x(), rect.center().y() - (bounding_rect.height() / 2) });",
          "new_line_content": "    case TextAlignment::CenterRight:",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "height",
          "new_api": null,
          "old_text": "bounding_rect.height()",
          "new_text": null,
          "old_line_content": "        bounding_rect.set_location({ (rect.right() + 1) - bounding_rect.width(), rect.center().y() - (bounding_rect.height() / 2) });",
          "new_line_content": "    case TextAlignment::Center:",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "clip_rect()",
          "new_text": null,
          "old_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": "center_within",
          "new_api": null,
          "old_text": "bounding_rect.center_within(rect)",
          "new_text": null,
          "old_line_content": "        bounding_rect.center_within(rect);",
          "new_line_content": "    default:",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "ASSERT_NOT_REACHED",
          "new_api": null,
          "old_text": "ASSERT_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "        ASSERT_NOT_REACHED();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": "x",
          "new_api": null,
          "old_text": "clipped_rect.x()",
          "new_text": null,
          "old_line_content": "    RGBA32* dst = m_target->scanline(clipped_rect.y()) + clipped_rect.x();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": "intersect",
          "new_api": null,
          "old_text": "line_rect.intersect(rect)",
          "new_text": null,
          "old_line_content": "        line_rect.intersect(rect);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "draw_text_line",
          "new_api": null,
          "old_text": "draw_text_line(line_rect, line, font, alignment, color, elision)",
          "new_text": null,
          "old_line_content": "        draw_text_line(line_rect, line, font, alignment, color, elision);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": "top",
          "new_api": null,
          "old_text": "src_rect.top()",
          "new_text": null,
          "old_line_content": "        int sr = (row + src_rect.top()) * vscale;",
          "new_line_content": "            dst += dst_skip;",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": "size",
          "new_api": null,
          "old_text": "source.size().height()",
          "new_text": null,
          "old_line_content": "        if (sr >= source.size().height() || sr < 0) {",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": "scanline",
          "new_api": null,
          "old_text": "source.scanline(sr)",
          "new_text": null,
          "old_line_content": "        const RGBA32* sl = source.scanline(sr);",
          "new_line_content": "            int sx = x * hscale;",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": "state",
          "new_api": null,
          "old_text": "state()",
          "new_text": null,
          "old_line_content": "    point.move_by(state().translation);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": "size",
          "new_api": null,
          "old_text": "source.size().width()",
          "new_text": null,
          "old_line_content": "            if (sx < source.size().width() && sx >= 0)",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": "value",
          "new_api": null,
          "old_text": "color.value()",
          "new_text": null,
          "old_line_content": "    m_target->scanline(point.y())[point.x()] = color.value();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "draw_op",
          "new_api": null,
          "old_text": "draw_op()",
          "new_text": null,
          "old_line_content": "    else if (draw_op() == DrawOp::Xor)",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": "value",
          "new_api": null,
          "old_text": "color.value()",
          "new_text": null,
          "old_line_content": "        pixel ^= color.value();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": "has_alpha_channel",
          "new_api": null,
          "old_text": "m_target->has_alpha_channel()",
          "new_text": null,
          "old_line_content": "    ASSERT(!m_target->has_alpha_channel());",
          "new_line_content": "    if (!opacity)",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": "blit",
          "new_api": null,
          "old_text": "blit(position, source, src_rect)",
          "new_text": null,
          "old_line_content": "        return blit(position, source, src_rect);",
          "new_line_content": "    u8 alpha = 255 * opacity;",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": "translated",
          "new_api": null,
          "old_text": "position.translated(-(thickness / 2), -(thickness / 2))",
          "new_text": null,
          "old_line_content": "    Rect rect { position.translated(-(thickness / 2), -(thickness / 2)), { thickness, thickness } };",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": "state",
          "new_api": null,
          "old_text": "state()",
          "new_text": null,
          "old_line_content": "    fill_rect(rect.translated(-state().translation), color);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "clip_rect()",
          "new_text": null,
          "old_line_content": "    auto clipped_rect = Rect::intersection(dst_rect, clip_rect());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "this->clip_rect()",
          "new_text": null,
          "old_line_content": "    auto clip_rect = this->clip_rect();",
          "new_line_content": "    auto point1 = p1;",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": "state",
          "new_api": null,
          "old_text": "state()",
          "new_text": null,
          "old_line_content": "    point1.move_by(state().translation);",
          "new_line_content": "    auto point2 = p2;",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": "state",
          "new_api": null,
          "old_text": "state()",
          "new_text": null,
          "old_line_content": "    point2.move_by(state().translation);",
          "new_line_content": "    // Special case: vertical line.",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "pitch",
          "new_api": null,
          "old_text": "m_target->pitch()",
          "new_text": null,
          "old_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": "pitch",
          "new_api": null,
          "old_text": "source.pitch()",
          "new_text": null,
          "old_line_content": "    const unsigned src_skip = source.pitch() / sizeof(RGBA32);",
          "new_line_content": "    for (int row = first_row; row <= last_row; ++row) {",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": "x",
          "new_api": null,
          "old_text": "point1.x()",
          "new_text": null,
          "old_line_content": "        const int x = point1.x();",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": "swap",
          "new_api": null,
          "old_text": "swap(point1, point2)",
          "new_text": null,
          "old_line_content": "            swap(point1, point2);",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": "Color::from_rgb(dst[x])",
          "new_api": null,
          "old_text": "Color::from_rgb(dst[x])",
          "new_text": null,
          "old_line_content": "            Color dst_color = Color::from_rgb(dst[x]);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": "blend",
          "new_api": null,
          "old_text": "dst_color.blend(src_color_with_alpha).value()",
          "new_text": null,
          "old_line_content": "            dst[x] = dst_color.blend(src_color_with_alpha).value();",
          "new_line_content": "        dst += dst_skip;",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": "top",
          "new_api": null,
          "old_text": "clip_rect.top()",
          "new_text": null,
          "old_line_content": "        int min_y = max(point1.y(), clip_rect.top());",
          "new_line_content": "        if (style == LineStyle::Dotted) {",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": "bottom",
          "new_api": null,
          "old_text": "clip_rect.bottom()",
          "new_text": null,
          "old_line_content": "        int max_y = min(point2.y(), clip_rect.bottom());",
          "new_line_content": "            for (int y = min_y; y <= max_y; y += thickness * 2)",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": "draw_pixel",
          "new_api": null,
          "old_text": "draw_pixel({ x, y }, color, thickness)",
          "new_text": null,
          "old_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "new_line_content": "            for (int y = min_y; y <= max_y; y += thickness * 6) {",
          "content_same": false
        },
        {
          "line": 486,
          "old_api": "clip_rect",
          "new_api": null,
          "old_text": "clip_rect()",
          "new_text": null,
          "old_line_content": "    auto clipped_rect = dst_rect.intersected(clip_rect());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": "min",
          "new_api": null,
          "old_text": "min(y + thickness, max_y)",
          "new_text": null,
          "old_line_content": "                draw_pixel({ x, min(y + thickness, max_y) }, color, thickness);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "min",
          "new_api": null,
          "old_text": "min(y + thickness * 2, max_y)",
          "new_text": null,
          "old_line_content": "                draw_pixel({ x, min(y + thickness * 2, max_y) }, color, thickness);",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": "draw_pixel",
          "new_api": null,
          "old_text": "draw_pixel({ x, y }, color, thickness)",
          "new_text": null,
          "old_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": "pitch",
          "new_api": null,
          "old_text": "m_target->pitch()",
          "new_text": null,
          "old_line_content": "    const size_t dst_skip = m_target->pitch() / sizeof(RGBA32);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": "pitch",
          "new_api": null,
          "old_text": "source.pitch()",
          "new_text": null,
          "old_line_content": "    const size_t src_skip = source.pitch() / sizeof(RGBA32);",
          "new_line_content": "    for (int row = first_row; row <= last_row; ++row) {",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": "y",
          "new_api": null,
          "old_text": "point1.y()",
          "new_text": null,
          "old_line_content": "        const int y = point1.y();",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": "Color::from_rgba(src[x])",
          "new_api": null,
          "old_text": "Color::from_rgba(src[x])",
          "new_text": null,
          "old_line_content": "                dst[x] = filter(Color::from_rgba(src[x])).value();",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": "swap",
          "new_api": null,
          "old_text": "swap(point1, point2)",
          "new_text": null,
          "old_line_content": "            swap(point1, point2);",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "Color::from_rgba(src[x])",
          "new_api": null,
          "old_text": "Color::from_rgba(src[x])",
          "new_text": null,
          "old_line_content": "                dst[x] = Color::from_rgba(dst[x]).blend(filter(Color::from_rgba(src[x]))).value();",
          "new_line_content": "        dst += dst_skip;",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": "left",
          "new_api": null,
          "old_text": "clip_rect.left()",
          "new_text": null,
          "old_line_content": "        int min_x = max(point1.x(), clip_rect.left());",
          "new_line_content": "        if (style == LineStyle::Dotted) {",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "right",
          "new_api": null,
          "old_text": "clip_rect.right()",
          "new_text": null,
          "old_line_content": "        int max_x = min(point2.x(), clip_rect.right());",
          "new_line_content": "            for (int x = min_x; x <= max_x; x += thickness * 2)",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": "draw_pixel",
          "new_api": null,
          "old_text": "draw_pixel({ x, y }, color, thickness)",
          "new_text": null,
          "old_line_content": "                draw_pixel({ x, y }, color, thickness);",
          "new_line_content": "            for (int x = min_x; x <= max_x; x += thickness * 6) {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 172,
      "total_additions": 249,
      "total_deletions": 250,
      "total_api_changes": 671
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 4,
        "api_related_lines": 671,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          152,
          150,
          151
        ]
      }
    },
    "api_calls_before": 902,
    "api_calls_after": 900,
    "diff_info": {
      "added_lines": 2,
      "removed_lines": 4,
      "total_diff_lines": 18
    }
  }
}