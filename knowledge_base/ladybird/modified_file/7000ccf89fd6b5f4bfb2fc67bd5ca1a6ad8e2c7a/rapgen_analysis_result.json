{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/7000ccf89fd6b5f4bfb2fc67bd5ca1a6ad8e2c7a",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/7000ccf89fd6b5f4bfb2fc67bd5ca1a6ad8e2c7a/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/7000ccf89fd6b5f4bfb2fc67bd5ca1a6ad8e2c7a/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/7000ccf89fd6b5f4bfb2fc67bd5ca1a6ad8e2c7a/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 545,
          "old_api": "release_value",
          "new_api": "decode_bit_with_probability",
          "old_text": "m_leftover_match_length.release_value()",
          "new_text": "decode_bit_with_probability(m_is_match_probabilities[state2])",
          "old_line_content": "            TRY(copy_match_to_buffer(m_leftover_match_length.release_value()));",
          "new_line_content": "        if (TRY(decode_bit_with_probability(m_is_match_probabilities[state2])) == 0) {",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "decode_normalized_match_distance",
          "new_api": "Error::from_string_literal(\"An end-of-stream marker was found, but the LZMA stream is configured to reject them\")",
          "old_text": "decode_normalized_match_distance(normalized_length)",
          "new_text": "Error::from_string_literal(\"An end-of-stream marker was found, but the LZMA stream is configured to reject them\")",
          "old_line_content": "            m_rep0 = TRY(decode_normalized_match_distance(normalized_length));",
          "new_line_content": "                    return Error::from_string_literal(\"An end-of-stream marker was found, but the LZMA stream is configured to reject them\");",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": "Error::from_string_literal(\"An end-of-stream marker was found, but the LZMA stream is configured to reject them\")",
          "new_api": "Error::from_string_literal(\"First simple match after the expected uncompressed size is not the EOS marker\")",
          "old_text": "Error::from_string_literal(\"An end-of-stream marker was found, but the LZMA stream is configured to reject them\")",
          "new_text": "Error::from_string_literal(\"First simple match after the expected uncompressed size is not the EOS marker\")",
          "old_line_content": "                    return Error::from_string_literal(\"An end-of-stream marker was found, but the LZMA stream is configured to reject them\");",
          "new_line_content": "                return Error::from_string_literal(\"First simple match after the expected uncompressed size is not the EOS marker\");",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": "has_reached_expected_data_size",
          "new_api": "seekback_limit",
          "old_text": "has_reached_expected_data_size()",
          "new_text": "m_dictionary->seekback_limit()",
          "old_line_content": "            if (has_reached_expected_data_size())",
          "new_line_content": "            if (current_repetition_offset() > m_dictionary->seekback_limit())",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": "Error::from_string_literal(\"First simple match after the expected uncompressed size is not the EOS marker\")",
          "new_api": "Error::from_string_literal(\"rep0 value is larger than the possible lookback size\")",
          "old_text": "Error::from_string_literal(\"First simple match after the expected uncompressed size is not the EOS marker\")",
          "new_text": "Error::from_string_literal(\"rep0 value is larger than the possible lookback size\")",
          "old_line_content": "                return Error::from_string_literal(\"First simple match after the expected uncompressed size is not the EOS marker\");",
          "new_line_content": "                return Error::from_string_literal(\"rep0 value is larger than the possible lookback size\");",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": "decode_bit_with_probability",
          "new_api": "update_state_after_short_rep",
          "old_text": "decode_bit_with_probability(m_is_rep_g0_probabilities[m_state])",
          "new_text": "update_state_after_short_rep()",
          "old_line_content": "        if (TRY(decode_bit_with_probability(m_is_rep_g0_probabilities[m_state])) == 0) {",
          "new_line_content": "                update_state_after_short_rep();",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": "update_state_after_rep",
          "new_api": "Error::from_string_literal(\"Found end-of-stream marker earlier than expected\")",
          "old_text": "update_state_after_rep()",
          "new_text": "Error::from_string_literal(\"Found end-of-stream marker earlier than expected\")",
          "old_line_content": "        update_state_after_rep();",
          "new_line_content": "            return Error::from_string_literal(\"Found end-of-stream marker earlier than expected\");",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": "is_range_decoder_in_clean_state",
          "new_api": "Error::from_errno(EBADF)",
          "old_text": "is_range_decoder_in_clean_state()",
          "new_text": "Error::from_errno(EBADF)",
          "old_line_content": "        if (!is_range_decoder_in_clean_state())",
          "new_line_content": "    return Error::from_errno(EBADF);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 642,
          "old_api": null,
          "new_api": "decode_bit_with_probability",
          "old_text": null,
          "new_text": "decode_bit_with_probability(m_is_rep_g1_probabilities[m_state])",
          "old_line_content": "",
          "new_line_content": "            if (TRY(decode_bit_with_probability(m_is_rep_g1_probabilities[m_state])) == 0) {",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": null,
          "new_api": "current_repetition_offset",
          "old_text": null,
          "new_text": "current_repetition_offset()",
          "old_line_content": "            while (real_length > 0) {",
          "new_line_content": "            auto copied_length = TRY(m_dictionary->copy_from_seekback(current_repetition_offset(), real_length));",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "m_leftover_match_length.has_value()",
          "old_line_content": "                m_total_decoded_bytes++;",
          "new_line_content": "        if (m_leftover_match_length.has_value()) {",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": null,
          "new_api": "release_value",
          "old_text": null,
          "new_text": "m_leftover_match_length.release_value()",
          "old_line_content": "",
          "new_line_content": "            TRY(copy_match_to_buffer(m_leftover_match_length.release_value()));",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": null,
          "new_api": "decode_normalized_match_length",
          "old_text": null,
          "new_text": "decode_normalized_match_length(m_rep_length_decoder)",
          "old_line_content": "                m_rep3 = m_rep2;",
          "new_line_content": "        u16 normalized_length = TRY(decode_normalized_match_length(m_rep_length_decoder));",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": null,
          "new_api": "update_state_after_rep",
          "old_text": null,
          "new_text": "update_state_after_rep()",
          "old_line_content": "                m_rep0 = distance;",
          "new_line_content": "        update_state_after_rep();",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": null,
          "new_api": "has_reached_expected_data_size",
          "old_text": null,
          "new_text": "has_reached_expected_data_size()",
          "old_line_content": "        }",
          "new_line_content": "            if (has_reached_expected_data_size())",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": null,
          "new_api": "Error::from_string_literal(\"Found literal after reaching expected uncompressed size\")",
          "old_text": null,
          "new_text": "Error::from_string_literal(\"Found literal after reaching expected uncompressed size\")",
          "old_line_content": "",
          "new_line_content": "                return Error::from_string_literal(\"Found literal after reaching expected uncompressed size\");",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": null,
          "new_api": "copy_match_to_buffer",
          "old_text": null,
          "new_text": "copy_match_to_buffer(normalized_length + normalized_to_real_match_length_offset)",
          "old_line_content": "        // \"In other cases (Rep Match 0/1/2/3), it decodes the zero-based",
          "new_line_content": "        TRY(copy_match_to_buffer(normalized_length + normalized_to_real_match_length_offset));",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": null,
          "new_api": "has_reached_expected_data_size",
          "old_text": null,
          "new_text": "has_reached_expected_data_size()",
          "old_line_content": "",
          "new_line_content": "    if (m_found_end_of_stream_marker || has_reached_expected_data_size()) {",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "m_options.uncompressed_size.value()",
          "old_line_content": "        // \"Then it updates the state.\"",
          "new_line_content": "        if (m_options.uncompressed_size.has_value() && m_total_decoded_bytes < m_options.uncompressed_size.value())",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": null,
          "new_api": "decode_literal_to_output_buffer",
          "old_text": null,
          "new_text": "decode_literal_to_output_buffer()",
          "old_line_content": "            // If we are already past the expected uncompressed size, we are already in \"look for EOS only\" mode.",
          "new_line_content": "            TRY(decode_literal_to_output_buffer());",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "is_range_decoder_in_clean_state",
          "old_text": null,
          "new_text": "is_range_decoder_in_clean_state()",
          "old_line_content": "        // \"Then the decoder must copy match bytes as described in",
          "new_line_content": "        if (!is_range_decoder_in_clean_state())",
          "content_same": false
        },
        {
          "line": 685,
          "old_api": null,
          "new_api": "Error::from_string_literal(\"LZMA stream ends in an unclean state\")",
          "old_text": null,
          "new_text": "Error::from_string_literal(\"LZMA stream ends in an unclean state\")",
          "old_line_content": "        //  \"The Match symbols copying\" section.\"",
          "new_line_content": "            return Error::from_string_literal(\"LZMA stream ends in an unclean state\");",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": null,
          "new_api": "update_state_after_literal",
          "old_text": null,
          "new_text": "update_state_after_literal()",
          "old_line_content": "",
          "new_line_content": "            update_state_after_literal();",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": null,
          "new_api": "read",
          "old_text": null,
          "new_text": "m_dictionary->read(bytes)",
          "old_line_content": "",
          "new_line_content": "    return m_dictionary->read(bytes);",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": null,
          "new_api": "decode_bit_with_probability",
          "old_text": null,
          "new_text": "decode_bit_with_probability(m_is_rep_probabilities[m_state])",
          "old_line_content": "",
          "new_line_content": "        if (TRY(decode_bit_with_probability(m_is_rep_probabilities[m_state])) == 0) {",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": null,
          "new_api": "used_space",
          "old_text": null,
          "new_text": "m_dictionary->used_space()",
          "old_line_content": "}",
          "new_line_content": "    if (m_dictionary->used_space() > 0)",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "decode_normalized_match_length",
          "old_text": null,
          "new_text": "decode_normalized_match_length(m_length_decoder)",
          "old_line_content": "        //     IsRep[state] decode",
          "new_line_content": "            u16 normalized_length = TRY(decode_normalized_match_length(m_length_decoder));",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": null,
          "new_api": "has_reached_expected_data_size",
          "old_text": null,
          "new_text": "has_reached_expected_data_size()",
          "old_line_content": "{",
          "new_line_content": "    if (has_reached_expected_data_size())",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": null,
          "new_api": "update_state_after_match",
          "old_text": null,
          "new_text": "update_state_after_match()",
          "old_line_content": "            // \"The distance history table is updated with the following scheme:\"",
          "new_line_content": "            update_state_after_match();",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": null,
          "new_api": "decode_normalized_match_distance",
          "old_text": null,
          "new_text": "decode_normalized_match_distance(normalized_length)",
          "old_line_content": "            m_rep1 = m_rep0;",
          "new_line_content": "            m_rep0 = TRY(decode_normalized_match_distance(normalized_length));",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": null,
          "new_api": "has_reached_expected_data_size",
          "old_text": null,
          "new_text": "has_reached_expected_data_size()",
          "old_line_content": "                if (m_options.reject_end_of_stream_marker)",
          "new_line_content": "            if (has_reached_expected_data_size())",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": null,
          "new_api": "copy_match_to_buffer",
          "old_text": null,
          "new_text": "copy_match_to_buffer(normalized_length + normalized_to_real_match_length_offset)",
          "old_line_content": "            // This is being checked for in the common \"copy to buffer\" implementation.",
          "new_line_content": "            TRY(copy_match_to_buffer(normalized_length + normalized_to_real_match_length_offset));",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": null,
          "new_api": "has_reached_expected_data_size",
          "old_text": null,
          "new_text": "has_reached_expected_data_size()",
          "old_line_content": "",
          "new_line_content": "        if (has_reached_expected_data_size())",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": null,
          "new_api": "Error::from_string_literal(\"First match type after the expected uncompressed size is not a simple match\")",
          "old_text": null,
          "new_text": "Error::from_string_literal(\"First match type after the expected uncompressed size is not a simple match\")",
          "old_line_content": "            // \"Then the decoder must copy match bytes as described in",
          "new_line_content": "            return Error::from_string_literal(\"First match type after the expected uncompressed size is not a simple match\");",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": null,
          "new_api": "decode_bit_with_probability",
          "old_text": null,
          "new_text": "decode_bit_with_probability(m_is_rep_g0_probabilities[m_state])",
          "old_line_content": "        }",
          "new_line_content": "        if (TRY(decode_bit_with_probability(m_is_rep_g0_probabilities[m_state])) == 0) {",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": null,
          "new_api": "decode_bit_with_probability",
          "old_text": null,
          "new_text": "decode_bit_with_probability(m_is_rep0_long_probabilities[state2])",
          "old_line_content": "",
          "new_line_content": "            if (TRY(decode_bit_with_probability(m_is_rep0_long_probabilities[state2])) == 0) {",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": null,
          "new_api": "copy_match_to_buffer",
          "old_text": null,
          "new_text": "copy_match_to_buffer(1)",
          "old_line_content": "",
          "new_line_content": "                TRY(copy_match_to_buffer(1));",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 641,
          "old_api": "copy_match_to_buffer",
          "new_api": null,
          "old_text": "copy_match_to_buffer(1)",
          "new_text": null,
          "old_line_content": "                TRY(copy_match_to_buffer(1));",
          "new_line_content": "            //           0 - Rep Match 1\"",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": "empty_space",
          "new_api": null,
          "old_text": "m_dictionary->empty_space()",
          "new_text": null,
          "old_line_content": "                if (m_dictionary->empty_space() == 0) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": "current_repetition_offset",
          "new_api": null,
          "old_text": "current_repetition_offset()",
          "new_text": null,
          "old_line_content": "                auto read_bytes = TRY(m_dictionary->read_with_seekback({ &byte, sizeof(byte) }, current_repetition_offset()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "size",
          "new_api": null,
          "old_text": "read_bytes.size()",
          "new_text": null,
          "old_line_content": "                VERIFY(read_bytes.size() == sizeof(byte));",
          "new_line_content": "            return {};",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": "decode_bit_with_probability",
          "new_api": null,
          "old_text": "decode_bit_with_probability(m_is_rep_g2_probabilities[m_state])",
          "new_text": null,
          "old_line_content": "            else if (TRY(decode_bit_with_probability(m_is_rep_g2_probabilities[m_state])) == 0) {",
          "new_line_content": "                u32 distance = m_rep3;",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": "write",
          "new_api": null,
          "old_text": "m_dictionary->write({ &byte, sizeof(byte) })",
          "new_text": null,
          "old_line_content": "                auto written_bytes = m_dictionary->write({ &byte, sizeof(byte) });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "VERIFY",
          "new_api": null,
          "old_text": "VERIFY(written_bytes == sizeof(byte))",
          "new_text": null,
          "old_line_content": "                VERIFY(written_bytes == sizeof(byte));",
          "new_line_content": "        // If we have a leftover part of a repeating match, we should finish that first.",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "m_leftover_match_length.has_value()",
          "new_text": null,
          "old_line_content": "        if (m_leftover_match_length.has_value()) {",
          "new_line_content": "        //   0 - the Literal\"",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "decode_normalized_match_length",
          "new_api": null,
          "old_text": "decode_normalized_match_length(m_rep_length_decoder)",
          "new_text": null,
          "old_line_content": "        u16 normalized_length = TRY(decode_normalized_match_length(m_rep_length_decoder));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": "decode_bit_with_probability",
          "new_api": null,
          "old_text": "decode_bit_with_probability(m_is_match_probabilities[state2])",
          "new_text": null,
          "old_line_content": "        if (TRY(decode_bit_with_probability(m_is_match_probabilities[state2])) == 0) {",
          "new_line_content": "            // \"Then it decodes literal value and puts it to sliding window.\"",
          "content_same": false
        },
        {
          "line": 556,
          "old_api": "has_reached_expected_data_size",
          "new_api": null,
          "old_text": "has_reached_expected_data_size()",
          "new_text": null,
          "old_line_content": "            if (has_reached_expected_data_size())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": "Error::from_string_literal(\"Found literal after reaching expected uncompressed size\")",
          "new_api": null,
          "old_text": "Error::from_string_literal(\"Found literal after reaching expected uncompressed size\")",
          "new_text": null,
          "old_line_content": "                return Error::from_string_literal(\"Found literal after reaching expected uncompressed size\");",
          "new_line_content": "            // \"Then the decoder must update the \"state\" value.\"",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": "copy_match_to_buffer",
          "new_api": null,
          "old_text": "copy_match_to_buffer(normalized_length + normalized_to_real_match_length_offset)",
          "new_text": null,
          "old_line_content": "        TRY(copy_match_to_buffer(normalized_length + normalized_to_real_match_length_offset));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": "has_reached_expected_data_size",
          "new_api": null,
          "old_text": "has_reached_expected_data_size()",
          "new_text": null,
          "old_line_content": "    if (m_found_end_of_stream_marker || has_reached_expected_data_size()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": "value",
          "new_api": null,
          "old_text": "m_options.uncompressed_size.value()",
          "new_text": null,
          "old_line_content": "        if (m_options.uncompressed_size.has_value() && m_total_decoded_bytes < m_options.uncompressed_size.value())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": "Error::from_string_literal(\"Found end-of-stream marker earlier than expected\")",
          "new_api": null,
          "old_text": "Error::from_string_literal(\"Found end-of-stream marker earlier than expected\")",
          "new_text": null,
          "old_line_content": "            return Error::from_string_literal(\"Found end-of-stream marker earlier than expected\");",
          "new_line_content": "ErrorOr<size_t> LzmaDecompressor::write_some(ReadonlyBytes)",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "decode_literal_to_output_buffer",
          "new_api": null,
          "old_text": "decode_literal_to_output_buffer()",
          "new_text": null,
          "old_line_content": "            TRY(decode_literal_to_output_buffer());",
          "new_line_content": "        //       0 - Simple Match\"",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": "Error::from_string_literal(\"LZMA stream ends in an unclean state\")",
          "new_api": null,
          "old_text": "Error::from_string_literal(\"LZMA stream ends in an unclean state\")",
          "new_text": null,
          "old_line_content": "            return Error::from_string_literal(\"LZMA stream ends in an unclean state\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "update_state_after_literal",
          "new_api": null,
          "old_text": "update_state_after_literal()",
          "new_text": null,
          "old_line_content": "            update_state_after_literal();",
          "new_line_content": "            m_rep3 = m_rep2;",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": "read",
          "new_api": null,
          "old_text": "m_dictionary->read(bytes)",
          "new_text": null,
          "old_line_content": "    return m_dictionary->read(bytes);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": "decode_bit_with_probability",
          "new_api": null,
          "old_text": "decode_bit_with_probability(m_is_rep_probabilities[m_state])",
          "new_text": null,
          "old_line_content": "        if (TRY(decode_bit_with_probability(m_is_rep_probabilities[m_state])) == 0) {",
          "new_line_content": "            // \"The state is update with UpdateState_Match function.\"",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": "Error::from_errno(EBADF)",
          "new_api": null,
          "old_text": "Error::from_errno(EBADF)",
          "new_text": null,
          "old_line_content": "    return Error::from_errno(EBADF);",
          "new_line_content": "        return true;",
          "content_same": false
        },
        {
          "line": 707,
          "old_api": "used_space",
          "new_api": null,
          "old_text": "m_dictionary->used_space()",
          "new_text": null,
          "old_line_content": "    if (m_dictionary->used_space() > 0)",
          "new_line_content": "bool LzmaDecompressor::is_open() const",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": "decode_normalized_match_length",
          "new_api": null,
          "old_text": "decode_normalized_match_length(m_length_decoder)",
          "new_text": null,
          "old_line_content": "            u16 normalized_length = TRY(decode_normalized_match_length(m_length_decoder));",
          "new_line_content": "            //  \"End of stream\" marker, so we can stop decoding and check finishing",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": "has_reached_expected_data_size",
          "new_api": null,
          "old_text": "has_reached_expected_data_size()",
          "new_text": null,
          "old_line_content": "    if (has_reached_expected_data_size())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "update_state_after_match",
          "new_api": null,
          "old_text": "update_state_after_match()",
          "new_text": null,
          "old_line_content": "            update_state_after_match();",
          "new_line_content": "                // If we should reject end-of-stream markers, do so now.",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": "seekback_limit",
          "new_api": null,
          "old_text": "m_dictionary->seekback_limit()",
          "new_text": null,
          "old_line_content": "            if (current_repetition_offset() > m_dictionary->seekback_limit())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": "Error::from_string_literal(\"rep0 value is larger than the possible lookback size\")",
          "new_api": null,
          "old_text": "Error::from_string_literal(\"rep0 value is larger than the possible lookback size\")",
          "new_text": null,
          "old_line_content": "                return Error::from_string_literal(\"rep0 value is larger than the possible lookback size\");",
          "new_line_content": "        // If we are looking for EOS, but find another match type, the stream is also corrupted.",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": "copy_match_to_buffer",
          "new_api": null,
          "old_text": "copy_match_to_buffer(normalized_length + normalized_to_real_match_length_offset)",
          "new_text": null,
          "old_line_content": "            TRY(copy_match_to_buffer(normalized_length + normalized_to_real_match_length_offset));",
          "new_line_content": "        // \"     1 - Rep Match",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": "has_reached_expected_data_size",
          "new_api": null,
          "old_text": "has_reached_expected_data_size()",
          "new_text": null,
          "old_line_content": "        if (has_reached_expected_data_size())",
          "new_line_content": "            // \"       IsRep0Long[state2] decode",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": "Error::from_string_literal(\"First match type after the expected uncompressed size is not a simple match\")",
          "new_api": null,
          "old_text": "Error::from_string_literal(\"First match type after the expected uncompressed size is not a simple match\")",
          "new_text": null,
          "old_line_content": "            return Error::from_string_literal(\"First match type after the expected uncompressed size is not a simple match\");",
          "new_line_content": "            //           0 - Short Rep Match\"",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": "decode_bit_with_probability",
          "new_api": null,
          "old_text": "decode_bit_with_probability(m_is_rep0_long_probabilities[state2])",
          "new_text": null,
          "old_line_content": "            if (TRY(decode_bit_with_probability(m_is_rep0_long_probabilities[state2])) == 0) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": "update_state_after_short_rep",
          "new_api": null,
          "old_text": "update_state_after_short_rep()",
          "new_text": null,
          "old_line_content": "                update_state_after_short_rep();",
          "new_line_content": "            // \"     1 -",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 8,
      "total_additions": 29,
      "total_deletions": 33,
      "total_api_changes": 70
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 15,
        "api_related_lines": 70,
        "non_api_lines": 7,
        "non_api_line_numbers": [
          525,
          526,
          527,
          528,
          529,
          537,
          538
        ]
      }
    },
    "api_calls_before": 203,
    "api_calls_after": 198,
    "diff_info": {
      "added_lines": 5,
      "removed_lines": 14,
      "total_diff_lines": 33
    }
  }
}