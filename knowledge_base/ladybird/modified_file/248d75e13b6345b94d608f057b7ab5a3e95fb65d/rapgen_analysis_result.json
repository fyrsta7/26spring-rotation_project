{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/248d75e13b6345b94d608f057b7ab5a3e95fb65d",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/248d75e13b6345b94d608f057b7ab5a3e95fb65d/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/248d75e13b6345b94d608f057b7ab5a3e95fb65d/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/248d75e13b6345b94d608f057b7ab5a3e95fb65d/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": true,
    "api_changes": {
      "replacements": [
        {
          "line": 805,
          "old_api": "size",
          "new_api": "scale_factor",
          "old_text": "cursor_rect.size()",
          "new_text": "Screen::the().scale_factor()",
          "old_line_content": "    if (!m_cursor_back_bitmap || m_cursor_back_bitmap->size() != cursor_rect.size()) {",
          "new_line_content": "    auto physical_cursor_size = cursor_rect.size() * Screen::the().scale_factor();",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "scale_factor",
          "new_api": "size",
          "old_text": "Screen::the().scale_factor()",
          "new_text": "m_cursor_back_bitmap->size()",
          "old_line_content": "        m_cursor_back_bitmap = Gfx::Bitmap::create(Gfx::BitmapFormat::RGB32, cursor_rect.size() * Screen::the().scale_factor());",
          "new_line_content": "    if (!m_cursor_back_bitmap || m_cursor_back_bitmap->size() != physical_cursor_size) {",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "make<Gfx::Painter>(*m_cursor_back_bitmap)",
          "new_api": "Gfx::Bitmap::create(Gfx::BitmapFormat::RGB32, physical_cursor_size)",
          "old_text": "make<Gfx::Painter>(*m_cursor_back_bitmap)",
          "new_text": "Gfx::Bitmap::create(Gfx::BitmapFormat::RGB32, physical_cursor_size)",
          "old_line_content": "        m_cursor_back_painter = make<Gfx::Painter>(*m_cursor_back_bitmap);",
          "new_line_content": "        m_cursor_back_bitmap = Gfx::Bitmap::create(Gfx::BitmapFormat::RGB32, physical_cursor_size);",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "size",
          "new_api": "physical_rect",
          "old_text": "last_physical_cursor_rect.size()",
          "new_text": "Screen::the().physical_rect()",
          "old_line_content": "    unscaled_back_painter.blit(last_physical_cursor_rect.location(), *m_cursor_back_bitmap, { { 0, 0 }, last_physical_cursor_rect.size() });",
          "new_line_content": "    auto last_physical_cursor_rect = (m_last_cursor_rect * Screen::the().scale_factor()).intersected(Screen::the().physical_rect());",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": "for_each_visible_window_from_back_to_front",
          "new_api": "WindowManager::the()",
          "old_text": "wm.for_each_visible_window_from_back_to_front([&](Window& window) {\n        if (wm.m_switcher.is_visible()) {\n            window.set_occluded(false);\n        } else {\n            if (any_opaque_window_above_this_one_contains_rect(window, window.frame().rect()))\n                window.set_occluded(true);\n            else\n                window.set_occluded(false);\n        }\n        return IterationDecision::Continue;\n    })",
          "new_text": "WindowManager::the()",
          "old_line_content": "    wm.for_each_visible_window_from_back_to_front([&](Window& window) {",
          "new_line_content": "    auto& wm = WindowManager::the();",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": "is_visible",
          "new_api": "for_each_visible_window_from_back_to_front",
          "old_text": "wm.m_switcher.is_visible()",
          "new_text": "wm.for_each_visible_window_from_back_to_front([&](Window& window) {\n        if (wm.m_switcher.is_visible()) {\n            window.set_occluded(false);\n        } else {\n            if (any_opaque_window_above_this_one_contains_rect(window, window.frame().rect()))\n                window.set_occluded(true);\n            else\n                window.set_occluded(false);\n        }\n        return IterationDecision::Continue;\n    })",
          "old_line_content": "        if (wm.m_switcher.is_visible()) {",
          "new_line_content": "    wm.for_each_visible_window_from_back_to_front([&](Window& window) {",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": "set_occluded",
          "new_api": "is_visible",
          "old_text": "window.set_occluded(false)",
          "new_text": "wm.m_switcher.is_visible()",
          "old_line_content": "            window.set_occluded(false);",
          "new_line_content": "        if (wm.m_switcher.is_visible()) {",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": "set_occluded",
          "new_api": "frame",
          "old_text": "window.set_occluded(true)",
          "new_text": "window.frame().rect()",
          "old_line_content": "                window.set_occluded(true);",
          "new_line_content": "            if (any_opaque_window_above_this_one_contains_rect(window, window.frame().rect()))",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": "for_each_visible_window_from_front_to_back",
          "new_api": "active_fullscreen_window",
          "old_text": "WindowManager::the().for_each_visible_window_from_front_to_back([&](Window& w) {\n            auto& visible_opaque = w.opaque_rects();\n            auto& transparency_rects = w.transparency_rects();\n            auto& transparency_wallpaper_rects = w.transparency_wallpaper_rects();\n            if (&w == fullscreen_window) {\n                if (w.is_opaque()) {\n                    visible_opaque = screen_rect;\n                    transparency_rects.clear();\n                    transparency_wallpaper_rects.clear();\n                } else {\n                    visible_opaque.clear();\n                    transparency_rects = screen_rect;\n                    transparency_wallpaper_rects = screen_rect;\n                }\n            } else {\n                visible_opaque.clear();\n                transparency_rects.clear();\n                transparency_wallpaper_rects.clear();\n            }\n            return IterationDecision::Continue;\n        })",
          "new_text": "wm.active_fullscreen_window()",
          "old_line_content": "        WindowManager::the().for_each_visible_window_from_front_to_back([&](Window& w) {",
          "new_line_content": "    if (auto* fullscreen_window = wm.active_fullscreen_window()) {",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": "opaque_rects",
          "new_api": "for_each_visible_window_from_front_to_back",
          "old_text": "w.opaque_rects()",
          "new_text": "WindowManager::the().for_each_visible_window_from_front_to_back([&](Window& w) {\n            auto& visible_opaque = w.opaque_rects();\n            auto& transparency_rects = w.transparency_rects();\n            auto& transparency_wallpaper_rects = w.transparency_wallpaper_rects();\n            if (&w == fullscreen_window) {\n                if (w.is_opaque()) {\n                    visible_opaque = screen_rect;\n                    transparency_rects.clear();\n                    transparency_wallpaper_rects.clear();\n                } else {\n                    visible_opaque.clear();\n                    transparency_rects = screen_rect;\n                    transparency_wallpaper_rects = screen_rect;\n                }\n            } else {\n                visible_opaque.clear();\n                transparency_rects.clear();\n                transparency_wallpaper_rects.clear();\n            }\n            return IterationDecision::Continue;\n        })",
          "old_line_content": "            auto& visible_opaque = w.opaque_rects();",
          "new_line_content": "        WindowManager::the().for_each_visible_window_from_front_to_back([&](Window& w) {",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": "transparency_rects",
          "new_api": "opaque_rects",
          "old_text": "w.transparency_rects()",
          "new_text": "w.opaque_rects()",
          "old_line_content": "            auto& transparency_rects = w.transparency_rects();",
          "new_line_content": "            auto& visible_opaque = w.opaque_rects();",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "transparency_wallpaper_rects",
          "new_api": "transparency_rects",
          "old_text": "w.transparency_wallpaper_rects()",
          "new_text": "w.transparency_rects()",
          "old_line_content": "            auto& transparency_wallpaper_rects = w.transparency_wallpaper_rects();",
          "new_line_content": "            auto& transparency_rects = w.transparency_rects();",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": "frame",
          "new_api": "for_each_visible_window_from_front_to_back",
          "old_text": "w.frame().rect().intersected(screen_rect)",
          "new_text": "WindowManager::the().for_each_visible_window_from_front_to_back([&](Window& w) {\n            auto window_frame_rect = w.frame().rect().intersected(screen_rect);\n            w.transparency_wallpaper_rects().clear();\n            auto& visible_opaque = w.opaque_rects();\n            auto& transparency_rects = w.transparency_rects();\n            if (w.is_minimized() || window_frame_rect.is_empty()) {\n                visible_opaque.clear();\n                transparency_rects.clear();\n                return IterationDecision::Continue;\n            }\n\n            Gfx::DisjointRectSet opaque_covering;\n            if (w.is_opaque()) {\n                visible_opaque = visible_rects.intersected(window_frame_rect);\n                transparency_rects.clear();\n            } else {\n                visible_opaque.clear();\n                transparency_rects = visible_rects.intersected(window_frame_rect);\n            }\n\n            bool found_this_window = false;\n            WindowManager::the().for_each_visible_window_from_back_to_front([&](Window& w2) {\n                if (!found_this_window) {\n                    if (&w == &w2)\n                        found_this_window = true;\n                    return IterationDecision::Continue;\n                }\n\n                if (w2.is_minimized())\n                    return IterationDecision::Continue;\n                auto window_frame_rect2 = w2.frame().rect().intersected(screen_rect);\n                auto covering_rect = window_frame_rect2.intersected(window_frame_rect);\n                if (covering_rect.is_empty())\n                    return IterationDecision::Continue;\n\n                if (w2.is_opaque()) {\n                    opaque_covering.add(covering_rect);\n                    if (opaque_covering.contains(window_frame_rect)) {\n                        // This window is entirely covered by another opaque window\n                        visible_opaque.clear();\n                        transparency_rects.clear();\n                        return IterationDecision::Break;\n                    }\n\n                    if (!visible_opaque.is_empty()) {\n                        auto uncovered_opaque = visible_opaque.shatter(covering_rect);\n                        visible_opaque = move(uncovered_opaque);\n                    }\n\n                    if (!transparency_rects.is_empty()) {\n                        auto uncovered_transparency = transparency_rects.shatter(covering_rect);\n                        transparency_rects = move(uncovered_transparency);\n                    }\n                } else {\n                    visible_rects.for_each_intersected(covering_rect, [&](const Gfx::IntRect& intersected) {\n                        transparency_rects.add(intersected);\n                        if (!visible_opaque.is_empty()) {\n                            auto uncovered_opaque = visible_opaque.shatter(intersected);\n                            visible_opaque = move(uncovered_opaque);\n                        }\n                        return IterationDecision::Continue;\n                    });\n                }\n\n                return IterationDecision::Continue;\n            });\n\n            if (!transparency_rects.is_empty())\n                have_transparent = true;\n\n            ASSERT(!visible_opaque.intersects(transparency_rects));\n\n            if (w.is_opaque()) {\n                // Determine visible area for the window below\n                auto visible_rects_below_window = visible_rects.shatter(window_frame_rect);\n                visible_rects = move(visible_rects_below_window);\n            }\n            return IterationDecision::Continue;\n        })",
          "old_line_content": "            auto window_frame_rect = w.frame().rect().intersected(screen_rect);",
          "new_line_content": "        WindowManager::the().for_each_visible_window_from_front_to_back([&](Window& w) {",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "transparency_wallpaper_rects",
          "new_api": "frame",
          "old_text": "w.transparency_wallpaper_rects().clear()",
          "new_text": "w.frame().rect().intersected(screen_rect)",
          "old_line_content": "            w.transparency_wallpaper_rects().clear();",
          "new_line_content": "            auto window_frame_rect = w.frame().rect().intersected(screen_rect);",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "opaque_rects",
          "new_api": "transparency_wallpaper_rects",
          "old_text": "w.opaque_rects()",
          "new_text": "w.transparency_wallpaper_rects().clear()",
          "old_line_content": "            auto& visible_opaque = w.opaque_rects();",
          "new_line_content": "            w.transparency_wallpaper_rects().clear();",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "transparency_rects",
          "new_api": "opaque_rects",
          "old_text": "w.transparency_rects()",
          "new_text": "w.opaque_rects()",
          "old_line_content": "            auto& transparency_rects = w.transparency_rects();",
          "new_line_content": "            auto& visible_opaque = w.opaque_rects();",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "is_empty",
          "new_api": "transparency_rects",
          "old_text": "window_frame_rect.is_empty()",
          "new_text": "w.transparency_rects()",
          "old_line_content": "            if (w.is_minimized() || window_frame_rect.is_empty()) {",
          "new_line_content": "            auto& transparency_rects = w.transparency_rects();",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "clear",
          "new_api": "is_empty",
          "old_text": "visible_opaque.clear()",
          "new_text": "window_frame_rect.is_empty()",
          "old_line_content": "                visible_opaque.clear();",
          "new_line_content": "            if (w.is_minimized() || window_frame_rect.is_empty()) {",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "intersected",
          "new_api": "is_opaque",
          "old_text": "visible_rects.intersected(window_frame_rect)",
          "new_text": "w.is_opaque()",
          "old_line_content": "                visible_opaque = visible_rects.intersected(window_frame_rect);",
          "new_line_content": "            if (w.is_opaque()) {",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "clear",
          "new_api": "intersected",
          "old_text": "transparency_rects.clear()",
          "new_text": "visible_rects.intersected(window_frame_rect)",
          "old_line_content": "                transparency_rects.clear();",
          "new_line_content": "                visible_opaque = visible_rects.intersected(window_frame_rect);",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": "intersected",
          "new_api": "clear",
          "old_text": "visible_rects.intersected(window_frame_rect)",
          "new_text": "visible_opaque.clear()",
          "old_line_content": "                transparency_rects = visible_rects.intersected(window_frame_rect);",
          "new_line_content": "                visible_opaque.clear();",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": "intersected",
          "new_api": "frame",
          "old_text": "window_frame_rect2.intersected(window_frame_rect)",
          "new_text": "w2.frame().rect().intersected(screen_rect)",
          "old_line_content": "                auto covering_rect = window_frame_rect2.intersected(window_frame_rect);",
          "new_line_content": "                auto window_frame_rect2 = w2.frame().rect().intersected(screen_rect);",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": "is_empty",
          "new_api": "intersected",
          "old_text": "covering_rect.is_empty()",
          "new_text": "window_frame_rect2.intersected(window_frame_rect)",
          "old_line_content": "                if (covering_rect.is_empty())",
          "new_line_content": "                auto covering_rect = window_frame_rect2.intersected(window_frame_rect);",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": "add",
          "new_api": "is_opaque",
          "old_text": "opaque_covering.add(covering_rect)",
          "new_text": "w2.is_opaque()",
          "old_line_content": "                    opaque_covering.add(covering_rect);",
          "new_line_content": "                if (w2.is_opaque()) {",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": "contains",
          "new_api": "add",
          "old_text": "opaque_covering.contains(window_frame_rect)",
          "new_text": "opaque_covering.add(covering_rect)",
          "old_line_content": "                    if (opaque_covering.contains(window_frame_rect)) {",
          "new_line_content": "                    opaque_covering.add(covering_rect);",
          "content_same": false
        },
        {
          "line": 973,
          "old_api": "shatter",
          "new_api": "is_empty",
          "old_text": "visible_opaque.shatter(covering_rect)",
          "new_text": "visible_opaque.is_empty()",
          "old_line_content": "                        auto uncovered_opaque = visible_opaque.shatter(covering_rect);",
          "new_line_content": "                    if (!visible_opaque.is_empty()) {",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": "move",
          "new_api": "shatter",
          "old_text": "move(uncovered_opaque)",
          "new_text": "visible_opaque.shatter(covering_rect)",
          "old_line_content": "                        visible_opaque = move(uncovered_opaque);",
          "new_line_content": "                        auto uncovered_opaque = visible_opaque.shatter(covering_rect);",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "shatter",
          "new_api": "is_empty",
          "old_text": "transparency_rects.shatter(covering_rect)",
          "new_text": "transparency_rects.is_empty()",
          "old_line_content": "                        auto uncovered_transparency = transparency_rects.shatter(covering_rect);",
          "new_line_content": "                    if (!transparency_rects.is_empty()) {",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": "move",
          "new_api": "shatter",
          "old_text": "move(uncovered_transparency)",
          "new_text": "transparency_rects.shatter(covering_rect)",
          "old_line_content": "                        transparency_rects = move(uncovered_transparency);",
          "new_line_content": "                        auto uncovered_transparency = transparency_rects.shatter(covering_rect);",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "add",
          "new_api": "for_each_intersected",
          "old_text": "transparency_rects.add(intersected)",
          "new_text": "visible_rects.for_each_intersected(covering_rect, [&](const Gfx::IntRect& intersected) {\n                        transparency_rects.add(intersected);\n                        if (!visible_opaque.is_empty()) {\n                            auto uncovered_opaque = visible_opaque.shatter(intersected);\n                            visible_opaque = move(uncovered_opaque);\n                        }\n                        return IterationDecision::Continue;\n                    })",
          "old_line_content": "                        transparency_rects.add(intersected);",
          "new_line_content": "                    visible_rects.for_each_intersected(covering_rect, [&](const Gfx::IntRect& intersected) {",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": "is_empty",
          "new_api": "add",
          "old_text": "visible_opaque.is_empty()",
          "new_text": "transparency_rects.add(intersected)",
          "old_line_content": "                        if (!visible_opaque.is_empty()) {",
          "new_line_content": "                        transparency_rects.add(intersected);",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": "shatter",
          "new_api": "is_empty",
          "old_text": "visible_opaque.shatter(intersected)",
          "new_text": "visible_opaque.is_empty()",
          "old_line_content": "                            auto uncovered_opaque = visible_opaque.shatter(intersected);",
          "new_line_content": "                        if (!visible_opaque.is_empty()) {",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": "move",
          "new_api": "shatter",
          "old_text": "move(uncovered_opaque)",
          "new_text": "visible_opaque.shatter(intersected)",
          "old_line_content": "                            visible_opaque = move(uncovered_opaque);",
          "new_line_content": "                            auto uncovered_opaque = visible_opaque.shatter(intersected);",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": "move",
          "new_api": "shatter",
          "old_text": "move(visible_rects_below_window)",
          "new_text": "visible_rects.shatter(window_frame_rect)",
          "old_line_content": "                visible_rects = move(visible_rects_below_window);",
          "new_line_content": "                auto visible_rects_below_window = visible_rects.shatter(window_frame_rect);",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": "transparency_wallpaper_rects",
          "new_api": "for_each_visible_window_from_back_to_front",
          "old_text": "w.transparency_wallpaper_rects()",
          "new_text": "WindowManager::the().for_each_visible_window_from_back_to_front([&](Window& w) {\n                auto& transparency_wallpaper_rects = w.transparency_wallpaper_rects();\n                if (w.is_opaque() || w.is_minimized()) {\n                    transparency_wallpaper_rects.clear();\n                    return IterationDecision::Continue;\n                }\n                Gfx::DisjointRectSet& transparency_rects = w.transparency_rects();\n                if (transparency_rects.is_empty()) {\n                    transparency_wallpaper_rects.clear();\n                    return IterationDecision::Continue;\n                }\n\n                transparency_wallpaper_rects = visible_rects.intersected(transparency_rects);\n\n                auto remaining_visible = visible_rects.shatter(transparency_wallpaper_rects);\n                visible_rects = move(remaining_visible);\n                return IterationDecision::Continue;\n            })",
          "old_line_content": "                auto& transparency_wallpaper_rects = w.transparency_wallpaper_rects();",
          "new_line_content": "            WindowManager::the().for_each_visible_window_from_back_to_front([&](Window& w) {",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "is_minimized",
          "new_api": "transparency_wallpaper_rects",
          "old_text": "w.is_minimized()",
          "new_text": "w.transparency_wallpaper_rects()",
          "old_line_content": "                if (w.is_opaque() || w.is_minimized()) {",
          "new_line_content": "                auto& transparency_wallpaper_rects = w.transparency_wallpaper_rects();",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "clear",
          "new_api": "is_minimized",
          "old_text": "transparency_wallpaper_rects.clear()",
          "new_text": "w.is_minimized()",
          "old_line_content": "                    transparency_wallpaper_rects.clear();",
          "new_line_content": "                if (w.is_opaque() || w.is_minimized()) {",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": "is_empty",
          "new_api": "transparency_rects",
          "old_text": "transparency_rects.is_empty()",
          "new_text": "w.transparency_rects()",
          "old_line_content": "                if (transparency_rects.is_empty()) {",
          "new_line_content": "                Gfx::DisjointRectSet& transparency_rects = w.transparency_rects();",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": "clear",
          "new_api": "is_empty",
          "old_text": "transparency_wallpaper_rects.clear()",
          "new_text": "transparency_rects.is_empty()",
          "old_line_content": "                    transparency_wallpaper_rects.clear();",
          "new_line_content": "                if (transparency_rects.is_empty()) {",
          "content_same": false
        },
        {
          "line": 1025,
          "old_api": "move",
          "new_api": "shatter",
          "old_text": "move(remaining_visible)",
          "new_text": "visible_rects.shatter(transparency_wallpaper_rects)",
          "old_line_content": "                visible_rects = move(remaining_visible);",
          "new_line_content": "                auto remaining_visible = visible_rects.shatter(transparency_wallpaper_rects);",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": "dbg",
          "new_api": "rects",
          "old_text": "dbg()",
          "new_text": "m_opaque_wallpaper_rects.rects()",
          "old_line_content": "        dbg() << \"  wallpaper opaque: \" << r;",
          "new_line_content": "    for (auto& r : m_opaque_wallpaper_rects.rects())",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": "frame",
          "new_api": "for_each_visible_window_from_back_to_front",
          "old_text": "w.frame().rect().intersected(screen_rect)",
          "new_text": "wm.for_each_visible_window_from_back_to_front([&](Window& w) {\n        auto window_frame_rect = w.frame().rect().intersected(screen_rect);\n        if (w.is_minimized() || window_frame_rect.is_empty())\n            return IterationDecision::Continue;\n\n#ifdef OCCLUSIONS_DEBUG\n        dbg() << \"  Window \" << w.title() << \" frame rect: \" << window_frame_rect;\n        for (auto& r : w.opaque_rects().rects())\n            dbg() << \"    opaque: \" << r;\n        for (auto& r : w.transparency_wallpaper_rects().rects())\n            dbg() << \"    transparent wallpaper: \" << r;\n        for (auto& r : w.transparency_rects().rects())\n            dbg() << \"    transparent: \" << r;\n#endif\n        ASSERT(!w.opaque_rects().intersects(m_opaque_wallpaper_rects));\n        ASSERT(!w.transparency_rects().intersects(m_opaque_wallpaper_rects));\n        ASSERT(!w.transparency_wallpaper_rects().intersects(m_opaque_wallpaper_rects));\n        return IterationDecision::Continue;\n    })",
          "old_line_content": "        auto window_frame_rect = w.frame().rect().intersected(screen_rect);",
          "new_line_content": "    wm.for_each_visible_window_from_back_to_front([&](Window& w) {",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": "is_empty",
          "new_api": "frame",
          "old_text": "window_frame_rect.is_empty()",
          "new_text": "w.frame().rect().intersected(screen_rect)",
          "old_line_content": "        if (w.is_minimized() || window_frame_rect.is_empty())",
          "new_line_content": "        auto window_frame_rect = w.frame().rect().intersected(screen_rect);",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": "opaque_rects",
          "new_api": "title",
          "old_text": "w.opaque_rects().rects()",
          "new_text": "w.title()",
          "old_line_content": "        for (auto& r : w.opaque_rects().rects())",
          "new_line_content": "        dbg() << \"  Window \" << w.title() << \" frame rect: \" << window_frame_rect;",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": "dbg",
          "new_api": "opaque_rects",
          "old_text": "dbg()",
          "new_text": "w.opaque_rects().rects()",
          "old_line_content": "            dbg() << \"    opaque: \" << r;",
          "new_line_content": "        for (auto& r : w.opaque_rects().rects())",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": "transparency_wallpaper_rects",
          "new_api": "dbg",
          "old_text": "w.transparency_wallpaper_rects().rects()",
          "new_text": "dbg()",
          "old_line_content": "        for (auto& r : w.transparency_wallpaper_rects().rects())",
          "new_line_content": "            dbg() << \"    opaque: \" << r;",
          "content_same": false
        },
        {
          "line": 1048,
          "old_api": "dbg",
          "new_api": "transparency_wallpaper_rects",
          "old_text": "dbg()",
          "new_text": "w.transparency_wallpaper_rects().rects()",
          "old_line_content": "            dbg() << \"    transparent wallpaper: \" << r;",
          "new_line_content": "        for (auto& r : w.transparency_wallpaper_rects().rects())",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": "transparency_rects",
          "new_api": "dbg",
          "old_text": "w.transparency_rects().rects()",
          "new_text": "dbg()",
          "old_line_content": "        for (auto& r : w.transparency_rects().rects())",
          "new_line_content": "            dbg() << \"    transparent wallpaper: \" << r;",
          "content_same": false
        },
        {
          "line": 1050,
          "old_api": "dbg",
          "new_api": "transparency_rects",
          "old_text": "dbg()",
          "new_text": "w.transparency_rects().rects()",
          "old_line_content": "            dbg() << \"    transparent: \" << r;",
          "new_line_content": "        for (auto& r : w.transparency_rects().rects())",
          "content_same": false
        },
        {
          "line": 1053,
          "old_api": "transparency_rects",
          "new_api": "opaque_rects",
          "old_text": "w.transparency_rects().intersects(m_opaque_wallpaper_rects)",
          "new_text": "w.opaque_rects().intersects(m_opaque_wallpaper_rects)",
          "old_line_content": "        ASSERT(!w.transparency_rects().intersects(m_opaque_wallpaper_rects));",
          "new_line_content": "        ASSERT(!w.opaque_rects().intersects(m_opaque_wallpaper_rects));",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": "transparency_wallpaper_rects",
          "new_api": "transparency_rects",
          "old_text": "w.transparency_wallpaper_rects().intersects(m_opaque_wallpaper_rects)",
          "new_text": "w.transparency_rects().intersects(m_opaque_wallpaper_rects)",
          "old_line_content": "        ASSERT(!w.transparency_wallpaper_rects().intersects(m_opaque_wallpaper_rects));",
          "new_line_content": "        ASSERT(!w.transparency_rects().intersects(m_opaque_wallpaper_rects));",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 897,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"OCCLUSIONS:\")",
          "old_line_content": "#endif",
          "new_line_content": "    dbgln(\"OCCLUSIONS:\");",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(remaining_visible)",
          "old_line_content": "                return IterationDecision::Continue;",
          "new_line_content": "                visible_rects = move(remaining_visible);",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": null,
          "new_api": "rect",
          "old_text": null,
          "new_text": "Screen::the().rect()",
          "old_line_content": "",
          "new_line_content": "    auto screen_rect = Screen::the().rect();",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "transparency_wallpaper_rects.clear()",
          "old_line_content": "                    return IterationDecision::Continue;",
          "new_line_content": "                    transparency_wallpaper_rects.clear();",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(visible_rects)",
          "old_line_content": "    }",
          "new_line_content": "        m_opaque_wallpaper_rects = move(visible_rects);",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": null,
          "new_api": "transparency_wallpaper_rects",
          "old_text": null,
          "new_text": "w.transparency_wallpaper_rects()",
          "old_line_content": "            if (&w == fullscreen_window) {",
          "new_line_content": "            auto& transparency_wallpaper_rects = w.transparency_wallpaper_rects();",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": null,
          "new_api": "is_opaque",
          "old_text": null,
          "new_text": "w.is_opaque()",
          "old_line_content": "                    visible_opaque = screen_rect;",
          "new_line_content": "                if (w.is_opaque()) {",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": null,
          "new_api": "dbg",
          "old_text": null,
          "new_text": "dbg()",
          "old_line_content": "#endif",
          "new_line_content": "        dbg() << \"  wallpaper opaque: \" << r;",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "transparency_wallpaper_rects.clear()",
          "old_line_content": "                } else {",
          "new_line_content": "                    transparency_wallpaper_rects.clear();",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "visible_opaque.clear()",
          "old_line_content": "                    transparency_rects = screen_rect;",
          "new_line_content": "                    visible_opaque.clear();",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "window_frame_rect.is_empty()",
          "old_line_content": "            return IterationDecision::Continue;",
          "new_line_content": "        if (w.is_minimized() || window_frame_rect.is_empty())",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "transparency_wallpaper_rects.clear()",
          "old_line_content": "            }",
          "new_line_content": "                transparency_wallpaper_rects.clear();",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": null,
          "new_api": "dbg",
          "old_text": null,
          "new_text": "dbg()",
          "old_line_content": "#endif",
          "new_line_content": "            dbg() << \"    transparent: \" << r;",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "m_opaque_wallpaper_rects.clear()",
          "old_line_content": "    } else {",
          "new_line_content": "        m_opaque_wallpaper_rects.clear();",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": null,
          "new_api": "transparency_wallpaper_rects",
          "old_text": null,
          "new_text": "w.transparency_wallpaper_rects().intersects(m_opaque_wallpaper_rects)",
          "old_line_content": "        return IterationDecision::Continue;",
          "new_line_content": "        ASSERT(!w.transparency_wallpaper_rects().intersects(m_opaque_wallpaper_rects));",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": null,
          "new_api": "make<Gfx::Painter>(*m_cursor_back_bitmap)",
          "old_text": null,
          "new_text": "make<Gfx::Painter>(*m_cursor_back_bitmap)",
          "old_line_content": "    }",
          "new_line_content": "        m_cursor_back_painter = make<Gfx::Painter>(*m_cursor_back_bitmap);",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "transparency_rects.clear()",
          "old_line_content": "                return IterationDecision::Continue;",
          "new_line_content": "                transparency_rects.clear();",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": null,
          "new_api": "active_cursor",
          "old_text": null,
          "new_text": "wm.active_cursor()",
          "old_line_content": "    // FIXME: Give Bitmap an intrinsic scale factor and make Painter::blit() do the right thing if both it and the passed bitmap have scale factors:",
          "new_line_content": "    auto& current_cursor = m_current_cursor ? *m_current_cursor : wm.active_cursor();",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": null,
          "new_api": "physical_rect",
          "old_text": null,
          "new_text": "Screen::the().physical_rect()",
          "old_line_content": "",
          "new_line_content": "    m_cursor_back_painter->blit({ 0, 0 }, *m_back_bitmap, (current_cursor.rect().translated(cursor_rect.location()) * Screen::the().scale_factor()).intersected(Screen::the().physical_rect()));",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "transparency_rects.clear()",
          "old_line_content": "            } else {",
          "new_line_content": "                transparency_rects.clear();",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "source_rect",
          "old_text": null,
          "new_text": "current_cursor.source_rect(m_current_cursor_frame)",
          "old_line_content": "",
          "new_line_content": "    m_back_painter->blit(cursor_rect.location(), current_cursor.bitmap(), current_cursor.source_rect(m_current_cursor_frame));",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": null,
          "new_api": "intersected",
          "old_text": null,
          "new_text": "visible_rects.intersected(window_frame_rect)",
          "old_line_content": "            }",
          "new_line_content": "                transparency_rects = visible_rects.intersected(window_frame_rect);",
          "content_same": false
        },
        {
          "line": 950,
          "old_api": null,
          "new_api": "for_each_visible_window_from_back_to_front",
          "old_text": null,
          "new_text": "WindowManager::the().for_each_visible_window_from_back_to_front([&](Window& w2) {\n                if (!found_this_window) {\n                    if (&w == &w2)\n                        found_this_window = true;\n                    return IterationDecision::Continue;\n                }\n\n                if (w2.is_minimized())\n                    return IterationDecision::Continue;\n                auto window_frame_rect2 = w2.frame().rect().intersected(screen_rect);\n                auto covering_rect = window_frame_rect2.intersected(window_frame_rect);\n                if (covering_rect.is_empty())\n                    return IterationDecision::Continue;\n\n                if (w2.is_opaque()) {\n                    opaque_covering.add(covering_rect);\n                    if (opaque_covering.contains(window_frame_rect)) {\n                        // This window is entirely covered by another opaque window\n                        visible_opaque.clear();\n                        transparency_rects.clear();\n                        return IterationDecision::Break;\n                    }\n\n                    if (!visible_opaque.is_empty()) {\n                        auto uncovered_opaque = visible_opaque.shatter(covering_rect);\n                        visible_opaque = move(uncovered_opaque);\n                    }\n\n                    if (!transparency_rects.is_empty()) {\n                        auto uncovered_transparency = transparency_rects.shatter(covering_rect);\n                        transparency_rects = move(uncovered_transparency);\n                    }\n                } else {\n                    visible_rects.for_each_intersected(covering_rect, [&](const Gfx::IntRect& intersected) {\n                        transparency_rects.add(intersected);\n                        if (!visible_opaque.is_empty()) {\n                            auto uncovered_opaque = visible_opaque.shatter(intersected);\n                            visible_opaque = move(uncovered_opaque);\n                        }\n                        return IterationDecision::Continue;\n                    });\n                }\n\n                return IterationDecision::Continue;\n            })",
          "old_line_content": "                if (!found_this_window) {",
          "new_line_content": "            WindowManager::the().for_each_visible_window_from_back_to_front([&](Window& w2) {",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": null,
          "new_api": "is_minimized",
          "old_text": null,
          "new_text": "w2.is_minimized()",
          "old_line_content": "                    return IterationDecision::Continue;",
          "new_line_content": "                if (w2.is_minimized())",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "last_physical_cursor_rect.size()",
          "old_line_content": "}",
          "new_line_content": "    unscaled_back_painter.blit(last_physical_cursor_rect.location(), *m_cursor_back_bitmap, { { 0, 0 }, last_physical_cursor_rect.size() });",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "covering_rect.is_empty()",
          "old_line_content": "                    return IterationDecision::Continue;",
          "new_line_content": "                if (covering_rect.is_empty())",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": null,
          "new_api": "notify_display_link",
          "old_text": null,
          "new_text": "client.notify_display_link({})",
          "old_line_content": "    });",
          "new_line_content": "        client.notify_display_link({});",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "opaque_covering.contains(window_frame_rect)",
          "old_line_content": "                        // This window is entirely covered by another opaque window",
          "new_line_content": "                    if (opaque_covering.contains(window_frame_rect)) {",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "transparency_rects.clear()",
          "old_line_content": "                        return IterationDecision::Break;",
          "new_line_content": "                        transparency_rects.clear();",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": null,
          "new_api": "start",
          "old_text": null,
          "new_text": "m_display_link_notify_timer->start()",
          "old_line_content": "}",
          "new_line_content": "        m_display_link_notify_timer->start();",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(uncovered_opaque)",
          "old_line_content": "                    }",
          "new_line_content": "                        visible_opaque = move(uncovered_opaque);",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": null,
          "new_api": "ASSERT",
          "old_text": null,
          "new_text": "ASSERT(m_display_link_count)",
          "old_line_content": "    --m_display_link_count;",
          "new_line_content": "    ASSERT(m_display_link_count);",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": null,
          "new_api": "stop",
          "old_text": null,
          "new_text": "m_display_link_notify_timer->stop()",
          "old_line_content": "}",
          "new_line_content": "        m_display_link_notify_timer->stop();",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(uncovered_transparency)",
          "old_line_content": "                    }",
          "new_line_content": "                        transparency_rects = move(uncovered_transparency);",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": null,
          "new_api": "for_each_visible_window_from_back_to_front",
          "old_text": null,
          "new_text": "WindowManager::the().for_each_visible_window_from_back_to_front([&](Window& window) {\n        if (&window == &a_window) {\n            checking = true;\n            return IterationDecision::Continue;\n        }\n        if (!checking)\n            return IterationDecision::Continue;\n        if (!window.is_visible())\n            return IterationDecision::Continue;\n        if (window.is_minimized())\n            return IterationDecision::Continue;\n        if (!window.is_opaque())\n            return IterationDecision::Continue;\n        if (window.frame().rect().contains(rect)) {\n            found_containing_window = true;\n            return IterationDecision::Break;\n        }\n        return IterationDecision::Continue;\n    })",
          "old_line_content": "        if (&window == &a_window) {",
          "new_line_content": "    WindowManager::the().for_each_visible_window_from_back_to_front([&](Window& window) {",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(uncovered_opaque)",
          "old_line_content": "                        }",
          "new_line_content": "                            visible_opaque = move(uncovered_opaque);",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": null,
          "new_api": "is_visible",
          "old_text": null,
          "new_text": "window.is_visible()",
          "old_line_content": "            return IterationDecision::Continue;",
          "new_line_content": "        if (!window.is_visible())",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": null,
          "new_api": "is_minimized",
          "old_text": null,
          "new_text": "window.is_minimized()",
          "old_line_content": "            return IterationDecision::Continue;",
          "new_line_content": "        if (window.is_minimized())",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "transparency_rects.is_empty()",
          "old_line_content": "                have_transparent = true;",
          "new_line_content": "            if (!transparency_rects.is_empty())",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": null,
          "new_api": "is_opaque",
          "old_text": null,
          "new_text": "window.is_opaque()",
          "old_line_content": "            return IterationDecision::Continue;",
          "new_line_content": "        if (!window.is_opaque())",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": null,
          "new_api": "intersects",
          "old_text": null,
          "new_text": "visible_opaque.intersects(transparency_rects)",
          "old_line_content": "",
          "new_line_content": "            ASSERT(!visible_opaque.intersects(transparency_rects));",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": null,
          "new_api": "frame",
          "old_text": null,
          "new_text": "window.frame().rect().contains(rect)",
          "old_line_content": "            found_containing_window = true;",
          "new_line_content": "        if (window.frame().rect().contains(rect)) {",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": null,
          "new_api": "is_opaque",
          "old_text": null,
          "new_text": "w.is_opaque()",
          "old_line_content": "                // Determine visible area for the window below",
          "new_line_content": "            if (w.is_opaque()) {",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(visible_rects_below_window)",
          "old_line_content": "            }",
          "new_line_content": "                visible_rects = move(visible_rects_below_window);",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": null,
          "new_api": "set_occluded",
          "old_text": null,
          "new_text": "window.set_occluded(false)",
          "old_line_content": "        } else {",
          "new_line_content": "            window.set_occluded(false);",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "transparency_wallpaper_rects.clear()",
          "old_line_content": "                    return IterationDecision::Continue;",
          "new_line_content": "                    transparency_wallpaper_rects.clear();",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": null,
          "new_api": "set_occluded",
          "old_text": null,
          "new_text": "window.set_occluded(true)",
          "old_line_content": "            else",
          "new_line_content": "                window.set_occluded(true);",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": null,
          "new_api": "set_occluded",
          "old_text": null,
          "new_text": "window.set_occluded(false)",
          "old_line_content": "        }",
          "new_line_content": "                window.set_occluded(false);",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": null,
          "new_api": "intersected",
          "old_text": null,
          "new_text": "visible_rects.intersected(transparency_rects)",
          "old_line_content": "",
          "new_line_content": "                transparency_wallpaper_rects = visible_rects.intersected(transparency_rects);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 896,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"OCCLUSIONS:\")",
          "new_text": null,
          "old_line_content": "    dbgln(\"OCCLUSIONS:\");",
          "new_line_content": "#ifdef OCCLUSIONS_DEBUG",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": "shatter",
          "new_api": null,
          "old_text": "visible_rects.shatter(transparency_wallpaper_rects)",
          "new_text": null,
          "old_line_content": "                auto remaining_visible = visible_rects.shatter(transparency_wallpaper_rects);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": "rect",
          "new_api": null,
          "old_text": "Screen::the().rect()",
          "new_text": null,
          "old_line_content": "    auto screen_rect = Screen::the().rect();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": "active_fullscreen_window",
          "new_api": null,
          "old_text": "wm.active_fullscreen_window()",
          "new_text": null,
          "old_line_content": "    if (auto* fullscreen_window = wm.active_fullscreen_window()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": "move",
          "new_api": null,
          "old_text": "move(visible_rects)",
          "new_text": null,
          "old_line_content": "        m_opaque_wallpaper_rects = move(visible_rects);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": "rects",
          "new_api": null,
          "old_text": "m_opaque_wallpaper_rects.rects()",
          "new_text": null,
          "old_line_content": "    for (auto& r : m_opaque_wallpaper_rects.rects())",
          "new_line_content": "#ifdef OCCLUSIONS_DEBUG",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "is_opaque",
          "new_api": null,
          "old_text": "w.is_opaque()",
          "new_text": null,
          "old_line_content": "                if (w.is_opaque()) {",
          "new_line_content": "            if (&w == fullscreen_window) {",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": "clear",
          "new_api": null,
          "old_text": "transparency_rects.clear()",
          "new_text": null,
          "old_line_content": "                    transparency_rects.clear();",
          "new_line_content": "                    visible_opaque = screen_rect;",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "for_each_visible_window_from_back_to_front",
          "new_api": null,
          "old_text": "wm.for_each_visible_window_from_back_to_front([&](Window& w) {\n        auto window_frame_rect = w.frame().rect().intersected(screen_rect);\n        if (w.is_minimized() || window_frame_rect.is_empty())\n            return IterationDecision::Continue;\n\n#ifdef OCCLUSIONS_DEBUG\n        dbg() << \"  Window \" << w.title() << \" frame rect: \" << window_frame_rect;\n        for (auto& r : w.opaque_rects().rects())\n            dbg() << \"    opaque: \" << r;\n        for (auto& r : w.transparency_wallpaper_rects().rects())\n            dbg() << \"    transparent wallpaper: \" << r;\n        for (auto& r : w.transparency_rects().rects())\n            dbg() << \"    transparent: \" << r;\n#endif\n        ASSERT(!w.opaque_rects().intersects(m_opaque_wallpaper_rects));\n        ASSERT(!w.transparency_rects().intersects(m_opaque_wallpaper_rects));\n        ASSERT(!w.transparency_wallpaper_rects().intersects(m_opaque_wallpaper_rects));\n        return IterationDecision::Continue;\n    })",
          "new_text": null,
          "old_line_content": "    wm.for_each_visible_window_from_back_to_front([&](Window& w) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": "clear",
          "new_api": null,
          "old_text": "visible_opaque.clear()",
          "new_text": null,
          "old_line_content": "                    visible_opaque.clear();",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": "title",
          "new_api": null,
          "old_text": "w.title()",
          "new_text": null,
          "old_line_content": "        dbg() << \"  Window \" << w.title() << \" frame rect: \" << window_frame_rect;",
          "new_line_content": "#ifdef OCCLUSIONS_DEBUG",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": "clear",
          "new_api": null,
          "old_text": "visible_opaque.clear()",
          "new_text": null,
          "old_line_content": "                visible_opaque.clear();",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": "clear",
          "new_api": null,
          "old_text": "m_opaque_wallpaper_rects.clear()",
          "new_text": null,
          "old_line_content": "        m_opaque_wallpaper_rects.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": "opaque_rects",
          "new_api": null,
          "old_text": "w.opaque_rects().intersects(m_opaque_wallpaper_rects)",
          "new_text": null,
          "old_line_content": "        ASSERT(!w.opaque_rects().intersects(m_opaque_wallpaper_rects));",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": "for_each_visible_window_from_front_to_back",
          "new_api": null,
          "old_text": "WindowManager::the().for_each_visible_window_from_front_to_back([&](Window& w) {\n            auto window_frame_rect = w.frame().rect().intersected(screen_rect);\n            w.transparency_wallpaper_rects().clear();\n            auto& visible_opaque = w.opaque_rects();\n            auto& transparency_rects = w.transparency_rects();\n            if (w.is_minimized() || window_frame_rect.is_empty()) {\n                visible_opaque.clear();\n                transparency_rects.clear();\n                return IterationDecision::Continue;\n            }\n\n            Gfx::DisjointRectSet opaque_covering;\n            if (w.is_opaque()) {\n                visible_opaque = visible_rects.intersected(window_frame_rect);\n                transparency_rects.clear();\n            } else {\n                visible_opaque.clear();\n                transparency_rects = visible_rects.intersected(window_frame_rect);\n            }\n\n            bool found_this_window = false;\n            WindowManager::the().for_each_visible_window_from_back_to_front([&](Window& w2) {\n                if (!found_this_window) {\n                    if (&w == &w2)\n                        found_this_window = true;\n                    return IterationDecision::Continue;\n                }\n\n                if (w2.is_minimized())\n                    return IterationDecision::Continue;\n                auto window_frame_rect2 = w2.frame().rect().intersected(screen_rect);\n                auto covering_rect = window_frame_rect2.intersected(window_frame_rect);\n                if (covering_rect.is_empty())\n                    return IterationDecision::Continue;\n\n                if (w2.is_opaque()) {\n                    opaque_covering.add(covering_rect);\n                    if (opaque_covering.contains(window_frame_rect)) {\n                        // This window is entirely covered by another opaque window\n                        visible_opaque.clear();\n                        transparency_rects.clear();\n                        return IterationDecision::Break;\n                    }\n\n                    if (!visible_opaque.is_empty()) {\n                        auto uncovered_opaque = visible_opaque.shatter(covering_rect);\n                        visible_opaque = move(uncovered_opaque);\n                    }\n\n                    if (!transparency_rects.is_empty()) {\n                        auto uncovered_transparency = transparency_rects.shatter(covering_rect);\n                        transparency_rects = move(uncovered_transparency);\n                    }\n                } else {\n                    visible_rects.for_each_intersected(covering_rect, [&](const Gfx::IntRect& intersected) {\n                        transparency_rects.add(intersected);\n                        if (!visible_opaque.is_empty()) {\n                            auto uncovered_opaque = visible_opaque.shatter(intersected);\n                            visible_opaque = move(uncovered_opaque);\n                        }\n                        return IterationDecision::Continue;\n                    });\n                }\n\n                return IterationDecision::Continue;\n            });\n\n            if (!transparency_rects.is_empty())\n                have_transparent = true;\n\n            ASSERT(!visible_opaque.intersects(transparency_rects));\n\n            if (w.is_opaque()) {\n                // Determine visible area for the window below\n                auto visible_rects_below_window = visible_rects.shatter(window_frame_rect);\n                visible_rects = move(visible_rects_below_window);\n            }\n            return IterationDecision::Continue;\n        })",
          "new_text": null,
          "old_line_content": "        WindowManager::the().for_each_visible_window_from_front_to_back([&](Window& w) {",
          "new_line_content": "        bool have_transparent = false;",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": "active_cursor",
          "new_api": null,
          "old_text": "wm.active_cursor()",
          "new_text": null,
          "old_line_content": "    auto& current_cursor = m_current_cursor ? *m_current_cursor : wm.active_cursor();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "is_opaque",
          "new_api": null,
          "old_text": "w.is_opaque()",
          "new_text": null,
          "old_line_content": "            if (w.is_opaque()) {",
          "new_line_content": "            Gfx::DisjointRectSet opaque_covering;",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "physical_rect",
          "new_api": null,
          "old_text": "Screen::the().physical_rect()",
          "new_text": null,
          "old_line_content": "    m_cursor_back_painter->blit({ 0, 0 }, *m_back_bitmap, (current_cursor.rect().translated(cursor_rect.location()) * Screen::the().scale_factor()).intersected(Screen::the().physical_rect()));",
          "new_line_content": "    // If a 2x scaled bitmap is blitted on a 2x scaled painter, it should be blitted without scale.",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "source_rect",
          "new_api": null,
          "old_text": "current_cursor.source_rect(m_current_cursor_frame)",
          "new_text": null,
          "old_line_content": "    m_back_painter->blit(cursor_rect.location(), current_cursor.bitmap(), current_cursor.source_rect(m_current_cursor_frame));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "clear",
          "new_api": null,
          "old_text": "visible_opaque.clear()",
          "new_text": null,
          "old_line_content": "                visible_opaque.clear();",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": "for_each_visible_window_from_back_to_front",
          "new_api": null,
          "old_text": "WindowManager::the().for_each_visible_window_from_back_to_front([&](Window& w2) {\n                if (!found_this_window) {\n                    if (&w == &w2)\n                        found_this_window = true;\n                    return IterationDecision::Continue;\n                }\n\n                if (w2.is_minimized())\n                    return IterationDecision::Continue;\n                auto window_frame_rect2 = w2.frame().rect().intersected(screen_rect);\n                auto covering_rect = window_frame_rect2.intersected(window_frame_rect);\n                if (covering_rect.is_empty())\n                    return IterationDecision::Continue;\n\n                if (w2.is_opaque()) {\n                    opaque_covering.add(covering_rect);\n                    if (opaque_covering.contains(window_frame_rect)) {\n                        // This window is entirely covered by another opaque window\n                        visible_opaque.clear();\n                        transparency_rects.clear();\n                        return IterationDecision::Break;\n                    }\n\n                    if (!visible_opaque.is_empty()) {\n                        auto uncovered_opaque = visible_opaque.shatter(covering_rect);\n                        visible_opaque = move(uncovered_opaque);\n                    }\n\n                    if (!transparency_rects.is_empty()) {\n                        auto uncovered_transparency = transparency_rects.shatter(covering_rect);\n                        transparency_rects = move(uncovered_transparency);\n                    }\n                } else {\n                    visible_rects.for_each_intersected(covering_rect, [&](const Gfx::IntRect& intersected) {\n                        transparency_rects.add(intersected);\n                        if (!visible_opaque.is_empty()) {\n                            auto uncovered_opaque = visible_opaque.shatter(intersected);\n                            visible_opaque = move(uncovered_opaque);\n                        }\n                        return IterationDecision::Continue;\n                    });\n                }\n\n                return IterationDecision::Continue;\n            })",
          "new_text": null,
          "old_line_content": "            WindowManager::the().for_each_visible_window_from_back_to_front([&](Window& w2) {",
          "new_line_content": "            bool found_this_window = false;",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": "physical_rect",
          "new_api": null,
          "old_text": "Screen::the().physical_rect()",
          "new_text": null,
          "old_line_content": "    auto last_physical_cursor_rect = (m_last_cursor_rect * Screen::the().scale_factor()).intersected(Screen::the().physical_rect());",
          "new_line_content": "    Gfx::Painter unscaled_back_painter(*m_back_bitmap);",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "is_minimized",
          "new_api": null,
          "old_text": "w2.is_minimized()",
          "new_text": null,
          "old_line_content": "                if (w2.is_minimized())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": "frame",
          "new_api": null,
          "old_text": "w2.frame().rect().intersected(screen_rect)",
          "new_text": null,
          "old_line_content": "                auto window_frame_rect2 = w2.frame().rect().intersected(screen_rect);",
          "new_line_content": "                    return IterationDecision::Continue;",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": "notify_display_link",
          "new_api": null,
          "old_text": "ClientConnection::for_each_client([](auto& client) {\n        client.notify_display_link({});\n    })",
          "new_text": null,
          "old_line_content": "    ClientConnection::for_each_client([](auto& client) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": "is_opaque",
          "new_api": null,
          "old_text": "w2.is_opaque()",
          "new_text": null,
          "old_line_content": "                if (w2.is_opaque()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": "clear",
          "new_api": null,
          "old_text": "visible_opaque.clear()",
          "new_text": null,
          "old_line_content": "                        visible_opaque.clear();",
          "new_line_content": "                        // This window is entirely covered by another opaque window",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": "start",
          "new_api": null,
          "old_text": "m_display_link_notify_timer->start()",
          "new_text": null,
          "old_line_content": "        m_display_link_notify_timer->start();",
          "new_line_content": "    if (m_display_link_count == 1)",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "visible_opaque.is_empty()",
          "new_text": null,
          "old_line_content": "                    if (!visible_opaque.is_empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": "ASSERT",
          "new_api": null,
          "old_text": "ASSERT(m_display_link_count)",
          "new_text": null,
          "old_line_content": "    ASSERT(m_display_link_count);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "transparency_rects.is_empty()",
          "new_text": null,
          "old_line_content": "                    if (!transparency_rects.is_empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": "stop",
          "new_api": null,
          "old_text": "m_display_link_notify_timer->stop()",
          "new_text": null,
          "old_line_content": "        m_display_link_notify_timer->stop();",
          "new_line_content": "    if (!m_display_link_count)",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "for_each_intersected",
          "new_api": null,
          "old_text": "visible_rects.for_each_intersected(covering_rect, [&](const Gfx::IntRect& intersected) {\n                        transparency_rects.add(intersected);\n                        if (!visible_opaque.is_empty()) {\n                            auto uncovered_opaque = visible_opaque.shatter(intersected);\n                            visible_opaque = move(uncovered_opaque);\n                        }\n                        return IterationDecision::Continue;\n                    })",
          "new_text": null,
          "old_line_content": "                    visible_rects.for_each_intersected(covering_rect, [&](const Gfx::IntRect& intersected) {",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "for_each_visible_window_from_back_to_front",
          "new_api": null,
          "old_text": "WindowManager::the().for_each_visible_window_from_back_to_front([&](Window& window) {\n        if (&window == &a_window) {\n            checking = true;\n            return IterationDecision::Continue;\n        }\n        if (!checking)\n            return IterationDecision::Continue;\n        if (!window.is_visible())\n            return IterationDecision::Continue;\n        if (window.is_minimized())\n            return IterationDecision::Continue;\n        if (!window.is_opaque())\n            return IterationDecision::Continue;\n        if (window.frame().rect().contains(rect)) {\n            found_containing_window = true;\n            return IterationDecision::Break;\n        }\n        return IterationDecision::Continue;\n    })",
          "new_text": null,
          "old_line_content": "    WindowManager::the().for_each_visible_window_from_back_to_front([&](Window& window) {",
          "new_line_content": "    bool checking = false;",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "is_visible",
          "new_api": null,
          "old_text": "window.is_visible()",
          "new_text": null,
          "old_line_content": "        if (!window.is_visible())",
          "new_line_content": "            return IterationDecision::Continue;",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "is_minimized",
          "new_api": null,
          "old_text": "window.is_minimized()",
          "new_text": null,
          "old_line_content": "        if (window.is_minimized())",
          "new_line_content": "            return IterationDecision::Continue;",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "transparency_rects.is_empty()",
          "new_text": null,
          "old_line_content": "            if (!transparency_rects.is_empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": "is_opaque",
          "new_api": null,
          "old_text": "window.is_opaque()",
          "new_text": null,
          "old_line_content": "        if (!window.is_opaque())",
          "new_line_content": "            return IterationDecision::Continue;",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": "intersects",
          "new_api": null,
          "old_text": "visible_opaque.intersects(transparency_rects)",
          "new_text": null,
          "old_line_content": "            ASSERT(!visible_opaque.intersects(transparency_rects));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": "frame",
          "new_api": null,
          "old_text": "window.frame().rect().contains(rect)",
          "new_text": null,
          "old_line_content": "        if (window.frame().rect().contains(rect)) {",
          "new_line_content": "            return IterationDecision::Continue;",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": "is_opaque",
          "new_api": null,
          "old_text": "w.is_opaque()",
          "new_text": null,
          "old_line_content": "            if (w.is_opaque()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": "shatter",
          "new_api": null,
          "old_text": "visible_rects.shatter(window_frame_rect)",
          "new_text": null,
          "old_line_content": "                auto visible_rects_below_window = visible_rects.shatter(window_frame_rect);",
          "new_line_content": "                // Determine visible area for the window below",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "WindowManager::the()",
          "new_api": null,
          "old_text": "WindowManager::the()",
          "new_text": null,
          "old_line_content": "    auto& wm = WindowManager::the();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": "for_each_visible_window_from_back_to_front",
          "new_api": null,
          "old_text": "WindowManager::the().for_each_visible_window_from_back_to_front([&](Window& w) {\n                auto& transparency_wallpaper_rects = w.transparency_wallpaper_rects();\n                if (w.is_opaque() || w.is_minimized()) {\n                    transparency_wallpaper_rects.clear();\n                    return IterationDecision::Continue;\n                }\n                Gfx::DisjointRectSet& transparency_rects = w.transparency_rects();\n                if (transparency_rects.is_empty()) {\n                    transparency_wallpaper_rects.clear();\n                    return IterationDecision::Continue;\n                }\n\n                transparency_wallpaper_rects = visible_rects.intersected(transparency_rects);\n\n                auto remaining_visible = visible_rects.shatter(transparency_wallpaper_rects);\n                visible_rects = move(remaining_visible);\n                return IterationDecision::Continue;\n            })",
          "new_text": null,
          "old_line_content": "            WindowManager::the().for_each_visible_window_from_back_to_front([&](Window& w) {",
          "new_line_content": "            // Determine what transparent window areas need to render the wallpaper first",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "frame",
          "new_api": null,
          "old_text": "window.frame().rect()",
          "new_text": null,
          "old_line_content": "            if (any_opaque_window_above_this_one_contains_rect(window, window.frame().rect()))",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": "transparency_rects",
          "new_api": null,
          "old_text": "w.transparency_rects()",
          "new_text": null,
          "old_line_content": "                Gfx::DisjointRectSet& transparency_rects = w.transparency_rects();",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": "set_occluded",
          "new_api": null,
          "old_text": "window.set_occluded(false)",
          "new_text": null,
          "old_line_content": "                window.set_occluded(false);",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": "intersected",
          "new_api": null,
          "old_text": "visible_rects.intersected(transparency_rects)",
          "new_text": null,
          "old_line_content": "                transparency_wallpaper_rects = visible_rects.intersected(transparency_rects);",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 51,
      "total_additions": 49,
      "total_deletions": 48,
      "total_api_changes": 148
    },
    "non_api_changes": {
      "has_non_api_changes": false,
      "evidence": {
        "total_diff_lines": 3,
        "api_related_lines": 148,
        "non_api_lines": 0,
        "non_api_line_numbers": []
      }
    },
    "api_calls_before": 610,
    "api_calls_after": 609,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 2,
      "total_diff_lines": 17
    }
  }
}