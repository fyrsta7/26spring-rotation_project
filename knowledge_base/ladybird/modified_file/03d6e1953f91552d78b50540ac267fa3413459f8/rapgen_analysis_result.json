{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/03d6e1953f91552d78b50540ac267fa3413459f8",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/03d6e1953f91552d78b50540ac267fa3413459f8/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/03d6e1953f91552d78b50540ac267fa3413459f8/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/03d6e1953f91552d78b50540ac267fa3413459f8/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 179,
          "old_api": "set_needs_style_update",
          "new_api": "has_children",
          "old_text": "for_each_in_inclusive_subtree_of_type<Element>([&](auto& element) {\n        element.set_needs_style_update(true);\n        return IterationDecision::Continue;\n    })",
          "new_text": "for_each_in_inclusive_subtree([&](Node& node) {\n        node.m_needs_style_update = true;\n        if (node.has_children())\n            node.m_child_needs_style_update = true;\n        if (auto* shadow_root = node.is_element() ? static_cast<DOM::Element&>(node).shadow_root() : nullptr) {\n            shadow_root->m_needs_style_update = true;\n            if (shadow_root->has_children())\n                shadow_root->m_child_needs_style_update = true;\n        }\n        return IterationDecision::Continue;\n    })",
          "old_line_content": "    for_each_in_inclusive_subtree_of_type<Element>([&](auto& element) {",
          "new_line_content": "    for_each_in_inclusive_subtree([&](Node& node) {",
          "content_same": false
        },
        {
          "line": 183,
          "old_api": "schedule_style_update",
          "new_api": "shadow_root",
          "old_text": "document().schedule_style_update()",
          "new_text": "static_cast<DOM::Element&>(node).shadow_root()",
          "old_line_content": "    document().schedule_style_update();",
          "new_line_content": "        if (auto* shadow_root = node.is_element() ? static_cast<DOM::Element&>(node).shadow_root() : nullptr) {",
          "content_same": false
        },
        {
          "line": 209,
          "old_api": "parent",
          "new_api": "for_each_child",
          "old_text": "root->parent()",
          "new_text": "verify_cast<ParentNode>(*this).for_each_child([&](auto& child) {\n        if (is<Text>(child))\n            builder.append(verify_cast<Text>(child).text_content());\n    })",
          "old_line_content": "        root = root->parent();",
          "new_line_content": "    verify_cast<ParentNode>(*this).for_each_child([&](auto& child) {",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": "parent",
          "new_api": "host",
          "old_text": "parent()",
          "new_text": "verify_cast<ShadowRoot>(node_root).host()->shadow_including_root()",
          "old_line_content": "    if (!parent() || !is<Element>(parent()))",
          "new_line_content": "        return verify_cast<ShadowRoot>(node_root).host()->shadow_including_root();",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": "parent",
          "new_api": "is_document",
          "old_text": "parent()",
          "new_text": "shadow_including_root().is_document()",
          "old_line_content": "    if (!parent() || !is<Element>(parent()))",
          "new_line_content": "    return shadow_including_root().is_document();",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": "DOM::HierarchyRequestError::create(\"New node is an ancestor of this node\")",
          "new_api": "parent",
          "old_text": "DOM::HierarchyRequestError::create(\"New node is an ancestor of this node\")",
          "new_text": "parent()",
          "old_line_content": "        return DOM::HierarchyRequestError::create(\"New node is an ancestor of this node\");",
          "new_line_content": "    if (!parent() || !is<Element>(parent()))",
          "content_same": false
        },
        {
          "line": 257,
          "old_api": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "new_api": "is<Element>(this)",
          "old_text": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "new_text": "is<Element>(this)",
          "old_line_content": "        return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "new_line_content": "    if (!is<Document>(this) && !is<DocumentFragment>(this) && !is<Element>(this))",
          "content_same": false
        },
        {
          "line": 260,
          "old_api": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "new_api": "is_host_including_inclusive_ancestor_of",
          "old_text": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "new_text": "node->is_host_including_inclusive_ancestor_of(*this)",
          "old_line_content": "        return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "new_line_content": "    if (node->is_host_including_inclusive_ancestor_of(*this))",
          "content_same": false
        },
        {
          "line": 263,
          "old_api": "is<DocumentFragment>(*node)",
          "new_api": "parent",
          "old_text": "is<DocumentFragment>(*node)",
          "new_text": "child->parent()",
          "old_line_content": "        if (is<DocumentFragment>(*node)) {",
          "new_line_content": "    if (child && child->parent() != this)",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": "child_element_count",
          "new_api": "DOM::NotFoundError::create(\"This node is not the parent of the given child\")",
          "old_text": "verify_cast<DocumentFragment>(*node).child_element_count()",
          "new_text": "DOM::NotFoundError::create(\"This node is not the parent of the given child\")",
          "old_line_content": "            auto node_element_child_count = verify_cast<DocumentFragment>(*node).child_element_count();",
          "new_line_content": "        return DOM::NotFoundError::create(\"This node is not the parent of the given child\");",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": "is<Element>(*node)",
          "new_api": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "old_text": "is<Element>(*node)",
          "new_text": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "old_line_content": "        } else if (is<Element>(*node)) {",
          "new_line_content": "        return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "new_api": "is<Document>(this)",
          "old_text": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "new_text": "is<Document>(this)",
          "old_line_content": "                return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "new_line_content": "    if ((is<Text>(*node) && is<Document>(this)) || (is<DocumentType>(*node) && !is<Document>(this)))",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "is<DocumentType>(*node)",
          "new_api": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "old_text": "is<DocumentType>(*node)",
          "new_text": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "old_line_content": "        } else if (is<DocumentType>(*node)) {",
          "new_line_content": "        return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "new_api": "is<Document>(this)",
          "old_text": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "new_text": "is<Document>(this)",
          "old_line_content": "                return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "new_line_content": "    if (is<Document>(this)) {",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": "is<DocumentFragment>(*node)",
          "new_api": "has_child_of_type<Element>()",
          "old_text": "is<DocumentFragment>(*node)",
          "new_text": "has_child_of_type<Element>()",
          "old_line_content": "    if (is<DocumentFragment>(*node))",
          "new_line_content": "            if (has_child_of_type<DocumentType>() || (child && child->has_preceding_node_of_type_in_tree_order<Element>()) || (!child && has_child_of_type<Element>()))",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": "children_as_vector",
          "new_api": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "old_text": "verify_cast<DocumentFragment>(*node).children_as_vector()",
          "new_text": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "old_line_content": "        nodes = verify_cast<DocumentFragment>(*node).children_as_vector();",
          "new_line_content": "                return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": "adopt_node",
          "new_api": "remove_all_children",
          "old_text": ".adopt_node(node_to_insert);\n\n       ",
          "new_text": "node->remove_all_children(true)",
          "old_line_content": "        document().adopt_node(node_to_insert);",
          "new_line_content": "        node->remove_all_children(true);",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": "for_each_in_inclusive_subtree",
          "new_api": "adopt_node",
          "old_text": ".for_each_in_inclusive_subtree([&](Node& inclusive_descendant) {\n            inclusive_descendant.inserted();\n            if (inclusive_descendant.is_connected()) {\n                // FIXME: If inclusiveDescendant is custom, then enqueue a custom element callback reaction with inclusiveDescendant,\n                //        callback name \"connectedCallback\", and an empty argument list.\n\n                // FIXME: Otherwise, try to upgrade inclusiveDescendant.\n            }\n\n            return IterationDecision::Continue;\n        });\n    }\n\n    i",
          "new_text": ".adopt_node(node_to_insert);\n\n       ",
          "old_line_content": "        node_to_insert.for_each_in_inclusive_subtree([&](Node& inclusive_descendant) {",
          "new_line_content": "        document().adopt_node(node_to_insert);",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": "ng",
          "new_api": "idate_style",
          "old_text": "ng();\n\n    insert_be",
          "new_text": "idate_style();\n}\n\n// https://",
          "old_line_content": "        reference_child = node->next_sibling();",
          "new_line_content": "    document().invalidate_style();",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": "removing_steps",
          "new_api": "parent",
          "old_text": "removing_steps(*this);\n    });\n\n    // FIXM",
          "new_text": "parent();\n    VERIFY(par",
          "old_line_content": "        node_iterator.run_pre_removing_steps(*this);",
          "new_line_content": "    auto* parent = TreeNode<Node>::parent();",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": "invalidate_style",
          "new_api": "// FIXME: If descendant",
          "old_text": "ent().invalidate_style();\n",
          "new_text": "\n        // FIXME: If descendant",
          "old_line_content": "    parent->children_changed();",
          "new_line_content": "        descendant.removed_from(nullptr);",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": "stor_of",
          "new_api": "invalidate_style",
          "old_text": "stor_of(*this))\n        return DOM::HierarchyRequest",
          "new_text": "ent().invalidate_style();\n",
          "old_line_content": "    if (node->is_host_including_inclusive_ancestor_of(*this))",
          "new_line_content": "    parent->children_changed();",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": "valid node type for insertion\");\n\n    if ((is<Text>(*node) && is<Docu",
          "new_api": ":HierarchyRequest",
          "old_text": "valid node type for insertion\");\n\n    if ((is<Text>(*node) && is<Docu",
          "new_text": ":HierarchyRequest",
          "old_line_content": "        return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "new_line_content": "    if (!is<Document>(this) && !is<DocumentFragment>(this) && !is<Element>(this))",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": "valid node type for insertion\");\n\n    if (is<Document>(this)) {",
          "new_api": "stor_of",
          "old_text": "valid node type for insertion\");\n\n    if (is<Document>(this)) {\n     ",
          "new_text": "stor_of(*this))\n        return DOM::HierarchyRequest",
          "old_line_content": "        return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "new_line_content": "    if (node->is_host_including_inclusive_ancestor_of(*this))",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": "auto node_element_chil",
          "new_api": "n DOM::NotFound",
          "old_text": "     auto node_element_chil",
          "new_text": "n DOM::NotFound",
          "old_line_content": "        if (is<DocumentFragment>(*node)) {",
          "new_line_content": "    if (child->parent() != this)",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "hild_element_count",
          "new_api": "is not the parent of the given child\");\n\n    // FIXME: All the following \"In",
          "old_text": "hild_element_count();\n            if ((node_element_child_",
          "new_text": "is not the parent of the given child\");\n\n    // FIXME: All the following \"In",
          "old_line_content": "            auto node_element_child_count = verify_cast<DocumentFragment>(*node).child_element_count();",
          "new_line_content": "        return DOM::NotFoundError::create(\"This node is not the parent of the given child\");",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": "first_child_of_typ",
          "new_api": "valid node type for insertion\");\n\n    if ((is<Text>(*node) && is<Docu",
          "old_text": "first_child_of_typ",
          "new_text": "valid node type for insertion\");\n\n    if ((is<Text>(*node) && is<Docu",
          "old_line_content": "        } else if (is<Element>(*node)) {",
          "new_line_content": "        return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "valid node type for insertion\");\n        } else if (is<DocumentType>(",
          "new_api": "M::HierarchyReques",
          "old_text": "valid node type for insertion\");\n        } else if (is<DocumentType>(",
          "new_text": "M::HierarchyReques",
          "old_line_content": "                return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "new_line_content": "    if ((is<Text>(*node) && is<Document>(this)) || (is<DocumentType>(*node) && !is<Document>(this)))",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "if (first_child_of_typ",
          "new_api": "valid node type for insertion\");\n\n    if (is<Document>(this)) {",
          "old_text": " if (first_child_of_typ",
          "new_text": "valid node type for insertion\");\n\n    if (is<Document>(this)) {\n     ",
          "old_line_content": "        } else if (is<DocumentType>(*node)) {",
          "new_line_content": "        return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "valid node type for insertion\");\n        }\n    }\n\n    auto reference_",
          "new_api": "ocumentFragment>(*",
          "old_text": "valid node type for insertion\");\n        }\n    }\n\n    auto reference_",
          "new_text": "ocumentFragment>(*",
          "old_line_content": "                return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "new_line_content": "    if (is<Document>(this)) {",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": "ce_child == node)",
          "new_api": "ree_order<DocumentType>()))) {\n                return DOM::Hier",
          "old_text": "ce_child == node)\n   ",
          "new_text": "ree_order<DocumentType>()))) {\n                return DOM::Hier",
          "old_line_content": "    auto reference_child = child->next_sibling();",
          "new_line_content": "                || (node_element_child_count == 1 && (first_child_of_type<Element>() != child || child->has_following_node_of_type_in_tree_order<DocumentType>()))) {",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": "removedNodes t",
          "new_api": "ree_order<Element>())\n                return DOM::Hierarch",
          "old_text": " removedNodes t",
          "new_text": "ree_order<Element>())\n                return DOM::Hierarch",
          "old_line_content": "    if (child->parent()) {",
          "new_line_content": "            if (first_child_of_type<DocumentType>() != node || child->has_preceding_node_of_type_in_tree_order<Element>())",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "// FIXME: Queue a tree mutation record",
          "new_api": "et previousSibling b",
          "old_text": "   // FIXME: Queue a tree mutation record ",
          "new_text": "et previousSibling b",
          "old_line_content": "    insert_before(node, reference_child, true);",
          "new_line_content": "        reference_child = node->next_sibling();",
          "content_same": false
        },
        {
          "line": 512,
          "old_api": "uirks_mode",
          "new_api": "verify_cast<Eleme",
          "old_text": "uirks_mode(document",
          "new_text": "verify_cast<Eleme",
          "old_line_content": "        document_copy->set_origin(document_->origin());",
          "new_line_content": "    if (is<Element>(this)) {",
          "content_same": false
        },
        {
          "line": 513,
          "old_api": "ml\" or \"html\")",
          "new_api": "nt_copy = DOM::create_elem",
          "old_text": "ml\" or \"html\")\n  ",
          "new_text": "nt_copy = DOM::create_elem",
          "old_line_content": "        document_copy->set_quirks_mode(document_->mode());",
          "new_line_content": "        auto& element = *verify_cast<Element>(this);",
          "content_same": false
        },
        {
          "line": 515,
          "old_api": "e>(this)) {",
          "new_api": "set_attribute",
          "old_text": "e>(this)) {\n       ",
          "new_text": "alue) {\n            element_copy->set_attribute(name, value);\n        });\n        copy = move(element_copy);\n    } else if",
          "old_line_content": "        copy = move(document_copy);",
          "new_line_content": "        element.for_each_attribute([&](auto& name, auto& value) {",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": "pe = verify_cast<Docum",
          "new_api": "});\n        copy = move(element_copy);",
          "old_text": "pe = verify_cast<Docum",
          "new_text": "});\n        copy = move(element_copy);\n ",
          "old_line_content": "    } else if (is<DocumentType>(this)) {",
          "new_line_content": "            element_copy->set_attribute(name, value);",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": "set_name",
          "new_api": "is)) {\n        aut",
          "old_text": "ocument_type_copy->set_name(document_ty",
          "new_text": "is)) {\n        aut",
          "old_line_content": "        auto document_type_copy = adopt_ref(*new DocumentType(*document));",
          "new_line_content": "        copy = move(element_copy);",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": "set_public_id",
          "new_api": "ify_cast<Document>",
          "old_text": "->set_public_id(docum",
          "new_text": "ify_cast<Document>",
          "old_line_content": "        document_type_copy->set_name(document_type->name());",
          "new_line_content": "    } else if (is<Document>(this)) {",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": "set_system_id",
          "new_api": "_copy = Document::create(do",
          "old_text": "_copy->set_system_id(docum",
          "new_text": "_copy = Document::create(do",
          "old_line_content": "        document_type_copy->set_public_id(document_type->public_id());",
          "new_line_content": "        auto document_ = verify_cast<Document>(this);",
          "content_same": false
        },
        {
          "line": 521,
          "old_api": "ocument_type_copy);\n    }",
          "new_api": "ding",
          "old_text": "ocument_type_copy);\n    } ",
          "new_text": "ding(document_->",
          "old_line_content": "        document_type_copy->set_system_id(document_type->system_id());",
          "new_line_content": "        auto document_copy = Document::create(document_->url());",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": "this)) {\n        auto te",
          "new_api": "_content_type",
          "old_text": "this)) {\n        auto te",
          "new_text": "_content_type(documen",
          "old_line_content": "        copy = move(document_type_copy);",
          "new_line_content": "        document_copy->set_encoding(document_->encoding());",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": "Text>(this);",
          "new_api": ">set_origin(document_->or",
          "old_text": "Text>(this);\n ",
          "new_text": ">set_origin(document_->or",
          "old_line_content": "    } else if (is<Text>(this)) {",
          "new_line_content": "        document_copy->set_content_type(document_->content_type());",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": "adopt_ref",
          "new_api": "uirks_mode",
          "old_text": "adopt_ref(*new Text(*do",
          "new_text": "uirks_mode(document",
          "old_line_content": "        auto text = verify_cast<Text>(this);",
          "new_line_content": "        document_copy->set_origin(document_->origin());",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": "} else if",
          "new_api": "ml\" or \"html\")",
          "old_text": "  } else if ",
          "new_text": "ml\" or \"html\")\n  ",
          "old_line_content": "        auto text_copy = adopt_ref(*new Text(*document, text->data()));",
          "new_line_content": "        document_copy->set_quirks_mode(document_->mode());",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": "_cast<Comment>(th",
          "new_api": "e>(this)) {",
          "old_text": "_cast<Comment>(th",
          "new_text": "e>(this)) {\n       ",
          "old_line_content": "    } else if (is<Comment>(this)) {",
          "new_line_content": "        copy = move(document_copy);",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": "opy = adopt_ref(*new Comme",
          "new_api": "pe = verify_cast<Docum",
          "old_text": "opy = adopt_ref(*new Comme",
          "new_text": "pe = verify_cast<Docum",
          "old_line_content": "        auto comment = verify_cast<Comment>(this);",
          "new_line_content": "    } else if (is<DocumentType>(this)) {",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": "y);\n    } else",
          "new_api": "ment_type_copy = adopt_ref(*new",
          "old_text": "y);\n    } else ",
          "new_text": "ment_type_copy = adopt_ref(*new",
          "old_line_content": "        auto comment_copy = adopt_ref(*new Comment(*document, comment->data()));",
          "new_line_content": "        auto document_type = verify_cast<DocumentType>(this);",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": "struction>(this))",
          "new_api": "set_name",
          "old_text": "struction>(this)) ",
          "new_text": "ocument_type_copy->set_name(document_ty",
          "old_line_content": "        copy = move(comment_copy);",
          "new_line_content": "        auto document_type_copy = adopt_ref(*new DocumentType(*document));",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "ocessing_instruction = verify_c",
          "new_api": "set_public_id",
          "old_text": "ocessing_instruction = verify_c",
          "new_text": "->set_public_id(docum",
          "old_line_content": "    } else if (is<ProcessingInstruction>(this)) {",
          "new_line_content": "        document_type_copy->set_name(document_type->name());",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": "auto processing_instruction_copy = adopt",
          "new_api": "set_system_id",
          "old_text": "auto processing_instruction_copy = adopt",
          "new_text": "_copy->set_system_id(docum",
          "old_line_content": "        auto processing_instruction = verify_cast<ProcessingInstruction>(this);",
          "new_line_content": "        document_type_copy->set_public_id(document_type->public_id());",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": "move(processing_instruction_cop",
          "new_api": "ocument_type_copy);\n    }",
          "old_text": " move(processing_instruction_cop",
          "new_text": "ocument_type_copy);\n    } ",
          "old_line_content": "        auto processing_instruction_copy = adopt_ref(*new ProcessingInstruction(*document, processing_instruction->data(), processing_instruction->target()));",
          "new_line_content": "        document_type_copy->set_system_id(document_type->system_id());",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "is<DocumentFragment>(this)) {",
          "new_api": "this)) {\n        auto te",
          "old_text": "is<DocumentFragment>(this)) {\n   ",
          "new_text": "this)) {\n        auto te",
          "old_line_content": "        copy = move(processing_instruction_copy);",
          "new_line_content": "        copy = move(document_type_copy);",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": "t_fragment_copy = adopt_re",
          "new_api": "Text>(this);",
          "old_text": "t_fragment_copy = adopt_re",
          "new_text": "Text>(this);\n ",
          "old_line_content": "    } else if (is<DocumentFragment>(this)) {",
          "new_line_content": "    } else if (is<Text>(this)) {",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": "copy = move(document_fragment_copy);",
          "new_api": "adopt_ref",
          "old_text": "   copy = move(document_fragment_copy);\n   ",
          "new_text": "adopt_ref(*new Text(*do",
          "old_line_content": "        auto document_fragment_copy = adopt_ref(*new DocumentFragment(*document));",
          "new_line_content": "        auto text = verify_cast<Text>(this);",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "dbgln(\"clone_node() not imp",
          "new_api": "} else if",
          "old_text": " dbgln(\"clone_node() not imp",
          "new_text": "  } else if ",
          "old_line_content": "        copy = move(document_fragment_copy);",
          "new_line_content": "        auto text_copy = adopt_ref(*new Text(*document, text->data()));",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "}\", (u16)m_type);\n        TODO();\n    }\n    // FIXME: 4. Set copy’",
          "new_api": "_cast<Comment>(th",
          "old_text": "}\", (u16)m_type);\n        TODO();\n    }\n    // FIXME: 4. Set copy’",
          "new_text": "_cast<Comment>(th",
          "old_line_content": "        dbgln(\"clone_node() not implemented for NodeType {}\", (u16)m_type);",
          "new_line_content": "    } else if (is<Comment>(this)) {",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": "ument",
          "new_api": "opy = adopt_ref(*new Comme",
          "old_text": "ument ",
          "new_text": "opy = adopt_ref(*new Comme",
          "old_line_content": "        TODO();",
          "new_line_content": "        auto comment = verify_cast<Comment>(this);",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": ") {\n        for_each_child([&",
          "new_api": "auto processing_instruction_copy = adopt",
          "old_text": ") {\n        for_each_child([&",
          "new_text": "auto processing_instruction_copy = adopt",
          "old_line_content": "    cloned(*copy, clone_children);",
          "new_line_content": "        auto processing_instruction = verify_cast<ProcessingInstruction>(this);",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": "clone_node",
          "new_api": "t_fragment_copy = adopt_re",
          "old_text": "pend_child(child.clone_node(document, true));\n        });\n    }\n    return copy.release_nonnull();\n}\n\n// https",
          "new_text": "t_fragment_copy = adopt_re",
          "old_line_content": "        for_each_child([&](auto& child) {",
          "new_line_content": "    } else if (is<DocumentFragment>(this)) {",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": "release_nonnull",
          "new_api": "copy = move(document_fragment_copy);",
          "old_text": "   return copy.release_nonnull()",
          "new_text": "   copy = move(document_fragment_copy);\n   ",
          "old_line_content": "            copy->append_child(child.clone_node(document, true));",
          "new_line_content": "        auto document_fragment_copy = adopt_ref(*new DocumentFragment(*document));",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "org/#dom-node-clonenod",
          "new_api": "}\", (u16)m_type);\n        TODO();\n    }\n    // FIXME: 4. Set copy’",
          "old_text": "org/#dom-node-clonenod",
          "new_text": "}\", (u16)m_type);\n        TODO();\n    }\n    // FIXME: 4. Set copy’",
          "old_line_content": "    return copy.release_nonnull();",
          "new_line_content": "        dbgln(\"clone_node() not implemented for NodeType {}\", (u16)m_type);",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": "Badge<Document>, Document",
          "new_api": "clone_node",
          "old_text": "Badge<Document>, Document",
          "new_text": "pend_child(child.clone_node(document, true));\n        });\n    }\n    return copy.release_nonnull();\n}\n\n// https",
          "old_line_content": "    return clone_node(nullptr, deep);",
          "new_line_content": "        for_each_child([&](auto& child) {",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": "t and reset the \"needs sty",
          "new_api": "Badge<Document>, Document",
          "old_text": "t and reset the \"needs sty",
          "new_text": "Badge<Document>, Document",
          "old_line_content": "    if (needs_style_update() || child_needs_style_update()) {",
          "new_line_content": "    return clone_node(nullptr, deep);",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "_ref",
          "new_api": "_update",
          "old_text": "_ref()\n{\n    if (is<Docume",
          "new_text": "_update(true);\n    }\n}\n\nbool ",
          "old_line_content": "    return wrap(global_object, *this);",
          "new_line_content": "        set_needs_style_update(false);",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": "ast<ParentNode>(parent());\n}\n\nNonnull",
          "new_api": "serted",
          "old_text": "ast<ParentNode>(parent());\n}\n\nNonnull",
          "new_text": "serted()\n{\n    set_needs_style_upd",
          "old_line_content": "        return verify_cast<ShadowRoot>(*this).host();",
          "new_line_content": "        document().schedule_style_update();",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": "ITION_CONTAINED_BY | DOCUMENT",
          "new_api": "ibWeb suppo",
          "old_text": "ITION_CONTAINED_BY | DOCUMENT",
          "new_text": "ibWeb suppo",
          "old_line_content": "    if (node2->is_ancestor_of(*node1))",
          "new_line_content": "    Node* node1 = other.ptr();",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": "if (is<DocumentFragment>(other.",
          "new_api": "ITION_CONTAINED_BY | DOCUMENT",
          "old_text": "if (is<DocumentFragment>(other.",
          "new_text": "ITION_CONTAINED_BY | DOCUMENT",
          "old_line_content": "    if (is_inclusive_ancestor_of(other))",
          "new_line_content": "    if (node2->is_ancestor_of(*node1))",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": "static_cast<",
          "new_api": "_PRECEDING;\n    else",
          "old_text": "static_cast<",
          "new_text": "_PRECEDING;\n    else\n   ",
          "old_line_content": "        && static_cast<DocumentFragment const&>(other.root()).host()",
          "new_line_content": "    if (node1->is_before(*node2))",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": "type",
          "new_api": "return false;\n    if (!layout_node())\n        re",
          "old_text": "type",
          "new_text": "      return false;\n    if (!layout_node())\n        re",
          "old_line_content": "    MUST(object.add(\"id\", id()));",
          "new_line_content": "    if (!static_cast<Text const&>(*this).data().is_whitespace())",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": "add",
          "new_api": ">parent()->is",
          "old_text": "()) {\n        MUST(object.add(",
          "new_text": ">parent()->is",
          "old_line_content": "        MUST(object.add(\"type\", \"document\"));",
          "new_line_content": "    if (!layout_node())",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": "nt = static_cast<DOM::Element",
          "new_api": "ue;\n    return false;\n}\n\nvoid Node::ser",
          "old_text": "nt = static_cast<DOM::Element",
          "new_text": "ue;\n    return false;\n}\n\nvoid Node::ser",
          "old_line_content": "        MUST(object.add(\"type\", \"element\"));",
          "new_line_content": "    if (layout_node()->parent()->is_anonymous())",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": "rowsing_context_con",
          "new_api": "type",
          "old_text": "rowsing_context_con",
          "new_text": "type",
          "old_line_content": "            MUST(attributes.finish());",
          "new_line_content": "    MUST(object.add(\"id\", id()));",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": "to const* container = static_cast<HTML::",
          "new_api": ");",
          "old_text": "to const* container = static_cast<HTML::",
          "new_text": ");\n\n        ",
          "old_line_content": "        if (element->is_browsing_context_container()) {",
          "new_line_content": "    } else if (is_element()) {",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": ");\n            if (auto const* content_document = container",
          "new_api": "nt = static_cast<DOM::Element",
          "old_text": ");\n            if (auto const* content_document = container",
          "new_text": "nt = static_cast<DOM::Element",
          "old_line_content": "            auto const* container = static_cast<HTML::BrowsingContextContainer const*>(element);",
          "new_line_content": "        MUST(object.add(\"type\", \"element\"));",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "erializer<StringBuilder> con",
          "new_api": "has_attributes",
          "old_text": "erializer<StringBuilder> con",
          "new_text": "t->has_attributes()) {\n            aut",
          "old_line_content": "                auto children = MUST(object.add_array(\"children\"));",
          "new_line_content": "        auto const* element = static_cast<DOM::Element const*>(this);",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": "serialize_tree_as_jso",
          "new_api": "add_object",
          "old_text": "serialize_tree_as_jso",
          "new_text": " MUST(object.add_object(\"",
          "old_line_content": "                JsonObjectSerializer<StringBuilder> content_document_object = MUST(children.add_object());",
          "new_line_content": "        if (element->has_attributes()) {",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": "finish",
          "new_api": "_each_attribute",
          "old_text": "object);\n                MUST(content_document_object.finish());\n",
          "new_text": "_each_attribute([&attributes](a",
          "old_line_content": "                content_document->serialize_tree_as_json(content_document_object);",
          "new_line_content": "            auto attributes = MUST(object.add_object(\"attributes\"));",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": "finish",
          "new_api": "add",
          "old_text": "ildren.finish());\n            }\n",
          "new_text": "& value) {\n                MUST(attributes.add(name, value));\n            });\n            MUST(attributes.finish());\n        }\n\n      ",
          "old_line_content": "                MUST(content_document_object.finish());",
          "new_line_content": "            element->for_each_attribute([&attributes](auto& name, auto& value) {",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": "(is_text()) {",
          "new_api": "finish",
          "old_text": "(is_text()) {\n   ",
          "new_text": "MUST(attributes.finish());\n",
          "old_line_content": "                MUST(children.finish());",
          "new_line_content": "                MUST(attributes.add(name, value));",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": "data",
          "new_api": ");\n            if (auto const* content_document = container",
          "old_text": "dd(\"text\", text_node->data()));\n   ",
          "new_text": ");\n            if (auto const* content_document = container",
          "old_line_content": "        auto text_node = static_cast<DOM::Text const*>(this);",
          "new_line_content": "            auto const* container = static_cast<HTML::BrowsingContextContainer const*>(element);",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "MUST(object.add",
          "new_api": "add_array",
          "old_text": "  MUST(object.add",
          "new_text": "dren = MUST(object.add_array(",
          "old_line_content": "        MUST(object.add(\"text\", text_node->data()));",
          "new_line_content": "            if (auto const* content_document = container->content_document()) {",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": "\"sv));",
          "new_api": "erializer<StringBuilder> con",
          "old_text": "\"sv));\n     ",
          "new_text": "erializer<StringBuilder> con",
          "old_line_content": "    } else if (is_comment()) {",
          "new_line_content": "                auto children = MUST(object.add_array(\"children\"));",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "d",
          "new_api": "serialize_tree_as_jso",
          "old_text": "d(\"data\"sv, static_cast<DOM::Comm",
          "new_text": "serialize_tree_as_jso",
          "old_line_content": "        MUST(object.add(\"type\"sv, \"comment\"sv));",
          "new_line_content": "                JsonObjectSerializer<StringBuilder> content_document_object = MUST(children.add_object());",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "if (has_child_nodes()) {\n        auto child",
          "new_api": "finish",
          "old_text": "   if (has_child_nodes()) {\n        auto child",
          "new_text": "object);\n                MUST(content_document_object.finish());\n",
          "old_line_content": "        MUST(object.add(\"data\"sv, static_cast<DOM::Comment const&>(*this).data()));",
          "new_line_content": "                content_document->serialize_tree_as_json(content_document_object);",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "is_uninteresting_whitespace_node",
          "new_api": "aut",
          "old_text": " if (child.is_uninteresting_whitespace_node())\n                return;\n            JsonObjectSerializer<StringBuilder> child_object = MUST(children.add_object());\n            child.serialize_tree_as_json(child_object);\n            MUST(child_object.finish());\n        });\n\n        // Pseudo-elements don't have DOM nodes,so we h",
          "new_text": "      aut",
          "old_line_content": "        for_each_child([&children](DOM::Node& child) {",
          "new_line_content": "    } else if (is_text()) {",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": "return;\n            JsonObjectSerializer",
          "new_api": "tic_cast<DOM::Text const*>",
          "old_text": "return;\n            JsonObjectSerializer",
          "new_text": "tic_cast<DOM::Text const*>",
          "old_line_content": "            if (child.is_uninteresting_whitespace_node())",
          "new_line_content": "        MUST(object.add(\"type\", \"text\"));",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "s_json",
          "new_api": "data",
          "old_text": "s_json(child_object);",
          "new_text": "dd(\"text\", text_node->data()));\n   ",
          "old_line_content": "            JsonObjectSerializer<StringBuilder> child_object = MUST(children.add_object());",
          "new_line_content": "        auto text_node = static_cast<DOM::Text const*>(this);",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "finish",
          "new_api": "MUST(object.add",
          "old_text": "ST(child_object.finish());\n        });\n\n  ",
          "new_text": "  MUST(object.add",
          "old_line_content": "            child.serialize_tree_as_json(child_object);",
          "new_line_content": "        MUST(object.add(\"text\", text_node->data()));",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": "ments don't have DOM",
          "new_api": "\"sv));",
          "old_text": "ments don't have DOM ",
          "new_text": "\"sv));\n     ",
          "old_line_content": "            MUST(child_object.finish());",
          "new_line_content": "    } else if (is_comment()) {",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": "serialize_pseudo_elements_as_json",
          "new_api": "dd_array",
          "old_text": "t->serialize_pseudo_elements_as_json(c",
          "new_text": "dd_array(\"childre",
          "old_line_content": "            auto const* element = static_cast<DOM::Element const*>(this);",
          "new_line_content": "    if (has_child_nodes()) {",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": "finish",
          "new_api": "ildren](DOM::Node& child) {",
          "old_text": "    }\n\n        MUST(children.finish());\n    }\n}\n\n// ",
          "new_text": "ildren](DOM::Node& child) {\n",
          "old_line_content": "            element->serialize_pseudo_elements_as_json(children);",
          "new_line_content": "        auto children = MUST(object.add_array(\"children\"));",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": "wg.org/#dom-node-contains\nboo",
          "new_api": "serialize_pseudo_elements_as_json",
          "old_text": "wg.org/#dom-node-contains\nboo",
          "new_text": "t->serialize_pseudo_elements_as_json(c",
          "old_line_content": "    return !document().browsing_context();",
          "new_line_content": "            auto const* element = static_cast<DOM::Element const*>(this);",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "<ShadowRoot>(root()))",
          "new_api": "wg.org/#dom-node-contains\nboo",
          "old_text": "<ShadowRoot>(root()))\n ",
          "new_text": "wg.org/#dom-node-contains\nboo",
          "old_line_content": "    if (is_descendant_of(other))",
          "new_line_content": "    return !document().browsing_context();",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": "nherit",
          "new_api": "m.spec.whatwg.org/#concept-shadow-includ",
          "old_text": "nherit",
          "new_text": "m.spec.whatwg.org/#concept-shadow-includ",
          "old_line_content": "    auto& shadow_root = verify_cast<ShadowRoot>(root());",
          "new_line_content": "    return other && other->is_inclusive_descendant_of(*this);",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": "m.spec.whatwg.org/#concept-shadow-includ",
          "new_api": "rify_c",
          "old_text": "m.spec.whatwg.org/#concept-shadow-includ",
          "new_text": "rify_c",
          "old_line_content": "    return &other == this || is_shadow_including_descendant_of(other);",
          "new_line_content": "    if (!is<ShadowRoot>(root()))",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": "s://dom.spec.whatwg.org/#concept-shadow-includ",
          "new_api": "nt_of",
          "old_text": "s://dom.spec.whatwg.org/#concept-shadow-includ",
          "new_text": "nt_of(other);\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-includ",
          "old_line_content": "    return other.is_shadow_including_descendant_of(*this);",
          "new_line_content": "    return shadow_root.host()->is_shadow_including_inclusive_descendant_of(other);",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "}\n\n// https://dom.spec.whatwg.org/#concept-node-replace-",
          "new_api": "m.spec.whatwg.org/#concept-shadow-includ",
          "old_text": "}\n\n// https://dom.spec.whatwg.org/#concept-node-replace-",
          "new_text": "m.spec.whatwg.org/#concept-shadow-includ",
          "old_line_content": "    return other.is_shadow_including_inclusive_descendant_of(*this);",
          "new_line_content": "    return &other == this || is_shadow_including_descendant_of(other);",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": "Otherwise, context document is an XML document;",
          "new_api": "ithub.io/D",
          "old_text": " Otherwise, context document is an XML document;",
          "new_text": "ithub.io/D",
          "old_line_content": "    return HTML::HTMLParser::serialize_html_fragment(*this);",
          "new_line_content": "        node = make_ref_counted<Text>(document(), string);",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": "prefix",
          "new_api": "verify_cast<DocumentType>(*other",
          "old_text": " other_element.prefix()\n  ",
          "new_text": "verify_cast<DocumentType>(*other",
          "old_line_content": "        if (this_element.namespace_() != other_element.namespace_()",
          "new_line_content": "        auto& this_doctype = verify_cast<DocumentType>(*this);",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": "other_element.local_n",
          "new_api": "name",
          "old_text": " other_element.local_n",
          "new_text": ".name() != other_doctype.name()\n      ",
          "old_line_content": "            || this_element.prefix() != other_element.prefix()",
          "new_line_content": "        auto& other_doctype = verify_cast<DocumentType>(*other_node);",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": "ist_size",
          "new_api": "other_doctype.public",
          "old_text": "ist_size() != other_elemen",
          "new_text": "other_doctype.public",
          "old_line_content": "            || this_element.local_name() != other_element.local_name()",
          "new_line_content": "        if (this_doctype.name() != other_doctype.name()",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "// If A is an element, each at",
          "new_api": ") != other_doctype.system",
          "old_text": "     // If A is an element, each at",
          "new_text": ") != other_doctype.system",
          "old_line_content": "            || this_element.attribute_list_size() != other_element.attribute_list_size())",
          "new_line_content": "            || this_doctype.public_id() != other_doctype.public_id()",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "data",
          "new_api": "get_attribute",
          "old_text": "() != other_cdata.data())\n            r",
          "new_text": "       if (other_element.get_attribute(name) != value)\n                has_same_attributes = false;\n        });\n        if (!has_same_attributes)\n            return false;\n      ",
          "old_line_content": "        auto& other_cdata = verify_cast<CharacterData>(*other_node);",
          "new_line_content": "        this_element.for_each_attribute([&](auto& name, auto& value) {",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": "case (u16)NodeT",
          "new_api": "_attributes = false;\n        });",
          "old_text": "   case (u16)NodeT",
          "new_text": "_attributes = false;\n        });\n",
          "old_line_content": "        if (this_cdata.data() != other_cdata.data())",
          "new_line_content": "            if (other_element.get_attribute(name) != value)",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": "t",
          "new_api": "case (u16)NodeT",
          "old_text": "t();\n    if (",
          "new_text": "   case (u16)NodeT",
          "old_line_content": "    size_t this_child_count = child_count();",
          "new_line_content": "        if (this_cdata.data() != other_cdata.data())",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": "}\n\n    return true;\n}\n\n// https://do",
          "new_api": "t",
          "old_text": "  }\n\n    return true;\n}\n\n// https://do",
          "new_text": "t();\n    if (",
          "old_line_content": "        if (!this_child->is_equal_node(other_child))",
          "new_line_content": "    size_t this_child_count = child_count();",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "trootnode\nNonnullRef",
          "new_api": "ild))\n            r",
          "old_text": "trootnode\nNonnullRef",
          "new_text": "ild))\n            r",
          "old_line_content": "    return root().is_document();",
          "new_line_content": "        VERIFY(other_child);",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": "class_names",
          "new_api": "iption",
          "old_text": "nt.class_names())\n         ",
          "new_text": "iption() const\n{\n    St",
          "old_line_content": "            builder.appendff(\"#{}\", id);",
          "new_line_content": "        return shadow_including_root();",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": ");\n}\n\n// https://dom.spec.whatwg.or",
          "new_api": "ilder;",
          "old_text": ");\n}\n\n// https://dom.spec.whatwg.or",
          "new_text": "ilder;",
          "old_line_content": "            builder.appendff(\".{}\", class_name);",
          "new_line_content": "    return root();",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": "node, then ret",
          "new_api": "const& clas",
          "old_text": "node, then ret",
          "new_text": " const& clas",
          "old_line_content": "    if (is_document_type() || is_attribute())",
          "new_line_content": "        if (auto id = element.get_attribute(HTML::AttributeNames::id); !id.is_null())",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": "length",
          "new_api": "gth\nsize_t Node::le",
          "old_text": ".length();\n    }\n\n    // 3. Retu",
          "new_text": "gth\nsize_t Node::le",
          "old_line_content": "        auto* character_data_node = verify_cast<CharacterData>(this);",
          "new_line_content": "    return builder.to_string();",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": "const\n{\n    if (!layout_n",
          "new_api": "length",
          "old_text": " const\n{\n    if (!layout_n",
          "new_text": ".length();\n    }\n\n    // 3. Retu",
          "old_line_content": "    return layout_node()->paintable();",
          "new_line_content": "        auto* character_data_node = verify_cast<CharacterData>(this);",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": "return nul",
          "new_api": "(!layout_node",
          "old_text": "   return nul",
          "new_text": "(!layout_node",
          "old_line_content": "    if (!layout_node())",
          "new_line_content": "    return child_count();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1025,
          "old_api": null,
          "new_api": "cterData>(this);",
          "old_text": null,
          "new_text": "cterData>(this);\n  ",
          "old_line_content": "        return nullptr;",
          "new_line_content": "    if (is_character_data()) {",
          "content_same": false
        },
        {
          "line": 514,
          "old_api": null,
          "new_api": "e prefix, and node’s",
          "old_text": null,
          "new_text": "e prefix, and node’s",
          "old_line_content": "        // FIXME: Set type (\"xml\" or \"html\")",
          "new_line_content": "        auto element_copy = DOM::create_element(*document, element.local_name(), element.namespace_() /* FIXME: node’s namespace prefix, and node’s is value, with the synchronous custom elements flag unset */);",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": null,
          "new_api": "node’s children.\n    return child_co",
          "old_text": null,
          "new_text": "node’s children.\n    return child_co",
          "old_line_content": "}",
          "new_line_content": "        return character_data_node->data().length();",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": null,
          "new_api": "}\n\nPainting::",
          "old_text": null,
          "new_text": "}\n\nPainting::",
          "old_line_content": "}",
          "new_line_content": "    if (!layout_node())",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": null,
          "new_api": "const\n{\n    if (!layout_n",
          "old_text": null,
          "new_text": " const\n{\n    if (!layout_n",
          "old_line_content": "}",
          "new_line_content": "    return layout_node()->paintable();",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": null,
          "new_api": "return nul",
          "old_text": null,
          "new_text": "   return nul",
          "old_line_content": "",
          "new_line_content": "    if (!layout_node())",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": null,
          "new_api": "::Box const&>(*layout_n",
          "old_text": null,
          "new_text": "::Box const&>(*layout_n",
          "old_line_content": "",
          "new_line_content": "    if (!layout_node()->is_box())",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "    return static_cast<Layout::Box const&>(*layout_node()).paint_box();",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": null,
          "new_api": "{\n        auto",
          "old_text": null,
          "new_text": " {\n        auto",
          "old_line_content": "    } else {",
          "new_line_content": "        copy = move(text_copy);",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": null,
          "new_api": "y);\n    } else",
          "old_text": null,
          "new_text": "y);\n    } else ",
          "old_line_content": "    }",
          "new_line_content": "        auto comment_copy = adopt_ref(*new Comment(*document, comment->data()));",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": null,
          "new_api": "struction>(this))",
          "old_text": null,
          "new_text": "struction>(this)) ",
          "old_line_content": "    // FIXME: 4. Set copy’s node document and document to copy, if copy is a document, and set copy’s node document to document otherwise.",
          "new_line_content": "        copy = move(comment_copy);",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": null,
          "new_api": "ocessing_instruction = verify_c",
          "old_text": null,
          "new_text": "ocessing_instruction = verify_c",
          "old_line_content": "",
          "new_line_content": "    } else if (is<ProcessingInstruction>(this)) {",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": null,
          "new_api": "move(processing_instruction_cop",
          "old_text": null,
          "new_text": " move(processing_instruction_cop",
          "old_line_content": "",
          "new_line_content": "        auto processing_instruction_copy = adopt_ref(*new ProcessingInstruction(*document, processing_instruction->data(), processing_instruction->target()));",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": null,
          "new_api": "is<DocumentFragment>(this)) {",
          "old_text": null,
          "new_text": "is<DocumentFragment>(this)) {\n   ",
          "old_line_content": "    if (clone_children) {",
          "new_line_content": "        copy = move(processing_instruction_copy);",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": null,
          "new_api": "dbgln(\"clone_node() not imp",
          "old_text": null,
          "new_text": " dbgln(\"clone_node() not imp",
          "old_line_content": "        });",
          "new_line_content": "        copy = move(document_fragment_copy);",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": null,
          "new_api": "ument",
          "old_text": null,
          "new_text": "ument ",
          "old_line_content": "}",
          "new_line_content": "        TODO();",
          "content_same": false
        },
        {
          "line": 556,
          "old_api": null,
          "new_api": ") {\n        for_each_child([&",
          "old_text": null,
          "new_text": ") {\n        for_each_child([&",
          "old_line_content": "{",
          "new_line_content": "    cloned(*copy, clone_children);",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": null,
          "new_api": "release_nonnull",
          "old_text": null,
          "new_text": "   return copy.release_nonnull()",
          "old_line_content": "}",
          "new_line_content": "            copy->append_child(child.clone_node(document, true));",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": null,
          "new_api": "org/#dom-node-clonenod",
          "old_text": null,
          "new_text": "org/#dom-node-clonenod",
          "old_line_content": "{",
          "new_line_content": "    return copy.release_nonnull();",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": null,
          "new_api": "r::create(\"Cannot clo",
          "old_text": null,
          "new_text": "r::create(\"Cannot clo",
          "old_line_content": "    m_document = &document;",
          "new_line_content": "    if (is<ShadowRoot>(*this))",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": null,
          "new_api": "return clone_node(nullptr, deep);\n}\n\nvoid Node::",
          "old_text": null,
          "new_text": "\n    return clone_node(nullptr, deep);\n}\n\nvoid Node::",
          "old_line_content": "",
          "new_line_content": "        return NotSupportedError::create(\"Cannot clone shadow root\");",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": null,
          "new_api": "_node",
          "old_text": null,
          "new_text": "_node({});\n    m_document ",
          "old_line_content": "",
          "new_line_content": "    document.ref_from_node({});",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": null,
          "new_api": "ument;\n\n    if (needs_style_upd",
          "old_text": null,
          "new_text": "ument;\n\n    if (needs_style_upd",
          "old_line_content": "bool Node::is_editable() const",
          "new_line_content": "    m_document->unref_from_node({});",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": null,
          "new_api": "t and reset the \"needs sty",
          "old_text": null,
          "new_text": "t and reset the \"needs sty",
          "old_line_content": "}",
          "new_line_content": "    if (needs_style_update() || child_needs_style_update()) {",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": null,
          "new_api": "ditable",
          "old_text": null,
          "new_text": "ditable() const\n{\n    return",
          "old_line_content": "}",
          "new_line_content": "        set_needs_style_update(true);",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": null,
          "new_api": "rapper",
          "old_text": null,
          "new_text": "rapper(JS::GlobalObject",
          "old_line_content": "        return;",
          "new_line_content": "    return parent() && parent()->is_editable();",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": null,
          "new_api": "_ref",
          "old_text": null,
          "new_text": "_ref()\n{\n    if (is<Docume",
          "old_line_content": "",
          "new_line_content": "    return wrap(global_object, *this);",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": null,
          "new_api": "this).removed_last_",
          "old_text": null,
          "new_text": "this).removed_last_",
          "old_line_content": "    else",
          "new_line_content": "    if (is<Document>(*this)) {",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": null,
          "new_api": "return;\n    }\n    m_deletion_has_begun = tru",
          "old_text": null,
          "new_text": "   return;\n    }\n    m_deletion_has_begun = tru",
          "old_line_content": "        m_layout_node = nullptr;",
          "new_line_content": "        verify_cast<Document>(*this).removed_last_ref();",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": null,
          "new_api": "t_node = nullptr;\n}\n\nEventTa",
          "old_text": null,
          "new_text": "t_node = nullptr;\n}\n\nEventTa",
          "old_line_content": "{",
          "new_line_content": "        m_layout_node = layout_node->make_weak_ptr();",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": null,
          "new_api": "{\n    i",
          "old_text": null,
          "new_text": "\n{\n    i",
          "old_line_content": "        }",
          "new_line_content": "    return parent();",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": null,
          "new_api": ">m_child_needs_style_update = tru",
          "old_text": null,
          "new_text": ">m_child_needs_style_update = tru",
          "old_line_content": "ParentNode* Node::parent_or_shadow_host()",
          "new_line_content": "        for (auto* ancestor = parent_or_shadow_host(); ancestor; ancestor = ancestor->parent_or_shadow_host()) {",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": null,
          "new_api": "or_shadow_host",
          "old_text": null,
          "new_text": "or_shadow_host()\n{\n    if (i",
          "old_line_content": "    // FIXME: This should return the same LiveNodeList object every time,",
          "new_line_content": "    set_needs_style_update(true);",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": null,
          "new_api": "host",
          "old_text": null,
          "new_text": "ot>(*this).host();\n  ",
          "old_line_content": "}",
          "new_line_content": "    if (is<ShadowRoot>(*this))",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": null,
          "new_api": "ast<ParentNode>(parent());\n}\n\nNonnull",
          "old_text": null,
          "new_text": "ast<ParentNode>(parent());\n}\n\nNonnull",
          "old_line_content": "",
          "new_line_content": "        return verify_cast<ShadowRoot>(*this).host();",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": null,
          "new_api": "{\n    //",
          "old_text": null,
          "new_text": "{\n    //",
          "old_line_content": "NonnullRefPtrVector<Node> Node::children_as_vector() const",
          "new_line_content": "    return verify_cast<ParentNode>(parent());",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": null,
          "new_api": "eturn is_parent_of(node);\n    });\n}\n\nNonnullRefPtrVector<Node> Node::children_as_vector()",
          "old_text": null,
          "new_text": "eturn is_parent_of(node);\n    });\n}\n\nNonnullRefPtrVector<Node> Node::children_as_vector() ",
          "old_line_content": "",
          "new_line_content": "    return LiveNodeList::create(*this, [this](auto& node) {",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": null,
          "new_api": "ode::children_as_v",
          "old_text": null,
          "new_text": "ode::children_as_v",
          "old_line_content": "    return nodes;",
          "new_line_content": "        return is_parent_of(node);",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": null,
          "new_api": "ld);\n    });\n\n    return nodes;\n}\n\nvoid Node::remove_all_children(boo",
          "old_text": null,
          "new_text": "ld);\n    });\n\n    return nodes;\n}\n\nvoid Node::remove_all_children(boo",
          "old_line_content": "",
          "new_line_content": "    for_each_child([&](auto& child) {",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": null,
          "new_api": "de::remove_all_chil",
          "old_text": null,
          "new_text": "de::remove_all_chil",
          "old_line_content": "// https://dom.spec.whatwg.org/#dom-node-comparedocumentposition",
          "new_line_content": "        nodes.append(child);",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": null,
          "new_api": "}\n\n// https:/",
          "old_text": null,
          "new_text": "}\n\n// https:/",
          "old_line_content": "        DOCUMENT_POSITION_CONTAINS = 8,",
          "new_line_content": "    while (RefPtr<Node> child = first_child())",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": null,
          "new_api": "whatwg.org/#dom-node-comparedocum",
          "old_text": null,
          "new_text": "whatwg.org/#dom-node-comparedocum",
          "old_line_content": "        DOCUMENT_POSITION_CONTAINED_BY = 16,",
          "new_line_content": "        child->remove(suppress_observers);",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": null,
          "new_api": "has_children",
          "old_text": null,
          "new_text": "node.has_children()",
          "old_line_content": "        return IterationDecision::Continue;",
          "new_line_content": "        if (node.has_children())",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": null,
          "new_api": "has_children",
          "old_text": null,
          "new_text": "shadow_root->has_children()",
          "old_line_content": "",
          "new_line_content": "            if (shadow_root->has_children())",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": null,
          "new_api": "1 == nullptr",
          "old_text": null,
          "new_text": "1 == nullptr ",
          "old_line_content": "        return DOCUMENT_POSITION_PRECEDING;",
          "new_line_content": "    VERIFY(node1->type() != NodeType::ATTRIBUTE_NODE && node2->type() != NodeType::ATTRIBUTE_NODE);",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": null,
          "new_api": "TED | DOCUMEN",
          "old_text": null,
          "new_text": "TED | DOCUMEN",
          "old_line_content": "        return DOCUMENT_POSITION_FOLLOWING;",
          "new_line_content": "    if ((node1 == nullptr || node2 == nullptr) || (&node1->root() != &node2->root()))",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": null,
          "new_api": "parent_or_shadow_host",
          "old_text": null,
          "new_text": "parent_or_shadow_host()",
          "old_line_content": "",
          "new_line_content": "    for (auto* ancestor = parent_or_shadow_host(); ancestor; ancestor = parent_or_shadow_host()) {",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": null,
          "new_api": "ITION_CONTAINS | DOCUMENT_POS",
          "old_text": null,
          "new_text": "ITION_CONTAINS | DOCUMENT_POS",
          "old_line_content": "// https://dom.spec.whatwg.org/#concept-tree-host-including-inclusive-ancestor",
          "new_line_content": "    if (node1->is_ancestor_of(*node2))",
          "content_same": false
        },
        {
          "line": 195,
          "old_api": null,
          "new_api": "schedule_style_update",
          "old_text": null,
          "new_text": "document().schedule_style_update()",
          "old_line_content": "",
          "new_line_content": "    document().schedule_style_update();",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": null,
          "new_api": "enclosing_link_element",
          "old_text": null,
          "new_text": "enclosing_link_element()",
          "old_line_content": "    });",
          "new_line_content": "    return enclosing_link_element();",
          "content_same": false
        },
        {
          "line": 205,
          "old_api": null,
          "new_api": "is<ParentNode>(*this)",
          "old_text": null,
          "new_text": "is<ParentNode>(*this)",
          "old_line_content": "Node& Node::root()",
          "new_line_content": "    if (!is<ParentNode>(*this))",
          "content_same": false
        },
        {
          "line": 206,
          "old_api": null,
          "new_api": "String::empty()",
          "old_text": null,
          "new_text": "String::empty()",
          "old_line_content": "{",
          "new_line_content": "        return String::empty();",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": null,
          "new_api": "if (is<DocumentFragment>(other.",
          "old_text": null,
          "new_text": "if (is<DocumentFragment>(other.",
          "old_line_content": "{",
          "new_line_content": "    if (is_inclusive_ancestor_of(other))",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": null,
          "new_api": "t&>(other.ro",
          "old_text": null,
          "new_text": "t&>(other.ro",
          "old_line_content": "        return nullptr;",
          "new_line_content": "    if (is<DocumentFragment>(other.root())",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "static_cast<",
          "old_text": null,
          "new_text": "static_cast<",
          "old_line_content": "    return m_document;",
          "new_line_content": "        && static_cast<DocumentFragment const&>(other.root()).host()",
          "content_same": false
        },
        {
          "line": 210,
          "old_api": null,
          "new_api": "is<Text>(child)",
          "old_text": null,
          "new_text": "is<Text>(child)",
          "old_line_content": "    return *root;",
          "new_line_content": "        if (is<Text>(child))",
          "content_same": false
        },
        {
          "line": 211,
          "old_api": null,
          "new_api": "text_content",
          "old_text": null,
          "new_text": "verify_cast<Text>(child).text_content()",
          "old_line_content": "}",
          "new_line_content": "            builder.append(verify_cast<Text>(child).text_content());",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": null,
          "new_api": "turn false;",
          "old_text": null,
          "new_text": "turn false;\n",
          "old_line_content": "}",
          "new_line_content": "        && is_inclusive_ancestor_of(*static_cast<DocumentFragment const&>(other.root()).host())) {",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": null,
          "new_api": "build",
          "old_text": null,
          "new_text": "builder.build()",
          "old_line_content": "// https://dom.spec.whatwg.org/#concept-shadow-including-root",
          "new_line_content": "    return builder.build();",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "nt;\n}\n\n// Thi",
          "old_text": null,
          "new_text": "nt;\n}\n\n// Thi",
          "old_line_content": "        return false;",
          "new_line_content": "    if (is_document())",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "root->parent()",
          "old_line_content": "}",
          "new_line_content": "    while (root->parent())",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "root->parent()",
          "old_line_content": "",
          "new_line_content": "        root = root->parent();",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": null,
          "new_api": "root",
          "old_text": null,
          "new_text": "root()",
          "old_line_content": "Element* Node::parent_element()",
          "new_line_content": "    auto& node_root = root();",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": null,
          "new_api": "is<ShadowRoot>(node_root)",
          "old_text": null,
          "new_text": "is<ShadowRoot>(node_root)",
          "old_line_content": "{",
          "new_line_content": "    if (is<ShadowRoot>(node_root))",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": null,
          "new_api": "t<Text const&>(",
          "old_text": null,
          "new_text": "t<Text const&>(",
          "old_line_content": "{",
          "new_line_content": "    if (!is<Text>(*this))",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "parent()",
          "old_line_content": "// https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity",
          "new_line_content": "    if (!parent() || !is<Element>(parent()))",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": null,
          "new_api": "if (is_document(",
          "old_text": null,
          "new_text": "  if (is_document(",
          "old_line_content": "            });",
          "new_line_content": "    MUST(object.add(\"name\", node_name().view()));",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "parent()",
          "old_line_content": "{",
          "new_line_content": "    return verify_cast<Element>(parent());",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": null,
          "new_api": "\"));\n    } el",
          "old_text": null,
          "new_text": "\"));\n    } el",
          "old_line_content": "        }",
          "new_line_content": "    if (is_document()) {",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "()) {\n        MUST(object.add(",
          "old_line_content": "",
          "new_line_content": "        MUST(object.add(\"type\", \"document\"));",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": null,
          "new_api": "rowsing_context_con",
          "old_text": null,
          "new_text": "rowsing_context_con",
          "old_line_content": "        }",
          "new_line_content": "            MUST(attributes.finish());",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": null,
          "new_api": "DOM::HierarchyRequestError::create(\"Can only insert into a document, document fragment or element\")",
          "old_text": null,
          "new_text": "DOM::HierarchyRequestError::create(\"Can only insert into a document, document fragment or element\")",
          "old_line_content": "",
          "new_line_content": "        return DOM::HierarchyRequestError::create(\"Can only insert into a document, document fragment or element\");",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": null,
          "new_api": "to const* container = static_cast<HTML::",
          "old_text": null,
          "new_text": "to const* container = static_cast<HTML::",
          "old_line_content": "",
          "new_line_content": "        if (element->is_browsing_context_container()) {",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": null,
          "new_api": "DOM::HierarchyRequestError::create(\"New node is an ancestor of this node\")",
          "old_text": null,
          "new_text": "DOM::HierarchyRequestError::create(\"New node is an ancestor of this node\")",
          "old_line_content": "",
          "new_line_content": "        return DOM::HierarchyRequestError::create(\"New node is an ancestor of this node\");",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": null,
          "new_api": "finish",
          "old_text": null,
          "new_text": "ildren.finish());\n            }\n",
          "old_line_content": "    }",
          "new_line_content": "                MUST(content_document_object.finish());",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": null,
          "new_api": "(is_text()) {",
          "old_text": null,
          "new_text": "(is_text()) {\n   ",
          "old_line_content": "",
          "new_line_content": "                MUST(children.finish());",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": null,
          "new_api": "is<ProcessingInstruction>(*node)",
          "old_text": null,
          "new_text": "is<ProcessingInstruction>(*node)",
          "old_line_content": "            }",
          "new_line_content": "    if (!is<DocumentFragment>(*node) && !is<DocumentType>(*node) && !is<Element>(*node) && !is<Text>(*node) && !is<Comment>(*node) && !is<ProcessingInstruction>(*node))",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": null,
          "new_api": "is<DocumentFragment>(*node)",
          "old_text": null,
          "new_text": "is<DocumentFragment>(*node)",
          "old_line_content": "        }",
          "new_line_content": "        if (is<DocumentFragment>(*node)) {",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": null,
          "new_api": "child_element_count",
          "old_text": null,
          "new_text": "verify_cast<DocumentFragment>(*node).child_element_count()",
          "old_line_content": "    }",
          "new_line_content": "            auto node_element_child_count = verify_cast<DocumentFragment>(*node).child_element_count();",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": null,
          "new_api": "node->has_child_of_type<Text>()",
          "old_text": null,
          "new_text": "node->has_child_of_type<Text>()",
          "old_line_content": "",
          "new_line_content": "            if ((node_element_child_count > 1 || node->has_child_of_type<Text>())",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": null,
          "new_api": "child->has_following_node_of_type_in_tree_order<DocumentType>()",
          "old_text": null,
          "new_text": "child->has_following_node_of_type_in_tree_order<DocumentType>()",
          "old_line_content": "    return {};",
          "new_line_content": "                || (node_element_child_count == 1 && (has_child_of_type<Element>() || is<DocumentType>(child.ptr()) || (child && child->has_following_node_of_type_in_tree_order<DocumentType>())))) {",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "old_text": null,
          "new_text": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "old_line_content": "}",
          "new_line_content": "                return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "d(\"data\"sv, static_cast<DOM::Comm",
          "old_line_content": "        });",
          "new_line_content": "        MUST(object.add(\"type\"sv, \"comment\"sv));",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": null,
          "new_api": "is<Element>(*node)",
          "old_text": null,
          "new_text": "is<Element>(*node)",
          "old_line_content": "// https://dom.spec.whatwg.org/#concept-node-insert",
          "new_line_content": "        } else if (is<Element>(*node)) {",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": null,
          "new_api": "child->has_following_node_of_type_in_tree_order<DocumentType>()",
          "old_text": null,
          "new_text": "child->has_following_node_of_type_in_tree_order<DocumentType>()",
          "old_line_content": "void Node::insert_before(NonnullRefPtr<Node> node, RefPtr<Node> child, bool suppress_observers)",
          "new_line_content": "            if (has_child_of_type<Element>() || is<DocumentType>(child.ptr()) || (child && child->has_following_node_of_type_in_tree_order<DocumentType>()))",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": null,
          "new_api": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "old_text": null,
          "new_text": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "old_line_content": "{",
          "new_line_content": "                return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": null,
          "new_api": "is<DocumentType>(*node)",
          "old_text": null,
          "new_text": "is<DocumentType>(*node)",
          "old_line_content": "    NonnullRefPtrVector<Node> nodes;",
          "new_line_content": "        } else if (is<DocumentType>(*node)) {",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": null,
          "new_api": "if (has_child_nodes()) {\n        auto child",
          "old_text": null,
          "new_text": "   if (has_child_nodes()) {\n        auto child",
          "old_line_content": "",
          "new_line_content": "        MUST(object.add(\"data\"sv, static_cast<DOM::Comment const&>(*this).data()));",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": null,
          "new_api": "is_uninteresting_whitespace_node",
          "old_text": null,
          "new_text": " if (child.is_uninteresting_whitespace_node())\n                return;\n            JsonObjectSerializer<StringBuilder> child_object = MUST(children.add_object());\n            child.serialize_tree_as_json(child_object);\n            MUST(child_object.finish());\n        });\n\n        // Pseudo-elements don't have DOM nodes,so we h",
          "old_line_content": "        }",
          "new_line_content": "        for_each_child([&children](DOM::Node& child) {",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": null,
          "new_api": "return;\n            JsonObjectSerializer",
          "old_text": null,
          "new_text": "return;\n            JsonObjectSerializer",
          "old_line_content": "",
          "new_line_content": "            if (child.is_uninteresting_whitespace_node())",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": null,
          "new_api": "s_json",
          "old_text": null,
          "new_text": "s_json(child_object);",
          "old_line_content": "    }",
          "new_line_content": "            JsonObjectSerializer<StringBuilder> child_object = MUST(children.add_object());",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": null,
          "new_api": "finish",
          "old_text": null,
          "new_text": "ST(child_object.finish());\n        });\n\n  ",
          "old_line_content": "}",
          "new_line_content": "            child.serialize_tree_as_json(child_object);",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": null,
          "new_api": "ments don't have DOM",
          "old_text": null,
          "new_text": "ments don't have DOM ",
          "old_line_content": "",
          "new_line_content": "            MUST(child_object.finish());",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": null,
          "new_api": "ast<DOM::Ele",
          "old_text": null,
          "new_text": "ast<DOM::Ele",
          "old_line_content": "    // FIXME: or when scripting is disabled for its relevant settings object.",
          "new_line_content": "        if (is_element()) {",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": null,
          "new_api": "finish",
          "old_text": null,
          "new_text": "    }\n\n        MUST(children.finish());\n    }\n}\n\n// ",
          "old_line_content": "}",
          "new_line_content": "            element->serialize_pseudo_elements_as_json(children);",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": null,
          "new_api": "rg/multipage/weba",
          "old_text": null,
          "new_text": "rg/multipage/weba",
          "old_line_content": "bool Node::contains(RefPtr<Node> other) const",
          "new_line_content": "        MUST(children.finish());",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": null,
          "new_api": "is<DocumentFragment>(*node)",
          "old_text": null,
          "new_text": "is<DocumentFragment>(*node)",
          "old_line_content": "    }",
          "new_line_content": "    if (is<DocumentFragment>(*node))",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": null,
          "new_api": "children_as_vector",
          "old_text": null,
          "new_text": "verify_cast<DocumentFragment>(*node).children_as_vector()",
          "old_line_content": "",
          "new_line_content": "        nodes = verify_cast<DocumentFragment>(*node).children_as_vector();",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "nodes.append(node)",
          "old_line_content": "        // FIXME: For each live range whose start node is parent and start offset is greater than child’s index, increase its start offset by count.",
          "new_line_content": "        nodes.append(node);",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "nodes.size()",
          "old_line_content": "    }",
          "new_line_content": "    auto count = nodes.size();",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": null,
          "new_api": "is<DocumentFragment>(*node)",
          "old_text": null,
          "new_text": "is<DocumentFragment>(*node)",
          "old_line_content": "    for (auto& node_to_insert : nodes) { // FIXME: In tree order",
          "new_line_content": "    if (is<DocumentFragment>(*node)) {",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": null,
          "new_api": "<ShadowRoot>(root()))",
          "old_text": null,
          "new_text": "<ShadowRoot>(root()))\n ",
          "old_line_content": "// https://dom.spec.whatwg.org/#concept-shadow-including-inclusive-descendant",
          "new_line_content": "    if (is_descendant_of(other))",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": null,
          "new_api": "nherit",
          "old_text": null,
          "new_text": "nherit",
          "old_line_content": "// https://dom.spec.whatwg.org/#concept-shadow-including-ancestor",
          "new_line_content": "    auto& shadow_root = verify_cast<ShadowRoot>(root());",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": null,
          "new_api": "ode>::append_child(node_to_insert);",
          "old_text": null,
          "new_text": "ode>::append_child(node_to_insert);\n        ",
          "old_line_content": "                // FIXME: If inclusiveDescendant is custom, then enqueue a custom element callback reaction with inclusiveDescendant,",
          "new_line_content": "            TreeNode<Node>::append_child(node_to_insert);",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": null,
          "new_api": "ode>::insert_before(node_to_insert, child);",
          "old_text": null,
          "new_text": "ode>::insert_before(node_to_insert, child);\n\n       ",
          "old_line_content": "",
          "new_line_content": "            TreeNode<Node>::insert_before(node_to_insert, child);",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": null,
          "new_api": "for_each_in_inclusive_subtree",
          "old_text": null,
          "new_text": ".for_each_in_inclusive_subtree([&](Node& inclusive_descendant) {\n            inclusive_descendant.inserted();\n            if (inclusive_descendant.is_connected()) {\n                // FIXME: If inclusiveDescendant is custom, then enqueue a custom element callback reaction with inclusiveDescendant,\n                //        callback name \"connectedCallback\", and an empty argument list.\n\n                // FIXME: Otherwise, try to upgrade inclusiveDescendant.\n            }\n\n            return IterationDecision::Continue;\n        });\n    }\n\n    i",
          "old_line_content": "",
          "new_line_content": "        node_to_insert.for_each_in_inclusive_subtree([&](Node& inclusive_descendant) {",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": null,
          "new_api": "inserted",
          "old_text": null,
          "new_text": "endant.inserted();\n            ",
          "old_line_content": "    if (!suppress_observers) {",
          "new_line_content": "            inclusive_descendant.inserted();",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": null,
          "new_api": "is_connected",
          "old_text": null,
          "new_text": "endant.is_connected()) {\n          ",
          "old_line_content": "        // FIXME: queue a tree mutation record for parent with nodes, « », previousSibling, and child.",
          "new_line_content": "            if (inclusive_descendant.is_connected()) {",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": null,
          "new_api": "s://dom.spec.whatwg.org/#concept-shadow-includ",
          "old_text": null,
          "new_text": "s://dom.spec.whatwg.org/#concept-shadow-includ",
          "old_line_content": "    // FIXME: Let removedNodes be parent’s children. (Current unused so not included)",
          "new_line_content": "    return other.is_shadow_including_descendant_of(*this);",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": null,
          "new_api": "}\n\n// https://dom.spec.whatwg.org/#concept-node-replace-",
          "old_text": null,
          "new_text": "}\n\n// https://dom.spec.whatwg.org/#concept-node-replace-",
          "old_line_content": "",
          "new_line_content": "    return other.is_shadow_including_inclusive_descendant_of(*this);",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": null,
          "new_api": "();\n\n    document(",
          "old_text": null,
          "new_text": "();\n\n    document(",
          "old_line_content": "    auto reference_child = child;",
          "new_line_content": "    children_changed();",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": null,
          "new_api": "*node, nullptr, true);",
          "old_text": null,
          "new_text": "*node, nullptr, true);\n\n ",
          "old_line_content": "",
          "new_line_content": "    remove_all_children(true);",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": null,
          "new_api": "tion_validity",
          "old_text": null,
          "new_text": "tion_validity(node, child);\n    if (validi",
          "old_line_content": "// https://dom.spec.whatwg.org/#dom-node-removechild",
          "new_line_content": "    auto validity_result = ensure_pre_insertion_validity(node, child);",
          "content_same": false
        },
        {
          "line": 357,
          "old_api": null,
          "new_api": "is_exception",
          "old_text": null,
          "new_text": "is_exception())\n        return",
          "old_line_content": "ExceptionOr<NonnullRefPtr<Node>> Node::remove_child(NonnullRefPtr<Node> child)",
          "new_line_content": "    if (validity_result.is_exception())",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": null,
          "new_api": "exception",
          "old_text": null,
          "new_text": "exception();\n\n    auto refe",
          "old_line_content": "{",
          "new_line_content": "        return validity_result.exception();",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": null,
          "new_api": "dedNodes or removedNodes is not emp",
          "old_text": null,
          "new_text": "dedNodes or removedNodes is not emp",
          "old_line_content": "",
          "new_line_content": "        insert_before(*node, nullptr, true);",
          "content_same": false
        },
        {
          "line": 362,
          "old_api": null,
          "new_api": "ng",
          "old_text": null,
          "new_text": "ng();\n\n    insert_be",
          "old_line_content": "// https://dom.spec.whatwg.org/#concept-node-pre-remove",
          "new_line_content": "        reference_child = node->next_sibling();",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": null,
          "new_api": "de, reference_child);\n    return nod",
          "old_text": null,
          "new_text": "de, reference_child);\n    return nod",
          "old_line_content": "{",
          "new_line_content": "    insert_before(node, reference_child);",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": null,
          "new_api": "t",
          "old_text": null,
          "new_text": "t(), string);\n\n  ",
          "old_line_content": "    //        (We currently always do this)",
          "new_line_content": "    if (!string.is_empty())",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": null,
          "new_api": "fragment-serializ",
          "old_text": null,
          "new_text": "fragment-serializ",
          "old_line_content": "    // FIXME: Otherwise, context document is an XML document; return an XML serialization of node passing the flag require well-formed.",
          "new_line_content": "    replace_all(node);",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": null,
          "new_api": ");\n}\n\n// https://",
          "old_text": null,
          "new_text": ");\n}\n\n// https://",
          "old_line_content": "}",
          "new_line_content": "    return pre_remove(child);",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": null,
          "new_api": "!= this)",
          "old_text": null,
          "new_text": "!= this)\n      ",
          "old_line_content": "}",
          "new_line_content": "    if (child->parent() != this)",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": null,
          "new_api": "or::create(\"Child does not belong to this node\");\n\n    child->re",
          "old_text": null,
          "new_text": "or::create(\"Child does not belong to this node\");\n\n    child->re",
          "old_line_content": "",
          "new_line_content": "        return DOM::NotFoundError::create(\"Child does not belong to this node\");",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": null,
          "new_api": "Otherwise, context document is an XML document;",
          "old_text": null,
          "new_text": " Otherwise, context document is an XML document;",
          "old_line_content": "bool Node::is_equal_node(Node const* other_node) const",
          "new_line_content": "    return HTML::HTMLParser::serialize_html_fragment(*this);",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": null,
          "new_api": "return ch",
          "old_text": null,
          "new_text": "\n\n    return ch",
          "old_line_content": "void Node::remove(bool suppress_observers)",
          "new_line_content": "    child->remove();",
          "content_same": false
        },
        {
          "line": 388,
          "old_api": null,
          "new_api": "nullptr);\n}\n\n// https://",
          "old_text": null,
          "new_text": " nullptr);\n}\n\n// https://",
          "old_line_content": "    // FIXME: For each live range whose end node is an inclusive descendant of node, set its end to (parent, index).",
          "new_line_content": "    return pre_insert(node, nullptr);",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": null,
          "new_api": "// FIXME:",
          "old_text": null,
          "new_text": "\n    // FIXME:",
          "old_line_content": "    });",
          "new_line_content": "    VERIFY(parent);",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": null,
          "new_api": "wing are equal, switchi",
          "old_text": null,
          "new_text": "wing are equal, switchi",
          "old_line_content": "            return false;",
          "new_line_content": "    if (node_name() != other_node->node_name())",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": null,
          "new_api": "run_pre_removing_steps",
          "old_text": null,
          "new_text": "de_iterator([&](NodeIterator& node_iterator) {\n        node_iterator.run_pre_removing_steps(*this);\n    });\n\n    // FIXME: Let o",
          "old_line_content": "",
          "new_line_content": "    document().for_each_node_iterator([&](NodeIterator& node_iterator) {",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": null,
          "new_api": "removing_steps",
          "old_text": null,
          "new_text": "removing_steps(*this);\n    });\n\n    // FIXM",
          "old_line_content": "    // FIXME: If node has an inclusive descendant that is a slot, then:",
          "new_line_content": "        node_iterator.run_pre_removing_steps(*this);",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "// Its",
          "old_text": null,
          "new_text": "     // Its",
          "old_line_content": "        // Its namespace, namespace prefix, local name, and its attribute list’s size.",
          "new_line_content": "    switch (node_type()) {",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": null,
          "new_api": "// FIXME: If node i",
          "old_text": null,
          "new_text": "  // FIXME: If node i",
          "old_line_content": "    // FIXME: Let isParentConnected be parent’s connected. (Currently unused so not included)",
          "new_line_content": "    parent->TreeNode::remove_child(*this);",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": null,
          "new_api": "ak;\n    }\n    case (u16)N",
          "old_text": null,
          "new_text": "ak;\n    }\n    case (u16)N",
          "old_line_content": "            return false;",
          "new_line_content": "            || this_doctype.system_id() != other_doctype.system_id())",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": null,
          "new_api": "cast<Element>(*other_node);",
          "old_text": null,
          "new_text": "cast<Element>(*other_node);",
          "old_line_content": "        });",
          "new_line_content": "        auto& this_element = verify_cast<Element>(*this);",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": null,
          "new_api": "XME: Let isParentCon",
          "old_text": null,
          "new_text": "XME: Let isParentCon",
          "old_line_content": "        //        callback name \"disconnectedCallback\", and an empty argument list.",
          "new_line_content": "    removed_from(parent);",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": null,
          "new_api": "ace_",
          "old_text": null,
          "new_text": "ace_() != other_element.namespace",
          "old_line_content": "        if (!has_same_attributes)",
          "new_line_content": "        auto& other_element = verify_cast<Element>(*other_node);",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": null,
          "new_api": "prefix",
          "old_text": null,
          "new_text": " other_element.prefix()\n  ",
          "old_line_content": "            return false;",
          "new_line_content": "        if (this_element.namespace_() != other_element.namespace_()",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "other_element.local_n",
          "old_text": null,
          "new_text": " other_element.local_n",
          "old_line_content": "        break;",
          "new_line_content": "            || this_element.prefix() != other_element.prefix()",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": null,
          "new_api": "ist_size",
          "old_text": null,
          "new_text": "ist_size() != other_elemen",
          "old_line_content": "    }",
          "new_line_content": "            || this_element.local_name() != other_element.local_name()",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "// If A is an element, each at",
          "old_text": null,
          "new_text": "     // If A is an element, each at",
          "old_line_content": "    case (u16)NodeType::COMMENT_NODE:",
          "new_line_content": "            || this_element.attribute_list_size() != other_element.attribute_list_size())",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": null,
          "new_api": "removed_from",
          "old_text": null,
          "new_text": "endant) {\n        descendant.removed_from(nullptr);\n\n        // FIXME: If descendant is custom and isParentConnected is true, then enqueue a custom element callback reaction with descendant,\n        //        callback name \"disconnectedCallback\", and an empty argument list.\n\n        return IterationDecision::Continue;\n    });\n\n    if (!suppress_observers) {\n",
          "old_line_content": "",
          "new_line_content": "    for_each_in_subtree([&](Node& descendant) {",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": null,
          "new_api": "y_cast<CharacterData>(*other_node",
          "old_text": null,
          "new_text": "y_cast<CharacterData>(*other_node",
          "old_line_content": "",
          "new_line_content": "        auto& this_cdata = verify_cast<CharacterData>(*this);",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "() != other_cdata.data())\n            r",
          "old_line_content": "    // A and B have the same number of children.",
          "new_line_content": "        auto& other_cdata = verify_cast<CharacterData>(*other_node);",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": null,
          "new_api": "ttps://dom.spec.whatwg.org/#c",
          "old_text": null,
          "new_text": "ttps://dom.spec.whatwg.org/#c",
          "old_line_content": "",
          "new_line_content": "    document().invalidate_style();",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": null,
          "new_api": "ame nu",
          "old_text": null,
          "new_text": "ame nu",
          "old_line_content": "    // FIXME: This can be made nicer. child_at_index() is O(n).",
          "new_line_content": "        TODO();",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": null,
          "new_api": "n only insert into a document, document fragment or element\");\n\n    if (node->is_host_including_inc",
          "old_text": null,
          "new_text": "n only insert into a document, document fragment or element\");\n\n    if (node->is_host_including_inc",
          "old_line_content": "",
          "new_line_content": "        return DOM::HierarchyRequestError::create(\"Can only insert into a document, document fragment or element\");",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "w node is an ancestor of this node\");\n\n    if (child->parent() != this)\n  ",
          "old_line_content": "",
          "new_line_content": "        return DOM::HierarchyRequestError::create(\"New node is an ancestor of this node\");",
          "content_same": false
        },
        {
          "line": 968,
          "old_api": null,
          "new_api": "ount)\n        return fals",
          "old_text": null,
          "new_text": "ount)\n        return fals",
          "old_line_content": "            return false;",
          "new_line_content": "    size_t other_child_count = other_node->child_count();",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": null,
          "new_api": "return DOM::HierarchyRequest",
          "old_text": null,
          "new_text": "    return DOM::HierarchyRequest",
          "old_line_content": "            }",
          "new_line_content": "    if (!is<DocumentFragment>(*node) && !is<DocumentType>(*node) && !is<Element>(*node) && !is<Text>(*node) && !is<Comment>(*node) && !is<ProcessingInstruction>(*node))",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": null,
          "new_api": "index",
          "old_text": null,
          "new_text": "index(i);\n       ",
          "old_line_content": "bool Node::in_a_document_tree() const",
          "new_line_content": "        auto* this_child = child_at_index(i);",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": null,
          "new_api": "ERIFY",
          "old_text": null,
          "new_text": "ERIFY(other_child);\n        i",
          "old_line_content": "{",
          "new_line_content": "        auto* other_child = other_node->child_at_index(i);",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": null,
          "new_api": "hild->is_equal_nod",
          "old_text": null,
          "new_text": "hild->is_equal_nod",
          "old_line_content": "    // An element is in a document tree if its root is a document.",
          "new_line_content": "        VERIFY(this_child);",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": null,
          "new_api": "}\n\n    return true;\n}\n\n// https://do",
          "old_text": null,
          "new_text": "  }\n\n    return true;\n}\n\n// https://do",
          "old_line_content": "}",
          "new_line_content": "        if (!this_child->is_equal_node(other_child))",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": null,
          "new_api": "auto node_element_chil",
          "old_text": null,
          "new_text": "     auto node_element_chil",
          "old_line_content": "        }",
          "new_line_content": "        if (is<DocumentFragment>(*node)) {",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": null,
          "new_api": "hild_element_count",
          "old_text": null,
          "new_text": "hild_element_count();\n            if ((node_element_child_",
          "old_line_content": "    }",
          "new_line_content": "            auto node_element_child_count = verify_cast<DocumentFragment>(*node).child_element_count();",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": null,
          "new_api": "|| (node_element_chi",
          "old_text": null,
          "new_text": "           || (node_element_chi",
          "old_line_content": "",
          "new_line_content": "            if ((node_element_child_count > 1 || node->has_child_of_type<Text>())",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": null,
          "new_api": "valid node type for insertion\");\n            }\n        } else if (is<",
          "old_text": null,
          "new_text": "valid node type for insertion\");\n            }\n        } else if (is<",
          "old_line_content": "    if (reference_child == node)",
          "new_line_content": "                return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": null,
          "new_api": "first_child_of_typ",
          "old_text": null,
          "new_text": "first_child_of_typ",
          "old_line_content": "",
          "new_line_content": "        } else if (is<Element>(*node)) {",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": null,
          "new_api": "ree_order<DocumentType>())\n                return DOM::Hierarch",
          "old_text": null,
          "new_text": "ree_order<DocumentType>())\n                return DOM::Hierarch",
          "old_line_content": "    // FIXME: Let previousSibling be child’s previous sibling. (Currently unused so not included)",
          "new_line_content": "            if (first_child_of_type<Element>() != child || child->has_following_node_of_type_in_tree_order<DocumentType>())",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": null,
          "new_api": "valid node type for insertion\");\n        } else if (is<DocumentType>(",
          "old_text": null,
          "new_text": "valid node type for insertion\");\n        } else if (is<DocumentType>(",
          "old_line_content": "    // FIXME: Let removedNodes be the empty set. (Currently unused so not included)",
          "new_line_content": "                return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "content_same": false
        },
        {
          "line": 479,
          "old_api": null,
          "new_api": "if (first_child_of_typ",
          "old_text": null,
          "new_text": " if (first_child_of_typ",
          "old_line_content": "",
          "new_line_content": "        } else if (is<DocumentType>(*node)) {",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": null,
          "new_api": "trootnode\nNonnullRef",
          "old_text": null,
          "new_text": "trootnode\nNonnullRef",
          "old_line_content": "",
          "new_line_content": "    return root().is_document();",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": null,
          "new_api": "valid node type for insertion\");\n        }\n    }\n\n    auto reference_",
          "old_text": null,
          "new_text": "valid node type for insertion\");\n        }\n    }\n\n    auto reference_",
          "old_line_content": "        // FIXME: Set removedNodes to « child ».",
          "new_line_content": "                return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": null,
          "new_api": "ce_child == node)",
          "old_text": null,
          "new_text": "ce_child == node)\n   ",
          "old_line_content": "    // FIXME: Let nodes be node’s children if node is a DocumentFragment node; otherwise « node ». (Currently unused so not included)",
          "new_line_content": "    auto reference_child = child->next_sibling();",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": null,
          "new_api": "removedNodes t",
          "old_text": null,
          "new_text": " removedNodes t",
          "old_line_content": "}",
          "new_line_content": "    if (child->parent()) {",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": null,
          "new_api": "Let nodes be node’s",
          "old_text": null,
          "new_text": "Let nodes be node’s",
          "old_line_content": "// https://dom.spec.whatwg.org/#concept-node-clone",
          "new_line_content": "        child->remove(true);",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": null,
          "new_api": "nt = static_cast<DOM::Elem",
          "old_text": null,
          "new_text": "nt = static_cast<DOM::Elem",
          "old_line_content": "size_t Node::length() const",
          "new_line_content": "    builder.append(node_name().to_lowercase());",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": null,
          "new_api": "(*this);",
          "old_text": null,
          "new_text": "(*this);\n   ",
          "old_line_content": "{",
          "new_line_content": "    if (is_element()) {",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": null,
          "new_api": "et_attribute",
          "old_text": null,
          "new_text": "et_attribute(HTML::AttributeNames::id);",
          "old_line_content": "    // 1. If node is a DocumentType or Attr node, then return 0.",
          "new_line_content": "        auto& element = static_cast<DOM::Element const&>(*this);",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": null,
          "new_api": "class_names",
          "old_text": null,
          "new_text": "nt.class_names())\n         ",
          "old_line_content": "        return 0;",
          "new_line_content": "            builder.appendff(\"#{}\", id);",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": null,
          "new_api": "// FIXME: Queue a tree mutation record",
          "old_text": null,
          "new_text": "   // FIXME: Queue a tree mutation record ",
          "old_line_content": "    RefPtr<Node> copy;",
          "new_line_content": "    insert_before(node, reference_child, true);",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": null,
          "new_api": "}\n    return buil",
          "old_text": null,
          "new_text": "    }\n    return buil",
          "old_line_content": "",
          "new_line_content": "        for (auto const& class_name : element.class_names())",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": null,
          "new_api": ");\n}\n\n// https://dom.spec.whatwg.or",
          "old_text": null,
          "new_text": ");\n}\n\n// https://dom.spec.whatwg.or",
          "old_line_content": "    // 2. If node is a CharacterData node, then return node’s data’s length.",
          "new_line_content": "            builder.appendff(\".{}\", class_name);",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": null,
          "new_api": "node, then ret",
          "old_text": null,
          "new_text": "node, then ret",
          "old_line_content": "",
          "new_line_content": "    if (is_document_type() || is_attribute())",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1024,
          "old_api": "}\n\nPainting::",
          "new_api": null,
          "old_text": "}\n\nPainting::",
          "new_text": null,
          "old_line_content": "    if (!layout_node())",
          "new_line_content": "    // 2. If node is a CharacterData node, then return node’s data’s length.",
          "content_same": false
        },
        {
          "line": 517,
          "old_api": "ment_type_copy = adopt_ref(*new",
          "new_api": null,
          "old_text": "ment_type_copy = adopt_ref(*new",
          "new_text": null,
          "old_line_content": "        auto document_type = verify_cast<DocumentType>(this);",
          "new_line_content": "        });",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": "(!layout_node",
          "new_api": null,
          "old_text": "(!layout_node",
          "new_text": null,
          "old_line_content": "    return child_count();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": "::Box const&>(*layout_n",
          "new_api": null,
          "old_text": "::Box const&>(*layout_n",
          "new_text": null,
          "old_line_content": "    if (!layout_node()->is_box())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "    return static_cast<Layout::Box const&>(*layout_node()).paint_box();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": "{\n        auto",
          "new_api": null,
          "old_text": " {\n        auto",
          "new_text": null,
          "old_line_content": "        copy = move(text_copy);",
          "new_line_content": "        // FIXME: Set type (\"xml\" or \"html\")",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": "r::create(\"Cannot clo",
          "new_api": null,
          "old_text": "r::create(\"Cannot clo",
          "new_text": null,
          "old_line_content": "    if (is<ShadowRoot>(*this))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": "return clone_node(nullptr, deep);\n}\n\nvoid Node::",
          "new_api": null,
          "old_text": "\n    return clone_node(nullptr, deep);\n}\n\nvoid Node::",
          "new_text": null,
          "old_line_content": "        return NotSupportedError::create(\"Cannot clone shadow root\");",
          "new_line_content": "    if (clone_children) {",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "_node",
          "new_api": null,
          "old_text": "_node({});\n    m_document ",
          "new_text": null,
          "old_line_content": "    document.ref_from_node({});",
          "new_line_content": "ExceptionOr<NonnullRefPtr<Node>> Node::clone_node_binding(bool deep)",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": "ument;\n\n    if (needs_style_upd",
          "new_api": null,
          "old_text": "ument;\n\n    if (needs_style_upd",
          "new_text": null,
          "old_line_content": "    m_document->unref_from_node({});",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "_update",
          "new_api": null,
          "old_text": "_update(true);\n    }\n}\n\nbool ",
          "new_text": null,
          "old_line_content": "        set_needs_style_update(false);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "ditable",
          "new_api": null,
          "old_text": "ditable() const\n{\n    return",
          "new_text": null,
          "old_line_content": "        set_needs_style_update(true);",
          "new_line_content": "    if (m_document == &document)",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": "rapper",
          "new_api": null,
          "old_text": "rapper(JS::GlobalObject",
          "new_text": null,
          "old_line_content": "    return parent() && parent()->is_editable();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": "this).removed_last_",
          "new_api": null,
          "old_text": "this).removed_last_",
          "new_text": null,
          "old_line_content": "    if (is<Document>(*this)) {",
          "new_line_content": "bool Node::is_editable() const",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": "return;\n    }\n    m_deletion_has_begun = tru",
          "new_api": null,
          "old_text": "   return;\n    }\n    m_deletion_has_begun = tru",
          "new_text": null,
          "old_line_content": "        verify_cast<Document>(*this).removed_last_ref();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "t_node = nullptr;\n}\n\nEventTa",
          "new_api": null,
          "old_text": "t_node = nullptr;\n}\n\nEventTa",
          "new_text": null,
          "old_line_content": "        m_layout_node = layout_node->make_weak_ptr();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "{\n    i",
          "new_api": null,
          "old_text": "\n{\n    i",
          "new_text": null,
          "old_line_content": "    return parent();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": ">m_child_needs_style_update = tru",
          "new_api": null,
          "old_text": ">m_child_needs_style_update = tru",
          "new_text": null,
          "old_line_content": "        for (auto* ancestor = parent_or_shadow_host(); ancestor; ancestor = ancestor->parent_or_shadow_host()) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": "serted",
          "new_api": null,
          "old_text": "serted()\n{\n    set_needs_style_upd",
          "new_text": null,
          "old_line_content": "        document().schedule_style_update();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": "or_shadow_host",
          "new_api": null,
          "old_text": "or_shadow_host()\n{\n    if (i",
          "new_text": null,
          "old_line_content": "    set_needs_style_update(true);",
          "new_line_content": "    m_needs_style_update = value;",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": "host",
          "new_api": null,
          "old_text": "ot>(*this).host();\n  ",
          "new_text": null,
          "old_line_content": "    if (is<ShadowRoot>(*this))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": "{\n    //",
          "new_api": null,
          "old_text": "{\n    //",
          "new_text": null,
          "old_line_content": "    return verify_cast<ParentNode>(parent());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": "eturn is_parent_of(node);\n    });\n}\n\nNonnullRefPtrVector<Node> Node::children_as_vector()",
          "new_api": null,
          "old_text": "eturn is_parent_of(node);\n    });\n}\n\nNonnullRefPtrVector<Node> Node::children_as_vector() ",
          "new_text": null,
          "old_line_content": "    return LiveNodeList::create(*this, [this](auto& node) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": "ode::children_as_v",
          "new_api": null,
          "old_text": "ode::children_as_v",
          "new_text": null,
          "old_line_content": "        return is_parent_of(node);",
          "new_line_content": "ParentNode* Node::parent_or_shadow_host()",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": "ld);\n    });\n\n    return nodes;\n}\n\nvoid Node::remove_all_children(boo",
          "new_api": null,
          "old_text": "ld);\n    });\n\n    return nodes;\n}\n\nvoid Node::remove_all_children(boo",
          "new_text": null,
          "old_line_content": "    for_each_child([&](auto& child) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": "de::remove_all_chil",
          "new_api": null,
          "old_text": "de::remove_all_chil",
          "new_text": null,
          "old_line_content": "        nodes.append(child);",
          "new_line_content": "    // FIXME: This should return the same LiveNodeList object every time,",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": "}\n\n// https:/",
          "new_api": null,
          "old_text": "}\n\n// https:/",
          "new_text": null,
          "old_line_content": "    while (RefPtr<Node> child = first_child())",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": "whatwg.org/#dom-node-comparedocum",
          "new_api": null,
          "old_text": "whatwg.org/#dom-node-comparedocum",
          "new_text": null,
          "old_line_content": "        child->remove(suppress_observers);",
          "new_line_content": "    NonnullRefPtrVector<Node> nodes;",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": "ibWeb suppo",
          "new_api": null,
          "old_text": "ibWeb suppo",
          "new_text": null,
          "old_line_content": "    Node* node1 = other.ptr();",
          "new_line_content": "        DOCUMENT_POSITION_EQUAL = 0,",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": "1 == nullptr",
          "new_api": null,
          "old_text": "1 == nullptr ",
          "new_text": null,
          "old_line_content": "    VERIFY(node1->type() != NodeType::ATTRIBUTE_NODE && node2->type() != NodeType::ATTRIBUTE_NODE);",
          "new_line_content": "        DOCUMENT_POSITION_CONTAINS = 8,",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": "TED | DOCUMEN",
          "new_api": null,
          "old_text": "TED | DOCUMEN",
          "new_text": null,
          "old_line_content": "    if ((node1 == nullptr || node2 == nullptr) || (&node1->root() != &node2->root()))",
          "new_line_content": "        DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32,",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": "ITION_CONTAINS | DOCUMENT_POS",
          "new_api": null,
          "old_text": "ITION_CONTAINS | DOCUMENT_POS",
          "new_text": null,
          "old_line_content": "    if (node1->is_ancestor_of(*node2))",
          "new_line_content": "    if (this == other)",
          "content_same": false
        },
        {
          "line": 180,
          "old_api": "set_needs_style_update",
          "new_api": null,
          "old_text": "element.set_needs_style_update(true)",
          "new_text": null,
          "old_line_content": "        element.set_needs_style_update(true);",
          "new_line_content": "        node.m_needs_style_update = true;",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": "_PRECEDING;\n    else",
          "new_api": null,
          "old_text": "_PRECEDING;\n    else\n   ",
          "new_text": null,
          "old_line_content": "    if (node1->is_before(*node2))",
          "new_line_content": "    // FIXME: Once LibWeb supports attribute nodes fix to follow the specification.",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": "enclosing_link_element",
          "new_api": null,
          "old_text": "enclosing_link_element()",
          "new_text": null,
          "old_line_content": "    return enclosing_link_element();",
          "new_line_content": "        return IterationDecision::Continue;",
          "content_same": false
        },
        {
          "line": 193,
          "old_api": "is<ParentNode>(*this)",
          "new_api": null,
          "old_text": "is<ParentNode>(*this)",
          "new_text": null,
          "old_line_content": "    if (!is<ParentNode>(*this))",
          "new_line_content": "        ancestor->m_child_needs_style_update = true;",
          "content_same": false
        },
        {
          "line": 194,
          "old_api": "String::empty()",
          "new_api": null,
          "old_text": "String::empty()",
          "new_text": null,
          "old_line_content": "        return String::empty();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": "t&>(other.ro",
          "new_api": null,
          "old_text": "t&>(other.ro",
          "new_text": null,
          "old_line_content": "    if (is<DocumentFragment>(other.root())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": "for_each_child",
          "new_api": null,
          "old_text": "verify_cast<ParentNode>(*this).for_each_child([&](auto& child) {\n        if (is<Text>(child))\n            builder.append(verify_cast<Text>(child).text_content());\n    })",
          "new_text": null,
          "old_line_content": "    verify_cast<ParentNode>(*this).for_each_child([&](auto& child) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 198,
          "old_api": "is<Text>(child)",
          "new_api": null,
          "old_text": "is<Text>(child)",
          "new_text": null,
          "old_line_content": "        if (is<Text>(child))",
          "new_line_content": "bool Node::is_link() const",
          "content_same": false
        },
        {
          "line": 199,
          "old_api": "text_content",
          "new_api": null,
          "old_text": "verify_cast<Text>(child).text_content()",
          "new_text": null,
          "old_line_content": "            builder.append(verify_cast<Text>(child).text_content());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": "turn false;",
          "new_api": null,
          "old_text": "turn false;\n",
          "new_text": null,
          "old_line_content": "        && is_inclusive_ancestor_of(*static_cast<DocumentFragment const&>(other.root()).host())) {",
          "new_line_content": "        return DOCUMENT_POSITION_PRECEDING;",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": "build",
          "new_api": null,
          "old_text": "builder.build()",
          "new_text": null,
          "old_line_content": "    return builder.build();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": "nt;\n}\n\n// Thi",
          "new_api": null,
          "old_text": "nt;\n}\n\n// Thi",
          "new_text": null,
          "old_line_content": "    if (is_document())",
          "new_line_content": "        return true;",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": "parent",
          "new_api": null,
          "old_text": "root->parent()",
          "new_text": null,
          "old_line_content": "    while (root->parent())",
          "new_line_content": "    StringBuilder builder;",
          "content_same": false
        },
        {
          "line": 216,
          "old_api": "root",
          "new_api": null,
          "old_text": "root()",
          "new_text": null,
          "old_line_content": "    auto& node_root = root();",
          "new_line_content": "// https://dom.spec.whatwg.org/#concept-tree-root",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": "is<ShadowRoot>(node_root)",
          "new_api": null,
          "old_text": "is<ShadowRoot>(node_root)",
          "new_text": null,
          "old_line_content": "    if (is<ShadowRoot>(node_root))",
          "new_line_content": "Node& Node::root()",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": "host",
          "new_api": null,
          "old_text": "verify_cast<ShadowRoot>(node_root).host()->shadow_including_root()",
          "new_text": null,
          "old_line_content": "        return verify_cast<ShadowRoot>(node_root).host()->shadow_including_root();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": "t<Text const&>(",
          "new_api": null,
          "old_text": "t<Text const&>(",
          "new_text": null,
          "old_line_content": "    if (!is<Text>(*this))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": "return false;\n    if (!layout_node())\n        re",
          "new_api": null,
          "old_text": "      return false;\n    if (!layout_node())\n        re",
          "new_text": null,
          "old_line_content": "    if (!static_cast<Text const&>(*this).data().is_whitespace())",
          "new_line_content": "        return nullptr;",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": ">parent()->is",
          "new_api": null,
          "old_text": ">parent()->is",
          "new_text": null,
          "old_line_content": "    if (!layout_node())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": "ue;\n    return false;\n}\n\nvoid Node::ser",
          "new_api": null,
          "old_text": "ue;\n    return false;\n}\n\nvoid Node::ser",
          "new_text": null,
          "old_line_content": "    if (layout_node()->parent()->is_anonymous())",
          "new_line_content": "// This function tells us whether a node is interesting enough to show up",
          "content_same": false
        },
        {
          "line": 225,
          "old_api": "is_document",
          "new_api": null,
          "old_text": "shadow_including_root().is_document()",
          "new_text": null,
          "old_line_content": "    return shadow_including_root().is_document();",
          "new_line_content": "// https://dom.spec.whatwg.org/#concept-shadow-including-root",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "if (is_document(",
          "new_api": null,
          "old_text": "  if (is_document(",
          "new_text": null,
          "old_line_content": "    MUST(object.add(\"name\", node_name().view()));",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": "parent",
          "new_api": null,
          "old_text": "parent()",
          "new_text": null,
          "old_line_content": "    return verify_cast<Element>(parent());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": "\"));\n    } el",
          "new_api": null,
          "old_text": "\"));\n    } el",
          "new_text": null,
          "old_line_content": "    if (is_document()) {",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": ");",
          "new_api": null,
          "old_text": ");\n\n        ",
          "new_text": null,
          "old_line_content": "    } else if (is_element()) {",
          "new_line_content": "        return true;",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": "has_attributes",
          "new_api": null,
          "old_text": "t->has_attributes()) {\n            aut",
          "new_text": null,
          "old_line_content": "        auto const* element = static_cast<DOM::Element const*>(this);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": "parent",
          "new_api": null,
          "old_text": "parent()",
          "new_text": null,
          "old_line_content": "    return verify_cast<Element>(parent());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": "add_object",
          "new_api": null,
          "old_text": " MUST(object.add_object(\"",
          "new_text": null,
          "old_line_content": "        if (element->has_attributes()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": "_each_attribute",
          "new_api": null,
          "old_text": "_each_attribute([&attributes](a",
          "new_text": null,
          "old_line_content": "            auto attributes = MUST(object.add_object(\"attributes\"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "add",
          "new_api": null,
          "old_text": "& value) {\n                MUST(attributes.add(name, value));\n            });\n            MUST(attributes.finish());\n        }\n\n      ",
          "new_text": null,
          "old_line_content": "            element->for_each_attribute([&attributes](auto& name, auto& value) {",
          "new_line_content": "void Node::serialize_tree_as_json(JsonObjectSerializer<StringBuilder>& object) const",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": "finish",
          "new_api": null,
          "old_text": "MUST(attributes.finish());\n",
          "new_text": null,
          "old_line_content": "                MUST(attributes.add(name, value));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": "is<Element>(this)",
          "new_api": null,
          "old_text": "is<Element>(this)",
          "new_text": null,
          "old_line_content": "    if (!is<Document>(this) && !is<DocumentFragment>(this) && !is<Element>(this))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": "DOM::HierarchyRequestError::create(\"Can only insert into a document, document fragment or element\")",
          "new_api": null,
          "old_text": "DOM::HierarchyRequestError::create(\"Can only insert into a document, document fragment or element\")",
          "new_text": null,
          "old_line_content": "        return DOM::HierarchyRequestError::create(\"Can only insert into a document, document fragment or element\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": "is_host_including_inclusive_ancestor_of",
          "new_api": null,
          "old_text": "node->is_host_including_inclusive_ancestor_of(*this)",
          "new_text": null,
          "old_line_content": "    if (node->is_host_including_inclusive_ancestor_of(*this))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "add_array",
          "new_api": null,
          "old_text": "dren = MUST(object.add_array(",
          "new_text": null,
          "old_line_content": "            if (auto const* content_document = container->content_document()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": "DOM::NotFoundError::create(\"This node is not the parent of the given child\")",
          "new_api": null,
          "old_text": "DOM::NotFoundError::create(\"This node is not the parent of the given child\")",
          "new_text": null,
          "old_line_content": "        return DOM::NotFoundError::create(\"This node is not the parent of the given child\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 256,
          "old_api": "is<ProcessingInstruction>(*node)",
          "new_api": null,
          "old_text": "is<ProcessingInstruction>(*node)",
          "new_text": null,
          "old_line_content": "    if (!is<DocumentFragment>(*node) && !is<DocumentType>(*node) && !is<Element>(*node) && !is<Text>(*node) && !is<Comment>(*node) && !is<ProcessingInstruction>(*node))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": "aut",
          "new_api": null,
          "old_text": "      aut",
          "new_text": null,
          "old_line_content": "    } else if (is_text()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "tic_cast<DOM::Text const*>",
          "new_api": null,
          "old_text": "tic_cast<DOM::Text const*>",
          "new_text": null,
          "old_line_content": "        MUST(object.add(\"type\", \"text\"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": "is<Document>(this)",
          "new_api": null,
          "old_text": "is<Document>(this)",
          "new_text": null,
          "old_line_content": "    if ((is<Text>(*node) && is<Document>(this)) || (is<DocumentType>(*node) && !is<Document>(this)))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": "is<Document>(this)",
          "new_api": null,
          "old_text": "is<Document>(this)",
          "new_text": null,
          "old_line_content": "    if (is<Document>(this)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": "node->has_child_of_type<Text>()",
          "new_api": null,
          "old_text": "node->has_child_of_type<Text>()",
          "new_text": null,
          "old_line_content": "            if ((node_element_child_count > 1 || node->has_child_of_type<Text>())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": "child->has_following_node_of_type_in_tree_order<DocumentType>()",
          "new_api": null,
          "old_text": "child->has_following_node_of_type_in_tree_order<DocumentType>()",
          "new_text": null,
          "old_line_content": "                || (node_element_child_count == 1 && (has_child_of_type<Element>() || is<DocumentType>(child.ptr()) || (child && child->has_following_node_of_type_in_tree_order<DocumentType>())))) {",
          "new_line_content": "    // FIXME: All the following \"Invalid node type for insertion\" messages could be more descriptive.",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "new_api": null,
          "old_text": "DOM::HierarchyRequestError::create(\"Invalid node type for insertion\")",
          "new_text": null,
          "old_line_content": "                return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": "dd_array",
          "new_api": null,
          "old_text": "dd_array(\"childre",
          "new_text": null,
          "old_line_content": "    if (has_child_nodes()) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": "ildren](DOM::Node& child) {",
          "new_api": null,
          "old_text": "ildren](DOM::Node& child) {\n",
          "new_text": null,
          "old_line_content": "        auto children = MUST(object.add_array(\"children\"));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": "child->has_following_node_of_type_in_tree_order<DocumentType>()",
          "new_api": null,
          "old_text": "child->has_following_node_of_type_in_tree_order<DocumentType>()",
          "new_text": null,
          "old_line_content": "            if (has_child_of_type<Element>() || is<DocumentType>(child.ptr()) || (child && child->has_following_node_of_type_in_tree_order<DocumentType>()))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": "has_child_of_type<Element>()",
          "new_api": null,
          "old_text": "has_child_of_type<Element>()",
          "new_text": null,
          "old_line_content": "            if (has_child_of_type<DocumentType>() || (child && child->has_preceding_node_of_type_in_tree_order<Element>()) || (!child && has_child_of_type<Element>()))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "ast<DOM::Ele",
          "new_api": null,
          "old_text": "ast<DOM::Ele",
          "new_text": null,
          "old_line_content": "        if (is_element()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": "rg/multipage/weba",
          "new_api": null,
          "old_text": "rg/multipage/weba",
          "new_text": null,
          "old_line_content": "        MUST(children.finish());",
          "new_line_content": "                return;",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": "append",
          "new_api": null,
          "old_text": "nodes.append(node)",
          "new_text": null,
          "old_line_content": "        nodes.append(node);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": "size",
          "new_api": null,
          "old_text": "nodes.size()",
          "new_text": null,
          "old_line_content": "    auto count = nodes.size();",
          "new_line_content": "    return {};",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": "is<DocumentFragment>(*node)",
          "new_api": null,
          "old_text": "is<DocumentFragment>(*node)",
          "new_text": null,
          "old_line_content": "    if (is<DocumentFragment>(*node)) {",
          "new_line_content": "void Node::insert_before(NonnullRefPtr<Node> node, RefPtr<Node> child, bool suppress_observers)",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": "remove_all_children",
          "new_api": null,
          "old_text": "node->remove_all_children(true)",
          "new_text": null,
          "old_line_content": "        node->remove_all_children(true);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": "m.spec.whatwg.org/#concept-shadow-includ",
          "new_api": null,
          "old_text": "m.spec.whatwg.org/#concept-shadow-includ",
          "new_text": null,
          "old_line_content": "    return other && other->is_inclusive_descendant_of(*this);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": "rify_c",
          "new_api": null,
          "old_text": "rify_c",
          "new_text": null,
          "old_line_content": "    if (!is<ShadowRoot>(root()))",
          "new_line_content": "// https://dom.spec.whatwg.org/#dom-node-contains",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "ode>::append_child(node_to_insert);",
          "new_api": null,
          "old_text": "ode>::append_child(node_to_insert);\n        ",
          "new_text": null,
          "old_line_content": "            TreeNode<Node>::append_child(node_to_insert);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "ode>::insert_before(node_to_insert, child);",
          "new_api": null,
          "old_text": "ode>::insert_before(node_to_insert, child);\n\n       ",
          "new_text": null,
          "old_line_content": "            TreeNode<Node>::insert_before(node_to_insert, child);",
          "new_line_content": "        // FIXME: For each live range whose start node is parent and start offset is greater than child’s index, increase its start offset by count.",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": "nt_of",
          "new_api": null,
          "old_text": "nt_of(other);\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-includ",
          "new_text": null,
          "old_line_content": "    return shadow_root.host()->is_shadow_including_inclusive_descendant_of(other);",
          "new_line_content": "// https://dom.spec.whatwg.org/#concept-shadow-including-descendant",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": "inserted",
          "new_api": null,
          "old_text": "endant.inserted();\n            ",
          "new_text": null,
          "old_line_content": "            inclusive_descendant.inserted();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": "is_connected",
          "new_api": null,
          "old_text": "endant.is_connected()) {\n          ",
          "new_text": null,
          "old_line_content": "            if (inclusive_descendant.is_connected()) {",
          "new_line_content": "        if (!child)",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": "();\n\n    document(",
          "new_api": null,
          "old_text": "();\n\n    document(",
          "new_text": null,
          "old_line_content": "    children_changed();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": "idate_style",
          "new_api": null,
          "old_text": "idate_style();\n}\n\n// https://",
          "new_text": null,
          "old_line_content": "    document().invalidate_style();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 853,
          "old_api": "*node, nullptr, true);",
          "new_api": null,
          "old_text": "*node, nullptr, true);\n\n ",
          "new_text": null,
          "old_line_content": "    remove_all_children(true);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": "tion_validity",
          "new_api": null,
          "old_text": "tion_validity(node, child);\n    if (validi",
          "new_text": null,
          "old_line_content": "    auto validity_result = ensure_pre_insertion_validity(node, child);",
          "new_line_content": "    if (!suppress_observers) {",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": "is_exception",
          "new_api": null,
          "old_text": "is_exception())\n        return",
          "new_text": null,
          "old_line_content": "    if (validity_result.is_exception())",
          "new_line_content": "        // FIXME: queue a tree mutation record for parent with nodes, « », previousSibling, and child.",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": "exception",
          "new_api": null,
          "old_text": "exception();\n\n    auto refe",
          "new_text": null,
          "old_line_content": "        return validity_result.exception();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": "dedNodes or removedNodes is not emp",
          "new_api": null,
          "old_text": "dedNodes or removedNodes is not emp",
          "new_text": null,
          "old_line_content": "        insert_before(*node, nullptr, true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 352,
          "old_api": "de, reference_child);\n    return nod",
          "new_api": null,
          "old_text": "de, reference_child);\n    return nod",
          "new_text": null,
          "old_line_content": "    insert_before(node, reference_child);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": "t",
          "new_api": null,
          "old_text": "t(), string);\n\n  ",
          "new_text": null,
          "old_line_content": "    if (!string.is_empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "ithub.io/D",
          "new_api": null,
          "old_text": "ithub.io/D",
          "new_text": null,
          "old_line_content": "        node = make_ref_counted<Text>(document(), string);",
          "new_line_content": "    if (node)",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": "fragment-serializ",
          "new_api": null,
          "old_text": "fragment-serializ",
          "new_text": null,
          "old_line_content": "    replace_all(node);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": ");\n}\n\n// https://",
          "new_api": null,
          "old_text": ");\n}\n\n// https://",
          "new_text": null,
          "old_line_content": "    return pre_remove(child);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "!= this)",
          "new_api": null,
          "old_text": "!= this)\n      ",
          "new_text": null,
          "old_line_content": "    if (child->parent() != this)",
          "new_line_content": "    return node;",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": "or::create(\"Child does not belong to this node\");\n\n    child->re",
          "new_api": null,
          "old_text": "or::create(\"Child does not belong to this node\");\n\n    child->re",
          "new_text": null,
          "old_line_content": "        return DOM::NotFoundError::create(\"Child does not belong to this node\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 368,
          "old_api": "return ch",
          "new_api": null,
          "old_text": "\n\n    return ch",
          "new_text": null,
          "old_line_content": "    child->remove();",
          "new_line_content": "// https://dom.spec.whatwg.org/#dom-node-removechild",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": "nullptr);\n}\n\n// https://",
          "new_api": null,
          "old_text": " nullptr);\n}\n\n// https://",
          "new_text": null,
          "old_line_content": "    return pre_insert(node, nullptr);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": "parent",
          "new_api": null,
          "old_text": "parent();\n    VERIFY(par",
          "new_text": null,
          "old_line_content": "    auto* parent = TreeNode<Node>::parent();",
          "new_line_content": "    return child;",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": "// FIXME:",
          "new_api": null,
          "old_text": "\n    // FIXME:",
          "new_text": null,
          "old_line_content": "    VERIFY(parent);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": "wing are equal, switchi",
          "new_api": null,
          "old_text": "wing are equal, switchi",
          "new_text": null,
          "old_line_content": "    if (node_name() != other_node->node_name())",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": "run_pre_removing_steps",
          "new_api": null,
          "old_text": "de_iterator([&](NodeIterator& node_iterator) {\n        node_iterator.run_pre_removing_steps(*this);\n    });\n\n    // FIXME: Let o",
          "new_text": null,
          "old_line_content": "    document().for_each_node_iterator([&](NodeIterator& node_iterator) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": "// Its",
          "new_api": null,
          "old_text": "     // Its",
          "new_text": null,
          "old_line_content": "    switch (node_type()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": "verify_cast<DocumentType>(*other",
          "new_api": null,
          "old_text": "verify_cast<DocumentType>(*other",
          "new_text": null,
          "old_line_content": "        auto& this_doctype = verify_cast<DocumentType>(*this);",
          "new_line_content": "        return true;",
          "content_same": false
        },
        {
          "line": 400,
          "old_api": "// FIXME: If node i",
          "new_api": null,
          "old_text": "  // FIXME: If node i",
          "new_text": null,
          "old_line_content": "    parent->TreeNode::remove_child(*this);",
          "new_line_content": "    // FIXME: For each live range whose end node is an inclusive descendant of node, set its end to (parent, index).",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": "name",
          "new_api": null,
          "old_text": ".name() != other_doctype.name()\n      ",
          "new_text": null,
          "old_line_content": "        auto& other_doctype = verify_cast<DocumentType>(*other_node);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": "other_doctype.public",
          "new_api": null,
          "old_text": "other_doctype.public",
          "new_text": null,
          "old_line_content": "        if (this_doctype.name() != other_doctype.name()",
          "new_line_content": "    // A node A equals a node B if all of the following conditions are true:",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": ") != other_doctype.system",
          "new_api": null,
          "old_text": ") != other_doctype.system",
          "new_text": null,
          "old_line_content": "            || this_doctype.public_id() != other_doctype.public_id()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": "ak;\n    }\n    case (u16)N",
          "new_api": null,
          "old_text": "ak;\n    }\n    case (u16)N",
          "new_text": null,
          "old_line_content": "            || this_doctype.system_id() != other_doctype.system_id())",
          "new_line_content": "    // A and B implement the same interfaces.",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": "cast<Element>(*other_node);",
          "new_api": null,
          "old_text": "cast<Element>(*other_node);",
          "new_text": null,
          "old_line_content": "        auto& this_element = verify_cast<Element>(*this);",
          "new_line_content": "    case (u16)NodeType::DOCUMENT_TYPE_NODE: {",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "XME: Let isParentCon",
          "new_api": null,
          "old_text": "XME: Let isParentCon",
          "new_text": null,
          "old_line_content": "    removed_from(parent);",
          "new_line_content": "    // FIXME: Let oldNextSibling be node’s next sibling. (Currently unused so not included)",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "ace_",
          "new_api": null,
          "old_text": "ace_() != other_element.namespace",
          "new_text": null,
          "old_line_content": "        auto& other_element = verify_cast<Element>(*other_node);",
          "new_line_content": "        // Its name, public ID, and system ID.",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": "removed_from",
          "new_api": null,
          "old_text": "endant) {\n        descendant.removed_from(nullptr);\n\n        // FIXME: If descendant is custom and isParentConnected is true, then enqueue a custom element callback reaction with descendant,\n        //        callback name \"disconnectedCallback\", and an empty argument list.\n\n        return IterationDecision::Continue;\n    });\n\n    if (!suppress_observers) {\n",
          "new_text": null,
          "old_line_content": "    for_each_in_subtree([&](Node& descendant) {",
          "new_line_content": "    // FIXME: If node has an inclusive descendant that is a slot, then:",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": "// FIXME: If descendant",
          "new_api": null,
          "old_text": "\n        // FIXME: If descendant",
          "new_text": null,
          "old_line_content": "        descendant.removed_from(nullptr);",
          "new_line_content": "    //          Run assign slottables for a tree with parent’s root.",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "get_attribute",
          "new_api": null,
          "old_text": "       if (other_element.get_attribute(name) != value)\n                has_same_attributes = false;\n        });\n        if (!has_same_attributes)\n            return false;\n      ",
          "new_text": null,
          "old_line_content": "        this_element.for_each_attribute([&](auto& name, auto& value) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "_attributes = false;\n        });",
          "new_api": null,
          "old_text": "_attributes = false;\n        });\n",
          "new_text": null,
          "old_line_content": "            if (other_element.get_attribute(name) != value)",
          "new_line_content": "    case (u16)NodeType::ELEMENT_NODE: {",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "y_cast<CharacterData>(*other_node",
          "new_api": null,
          "old_text": "y_cast<CharacterData>(*other_node",
          "new_text": null,
          "old_line_content": "        auto& this_cdata = verify_cast<CharacterData>(*this);",
          "new_line_content": "        bool has_same_attributes = true;",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": "ttps://dom.spec.whatwg.org/#c",
          "new_api": null,
          "old_text": "ttps://dom.spec.whatwg.org/#c",
          "new_text": null,
          "old_line_content": "    document().invalidate_style();",
          "new_line_content": "        // FIXME: If descendant is custom and isParentConnected is true, then enqueue a custom element callback reaction with descendant,",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": "ame nu",
          "new_api": null,
          "old_text": "ame nu",
          "new_text": null,
          "old_line_content": "        TODO();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": ":HierarchyRequest",
          "new_api": null,
          "old_text": ":HierarchyRequest",
          "new_text": null,
          "old_line_content": "    if (!is<Document>(this) && !is<DocumentFragment>(this) && !is<Element>(this))",
          "new_line_content": "        // FIXME: queue a tree mutation record for parent with « », « node », oldPreviousSibling, and oldNextSibling.",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": "n only insert into a document, document fragment or element\");\n\n    if (node->is_host_including_inc",
          "new_api": null,
          "old_text": "n only insert into a document, document fragment or element\");\n\n    if (node->is_host_including_inc",
          "new_text": null,
          "old_line_content": "        return DOM::HierarchyRequestError::create(\"Can only insert into a document, document fragment or element\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": "parent",
          "new_api": null,
          "old_text": "w node is an ancestor of this node\");\n\n    if (child->parent() != this)\n  ",
          "new_text": null,
          "old_line_content": "        return DOM::HierarchyRequestError::create(\"New node is an ancestor of this node\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "ount)\n        return fals",
          "new_api": null,
          "old_text": "ount)\n        return fals",
          "new_text": null,
          "old_line_content": "    size_t other_child_count = other_node->child_count();",
          "new_line_content": "            return false;",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": "n DOM::NotFound",
          "new_api": null,
          "old_text": "n DOM::NotFound",
          "new_text": null,
          "old_line_content": "    if (child->parent() != this)",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": "is not the parent of the given child\");\n\n    // FIXME: All the following \"In",
          "new_api": null,
          "old_text": "is not the parent of the given child\");\n\n    // FIXME: All the following \"In",
          "new_text": null,
          "old_line_content": "        return DOM::NotFoundError::create(\"This node is not the parent of the given child\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": "return DOM::HierarchyRequest",
          "new_api": null,
          "old_text": "    return DOM::HierarchyRequest",
          "new_text": null,
          "old_line_content": "    if (!is<DocumentFragment>(*node) && !is<DocumentType>(*node) && !is<Element>(*node) && !is<Text>(*node) && !is<Comment>(*node) && !is<ProcessingInstruction>(*node))",
          "new_line_content": "    // NOTE: This differs slightly from ensure_pre_insertion_validity.",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": "index",
          "new_api": null,
          "old_text": "index(i);\n       ",
          "new_text": null,
          "old_line_content": "        auto* this_child = child_at_index(i);",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": "ERIFY",
          "new_api": null,
          "old_text": "ERIFY(other_child);\n        i",
          "new_text": null,
          "old_line_content": "        auto* other_child = other_node->child_at_index(i);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": "M::HierarchyReques",
          "new_api": null,
          "old_text": "M::HierarchyReques",
          "new_text": null,
          "old_line_content": "    if ((is<Text>(*node) && is<Document>(this)) || (is<DocumentType>(*node) && !is<Document>(this)))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": "hild->is_equal_nod",
          "new_api": null,
          "old_text": "hild->is_equal_nod",
          "new_text": null,
          "old_line_content": "        VERIFY(this_child);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": "ild))\n            r",
          "new_api": null,
          "old_text": "ild))\n            r",
          "new_text": null,
          "old_line_content": "        VERIFY(other_child);",
          "new_line_content": "    // A and B have the same number of children.",
          "content_same": false
        },
        {
          "line": 457,
          "old_api": "ocumentFragment>(*",
          "new_api": null,
          "old_text": "ocumentFragment>(*",
          "new_text": null,
          "old_line_content": "    if (is<Document>(this)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": "|| (node_element_chi",
          "new_api": null,
          "old_text": "           || (node_element_chi",
          "new_text": null,
          "old_line_content": "            if ((node_element_child_count > 1 || node->has_child_of_type<Text>())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": "ree_order<DocumentType>()))) {\n                return DOM::Hier",
          "new_api": null,
          "old_text": "ree_order<DocumentType>()))) {\n                return DOM::Hier",
          "new_text": null,
          "old_line_content": "                || (node_element_child_count == 1 && (first_child_of_type<Element>() != child || child->has_following_node_of_type_in_tree_order<DocumentType>()))) {",
          "new_line_content": "    // FIXME: All the following \"Invalid node type for insertion\" messages could be more descriptive.",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": "valid node type for insertion\");\n            }\n        } else if (is<",
          "new_api": null,
          "old_text": "valid node type for insertion\");\n            }\n        } else if (is<",
          "new_text": null,
          "old_line_content": "                return DOM::HierarchyRequestError::create(\"Invalid node type for insertion\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": "ree_order<DocumentType>())\n                return DOM::Hierarch",
          "new_api": null,
          "old_text": "ree_order<DocumentType>())\n                return DOM::Hierarch",
          "new_text": null,
          "old_line_content": "            if (first_child_of_type<Element>() != child || child->has_following_node_of_type_in_tree_order<DocumentType>())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": "ree_order<Element>())\n                return DOM::Hierarch",
          "new_api": null,
          "old_text": "ree_order<Element>())\n                return DOM::Hierarch",
          "new_text": null,
          "old_line_content": "            if (first_child_of_type<DocumentType>() != node || child->has_preceding_node_of_type_in_tree_order<Element>())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": "iption",
          "new_api": null,
          "old_text": "iption() const\n{\n    St",
          "new_text": null,
          "old_line_content": "        return shadow_including_root();",
          "new_line_content": "// https://dom.spec.whatwg.org/#in-a-document-tree",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": "et previousSibling b",
          "new_api": null,
          "old_text": "et previousSibling b",
          "new_text": null,
          "old_line_content": "        reference_child = node->next_sibling();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": "ilder;",
          "new_api": null,
          "old_text": "ilder;",
          "new_text": null,
          "old_line_content": "    return root();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": "Let nodes be node’s",
          "new_api": null,
          "old_text": "Let nodes be node’s",
          "new_text": null,
          "old_line_content": "        child->remove(true);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": "nt = static_cast<DOM::Elem",
          "new_api": null,
          "old_text": "nt = static_cast<DOM::Elem",
          "new_text": null,
          "old_line_content": "    builder.append(node_name().to_lowercase());",
          "new_line_content": "NonnullRefPtr<Node> Node::get_root_node(GetRootNodeOptions const& options)",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": "(*this);",
          "new_api": null,
          "old_text": "(*this);\n   ",
          "new_text": null,
          "old_line_content": "    if (is_element()) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": "et_attribute",
          "new_api": null,
          "old_text": "et_attribute(HTML::AttributeNames::id);",
          "new_text": null,
          "old_line_content": "        auto& element = static_cast<DOM::Element const&>(*this);",
          "new_line_content": "    // The getRootNode(options) method steps are to return this’s shadow-including root if options[\"composed\"] is true; otherwise this’s root.",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": "const& clas",
          "new_api": null,
          "old_text": " const& clas",
          "new_text": null,
          "old_line_content": "        if (auto id = element.get_attribute(HTML::AttributeNames::id); !id.is_null())",
          "new_line_content": "    if (options.composed)",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "}\n    return buil",
          "new_api": null,
          "old_text": "    }\n    return buil",
          "new_text": null,
          "old_line_content": "        for (auto const& class_name : element.class_names())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": "gth\nsize_t Node::le",
          "new_api": null,
          "old_text": "gth\nsize_t Node::le",
          "new_text": null,
          "old_line_content": "    return builder.to_string();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": "node’s children.\n    return child_co",
          "new_api": null,
          "old_text": "node’s children.\n    return child_co",
          "new_text": null,
          "old_line_content": "        return character_data_node->data().length();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "verify_cast<Eleme",
          "new_api": null,
          "old_text": "verify_cast<Eleme",
          "new_text": null,
          "old_line_content": "    if (is<Element>(this)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "nt_copy = DOM::create_elem",
          "new_api": null,
          "old_text": "nt_copy = DOM::create_elem",
          "new_text": null,
          "old_line_content": "        auto& element = *verify_cast<Element>(this);",
          "new_line_content": "    // FIXME: Queue a tree mutation record for parent with nodes, removedNodes, previousSibling, and referenceChild.",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": "e prefix, and node’s",
          "new_api": null,
          "old_text": "e prefix, and node’s",
          "new_text": null,
          "old_line_content": "        auto element_copy = DOM::create_element(*document, element.local_name(), element.namespace_() /* FIXME: node’s namespace prefix, and node’s is value, with the synchronous custom elements flag unset */);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": "set_attribute",
          "new_api": null,
          "old_text": "alue) {\n            element_copy->set_attribute(name, value);\n        });\n        copy = move(element_copy);\n    } else if",
          "new_text": null,
          "old_line_content": "        element.for_each_attribute([&](auto& name, auto& value) {",
          "new_line_content": "    return child;",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": "});\n        copy = move(element_copy);",
          "new_api": null,
          "old_text": "});\n        copy = move(element_copy);\n ",
          "new_text": null,
          "old_line_content": "            element_copy->set_attribute(name, value);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "cterData>(this);",
          "new_api": null,
          "old_text": "cterData>(this);\n  ",
          "new_text": null,
          "old_line_content": "    if (is_character_data()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "is)) {\n        aut",
          "new_api": null,
          "old_text": "is)) {\n        aut",
          "new_text": null,
          "old_line_content": "        copy = move(element_copy);",
          "new_line_content": "// https://dom.spec.whatwg.org/#concept-node-clone",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "ify_cast<Document>",
          "new_api": null,
          "old_text": "ify_cast<Document>",
          "new_text": null,
          "old_line_content": "    } else if (is<Document>(this)) {",
          "new_line_content": "NonnullRefPtr<Node> Node::clone_node(Document* document, bool clone_children)",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": "_copy = Document::create(do",
          "new_api": null,
          "old_text": "_copy = Document::create(do",
          "new_text": null,
          "old_line_content": "        auto document_ = verify_cast<Document>(this);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": "ding",
          "new_api": null,
          "old_text": "ding(document_->",
          "new_text": null,
          "old_line_content": "        auto document_copy = Document::create(document_->url());",
          "new_line_content": "    if (!document)",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": "_content_type",
          "new_api": null,
          "old_text": "_content_type(documen",
          "new_text": null,
          "old_line_content": "        document_copy->set_encoding(document_->encoding());",
          "new_line_content": "        document = m_document;",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": ">set_origin(document_->or",
          "new_api": null,
          "old_text": ">set_origin(document_->or",
          "new_text": null,
          "old_line_content": "        document_copy->set_content_type(document_->content_type());",
          "new_line_content": "    RefPtr<Node> copy;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 114,
      "total_additions": 174,
      "total_deletions": 171,
      "total_api_changes": 459
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 14,
        "api_related_lines": 459,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          192,
          182,
          184,
          186,
          187,
          191
        ]
      }
    },
    "api_calls_before": 482,
    "api_calls_after": 488,
    "diff_info": {
      "added_lines": 14,
      "removed_lines": 2,
      "total_diff_lines": 30
    }
  }
}