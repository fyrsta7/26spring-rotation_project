{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/e8ec1e908dd63e686b085751fad04cfb5088f614",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/e8ec1e908dd63e686b085751fad04cfb5088f614/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/e8ec1e908dd63e686b085751fad04cfb5088f614/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/e8ec1e908dd63e686b085751fad04cfb5088f614/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 457,
          "old_api": "metadata",
          "new_api": "load",
          "old_text": "main_program_description->metadata()",
          "new_text": "load(main_program_description, interpreter_description, main_program_header)",
          "old_line_content": "    auto main_program_metadata = main_program_description->metadata();",
          "new_line_content": "    auto load_result = TRY(load(main_program_description, interpreter_description, main_program_header));",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": "try_allocate_range",
          "new_api": "set_syscall_region",
          "old_text": "load_result.space->try_allocate_range({}, PAGE_SIZE)",
          "new_text": "signal_trampoline_region->set_syscall_region(true)",
          "old_line_content": "    auto signal_trampoline_range = TRY(load_result.space->try_allocate_range({}, PAGE_SIZE));",
          "new_line_content": "    signal_trampoline_region->set_syscall_region(true);",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": "custody",
          "new_api": "is_setuid",
          "old_text": "main_program_description->custody()->mount_flags()",
          "new_text": "main_program_metadata.is_setuid()",
          "old_line_content": "    if (!(main_program_description->custody()->mount_flags() & MS_NOSUID)) {",
          "new_line_content": "        if (main_program_metadata.is_setuid()) {",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": "custody",
          "new_api": "move",
          "old_text": "main_program_description->custody()",
          "new_text": "move(arguments)",
          "old_line_content": "    m_executable = main_program_description->custody();",
          "new_line_content": "    m_arguments = move(arguments);",
          "content_same": false
        },
        {
          "line": 521,
          "old_api": "clear",
          "new_api": "set_metadata",
          "old_text": "m_unveiled_paths.clear()",
          "new_text": "m_unveiled_paths.set_metadata({ \"/\", UnveilAccess::None, false })",
          "old_line_content": "    m_unveiled_paths.clear();",
          "new_line_content": "    m_unveiled_paths.set_metadata({ \"/\", UnveilAccess::None, false });",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": "Thread::current()",
          "new_api": "clear_signals",
          "old_text": "Thread::current()",
          "new_text": "current_thread->clear_signals()",
          "old_line_content": "    auto current_thread = Thread::current();",
          "new_line_content": "    current_thread->clear_signals();",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": "change_each",
          "new_api": "flags",
          "old_text": "fds().change_each([&](auto& file_description_metadata) {\n        if (file_description_metadata.is_valid() && file_description_metadata.flags() & FD_CLOEXEC)\n            file_description_metadata = {};\n    })",
          "new_text": "file_description_metadata.flags()",
          "old_line_content": "    fds().change_each([&](auto& file_description_metadata) {",
          "new_line_content": "        if (file_description_metadata.is_valid() && file_description_metadata.flags() & FD_CLOEXEC)",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "has_value",
          "new_api": "set_readable",
          "old_text": "main_program_fd_allocation.has_value()",
          "new_text": "main_program_description->set_readable(true)",
          "old_line_content": "    if (main_program_fd_allocation.has_value()) {",
          "new_line_content": "        main_program_description->set_readable(true);",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "set_readable",
          "new_api": "move",
          "old_text": "main_program_description->set_readable(true)",
          "new_text": "move(main_program_description)",
          "old_line_content": "        main_program_description->set_readable(true);",
          "new_line_content": "        m_fds[main_program_fd_allocation->fd].set(move(main_program_description), FD_CLOEXEC);",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": "move",
          "new_api": "is_error",
          "old_text": "move(auxv)",
          "new_text": "make_stack_result.is_error()",
          "old_line_content": "    auto make_stack_result = make_userspace_context_for_main_thread(new_main_thread->regs(), *load_result.stack_region.unsafe_ptr(), m_arguments, m_environment, move(auxv));",
          "new_line_content": "    if (make_stack_result.is_error())",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": "is_error",
          "new_api": "error",
          "old_text": "make_stack_result.is_error()",
          "new_text": "make_stack_result.error()",
          "old_line_content": "    if (make_stack_result.is_error())",
          "new_line_content": "        return make_stack_result.error();",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": "error",
          "new_api": "value",
          "old_text": "make_stack_result.error()",
          "new_text": "make_stack_result.value()",
          "old_line_content": "        return make_stack_result.error();",
          "new_line_content": "    FlatPtr new_userspace_sp = make_stack_result.value();",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "unlock",
          "new_api": "send_urgent_signal_to_self",
          "old_text": "ptrace_locker.unlock()",
          "new_text": "Thread::current()->send_urgent_signal_to_self(SIGSTOP)",
          "old_line_content": "        ptrace_locker.unlock();",
          "new_line_content": "        Thread::current()->send_urgent_signal_to_self(SIGSTOP);",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "Processor::enter_critical()",
          "new_api": "cpu_flags",
          "old_text": "Processor::enter_critical()",
          "new_text": "cpu_flags()",
          "old_line_content": "    Processor::enter_critical();",
          "new_line_content": "    prev_flags = cpu_flags();",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "cpu_flags",
          "new_api": "cli",
          "old_text": "cpu_flags()",
          "new_text": "cli()",
          "old_line_content": "    prev_flags = cpu_flags();",
          "new_line_content": "    cli();",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": "make_thread_specific_region",
          "new_api": "is_error",
          "old_text": "new_main_thread->make_thread_specific_region({})",
          "new_text": "tsr_result.is_error()",
          "old_line_content": "    auto tsr_result = new_main_thread->make_thread_specific_region({});",
          "new_line_content": "    if (tsr_result.is_error()) {",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": "force_unlock_if_locked",
          "new_api": "VERIFY_INTERRUPTS_DISABLED",
          "old_text": "big_lock().force_unlock_if_locked(lock_count_to_restore)",
          "new_text": "VERIFY_INTERRUPTS_DISABLED()",
          "old_line_content": "    [[maybe_unused]] auto rc = big_lock().force_unlock_if_locked(lock_count_to_restore);",
          "new_line_content": "    VERIFY_INTERRUPTS_DISABLED();",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": "VERIFY_INTERRUPTS_DISABLED",
          "new_api": "Processor::in_critical()",
          "old_text": "VERIFY_INTERRUPTS_DISABLED()",
          "new_text": "Processor::in_critical()",
          "old_line_content": "    VERIFY_INTERRUPTS_DISABLED();",
          "new_line_content": "    VERIFY(Processor::in_critical());",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": "has_value",
          "new_api": "append",
          "old_text": "main_program_fd_allocation.has_value()",
          "new_text": "auxv.append({ ELF::AuxiliaryValue::ExecFileDescriptor, main_program_fd_allocation->fd })",
          "old_line_content": "    if (main_program_fd_allocation.has_value())",
          "new_line_content": "        auxv.append({ ELF::AuxiliaryValue::ExecFileDescriptor, main_program_fd_allocation->fd });",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": "KString::try_create(StringView { &first_page[word_start], word_length })",
          "new_api": "move",
          "old_text": "KString::try_create(StringView { &first_page[word_start], word_length })",
          "new_text": "move(word)",
          "old_line_content": "                    auto word = TRY(KString::try_create(StringView { &first_page[word_start], word_length }));",
          "new_line_content": "                    interpreter_words.append(move(word));",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": "KString::try_create(StringView { &first_page[word_start], word_length })",
          "new_api": "move",
          "old_text": "KString::try_create(StringView { &first_page[word_start], word_length })",
          "new_text": "move(word)",
          "old_line_content": "            auto word = TRY(KString::try_create(StringView { &first_page[word_start], word_length }));",
          "new_line_content": "            interpreter_words.append(move(word));",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "ELF::validate_program_headers(main_executable_header, file_size, (u8 const*)&main_executable_header, main_executable_header_size, &interpreter_path)",
          "new_api": "dbgln",
          "old_text": "ELF::validate_program_headers(main_executable_header, file_size, (u8 const*)&main_executable_header, main_executable_header_size, &interpreter_path)",
          "new_text": "dbgln(\"exec({}): File has invalid ELF Program headers\", path)",
          "old_line_content": "    if (!ELF::validate_program_headers(main_executable_header, file_size, (u8 const*)&main_executable_header, main_executable_header_size, &interpreter_path)) {",
          "new_line_content": "        dbgln(\"exec({}): File has invalid ELF Program headers\", path);",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": "is_empty",
          "new_api": "dbgln_if",
          "old_text": "interpreter_path.is_empty()",
          "new_text": "dbgln_if(EXEC_DEBUG, \"exec({}): Using program interpreter {}\", path, interpreter_path)",
          "old_line_content": "    if (!interpreter_path.is_empty()) {",
          "new_line_content": "        dbgln_if(EXEC_DEBUG, \"exec({}): Using program interpreter {}\", path, interpreter_path);",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": "dbgln_if",
          "new_api": "current_directory",
          "old_text": "dbgln_if(EXEC_DEBUG, \"exec({}): Using program interpreter {}\", path, interpreter_path)",
          "new_text": "current_directory()",
          "old_line_content": "        dbgln_if(EXEC_DEBUG, \"exec({}): Using program interpreter {}\", path, interpreter_path);",
          "new_line_content": "        auto interpreter_description = TRY(VirtualFileSystem::the().open(interpreter_path, O_EXEC, 0, current_directory()));",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "current_directory",
          "new_api": "metadata",
          "old_text": "current_directory()",
          "new_text": "interpreter_description->metadata()",
          "old_line_content": "        auto interpreter_description = TRY(VirtualFileSystem::the().open(interpreter_path, O_EXEC, 0, current_directory()));",
          "new_line_content": "        auto interp_metadata = interpreter_description->metadata();",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": "UserOrKernelBuffer::for_kernel_buffer((u8*)&first_page)",
          "new_api": "read",
          "old_text": "UserOrKernelBuffer::for_kernel_buffer((u8*)&first_page)",
          "new_text": "interpreter_description->read(first_page_buffer, sizeof(first_page))",
          "old_line_content": "        auto first_page_buffer = UserOrKernelBuffer::for_kernel_buffer((u8*)&first_page);",
          "new_line_content": "        auto nread = TRY(interpreter_description->read(first_page_buffer, sizeof(first_page)));",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "ElfW",
          "new_api": "ELF::validate_elf_header(*elf_header, interp_metadata.size)",
          "old_text": "ElfW(Ehdr)",
          "new_text": "ELF::validate_elf_header(*elf_header, interp_metadata.size)",
          "old_line_content": "        auto elf_header = (ElfW(Ehdr)*)first_page;",
          "new_line_content": "        if (!ELF::validate_elf_header(*elf_header, interp_metadata.size)) {",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "ELF::validate_elf_header(*elf_header, interp_metadata.size)",
          "new_api": "absolute_path",
          "old_text": "ELF::validate_elf_header(*elf_header, interp_metadata.size)",
          "new_text": "interpreter_description->absolute_path()",
          "old_line_content": "        if (!ELF::validate_elf_header(*elf_header, interp_metadata.size)) {",
          "new_line_content": "            dbgln(\"exec({}): Interpreter ({}) has invalid ELF header\", path, interpreter_description->absolute_path());",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": "ELF::validate_program_headers(*elf_header, interp_metadata.size, (u8*)first_page, nread, &interpreter_interpreter_path)",
          "new_api": "absolute_path",
          "old_text": "ELF::validate_program_headers(*elf_header, interp_metadata.size, (u8*)first_page, nread, &interpreter_interpreter_path)",
          "new_text": "interpreter_description->absolute_path()",
          "old_line_content": "        if (!ELF::validate_program_headers(*elf_header, interp_metadata.size, (u8*)first_page, nread, &interpreter_interpreter_path)) {",
          "new_line_content": "            dbgln(\"exec({}): Interpreter ({}) has invalid ELF Program headers\", path, interpreter_description->absolute_path());",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": "is_empty",
          "new_api": "absolute_path",
          "old_text": "interpreter_interpreter_path.is_empty()",
          "new_text": "interpreter_description->absolute_path()",
          "old_line_content": "        if (!interpreter_interpreter_path.is_empty()) {",
          "new_line_content": "            dbgln(\"exec({}): Interpreter ({}) has its own interpreter ({})! No thank you!\", path, interpreter_description->absolute_path(), interpreter_interpreter_path);",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": "current_directory",
          "new_api": "metadata",
          "old_text": "current_directory()",
          "new_text": "description->metadata()",
          "old_line_content": "    auto description = TRY(VirtualFileSystem::the().open(path->view(), O_EXEC, 0, current_directory()));",
          "new_line_content": "    auto metadata = description->metadata();",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "UserOrKernelBuffer::for_kernel_buffer((u8*)&first_page)",
          "new_api": "read",
          "old_text": "UserOrKernelBuffer::for_kernel_buffer((u8*)&first_page)",
          "new_text": "description->read(first_page_buffer, sizeof(first_page))",
          "old_line_content": "    auto first_page_buffer = UserOrKernelBuffer::for_kernel_buffer((u8*)&first_page);",
          "new_line_content": "    auto nread = TRY(description->read(first_page_buffer, sizeof(first_page)));",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": "find_shebang_interpreter_for_executable",
          "new_api": "is_error",
          "old_text": "find_shebang_interpreter_for_executable(first_page, nread)",
          "new_text": "shebang_result.is_error()",
          "old_line_content": "    auto shebang_result = find_shebang_interpreter_for_executable(first_page, nread);",
          "new_line_content": "    if (!shebang_result.is_error()) {",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "is_error",
          "new_api": "release_value",
          "old_text": "shebang_result.is_error()",
          "new_text": "shebang_result.release_value()",
          "old_line_content": "    if (!shebang_result.is_error()) {",
          "new_line_content": "        auto shebang_words = shebang_result.release_value();",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": "release_value",
          "new_api": "first",
          "old_text": "shebang_result.release_value()",
          "new_text": "shebang_words.first().try_clone()",
          "old_line_content": "        auto shebang_words = shebang_result.release_value();",
          "new_line_content": "        auto shebang_path = TRY(shebang_words.first().try_clone());",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "first",
          "new_api": "move",
          "old_text": "shebang_words.first().try_clone()",
          "new_text": "move(path)",
          "old_line_content": "        auto shebang_path = TRY(shebang_words.first().try_clone());",
          "new_line_content": "        arguments.ptr_at(0) = move(path);",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "ELF::validate_elf_header(*main_program_header, metadata.size)",
          "new_api": "dbgln",
          "old_text": "ELF::validate_elf_header(*main_program_header, metadata.size)",
          "new_text": "dbgln(\"exec({}): File has invalid ELF header\", path)",
          "old_line_content": "    if (!ELF::validate_elf_header(*main_program_header, metadata.size)) {",
          "new_line_content": "        dbgln(\"exec({}): File has invalid ELF header\", path);",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": "view",
          "new_api": "move",
          "old_text": "path->view()",
          "new_text": "move(interpreter_description)",
          "old_line_content": "    auto interpreter_description = TRY(find_elf_interpreter_for_executable(path->view(), *main_program_header, nread, metadata.size));",
          "new_line_content": "    TRY(do_exec(move(description), move(arguments), move(environment), move(interpreter_description), new_main_thread, prev_flags, *main_program_header));",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": "VERIFY_INTERRUPTS_DISABLED",
          "new_api": "Processor::in_critical()",
          "old_text": "VERIFY_INTERRUPTS_DISABLED()",
          "new_text": "Processor::in_critical()",
          "old_line_content": "    VERIFY_INTERRUPTS_DISABLED();",
          "new_line_content": "    VERIFY(Processor::in_critical());",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "is_locked_by_current_processor",
          "new_api": "Processor::in_critical()",
          "old_text": "g_scheduler_lock.is_locked_by_current_processor()",
          "new_text": "Processor::in_critical()",
          "old_line_content": "        VERIFY(!g_scheduler_lock.is_locked_by_current_processor());",
          "new_line_content": "        VERIFY(Processor::in_critical() == 1);",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": "Processor::in_critical()",
          "new_api": "lock",
          "old_text": "Processor::in_critical()",
          "new_text": "g_scheduler_lock.lock()",
          "old_line_content": "        VERIFY(Processor::in_critical() == 1);",
          "new_line_content": "        g_scheduler_lock.lock();",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": "lock",
          "new_api": "set_state",
          "old_text": "g_scheduler_lock.lock()",
          "new_text": "current_thread->set_state(Thread::State::Running)",
          "old_line_content": "        g_scheduler_lock.lock();",
          "new_line_content": "        current_thread->set_state(Thread::State::Running);",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": "set_state",
          "new_api": "Processor::assume_context(*current_thread, prev_flags)",
          "old_text": "current_thread->set_state(Thread::State::Running)",
          "new_text": "Processor::assume_context(*current_thread, prev_flags)",
          "old_line_content": "        current_thread->set_state(Thread::State::Running);",
          "new_line_content": "        Processor::assume_context(*current_thread, prev_flags);",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": "Processor::assume_context(*current_thread, prev_flags)",
          "new_api": "VERIFY_NOT_REACHED",
          "old_text": "Processor::assume_context(*current_thread, prev_flags)",
          "new_text": "VERIFY_NOT_REACHED()",
          "old_line_content": "        Processor::assume_context(*current_thread, prev_flags);",
          "new_line_content": "        VERIFY_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": "sti",
          "new_api": "Processor::leave_critical()",
          "old_text": "sti()",
          "new_text": "Processor::leave_critical()",
          "old_line_content": "        sti();",
          "new_line_content": "    Processor::leave_critical();",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": "VERIFY_PROCESS_BIG_LOCK_ACQUIRED",
          "new_api": "REQUIRE_PROMISE",
          "old_text": "VERIFY_PROCESS_BIG_LOCK_ACQUIRED(this)",
          "new_text": "REQUIRE_PROMISE(exec)",
          "old_line_content": "    VERIFY_PROCESS_BIG_LOCK_ACQUIRED(this);",
          "new_line_content": "    REQUIRE_PROMISE(exec);",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": "try_copy_kstring_from_user",
          "new_api": "move",
          "old_text": "try_copy_kstring_from_user(strings[i])",
          "new_text": "move(string)",
          "old_line_content": "            auto string = TRY(try_copy_kstring_from_user(strings[i]));",
          "new_line_content": "            if (!output.try_append(move(string)))",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": "move",
          "new_api": "is_error",
          "old_text": "move(environment)",
          "new_text": "result.is_error()",
          "old_line_content": "    auto result = exec(move(path), move(arguments), move(environment));",
          "new_line_content": "    VERIFY(result.is_error()); // We should never continue after a successful exec!",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": "is_error",
          "new_api": "error",
          "old_text": "result.is_error()",
          "new_text": "result.error()",
          "old_line_content": "    VERIFY(result.is_error()); // We should never continue after a successful exec!",
          "new_line_content": "    return result.error();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 513,
          "old_api": null,
          "new_api": "Memory::MemoryManager::enter_address_space(*m_space)",
          "old_text": null,
          "new_text": "Memory::MemoryManager::enter_address_space(*m_space)",
          "old_line_content": "    }",
          "new_line_content": "    Memory::MemoryManager::enter_address_space(*m_space);",
          "content_same": false
        },
        {
          "line": 515,
          "old_api": null,
          "new_api": "custody",
          "old_text": null,
          "new_text": "main_program_description->custody()",
          "old_line_content": "",
          "new_line_content": "    m_executable = main_program_description->custody();",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "m_unveiled_paths.clear()",
          "old_line_content": "    m_veil_state = VeilState::None;",
          "new_line_content": "    m_unveiled_paths.clear();",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": null,
          "new_api": "Thread::current()",
          "old_text": null,
          "new_text": "Thread::current()",
          "old_line_content": "",
          "new_line_content": "    auto current_thread = Thread::current();",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": null,
          "new_api": "clear_futex_queues_on_exec",
          "old_text": null,
          "new_text": "clear_futex_queues_on_exec()",
          "old_line_content": "",
          "new_line_content": "    clear_futex_queues_on_exec();",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": null,
          "new_api": "change_each",
          "old_text": null,
          "new_text": "fds().change_each([&](auto& file_description_metadata) {\n        if (file_description_metadata.is_valid() && file_description_metadata.flags() & FD_CLOEXEC)\n            file_description_metadata = {};\n    })",
          "old_line_content": "",
          "new_line_content": "    fds().change_each([&](auto& file_description_metadata) {",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "main_program_fd_allocation.has_value()",
          "old_line_content": "",
          "new_line_content": "    if (main_program_fd_allocation.has_value()) {",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": null,
          "new_api": "process",
          "old_text": null,
          "new_text": "current_thread->process()",
          "old_line_content": "    new_main_thread = nullptr;",
          "new_line_content": "    if (&current_thread->process() == this) {",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": null,
          "new_api": "for_each_thread",
          "old_text": null,
          "new_text": "for_each_thread([&](auto& thread) {\n            new_main_thread = &thread;\n            return IterationDecision::Break;\n        })",
          "old_line_content": "    } else {",
          "new_line_content": "        for_each_thread([&](auto& thread) {",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": null,
          "new_api": "VERIFY",
          "old_text": null,
          "new_text": "VERIFY(new_main_thread)",
          "old_line_content": "    }",
          "new_line_content": "    VERIFY(new_main_thread);",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": null,
          "new_api": "view",
          "old_text": null,
          "new_text": "path->view()",
          "old_line_content": "",
          "new_line_content": "    auto auxv = generate_auxiliary_vector(load_result.load_base, load_result.entry_eip, uid(), euid(), gid(), egid(), path->view(), main_program_fd_allocation);",
          "content_same": false
        },
        {
          "line": 556,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(auxv)",
          "old_line_content": "    //       and we don't want to deal with faults after this point.",
          "new_line_content": "    auto make_stack_result = make_userspace_context_for_main_thread(new_main_thread->regs(), *load_result.stack_region.unsafe_ptr(), m_arguments, m_environment, move(auxv));",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "wait_for_tracer_at_next_execve",
          "old_text": null,
          "new_text": "wait_for_tracer_at_next_execve()",
          "old_line_content": "",
          "new_line_content": "    if (wait_for_tracer_at_next_execve()) {",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": null,
          "new_api": "unlock",
          "old_text": null,
          "new_text": "ptrace_locker.unlock()",
          "old_line_content": "        // Make sure we release the ptrace lock here or the tracer will block forever.",
          "new_line_content": "        ptrace_locker.unlock();",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": null,
          "new_api": "unlock",
          "old_text": null,
          "new_text": "ptrace_locker.unlock()",
          "old_line_content": "        // Ensure we always unlock after checking ptrace status to avoid TOCTOU ptrace issues",
          "new_line_content": "        ptrace_locker.unlock();",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": null,
          "new_api": "Processor::enter_critical()",
          "old_text": null,
          "new_text": "Processor::enter_critical()",
          "old_line_content": "    // If we used an InterruptDisabler that sti()'d on exit, we might timer tick'd too soon in exec().",
          "new_line_content": "    Processor::enter_critical();",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(new_process_name)",
          "old_line_content": "",
          "new_line_content": "    m_name = move(new_process_name);",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "m_protected_values.execpromises.load()",
          "old_line_content": "        ProtectedDataMutationScope scope { *this };",
          "new_line_content": "        m_protected_values.promises = m_protected_values.execpromises.load();",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": null,
          "new_api": "vaddr",
          "old_text": null,
          "new_text": "signal_trampoline_region->vaddr()",
          "old_line_content": "",
          "new_line_content": "        m_protected_values.signal_trampoline = signal_trampoline_region->vaddr();",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "new_main_thread->tid().value()",
          "old_line_content": "        // FIXME: PID/TID ISSUE",
          "new_line_content": "        m_protected_values.pid = new_main_thread->tid().value();",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": null,
          "new_api": "make_thread_specific_region",
          "old_text": null,
          "new_text": "new_main_thread->make_thread_specific_region({})",
          "old_line_content": "",
          "new_line_content": "    auto tsr_result = new_main_thread->make_thread_specific_region({});",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": null,
          "new_api": "VERIFY_NOT_REACHED",
          "old_text": null,
          "new_text": "VERIFY_NOT_REACHED()",
          "old_line_content": "        // FIXME: We cannot fail this late. Refactor this so the allocation happens before we commit to the new executable.",
          "new_line_content": "        VERIFY_NOT_REACHED();",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": null,
          "new_api": "reset_fpu_state",
          "old_text": null,
          "new_text": "new_main_thread->reset_fpu_state()",
          "old_line_content": "    }",
          "new_line_content": "    new_main_thread->reset_fpu_state();",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": null,
          "new_api": "page_directory",
          "old_text": null,
          "new_text": "address_space().page_directory().cr3()",
          "old_line_content": "#endif",
          "new_line_content": "    regs.cr3 = address_space().page_directory().cr3();",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": null,
          "new_api": "PerformanceManager::add_process_exec_event(*this)",
          "old_text": null,
          "new_text": "PerformanceManager::add_process_exec_event(*this)",
          "old_line_content": "        TemporaryChange profiling_disabler(m_profiling, was_profiling);",
          "new_line_content": "        PerformanceManager::add_process_exec_event(*this);",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": null,
          "new_api": "set_state",
          "old_text": null,
          "new_text": "new_main_thread->set_state(Thread::State::Runnable)",
          "old_line_content": "        SpinlockLocker lock(g_scheduler_lock);",
          "new_line_content": "        new_main_thread->set_state(Thread::State::Runnable);",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": null,
          "new_api": "force_unlock_if_locked",
          "old_text": null,
          "new_text": "big_lock().force_unlock_if_locked(lock_count_to_restore)",
          "old_line_content": "    u32 lock_count_to_restore;",
          "new_line_content": "    [[maybe_unused]] auto rc = big_lock().force_unlock_if_locked(lock_count_to_restore);",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "auxv.append({ ELF::AuxiliaryValue::PageSize, PAGE_SIZE })",
          "old_line_content": "    // PH*",
          "new_line_content": "    auxv.append({ ELF::AuxiliaryValue::PageSize, PAGE_SIZE });",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "auxv.append({ ELF::AuxiliaryValue::Entry, (void*)entry_eip })",
          "old_line_content": "",
          "new_line_content": "    auxv.append({ ELF::AuxiliaryValue::Entry, (void*)entry_eip });",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "uid.value()",
          "old_line_content": "    // NOTELF",
          "new_line_content": "    auxv.append({ ELF::AuxiliaryValue::Uid, (long)uid.value() });",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": null,
          "new_api": "Processor::platform_string()",
          "old_text": null,
          "new_text": "Processor::platform_string()",
          "old_line_content": "",
          "new_line_content": "    auxv.append({ ELF::AuxiliaryValue::Platform, Processor::platform_string() });",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": null,
          "new_api": "edx",
          "old_text": null,
          "new_text": "CPUID(1).edx()",
          "old_line_content": "    // FIXME: This is platform specific",
          "new_line_content": "    auxv.append({ ELF::AuxiliaryValue::HwCap, (long)CPUID(1).edx() });",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": null,
          "new_api": "ticks_per_second",
          "old_text": null,
          "new_text": "TimeManagement::the().ticks_per_second()",
          "old_line_content": "",
          "new_line_content": "    auxv.append({ ELF::AuxiliaryValue::ClockTick, (long)TimeManagement::the().ticks_per_second() });",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "auxv.append({ ELF::AuxiliaryValue::Secure, ((uid != euid) || (gid != egid)) ? 1 : 0 })",
          "old_line_content": "    // FIXME: Also take into account things like extended filesystem permissions? That's what linux does...",
          "new_line_content": "    auxv.append({ ELF::AuxiliaryValue::Secure, ((uid != euid) || (gid != egid)) ? 1 : 0 });",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": null,
          "new_api": "get_fast_random_bytes",
          "old_text": null,
          "new_text": "get_fast_random_bytes({ (u8*)random_bytes, sizeof(random_bytes) })",
          "old_line_content": "    char random_bytes[16] {};",
          "new_line_content": "    get_fast_random_bytes({ (u8*)random_bytes, sizeof(random_bytes) });",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": null,
          "new_api": "String",
          "old_text": null,
          "new_text": "String(random_bytes, sizeof(random_bytes))",
          "old_line_content": "",
          "new_line_content": "    auxv.append({ ELF::AuxiliaryValue::Random, String(random_bytes, sizeof(random_bytes)) });",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "auxv.append({ ELF::AuxiliaryValue::ExecFilename, executable_path })",
          "old_line_content": "",
          "new_line_content": "    auxv.append({ ELF::AuxiliaryValue::ExecFilename, executable_path });",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "main_program_fd_allocation.has_value()",
          "old_line_content": "",
          "new_line_content": "    if (main_program_fd_allocation.has_value())",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "auxv.append({ ELF::AuxiliaryValue::Null, 0L })",
          "old_line_content": "",
          "new_line_content": "    auxv.append({ ELF::AuxiliaryValue::Null, 0L });",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": null,
          "new_api": "KString::try_create(StringView { &first_page[word_start], word_length })",
          "old_text": null,
          "new_text": "KString::try_create(StringView { &first_page[word_start], word_length })",
          "old_line_content": "                if (word_length > 0) {",
          "new_line_content": "                    auto word = TRY(KString::try_create(StringView { &first_page[word_start], word_length }));",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": null,
          "new_api": "KString::try_create(StringView { &first_page[word_start], word_length })",
          "old_text": null,
          "new_text": "KString::try_create(StringView { &first_page[word_start], word_length })",
          "old_line_content": "        if (word_length > 0) {",
          "new_line_content": "            auto word = TRY(KString::try_create(StringView { &first_page[word_start], word_length }));",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "interpreter_words.is_empty()",
          "old_line_content": "",
          "new_line_content": "        if (!interpreter_words.is_empty())",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": null,
          "new_api": "ELF::validate_program_headers(main_executable_header, file_size, (u8 const*)&main_executable_header, main_executable_header_size, &interpreter_path)",
          "old_text": null,
          "new_text": "ELF::validate_program_headers(main_executable_header, file_size, (u8 const*)&main_executable_header, main_executable_header_size, &interpreter_path)",
          "old_line_content": "    String interpreter_path;",
          "new_line_content": "    if (!ELF::validate_program_headers(main_executable_header, file_size, (u8 const*)&main_executable_header, main_executable_header_size, &interpreter_path)) {",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "interpreter_path.is_empty()",
          "old_line_content": "",
          "new_line_content": "    if (!interpreter_path.is_empty()) {",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": null,
          "new_api": "inode",
          "old_text": null,
          "new_text": "interpreter_description->inode()",
          "old_line_content": "",
          "new_line_content": "        VERIFY(interpreter_description->inode());",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": null,
          "new_api": "ElfW",
          "old_text": null,
          "new_text": "ElfW(Ehdr)",
          "old_line_content": "        // If your program interpreter is a #! file or something, it's time to stop playing games :)",
          "new_line_content": "        if (interp_metadata.size < (int)sizeof(ElfW(Ehdr)))",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": null,
          "new_api": "UserOrKernelBuffer::for_kernel_buffer((u8*)&first_page)",
          "old_text": null,
          "new_text": "UserOrKernelBuffer::for_kernel_buffer((u8*)&first_page)",
          "old_line_content": "        char first_page[PAGE_SIZE] = {};",
          "new_line_content": "        auto first_page_buffer = UserOrKernelBuffer::for_kernel_buffer((u8*)&first_page);",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": null,
          "new_api": "ElfW",
          "old_text": null,
          "new_text": "ElfW(Ehdr)",
          "old_line_content": "",
          "new_line_content": "        if (nread < sizeof(ElfW(Ehdr)))",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": null,
          "new_api": "ElfW",
          "old_text": null,
          "new_text": "ElfW(Ehdr)",
          "old_line_content": "",
          "new_line_content": "        auto elf_header = (ElfW(Ehdr)*)first_page;",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": null,
          "new_api": "ELF::validate_program_headers(*elf_header, interp_metadata.size, (u8*)first_page, nread, &interpreter_interpreter_path)",
          "old_text": null,
          "new_text": "ELF::validate_program_headers(*elf_header, interp_metadata.size, (u8*)first_page, nread, &interpreter_interpreter_path)",
          "old_line_content": "        String interpreter_interpreter_path;",
          "new_line_content": "        if (!ELF::validate_program_headers(*elf_header, interp_metadata.size, (u8*)first_page, nread, &interpreter_interpreter_path)) {",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "interpreter_interpreter_path.is_empty()",
          "old_line_content": "",
          "new_line_content": "        if (!interpreter_interpreter_path.is_empty()) {",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"exec({}): WARNING - Dynamic ELF executable without a PT_INTERP header, and isn't /usr/lib/Loader.so\", path)",
          "old_line_content": "        if (path != \"/usr/lib/Loader.so\")",
          "new_line_content": "            dbgln(\"exec({}): WARNING - Dynamic ELF executable without a PT_INTERP header, and isn't /usr/lib/Loader.so\", path);",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"exec({}): SHENANIGANS! recursed too far trying to find #! interpreter\", path)",
          "old_line_content": "    if (recursion_depth > 2) {",
          "new_line_content": "        dbgln(\"exec({}): SHENANIGANS! recursed too far trying to find #! interpreter\", path);",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": null,
          "new_api": "current_directory",
          "old_text": null,
          "new_text": "current_directory()",
          "old_line_content": "    //",
          "new_line_content": "    auto description = TRY(VirtualFileSystem::the().open(path->view(), O_EXEC, 0, current_directory()));",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": null,
          "new_api": "is_regular_file",
          "old_text": null,
          "new_text": "metadata.is_regular_file()",
          "old_line_content": "",
          "new_line_content": "    if (!metadata.is_regular_file())",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": null,
          "new_api": "inode",
          "old_text": null,
          "new_text": "description->inode()",
          "old_line_content": "",
          "new_line_content": "    VERIFY(description->inode());",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": null,
          "new_api": "UserOrKernelBuffer::for_kernel_buffer((u8*)&first_page)",
          "old_text": null,
          "new_text": "UserOrKernelBuffer::for_kernel_buffer((u8*)&first_page)",
          "old_line_content": "    char first_page[PAGE_SIZE];",
          "new_line_content": "    auto first_page_buffer = UserOrKernelBuffer::for_kernel_buffer((u8*)&first_page);",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": null,
          "new_api": "find_shebang_interpreter_for_executable",
          "old_text": null,
          "new_text": "find_shebang_interpreter_for_executable(first_page, nread)",
          "old_line_content": "    // 1) #! interpreted file",
          "new_line_content": "    auto shebang_result = find_shebang_interpreter_for_executable(first_page, nread);",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(environment)",
          "old_line_content": "            return ENOMEM;",
          "new_line_content": "        return exec(move(shebang_path), move(arguments), move(environment), ++recursion_depth);",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": null,
          "new_api": "ElfW",
          "old_text": null,
          "new_text": "ElfW(Ehdr)",
          "old_line_content": "",
          "new_line_content": "    if (nread < sizeof(ElfW(Ehdr)))",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": null,
          "new_api": "ElfW",
          "old_text": null,
          "new_text": "ElfW(Ehdr)",
          "old_line_content": "        return ENOEXEC;",
          "new_line_content": "    auto main_program_header = (ElfW(Ehdr)*)first_page;",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": null,
          "new_api": "ELF::validate_elf_header(*main_program_header, metadata.size)",
          "old_text": null,
          "new_text": "ELF::validate_elf_header(*main_program_header, metadata.size)",
          "old_line_content": "",
          "new_line_content": "    if (!ELF::validate_elf_header(*main_program_header, metadata.size)) {",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": null,
          "new_api": "view",
          "old_text": null,
          "new_text": "path->view()",
          "old_line_content": "",
          "new_line_content": "    auto interpreter_description = TRY(find_elf_interpreter_for_executable(path->view(), *main_program_header, nread, metadata.size));",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": null,
          "new_api": "VERIFY_INTERRUPTS_DISABLED",
          "old_text": null,
          "new_text": "VERIFY_INTERRUPTS_DISABLED()",
          "old_line_content": "",
          "new_line_content": "    VERIFY_INTERRUPTS_DISABLED();",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": null,
          "new_api": "Thread::current()",
          "old_text": null,
          "new_text": "Thread::current()",
          "old_line_content": "",
          "new_line_content": "    auto current_thread = Thread::current();",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": null,
          "new_api": "is_locked_by_current_processor",
          "old_text": null,
          "new_text": "g_scheduler_lock.is_locked_by_current_processor()",
          "old_line_content": "        // thread. We should also still be in our critical section",
          "new_line_content": "        VERIFY(!g_scheduler_lock.is_locked_by_current_processor());",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": null,
          "new_api": "sti",
          "old_text": null,
          "new_text": "sti()",
          "old_line_content": "    if (prev_flags & 0x200)",
          "new_line_content": "        sti();",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": null,
          "new_api": "VERIFY_PROCESS_BIG_LOCK_ACQUIRED",
          "old_text": null,
          "new_text": "VERIFY_PROCESS_BIG_LOCK_ACQUIRED(this)",
          "old_line_content": "{",
          "new_line_content": "    VERIFY_PROCESS_BIG_LOCK_ACQUIRED(this);",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": null,
          "new_api": "copy_typed_from_user",
          "old_text": null,
          "new_text": "copy_typed_from_user(user_params)",
          "old_line_content": "    //       On success, the kernel stack will be lost.",
          "new_line_content": "    auto params = TRY(copy_typed_from_user(user_params));",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": null,
          "new_api": "get_syscall_path_argument",
          "old_text": null,
          "new_text": "get_syscall_path_argument(params.path)",
          "old_line_content": "",
          "new_line_content": "    auto path = TRY(get_syscall_path_argument(params.path));",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": null,
          "new_api": "has_overflow",
          "old_text": null,
          "new_text": "size.has_overflow()",
          "old_line_content": "        size *= list.length;",
          "new_line_content": "        if (size.has_overflow())",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": null,
          "new_api": "try_resize",
          "old_text": null,
          "new_text": "strings.try_resize(list.length)",
          "old_line_content": "        Vector<Syscall::StringArgument, 32> strings;",
          "new_line_content": "        if (!strings.try_resize(list.length))",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "size.value()",
          "old_line_content": "            return ENOMEM;",
          "new_line_content": "        TRY(copy_from_user(strings.data(), list.strings, size.value()));",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": null,
          "new_api": "try_copy_kstring_from_user",
          "old_text": null,
          "new_text": "try_copy_kstring_from_user(strings[i])",
          "old_line_content": "        for (size_t i = 0; i < list.length; ++i) {",
          "new_line_content": "            auto string = TRY(try_copy_kstring_from_user(strings[i]));",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": null,
          "new_api": "copy_user_strings",
          "old_text": null,
          "new_text": "copy_user_strings(params.arguments, arguments)",
          "old_line_content": "    NonnullOwnPtrVector<KString> arguments;",
          "new_line_content": "    TRY(copy_user_strings(params.arguments, arguments));",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": null,
          "new_api": "copy_user_strings",
          "old_text": null,
          "new_text": "copy_user_strings(params.environment, environment)",
          "old_line_content": "    NonnullOwnPtrVector<KString> environment;",
          "new_line_content": "    TRY(copy_user_strings(params.environment, environment));",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(environment)",
          "old_line_content": "",
          "new_line_content": "    auto result = exec(move(path), move(arguments), move(environment));",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": null,
          "new_api": "try_allocate_range",
          "old_text": null,
          "new_text": "load_result.space->try_allocate_range({}, PAGE_SIZE)",
          "old_line_content": "    interpreter_description = nullptr;",
          "new_line_content": "    auto signal_trampoline_range = TRY(load_result.space->try_allocate_range({}, PAGE_SIZE));",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": null,
          "new_api": "vmobject",
          "old_text": null,
          "new_text": "g_signal_trampoline_region->vmobject()",
          "old_line_content": "",
          "new_line_content": "    auto signal_trampoline_region = TRY(load_result.space->allocate_region_with_vmobject(signal_trampoline_range, g_signal_trampoline_region->vmobject(), 0, \"Signal trampoline\", PROT_READ | PROT_EXEC, true));",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": null,
          "new_api": "allocate",
          "old_text": null,
          "new_text": "m_fds.allocate()",
          "old_line_content": "    Optional<ScopedDescriptionAllocation> main_program_fd_allocation;",
          "new_line_content": "        main_program_fd_allocation = TRY(m_fds.allocate());",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": null,
          "new_api": "kill_threads_except_self",
          "old_text": null,
          "new_text": "kill_threads_except_self()",
          "old_line_content": "    TemporaryChange profiling_disabler(m_profiling, false);",
          "new_line_content": "    kill_threads_except_self();",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": null,
          "new_api": "custody",
          "old_text": null,
          "new_text": "main_program_description->custody()->mount_flags()",
          "old_line_content": "    bool executable_is_setid = false;",
          "new_line_content": "    if (!(main_program_description->custody()->mount_flags() & MS_NOSUID)) {",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": null,
          "new_api": "metadata",
          "old_text": null,
          "new_text": "main_program_description->metadata()",
          "old_line_content": "",
          "new_line_content": "        auto main_program_metadata = main_program_description->metadata();",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": null,
          "new_api": "is_setgid",
          "old_text": null,
          "new_text": "main_program_metadata.is_setgid()",
          "old_line_content": "        }",
          "new_line_content": "        if (main_program_metadata.is_setgid()) {",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": null,
          "new_api": "set_dumpable",
          "old_text": null,
          "new_text": "set_dumpable(!executable_is_setid)",
          "old_line_content": "",
          "new_line_content": "    set_dumpable(!executable_is_setid);",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": null,
          "new_api": "release_nonnull",
          "old_text": null,
          "new_text": "load_result.space.release_nonnull()",
          "old_line_content": "        TemporaryChange global_profiling_disabler(g_profiling_all_threads, false);",
          "new_line_content": "        m_space = load_result.space.release_nonnull();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 512,
          "old_api": "release_nonnull",
          "new_api": null,
          "old_text": "load_result.space.release_nonnull()",
          "new_text": null,
          "old_line_content": "        m_space = load_result.space.release_nonnull();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 514,
          "old_api": "Memory::MemoryManager::enter_address_space(*m_space)",
          "new_api": null,
          "old_text": "Memory::MemoryManager::enter_address_space(*m_space)",
          "new_text": null,
          "old_line_content": "    Memory::MemoryManager::enter_address_space(*m_space);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": "move",
          "new_api": null,
          "old_text": "move(environment)",
          "new_text": null,
          "old_line_content": "    m_environment = move(environment);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": "set_metadata",
          "new_api": null,
          "old_text": "m_unveiled_paths.set_metadata({ \"/\", UnveilAccess::None, false })",
          "new_text": null,
          "old_line_content": "    m_unveiled_paths.set_metadata({ \"/\", UnveilAccess::None, false });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": "clear_signals",
          "new_api": null,
          "old_text": "current_thread->clear_signals()",
          "new_text": null,
          "old_line_content": "    current_thread->clear_signals();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": "clear_futex_queues_on_exec",
          "new_api": null,
          "old_text": "clear_futex_queues_on_exec()",
          "new_text": null,
          "old_line_content": "    clear_futex_queues_on_exec();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": "flags",
          "new_api": null,
          "old_text": "file_description_metadata.flags()",
          "new_text": null,
          "old_line_content": "        if (file_description_metadata.is_valid() && file_description_metadata.flags() & FD_CLOEXEC)",
          "new_line_content": "            file_description_metadata = {};",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "move",
          "new_api": null,
          "old_text": "move(main_program_description)",
          "new_text": null,
          "old_line_content": "        m_fds[main_program_fd_allocation->fd].set(move(main_program_description), FD_CLOEXEC);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": "process",
          "new_api": null,
          "old_text": "current_thread->process()",
          "new_text": null,
          "old_line_content": "    if (&current_thread->process() == this) {",
          "new_line_content": "        new_main_thread = current_thread;",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": "for_each_thread",
          "new_api": null,
          "old_text": "for_each_thread([&](auto& thread) {\n            new_main_thread = &thread;\n            return IterationDecision::Break;\n        })",
          "new_text": null,
          "old_line_content": "        for_each_thread([&](auto& thread) {",
          "new_line_content": "            new_main_thread = &thread;",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "VERIFY",
          "new_api": null,
          "old_text": "VERIFY(new_main_thread)",
          "new_text": null,
          "old_line_content": "    VERIFY(new_main_thread);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": "view",
          "new_api": null,
          "old_text": "path->view()",
          "new_text": null,
          "old_line_content": "    auto auxv = generate_auxiliary_vector(load_result.load_base, load_result.entry_eip, uid(), euid(), gid(), egid(), path->view(), main_program_fd_allocation);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": "value",
          "new_api": null,
          "old_text": "make_stack_result.value()",
          "new_text": null,
          "old_line_content": "    FlatPtr new_userspace_sp = make_stack_result.value();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": "wait_for_tracer_at_next_execve",
          "new_api": null,
          "old_text": "wait_for_tracer_at_next_execve()",
          "new_text": null,
          "old_line_content": "    if (wait_for_tracer_at_next_execve()) {",
          "new_line_content": "        // Make sure we release the ptrace lock here or the tracer will block forever.",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": "send_urgent_signal_to_self",
          "new_api": null,
          "old_text": "Thread::current()->send_urgent_signal_to_self(SIGSTOP)",
          "new_text": null,
          "old_line_content": "        Thread::current()->send_urgent_signal_to_self(SIGSTOP);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": "unlock",
          "new_api": null,
          "old_text": "ptrace_locker.unlock()",
          "new_text": null,
          "old_line_content": "        ptrace_locker.unlock();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": "cli",
          "new_api": null,
          "old_text": "cli()",
          "new_text": null,
          "old_line_content": "    cli();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": "move",
          "new_api": null,
          "old_text": "move(new_main_thread_name)",
          "new_text": null,
          "old_line_content": "    new_main_thread->set_name(move(new_main_thread_name));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "load",
          "new_api": null,
          "old_text": "m_protected_values.has_execpromises.load()",
          "new_text": null,
          "old_line_content": "        m_protected_values.has_promises = m_protected_values.has_execpromises.load();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": "vaddr",
          "new_api": null,
          "old_text": "signal_trampoline_region->vaddr()",
          "new_text": null,
          "old_line_content": "        m_protected_values.signal_trampoline = signal_trampoline_region->vaddr();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "value",
          "new_api": null,
          "old_text": "new_main_thread->tid().value()",
          "new_text": null,
          "old_line_content": "        m_protected_values.pid = new_main_thread->tid().value();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": "is_error",
          "new_api": null,
          "old_text": "tsr_result.is_error()",
          "new_text": null,
          "old_line_content": "    if (tsr_result.is_error()) {",
          "new_line_content": "        // FIXME: We cannot fail this late. Refactor this so the allocation happens before we commit to the new executable.",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": "VERIFY_NOT_REACHED",
          "new_api": null,
          "old_text": "VERIFY_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "        VERIFY_NOT_REACHED();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "reset_fpu_state",
          "new_api": null,
          "old_text": "new_main_thread->reset_fpu_state()",
          "new_text": null,
          "old_line_content": "    new_main_thread->reset_fpu_state();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": "page_directory",
          "new_api": null,
          "old_text": "address_space().page_directory().cr3()",
          "new_text": null,
          "old_line_content": "    regs.cr3 = address_space().page_directory().cr3();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": "PerformanceManager::add_process_exec_event(*this)",
          "new_api": null,
          "old_text": "PerformanceManager::add_process_exec_event(*this)",
          "new_text": null,
          "old_line_content": "        PerformanceManager::add_process_exec_event(*this);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "set_state",
          "new_api": null,
          "old_text": "new_main_thread->set_state(Thread::State::Runnable)",
          "new_text": null,
          "old_line_content": "        new_main_thread->set_state(Thread::State::Runnable);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": "Processor::in_critical()",
          "new_api": null,
          "old_text": "Processor::in_critical()",
          "new_text": null,
          "old_line_content": "    VERIFY(Processor::in_critical());",
          "new_line_content": "    return KSuccess;",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "append",
          "new_api": null,
          "old_text": "auxv.append({ ELF::AuxiliaryValue::BaseAddress, (void*)load_base })",
          "new_text": null,
          "old_line_content": "    auxv.append({ ELF::AuxiliaryValue::BaseAddress, (void*)load_base });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": "append",
          "new_api": null,
          "old_text": "auxv.append({ ELF::AuxiliaryValue::Entry, (void*)entry_eip })",
          "new_text": null,
          "old_line_content": "    auxv.append({ ELF::AuxiliaryValue::Entry, (void*)entry_eip });",
          "new_line_content": "    // NOTELF",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "value",
          "new_api": null,
          "old_text": "egid.value()",
          "new_text": null,
          "old_line_content": "    auxv.append({ ELF::AuxiliaryValue::EGid, (long)egid.value() });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": "Processor::platform_string()",
          "new_api": null,
          "old_text": "Processor::platform_string()",
          "new_text": null,
          "old_line_content": "    auxv.append({ ELF::AuxiliaryValue::Platform, Processor::platform_string() });",
          "new_line_content": "    // FIXME: This is platform specific",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": "edx",
          "new_api": null,
          "old_text": "CPUID(1).edx()",
          "new_text": null,
          "old_line_content": "    auxv.append({ ELF::AuxiliaryValue::HwCap, (long)CPUID(1).edx() });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": "ticks_per_second",
          "new_api": null,
          "old_text": "TimeManagement::the().ticks_per_second()",
          "new_text": null,
          "old_line_content": "    auxv.append({ ELF::AuxiliaryValue::ClockTick, (long)TimeManagement::the().ticks_per_second() });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": "append",
          "new_api": null,
          "old_text": "auxv.append({ ELF::AuxiliaryValue::Secure, ((uid != euid) || (gid != egid)) ? 1 : 0 })",
          "new_text": null,
          "old_line_content": "    auxv.append({ ELF::AuxiliaryValue::Secure, ((uid != euid) || (gid != egid)) ? 1 : 0 });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": "get_fast_random_bytes",
          "new_api": null,
          "old_text": "get_fast_random_bytes({ (u8*)random_bytes, sizeof(random_bytes) })",
          "new_text": null,
          "old_line_content": "    get_fast_random_bytes({ (u8*)random_bytes, sizeof(random_bytes) });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": "String",
          "new_api": null,
          "old_text": "String(random_bytes, sizeof(random_bytes))",
          "new_text": null,
          "old_line_content": "    auxv.append({ ELF::AuxiliaryValue::Random, String(random_bytes, sizeof(random_bytes)) });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": "append",
          "new_api": null,
          "old_text": "auxv.append({ ELF::AuxiliaryValue::ExecFilename, executable_path })",
          "new_text": null,
          "old_line_content": "    auxv.append({ ELF::AuxiliaryValue::ExecFilename, executable_path });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "append",
          "new_api": null,
          "old_text": "auxv.append({ ELF::AuxiliaryValue::ExecFileDescriptor, main_program_fd_allocation->fd })",
          "new_text": null,
          "old_line_content": "        auxv.append({ ELF::AuxiliaryValue::ExecFileDescriptor, main_program_fd_allocation->fd });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": "append",
          "new_api": null,
          "old_text": "auxv.append({ ELF::AuxiliaryValue::Null, 0L })",
          "new_text": null,
          "old_line_content": "    auxv.append({ ELF::AuxiliaryValue::Null, 0L });",
          "new_line_content": "    return auxv;",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": "move",
          "new_api": null,
          "old_text": "move(word)",
          "new_text": null,
          "old_line_content": "                    interpreter_words.append(move(word));",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": "move",
          "new_api": null,
          "old_text": "move(word)",
          "new_text": null,
          "old_line_content": "            interpreter_words.append(move(word));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "interpreter_words.is_empty()",
          "new_text": null,
          "old_line_content": "        if (!interpreter_words.is_empty())",
          "new_line_content": "            return interpreter_words;",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"exec({}): File has invalid ELF Program headers\", path)",
          "new_text": null,
          "old_line_content": "        dbgln(\"exec({}): File has invalid ELF Program headers\", path);",
          "new_line_content": "        return ENOEXEC;",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "metadata",
          "new_api": null,
          "old_text": "interpreter_description->metadata()",
          "new_text": null,
          "old_line_content": "        auto interp_metadata = interpreter_description->metadata();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": "inode",
          "new_api": null,
          "old_text": "interpreter_description->inode()",
          "new_text": null,
          "old_line_content": "        VERIFY(interpreter_description->inode());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": "ElfW",
          "new_api": null,
          "old_text": "ElfW(Ehdr)",
          "new_text": null,
          "old_line_content": "        if (interp_metadata.size < (int)sizeof(ElfW(Ehdr)))",
          "new_line_content": "            return ENOEXEC;",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": "read",
          "new_api": null,
          "old_text": "interpreter_description->read(first_page_buffer, sizeof(first_page))",
          "new_text": null,
          "old_line_content": "        auto nread = TRY(interpreter_description->read(first_page_buffer, sizeof(first_page)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": "ElfW",
          "new_api": null,
          "old_text": "ElfW(Ehdr)",
          "new_text": null,
          "old_line_content": "        if (nread < sizeof(ElfW(Ehdr)))",
          "new_line_content": "            return ENOEXEC;",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "absolute_path",
          "new_api": null,
          "old_text": "interpreter_description->absolute_path()",
          "new_text": null,
          "old_line_content": "            dbgln(\"exec({}): Interpreter ({}) has invalid ELF header\", path, interpreter_description->absolute_path());",
          "new_line_content": "            return ENOEXEC;",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": "absolute_path",
          "new_api": null,
          "old_text": "interpreter_description->absolute_path()",
          "new_text": null,
          "old_line_content": "            dbgln(\"exec({}): Interpreter ({}) has invalid ELF Program headers\", path, interpreter_description->absolute_path());",
          "new_line_content": "            return ENOEXEC;",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": "absolute_path",
          "new_api": null,
          "old_text": "interpreter_description->absolute_path()",
          "new_text": null,
          "old_line_content": "            dbgln(\"exec({}): Interpreter ({}) has its own interpreter ({})! No thank you!\", path, interpreter_description->absolute_path(), interpreter_interpreter_path);",
          "new_line_content": "            return ELOOP;",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"exec({}): WARNING - Dynamic ELF executable without a PT_INTERP header, and isn't /usr/lib/Loader.so\", path)",
          "new_text": null,
          "old_line_content": "            dbgln(\"exec({}): WARNING - Dynamic ELF executable without a PT_INTERP header, and isn't /usr/lib/Loader.so\", path);",
          "new_line_content": "        return nullptr;",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"exec({}): SHENANIGANS! recursed too far trying to find #! interpreter\", path)",
          "new_text": null,
          "old_line_content": "        dbgln(\"exec({}): SHENANIGANS! recursed too far trying to find #! interpreter\", path);",
          "new_line_content": "        return ELOOP;",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": "metadata",
          "new_api": null,
          "old_text": "description->metadata()",
          "new_text": null,
          "old_line_content": "    auto metadata = description->metadata();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": "is_regular_file",
          "new_api": null,
          "old_text": "metadata.is_regular_file()",
          "new_text": null,
          "old_line_content": "    if (!metadata.is_regular_file())",
          "new_line_content": "        return EACCES;",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": "inode",
          "new_api": null,
          "old_text": "description->inode()",
          "new_text": null,
          "old_line_content": "    VERIFY(description->inode());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "read",
          "new_api": null,
          "old_text": "description->read(first_page_buffer, sizeof(first_page))",
          "new_text": null,
          "old_line_content": "    auto nread = TRY(description->read(first_page_buffer, sizeof(first_page)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "move",
          "new_api": null,
          "old_text": "move(shebang_words)",
          "new_text": null,
          "old_line_content": "        if (!arguments.try_prepend(move(shebang_words)))",
          "new_line_content": "            return ENOMEM;",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "move",
          "new_api": null,
          "old_text": "move(environment)",
          "new_text": null,
          "old_line_content": "        return exec(move(shebang_path), move(arguments), move(environment), ++recursion_depth);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": "ElfW",
          "new_api": null,
          "old_text": "ElfW(Ehdr)",
          "new_text": null,
          "old_line_content": "    if (nread < sizeof(ElfW(Ehdr)))",
          "new_line_content": "        return ENOEXEC;",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": "ElfW",
          "new_api": null,
          "old_text": "ElfW(Ehdr)",
          "new_text": null,
          "old_line_content": "    auto main_program_header = (ElfW(Ehdr)*)first_page;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"exec({}): File has invalid ELF header\", path)",
          "new_text": null,
          "old_line_content": "        dbgln(\"exec({}): File has invalid ELF header\", path);",
          "new_line_content": "        return ENOEXEC;",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": "move",
          "new_api": null,
          "old_text": "move(interpreter_description)",
          "new_text": null,
          "old_line_content": "    TRY(do_exec(move(description), move(arguments), move(environment), move(interpreter_description), new_main_thread, prev_flags, *main_program_header));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "Processor::in_critical()",
          "new_api": null,
          "old_text": "Processor::in_critical()",
          "new_text": null,
          "old_line_content": "    VERIFY(Processor::in_critical());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "Thread::current()",
          "new_api": null,
          "old_text": "Thread::current()",
          "new_text": null,
          "old_line_content": "    auto current_thread = Thread::current();",
          "new_line_content": "    if (current_thread == new_main_thread) {",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": "VERIFY_NOT_REACHED",
          "new_api": null,
          "old_text": "VERIFY_NOT_REACHED()",
          "new_text": null,
          "old_line_content": "        VERIFY_NOT_REACHED();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": "Processor::leave_critical()",
          "new_api": null,
          "old_text": "Processor::leave_critical()",
          "new_text": null,
          "old_line_content": "    Processor::leave_critical();",
          "new_line_content": "    return KSuccess;",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "REQUIRE_PROMISE",
          "new_api": null,
          "old_text": "REQUIRE_PROMISE(exec)",
          "new_text": null,
          "old_line_content": "    REQUIRE_PROMISE(exec);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": "copy_typed_from_user",
          "new_api": null,
          "old_text": "copy_typed_from_user(user_params)",
          "new_text": null,
          "old_line_content": "    auto params = TRY(copy_typed_from_user(user_params));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "get_syscall_path_argument",
          "new_api": null,
          "old_text": "get_syscall_path_argument(params.path)",
          "new_text": null,
          "old_line_content": "    auto path = TRY(get_syscall_path_argument(params.path));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": "has_overflow",
          "new_api": null,
          "old_text": "size.has_overflow()",
          "new_text": null,
          "old_line_content": "        if (size.has_overflow())",
          "new_line_content": "            return EOVERFLOW;",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "try_resize",
          "new_api": null,
          "old_text": "strings.try_resize(list.length)",
          "new_text": null,
          "old_line_content": "        if (!strings.try_resize(list.length))",
          "new_line_content": "            return ENOMEM;",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": "value",
          "new_api": null,
          "old_text": "size.value()",
          "new_text": null,
          "old_line_content": "        TRY(copy_from_user(strings.data(), list.strings, size.value()));",
          "new_line_content": "        for (size_t i = 0; i < list.length; ++i) {",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "move",
          "new_api": null,
          "old_text": "move(string)",
          "new_text": null,
          "old_line_content": "            if (!output.try_append(move(string)))",
          "new_line_content": "                return ENOMEM;",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": "copy_user_strings",
          "new_api": null,
          "old_text": "copy_user_strings(params.arguments, arguments)",
          "new_text": null,
          "old_line_content": "    TRY(copy_user_strings(params.arguments, arguments));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": "copy_user_strings",
          "new_api": null,
          "old_text": "copy_user_strings(params.environment, environment)",
          "new_text": null,
          "old_line_content": "    TRY(copy_user_strings(params.environment, environment));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "error",
          "new_api": null,
          "old_text": "result.error()",
          "new_text": null,
          "old_line_content": "    return result.error();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "load",
          "new_api": null,
          "old_text": "load(main_program_description, interpreter_description, main_program_header)",
          "new_text": null,
          "old_line_content": "    auto load_result = TRY(load(main_program_description, interpreter_description, main_program_header));",
          "new_line_content": "    // NOTE: We don't need the interpreter executable description after this point.",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "vmobject",
          "new_api": null,
          "old_text": "g_signal_trampoline_region->vmobject()",
          "new_text": null,
          "old_line_content": "    auto signal_trampoline_region = TRY(load_result.space->allocate_region_with_vmobject(signal_trampoline_range, g_signal_trampoline_region->vmobject(), 0, \"Signal trampoline\", PROT_READ | PROT_EXEC, true));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": "set_syscall_region",
          "new_api": null,
          "old_text": "signal_trampoline_region->set_syscall_region(true)",
          "new_text": null,
          "old_line_content": "    signal_trampoline_region->set_syscall_region(true);",
          "new_line_content": "    // (For dynamically linked executable) Allocate an FD for passing the main executable to the dynamic loader.",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": "allocate",
          "new_api": null,
          "old_text": "m_fds.allocate()",
          "new_text": null,
          "old_line_content": "        main_program_fd_allocation = TRY(m_fds.allocate());",
          "new_line_content": "    // We commit to the new executable at this point. There is no turning back!",
          "content_same": false
        },
        {
          "line": 486,
          "old_api": "kill_threads_except_self",
          "new_api": null,
          "old_text": "kill_threads_except_self()",
          "new_text": null,
          "old_line_content": "    kill_threads_except_self();",
          "new_line_content": "    bool executable_is_setid = false;",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": "is_setuid",
          "new_api": null,
          "old_text": "main_program_metadata.is_setuid()",
          "new_text": null,
          "old_line_content": "        if (main_program_metadata.is_setuid()) {",
          "new_line_content": "            executable_is_setid = true;",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": "is_setgid",
          "new_api": null,
          "old_text": "main_program_metadata.is_setgid()",
          "new_text": null,
          "old_line_content": "        if (main_program_metadata.is_setgid()) {",
          "new_line_content": "            executable_is_setid = true;",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": "set_dumpable",
          "new_api": null,
          "old_text": "set_dumpable(!executable_is_setid)",
          "new_text": null,
          "old_line_content": "    set_dumpable(!executable_is_setid);",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 49,
      "total_additions": 86,
      "total_deletions": 86,
      "total_api_changes": 221
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 3,
        "api_related_lines": 221,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          458
        ]
      }
    },
    "api_calls_before": 464,
    "api_calls_after": 464,
    "diff_info": {
      "added_lines": 1,
      "removed_lines": 2,
      "total_diff_lines": 22
    }
  }
}