{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/88ef1bff389ef483222a92587cc610900ac6e1de",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/88ef1bff389ef483222a92587cc610900ac6e1de/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/88ef1bff389ef483222a92587cc610900ac6e1de/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/88ef1bff389ef483222a92587cc610900ac6e1de/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": true,
    "api_changes": {
      "replacements": [
        {
          "line": 185,
          "old_api": "is_identity",
          "new_api": "is_identity_or_translation",
          "old_text": "m_drawing_state.transform.is_identity()",
          "new_text": "m_drawing_state.transform.is_identity_or_translation()",
          "old_line_content": "    if (m_drawing_state.transform.is_identity()) {",
          "new_line_content": "    if (m_drawing_state.transform.is_identity_or_translation()) {",
          "content_same": false
        },
        {
          "line": 203,
          "old_api": "has_value",
          "new_api": "inverse",
          "old_text": "inverse_transform.has_value()",
          "new_text": "m_drawing_state.transform.inverse()",
          "old_line_content": "        if (!inverse_transform.has_value())",
          "new_line_content": "        auto inverse_transform = m_drawing_state.transform.inverse();",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": "bounding_rect",
          "new_api": "map_to_quad",
          "old_text": "destination_quad.bounding_rect().to_rounded<int>()",
          "new_text": "m_drawing_state.transform.map_to_quad(destination_rect)",
          "old_line_content": "        auto destination_bounding_rect = destination_quad.bounding_rect().to_rounded<int>();",
          "new_line_content": "        auto destination_quad = m_drawing_state.transform.map_to_quad(destination_rect);",
          "content_same": false
        },
        {
          "line": 211,
          "old_api": "scale",
          "new_api": "translate",
          "old_text": "source_transform.scale(source_width / destination_width, source_height / destination_height)",
          "new_text": "source_transform.translate(source_x, source_y)",
          "old_line_content": "        source_transform.scale(source_width / destination_width, source_height / destination_height);",
          "new_line_content": "        source_transform.translate(source_x, source_y);",
          "content_same": false
        },
        {
          "line": 212,
          "old_api": "translate",
          "new_api": "scale",
          "old_text": "source_transform.translate(-destination_x, -destination_y)",
          "new_text": "source_transform.scale(source_width / destination_width, source_height / destination_height)",
          "old_line_content": "        source_transform.translate(-destination_x, -destination_y);",
          "new_line_content": "        source_transform.scale(source_width / destination_width, source_height / destination_height);",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": "right",
          "new_api": "bottom",
          "old_text": "destination_bounding_rect.right()",
          "new_text": "destination_bounding_rect.bottom()",
          "old_line_content": "            for (int x = destination_bounding_rect.x(); x <= destination_bounding_rect.right(); ++x) {",
          "new_line_content": "        for (int y = destination_bounding_rect.y(); y <= destination_bounding_rect.bottom(); ++y) {",
          "content_same": false
        },
        {
          "line": 222,
          "old_api": "contains",
          "new_api": "map",
          "old_text": "bitmap->rect().contains(source_point)",
          "new_text": "inverse_transform->map(destination_point)",
          "old_line_content": "                if (!bitmap->rect().contains(source_point))",
          "new_line_content": "                auto source_point = source_transform.map(inverse_transform->map(destination_point)).to_rounded<int>();",
          "content_same": false
        },
        {
          "line": 225,
          "old_api": "alpha",
          "new_api": "get_pixel",
          "old_text": "source_color.alpha()",
          "new_text": "bitmap->get_pixel(source_point)",
          "old_line_content": "                if (source_color.alpha() == 0)",
          "new_line_content": "                auto source_color = bitmap->get_pixel(source_point);",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": "set_pixel",
          "new_api": "alpha",
          "old_text": "painter->set_pixel(destination_point, source_color)",
          "new_text": "source_color.alpha()",
          "old_line_content": "                    painter->set_pixel(destination_point, source_color);",
          "new_line_content": "                if (source_color.alpha() == 255) {",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": "blend",
          "new_api": "target",
          "old_text": "dst_color.blend(source_color)",
          "new_text": "painter->target()->get_pixel(destination_point)",
          "old_line_content": "                painter->set_pixel(destination_point, dst_color.blend(source_color));",
          "new_line_content": "                auto dst_color = painter->target()->get_pixel(destination_point);",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": "scale",
          "new_api": "dbgln_if",
          "old_text": "m_drawing_state.transform.scale(sx, sy)",
          "new_text": "dbgln_if(CANVAS_RENDERING_CONTEXT_2D_DEBUG, \"CanvasRenderingContext2D::scale({}, {})\", sx, sy)",
          "old_line_content": "    m_drawing_state.transform.scale(sx, sy);",
          "new_line_content": "    dbgln_if(CANVAS_RENDERING_CONTEXT_2D_DEBUG, \"CanvasRenderingContext2D::scale({}, {})\", sx, sy);",
          "content_same": false
        },
        {
          "line": 253,
          "old_api": "translate",
          "new_api": "dbgln_if",
          "old_text": "m_drawing_state.transform.translate(tx, ty)",
          "new_text": "dbgln_if(CANVAS_RENDERING_CONTEXT_2D_DEBUG, \"CanvasRenderingContext2D::translate({}, {})\", tx, ty)",
          "old_line_content": "    m_drawing_state.transform.translate(tx, ty);",
          "new_line_content": "    dbgln_if(CANVAS_RENDERING_CONTEXT_2D_DEBUG, \"CanvasRenderingContext2D::translate({}, {})\", tx, ty);",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": "rotate_radians",
          "new_api": "dbgln_if",
          "old_text": "m_drawing_state.transform.rotate_radians(radians)",
          "new_text": "dbgln_if(CANVAS_RENDERING_CONTEXT_2D_DEBUG, \"CanvasRenderingContext2D::rotate({})\", radians)",
          "old_line_content": "    m_drawing_state.transform.rotate_radians(radians);",
          "new_line_content": "    dbgln_if(CANVAS_RENDERING_CONTEXT_2D_DEBUG, \"CanvasRenderingContext2D::rotate({})\", radians);",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": "create_bitmap",
          "new_api": "bitmap",
          "old_text": "m_element->create_bitmap()",
          "new_text": "m_element->bitmap()",
          "old_line_content": "        if (!m_element->create_bitmap())",
          "new_line_content": "    if (!m_element->bitmap()) {",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": "map",
          "new_api": "pixel_size",
          "old_text": "m_drawing_state.transform.map(text_rect)",
          "new_text": "painter->font().pixel_size()",
          "old_line_content": "    auto transformed_rect = m_drawing_state.transform.map(text_rect);",
          "new_line_content": "    auto text_rect = Gfx::IntRect(x, y, max_width.has_value() ? max_width.value() : painter->font().width(text), painter->font().pixel_size());",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": "draw_text",
          "new_api": "map",
          "old_text": "painter->draw_text(transformed_rect, text, Gfx::TextAlignment::TopLeft, m_drawing_state.fill_style)",
          "new_text": "m_drawing_state.transform.map(text_rect)",
          "old_line_content": "    painter->draw_text(transformed_rect, text, Gfx::TextAlignment::TopLeft, m_drawing_state.fill_style);",
          "new_line_content": "    auto transformed_rect = m_drawing_state.transform.map(text_rect);",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": "transformed_rect.to_type<float>()",
          "new_api": "draw_text",
          "old_text": "transformed_rect.to_type<float>()",
          "new_text": "painter->draw_text(transformed_rect, text, Gfx::TextAlignment::TopLeft, m_drawing_state.fill_style)",
          "old_line_content": "    did_draw(transformed_rect.to_type<float>());",
          "new_line_content": "    painter->draw_text(transformed_rect, text, Gfx::TextAlignment::TopLeft, m_drawing_state.fill_style);",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": "ellipse",
          "new_api": "String::formatted(\"The radius provided ({}) is negative.\", radius)",
          "old_text": "ellipse(x, y, radius, radius, 0, start_angle, end_angle, counter_clockwise)",
          "new_text": "String::formatted(\"The radius provided ({}) is negative.\", radius)",
          "old_line_content": "    return ellipse(x, y, radius, radius, 0, start_angle, end_angle, counter_clockwise);",
          "new_line_content": "        return DOM::IndexSizeError::create(String::formatted(\"The radius provided ({}) is negative.\", radius));",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": "cosf",
          "new_api": "sinf",
          "old_text": "cosf(rotation)",
          "new_text": "sinf(rotation)",
          "old_line_content": "    auto cos_rotation = cosf(rotation);",
          "new_line_content": "    auto sin_rotation = sinf(rotation);",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "close",
          "new_api": "line_to",
          "old_text": "m_path.close()",
          "new_text": "m_path.line_to({ x, y + height })",
          "old_line_content": "    m_path.close();",
          "new_line_content": "    m_path.line_to({ x, y + height });",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": "bounding_box",
          "new_api": "stroke_path",
          "old_text": "m_path.bounding_box()",
          "new_text": "painter->stroke_path(m_path, m_drawing_state.stroke_style, m_drawing_state.line_width)",
          "old_line_content": "    did_draw(m_path.bounding_box());",
          "new_line_content": "    painter->stroke_path(m_path, m_drawing_state.stroke_style, m_drawing_state.line_width);",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": "fill_path",
          "new_api": "close_all_subpaths",
          "old_text": "painter->fill_path(path, m_drawing_state.fill_style, winding)",
          "new_text": "path.close_all_subpaths()",
          "old_line_content": "    painter->fill_path(path, m_drawing_state.fill_style, winding);",
          "new_line_content": "    path.close_all_subpaths();",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": "bounding_box",
          "new_api": "fill_path",
          "old_text": "m_path.bounding_box()",
          "new_text": "painter->fill_path(path, m_drawing_state.fill_style, winding)",
          "old_line_content": "    did_draw(m_path.bounding_box());",
          "new_line_content": "    painter->fill_path(path, m_drawing_state.fill_style, winding);",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": "dbgln",
          "new_api": "wrapper",
          "old_text": "dbgln(\"Hmm! Attempted to create ImageData for wrapper-less CRC2D.\")",
          "new_text": "wrapper()",
          "old_line_content": "        dbgln(\"Hmm! Attempted to create ImageData for wrapper-less CRC2D.\");",
          "new_line_content": "    if (!wrapper()) {",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": "width",
          "new_api": "height",
          "old_text": "source_rect_intersected.width()",
          "new_text": "source_rect_intersected.height()",
          "old_line_content": "        for (int target_x = 0; target_x < source_rect_intersected.width(); ++target_x) {",
          "new_line_content": "    for (int target_y = 0; target_y < source_rect_intersected.height(); ++target_y) {",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": "get_pixel",
          "new_api": "width",
          "old_text": "bitmap.get_pixel(target_x + x, target_y + y)",
          "new_text": "source_rect_intersected.width()",
          "old_line_content": "            auto pixel = bitmap.get_pixel(target_x + x, target_y + y);",
          "new_line_content": "        for (int target_x = 0; target_x < source_rect_intersected.width(); ++target_x) {",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": "set_pixel",
          "new_api": "get_pixel",
          "old_text": "image_data->bitmap().set_pixel(target_x, target_y, pixel)",
          "new_text": "bitmap.get_pixel(target_x + x, target_y + y)",
          "old_line_content": "            image_data->bitmap().set_pixel(target_x, target_y, pixel);",
          "new_line_content": "            auto pixel = bitmap.get_pixel(target_x + x, target_y + y);",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": "TextMetrics::create()",
          "new_api": "prepare_text",
          "old_text": "TextMetrics::create()",
          "new_text": "prepare_text(text)",
          "old_line_content": "    auto metrics = TextMetrics::create();",
          "new_line_content": "    auto prepared_text = prepare_text(text);",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "length",
          "new_api": "static_cast<int>(height)",
          "old_text": "replaced_text.length()",
          "new_text": "static_cast<int>(height)",
          "old_line_content": "    prepared_text.glyphs.ensure_capacity(replaced_text.length());",
          "new_line_content": "    PreparedText prepared_text { {}, physical_alignment, { 0, 0, static_cast<int>(width), static_cast<int>(height) } };",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": "glyph_or_emoji_width",
          "new_api": "static_cast<int>(offset)",
          "old_text": "font.glyph_or_emoji_width(c)",
          "new_text": "static_cast<int>(offset)",
          "old_line_content": "        offset += font.glyph_or_emoji_width(c);",
          "new_line_content": "        prepared_text.glyphs.append({ c, { static_cast<int>(offset), 0 } });",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "DOM::InvalidStateError::create(\"Canvas width or height is zero\")",
          "new_api": "height",
          "old_text": "DOM::InvalidStateError::create(\"Canvas width or height is zero\")",
          "new_text": "canvas_element.height()",
          "old_line_content": "                return DOM::InvalidStateError::create(\"Canvas width or height is zero\");",
          "new_line_content": "            if (canvas_element.width() == 0 || canvas_element.height() == 0)",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": "release_value",
          "new_api": "has_value",
          "old_text": "usability.release_value()",
          "new_text": "usability.has_value()",
          "old_line_content": "        return usability.release_value();",
          "new_line_content": "    if (usability.has_value())",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 517,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "m_drawing_state_stack.is_empty()",
          "old_line_content": "        return;",
          "new_line_content": "    if (m_drawing_state_stack.is_empty())",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": null,
          "new_api": "take_last",
          "old_text": null,
          "new_text": "m_drawing_state_stack.take_last()",
          "old_line_content": "}",
          "new_line_content": "    m_drawing_state = m_drawing_state_stack.take_last();",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": null,
          "new_api": "reset_to_default_state",
          "old_text": null,
          "new_text": "reset_to_default_state()",
          "old_line_content": "}",
          "new_line_content": "    reset_to_default_state();",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": null,
          "new_api": "painter",
          "old_text": null,
          "new_text": "this->painter()",
          "old_line_content": "",
          "new_line_content": "    auto painter = this->painter();",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": null,
          "new_api": "target",
          "old_text": null,
          "new_text": "painter->target()->rect()",
          "old_line_content": "",
          "new_line_content": "        painter->clear_rect(painter->target()->rect(), Color::Transparent);",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "m_path.clear()",
          "old_line_content": "",
          "new_line_content": "    m_path.clear();",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "m_drawing_state_stack.clear()",
          "old_line_content": "",
          "new_line_content": "    m_drawing_state_stack.clear();",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": null,
          "new_api": "target",
          "old_text": null,
          "new_text": "painter->target()->rect().to_type<float>()",
          "old_line_content": "}",
          "new_line_content": "        did_draw(painter->target()->rect().to_type<float>());",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": null,
          "new_api": "TextMetrics::create()",
          "old_text": null,
          "new_text": "TextMetrics::create()",
          "old_line_content": "    // FIXME: Use the font that was used to create the glyphs in prepared_text.",
          "new_line_content": "    auto metrics = TextMetrics::create();",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": null,
          "new_api": "Gfx::FontDatabase::default_font()",
          "old_text": null,
          "new_text": "Gfx::FontDatabase::default_font()",
          "old_line_content": "",
          "new_line_content": "    auto& font = Gfx::FontDatabase::default_font();",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "prepared_text.bounding_box.width()",
          "old_line_content": "    // actualBoundingBoxLeft attribute: The distance parallel to the baseline from the alignment point given by the textAlign attribute to the left side of the bounding rectangle of the given text, in CSS pixels; positive numbers indicating a distance going left from the given alignment point.",
          "new_line_content": "    metrics->set_width(prepared_text.bounding_box.width());",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": null,
          "new_api": "left",
          "old_text": null,
          "new_text": "prepared_text.bounding_box.left()",
          "old_line_content": "    // actualBoundingBoxRight attribute: The distance parallel to the baseline from the alignment point given by the textAlign attribute to the right side of the bounding rectangle of the given text, in CSS pixels; positive numbers indicating a distance going right from the given alignment point.",
          "new_line_content": "    metrics->set_actual_bounding_box_left(-prepared_text.bounding_box.left());",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": null,
          "new_api": "right",
          "old_text": null,
          "new_text": "prepared_text.bounding_box.right()",
          "old_line_content": "    // fontBoundingBoxAscent attribute: The distance from the horizontal line indicated by the textBaseline attribute to the ascent metric of the first available font, in CSS pixels; positive numbers indicating a distance going up from the given baseline.",
          "new_line_content": "    metrics->set_actual_bounding_box_right(prepared_text.bounding_box.right());",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": null,
          "new_api": "baseline",
          "old_text": null,
          "new_text": "font.baseline()",
          "old_line_content": "    // fontBoundingBoxDescent attribute: The distance from the horizontal line indicated by the textBaseline attribute to the descent metric of the first available font, in CSS pixels; positive numbers indicating a distance going down from the given baseline.",
          "new_line_content": "    metrics->set_font_bounding_box_ascent(font.baseline());",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": null,
          "new_api": "baseline",
          "old_text": null,
          "new_text": "font.baseline()",
          "old_line_content": "    // actualBoundingBoxAscent attribute: The distance from the horizontal line indicated by the textBaseline attribute to the top of the bounding rectangle of the given text, in CSS pixels; positive numbers indicating a distance going up from the given baseline.",
          "new_line_content": "    metrics->set_font_bounding_box_descent(prepared_text.bounding_box.height() - font.baseline());",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": null,
          "new_api": "baseline",
          "old_text": null,
          "new_text": "font.baseline()",
          "old_line_content": "    // actualBoundingBoxDescent attribute: The distance from the horizontal line indicated by the textBaseline attribute to the bottom of the bounding rectangle of the given text, in CSS pixels; positive numbers indicating a distance going down from the given baseline.",
          "new_line_content": "    metrics->set_actual_bounding_box_ascent(font.baseline());",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": null,
          "new_api": "baseline",
          "old_text": null,
          "new_text": "font.baseline()",
          "old_line_content": "    // emHeightAscent attribute: The distance from the horizontal line indicated by the textBaseline attribute to the highest top of the em squares in the inline box, in CSS pixels; positive numbers indicating that the given baseline is below the top of that em square (so this value will usually be positive). Zero if the given baseline is the top of that em square; half the font size if the given baseline is the middle of that em square.",
          "new_line_content": "    metrics->set_actual_bounding_box_descent(prepared_text.bounding_box.height() - font.baseline());",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": null,
          "new_api": "baseline",
          "old_text": null,
          "new_text": "font.baseline()",
          "old_line_content": "    // emHeightDescent attribute: The distance from the horizontal line indicated by the textBaseline attribute to the lowest bottom of the em squares in the inline box, in CSS pixels; positive numbers indicating that the given baseline is above the bottom of that em square. (Zero if the given baseline is the bottom of that em square.)",
          "new_line_content": "    metrics->set_em_height_ascent(font.baseline());",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": null,
          "new_api": "baseline",
          "old_text": null,
          "new_text": "font.baseline()",
          "old_line_content": "    // hangingBaseline attribute: The distance from the horizontal line indicated by the textBaseline attribute to the hanging baseline of the inline box, in CSS pixels; positive numbers indicating that the given baseline is below the hanging baseline. (Zero if the given baseline is the hanging baseline.)",
          "new_line_content": "    metrics->set_em_height_descent(prepared_text.bounding_box.height() - font.baseline());",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": null,
          "new_api": "baseline",
          "old_text": null,
          "new_text": "font.baseline()",
          "old_line_content": "    // alphabeticBaseline attribute: The distance from the horizontal line indicated by the textBaseline attribute to the alphabetic baseline of the inline box, in CSS pixels; positive numbers indicating that the given baseline is below the alphabetic baseline. (Zero if the given baseline is the alphabetic baseline.)",
          "new_line_content": "    metrics->set_hanging_baseline(font.baseline());",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": null,
          "new_api": "set_font_bounding_box_ascent",
          "old_text": null,
          "new_text": "metrics->set_font_bounding_box_ascent(0)",
          "old_line_content": "    // ideographicBaseline attribute: The distance from the horizontal line indicated by the textBaseline attribute to the ideographic-under baseline of the inline box, in CSS pixels; positive numbers indicating that the given baseline is below the ideographic-under baseline. (Zero if the given baseline is the ideographic-under baseline.)",
          "new_line_content": "    metrics->set_font_bounding_box_ascent(0);",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": null,
          "new_api": "set_font_bounding_box_ascent",
          "old_text": null,
          "new_text": "metrics->set_font_bounding_box_ascent(0)",
          "old_line_content": "",
          "new_line_content": "    metrics->set_font_bounding_box_ascent(0);",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "text.length()",
          "old_line_content": "    for (auto c : text) {",
          "new_line_content": "    StringBuilder builder { text.length() };",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": null,
          "new_api": "is_ascii_space",
          "old_text": null,
          "new_text": "is_ascii_space(c)",
          "old_line_content": "    }",
          "new_line_content": "        builder.append(is_ascii_space(c) ? ' ' : c);",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": null,
          "new_api": "build",
          "old_text": null,
          "new_text": "builder.build()",
          "old_line_content": "",
          "new_line_content": "    String replaced_text = builder.build();",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": null,
          "new_api": "Gfx::FontDatabase::default_font()",
          "old_text": null,
          "new_text": "Gfx::FontDatabase::default_font()",
          "old_line_content": "    size_t width = 0;",
          "new_line_content": "    auto& font = Gfx::FontDatabase::default_font();",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": null,
          "new_api": "pixel_size",
          "old_text": null,
          "new_text": "font.pixel_size()",
          "old_line_content": "    for (auto c : Utf8View { replaced_text }) {",
          "new_line_content": "    size_t height = font.pixel_size();",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": null,
          "new_api": "glyph_or_emoji_width",
          "old_text": null,
          "new_text": "font.glyph_or_emoji_width(c)",
          "old_line_content": "    }",
          "new_line_content": "        width += font.glyph_or_emoji_width(c);",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "replaced_text.length()",
          "old_line_content": "",
          "new_line_content": "    prepared_text.glyphs.ensure_capacity(replaced_text.length());",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": null,
          "new_api": "glyph_or_emoji_width",
          "old_text": null,
          "new_text": "font.glyph_or_emoji_width(c)",
          "old_line_content": "    }",
          "new_line_content": "        offset += font.glyph_or_emoji_width(c);",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": null,
          "new_api": "CanvasGradient::create_radial(x0, y0, r0, x1, y1, r1)",
          "old_text": null,
          "new_text": "CanvasGradient::create_radial(x0, y0, r0, x1, y1, r1)",
          "old_line_content": "}",
          "new_line_content": "    return CanvasGradient::create_radial(x0, y0, r0, x1, y1, r1);",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": null,
          "new_api": "CanvasGradient::create_linear(x0, y0, x1, y1)",
          "old_text": null,
          "new_text": "CanvasGradient::create_linear(x0, y0, x1, y1)",
          "old_line_content": "}",
          "new_line_content": "    return CanvasGradient::create_linear(x0, y0, x1, y1);",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": null,
          "new_api": "CanvasGradient::create_conic(start_angle, x, y)",
          "old_text": null,
          "new_text": "CanvasGradient::create_conic(start_angle, x, y)",
          "old_line_content": "}",
          "new_line_content": "    return CanvasGradient::create_conic(start_angle, x, y);",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": null,
          "new_api": "f",
          "old_text": null,
          "new_text": "m_drawing_state.transform.f()",
          "old_line_content": "        // There's no affine transformation to worry about, we can just call Gfx::Painter.",
          "new_line_content": "        painter->translate(m_drawing_state.transform.e(), m_drawing_state.transform.f());",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": null,
          "new_api": "isfinite",
          "old_text": null,
          "new_text": "isfinite(f)",
          "old_line_content": "        return;",
          "new_line_content": "    if (!isfinite(a) || !isfinite(b) || !isfinite(c) || !isfinite(d) || !isfinite(e) || !isfinite(f))",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": null,
          "new_api": "f",
          "old_text": null,
          "new_text": "m_drawing_state.transform.f()",
          "old_line_content": "    } else {",
          "new_line_content": "        painter->translate(-m_drawing_state.transform.e(), -m_drawing_state.transform.f());",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": null,
          "new_api": "static_cast<float>(f)",
          "old_text": null,
          "new_text": "static_cast<float>(f)",
          "old_line_content": "}",
          "new_line_content": "    m_drawing_state.transform.multiply({ static_cast<float>(a), static_cast<float>(b), static_cast<float>(c), static_cast<float>(d), static_cast<float>(e), static_cast<float>(f) });",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": null,
          "new_api": "isfinite",
          "old_text": null,
          "new_text": "isfinite(f)",
          "old_line_content": "        return;",
          "new_line_content": "    if (!isfinite(a) || !isfinite(b) || !isfinite(c) || !isfinite(d) || !isfinite(e) || !isfinite(f))",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "inverse_transform.has_value()",
          "old_line_content": "            return {};",
          "new_line_content": "        if (!inverse_transform.has_value())",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": null,
          "new_api": "bounding_rect",
          "old_text": null,
          "new_text": "destination_quad.bounding_rect().to_rounded<int>()",
          "old_line_content": "",
          "new_line_content": "        auto destination_bounding_rect = destination_quad.bounding_rect().to_rounded<int>();",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": null,
          "new_api": "transform",
          "old_text": null,
          "new_text": "transform(a, b, c, d, e, f)",
          "old_line_content": "}",
          "new_line_content": "    transform(a, b, c, d, e, f);",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": null,
          "new_api": "translate",
          "old_text": null,
          "new_text": "source_transform.translate(-destination_x, -destination_y)",
          "old_line_content": "",
          "new_line_content": "        source_transform.translate(-destination_x, -destination_y);",
          "content_same": false
        },
        {
          "line": 216,
          "old_api": null,
          "new_api": "right",
          "old_text": null,
          "new_text": "destination_bounding_rect.right()",
          "old_line_content": "                auto destination_point = Gfx::IntPoint { x, y };",
          "new_line_content": "            for (int x = destination_bounding_rect.x(); x <= destination_bounding_rect.right(); ++x) {",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "painter->clip_rect().contains(destination_point)",
          "old_line_content": "                    continue;",
          "new_line_content": "                if (!painter->clip_rect().contains(destination_point))",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": null,
          "new_api": "destination_point.to_type<float>()",
          "old_text": null,
          "new_text": "destination_point.to_type<float>()",
          "old_line_content": "                    continue;",
          "new_line_content": "                if (!destination_quad.contains(destination_point.to_type<float>()))",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "bitmap->rect().contains(source_point)",
          "old_line_content": "                    continue;",
          "new_line_content": "                if (!bitmap->rect().contains(source_point))",
          "content_same": false
        },
        {
          "line": 226,
          "old_api": null,
          "new_api": "alpha",
          "old_text": null,
          "new_text": "source_color.alpha()",
          "old_line_content": "                    continue;",
          "new_line_content": "                if (source_color.alpha() == 0)",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": null,
          "new_api": "visit",
          "old_text": null,
          "new_text": "image.visit(\n        // HTMLOrSVGImageElement\n        [](HTMLImageElement const& image_element) -> DOM::ExceptionOr<Optional<CanvasImageSourceUsability>> {\n            // FIXME: If image's current request's state is broken, then throw an \"InvalidStateError\" DOMException.\n\n            // If image is not fully decodable, then return bad.\n            if (!image_element.bitmap())\n                return { CanvasImageSourceUsability::Bad };\n\n            // If image has an intrinsic width or intrinsic height (or both) equal to zero, then return bad.\n            if (image_element.bitmap()->width() == 0 || image_element.bitmap()->height() == 0)\n                return { CanvasImageSourceUsability::Bad };\n            return Optional<CanvasImageSourceUsability> {};\n        },\n\n        // FIXME: HTMLVideoElement\n        // If image's readyState attribute is either HAVE_NOTHING or HAVE_METADATA, then return bad.\n\n        // HTMLCanvasElement\n        // FIXME: OffscreenCanvas\n        [](HTMLCanvasElement const& canvas_element) -> DOM::ExceptionOr<Optional<CanvasImageSourceUsability>> {\n            // If image has either a horizontal dimension or a vertical dimension equal to zero, then throw an \"InvalidStateError\" DOMException.\n            if (canvas_element.width() == 0 || canvas_element.height() == 0)\n                return DOM::InvalidStateError::create(\"Canvas width or height is zero\");\n            return Optional<CanvasImageSourceUsability> {};\n        })",
          "old_line_content": "        // HTMLOrSVGImageElement",
          "new_line_content": "    auto usability = TRY(image.visit(",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": null,
          "new_api": "set_pixel",
          "old_text": null,
          "new_text": "painter->set_pixel(destination_point, source_color)",
          "old_line_content": "                    continue;",
          "new_line_content": "                    painter->set_pixel(destination_point, source_color);",
          "content_same": false
        },
        {
          "line": 233,
          "old_api": null,
          "new_api": "blend",
          "old_text": null,
          "new_text": "dst_color.blend(source_color)",
          "old_line_content": "            }",
          "new_line_content": "                painter->set_pixel(destination_point, dst_color.blend(source_color));",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "bitmap",
          "old_text": null,
          "new_text": "image_element.bitmap()",
          "old_line_content": "                return { CanvasImageSourceUsability::Bad };",
          "new_line_content": "            if (!image_element.bitmap())",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": null,
          "new_api": "bitmap",
          "old_text": null,
          "new_text": "image_element.bitmap()->height()",
          "old_line_content": "                return { CanvasImageSourceUsability::Bad };",
          "new_line_content": "            if (image_element.bitmap()->width() == 0 || image_element.bitmap()->height() == 0)",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": null,
          "new_api": "image_is_not_origin_clean",
          "old_text": null,
          "new_text": "image_is_not_origin_clean(image)",
          "old_line_content": "        m_origin_clean = false;",
          "new_line_content": "    if (image_is_not_origin_clean(image))",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": null,
          "new_api": "scale",
          "old_text": null,
          "new_text": "m_drawing_state.transform.scale(sx, sy)",
          "old_line_content": "}",
          "new_line_content": "    m_drawing_state.transform.scale(sx, sy);",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": null,
          "new_api": "DOM::InvalidStateError::create(\"Canvas width or height is zero\")",
          "old_text": null,
          "new_text": "DOM::InvalidStateError::create(\"Canvas width or height is zero\")",
          "old_line_content": "            return Optional<CanvasImageSourceUsability> {};",
          "new_line_content": "                return DOM::InvalidStateError::create(\"Canvas width or height is zero\");",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": null,
          "new_api": "release_value",
          "old_text": null,
          "new_text": "usability.release_value()",
          "old_line_content": "",
          "new_line_content": "        return usability.release_value();",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": null,
          "new_api": "translate",
          "old_text": null,
          "new_text": "m_drawing_state.transform.translate(tx, ty)",
          "old_line_content": "}",
          "new_line_content": "    m_drawing_state.transform.translate(tx, ty);",
          "content_same": false
        },
        {
          "line": 260,
          "old_api": null,
          "new_api": "rotate_radians",
          "old_text": null,
          "new_text": "m_drawing_state.transform.rotate_radians(radians)",
          "old_line_content": "}",
          "new_line_content": "    m_drawing_state.transform.rotate_radians(radians);",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": null,
          "new_api": "visit",
          "old_text": null,
          "new_text": "image.visit(\n        // HTMLOrSVGImageElement\n        [](HTMLImageElement const&) {\n            // FIXME: image's current request's image data is CORS-cross-origin.\n            return false;\n        },\n\n        // FIXME: HTMLVideoElement\n        // image's media data is CORS-cross-origin.\n\n        // HTMLCanvasElement\n        // FIXME: ImageBitmap\n        [](HTMLCanvasElement const&) {\n            // FIXME: image's bitmap's origin-clean flag is false.\n            return false;\n        })",
          "old_line_content": "        // HTMLOrSVGImageElement",
          "new_line_content": "    return image.visit(",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": null,
          "new_api": "layout_node",
          "old_text": null,
          "new_text": "m_element->layout_node()",
          "old_line_content": "        return;",
          "new_line_content": "    if (!m_element->layout_node())",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": null,
          "new_api": "layout_node",
          "old_text": null,
          "new_text": "m_element->layout_node()->set_needs_display()",
          "old_line_content": "}",
          "new_line_content": "    m_element->layout_node()->set_needs_display();",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "create_bitmap",
          "old_text": null,
          "new_text": "m_element->create_bitmap()",
          "old_line_content": "            return {};",
          "new_line_content": "        if (!m_element->create_bitmap())",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": null,
          "new_api": "bitmap",
          "old_text": null,
          "new_text": "m_element->bitmap()",
          "old_line_content": "}",
          "new_line_content": "    return make<Gfx::Painter>(*m_element->bitmap());",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "max_width.value()",
          "old_line_content": "        return;",
          "new_line_content": "    if (max_width.has_value() && max_width.value() <= 0)",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": null,
          "new_api": "painter",
          "old_text": null,
          "new_text": "this->painter()",
          "old_line_content": "    if (!painter)",
          "new_line_content": "    auto painter = this->painter();",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": null,
          "new_api": "transformed_rect.to_type<float>()",
          "old_text": null,
          "new_text": "transformed_rect.to_type<float>()",
          "old_line_content": "}",
          "new_line_content": "    did_draw(transformed_rect.to_type<float>());",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": null,
          "new_api": "fill_text",
          "old_text": null,
          "new_text": "fill_text(text, x, y, max_width)",
          "old_line_content": "}",
          "new_line_content": "    fill_text(text, x, y, max_width);",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": null,
          "new_api": "Gfx::Path()",
          "old_text": null,
          "new_text": "Gfx::Path()",
          "old_line_content": "}",
          "new_line_content": "    m_path = Gfx::Path();",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": null,
          "new_api": "close",
          "old_text": null,
          "new_text": "m_path.close()",
          "old_line_content": "}",
          "new_line_content": "    m_path.close();",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": null,
          "new_api": "move_to",
          "old_text": null,
          "new_text": "m_path.move_to({ x, y })",
          "old_line_content": "}",
          "new_line_content": "    m_path.move_to({ x, y });",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": null,
          "new_api": "line_to",
          "old_text": null,
          "new_text": "m_path.line_to({ x, y })",
          "old_line_content": "}",
          "new_line_content": "    m_path.line_to({ x, y });",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": null,
          "new_api": "quadratic_bezier_curve_to",
          "old_text": null,
          "new_text": "m_path.quadratic_bezier_curve_to({ cx, cy }, { x, y })",
          "old_line_content": "}",
          "new_line_content": "    m_path.quadratic_bezier_curve_to({ cx, cy }, { x, y });",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": null,
          "new_api": "Gfx::FloatPoint(x, y)",
          "old_text": null,
          "new_text": "Gfx::FloatPoint(x, y)",
          "old_line_content": "}",
          "new_line_content": "    m_path.cubic_bezier_curve_to(Gfx::FloatPoint(cp1x, cp1y), Gfx::FloatPoint(cp2x, cp2y), Gfx::FloatPoint(x, y));",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": null,
          "new_api": "ellipse",
          "old_text": null,
          "new_text": "ellipse(x, y, radius, radius, 0, start_angle, end_angle, counter_clockwise)",
          "old_line_content": "}",
          "new_line_content": "    return ellipse(x, y, radius, radius, 0, start_angle, end_angle, counter_clockwise);",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": null,
          "new_api": "String::formatted(\"The major-axis radius provided ({}) is negative.\", radius_x)",
          "old_text": null,
          "new_text": "String::formatted(\"The major-axis radius provided ({}) is negative.\", radius_x)",
          "old_line_content": "",
          "new_line_content": "        return DOM::IndexSizeError::create(String::formatted(\"The major-axis radius provided ({}) is negative.\", radius_x));",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": null,
          "new_api": "String::formatted(\"The minor-axis radius provided ({}) is negative.\", radius_y)",
          "old_text": null,
          "new_text": "String::formatted(\"The minor-axis radius provided ({}) is negative.\", radius_y)",
          "old_line_content": "",
          "new_line_content": "        return DOM::IndexSizeError::create(String::formatted(\"The minor-axis radius provided ({}) is negative.\", radius_y));",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "        || (counter_clockwise && (start_angle - end_angle) >= tau)) {",
          "new_line_content": "    if (constexpr float tau = M_TAU; (!counter_clockwise && (end_angle - start_angle) >= tau)",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": null,
          "new_api": "fmodf",
          "old_text": null,
          "new_text": "fmodf(end_angle, tau)",
          "old_line_content": "    }",
          "new_line_content": "        end_angle = fmodf(end_angle, tau);",
          "content_same": false
        },
        {
          "line": 367,
          "old_api": null,
          "new_api": "cosf",
          "old_text": null,
          "new_text": "cosf(rotation)",
          "old_line_content": "",
          "new_line_content": "    auto cos_rotation = cosf(rotation);",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": null,
          "new_api": "tanf",
          "old_text": null,
          "new_text": "tanf(angle)",
          "old_line_content": "        auto tan2 = tan_relative * tan_relative;",
          "new_line_content": "        auto tan_relative = tanf(angle);",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": null,
          "new_api": "sqrtf",
          "old_text": null,
          "new_text": "sqrtf(b2 + a2 * tan2)",
          "old_line_content": "",
          "new_line_content": "        auto sqrt = sqrtf(b2 + a2 * tan2);",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": null,
          "new_api": "sinf",
          "old_text": null,
          "new_text": "sinf(angle)",
          "old_line_content": "        relative_x_position *= sn;",
          "new_line_content": "        float sn = sinf(angle) >= 0 ? 1 : -1;",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": null,
          "new_api": "resolve_point_with_angle",
          "old_text": null,
          "new_text": "resolve_point_with_angle(end_angle)",
          "old_line_content": "",
          "new_line_content": "    auto end_point = resolve_point_with_angle(end_angle);",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": null,
          "new_api": "move_to",
          "old_text": null,
          "new_text": "m_path.move_to(start_point)",
          "old_line_content": "",
          "new_line_content": "    m_path.move_to(start_point);",
          "content_same": false
        },
        {
          "line": 400,
          "old_api": null,
          "new_api": "elliptical_arc_to",
          "old_text": null,
          "new_text": "m_path.elliptical_arc_to(end_point, { radius_x, radius_y }, rotation, delta_theta > M_PI, !counter_clockwise)",
          "old_line_content": "",
          "new_line_content": "    m_path.elliptical_arc_to(end_point, { radius_x, radius_y }, rotation, delta_theta > M_PI, !counter_clockwise);",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": null,
          "new_api": "close",
          "old_text": null,
          "new_text": "m_path.close()",
          "old_line_content": "    return {};",
          "new_line_content": "    m_path.close();",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": null,
          "new_api": "move_to",
          "old_text": null,
          "new_text": "m_path.move_to({ x, y })",
          "old_line_content": "    if (width == 0 || height == 0)",
          "new_line_content": "    m_path.move_to({ x, y });",
          "content_same": false
        },
        {
          "line": 414,
          "old_api": null,
          "new_api": "close",
          "old_text": null,
          "new_text": "m_path.close()",
          "old_line_content": "}",
          "new_line_content": "    m_path.close();",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": null,
          "new_api": "painter",
          "old_text": null,
          "new_text": "this->painter()",
          "old_line_content": "    if (!painter)",
          "new_line_content": "    auto painter = this->painter();",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": null,
          "new_api": "bounding_box",
          "old_text": null,
          "new_text": "m_path.bounding_box()",
          "old_line_content": "}",
          "new_line_content": "    did_draw(m_path.bounding_box());",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": null,
          "new_api": "painter",
          "old_text": null,
          "new_text": "this->painter()",
          "old_line_content": "    if (!painter)",
          "new_line_content": "    auto painter = this->painter();",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": null,
          "new_api": "bounding_box",
          "old_text": null,
          "new_text": "m_path.bounding_box()",
          "old_line_content": "}",
          "new_line_content": "    did_draw(m_path.bounding_box());",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": null,
          "new_api": "fill",
          "old_text": null,
          "new_text": "fill(Gfx::Painter::WindingRule::Nonzero)",
          "old_line_content": "}",
          "new_line_content": "    return fill(Gfx::Painter::WindingRule::Nonzero);",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"Hmm! Attempted to create ImageData for wrapper-less CRC2D.\")",
          "old_line_content": "        return {};",
          "new_line_content": "        dbgln(\"Hmm! Attempted to create ImageData for wrapper-less CRC2D.\");",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": null,
          "new_api": "global_object",
          "old_text": null,
          "new_text": "wrapper()->global_object()",
          "old_line_content": "}",
          "new_line_content": "    return ImageData::create_with_size(wrapper()->global_object(), width, height);",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": null,
          "new_api": "DOM::IndexSizeError::create(\"Width and height must not be zero\")",
          "old_text": null,
          "new_text": "DOM::IndexSizeError::create(\"Width and height must not be zero\")",
          "old_line_content": "",
          "new_line_content": "        return DOM::IndexSizeError::create(\"Width and height must not be zero\");",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": null,
          "new_api": "DOM::SecurityError::create(\"CanvasRenderingContext2D is not origin-clean\")",
          "old_text": null,
          "new_text": "DOM::SecurityError::create(\"CanvasRenderingContext2D is not origin-clean\")",
          "old_line_content": "",
          "new_line_content": "        return DOM::SecurityError::create(\"CanvasRenderingContext2D is not origin-clean\");",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": null,
          "new_api": "global_object",
          "old_text": null,
          "new_text": "wrapper()->global_object()",
          "old_line_content": "",
          "new_line_content": "    auto image_data = ImageData::create_with_size(wrapper()->global_object(), width, height);",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": null,
          "new_api": "bitmap",
          "old_text": null,
          "new_text": "m_element->bitmap()",
          "old_line_content": "        return image_data;",
          "new_line_content": "    if (!m_element || !m_element->bitmap())",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": null,
          "new_api": "bitmap",
          "old_text": null,
          "new_text": "m_element->bitmap()",
          "old_line_content": "",
          "new_line_content": "    auto const& bitmap = *m_element->bitmap();",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": null,
          "new_api": "rect",
          "old_text": null,
          "new_text": "bitmap.rect()",
          "old_line_content": "",
          "new_line_content": "    auto source_rect_intersected = source_rect.intersected(bitmap.rect());",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": null,
          "new_api": "set_pixel",
          "old_text": null,
          "new_text": "image_data->bitmap().set_pixel(target_x, target_y, pixel)",
          "old_line_content": "        }",
          "new_line_content": "            image_data->bitmap().set_pixel(target_x, target_y, pixel);",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": null,
          "new_api": "painter",
          "old_text": null,
          "new_text": "this->painter()",
          "old_line_content": "    if (!painter)",
          "new_line_content": "    auto painter = this->painter();",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": null,
          "new_api": "bitmap",
          "old_text": null,
          "new_text": "image_data.bitmap().rect()",
          "old_line_content": "",
          "new_line_content": "    painter->blit(Gfx::IntPoint(x, y), image_data.bitmap(), image_data.bitmap().rect());",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": null,
          "new_api": "height",
          "old_text": null,
          "new_text": "image_data.height()",
          "old_line_content": "}",
          "new_line_content": "    did_draw(Gfx::FloatRect(x, y, image_data.width(), image_data.height()));",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "m_drawing_state_stack.append(m_drawing_state)",
          "old_line_content": "}",
          "new_line_content": "    m_drawing_state_stack.append(m_drawing_state);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 516,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "m_drawing_state_stack.is_empty()",
          "new_text": null,
          "old_line_content": "    if (m_drawing_state_stack.is_empty())",
          "new_line_content": "    // The restore() method steps are to pop the top entry in the drawing state stack, and reset the drawing state it describes. If there is no saved state, then the method must do nothing.",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": "take_last",
          "new_api": null,
          "old_text": "m_drawing_state_stack.take_last()",
          "new_text": null,
          "old_line_content": "    m_drawing_state = m_drawing_state_stack.take_last();",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": "reset_to_default_state",
          "new_api": null,
          "old_text": "reset_to_default_state()",
          "new_text": null,
          "old_line_content": "    reset_to_default_state();",
          "new_line_content": "    // The reset() method steps are to reset the rendering context to its default state.",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "painter",
          "new_api": null,
          "old_text": "this->painter()",
          "new_text": null,
          "old_line_content": "    auto painter = this->painter();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": "target",
          "new_api": null,
          "old_text": "painter->target()->rect()",
          "new_text": null,
          "old_line_content": "        painter->clear_rect(painter->target()->rect(), Color::Transparent);",
          "new_line_content": "    if (painter)",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "clear",
          "new_api": null,
          "old_text": "m_path.clear()",
          "new_text": null,
          "old_line_content": "    m_path.clear();",
          "new_line_content": "    // 2. Empty the list of subpaths in context's current default path.",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": "clear",
          "new_api": null,
          "old_text": "m_drawing_state_stack.clear()",
          "new_text": null,
          "old_line_content": "    m_drawing_state_stack.clear();",
          "new_line_content": "    // 3. Clear the context's drawing state stack.",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": "target",
          "new_api": null,
          "old_text": "painter->target()->rect().to_type<float>()",
          "new_text": null,
          "old_line_content": "        did_draw(painter->target()->rect().to_type<float>());",
          "new_line_content": "    if (painter)",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": "prepare_text",
          "new_api": null,
          "old_text": "prepare_text(text)",
          "new_text": null,
          "old_line_content": "    auto prepared_text = prepare_text(text);",
          "new_line_content": "    // list:",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": "Gfx::FontDatabase::default_font()",
          "new_api": null,
          "old_text": "Gfx::FontDatabase::default_font()",
          "new_text": null,
          "old_line_content": "    auto& font = Gfx::FontDatabase::default_font();",
          "new_line_content": "    // FIXME: Use the font that was used to create the glyphs in prepared_text.",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": "width",
          "new_api": null,
          "old_text": "prepared_text.bounding_box.width()",
          "new_text": null,
          "old_line_content": "    metrics->set_width(prepared_text.bounding_box.width());",
          "new_line_content": "    // width attribute: The width of that inline box, in CSS pixels. (The text's advance width.)",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "left",
          "new_api": null,
          "old_text": "prepared_text.bounding_box.left()",
          "new_text": null,
          "old_line_content": "    metrics->set_actual_bounding_box_left(-prepared_text.bounding_box.left());",
          "new_line_content": "    // actualBoundingBoxLeft attribute: The distance parallel to the baseline from the alignment point given by the textAlign attribute to the left side of the bounding rectangle of the given text, in CSS pixels; positive numbers indicating a distance going left from the given alignment point.",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "right",
          "new_api": null,
          "old_text": "prepared_text.bounding_box.right()",
          "new_text": null,
          "old_line_content": "    metrics->set_actual_bounding_box_right(prepared_text.bounding_box.right());",
          "new_line_content": "    // actualBoundingBoxRight attribute: The distance parallel to the baseline from the alignment point given by the textAlign attribute to the right side of the bounding rectangle of the given text, in CSS pixels; positive numbers indicating a distance going right from the given alignment point.",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": "baseline",
          "new_api": null,
          "old_text": "font.baseline()",
          "new_text": null,
          "old_line_content": "    metrics->set_font_bounding_box_ascent(font.baseline());",
          "new_line_content": "    // fontBoundingBoxAscent attribute: The distance from the horizontal line indicated by the textBaseline attribute to the ascent metric of the first available font, in CSS pixels; positive numbers indicating a distance going up from the given baseline.",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": "baseline",
          "new_api": null,
          "old_text": "font.baseline()",
          "new_text": null,
          "old_line_content": "    metrics->set_font_bounding_box_descent(prepared_text.bounding_box.height() - font.baseline());",
          "new_line_content": "    // fontBoundingBoxDescent attribute: The distance from the horizontal line indicated by the textBaseline attribute to the descent metric of the first available font, in CSS pixels; positive numbers indicating a distance going down from the given baseline.",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": "baseline",
          "new_api": null,
          "old_text": "font.baseline()",
          "new_text": null,
          "old_line_content": "    metrics->set_actual_bounding_box_ascent(font.baseline());",
          "new_line_content": "    // actualBoundingBoxAscent attribute: The distance from the horizontal line indicated by the textBaseline attribute to the top of the bounding rectangle of the given text, in CSS pixels; positive numbers indicating a distance going up from the given baseline.",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": "baseline",
          "new_api": null,
          "old_text": "font.baseline()",
          "new_text": null,
          "old_line_content": "    metrics->set_actual_bounding_box_descent(prepared_text.bounding_box.height() - font.baseline());",
          "new_line_content": "    // actualBoundingBoxDescent attribute: The distance from the horizontal line indicated by the textBaseline attribute to the bottom of the bounding rectangle of the given text, in CSS pixels; positive numbers indicating a distance going down from the given baseline.",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": "baseline",
          "new_api": null,
          "old_text": "font.baseline()",
          "new_text": null,
          "old_line_content": "    metrics->set_em_height_ascent(font.baseline());",
          "new_line_content": "    // emHeightAscent attribute: The distance from the horizontal line indicated by the textBaseline attribute to the highest top of the em squares in the inline box, in CSS pixels; positive numbers indicating that the given baseline is below the top of that em square (so this value will usually be positive). Zero if the given baseline is the top of that em square; half the font size if the given baseline is the middle of that em square.",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "baseline",
          "new_api": null,
          "old_text": "font.baseline()",
          "new_text": null,
          "old_line_content": "    metrics->set_em_height_descent(prepared_text.bounding_box.height() - font.baseline());",
          "new_line_content": "    // emHeightDescent attribute: The distance from the horizontal line indicated by the textBaseline attribute to the lowest bottom of the em squares in the inline box, in CSS pixels; positive numbers indicating that the given baseline is above the bottom of that em square. (Zero if the given baseline is the bottom of that em square.)",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": "baseline",
          "new_api": null,
          "old_text": "font.baseline()",
          "new_text": null,
          "old_line_content": "    metrics->set_hanging_baseline(font.baseline());",
          "new_line_content": "    // hangingBaseline attribute: The distance from the horizontal line indicated by the textBaseline attribute to the hanging baseline of the inline box, in CSS pixels; positive numbers indicating that the given baseline is below the hanging baseline. (Zero if the given baseline is the hanging baseline.)",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": "set_font_bounding_box_ascent",
          "new_api": null,
          "old_text": "metrics->set_font_bounding_box_ascent(0)",
          "new_text": null,
          "old_line_content": "    metrics->set_font_bounding_box_ascent(0);",
          "new_line_content": "    // alphabeticBaseline attribute: The distance from the horizontal line indicated by the textBaseline attribute to the alphabetic baseline of the inline box, in CSS pixels; positive numbers indicating that the given baseline is below the alphabetic baseline. (Zero if the given baseline is the alphabetic baseline.)",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": "set_font_bounding_box_ascent",
          "new_api": null,
          "old_text": "metrics->set_font_bounding_box_ascent(0)",
          "new_text": null,
          "old_line_content": "    metrics->set_font_bounding_box_ascent(0);",
          "new_line_content": "    // ideographicBaseline attribute: The distance from the horizontal line indicated by the textBaseline attribute to the ideographic-under baseline of the inline box, in CSS pixels; positive numbers indicating that the given baseline is below the ideographic-under baseline. (Zero if the given baseline is the ideographic-under baseline.)",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": "length",
          "new_api": null,
          "old_text": "text.length()",
          "new_text": null,
          "old_line_content": "    StringBuilder builder { text.length() };",
          "new_line_content": "    //       doesn't consider it as whitespace.",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "is_ascii_space",
          "new_api": null,
          "old_text": "is_ascii_space(c)",
          "new_text": null,
          "old_line_content": "        builder.append(is_ascii_space(c) ? ' ' : c);",
          "new_line_content": "    for (auto c : text) {",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": "build",
          "new_api": null,
          "old_text": "builder.build()",
          "new_text": null,
          "old_line_content": "    String replaced_text = builder.build();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": "Gfx::FontDatabase::default_font()",
          "new_api": null,
          "old_text": "Gfx::FontDatabase::default_font()",
          "new_text": null,
          "old_line_content": "    auto& font = Gfx::FontDatabase::default_font();",
          "new_line_content": "    // FIXME: Once we have CanvasTextDrawingStyles, add the CSS attributes.",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": "pixel_size",
          "new_api": null,
          "old_text": "font.pixel_size()",
          "new_text": null,
          "old_line_content": "    size_t height = font.pixel_size();",
          "new_line_content": "    size_t width = 0;",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "glyph_or_emoji_width",
          "new_api": null,
          "old_text": "font.glyph_or_emoji_width(c)",
          "new_text": null,
          "old_line_content": "        width += font.glyph_or_emoji_width(c);",
          "new_line_content": "    for (auto c : Utf8View { replaced_text }) {",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": "static_cast<int>(height)",
          "new_api": null,
          "old_text": "static_cast<int>(height)",
          "new_text": null,
          "old_line_content": "    PreparedText prepared_text { {}, physical_alignment, { 0, 0, static_cast<int>(width), static_cast<int>(height) } };",
          "new_line_content": "    // 8. Let result be an array constructed by iterating over each glyph in the inline box from left to right (if any), adding to the array, for each glyph, the shape of the glyph as it is in the inline box, positioned on a coordinate space using CSS pixels with its origin is at the anchor point.",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": "static_cast<int>(offset)",
          "new_api": null,
          "old_text": "static_cast<int>(offset)",
          "new_text": null,
          "old_line_content": "        prepared_text.glyphs.append({ c, { static_cast<int>(offset), 0 } });",
          "new_line_content": "    for (auto c : Utf8View { replaced_text }) {",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": "CanvasGradient::create_radial(x0, y0, r0, x1, y1, r1)",
          "new_api": null,
          "old_text": "CanvasGradient::create_radial(x0, y0, r0, x1, y1, r1)",
          "new_text": null,
          "old_line_content": "    return CanvasGradient::create_radial(x0, y0, r0, x1, y1, r1);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": "CanvasGradient::create_linear(x0, y0, x1, y1)",
          "new_api": null,
          "old_text": "CanvasGradient::create_linear(x0, y0, x1, y1)",
          "new_text": null,
          "old_line_content": "    return CanvasGradient::create_linear(x0, y0, x1, y1);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": "CanvasGradient::create_conic(start_angle, x, y)",
          "new_api": null,
          "old_text": "CanvasGradient::create_conic(start_angle, x, y)",
          "new_text": null,
          "old_line_content": "    return CanvasGradient::create_conic(start_angle, x, y);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": "isfinite",
          "new_api": null,
          "old_text": "isfinite(f)",
          "new_text": null,
          "old_line_content": "    if (!isfinite(a) || !isfinite(b) || !isfinite(c) || !isfinite(d) || !isfinite(e) || !isfinite(f))",
          "new_line_content": "    // 1. If any of the arguments are infinite or NaN, then return.",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": "static_cast<float>(f)",
          "new_api": null,
          "old_text": "static_cast<float>(f)",
          "new_text": null,
          "old_line_content": "    m_drawing_state.transform.multiply({ static_cast<float>(a), static_cast<float>(b), static_cast<float>(c), static_cast<float>(d), static_cast<float>(e), static_cast<float>(f) });",
          "new_line_content": "    //    0 0 1",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": "isfinite",
          "new_api": null,
          "old_text": "isfinite(f)",
          "new_text": null,
          "old_line_content": "    if (!isfinite(a) || !isfinite(b) || !isfinite(c) || !isfinite(d) || !isfinite(e) || !isfinite(f))",
          "new_line_content": "    // 1. If any of the arguments are infinite or NaN, then return.",
          "content_same": false
        },
        {
          "line": 202,
          "old_api": "inverse",
          "new_api": null,
          "old_text": "m_drawing_state.transform.inverse()",
          "new_text": null,
          "old_line_content": "        auto inverse_transform = m_drawing_state.transform.inverse();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 206,
          "old_api": "map_to_quad",
          "new_api": null,
          "old_text": "m_drawing_state.transform.map_to_quad(destination_rect)",
          "new_text": null,
          "old_line_content": "        auto destination_quad = m_drawing_state.transform.map_to_quad(destination_rect);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": "transform",
          "new_api": null,
          "old_text": "transform(a, b, c, d, e, f)",
          "new_text": null,
          "old_line_content": "    transform(a, b, c, d, e, f);",
          "new_line_content": "    // 3. Invoke the transform(a, b, c, d, e, f) method with the same arguments.",
          "content_same": false
        },
        {
          "line": 210,
          "old_api": "translate",
          "new_api": null,
          "old_text": "source_transform.translate(source_x, source_y)",
          "new_text": null,
          "old_line_content": "        source_transform.translate(source_x, source_y);",
          "new_line_content": "        Gfx::AffineTransform source_transform;",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": "bottom",
          "new_api": null,
          "old_text": "destination_bounding_rect.bottom()",
          "new_text": null,
          "old_line_content": "        for (int y = destination_bounding_rect.y(); y <= destination_bounding_rect.bottom(); ++y) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": "contains",
          "new_api": null,
          "old_text": "painter->clip_rect().contains(destination_point)",
          "new_text": null,
          "old_line_content": "                if (!painter->clip_rect().contains(destination_point))",
          "new_line_content": "                auto destination_point = Gfx::IntPoint { x, y };",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": "destination_point.to_type<float>()",
          "new_api": null,
          "old_text": "destination_point.to_type<float>()",
          "new_text": null,
          "old_line_content": "                if (!destination_quad.contains(destination_point.to_type<float>()))",
          "new_line_content": "                    continue;",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": "map",
          "new_api": null,
          "old_text": "inverse_transform->map(destination_point)",
          "new_text": null,
          "old_line_content": "                auto source_point = source_transform.map(inverse_transform->map(destination_point)).to_rounded<int>();",
          "new_line_content": "                    continue;",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": "get_pixel",
          "new_api": null,
          "old_text": "bitmap->get_pixel(source_point)",
          "new_text": null,
          "old_line_content": "                auto source_color = bitmap->get_pixel(source_point);",
          "new_line_content": "                    continue;",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": "visit",
          "new_api": null,
          "old_text": "image.visit(\n        // HTMLOrSVGImageElement\n        [](HTMLImageElement const& image_element) -> DOM::ExceptionOr<Optional<CanvasImageSourceUsability>> {\n            // FIXME: If image's current request's state is broken, then throw an \"InvalidStateError\" DOMException.\n\n            // If image is not fully decodable, then return bad.\n            if (!image_element.bitmap())\n                return { CanvasImageSourceUsability::Bad };\n\n            // If image has an intrinsic width or intrinsic height (or both) equal to zero, then return bad.\n            if (image_element.bitmap()->width() == 0 || image_element.bitmap()->height() == 0)\n                return { CanvasImageSourceUsability::Bad };\n            return Optional<CanvasImageSourceUsability> {};\n        },\n\n        // FIXME: HTMLVideoElement\n        // If image's readyState attribute is either HAVE_NOTHING or HAVE_METADATA, then return bad.\n\n        // HTMLCanvasElement\n        // FIXME: OffscreenCanvas\n        [](HTMLCanvasElement const& canvas_element) -> DOM::ExceptionOr<Optional<CanvasImageSourceUsability>> {\n            // If image has either a horizontal dimension or a vertical dimension equal to zero, then throw an \"InvalidStateError\" DOMException.\n            if (canvas_element.width() == 0 || canvas_element.height() == 0)\n                return DOM::InvalidStateError::create(\"Canvas width or height is zero\");\n            return Optional<CanvasImageSourceUsability> {};\n        })",
          "new_text": null,
          "old_line_content": "    auto usability = TRY(image.visit(",
          "new_line_content": "    // 1. Switch on image:",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": "alpha",
          "new_api": null,
          "old_text": "source_color.alpha()",
          "new_text": null,
          "old_line_content": "                if (source_color.alpha() == 255) {",
          "new_line_content": "                    continue;",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": "target",
          "new_api": null,
          "old_text": "painter->target()->get_pixel(destination_point)",
          "new_text": null,
          "old_line_content": "                auto dst_color = painter->target()->get_pixel(destination_point);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": "bitmap",
          "new_api": null,
          "old_text": "image_element.bitmap()",
          "new_text": null,
          "old_line_content": "            if (!image_element.bitmap())",
          "new_line_content": "            // If image is not fully decodable, then return bad.",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": "bitmap",
          "new_api": null,
          "old_text": "image_element.bitmap()->height()",
          "new_text": null,
          "old_line_content": "            if (image_element.bitmap()->width() == 0 || image_element.bitmap()->height() == 0)",
          "new_line_content": "            // If image has an intrinsic width or intrinsic height (or both) equal to zero, then return bad.",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": "image_is_not_origin_clean",
          "new_api": null,
          "old_text": "image_is_not_origin_clean(image)",
          "new_text": null,
          "old_line_content": "    if (image_is_not_origin_clean(image))",
          "new_line_content": "    // 7. If image is not origin-clean, then set the CanvasRenderingContext2D's origin-clean flag to false.",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": "dbgln_if",
          "new_api": null,
          "old_text": "dbgln_if(CANVAS_RENDERING_CONTEXT_2D_DEBUG, \"CanvasRenderingContext2D::scale({}, {})\", sx, sy)",
          "new_text": null,
          "old_line_content": "    dbgln_if(CANVAS_RENDERING_CONTEXT_2D_DEBUG, \"CanvasRenderingContext2D::scale({}, {})\", sx, sy);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": "height",
          "new_api": null,
          "old_text": "canvas_element.height()",
          "new_text": null,
          "old_line_content": "            if (canvas_element.width() == 0 || canvas_element.height() == 0)",
          "new_line_content": "            // If image has either a horizontal dimension or a vertical dimension equal to zero, then throw an \"InvalidStateError\" DOMException.",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "usability.has_value()",
          "new_text": null,
          "old_line_content": "    if (usability.has_value())",
          "new_line_content": "        }));",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": "dbgln_if",
          "new_api": null,
          "old_text": "dbgln_if(CANVAS_RENDERING_CONTEXT_2D_DEBUG, \"CanvasRenderingContext2D::translate({}, {})\", tx, ty)",
          "new_text": null,
          "old_line_content": "    dbgln_if(CANVAS_RENDERING_CONTEXT_2D_DEBUG, \"CanvasRenderingContext2D::translate({}, {})\", tx, ty);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": "dbgln_if",
          "new_api": null,
          "old_text": "dbgln_if(CANVAS_RENDERING_CONTEXT_2D_DEBUG, \"CanvasRenderingContext2D::rotate({})\", radians)",
          "new_text": null,
          "old_line_content": "    dbgln_if(CANVAS_RENDERING_CONTEXT_2D_DEBUG, \"CanvasRenderingContext2D::rotate({})\", radians);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "visit",
          "new_api": null,
          "old_text": "image.visit(\n        // HTMLOrSVGImageElement\n        [](HTMLImageElement const&) {\n            // FIXME: image's current request's image data is CORS-cross-origin.\n            return false;\n        },\n\n        // FIXME: HTMLVideoElement\n        // image's media data is CORS-cross-origin.\n\n        // HTMLCanvasElement\n        // FIXME: ImageBitmap\n        [](HTMLCanvasElement const&) {\n            // FIXME: image's bitmap's origin-clean flag is false.\n            return false;\n        })",
          "new_text": null,
          "old_line_content": "    return image.visit(",
          "new_line_content": "    // An object image is not origin-clean if, switching on image's type:",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "layout_node",
          "new_api": null,
          "old_text": "m_element->layout_node()",
          "new_text": null,
          "old_line_content": "    if (!m_element->layout_node())",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": "layout_node",
          "new_api": null,
          "old_text": "m_element->layout_node()->set_needs_display()",
          "new_text": null,
          "old_line_content": "    m_element->layout_node()->set_needs_display();",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": "bitmap",
          "new_api": null,
          "old_text": "m_element->bitmap()",
          "new_text": null,
          "old_line_content": "    if (!m_element->bitmap()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": "bitmap",
          "new_api": null,
          "old_text": "m_element->bitmap()",
          "new_text": null,
          "old_line_content": "    return make<Gfx::Painter>(*m_element->bitmap());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": "value",
          "new_api": null,
          "old_text": "max_width.value()",
          "new_text": null,
          "old_line_content": "    if (max_width.has_value() && max_width.value() <= 0)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": "painter",
          "new_api": null,
          "old_text": "this->painter()",
          "new_text": null,
          "old_line_content": "    auto painter = this->painter();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": "pixel_size",
          "new_api": null,
          "old_text": "painter->font().pixel_size()",
          "new_text": null,
          "old_line_content": "    auto text_rect = Gfx::IntRect(x, y, max_width.has_value() ? max_width.value() : painter->font().width(text), painter->font().pixel_size());",
          "new_line_content": "    // FIXME: painter only supports integer rects for text right now, so this effectively chops off any fractional position",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "fill_text",
          "new_api": null,
          "old_text": "fill_text(text, x, y, max_width)",
          "new_text": null,
          "old_line_content": "    fill_text(text, x, y, max_width);",
          "new_line_content": "    // FIXME: Stroke the text instead of filling it.",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": "Gfx::Path()",
          "new_api": null,
          "old_text": "Gfx::Path()",
          "new_text": null,
          "old_line_content": "    m_path = Gfx::Path();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": "close",
          "new_api": null,
          "old_text": "m_path.close()",
          "new_text": null,
          "old_line_content": "    m_path.close();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": "move_to",
          "new_api": null,
          "old_text": "m_path.move_to({ x, y })",
          "new_text": null,
          "old_line_content": "    m_path.move_to({ x, y });",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": "line_to",
          "new_api": null,
          "old_text": "m_path.line_to({ x, y })",
          "new_text": null,
          "old_line_content": "    m_path.line_to({ x, y });",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": "quadratic_bezier_curve_to",
          "new_api": null,
          "old_text": "m_path.quadratic_bezier_curve_to({ cx, cy }, { x, y })",
          "new_text": null,
          "old_line_content": "    m_path.quadratic_bezier_curve_to({ cx, cy }, { x, y });",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 334,
          "old_api": "Gfx::FloatPoint(x, y)",
          "new_api": null,
          "old_text": "Gfx::FloatPoint(x, y)",
          "new_text": null,
          "old_line_content": "    m_path.cubic_bezier_curve_to(Gfx::FloatPoint(cp1x, cp1y), Gfx::FloatPoint(cp2x, cp2y), Gfx::FloatPoint(x, y));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": "String::formatted(\"The radius provided ({}) is negative.\", radius)",
          "new_api": null,
          "old_text": "String::formatted(\"The radius provided ({}) is negative.\", radius)",
          "new_text": null,
          "old_line_content": "        return DOM::IndexSizeError::create(String::formatted(\"The radius provided ({}) is negative.\", radius));",
          "new_line_content": "    if (radius < 0)",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": "String::formatted(\"The major-axis radius provided ({}) is negative.\", radius_x)",
          "new_api": null,
          "old_text": "String::formatted(\"The major-axis radius provided ({}) is negative.\", radius_x)",
          "new_text": null,
          "old_line_content": "        return DOM::IndexSizeError::create(String::formatted(\"The major-axis radius provided ({}) is negative.\", radius_x));",
          "new_line_content": "    if (radius_x < 0)",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": "String::formatted(\"The minor-axis radius provided ({}) is negative.\", radius_y)",
          "new_api": null,
          "old_text": "String::formatted(\"The minor-axis radius provided ({}) is negative.\", radius_y)",
          "new_text": null,
          "old_line_content": "        return DOM::IndexSizeError::create(String::formatted(\"The minor-axis radius provided ({}) is negative.\", radius_y));",
          "new_line_content": "    if (radius_y < 0)",
          "content_same": false
        },
        {
          "line": 352,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "    if (constexpr float tau = M_TAU; (!counter_clockwise && (end_angle - start_angle) >= tau)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 357,
          "old_api": "fmodf",
          "new_api": null,
          "old_text": "fmodf(start_angle, tau)",
          "new_text": null,
          "old_line_content": "        start_angle = fmodf(start_angle, tau);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "sinf",
          "new_api": null,
          "old_text": "sinf(rotation)",
          "new_text": null,
          "old_line_content": "    auto sin_rotation = sinf(rotation);",
          "new_line_content": "    // The sign of the resulting relative positions is just whether our angle is on one of the left quadrants.",
          "content_same": false
        },
        {
          "line": 369,
          "old_api": "tanf",
          "new_api": null,
          "old_text": "tanf(angle)",
          "new_text": null,
          "old_line_content": "        auto tan_relative = tanf(angle);",
          "new_line_content": "    auto resolve_point_with_angle = [&](float angle) {",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": "sqrtf",
          "new_api": null,
          "old_text": "sqrtf(b2 + a2 * tan2)",
          "new_text": null,
          "old_line_content": "        auto sqrt = sqrtf(b2 + a2 * tan2);",
          "new_line_content": "        auto b2 = radius_y * radius_y;",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": "sinf",
          "new_api": null,
          "old_text": "sinf(angle)",
          "new_text": null,
          "old_line_content": "        float sn = sinf(angle) >= 0 ? 1 : -1;",
          "new_line_content": "        // Make sure to set the correct sign",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": "resolve_point_with_angle",
          "new_api": null,
          "old_text": "resolve_point_with_angle(start_angle)",
          "new_text": null,
          "old_line_content": "    auto start_point = resolve_point_with_angle(start_angle);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": "move_to",
          "new_api": null,
          "old_text": "m_path.move_to(start_point)",
          "new_text": null,
          "old_line_content": "    m_path.move_to(start_point);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 399,
          "old_api": "elliptical_arc_to",
          "new_api": null,
          "old_text": "m_path.elliptical_arc_to(end_point, { radius_x, radius_y }, rotation, delta_theta > M_PI, !counter_clockwise)",
          "new_text": null,
          "old_line_content": "    m_path.elliptical_arc_to(end_point, { radius_x, radius_y }, rotation, delta_theta > M_PI, !counter_clockwise);",
          "new_line_content": "    // FIXME: This is still goofy for some values.",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": "close",
          "new_api": null,
          "old_text": "m_path.close()",
          "new_text": null,
          "old_line_content": "    m_path.close();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": "move_to",
          "new_api": null,
          "old_text": "m_path.move_to({ x, y })",
          "new_text": null,
          "old_line_content": "    m_path.move_to({ x, y });",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "line_to",
          "new_api": null,
          "old_text": "m_path.line_to({ x + width, y })",
          "new_text": null,
          "old_line_content": "    m_path.line_to({ x + width, y });",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": "painter",
          "new_api": null,
          "old_text": "this->painter()",
          "new_text": null,
          "old_line_content": "    auto painter = this->painter();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "stroke_path",
          "new_api": null,
          "old_text": "painter->stroke_path(m_path, m_drawing_state.stroke_style, m_drawing_state.line_width)",
          "new_text": null,
          "old_line_content": "    painter->stroke_path(m_path, m_drawing_state.stroke_style, m_drawing_state.line_width);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": "painter",
          "new_api": null,
          "old_text": "this->painter()",
          "new_text": null,
          "old_line_content": "    auto painter = this->painter();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": "close_all_subpaths",
          "new_api": null,
          "old_text": "path.close_all_subpaths()",
          "new_text": null,
          "old_line_content": "    path.close_all_subpaths();",
          "new_line_content": "    auto path = m_path;",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": "fill",
          "new_api": null,
          "old_text": "fill(Gfx::Painter::WindingRule::EvenOdd)",
          "new_text": null,
          "old_line_content": "        return fill(Gfx::Painter::WindingRule::EvenOdd);",
          "new_line_content": "    if (fill_rule == \"evenodd\")",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": "wrapper",
          "new_api": null,
          "old_text": "wrapper()",
          "new_text": null,
          "old_line_content": "    if (!wrapper()) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": "global_object",
          "new_api": null,
          "old_text": "wrapper()->global_object()",
          "new_text": null,
          "old_line_content": "    return ImageData::create_with_size(wrapper()->global_object(), width, height);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "DOM::IndexSizeError::create(\"Width and height must not be zero\")",
          "new_api": null,
          "old_text": "DOM::IndexSizeError::create(\"Width and height must not be zero\")",
          "new_text": null,
          "old_line_content": "        return DOM::IndexSizeError::create(\"Width and height must not be zero\");",
          "new_line_content": "    if (width == 0 || height == 0)",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": "DOM::SecurityError::create(\"CanvasRenderingContext2D is not origin-clean\")",
          "new_api": null,
          "old_text": "DOM::SecurityError::create(\"CanvasRenderingContext2D is not origin-clean\")",
          "new_text": null,
          "old_line_content": "        return DOM::SecurityError::create(\"CanvasRenderingContext2D is not origin-clean\");",
          "new_line_content": "    if (!m_origin_clean)",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "global_object",
          "new_api": null,
          "old_text": "wrapper()->global_object()",
          "new_text": null,
          "old_line_content": "    auto image_data = ImageData::create_with_size(wrapper()->global_object(), width, height);",
          "new_line_content": "    // 4. Initialize imageData given sw, sh, settings set to settings, and defaultColorSpace set to this's color space.",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": "bitmap",
          "new_api": null,
          "old_text": "m_element->bitmap()",
          "new_text": null,
          "old_line_content": "    if (!m_element || !m_element->bitmap())",
          "new_line_content": "    // NOTE: We don't attempt to create the underlying bitmap here; if it doesn't exist, it's like copying only transparent black pixels (which is a no-op).",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": "bitmap",
          "new_api": null,
          "old_text": "m_element->bitmap()",
          "new_text": null,
          "old_line_content": "    auto const& bitmap = *m_element->bitmap();",
          "new_line_content": "        return image_data;",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": "rect",
          "new_api": null,
          "old_text": "bitmap.rect()",
          "new_text": null,
          "old_line_content": "    auto source_rect_intersected = source_rect.intersected(bitmap.rect());",
          "new_line_content": "    auto source_rect = Gfx::Rect { x, y, width, height };",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": "height",
          "new_api": null,
          "old_text": "source_rect_intersected.height()",
          "new_text": null,
          "old_line_content": "    for (int target_y = 0; target_y < source_rect_intersected.height(); ++target_y) {",
          "new_line_content": "    // FIXME: Can't use a Gfx::Painter + blit() here as it doesn't support ImageData bitmap's RGBA8888 format.",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": "painter",
          "new_api": null,
          "old_text": "this->painter()",
          "new_text": null,
          "old_line_content": "    auto painter = this->painter();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "bitmap",
          "new_api": null,
          "old_text": "image_data.bitmap().rect()",
          "new_text": null,
          "old_line_content": "    painter->blit(Gfx::IntPoint(x, y), image_data.bitmap(), image_data.bitmap().rect());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": "height",
          "new_api": null,
          "old_text": "image_data.height()",
          "new_text": null,
          "old_line_content": "    did_draw(Gfx::FloatRect(x, y, image_data.width(), image_data.height()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": "append",
          "new_api": null,
          "old_text": "m_drawing_state_stack.append(m_drawing_state)",
          "new_text": null,
          "old_line_content": "    m_drawing_state_stack.append(m_drawing_state);",
          "new_line_content": "    // The save() method steps are to push a copy of the current drawing state onto the drawing state stack.",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 32,
      "total_additions": 106,
      "total_deletions": 104,
      "total_api_changes": 242
    },
    "non_api_changes": {
      "has_non_api_changes": false,
      "evidence": {
        "total_diff_lines": 3,
        "api_related_lines": 242,
        "non_api_lines": 0,
        "non_api_line_numbers": []
      }
    },
    "api_calls_before": 302,
    "api_calls_after": 308,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 2,
      "total_diff_lines": 18
    }
  }
}