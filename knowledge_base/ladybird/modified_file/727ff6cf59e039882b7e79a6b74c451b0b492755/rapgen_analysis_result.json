{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/727ff6cf59e039882b7e79a6b74c451b0b492755",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/727ff6cf59e039882b7e79a6b74c451b0b492755/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/727ff6cf59e039882b7e79a6b74c451b0b492755/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/727ff6cf59e039882b7e79a6b74c451b0b492755/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 272,
          "old_api": "parse_fill_rule",
          "new_api": "drawing_state",
          "old_text": "parse_fill_rule(fill_rule)",
          "new_text": "this->drawing_state()",
          "old_line_content": "        painter.fill_path(path, *drawing_state().fill_style.to_gfx_paint_style(), parse_fill_rule(fill_rule));",
          "new_line_content": "        auto& drawing_state = this->drawing_state();",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": "bounding_box",
          "new_api": "parse_fill_rule",
          "old_text": "path.bounding_box()",
          "new_text": "parse_fill_rule(fill_rule_value)",
          "old_line_content": "        return path.bounding_box();",
          "new_line_content": "        auto fill_rule = parse_fill_rule(fill_rule_value);",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": "drawing_state",
          "new_api": "bounding_box",
          "old_text": "drawing_state()",
          "new_text": "path.bounding_box()",
          "old_line_content": "    auto transformed_path = path().copy_transformed(drawing_state().transform);",
          "new_line_content": "        return path.bounding_box();",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": "realm",
          "new_api": "drawing_state",
          "old_text": "realm()",
          "new_text": "drawing_state()",
          "old_line_content": "    return ImageData::create_with_size(realm(), width, height);",
          "new_line_content": "    auto transformed_path = path.path().copy_transformed(drawing_state().transform);",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": "rect",
          "new_api": "bitmap",
          "old_text": "bitmap.rect()",
          "new_text": "canvas_element().bitmap()",
          "old_line_content": "    auto source_rect_intersected = source_rect.intersected(bitmap.rect());",
          "new_line_content": "    if (!canvas_element().bitmap())",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "get_pixel",
          "new_api": "rect",
          "old_text": "bitmap.get_pixel(target_x + x, target_y + y)",
          "new_text": "bitmap.rect()",
          "old_line_content": "            auto pixel = bitmap.get_pixel(target_x + x, target_y + y);",
          "new_line_content": "    auto source_rect_intersected = source_rect.intersected(bitmap.rect());",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": "clear_drawing_state_stack",
          "new_api": "target",
          "old_text": "clear_drawing_state_stack()",
          "new_text": "painter->target()->rect()",
          "old_line_content": "    clear_drawing_state_stack();",
          "new_line_content": "        painter->clear_rect(painter->target()->rect(), Color::Transparent);",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": "reset_drawing_state",
          "new_api": "clear",
          "old_text": "reset_drawing_state()",
          "new_text": "path().clear()",
          "old_line_content": "    reset_drawing_state();",
          "new_line_content": "    path().clear();",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": "target",
          "new_api": "clear_drawing_state_stack",
          "old_text": "painter->target()->rect().to_type<float>()",
          "new_text": "clear_drawing_state_stack()",
          "old_line_content": "        did_draw(painter->target()->rect().to_type<float>());",
          "new_line_content": "    clear_drawing_state_stack();",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": "width",
          "new_api": "prepare_text",
          "old_text": "prepared_text.bounding_box.width()",
          "new_text": "prepare_text(text)",
          "old_line_content": "    metrics->set_width(prepared_text.bounding_box.width());",
          "new_line_content": "    auto prepared_text = prepare_text(text);",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": "baseline",
          "new_api": "width",
          "old_text": "font.baseline()",
          "new_text": "prepared_text.bounding_box.width()",
          "old_line_content": "    metrics->set_font_bounding_box_ascent(font.baseline());",
          "new_line_content": "    metrics->set_width(prepared_text.bounding_box.width());",
          "content_same": false
        },
        {
          "line": 386,
          "old_api": "baseline",
          "new_api": "left",
          "old_text": "font.baseline()",
          "new_text": "prepared_text.bounding_box.left()",
          "old_line_content": "    metrics->set_font_bounding_box_descent(prepared_text.bounding_box.height() - font.baseline());",
          "new_line_content": "    metrics->set_actual_bounding_box_left(-prepared_text.bounding_box.left());",
          "content_same": false
        },
        {
          "line": 388,
          "old_api": "baseline",
          "new_api": "right",
          "old_text": "font.baseline()",
          "new_text": "prepared_text.bounding_box.right()",
          "old_line_content": "    metrics->set_actual_bounding_box_ascent(font.baseline());",
          "new_line_content": "    metrics->set_actual_bounding_box_right(prepared_text.bounding_box.right());",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": "set_font_bounding_box_ascent",
          "new_api": "baseline",
          "old_text": "metrics->set_font_bounding_box_ascent(0)",
          "new_text": "font.baseline()",
          "old_line_content": "    metrics->set_font_bounding_box_ascent(0);",
          "new_line_content": "    metrics->set_em_height_ascent(font.baseline());",
          "content_same": false
        },
        {
          "line": 400,
          "old_api": "set_font_bounding_box_ascent",
          "new_api": "baseline",
          "old_text": "metrics->set_font_bounding_box_ascent(0)",
          "new_text": "font.baseline()",
          "old_line_content": "    metrics->set_font_bounding_box_ascent(0);",
          "new_line_content": "    metrics->set_em_height_descent(prepared_text.bounding_box.height() - font.baseline());",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": "glyph_or_emoji_width",
          "new_api": "default_font",
          "old_text": "font.glyph_or_emoji_width(it)",
          "new_text": "Platform::FontPlugin::the().default_font()",
          "old_line_content": "        width += font.glyph_or_emoji_width(it);",
          "new_line_content": "    auto& font = Platform::FontPlugin::the().default_font();",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": "clip_internal",
          "new_api": "parse_fill_rule",
          "old_text": "clip_internal(transformed_path, fill_rule)",
          "new_text": "parse_fill_rule(fill_rule)",
          "old_line_content": "    return clip_internal(transformed_path, fill_rule);",
          "new_line_content": "    drawing_state().clip = CanvasClip { path, parse_fill_rule(fill_rule) };",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": "bitmap",
          "new_api": "visit",
          "old_text": "image_element->bitmap()",
          "new_text": "image.visit(\n        // HTMLOrSVGImageElement\n        [](JS::Handle<HTMLImageElement> const& image_element) -> WebIDL::ExceptionOr<Optional<CanvasImageSourceUsability>> {\n            // FIXME: If image's current request's state is broken, then throw an \"InvalidStateError\" DOMException.\n\n            // If image is not fully decodable, then return bad.\n            if (!image_element->bitmap())\n                return { CanvasImageSourceUsability::Bad };\n\n            // If image has an intrinsic width or intrinsic height (or both) equal to zero, then return bad.\n            if (image_element->bitmap()->width() == 0 || image_element->bitmap()->height() == 0)\n                return { CanvasImageSourceUsability::Bad };\n            return Optional<CanvasImageSourceUsability> {};\n        },\n\n        // FIXME: HTMLVideoElement\n        // If image's readyState attribute is either HAVE_NOTHING or HAVE_METADATA, then return bad.\n\n        // HTMLCanvasElement\n        // FIXME: OffscreenCanvas\n        [](JS::Handle<HTMLCanvasElement> const& canvas_element) -> WebIDL::ExceptionOr<Optional<CanvasImageSourceUsability>> {\n            // If image has either a horizontal dimension or a vertical dimension equal to zero, then throw an \"InvalidStateError\" DOMException.\n            if (canvas_element->width() == 0 || canvas_element->height() == 0)\n                return WebIDL::InvalidStateError::create(canvas_element->realm(), \"Canvas width or height is zero\");\n            return Optional<CanvasImageSourceUsability> {};\n        })",
          "old_line_content": "            if (!image_element->bitmap())",
          "new_line_content": "    auto usability = TRY(image.visit(",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 516,
          "old_api": null,
          "new_api": "drawing_state",
          "old_text": null,
          "new_text": "drawing_state()",
          "old_line_content": "{",
          "new_line_content": "    auto transformed_path = path.path().copy_transformed(drawing_state().transform);",
          "content_same": false
        },
        {
          "line": 517,
          "old_api": null,
          "new_api": "clip_internal",
          "old_text": null,
          "new_text": "clip_internal(transformed_path, fill_rule)",
          "old_line_content": "    // 1. Switch on image:",
          "new_line_content": "    return clip_internal(transformed_path, fill_rule);",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": null,
          "new_api": "bitmap",
          "old_text": null,
          "new_text": "image_element->bitmap()",
          "old_line_content": "            return Optional<CanvasImageSourceUsability> {};",
          "new_line_content": "            if (!image_element->bitmap())",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "color.has_value()",
          "old_line_content": "    });",
          "new_line_content": "        if (auto color = drawing_state.fill_style.as_color(); color.has_value()) {",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": null,
          "new_api": "fill_path",
          "old_text": null,
          "new_text": "painter.fill_path(path, *color, fill_rule)",
          "old_line_content": "}",
          "new_line_content": "            painter.fill_path(path, *color, fill_rule);",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": null,
          "new_api": "to_gfx_paint_style",
          "old_text": null,
          "new_text": "drawing_state.fill_style.to_gfx_paint_style()",
          "old_line_content": "void CanvasRenderingContext2D::fill(DeprecatedString const& fill_rule)",
          "new_line_content": "            painter.fill_path(path, drawing_state.fill_style.to_gfx_paint_style(), fill_rule);",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": null,
          "new_api": "bitmap",
          "old_text": null,
          "new_text": "image_element->bitmap()->height()",
          "old_line_content": "        // If image's readyState attribute is either HAVE_NOTHING or HAVE_METADATA, then return bad.",
          "new_line_content": "            if (image_element->bitmap()->width() == 0 || image_element->bitmap()->height() == 0)",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": null,
          "new_api": "baseline",
          "old_text": null,
          "new_text": "font.baseline()",
          "old_line_content": "    return metrics;",
          "new_line_content": "    metrics->set_hanging_baseline(font.baseline());",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": null,
          "new_api": "set_font_bounding_box_ascent",
          "old_text": null,
          "new_text": "metrics->set_font_bounding_box_ascent(0)",
          "old_line_content": "",
          "new_line_content": "    metrics->set_font_bounding_box_ascent(0);",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": null,
          "new_api": "set_font_bounding_box_ascent",
          "old_text": null,
          "new_text": "metrics->set_font_bounding_box_ascent(0)",
          "old_line_content": "CanvasRenderingContext2D::PreparedText CanvasRenderingContext2D::prepare_text(DeprecatedString const& text, float max_width)",
          "new_line_content": "    metrics->set_font_bounding_box_ascent(0);",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": null,
          "new_api": "height",
          "old_text": null,
          "new_text": "canvas_element->height()",
          "old_line_content": "",
          "new_line_content": "            if (canvas_element->width() == 0 || canvas_element->height() == 0)",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": null,
          "new_api": "realm",
          "old_text": null,
          "new_text": "canvas_element->realm()",
          "old_line_content": "    // 2. Return good.",
          "new_line_content": "                return WebIDL::InvalidStateError::create(canvas_element->realm(), \"Canvas width or height is zero\");",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": null,
          "new_api": "fill_internal",
          "old_text": null,
          "new_text": "fill_internal(transformed_path, fill_rule)",
          "old_line_content": "}",
          "new_line_content": "    return fill_internal(transformed_path, fill_rule);",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "text.length()",
          "old_line_content": "    // 3. Let font be the current font of target, as given by that object's font attribute.",
          "new_line_content": "    StringBuilder builder { text.length() };",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "usability.has_value()",
          "old_line_content": "",
          "new_line_content": "    if (usability.has_value())",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": null,
          "new_api": "release_value",
          "old_text": null,
          "new_text": "usability.release_value()",
          "old_line_content": "// https://html.spec.whatwg.org/multipage/canvas.html#the-image-argument-is-not-origin-clean",
          "new_line_content": "        return usability.release_value();",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": null,
          "new_api": "Infra::is_ascii_whitespace(c)",
          "old_text": null,
          "new_text": "Infra::is_ascii_whitespace(c)",
          "old_line_content": "",
          "new_line_content": "        builder.append(Infra::is_ascii_whitespace(c) ? ' ' : c);",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": null,
          "new_api": "realm",
          "old_text": null,
          "new_text": "realm()",
          "old_line_content": "    // 1. If either the sw or sh arguments are zero, then throw an \"IndexSizeError\" DOMException.",
          "new_line_content": "    return ImageData::create_with_size(realm(), width, height);",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": null,
          "new_api": "to_deprecated_string",
          "old_text": null,
          "new_text": "builder.to_deprecated_string()",
          "old_line_content": "    //   4.1. If the target object's direction attribute has the value \"ltr\": Let direction be 'ltr'.",
          "new_line_content": "    auto replaced_text = builder.to_deprecated_string();",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "visit",
          "old_text": null,
          "new_text": "image.visit(\n        // HTMLOrSVGImageElement\n        [](JS::Handle<HTMLImageElement> const&) {\n            // FIXME: image's current request's image data is CORS-cross-origin.\n            return false;\n        },\n\n        // FIXME: HTMLVideoElement\n        // image's media data is CORS-cross-origin.\n\n        // HTMLCanvasElement\n        // FIXME: ImageBitmap\n        [](JS::Handle<HTMLCanvasElement> const&) {\n            // FIXME: image's bitmap's origin-clean flag is false.\n            return false;\n        })",
          "old_line_content": "",
          "new_line_content": "    return image.visit(",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": null,
          "new_api": "realm",
          "old_text": null,
          "new_text": "realm()",
          "old_line_content": "    // 3. Let imageData be a new ImageData object.",
          "new_line_content": "        return WebIDL::IndexSizeError::create(realm(), \"Width and height must not be zero\");",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": null,
          "new_api": "realm",
          "old_text": null,
          "new_text": "realm()",
          "old_line_content": "    // NOTE: We don't attempt to create the underlying bitmap here; if it doesn't exist, it's like copying only transparent black pixels (which is a no-op).",
          "new_line_content": "        return WebIDL::SecurityError::create(realm(), \"CanvasRenderingContext2D is not origin-clean\");",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": null,
          "new_api": "realm",
          "old_text": null,
          "new_text": "realm()",
          "old_line_content": "",
          "new_line_content": "    auto image_data = ImageData::create_with_size(realm(), width, height);",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": null,
          "new_api": "bitmap",
          "old_text": null,
          "new_text": "canvas_element().bitmap()",
          "old_line_content": "    // 6. Set the pixel values of imageData to be the pixels of this's output bitmap in the area specified by the source rectangle in the bitmap's coordinate space units, converted from this's color space to imageData's colorSpace using 'relative-colorimetric' rendering intent.",
          "new_line_content": "    auto const& bitmap = *canvas_element().bitmap();",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": null,
          "new_api": "pixel_size",
          "old_text": null,
          "new_text": "font.pixel_size()",
          "old_line_content": "    // 6. If maxWidth was provided and the hypothetical width of the inline box in the hypothetical line box is greater than maxWidth CSS pixels, then change font to have a more condensed font (if one is available or if a reasonably readable one can be synthesized by applying a horizontal scale factor to the font) or a smaller font, and return to the previous step.",
          "new_line_content": "    size_t height = font.pixel_size();",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": null,
          "new_api": "drawing_state",
          "old_text": null,
          "new_text": "drawing_state()",
          "old_line_content": "}",
          "new_line_content": "    return drawing_state().image_smoothing_enabled;",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": null,
          "new_api": "height",
          "old_text": null,
          "new_text": "source_rect_intersected.height()",
          "old_line_content": "",
          "new_line_content": "    for (int target_y = 0; target_y < source_rect_intersected.height(); ++target_y) {",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "source_rect_intersected.width()",
          "old_line_content": "    // 7. Set the pixels values of imageData for areas of the source rectangle that are outside of the output bitmap to transparent black.",
          "new_line_content": "        for (int target_x = 0; target_x < source_rect_intersected.width(); ++target_x) {",
          "content_same": false
        },
        {
          "line": 328,
          "old_api": null,
          "new_api": "get_pixel",
          "old_text": null,
          "new_text": "bitmap.get_pixel(target_x + x, target_y + y)",
          "old_line_content": "    // NOTE: No-op, already done during creation.",
          "new_line_content": "            auto pixel = bitmap.get_pixel(target_x + x, target_y + y);",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": null,
          "new_api": "set_pixel",
          "old_text": null,
          "new_text": "image_data->bitmap().set_pixel(target_x, target_y, pixel)",
          "old_line_content": "",
          "new_line_content": "            image_data->bitmap().set_pixel(target_x, target_y, pixel);",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": null,
          "new_api": "drawing_state",
          "old_text": null,
          "new_text": "drawing_state()",
          "old_line_content": "}",
          "new_line_content": "    drawing_state().image_smoothing_enabled = enabled;",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "replaced_text_view.end()",
          "old_line_content": "    // 7. The anchor point is a point on the inline box, and the physical alignment is one of the values left, right, and center. These variables are determined by the textAlign and textBaseline values as follows:",
          "new_line_content": "    for (auto it = replaced_text_view.begin(); it != replaced_text_view.end(); ++it)",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": null,
          "new_api": "glyph_or_emoji_width",
          "old_text": null,
          "new_text": "font.glyph_or_emoji_width(it)",
          "old_line_content": "    // Horizontal position:",
          "new_line_content": "        width += font.glyph_or_emoji_width(it);",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": null,
          "new_api": "drawing_state",
          "old_text": null,
          "new_text": "drawing_state()",
          "old_line_content": "}",
          "new_line_content": "    return drawing_state().image_smoothing_quality;",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": null,
          "new_api": "drawing_state",
          "old_text": null,
          "new_text": "drawing_state()",
          "old_line_content": "",
          "new_line_content": "    drawing_state().image_smoothing_quality = quality;",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": null,
          "new_api": "underlying_painter",
          "old_text": null,
          "new_text": "draw_clipped([&](auto& painter) {\n        painter.underlying_painter().blit(Gfx::IntPoint(x, y), image_data.bitmap(), image_data.bitmap().rect());\n        return Gfx::FloatRect(x, y, image_data.width(), image_data.height());\n    })",
          "old_line_content": "// https://html.spec.whatwg.org/multipage/canvas.html#reset-the-rendering-context-to-its-default-state",
          "new_line_content": "    draw_clipped([&](auto& painter) {",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": null,
          "new_api": "bitmap",
          "old_text": null,
          "new_text": "image_data.bitmap().rect()",
          "old_line_content": "void CanvasRenderingContext2D::reset_to_default_state()",
          "new_line_content": "        painter.underlying_painter().blit(Gfx::IntPoint(x, y), image_data.bitmap(), image_data.bitmap().rect());",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": null,
          "new_api": "height",
          "old_text": null,
          "new_text": "image_data.height()",
          "old_line_content": "{",
          "new_line_content": "        return Gfx::FloatRect(x, y, image_data.width(), image_data.height());",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": null,
          "new_api": "maybe_unused",
          "old_text": null,
          "new_text": "maybe_unused",
          "old_line_content": "",
          "new_line_content": "    [[maybe_unused]] Gfx::IntPoint anchor { 0, 0 };",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": null,
          "new_api": "static_cast<int>(height)",
          "old_text": null,
          "new_text": "static_cast<int>(height)",
          "old_line_content": "            return IterationDecision::Continue;",
          "new_line_content": "    PreparedText prepared_text { {}, physical_alignment, { 0, 0, static_cast<int>(width), static_cast<int>(height) } };",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": null,
          "new_api": "painter",
          "old_text": null,
          "new_text": "this->painter()",
          "old_line_content": "    // 2. Empty the list of subpaths in context's current default path.",
          "new_line_content": "    auto painter = this->painter();",
          "content_same": false
        },
        {
          "line": 479,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "replaced_text.length()",
          "old_line_content": "",
          "new_line_content": "    prepared_text.glyphs.ensure_capacity(replaced_text.length());",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": null,
          "new_api": "substring_view",
          "old_text": null,
          "new_text": "Unicode::for_each_grapheme_segmentation_boundary(replaced_text_view, [&](auto boundary) {\n        if (boundary == 0)\n            return IterationDecision::Continue;\n\n        auto glyph_view = replaced_text_view.substring_view(previous_grapheme_boundary, boundary - previous_grapheme_boundary);\n        auto glyph = String::from_utf8(glyph_view.as_string()).release_value_but_fixme_should_propagate_errors();\n\n        prepared_text.glyphs.append({ move(glyph), { static_cast<int>(boundary), 0 } });\n        return IterationDecision::Continue;\n    })",
          "old_line_content": "",
          "new_line_content": "    Unicode::for_each_grapheme_segmentation_boundary(replaced_text_view, [&](auto boundary) {",
          "content_same": false
        },
        {
          "line": 486,
          "old_api": null,
          "new_api": "substring_view",
          "old_text": null,
          "new_text": "replaced_text_view.substring_view(previous_grapheme_boundary, boundary - previous_grapheme_boundary)",
          "old_line_content": "",
          "new_line_content": "        auto glyph_view = replaced_text_view.substring_view(previous_grapheme_boundary, boundary - previous_grapheme_boundary);",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": null,
          "new_api": "as_string",
          "old_text": null,
          "new_text": "glyph_view.as_string()",
          "old_line_content": "    // 9. Return result, physical alignment, and the inline box.",
          "new_line_content": "        auto glyph = String::from_utf8(glyph_view.as_string()).release_value_but_fixme_should_propagate_errors();",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": null,
          "new_api": "static_cast<int>(boundary)",
          "old_text": null,
          "new_text": "static_cast<int>(boundary)",
          "old_line_content": "}",
          "new_line_content": "        prepared_text.glyphs.append({ move(glyph), { static_cast<int>(boundary), 0 } });",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": null,
          "new_api": "reset_drawing_state",
          "old_text": null,
          "new_text": "reset_drawing_state()",
          "old_line_content": "// https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-measuretext",
          "new_line_content": "    reset_drawing_state();",
          "content_same": false
        },
        {
          "line": 367,
          "old_api": null,
          "new_api": "target",
          "old_text": null,
          "new_text": "painter->target()->rect().to_type<float>()",
          "old_line_content": "    // The measureText(text) method steps are to run the text preparation",
          "new_line_content": "        did_draw(painter->target()->rect().to_type<float>());",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": null,
          "new_api": "close_all_subpaths",
          "old_text": null,
          "new_text": "path.close_all_subpaths()",
          "old_line_content": "",
          "new_line_content": "    path.close_all_subpaths();",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "drawing_state().clip.has_value()",
          "old_line_content": "void CanvasRenderingContext2D::clip(DeprecatedString const& fill_rule)",
          "new_line_content": "    if (drawing_state().clip.has_value()) {",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": null,
          "new_api": "dbgln",
          "old_text": null,
          "new_text": "dbgln(\"FIXME: CRC2D: Calculate the new clip path by intersecting the given path with the current one.\")",
          "old_line_content": "{",
          "new_line_content": "        dbgln(\"FIXME: CRC2D: Calculate the new clip path by intersecting the given path with the current one.\");",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": null,
          "new_api": "realm",
          "old_text": null,
          "new_text": "realm()",
          "old_line_content": "    // actualBoundingBoxLeft attribute: The distance parallel to the baseline from the alignment point given by the textAlign attribute to the left side of the bounding rectangle of the given text, in CSS pixels; positive numbers indicating a distance going left from the given alignment point.",
          "new_line_content": "    auto metrics = TextMetrics::create(realm()).release_value_but_fixme_should_propagate_errors();",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": null,
          "new_api": "default_font",
          "old_text": null,
          "new_text": "Platform::FontPlugin::the().default_font()",
          "old_line_content": "    // actualBoundingBoxRight attribute: The distance parallel to the baseline from the alignment point given by the textAlign attribute to the right side of the bounding rectangle of the given text, in CSS pixels; positive numbers indicating a distance going right from the given alignment point.",
          "new_line_content": "    auto& font = Platform::FontPlugin::the().default_font();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 518,
          "old_api": "visit",
          "new_api": null,
          "old_text": "image.visit(\n        // HTMLOrSVGImageElement\n        [](JS::Handle<HTMLImageElement> const& image_element) -> WebIDL::ExceptionOr<Optional<CanvasImageSourceUsability>> {\n            // FIXME: If image's current request's state is broken, then throw an \"InvalidStateError\" DOMException.\n\n            // If image is not fully decodable, then return bad.\n            if (!image_element->bitmap())\n                return { CanvasImageSourceUsability::Bad };\n\n            // If image has an intrinsic width or intrinsic height (or both) equal to zero, then return bad.\n            if (image_element->bitmap()->width() == 0 || image_element->bitmap()->height() == 0)\n                return { CanvasImageSourceUsability::Bad };\n            return Optional<CanvasImageSourceUsability> {};\n        },\n\n        // FIXME: HTMLVideoElement\n        // If image's readyState attribute is either HAVE_NOTHING or HAVE_METADATA, then return bad.\n\n        // HTMLCanvasElement\n        // FIXME: OffscreenCanvas\n        [](JS::Handle<HTMLCanvasElement> const& canvas_element) -> WebIDL::ExceptionOr<Optional<CanvasImageSourceUsability>> {\n            // If image has either a horizontal dimension or a vertical dimension equal to zero, then throw an \"InvalidStateError\" DOMException.\n            if (canvas_element->width() == 0 || canvas_element->height() == 0)\n                return WebIDL::InvalidStateError::create(canvas_element->realm(), \"Canvas width or height is zero\");\n            return Optional<CanvasImageSourceUsability> {};\n        })",
          "new_text": null,
          "old_line_content": "    auto usability = TRY(image.visit(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": "bitmap",
          "new_api": null,
          "old_text": "image_element->bitmap()->height()",
          "new_text": null,
          "old_line_content": "            if (image_element->bitmap()->width() == 0 || image_element->bitmap()->height() == 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": "fill_internal",
          "new_api": null,
          "old_text": "fill_internal(transformed_path, fill_rule)",
          "new_text": null,
          "old_line_content": "    return fill_internal(transformed_path, fill_rule);",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": "height",
          "new_api": null,
          "old_text": "canvas_element->height()",
          "new_text": null,
          "old_line_content": "            if (canvas_element->width() == 0 || canvas_element->height() == 0)",
          "new_line_content": "        // If image's readyState attribute is either HAVE_NOTHING or HAVE_METADATA, then return bad.",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": "realm",
          "new_api": null,
          "old_text": "canvas_element->realm()",
          "new_text": null,
          "old_line_content": "                return WebIDL::InvalidStateError::create(canvas_element->realm(), \"Canvas width or height is zero\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 414,
          "old_api": "length",
          "new_api": null,
          "old_text": "text.length()",
          "new_text": null,
          "old_line_content": "    StringBuilder builder { text.length() };",
          "new_line_content": "    // 1. If maxWidth was provided but is less than or equal to zero or equal to NaN, then return an empty array.",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "usability.has_value()",
          "new_text": null,
          "old_line_content": "    if (usability.has_value())",
          "new_line_content": "        [](JS::Handle<HTMLCanvasElement> const& canvas_element) -> WebIDL::ExceptionOr<Optional<CanvasImageSourceUsability>> {",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "release_value",
          "new_api": null,
          "old_text": "usability.release_value()",
          "new_text": null,
          "old_line_content": "        return usability.release_value();",
          "new_line_content": "            // If image has either a horizontal dimension or a vertical dimension equal to zero, then throw an \"InvalidStateError\" DOMException.",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": "Infra::is_ascii_whitespace(c)",
          "new_api": null,
          "old_text": "Infra::is_ascii_whitespace(c)",
          "new_text": null,
          "old_line_content": "        builder.append(Infra::is_ascii_whitespace(c) ? ' ' : c);",
          "new_line_content": "        return {};",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": "to_deprecated_string",
          "new_api": null,
          "old_text": "builder.to_deprecated_string()",
          "new_text": null,
          "old_line_content": "    auto replaced_text = builder.to_deprecated_string();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": "visit",
          "new_api": null,
          "old_text": "image.visit(\n        // HTMLOrSVGImageElement\n        [](JS::Handle<HTMLImageElement> const&) {\n            // FIXME: image's current request's image data is CORS-cross-origin.\n            return false;\n        },\n\n        // FIXME: HTMLVideoElement\n        // image's media data is CORS-cross-origin.\n\n        // HTMLCanvasElement\n        // FIXME: ImageBitmap\n        [](JS::Handle<HTMLCanvasElement> const&) {\n            // FIXME: image's bitmap's origin-clean flag is false.\n            return false;\n        })",
          "new_text": null,
          "old_line_content": "    return image.visit(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": "realm",
          "new_api": null,
          "old_text": "realm()",
          "new_text": null,
          "old_line_content": "        return WebIDL::IndexSizeError::create(realm(), \"Width and height must not be zero\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": "realm",
          "new_api": null,
          "old_text": "realm()",
          "new_text": null,
          "old_line_content": "        return WebIDL::SecurityError::create(realm(), \"CanvasRenderingContext2D is not origin-clean\");",
          "new_line_content": "    // 1. If either the sw or sh arguments are zero, then throw an \"IndexSizeError\" DOMException.",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": "realm",
          "new_api": null,
          "old_text": "realm()",
          "new_text": null,
          "old_line_content": "    auto image_data = ImageData::create_with_size(realm(), width, height);",
          "new_line_content": "    // 2. If the CanvasRenderingContext2D's origin-clean flag is set to false, then throw a \"SecurityError\" DOMException.",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "bitmap",
          "new_api": null,
          "old_text": "canvas_element().bitmap()",
          "new_text": null,
          "old_line_content": "    if (!canvas_element().bitmap())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "bitmap",
          "new_api": null,
          "old_text": "canvas_element().bitmap()",
          "new_text": null,
          "old_line_content": "    auto const& bitmap = *canvas_element().bitmap();",
          "new_line_content": "    // 4. Initialize imageData given sw, sh, settings set to settings, and defaultColorSpace set to this's color space.",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": "default_font",
          "new_api": null,
          "old_text": "Platform::FontPlugin::the().default_font()",
          "new_text": null,
          "old_line_content": "    auto& font = Platform::FontPlugin::the().default_font();",
          "new_line_content": "    //   SVG text-rendering  -> target's textRendering",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": "pixel_size",
          "new_api": null,
          "old_text": "font.pixel_size()",
          "new_text": null,
          "old_line_content": "    size_t height = font.pixel_size();",
          "new_line_content": "    //   'word-spacing'      -> target's wordSpacing",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "drawing_state",
          "new_api": null,
          "old_text": "drawing_state()",
          "new_text": null,
          "old_line_content": "    return drawing_state().image_smoothing_enabled;",
          "new_line_content": "            return false;",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": "height",
          "new_api": null,
          "old_text": "source_rect_intersected.height()",
          "new_text": null,
          "old_line_content": "    for (int target_y = 0; target_y < source_rect_intersected.height(); ++target_y) {",
          "new_line_content": "    // 5. Let the source rectangle be the rectangle whose corners are the four points (sx, sy), (sx+sw, sy), (sx+sw, sy+sh), (sx, sy+sh).",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": "width",
          "new_api": null,
          "old_text": "source_rect_intersected.width()",
          "new_text": null,
          "old_line_content": "        for (int target_x = 0; target_x < source_rect_intersected.width(); ++target_x) {",
          "new_line_content": "    auto source_rect = Gfx::Rect { x, y, width, height };",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": "end",
          "new_api": null,
          "old_text": "replaced_text_view.end()",
          "new_text": null,
          "old_line_content": "    for (auto it = replaced_text_view.begin(); it != replaced_text_view.end(); ++it)",
          "new_line_content": "    // FIXME: Once we have CanvasTextDrawingStyles, add the CSS attributes.",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": "set_pixel",
          "new_api": null,
          "old_text": "image_data->bitmap().set_pixel(target_x, target_y, pixel)",
          "new_text": null,
          "old_line_content": "            image_data->bitmap().set_pixel(target_x, target_y, pixel);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": "drawing_state",
          "new_api": null,
          "old_text": "drawing_state()",
          "new_text": null,
          "old_line_content": "    drawing_state().image_smoothing_enabled = enabled;",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": "drawing_state",
          "new_api": null,
          "old_text": "drawing_state()",
          "new_text": null,
          "old_line_content": "    return drawing_state().image_smoothing_quality;",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": "drawing_state",
          "new_api": null,
          "old_text": "drawing_state()",
          "new_text": null,
          "old_line_content": "    drawing_state().image_smoothing_quality = quality;",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": "underlying_painter",
          "new_api": null,
          "old_text": "draw_clipped([&](auto& painter) {\n        painter.underlying_painter().blit(Gfx::IntPoint(x, y), image_data.bitmap(), image_data.bitmap().rect());\n        return Gfx::FloatRect(x, y, image_data.width(), image_data.height());\n    })",
          "new_text": null,
          "old_line_content": "    draw_clipped([&](auto& painter) {",
          "new_line_content": "    // 8. Return imageData.",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": "bitmap",
          "new_api": null,
          "old_text": "image_data.bitmap().rect()",
          "new_text": null,
          "old_line_content": "        painter.underlying_painter().blit(Gfx::IntPoint(x, y), image_data.bitmap(), image_data.bitmap().rect());",
          "new_line_content": "    return image_data;",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": "height",
          "new_api": null,
          "old_text": "image_data.height()",
          "new_text": null,
          "old_line_content": "        return Gfx::FloatRect(x, y, image_data.width(), image_data.height());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": "maybe_unused",
          "new_api": null,
          "old_text": "maybe_unused",
          "new_text": null,
          "old_line_content": "    [[maybe_unused]] Gfx::IntPoint anchor { 0, 0 };",
          "new_line_content": "    //   7.5. If textBaseline is hanging: Let the anchor point's vertical position be the hanging baseline of the first available font of the inline box.",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": "static_cast<int>(height)",
          "new_api": null,
          "old_text": "static_cast<int>(height)",
          "new_text": null,
          "old_line_content": "    PreparedText prepared_text { {}, physical_alignment, { 0, 0, static_cast<int>(width), static_cast<int>(height) } };",
          "new_line_content": "    //   7.9. If textBaseline is bottom: Let the anchor point's vertical position be the bottom of the em box of the first available font of the inline box.",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": "painter",
          "new_api": null,
          "old_text": "this->painter()",
          "new_text": null,
          "old_line_content": "    auto painter = this->painter();",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": "length",
          "new_api": null,
          "old_text": "replaced_text.length()",
          "new_text": null,
          "old_line_content": "    prepared_text.glyphs.ensure_capacity(replaced_text.length());",
          "new_line_content": "    // FIXME: Once we have CanvasTextDrawingStyles, handle the alignment and baseline.",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": "substring_view",
          "new_api": null,
          "old_text": "Unicode::for_each_grapheme_segmentation_boundary(replaced_text_view, [&](auto boundary) {\n        if (boundary == 0)\n            return IterationDecision::Continue;\n\n        auto glyph_view = replaced_text_view.substring_view(previous_grapheme_boundary, boundary - previous_grapheme_boundary);\n        auto glyph = String::from_utf8(glyph_view.as_string()).release_value_but_fixme_should_propagate_errors();\n\n        prepared_text.glyphs.append({ move(glyph), { static_cast<int>(boundary), 0 } });\n        return IterationDecision::Continue;\n    })",
          "new_text": null,
          "old_line_content": "    Unicode::for_each_grapheme_segmentation_boundary(replaced_text_view, [&](auto boundary) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": "target",
          "new_api": null,
          "old_text": "painter->target()->rect()",
          "new_text": null,
          "old_line_content": "        painter->clear_rect(painter->target()->rect(), Color::Transparent);",
          "new_line_content": "void CanvasRenderingContext2D::reset_to_default_state()",
          "content_same": false
        },
        {
          "line": 352,
          "old_api": "clear",
          "new_api": null,
          "old_text": "path().clear()",
          "new_text": null,
          "old_line_content": "    path().clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": "substring_view",
          "new_api": null,
          "old_text": "replaced_text_view.substring_view(previous_grapheme_boundary, boundary - previous_grapheme_boundary)",
          "new_text": null,
          "old_line_content": "        auto glyph_view = replaced_text_view.substring_view(previous_grapheme_boundary, boundary - previous_grapheme_boundary);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": "as_string",
          "new_api": null,
          "old_text": "glyph_view.as_string()",
          "new_text": null,
          "old_line_content": "        auto glyph = String::from_utf8(glyph_view.as_string()).release_value_but_fixme_should_propagate_errors();",
          "new_line_content": "    size_t previous_grapheme_boundary = 0;",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": "static_cast<int>(boundary)",
          "new_api": null,
          "old_text": "static_cast<int>(boundary)",
          "new_text": null,
          "old_line_content": "        prepared_text.glyphs.append({ move(glyph), { static_cast<int>(boundary), 0 } });",
          "new_line_content": "        if (boundary == 0)",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": "close_all_subpaths",
          "new_api": null,
          "old_text": "path.close_all_subpaths()",
          "new_text": null,
          "old_line_content": "    path.close_all_subpaths();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "drawing_state().clip.has_value()",
          "new_text": null,
          "old_line_content": "    if (drawing_state().clip.has_value()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": "dbgln",
          "new_api": null,
          "old_text": "dbgln(\"FIXME: CRC2D: Calculate the new clip path by intersecting the given path with the current one.\")",
          "new_text": null,
          "old_line_content": "        dbgln(\"FIXME: CRC2D: Calculate the new clip path by intersecting the given path with the current one.\");",
          "new_line_content": "void CanvasRenderingContext2D::clip_internal(Gfx::Path& path, StringView fill_rule)",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": "parse_fill_rule",
          "new_api": null,
          "old_text": "parse_fill_rule(fill_rule)",
          "new_text": null,
          "old_line_content": "    drawing_state().clip = CanvasClip { path, parse_fill_rule(fill_rule) };",
          "new_line_content": "    // FIXME: This should calculate the new clip path by intersecting the given path with the current one.",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "prepare_text",
          "new_api": null,
          "old_text": "prepare_text(text)",
          "new_text": null,
          "old_line_content": "    auto prepared_text = prepare_text(text);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": "realm",
          "new_api": null,
          "old_text": "realm()",
          "new_text": null,
          "old_line_content": "    auto metrics = TextMetrics::create(realm()).release_value_but_fixme_should_propagate_errors();",
          "new_line_content": "    // The measureText(text) method steps are to run the text preparation",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": "default_font",
          "new_api": null,
          "old_text": "Platform::FontPlugin::the().default_font()",
          "new_text": null,
          "old_line_content": "    auto& font = Platform::FontPlugin::the().default_font();",
          "new_line_content": "    // interface, and then using the returned inline box must return a new",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": "drawing_state",
          "new_api": null,
          "old_text": "drawing_state()",
          "new_text": null,
          "old_line_content": "    auto transformed_path = path().copy_transformed(drawing_state().transform);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "left",
          "new_api": null,
          "old_text": "prepared_text.bounding_box.left()",
          "new_text": null,
          "old_line_content": "    metrics->set_actual_bounding_box_left(-prepared_text.bounding_box.left());",
          "new_line_content": "    // FIXME: Use the font that was used to create the glyphs in prepared_text.",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": "right",
          "new_api": null,
          "old_text": "prepared_text.bounding_box.right()",
          "new_text": null,
          "old_line_content": "    metrics->set_actual_bounding_box_right(prepared_text.bounding_box.right());",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 18,
      "total_additions": 53,
      "total_deletions": 49,
      "total_api_changes": 120
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 120,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          268,
          276,
          278
        ]
      }
    },
    "api_calls_before": 272,
    "api_calls_after": 275,
    "diff_info": {
      "added_lines": 8,
      "removed_lines": 2,
      "total_diff_lines": 25
    }
  }
}