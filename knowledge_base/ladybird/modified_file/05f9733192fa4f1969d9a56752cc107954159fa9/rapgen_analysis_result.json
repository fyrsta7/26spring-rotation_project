{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/05f9733192fa4f1969d9a56752cc107954159fa9",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/05f9733192fa4f1969d9a56752cc107954159fa9/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/05f9733192fa4f1969d9a56752cc107954159fa9/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/05f9733192fa4f1969d9a56752cc107954159fa9/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": true,
    "api_changes": {
      "replacements": [
        {
          "line": 353,
          "old_api": "accumulate_non_zero_scanline",
          "new_api": "accumulate_even_odd_scanline",
          "old_text": "accumulate_non_zero_scanline(edge_extent, init, callback)",
          "new_text": "accumulate_even_odd_scanline(edge_extent, init, callback)",
          "old_line_content": "        return accumulate_non_zero_scanline(edge_extent, init, callback);",
          "new_line_content": "        return accumulate_even_odd_scanline(edge_extent, init, callback);",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": "coverage_to_alpha",
          "new_api": "x",
          "old_text": "coverage_to_alpha(coverage)",
          "new_text": "m_blit_origin.x()",
          "old_line_content": "    auto paint_color = scanline_color(scanline, offset, coverage_to_alpha(coverage), color_or_function);",
          "new_line_content": "    auto dest_x = offset + m_blit_origin.x();",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": "blend",
          "new_api": "SubpixelSample::compute_coverage(sample)",
          "old_text": "color_for_format(format, scanline_ptr[dest_x]).blend(paint_color).value()",
          "new_text": "SubpixelSample::compute_coverage(sample)",
          "old_line_content": "    scanline_ptr[dest_x] = color_for_format(format, scanline_ptr[dest_x]).blend(paint_color).value();",
          "new_line_content": "    auto coverage = SubpixelSample::compute_coverage(sample);",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "value",
          "new_api": "x",
          "old_text": "color.value()",
          "new_text": "m_blit_origin.x()",
          "old_line_content": "    fast_u32_fill(scanline_ptr + start_x, color.value(), end_x - start_x + 1);",
          "new_line_content": "    auto start_x = start + m_blit_origin.x();",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": "NumericLimits<SampleType>::max()",
          "new_api": "alpha",
          "old_text": "NumericLimits<SampleType>::max()",
          "new_text": "color.alpha()",
          "old_line_content": "        constexpr SampleType full_converage = NumericLimits<SampleType>::max();",
          "new_line_content": "        if (color.alpha() != 255)",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "accumulate_scanline<WindingRule>(clipped_extent, acc, [&](int x, SampleType sample) {\n            if (sample == full_converage) {\n                full_converage_count++;\n                return;\n            } else {\n                write_pixel(dest_format, dest_ptr, scanline, x, sample, color);\n            }\n            if (full_converage_count > 0) {\n                fast_fill_solid_color_span(dest_ptr, x - full_converage_count, x - 1, color);\n                full_converage_count = 0;\n            }\n        })",
          "new_api": "NumericLimits<SampleType>::max()",
          "old_text": "accumulate_scanline<WindingRule>(clipped_extent, acc, [&](int x, SampleType sample) {\n            if (sample == full_converage) {\n                full_converage_count++;\n                return;\n            } else {\n                write_pixel(dest_format, dest_ptr, scanline, x, sample, color);\n            }\n            if (full_converage_count > 0) {\n                fast_fill_solid_color_span(dest_ptr, x - full_converage_count, x - 1, color);\n                full_converage_count = 0;\n            }\n        })",
          "new_text": "NumericLimits<SampleType>::max()",
          "old_line_content": "        accumulate_scanline<WindingRule>(clipped_extent, acc, [&](int x, SampleType sample) {",
          "new_line_content": "        constexpr SampleType full_converage = NumericLimits<SampleType>::max();",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": "switch_on_color_or_function",
          "new_api": "fast_fill_solid_color_span",
          "old_text": "switch_on_color_or_function(\n        color_or_function, write_scanline_with_fast_fills, write_scanline_pixelwise)",
          "new_text": "fast_fill_solid_color_span(dest_ptr, clipped_extent.max_x - full_converage_count + 1, clipped_extent.max_x, color)",
          "old_line_content": "    switch_on_color_or_function(",
          "new_line_content": "            fast_fill_solid_color_span(dest_ptr, clipped_extent.max_x - full_converage_count + 1, clipped_extent.max_x, color);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 388,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "m_windings.data()",
          "old_line_content": "    }",
          "new_line_content": "            edge_extent.memset_extent(m_windings.data(), 0);",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": null,
          "new_api": "initial_acc<WindingRule>()",
          "old_text": null,
          "new_text": "initial_acc<WindingRule>()",
          "old_line_content": "    });",
          "new_line_content": "    auto acc = accumulate_scanline<WindingRule>(EdgeExtent { edge_extent.min_x, left_clip - 1 }, initial_acc<WindingRule>(), [](int, SampleType) {",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": null,
          "new_api": "target",
          "old_text": null,
          "new_text": "painter.target()->format()",
          "old_line_content": "",
          "new_line_content": "    auto dest_format = painter.target()->format();",
          "content_same": false
        },
        {
          "line": 399,
          "old_api": null,
          "new_api": "y",
          "old_text": null,
          "new_text": "m_blit_origin.y()",
          "old_line_content": "    // Simple case: Handle each pixel individually.",
          "new_line_content": "    auto dest_ptr = painter.target()->scanline(scanline + m_blit_origin.y());",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": null,
          "new_api": "accumulate_scanline<WindingRule>(clipped_extent, acc, [&](int x, SampleType sample) {\n            write_pixel(dest_format, dest_ptr, scanline, x, sample, color_or_function);\n        })",
          "old_text": null,
          "new_text": "accumulate_scanline<WindingRule>(clipped_extent, acc, [&](int x, SampleType sample) {\n            write_pixel(dest_format, dest_ptr, scanline, x, sample, color_or_function);\n        })",
          "old_line_content": "        });",
          "new_line_content": "        accumulate_scanline<WindingRule>(clipped_extent, acc, [&](int x, SampleType sample) {",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": null,
          "new_api": "write_pixel",
          "old_text": null,
          "new_text": "write_pixel(dest_format, dest_ptr, scanline, x, sample, color_or_function)",
          "old_line_content": "    };",
          "new_line_content": "            write_pixel(dest_format, dest_ptr, scanline, x, sample, color_or_function);",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": null,
          "new_api": "write_scanline_pixelwise",
          "old_text": null,
          "new_text": "write_scanline_pixelwise(color)",
          "old_line_content": "        int full_converage_count = 0;",
          "new_line_content": "            return write_scanline_pixelwise(color);",
          "content_same": false
        },
        {
          "line": 415,
          "old_api": null,
          "new_api": "accumulate_scanline<WindingRule>(clipped_extent, acc, [&](int x, SampleType sample) {\n            if (sample == full_converage) {\n                full_converage_count++;\n                return;\n            } else {\n                write_pixel(dest_format, dest_ptr, scanline, x, sample, color);\n            }\n            if (full_converage_count > 0) {\n                fast_fill_solid_color_span(dest_ptr, x - full_converage_count, x - 1, color);\n                full_converage_count = 0;\n            }\n        })",
          "old_text": null,
          "new_text": "accumulate_scanline<WindingRule>(clipped_extent, acc, [&](int x, SampleType sample) {\n            if (sample == full_converage) {\n                full_converage_count++;\n                return;\n            } else {\n                write_pixel(dest_format, dest_ptr, scanline, x, sample, color);\n            }\n            if (full_converage_count > 0) {\n                fast_fill_solid_color_span(dest_ptr, x - full_converage_count, x - 1, color);\n                full_converage_count = 0;\n            }\n        })",
          "old_line_content": "                full_converage_count++;",
          "new_line_content": "        accumulate_scanline<WindingRule>(clipped_extent, acc, [&](int x, SampleType sample) {",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": null,
          "new_api": "write_pixel",
          "old_text": null,
          "new_text": "write_pixel(dest_format, dest_ptr, scanline, x, sample, color)",
          "old_line_content": "            if (full_converage_count > 0) {",
          "new_line_content": "                write_pixel(dest_format, dest_ptr, scanline, x, sample, color);",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": null,
          "new_api": "fast_fill_solid_color_span",
          "old_text": null,
          "new_text": "fast_fill_solid_color_span(dest_ptr, x - full_converage_count, x - 1, color)",
          "old_line_content": "            }",
          "new_line_content": "                fast_fill_solid_color_span(dest_ptr, x - full_converage_count, x - 1, color);",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": null,
          "new_api": "switch_on_color_or_function",
          "old_text": null,
          "new_text": "switch_on_color_or_function(\n        color_or_function, write_scanline_with_fast_fills, write_scanline_pixelwise)",
          "old_line_content": "}",
          "new_line_content": "    switch_on_color_or_function(",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": null,
          "new_api": "bounding_box",
          "old_text": null,
          "new_text": "path.bounding_box()",
          "old_line_content": "",
          "new_line_content": "    return enclosing_int_rect(path.bounding_box()).size();",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": null,
          "new_api": "VERIFY",
          "old_text": null,
          "new_text": "VERIFY(edge_extent.min_x >= 0)",
          "old_line_content": "    for (int x = edge_extent.min_x; x <= edge_extent.max_x; x += 1) {",
          "new_line_content": "    VERIFY(edge_extent.min_x >= 0);",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "m_scanline.size()",
          "old_line_content": "        sample ^= m_scanline[x];",
          "new_line_content": "    VERIFY(edge_extent.max_x <= static_cast<int>(m_scanline.size()));",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "m_scanline.data()",
          "old_line_content": "        m_scanline[x] = 0;",
          "new_line_content": "        sample ^= m_scanline.data()[x];",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": null,
          "new_api": "sample_callback",
          "old_text": null,
          "new_text": "sample_callback(x, sample)",
          "old_line_content": "    }",
          "new_line_content": "        sample_callback(x, sample);",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "m_scanline.data()",
          "old_line_content": "    return sample;",
          "new_line_content": "        m_scanline.data()[x] = 0;",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": null,
          "new_api": "fill",
          "old_text": null,
          "new_text": "rasterizer.fill(*this, path, color, winding_rule)",
          "old_line_content": "",
          "new_line_content": "    rasterizer.fill(*this, path, color, winding_rule);",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": null,
          "new_api": "fill",
          "old_text": null,
          "new_text": "rasterizer.fill(*this, path, paint_style, opacity, winding_rule)",
          "old_line_content": "",
          "new_line_content": "    rasterizer.fill(*this, path, paint_style, opacity, winding_rule);",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": null,
          "new_api": "translation",
          "old_text": null,
          "new_text": "m_transform.translation()",
          "old_line_content": "",
          "new_line_content": "    rasterizer.fill(m_underlying_painter, path, color, winding_rule, m_transform.translation());",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": null,
          "new_api": "translation",
          "old_text": null,
          "new_text": "m_transform.translation()",
          "old_line_content": "",
          "new_line_content": "    rasterizer.fill(m_underlying_painter, path, paint_style, opacity, winding_rule, m_transform.translation());",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": null,
          "new_api": "sample_callback",
          "old_text": null,
          "new_text": "sample_callback(x, acc.sample)",
          "old_line_content": "        m_windings[x] = {};",
          "new_line_content": "        sample_callback(x, acc.sample);",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": null,
          "new_api": "accumulate_non_zero_scanline",
          "old_text": null,
          "new_text": "accumulate_non_zero_scanline(edge_extent, init, callback)",
          "old_line_content": "",
          "new_line_content": "        return accumulate_non_zero_scanline(edge_extent, init, callback);",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": null,
          "new_api": "coverage_to_alpha",
          "old_text": null,
          "new_text": "coverage_to_alpha(coverage)",
          "old_line_content": "}",
          "new_line_content": "    auto paint_color = scanline_color(scanline, offset, coverage_to_alpha(coverage), color_or_function);",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": null,
          "new_api": "blend",
          "old_text": null,
          "new_text": "color_for_format(format, scanline_ptr[dest_x]).blend(paint_color).value()",
          "old_line_content": "",
          "new_line_content": "    scanline_ptr[dest_x] = color_for_format(format, scanline_ptr[dest_x]).blend(paint_color).value();",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": null,
          "new_api": "x",
          "old_text": null,
          "new_text": "m_blit_origin.x()",
          "old_line_content": "}",
          "new_line_content": "    auto end_x = end + m_blit_origin.x();",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "color.value()",
          "old_line_content": "",
          "new_line_content": "    fast_u32_fill(scanline_ptr + start_x, color.value(), end_x - start_x + 1);",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": null,
          "new_api": "__attribute__",
          "old_text": null,
          "new_text": "__attribute__((hot))",
          "old_line_content": "    // Handle scanline clipping.",
          "new_line_content": "FLATTEN __attribute__((hot)) void EdgeFlagPathRasterizer<SamplesPerPixel>::write_scanline(Painter& painter, int scanline, EdgeExtent edge_extent, auto& color_or_function)",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": null,
          "new_api": "x",
          "old_text": null,
          "new_text": "m_blit_origin.x()",
          "old_line_content": "    if (clipped_extent.min_x > clipped_extent.max_x) {",
          "new_line_content": "    auto left_clip = m_clip.left() - m_blit_origin.x();",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": null,
          "new_api": "max",
          "old_text": null,
          "new_text": "max(left_clip, edge_extent.min_x)",
          "old_line_content": "        // Fully clipped. Unfortunately we still need to zero the scanline data.",
          "new_line_content": "    EdgeExtent clipped_extent { max(left_clip, edge_extent.min_x), edge_extent.max_x };",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 384,
          "old_api": "data",
          "new_api": null,
          "old_text": "m_scanline.data()",
          "new_text": null,
          "old_line_content": "        edge_extent.memset_extent(m_scanline.data(), 0);",
          "new_line_content": "    if (clipped_extent.min_x > clipped_extent.max_x) {",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": "initial_acc<WindingRule>()",
          "new_api": null,
          "old_text": "initial_acc<WindingRule>()",
          "new_text": null,
          "old_line_content": "    auto acc = accumulate_scanline<WindingRule>(EdgeExtent { edge_extent.min_x, left_clip - 1 }, initial_acc<WindingRule>(), [](int, SampleType) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": "target",
          "new_api": null,
          "old_text": "painter.target()->format()",
          "new_text": null,
          "old_line_content": "    auto dest_format = painter.target()->format();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": "y",
          "new_api": null,
          "old_text": "m_blit_origin.y()",
          "new_text": null,
          "old_line_content": "    auto dest_ptr = painter.target()->scanline(scanline + m_blit_origin.y());",
          "new_line_content": "    // Get pointer to current scanline pixels.",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": "accumulate_scanline<WindingRule>(clipped_extent, acc, [&](int x, SampleType sample) {\n            write_pixel(dest_format, dest_ptr, scanline, x, sample, color_or_function);\n        })",
          "new_api": null,
          "old_text": "accumulate_scanline<WindingRule>(clipped_extent, acc, [&](int x, SampleType sample) {\n            write_pixel(dest_format, dest_ptr, scanline, x, sample, color_or_function);\n        })",
          "new_text": null,
          "old_line_content": "        accumulate_scanline<WindingRule>(clipped_extent, acc, [&](int x, SampleType sample) {",
          "new_line_content": "    // Used for PaintStyle fills and semi-transparent colors.",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": "write_pixel",
          "new_api": null,
          "old_text": "write_pixel(dest_format, dest_ptr, scanline, x, sample, color_or_function)",
          "new_text": null,
          "old_line_content": "            write_pixel(dest_format, dest_ptr, scanline, x, sample, color_or_function);",
          "new_line_content": "    auto write_scanline_pixelwise = [&](auto& color_or_function) {",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": "alpha",
          "new_api": null,
          "old_text": "color.alpha()",
          "new_text": null,
          "old_line_content": "        if (color.alpha() != 255)",
          "new_line_content": "    // Used for opaque colors (i.e. alpha == 255).",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "write_scanline_pixelwise",
          "new_api": null,
          "old_text": "write_scanline_pixelwise(color)",
          "new_text": null,
          "old_line_content": "            return write_scanline_pixelwise(color);",
          "new_line_content": "    auto write_scanline_with_fast_fills = [&](Color color) {",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": "write_pixel",
          "new_api": null,
          "old_text": "write_pixel(dest_format, dest_ptr, scanline, x, sample, color)",
          "new_text": null,
          "old_line_content": "                write_pixel(dest_format, dest_ptr, scanline, x, sample, color);",
          "new_line_content": "                return;",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": "fast_fill_solid_color_span",
          "new_api": null,
          "old_text": "fast_fill_solid_color_span(dest_ptr, x - full_converage_count, x - 1, color)",
          "new_text": null,
          "old_line_content": "                fast_fill_solid_color_span(dest_ptr, x - full_converage_count, x - 1, color);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": "fast_fill_solid_color_span",
          "new_api": null,
          "old_text": "fast_fill_solid_color_span(dest_ptr, clipped_extent.max_x - full_converage_count + 1, clipped_extent.max_x, color)",
          "new_text": null,
          "old_line_content": "            fast_fill_solid_color_span(dest_ptr, clipped_extent.max_x - full_converage_count + 1, clipped_extent.max_x, color);",
          "new_line_content": "        });",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": "bounding_box",
          "new_api": null,
          "old_text": "path.bounding_box()",
          "new_text": null,
          "old_line_content": "    return enclosing_int_rect(path.bounding_box()).size();",
          "new_line_content": "static IntSize path_bounds(Gfx::Path const& path)",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": "sample_callback",
          "new_api": null,
          "old_text": "sample_callback(x, sample)",
          "new_text": null,
          "old_line_content": "        sample_callback(x, sample);",
          "new_line_content": "    for (int x = edge_extent.min_x; x <= edge_extent.max_x; x += 1) {",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": "fill",
          "new_api": null,
          "old_text": "rasterizer.fill(*this, path, color, winding_rule)",
          "new_text": null,
          "old_line_content": "    rasterizer.fill(*this, path, color, winding_rule);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": "fill",
          "new_api": null,
          "old_text": "rasterizer.fill(*this, path, paint_style, opacity, winding_rule)",
          "new_text": null,
          "old_line_content": "    rasterizer.fill(*this, path, paint_style, opacity, winding_rule);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": "translation",
          "new_api": null,
          "old_text": "m_transform.translation()",
          "new_text": null,
          "old_line_content": "    rasterizer.fill(m_underlying_painter, path, color, winding_rule, m_transform.translation());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": "translation",
          "new_api": null,
          "old_text": "m_transform.translation()",
          "new_text": null,
          "old_line_content": "    rasterizer.fill(m_underlying_painter, path, paint_style, opacity, winding_rule, m_transform.translation());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": "sample_callback",
          "new_api": null,
          "old_text": "sample_callback(x, acc.sample)",
          "new_text": null,
          "old_line_content": "        sample_callback(x, acc.sample);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": "accumulate_even_odd_scanline",
          "new_api": null,
          "old_text": "accumulate_even_odd_scanline(edge_extent, init, callback)",
          "new_text": null,
          "old_line_content": "        return accumulate_even_odd_scanline(edge_extent, init, callback);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": "x",
          "new_api": null,
          "old_text": "m_blit_origin.x()",
          "new_text": null,
          "old_line_content": "    auto dest_x = offset + m_blit_origin.x();",
          "new_line_content": "    if (!sample)",
          "content_same": false
        },
        {
          "line": 362,
          "old_api": "SubpixelSample::compute_coverage(sample)",
          "new_api": null,
          "old_text": "SubpixelSample::compute_coverage(sample)",
          "new_text": null,
          "old_line_content": "    auto coverage = SubpixelSample::compute_coverage(sample);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": "x",
          "new_api": null,
          "old_text": "m_blit_origin.x()",
          "new_text": null,
          "old_line_content": "    auto start_x = start + m_blit_origin.x();",
          "new_line_content": "void EdgeFlagPathRasterizer<SamplesPerPixel>::fast_fill_solid_color_span(ARGB32* scanline_ptr, int start, int end, Color color)",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": "x",
          "new_api": null,
          "old_text": "m_blit_origin.x()",
          "new_text": null,
          "old_line_content": "    auto end_x = end + m_blit_origin.x();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": "__attribute__",
          "new_api": null,
          "old_text": "__attribute__((hot))",
          "new_text": null,
          "old_line_content": "FLATTEN __attribute__((hot)) void EdgeFlagPathRasterizer<SamplesPerPixel>::write_scanline(Painter& painter, int scanline, EdgeExtent edge_extent, auto& color_or_function)",
          "new_line_content": "template<unsigned SamplesPerPixel>",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "x",
          "new_api": null,
          "old_text": "m_blit_origin.x()",
          "new_text": null,
          "old_line_content": "    auto left_clip = m_clip.left() - m_blit_origin.x();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": "max",
          "new_api": null,
          "old_text": "max(left_clip, edge_extent.min_x)",
          "new_text": null,
          "old_line_content": "    EdgeExtent clipped_extent { max(left_clip, edge_extent.min_x), edge_extent.max_x };",
          "new_line_content": "    // Handle scanline clipping.",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 7,
      "total_additions": 30,
      "total_deletions": 26,
      "total_api_changes": 63
    },
    "non_api_changes": {
      "has_non_api_changes": false,
      "evidence": {
        "total_diff_lines": 4,
        "api_related_lines": 63,
        "non_api_lines": 0,
        "non_api_line_numbers": []
      }
    },
    "api_calls_before": 145,
    "api_calls_after": 151,
    "diff_info": {
      "added_lines": 4,
      "removed_lines": 2,
      "total_diff_lines": 20
    }
  }
}