{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/protobuf/modified_file/34fe50818d9cfb7c6200875985f12546e9400f22",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/protobuf/modified_file/34fe50818d9cfb7c6200875985f12546e9400f22/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/protobuf/modified_file/34fe50818d9cfb7c6200875985f12546e9400f22/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/protobuf/modified_file/34fe50818d9cfb7c6200875985f12546e9400f22/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": true,
    "api_changes": {
      "replacements": [
        {
          "line": 32,
          "old_api": "max",
          "new_api": "upb_table_size",
          "old_text": "max(t->size_lg2, 4)",
          "new_text": "upb_table_size(t)",
          "old_line_content": "  t->size_lg2 = max(t->size_lg2, 4);  /* Min size of 16. */",
          "new_line_content": "  size_t bytes = upb_table_size(t) * t->entry_size;",
          "content_same": false
        },
        {
          "line": 33,
          "old_api": "upb_table_size",
          "new_api": "malloc",
          "old_text": "upb_table_size(t)",
          "new_text": "malloc(bytes)",
          "old_line_content": "  size_t bytes = upb_table_size(t) * t->entry_size;",
          "new_line_content": "  t->entries = malloc(bytes);",
          "content_same": false
        },
        {
          "line": 34,
          "old_api": "malloc",
          "new_api": "memset",
          "old_text": "malloc(bytes)",
          "new_text": "memset(t->entries, 0, bytes)",
          "old_line_content": "  t->entries = malloc(bytes);",
          "new_line_content": "  memset(t->entries, 0, bytes);  /* Both tables consider 0's an empty entry. */",
          "content_same": false
        },
        {
          "line": 48,
          "old_api": "free",
          "new_api": "upb_table_free",
          "old_text": "free(t->entries)",
          "new_text": "upb_table_free(&t->t)",
          "old_line_content": "void upb_table_free(struct upb_table *t) { free(t->entries); }",
          "new_line_content": "void upb_inttable_free(struct upb_inttable *t) { upb_table_free(&t->t); }",
          "content_same": false
        },
        {
          "line": 54,
          "old_api": "MurmurHash2",
          "new_api": "upb_strtable_size",
          "old_text": "MurmurHash2(key->ptr, key->byte_len, 0)",
          "new_text": "upb_strtable_size(t)",
          "old_line_content": "  uint32_t hash = MurmurHash2(key->ptr, key->byte_len, 0);",
          "new_line_content": "  return (hash & (upb_strtable_size(t)-1)) + 1;",
          "content_same": false
        },
        {
          "line": 63,
          "old_api": "strent",
          "new_api": "upb_streql",
          "old_text": "strent(t, bucket)",
          "new_text": "upb_streql(&e->key, key)",
          "old_line_content": "    e = strent(t, bucket);",
          "new_line_content": "    if(upb_streql(&e->key, key)) return e;",
          "content_same": false
        },
        {
          "line": 72,
          "old_api": "upb_inttable_size",
          "new_api": "intent",
          "old_text": "upb_inttable_size(table)",
          "new_text": "intent(table, i)",
          "old_line_content": "  for(uint32_t i = 1; i <= upb_inttable_size(table); i++) {",
          "new_line_content": "    struct upb_inttable_entry *e = intent(table, i);",
          "content_same": false
        },
        {
          "line": 85,
          "old_api": "upb_inttable_lookup",
          "new_api": "upb_inttable_bucket",
          "old_text": "upb_inttable_lookup(t, e->key, t->t.entry_size)",
          "new_text": "upb_inttable_bucket(t, e->key)",
          "old_line_content": "  assert(upb_inttable_lookup(t, e->key, t->t.entry_size) == NULL);",
          "new_line_content": "  uint32_t bucket = upb_inttable_bucket(t, e->key);",
          "content_same": false
        },
        {
          "line": 86,
          "old_api": "upb_inttable_bucket",
          "new_api": "intent",
          "old_text": "upb_inttable_bucket(t, e->key)",
          "new_text": "intent(t, bucket)",
          "old_line_content": "  uint32_t bucket = upb_inttable_bucket(t, e->key);",
          "new_line_content": "  struct upb_inttable_entry *table_e = intent(t, bucket);",
          "content_same": false
        },
        {
          "line": 100,
          "old_api": "empty_intbucket",
          "new_api": "upb_inttable_bucket",
          "old_text": "empty_intbucket(t)",
          "new_text": "upb_inttable_bucket(t, table_e->key)",
          "old_line_content": "      uint32_t empty_bucket = empty_intbucket(t);",
          "new_line_content": "      uint32_t evictee_bucket = upb_inttable_bucket(t, table_e->key);",
          "content_same": false
        },
        {
          "line": 101,
          "old_api": "upb_inttable_bucket",
          "new_api": "intent",
          "old_text": "upb_inttable_bucket(t, table_e->key)",
          "new_text": "intent(t, empty_bucket)",
          "old_line_content": "      uint32_t evictee_bucket = upb_inttable_bucket(t, table_e->key);",
          "new_line_content": "      memcpy(intent(t, empty_bucket), table_e, t->t.entry_size); /* copies next */",
          "content_same": false
        },
        {
          "line": 122,
          "old_api": "assert",
          "new_api": "upb_inttable_size",
          "old_text": "assert(e->key != 0)",
          "new_text": "upb_inttable_size(t)",
          "old_line_content": "  assert(e->key != 0);",
          "new_line_content": "  if((double)++t->t.count / upb_inttable_size(t) > MAX_LOAD) {",
          "content_same": false
        },
        {
          "line": 128,
          "old_api": "upb_inttable_next",
          "new_api": "intinsert",
          "old_text": "upb_inttable_next(t, old_e)",
          "new_text": "intinsert(&new_table, old_e)",
          "old_line_content": "    for(old_e = upb_inttable_begin(t); old_e; old_e = upb_inttable_next(t, old_e))",
          "new_line_content": "      intinsert(&new_table, old_e);",
          "content_same": false
        },
        {
          "line": 129,
          "old_api": "intinsert",
          "new_api": "upb_inttable_free",
          "old_text": "intinsert(&new_table, old_e)",
          "new_text": "upb_inttable_free(t)",
          "old_line_content": "      intinsert(&new_table, old_e);",
          "new_line_content": "    upb_inttable_free(t);",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": "upb_strtable_size",
          "new_api": "strent",
          "old_text": "upb_strtable_size(table)",
          "new_text": "strent(table, i)",
          "old_line_content": "  for(uint32_t i = 1; i <= upb_strtable_size(table); i++) {",
          "new_line_content": "    struct upb_strtable_entry *e = strent(table, i);",
          "content_same": false
        },
        {
          "line": 149,
          "old_api": "upb_strtable_lookup",
          "new_api": "strtable_bucket",
          "old_text": "upb_strtable_lookup(t, &e->key)",
          "new_text": "strtable_bucket(t, &e->key)",
          "old_line_content": "  assert(upb_strtable_lookup(t, &e->key) == NULL);",
          "new_line_content": "  uint32_t bucket = strtable_bucket(t, &e->key);",
          "content_same": false
        },
        {
          "line": 150,
          "old_api": "strtable_bucket",
          "new_api": "strent",
          "old_text": "strtable_bucket(t, &e->key)",
          "new_text": "strent(t, bucket)",
          "old_line_content": "  uint32_t bucket = strtable_bucket(t, &e->key);",
          "new_line_content": "  struct upb_strtable_entry *table_e = strent(t, bucket);",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": "empty_strbucket",
          "new_api": "strtable_bucket",
          "old_text": "empty_strbucket(t)",
          "new_text": "strtable_bucket(t, &table_e->key)",
          "old_line_content": "      uint32_t empty_bucket = empty_strbucket(t);",
          "new_line_content": "      uint32_t evictee_bucket = strtable_bucket(t, &table_e->key);",
          "content_same": false
        },
        {
          "line": 165,
          "old_api": "strtable_bucket",
          "new_api": "strent",
          "old_text": "strtable_bucket(t, &table_e->key)",
          "new_text": "strent(t, empty_bucket)",
          "old_line_content": "      uint32_t evictee_bucket = strtable_bucket(t, &table_e->key);",
          "new_line_content": "      memcpy(strent(t, empty_bucket), table_e, t->t.entry_size); /* copies next */",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": "upb_strtable_next",
          "new_api": "strinsert",
          "old_text": "upb_strtable_next(t, old_e)",
          "new_text": "strinsert(&new_table, old_e)",
          "old_line_content": "    for(old_e = upb_strtable_begin(t); old_e; old_e = upb_strtable_next(t, old_e))",
          "new_line_content": "      strinsert(&new_table, old_e);",
          "content_same": false
        },
        {
          "line": 193,
          "old_api": "strinsert",
          "new_api": "upb_strtable_free",
          "old_text": "strinsert(&new_table, old_e)",
          "new_text": "upb_strtable_free(t)",
          "old_line_content": "      strinsert(&new_table, old_e);",
          "new_line_content": "    upb_strtable_free(t);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 132,
          "old_api": null,
          "new_api": "intinsert",
          "old_text": null,
          "new_text": "intinsert(t, e)",
          "old_line_content": "  }",
          "new_line_content": "  intinsert(t, e);",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": null,
          "new_api": "upb_strtable_size",
          "old_text": null,
          "new_text": "upb_strtable_size(table)",
          "old_line_content": "  /* TODO: does it matter that this is biased towards the front of the table? */",
          "new_line_content": "  for(uint32_t i = 1; i <= upb_strtable_size(table); i++) {",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(false)",
          "old_line_content": "  }",
          "new_line_content": "  assert(false);",
          "content_same": false
        },
        {
          "line": 148,
          "old_api": null,
          "new_api": "upb_strtable_lookup",
          "old_text": null,
          "new_text": "upb_strtable_lookup(t, &e->key)",
          "old_line_content": "{",
          "new_line_content": "  assert(upb_strtable_lookup(t, &e->key) == NULL);",
          "content_same": false
        },
        {
          "line": 152,
          "old_api": null,
          "new_api": "strtable_bucket",
          "old_text": null,
          "new_text": "strtable_bucket(t, &table_e->key)",
          "old_line_content": "  if(table_e->key.byte_len != 0) {  /* Collision. */",
          "new_line_content": "    if(bucket == strtable_bucket(t, &table_e->key)) {",
          "content_same": false
        },
        {
          "line": 155,
          "old_api": null,
          "new_api": "empty_strbucket",
          "old_text": null,
          "new_text": "empty_strbucket(t)",
          "old_line_content": "       * place our new element and append it to this key's chain. */",
          "new_line_content": "      uint32_t empty_bucket = empty_strbucket(t);",
          "content_same": false
        },
        {
          "line": 157,
          "old_api": null,
          "new_api": "strent",
          "old_text": null,
          "new_text": "strent(t, table_e->next)",
          "old_line_content": "      while (table_e->next != UPB_END_OF_CHAIN)",
          "new_line_content": "        table_e = strent(t, table_e->next);",
          "content_same": false
        },
        {
          "line": 159,
          "old_api": null,
          "new_api": "strent",
          "old_text": null,
          "new_text": "strent(t, empty_bucket)",
          "old_line_content": "      table_e->next = empty_bucket;",
          "new_line_content": "      table_e = strent(t, empty_bucket);",
          "content_same": false
        },
        {
          "line": 163,
          "old_api": null,
          "new_api": "empty_strbucket",
          "old_text": null,
          "new_text": "empty_strbucket(t)",
          "old_line_content": "       * slot and put our element in its main position. */",
          "new_line_content": "      uint32_t empty_bucket = empty_strbucket(t);",
          "content_same": false
        },
        {
          "line": 39,
          "old_api": null,
          "new_api": "upb_table_init",
          "old_text": null,
          "new_text": "upb_table_init(&t->t, size, entsize)",
          "old_line_content": "{",
          "new_line_content": "  upb_table_init(&t->t, size, entsize);",
          "content_same": false
        },
        {
          "line": 168,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(evictee_e->key.byte_len != 0)",
          "old_line_content": "      while(1) {",
          "new_line_content": "        assert(evictee_e->key.byte_len != 0);",
          "content_same": false
        },
        {
          "line": 44,
          "old_api": null,
          "new_api": "upb_table_init",
          "old_text": null,
          "new_text": "upb_table_init(&t->t, size, entsize)",
          "old_line_content": "{",
          "new_line_content": "  upb_table_init(&t->t, size, entsize);",
          "content_same": false
        },
        {
          "line": 174,
          "old_api": null,
          "new_api": "strent",
          "old_text": null,
          "new_text": "strent(t, evictee_e->next)",
          "old_line_content": "        }",
          "new_line_content": "        evictee_e = strent(t, evictee_e->next);",
          "content_same": false
        },
        {
          "line": 47,
          "old_api": null,
          "new_api": "free",
          "old_text": null,
          "new_text": "free(t->entries)",
          "old_line_content": "",
          "new_line_content": "void upb_table_free(struct upb_table *t) { free(t->entries); }",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(table_e, e, t->t.entry_size)",
          "old_line_content": "  }",
          "new_line_content": "  memcpy(table_e, e, t->t.entry_size);",
          "content_same": false
        },
        {
          "line": 53,
          "old_api": null,
          "new_api": "MurmurHash2",
          "old_text": null,
          "new_text": "MurmurHash2(key->ptr, key->byte_len, 0)",
          "old_line_content": "{",
          "new_line_content": "  uint32_t hash = MurmurHash2(key->ptr, key->byte_len, 0);",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": null,
          "new_api": "upb_strtable_lookup",
          "old_text": null,
          "new_text": "upb_strtable_lookup(t, &e->key)",
          "old_line_content": "  table_e->next = UPB_END_OF_CHAIN;",
          "new_line_content": "  assert(upb_strtable_lookup(t, &e->key) == table_e);",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": null,
          "new_api": "upb_strtable_size",
          "old_text": null,
          "new_text": "upb_strtable_size(t)",
          "old_line_content": "{",
          "new_line_content": "  if((double)++t->t.count / upb_strtable_size(t) > MAX_LOAD) {",
          "content_same": false
        },
        {
          "line": 59,
          "old_api": null,
          "new_api": "strtable_bucket",
          "old_text": null,
          "new_text": "strtable_bucket(t, key)",
          "old_line_content": "{",
          "new_line_content": "  uint32_t bucket = strtable_bucket(t, key);",
          "content_same": false
        },
        {
          "line": 189,
          "old_api": null,
          "new_api": "upb_strtable_size",
          "old_text": null,
          "new_text": "upb_strtable_size(t)",
          "old_line_content": "    struct upb_strtable new_table;",
          "new_line_content": "    upb_strtable_init(&new_table, upb_strtable_size(t)*2, t->t.entry_size);",
          "content_same": false
        },
        {
          "line": 62,
          "old_api": null,
          "new_api": "strent",
          "old_text": null,
          "new_text": "strent(t, bucket)",
          "old_line_content": "  do {",
          "new_line_content": "    e = strent(t, bucket);",
          "content_same": false
        },
        {
          "line": 191,
          "old_api": null,
          "new_api": "upb_strtable_next",
          "old_text": null,
          "new_text": "upb_strtable_next(t, old_e)",
          "old_line_content": "    struct upb_strtable_entry *old_e;",
          "new_line_content": "    for(old_e = upb_strtable_begin(t); old_e; old_e = upb_strtable_next(t, old_e))",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": null,
          "new_api": "MIX",
          "old_text": null,
          "new_text": "MIX(h,k,m)",
          "old_line_content": "",
          "new_line_content": "      MIX(h,k,m);",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": null,
          "new_api": "strinsert",
          "old_text": null,
          "new_text": "strinsert(t, e)",
          "old_line_content": "  }",
          "new_line_content": "  strinsert(t, e);",
          "content_same": false
        },
        {
          "line": 71,
          "old_api": null,
          "new_api": "upb_inttable_size",
          "old_text": null,
          "new_text": "upb_inttable_size(table)",
          "old_line_content": "  /* TODO: does it matter that this is biased towards the front of the table? */",
          "new_line_content": "  for(uint32_t i = 1; i <= upb_inttable_size(table); i++) {",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": null,
          "new_api": "intent",
          "old_text": null,
          "new_text": "intent(t, 0)",
          "old_line_content": "void *upb_inttable_begin(struct upb_inttable *t) {",
          "new_line_content": "  return upb_inttable_next(t, intent(t, 0));",
          "content_same": false
        },
        {
          "line": 75,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(false)",
          "old_line_content": "  }",
          "new_line_content": "  assert(false);",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": null,
          "new_api": "upb_inttable_size",
          "old_text": null,
          "new_text": "upb_inttable_size(t)",
          "old_line_content": "void *upb_inttable_next(struct upb_inttable *t, struct upb_inttable_entry *cur) {",
          "new_line_content": "  struct upb_inttable_entry *end = intent(t, upb_inttable_size(t)+1);",
          "content_same": false
        },
        {
          "line": 84,
          "old_api": null,
          "new_api": "upb_inttable_lookup",
          "old_text": null,
          "new_text": "upb_inttable_lookup(t, e->key, t->t.entry_size)",
          "old_line_content": "{",
          "new_line_content": "  assert(upb_inttable_lookup(t, e->key, t->t.entry_size) == NULL);",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": null,
          "new_api": "strent",
          "old_text": null,
          "new_text": "strent(t, 0)",
          "old_line_content": "void *upb_strtable_begin(struct upb_strtable *t) {",
          "new_line_content": "  return upb_strtable_next(t, strent(t, 0));",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": null,
          "new_api": "MIX",
          "old_text": null,
          "new_text": "MIX(h,k,m)",
          "old_line_content": "      uint32_t k = (t >> sr) | (d << sl);",
          "new_line_content": "      MIX(h,k,m);",
          "content_same": false
        },
        {
          "line": 88,
          "old_api": null,
          "new_api": "upb_inttable_bucket",
          "old_text": null,
          "new_text": "upb_inttable_bucket(t, table_e->key)",
          "old_line_content": "  if(table_e->key != EMPTYENT) {  /* Collision. */",
          "new_line_content": "    if(bucket == upb_inttable_bucket(t, table_e->key)) {",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": null,
          "new_api": "upb_strtable_size",
          "old_text": null,
          "new_text": "upb_strtable_size(t)",
          "old_line_content": "void *upb_strtable_next(struct upb_strtable *t, struct upb_strtable_entry *cur) {",
          "new_line_content": "  struct upb_strtable_entry *end = strent(t, upb_strtable_size(t)+1);",
          "content_same": false
        },
        {
          "line": 91,
          "old_api": null,
          "new_api": "empty_intbucket",
          "old_text": null,
          "new_text": "empty_intbucket(t)",
          "old_line_content": "       * place our new element and append it to this key's chain. */",
          "new_line_content": "      uint32_t empty_bucket = empty_intbucket(t);",
          "content_same": false
        },
        {
          "line": 93,
          "old_api": null,
          "new_api": "intent",
          "old_text": null,
          "new_text": "intent(t, table_e->next)",
          "old_line_content": "      while (table_e->next != UPB_END_OF_CHAIN)",
          "new_line_content": "        table_e = intent(t, table_e->next);",
          "content_same": false
        },
        {
          "line": 95,
          "old_api": null,
          "new_api": "intent",
          "old_text": null,
          "new_text": "intent(t, empty_bucket)",
          "old_line_content": "      table_e->next = empty_bucket;",
          "new_line_content": "      table_e = intent(t, empty_bucket);",
          "content_same": false
        },
        {
          "line": 99,
          "old_api": null,
          "new_api": "empty_intbucket",
          "old_text": null,
          "new_text": "empty_intbucket(t)",
          "old_line_content": "       * slot and put our element in its main position. */",
          "new_line_content": "      uint32_t empty_bucket = empty_intbucket(t);",
          "content_same": false
        },
        {
          "line": 104,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(evictee_e->key != UPB_EMPTY_ENTRY)",
          "old_line_content": "      while(1) {",
          "new_line_content": "        assert(evictee_e->key != UPB_EMPTY_ENTRY);",
          "content_same": false
        },
        {
          "line": 114,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(table_e, e, t->t.entry_size)",
          "old_line_content": "  }",
          "new_line_content": "  memcpy(table_e, e, t->t.entry_size);",
          "content_same": false
        },
        {
          "line": 116,
          "old_api": null,
          "new_api": "upb_inttable_lookup",
          "old_text": null,
          "new_text": "upb_inttable_lookup(t, e->key, t->t.entry_size)",
          "old_line_content": "  table_e->next = UPB_END_OF_CHAIN;",
          "new_line_content": "  assert(upb_inttable_lookup(t, e->key, t->t.entry_size) == table_e);",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": null,
          "new_api": "MIX",
          "old_text": null,
          "new_text": "MIX(h,k,m)",
          "old_line_content": "",
          "new_line_content": "      MIX(h,k,m);",
          "content_same": false
        },
        {
          "line": 121,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(e->key != 0)",
          "old_line_content": "{",
          "new_line_content": "  assert(e->key != 0);",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": null,
          "new_api": "upb_inttable_size",
          "old_text": null,
          "new_text": "upb_inttable_size(t)",
          "old_line_content": "    struct upb_inttable new_table;",
          "new_line_content": "    upb_inttable_init(&new_table, upb_inttable_size(t)*2, t->t.entry_size);",
          "content_same": false
        },
        {
          "line": 127,
          "old_api": null,
          "new_api": "upb_inttable_next",
          "old_text": null,
          "new_text": "upb_inttable_next(t, old_e)",
          "old_line_content": "    struct upb_inttable_entry *old_e;",
          "new_line_content": "    for(old_e = upb_inttable_begin(t); old_e; old_e = upb_inttable_next(t, old_e))",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 130,
          "old_api": "upb_inttable_free",
          "new_api": null,
          "old_text": "upb_inttable_free(t)",
          "new_text": null,
          "old_line_content": "    upb_inttable_free(t);",
          "new_line_content": "    *t = new_table;",
          "content_same": false
        },
        {
          "line": 133,
          "old_api": "intinsert",
          "new_api": null,
          "old_text": "intinsert(t, e)",
          "new_text": null,
          "old_line_content": "  intinsert(t, e);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 140,
          "old_api": "strent",
          "new_api": null,
          "old_text": "strent(table, i)",
          "new_text": null,
          "old_line_content": "    struct upb_strtable_entry *e = strent(table, i);",
          "new_line_content": "    if(e->key.byte_len == 0) return i;",
          "content_same": false
        },
        {
          "line": 143,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(false)",
          "new_text": null,
          "old_line_content": "  assert(false);",
          "new_line_content": "  return 0;",
          "content_same": false
        },
        {
          "line": 151,
          "old_api": "strent",
          "new_api": null,
          "old_text": "strent(t, bucket)",
          "new_text": null,
          "old_line_content": "  struct upb_strtable_entry *table_e = strent(t, bucket);",
          "new_line_content": "  if(table_e->key.byte_len != 0) {  /* Collision. */",
          "content_same": false
        },
        {
          "line": 153,
          "old_api": "strtable_bucket",
          "new_api": null,
          "old_text": "strtable_bucket(t, &table_e->key)",
          "new_text": null,
          "old_line_content": "    if(bucket == strtable_bucket(t, &table_e->key)) {",
          "new_line_content": "      /* Existing element is in its main posisiton.  Find an empty slot to",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": "empty_strbucket",
          "new_api": null,
          "old_text": "empty_strbucket(t)",
          "new_text": null,
          "old_line_content": "      uint32_t empty_bucket = empty_strbucket(t);",
          "new_line_content": "      while (table_e->next != UPB_END_OF_CHAIN)",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": "strent",
          "new_api": null,
          "old_text": "strent(t, table_e->next)",
          "new_text": null,
          "old_line_content": "        table_e = strent(t, table_e->next);",
          "new_line_content": "      table_e->next = empty_bucket;",
          "content_same": false
        },
        {
          "line": 160,
          "old_api": "strent",
          "new_api": null,
          "old_text": "strent(t, empty_bucket)",
          "new_text": null,
          "old_line_content": "      table_e = strent(t, empty_bucket);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 35,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(t->entries, 0, bytes)",
          "new_text": null,
          "old_line_content": "  memset(t->entries, 0, bytes);  /* Both tables consider 0's an empty entry. */",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 167,
          "old_api": "strent",
          "new_api": null,
          "old_text": "strent(t, evictee_bucket)",
          "new_text": null,
          "old_line_content": "      struct upb_strtable_entry *evictee_e = strent(t, evictee_bucket);",
          "new_line_content": "      while(1) {",
          "content_same": false
        },
        {
          "line": 40,
          "old_api": "upb_table_init",
          "new_api": null,
          "old_text": "upb_table_init(&t->t, size, entsize)",
          "new_text": null,
          "old_line_content": "  upb_table_init(&t->t, size, entsize);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 170,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(evictee_e->next != UPB_END_OF_CHAIN)",
          "new_text": null,
          "old_line_content": "        assert(evictee_e->next != UPB_END_OF_CHAIN);",
          "new_line_content": "        if(evictee_e->next == bucket) {",
          "content_same": false
        },
        {
          "line": 45,
          "old_api": "upb_table_init",
          "new_api": null,
          "old_text": "upb_table_init(&t->t, size, entsize)",
          "new_text": null,
          "old_line_content": "  upb_table_init(&t->t, size, entsize);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 175,
          "old_api": "strent",
          "new_api": null,
          "old_text": "strent(t, evictee_e->next)",
          "new_text": null,
          "old_line_content": "        evictee_e = strent(t, evictee_e->next);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 50,
          "old_api": "upb_table_free",
          "new_api": null,
          "old_text": "upb_table_free(&t->t)",
          "new_text": null,
          "old_line_content": "void upb_strtable_free(struct upb_strtable *t) { upb_table_free(&t->t); }",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 180,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(table_e, e, t->t.entry_size)",
          "new_text": null,
          "old_line_content": "  memcpy(table_e, e, t->t.entry_size);",
          "new_line_content": "  table_e->next = UPB_END_OF_CHAIN;",
          "content_same": false
        },
        {
          "line": 182,
          "old_api": "upb_strtable_lookup",
          "new_api": null,
          "old_text": "upb_strtable_lookup(t, &e->key)",
          "new_text": null,
          "old_line_content": "  assert(upb_strtable_lookup(t, &e->key) == table_e);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 55,
          "old_api": "upb_strtable_size",
          "new_api": null,
          "old_text": "upb_strtable_size(t)",
          "new_text": null,
          "old_line_content": "  return (hash & (upb_strtable_size(t)-1)) + 1;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 187,
          "old_api": "upb_strtable_size",
          "new_api": null,
          "old_text": "upb_strtable_size(t)",
          "new_text": null,
          "old_line_content": "  if((double)++t->t.count / upb_strtable_size(t) > MAX_LOAD) {",
          "new_line_content": "    /* Need to resize.  New table of double the size, add old elements to it. */",
          "content_same": false
        },
        {
          "line": 60,
          "old_api": "strtable_bucket",
          "new_api": null,
          "old_text": "strtable_bucket(t, key)",
          "new_text": null,
          "old_line_content": "  uint32_t bucket = strtable_bucket(t, key);",
          "new_line_content": "  struct upb_strtable_entry *e;",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": "upb_strtable_size",
          "new_api": null,
          "old_text": "upb_strtable_size(t)",
          "new_text": null,
          "old_line_content": "    upb_strtable_init(&new_table, upb_strtable_size(t)*2, t->t.entry_size);",
          "new_line_content": "    struct upb_strtable_entry *old_e;",
          "content_same": false
        },
        {
          "line": 64,
          "old_api": "upb_streql",
          "new_api": null,
          "old_text": "upb_streql(&e->key, key)",
          "new_text": null,
          "old_line_content": "    if(upb_streql(&e->key, key)) return e;",
          "new_line_content": "  } while((bucket = e->next) != UPB_END_OF_CHAIN);",
          "content_same": false
        },
        {
          "line": 194,
          "old_api": "upb_strtable_free",
          "new_api": null,
          "old_text": "upb_strtable_free(t)",
          "new_text": null,
          "old_line_content": "    upb_strtable_free(t);",
          "new_line_content": "    *t = new_table;",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": "MIX",
          "new_api": null,
          "old_text": "MIX(h,k,m)",
          "new_text": null,
          "old_line_content": "      MIX(h,k,m);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": "strinsert",
          "new_api": null,
          "old_text": "strinsert(t, e)",
          "new_text": null,
          "old_line_content": "  strinsert(t, e);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 73,
          "old_api": "intent",
          "new_api": null,
          "old_text": "intent(table, i)",
          "new_text": null,
          "old_line_content": "    struct upb_inttable_entry *e = intent(table, i);",
          "new_line_content": "    if(e->key == EMPTYENT) return i;",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": "intent",
          "new_api": null,
          "old_text": "intent(t, 0)",
          "new_text": null,
          "old_line_content": "  return upb_inttable_next(t, intent(t, 0));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 76,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(false)",
          "new_text": null,
          "old_line_content": "  assert(false);",
          "new_line_content": "  return 0;",
          "content_same": false
        },
        {
          "line": 205,
          "old_api": "upb_inttable_size",
          "new_api": null,
          "old_text": "upb_inttable_size(t)",
          "new_text": null,
          "old_line_content": "  struct upb_inttable_entry *end = intent(t, upb_inttable_size(t)+1);",
          "new_line_content": "  do {",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": "strent",
          "new_api": null,
          "old_text": "strent(t, 0)",
          "new_text": null,
          "old_line_content": "  return upb_strtable_next(t, strent(t, 0));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 87,
          "old_api": "intent",
          "new_api": null,
          "old_text": "intent(t, bucket)",
          "new_text": null,
          "old_line_content": "  struct upb_inttable_entry *table_e = intent(t, bucket);",
          "new_line_content": "  if(table_e->key != EMPTYENT) {  /* Collision. */",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": "MIX",
          "new_api": null,
          "old_text": "MIX(h,k,m)",
          "new_text": null,
          "old_line_content": "      MIX(h,k,m);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 89,
          "old_api": "upb_inttable_bucket",
          "new_api": null,
          "old_text": "upb_inttable_bucket(t, table_e->key)",
          "new_text": null,
          "old_line_content": "    if(bucket == upb_inttable_bucket(t, table_e->key)) {",
          "new_line_content": "      /* Existing element is in its main posisiton.  Find an empty slot to",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": "upb_strtable_size",
          "new_api": null,
          "old_text": "upb_strtable_size(t)",
          "new_text": null,
          "old_line_content": "  struct upb_strtable_entry *end = strent(t, upb_strtable_size(t)+1);",
          "new_line_content": "  do {",
          "content_same": false
        },
        {
          "line": 92,
          "old_api": "empty_intbucket",
          "new_api": null,
          "old_text": "empty_intbucket(t)",
          "new_text": null,
          "old_line_content": "      uint32_t empty_bucket = empty_intbucket(t);",
          "new_line_content": "      while (table_e->next != UPB_END_OF_CHAIN)",
          "content_same": false
        },
        {
          "line": 94,
          "old_api": "intent",
          "new_api": null,
          "old_text": "intent(t, table_e->next)",
          "new_text": null,
          "old_line_content": "        table_e = intent(t, table_e->next);",
          "new_line_content": "      table_e->next = empty_bucket;",
          "content_same": false
        },
        {
          "line": 96,
          "old_api": "intent",
          "new_api": null,
          "old_text": "intent(t, empty_bucket)",
          "new_text": null,
          "old_line_content": "      table_e = intent(t, empty_bucket);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 103,
          "old_api": "intent",
          "new_api": null,
          "old_text": "intent(t, evictee_bucket)",
          "new_text": null,
          "old_line_content": "      struct upb_inttable_entry *evictee_e = intent(t, evictee_bucket);",
          "new_line_content": "      while(1) {",
          "content_same": false
        },
        {
          "line": 106,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(evictee_e->next != UPB_END_OF_CHAIN)",
          "new_text": null,
          "old_line_content": "        assert(evictee_e->next != UPB_END_OF_CHAIN);",
          "new_line_content": "        if(evictee_e->next == bucket) {",
          "content_same": false
        },
        {
          "line": 115,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(table_e, e, t->t.entry_size)",
          "new_text": null,
          "old_line_content": "  memcpy(table_e, e, t->t.entry_size);",
          "new_line_content": "  table_e->next = UPB_END_OF_CHAIN;",
          "content_same": false
        },
        {
          "line": 117,
          "old_api": "upb_inttable_lookup",
          "new_api": null,
          "old_text": "upb_inttable_lookup(t, e->key, t->t.entry_size)",
          "new_text": null,
          "old_line_content": "  assert(upb_inttable_lookup(t, e->key, t->t.entry_size) == table_e);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": "MIX",
          "new_api": null,
          "old_text": "MIX(h,k,m)",
          "new_text": null,
          "old_line_content": "      MIX(h,k,m);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 123,
          "old_api": "upb_inttable_size",
          "new_api": null,
          "old_text": "upb_inttable_size(t)",
          "new_text": null,
          "old_line_content": "  if((double)++t->t.count / upb_inttable_size(t) > MAX_LOAD) {",
          "new_line_content": "    /* Need to resize.  New table of double the size, add old elements to it. */",
          "content_same": false
        },
        {
          "line": 126,
          "old_api": "upb_inttable_size",
          "new_api": null,
          "old_text": "upb_inttable_size(t)",
          "new_text": null,
          "old_line_content": "    upb_inttable_init(&new_table, upb_inttable_size(t)*2, t->t.entry_size);",
          "new_line_content": "    struct upb_inttable_entry *old_e;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 21,
      "total_additions": 44,
      "total_deletions": 45,
      "total_api_changes": 110
    },
    "non_api_changes": {
      "has_non_api_changes": false,
      "evidence": {
        "total_diff_lines": 1,
        "api_related_lines": 110,
        "non_api_lines": 0,
        "non_api_line_numbers": []
      }
    },
    "api_calls_before": 87,
    "api_calls_after": 86,
    "diff_info": {
      "added_lines": 0,
      "removed_lines": 1,
      "total_diff_lines": 13
    }
  }
}