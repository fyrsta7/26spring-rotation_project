{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/esp-idf/modified_file/b4c4f8514b24c0270e8419b9b4d1da2b5a77f32b",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/esp-idf/modified_file/b4c4f8514b24c0270e8419b9b4d1da2b5a77f32b/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/esp-idf/modified_file/b4c4f8514b24c0270e8419b9b4d1da2b5a77f32b/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/esp-idf/modified_file/b4c4f8514b24c0270e8419b9b4d1da2b5a77f32b/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 217,
          "old_api": "isVariableLengthType",
          "new_api": "Item",
          "old_text": "isVariableLengthType(datatype)",
          "new_text": "Item(nsIndex, datatype, span, key, chunkIdx)",
          "old_line_content": "    if (!isVariableLengthType(datatype)) {",
          "new_line_content": "    item = Item(nsIndex, datatype, span, key, chunkIdx);",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": "memcpy",
          "new_api": "insert",
          "old_text": "memcpy(item.data, data, dataSize)",
          "new_text": "mHashList.insert(item, mNextFreeEntry)",
          "old_line_content": "        memcpy(item.data, data, dataSize);",
          "new_line_content": "    mHashList.insert(item, mNextFreeEntry);",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": "writeEntry",
          "new_api": "isVariableLengthType",
          "old_text": "writeEntry(item)",
          "new_text": "isVariableLengthType(datatype)",
          "old_line_content": "        err = writeEntry(item);",
          "new_line_content": "    if (!isVariableLengthType(datatype)) {",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": "calculateCrc32",
          "new_api": "Item::calculateCrc32(src, dataSize)",
          "old_text": "item.calculateCrc32()",
          "new_text": "Item::calculateCrc32(src, dataSize)",
          "old_line_content": "        item.crc32 = item.calculateCrc32();",
          "new_line_content": "        item.varLength.dataCrc32 = Item::calculateCrc32(src, dataSize);",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": "get",
          "new_api": "erase",
          "old_text": "mEntryTable.get(i)",
          "new_text": "mHashList.erase(index)",
          "old_line_content": "                if (mEntryTable.get(i) == EntryState::WRITTEN) {",
          "new_line_content": "            mHashList.erase(index);",
          "content_same": false
        },
        {
          "line": 437,
          "old_api": "readEntry",
          "new_api": "assert",
          "old_text": "readEntry(i, entry)",
          "new_text": "assert(end <= ENTRY_COUNT)",
          "old_line_content": "            readEntry(i, entry);",
          "new_line_content": "        assert(end <= ENTRY_COUNT);",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": "find",
          "new_api": "insert",
          "old_text": "mHashList.find(0, item)",
          "new_text": "mHashList.insert(item, i)",
          "old_line_content": "            size_t duplicateIndex = mHashList.find(0, item);",
          "new_line_content": "            mHashList.insert(item, i);",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": "eraseEntryAndSpan",
          "new_api": "isVariableLengthType",
          "old_text": "eraseEntryAndSpan(i)",
          "new_text": "isVariableLengthType(item.datatype)",
          "old_line_content": "                        eraseEntryAndSpan(i);",
          "new_line_content": "            if (isVariableLengthType(item.datatype)) {",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "data",
          "new_api": "assert",
          "old_text": "mEntryTable.data()",
          "new_text": "assert(index < ENTRY_COUNT)",
          "old_line_content": "    uint32_t word = mEntryTable.data()[wordToWrite];",
          "new_line_content": "    assert(index < ENTRY_COUNT);",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": "static_cast<uint32_t>(wordToWrite)",
          "new_api": "set",
          "old_text": "static_cast<uint32_t>(wordToWrite)",
          "new_text": "mEntryTable.set(index, state)",
          "old_line_content": "    auto rc = spi_flash_write(mBaseAddress + ENTRY_TABLE_OFFSET + static_cast<uint32_t>(wordToWrite) * 4,",
          "new_line_content": "    mEntryTable.set(index, state);",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": "static_cast<ptrdiff_t>(begin)",
          "new_api": "assert",
          "old_text": "static_cast<ptrdiff_t>(begin)",
          "new_text": "assert(end <= ENTRY_COUNT)",
          "old_line_content": "    for (ptrdiff_t i = end - 1; i >= static_cast<ptrdiff_t>(begin); --i) {",
          "new_line_content": "    assert(end <= ENTRY_COUNT);",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": "set",
          "new_api": "assert",
          "old_text": "mEntryTable.set(i, state)",
          "new_text": "assert(end > begin)",
          "old_line_content": "        mEntryTable.set(i, state);",
          "new_line_content": "    assert(end > begin);",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": "getWordIndex",
          "new_api": "static_cast<ptrdiff_t>(begin)",
          "old_text": "mEntryTable.getWordIndex(i - 1)",
          "new_text": "static_cast<ptrdiff_t>(begin)",
          "old_line_content": "            nextWordIndex = mEntryTable.getWordIndex(i - 1);",
          "new_line_content": "        if (i == static_cast<ptrdiff_t>(begin)) {",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": "data",
          "new_api": "getWordIndex",
          "old_text": "mEntryTable.data()",
          "new_text": "mEntryTable.getWordIndex(i - 1)",
          "old_line_content": "            uint32_t word = mEntryTable.data()[wordIndex];",
          "new_line_content": "            nextWordIndex = mEntryTable.getWordIndex(i - 1);",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": "static_cast<int>(i)",
          "new_api": "static_cast<int>(mNextFreeEntry)",
          "old_text": "static_cast<int>(i)",
          "new_text": "static_cast<int>(mNextFreeEntry)",
          "old_line_content": "        printf(\"%3d: \", static_cast<int>(i));",
          "new_line_content": "    printf(\"state=%x (%s) addr=%x seq=%d\\nfirstUsed=%d nextFree=%d used=%d erased=%d\\n\", (uint32_t) mState, pageStateToName(mState), mBaseAddress, mSeqNumber, static_cast<int>(mFirstUsedEntry), static_cast<int>(mNextFreeEntry), mUsedEntryCount, mErasedEntryCount);",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "printf",
          "new_api": "static_cast<int>(i)",
          "old_text": "printf(\"E\\n\")",
          "new_text": "static_cast<int>(i)",
          "old_line_content": "            printf(\"E\\n\");",
          "new_line_content": "        printf(\"%3d: \", static_cast<int>(i));",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": "readEntry",
          "new_api": "printf",
          "old_text": "readEntry(i, item)",
          "new_text": "printf(\"X\\n\")",
          "old_line_content": "            readEntry(i, item);",
          "new_line_content": "            printf(\"X\\n\");",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 530,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mEntryTable.get(i)",
          "old_line_content": "            }",
          "new_line_content": "            if (mEntryTable.get(i) == EntryState::ERASED) {",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": null,
          "new_api": "readEntry",
          "old_text": null,
          "new_text": "readEntry(i, item)",
          "old_line_content": "                return err;",
          "new_line_content": "            auto err = readEntry(i, item);",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": null,
          "new_api": "calculateCrc32",
          "old_text": null,
          "new_text": "item.calculateCrc32()",
          "old_line_content": "                    mState = PageState::INVALID;",
          "new_line_content": "            if (item.crc32 != item.calculateCrc32()) {",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": null,
          "new_api": "eraseEntryAndSpan",
          "old_text": null,
          "new_text": "eraseEntryAndSpan(i)",
          "old_line_content": "                    return err;",
          "new_line_content": "                err = eraseEntryAndSpan(i);",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mHashList.find(0, item)",
          "old_line_content": "                span = item.span;",
          "new_line_content": "            size_t duplicateIndex = mHashList.find(0, item);",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": null,
          "new_api": "isVariableLengthType",
          "old_text": null,
          "new_text": "isVariableLengthType(item.datatype)",
          "old_line_content": "                for (size_t j = i; j < i + span; ++j) {",
          "new_line_content": "            if (isVariableLengthType(item.datatype)) {",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mEntryTable.get(j)",
          "old_line_content": "                        break;",
          "new_line_content": "                    if (mEntryTable.get(j) != EntryState::WRITTEN) {",
          "content_same": false
        },
        {
          "line": 54,
          "old_api": null,
          "new_api": "spi_flash_read",
          "old_text": null,
          "new_text": "spi_flash_read(mBaseAddress + i, block, 4 * BLOCK_SIZE)",
          "old_line_content": "            if (rc != ESP_OK) {",
          "new_line_content": "            rc = spi_flash_read(mBaseAddress + i, block, 4 * BLOCK_SIZE);",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": null,
          "new_api": "eraseEntryAndSpan",
          "old_text": null,
          "new_text": "eraseEntryAndSpan(i)",
          "old_line_content": "            }",
          "new_line_content": "                    eraseEntryAndSpan(i);",
          "content_same": false
        },
        {
          "line": 60,
          "old_api": null,
          "new_api": "std::any_of(block, block + BLOCK_SIZE, [](uint32_t val) -> bool { return val != 0xffffffff; })",
          "old_text": null,
          "new_text": "std::any_of(block, block + BLOCK_SIZE, [](uint32_t val) -> bool { return val != 0xffffffff; })",
          "old_line_content": "                mState = PageState::CORRUPT;",
          "new_line_content": "            if (std::any_of(block, block + BLOCK_SIZE, [](uint32_t val) -> bool { return val != 0xffffffff; })) {",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": null,
          "new_api": "eraseEntryAndSpan",
          "old_text": null,
          "new_text": "eraseEntryAndSpan(duplicateIndex)",
          "old_line_content": "",
          "new_line_content": "                eraseEntryAndSpan(duplicateIndex);",
          "content_same": false
        },
        {
          "line": 67,
          "old_api": null,
          "new_api": "calculateCrc32",
          "old_text": null,
          "new_text": "header.calculateCrc32()",
          "old_line_content": "        mState = header.mState;",
          "new_line_content": "    } else if (header.mCrc32 != header.calculateCrc32()) {",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": null,
          "new_api": "findItem",
          "old_text": null,
          "new_text": "findItem(item.nsIndex, item.datatype, item.key, findItemIndex, dupItem)",
          "old_line_content": "                    if (err != ESP_OK) {",
          "new_line_content": "            if (findItem(item.nsIndex, item.datatype, item.key, findItemIndex, dupItem) == ESP_OK) {",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": null,
          "new_api": "eraseEntryAndSpan",
          "old_text": null,
          "new_text": "eraseEntryAndSpan(findItemIndex)",
          "old_line_content": "                        return err;",
          "new_line_content": "                    auto err = eraseEntryAndSpan(findItemIndex);",
          "content_same": false
        },
        {
          "line": 86,
          "old_api": null,
          "new_api": "mLoadEntryTable",
          "old_text": null,
          "new_text": "mLoadEntryTable()",
          "old_line_content": "    default:",
          "new_line_content": "        mLoadEntryTable();",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mEntryTable.get(i)",
          "old_line_content": "",
          "new_line_content": "            if (mEntryTable.get(i) != EntryState::WRITTEN) {",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": null,
          "new_api": "readEntry",
          "old_text": null,
          "new_text": "readEntry(i, item)",
          "old_line_content": "                return err;",
          "new_line_content": "            auto err = readEntry(i, item);",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": null,
          "new_api": "calculateCrc32",
          "old_text": null,
          "new_text": "item.calculateCrc32()",
          "old_line_content": "                    mState = PageState::INVALID;",
          "new_line_content": "            if (item.crc32 != item.calculateCrc32()) {",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": null,
          "new_api": "eraseEntryAndSpan",
          "old_text": null,
          "new_text": "eraseEntryAndSpan(i)",
          "old_line_content": "                    return err;",
          "new_line_content": "                err = eraseEntryAndSpan(i);",
          "content_same": false
        },
        {
          "line": 101,
          "old_api": null,
          "new_api": "getEntryAddress",
          "old_text": null,
          "new_text": "getEntryAddress(mNextFreeEntry)",
          "old_line_content": "        mState = PageState::INVALID;",
          "new_line_content": "    err = nvs_flash_write(getEntryAddress(mNextFreeEntry), &item, sizeof(item));",
          "content_same": false
        },
        {
          "line": 108,
          "old_api": null,
          "new_api": "alterEntryState",
          "old_text": null,
          "new_text": "alterEntryState(mNextFreeEntry, EntryState::WRITTEN)",
          "old_line_content": "    }",
          "new_line_content": "    err = alterEntryState(mNextFreeEntry, EntryState::WRITTEN);",
          "content_same": false
        },
        {
          "line": 620,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(item.span > 0)",
          "old_line_content": "",
          "new_line_content": "            assert(item.span > 0);",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "mHashList.insert(item, i)",
          "old_line_content": "",
          "new_line_content": "            mHashList.insert(item, i);",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mEntryTable.get(j)",
          "old_line_content": "                    }",
          "new_line_content": "                    if (mEntryTable.get(j) != EntryState::WRITTEN) {",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": null,
          "new_api": "eraseEntryAndSpan",
          "old_text": null,
          "new_text": "eraseEntryAndSpan(i)",
          "old_line_content": "                }",
          "new_line_content": "                        eraseEntryAndSpan(i);",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(size % ENTRY_SIZE == 0)",
          "old_line_content": "    const uint16_t count = size / ENTRY_SIZE;",
          "new_line_content": "    assert(size % ENTRY_SIZE == 0);",
          "content_same": false
        },
        {
          "line": 126,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(mNextFreeEntry != INVALID_ENTRY)",
          "old_line_content": "",
          "new_line_content": "    assert(mNextFreeEntry != INVALID_ENTRY);",
          "content_same": false
        },
        {
          "line": 127,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(mFirstUsedEntry != INVALID_ENTRY)",
          "old_line_content": "    const uint8_t* buf = data;",
          "new_line_content": "    assert(mFirstUsedEntry != INVALID_ENTRY);",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(mState == PageState::UNINITIALIZED)",
          "old_line_content": "    header.mState = mState;",
          "new_line_content": "    assert(mState == PageState::UNINITIALIZED);",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": null,
          "new_api": "calculateCrc32",
          "old_text": null,
          "new_text": "header.calculateCrc32()",
          "old_line_content": "    if (rc != ESP_OK) {",
          "new_line_content": "    header.mCrc32 = header.calculateCrc32();",
          "content_same": false
        },
        {
          "line": 141,
          "old_api": null,
          "new_api": "malloc",
          "old_text": null,
          "new_text": "malloc(size)",
          "old_line_content": "        }",
          "new_line_content": "        buf = (uint8_t*) malloc(size);",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": null,
          "new_api": "spi_flash_write",
          "old_text": null,
          "new_text": "spi_flash_write(mBaseAddress, &header, sizeof(header))",
          "old_line_content": "        return rc;",
          "new_line_content": "    auto rc = spi_flash_write(mBaseAddress, &header, sizeof(header));",
          "content_same": false
        },
        {
          "line": 145,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy((void*)buf, data, size)",
          "old_line_content": "",
          "new_line_content": "        memcpy((void*)buf, data, size);",
          "content_same": false
        },
        {
          "line": 149,
          "old_api": null,
          "new_api": "getEntryAddress",
          "old_text": null,
          "new_text": "getEntryAddress(mNextFreeEntry)",
          "old_line_content": "    if (buf != data) {",
          "new_line_content": "    auto rc = nvs_flash_write(getEntryAddress(mNextFreeEntry), buf, size);",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": null,
          "new_api": "byteSize",
          "old_text": null,
          "new_text": "mEntryTable.byteSize()",
          "old_line_content": "",
          "new_line_content": "    std::fill_n(mEntryTable.data(), mEntryTable.byteSize() / sizeof(uint32_t), 0xffffffff);",
          "content_same": false
        },
        {
          "line": 153,
          "old_api": null,
          "new_api": "free",
          "old_text": null,
          "new_text": "free((void*)buf)",
          "old_line_content": "    if (rc != ESP_OK) {",
          "new_line_content": "        free((void*)buf);",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": null,
          "new_api": "getWordIndex",
          "old_text": null,
          "new_text": "mEntryTable.getWordIndex(index)",
          "old_line_content": "            &word, sizeof(word));",
          "new_line_content": "    size_t wordToWrite = mEntryTable.getWordIndex(index);",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "mEntryTable.data()",
          "old_line_content": "    if (rc != ESP_OK) {",
          "new_line_content": "    uint32_t word = mEntryTable.data()[wordToWrite];",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": null,
          "new_api": "static_cast<uint32_t>(wordToWrite)",
          "old_text": null,
          "new_text": "static_cast<uint32_t>(wordToWrite)",
          "old_line_content": "        mState = PageState::INVALID;",
          "new_line_content": "    auto rc = spi_flash_write(mBaseAddress + ENTRY_TABLE_OFFSET + static_cast<uint32_t>(wordToWrite) * 4,",
          "content_same": false
        },
        {
          "line": 160,
          "old_api": null,
          "new_api": "alterEntryRangeState",
          "old_text": null,
          "new_text": "alterEntryRangeState(mNextFreeEntry, mNextFreeEntry + count, EntryState::WRITTEN)",
          "old_line_content": "    }",
          "new_line_content": "    auto err = alterEntryRangeState(mNextFreeEntry, mNextFreeEntry + count, EntryState::WRITTEN);",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "getWordIndex",
          "old_text": null,
          "new_text": "mEntryTable.getWordIndex(end - 1)",
          "old_line_content": "        size_t nextWordIndex;",
          "new_line_content": "    size_t wordIndex = mEntryTable.getWordIndex(end - 1);",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "mEntryTable.set(i, state)",
          "old_line_content": "            nextWordIndex = (size_t) -1;",
          "new_line_content": "        mEntryTable.set(i, state);",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": null,
          "new_api": "initialize",
          "old_text": null,
          "new_text": "initialize()",
          "old_line_content": "        }",
          "new_line_content": "        err = initialize();",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "mEntryTable.data()",
          "old_line_content": "            if (rc != ESP_OK) {",
          "new_line_content": "            uint32_t word = mEntryTable.data()[wordIndex];",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": null,
          "new_api": "static_cast<uint32_t>(wordIndex)",
          "old_text": null,
          "new_text": "static_cast<uint32_t>(wordIndex)",
          "old_line_content": "                return rc;",
          "new_line_content": "            auto rc = spi_flash_write(mBaseAddress + ENTRY_TABLE_OFFSET + static_cast<uint32_t>(wordIndex) * 4,",
          "content_same": false
        },
        {
          "line": 189,
          "old_api": null,
          "new_api": "strlen",
          "old_text": null,
          "new_text": "strlen(key)",
          "old_line_content": "    }",
          "new_line_content": "    const size_t keySize = strlen(key);",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": null,
          "new_api": "static_cast<uint32_t>(state)",
          "old_text": null,
          "new_text": "static_cast<uint32_t>(state)",
          "old_line_content": "        mState = PageState::INVALID;",
          "new_line_content": "    uint32_t state_val = static_cast<uint32_t>(state);",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": null,
          "new_api": "spi_flash_write",
          "old_text": null,
          "new_text": "spi_flash_write(mBaseAddress, &state_val, sizeof(state))",
          "old_line_content": "        return rc;",
          "new_line_content": "    auto rc = spi_flash_write(mBaseAddress, &state_val, sizeof(state));",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": null,
          "new_api": "isVariableLengthType",
          "old_text": null,
          "new_text": "isVariableLengthType(datatype)",
          "old_line_content": "        entriesCount += roundedSize / ENTRY_SIZE;",
          "new_line_content": "    if (isVariableLengthType(datatype)) {",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(totalSize == ENTRY_SIZE ||\n       isVariableLengthType(datatype))",
          "old_line_content": "    if (mNextFreeEntry == INVALID_ENTRY || mNextFreeEntry + entriesCount > ENTRY_COUNT) {",
          "new_line_content": "    assert(totalSize == ENTRY_SIZE ||",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": null,
          "new_api": "isVariableLengthType",
          "old_text": null,
          "new_text": "isVariableLengthType(datatype)",
          "old_line_content": "        // page will not fit this amount of data",
          "new_line_content": "       isVariableLengthType(datatype));",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": null,
          "new_api": "getEntryAddress",
          "old_text": null,
          "new_text": "getEntryAddress(index)",
          "old_line_content": "    }",
          "new_line_content": "    auto rc = nvs_flash_read(getEntryAddress(index), &dst, sizeof(dst));",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(item.data, data, dataSize)",
          "old_line_content": "        if (err != ESP_OK) {",
          "new_line_content": "        memcpy(item.data, data, dataSize);",
          "content_same": false
        },
        {
          "line": 222,
          "old_api": null,
          "new_api": "calculateCrc32",
          "old_text": null,
          "new_text": "item.calculateCrc32()",
          "old_line_content": "            return err;",
          "new_line_content": "        item.crc32 = item.calculateCrc32();",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": null,
          "new_api": "writeEntry",
          "old_text": null,
          "new_text": "writeEntry(item)",
          "old_line_content": "        }",
          "new_line_content": "        err = writeEntry(item);",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": null,
          "new_api": "reinterpret_cast<const uint8_t*>(data)",
          "old_text": null,
          "new_text": "reinterpret_cast<const uint8_t*>(data)",
          "old_line_content": "        item.varLength.reserved = 0xffff;",
          "new_line_content": "        const uint8_t* src = reinterpret_cast<const uint8_t*>(data);",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": null,
          "new_api": "calculateCrc32",
          "old_text": null,
          "new_text": "item.calculateCrc32()",
          "old_line_content": "            return err;",
          "new_line_content": "        item.crc32 = item.calculateCrc32();",
          "content_same": false
        },
        {
          "line": 233,
          "old_api": null,
          "new_api": "writeEntry",
          "old_text": null,
          "new_text": "writeEntry(item)",
          "old_line_content": "        }",
          "new_line_content": "        err = writeEntry(item);",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": null,
          "new_api": "Item",
          "old_text": null,
          "new_text": "Item(nsIndex, datatype, 0, key, chunkIdx)",
          "old_line_content": "        } else {",
          "new_line_content": "        size_t cachedIndex = mHashList.find(start, Item(nsIndex, datatype, 0, key, chunkIdx));",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": null,
          "new_api": "static_cast<const uint8_t*>(data)",
          "old_text": null,
          "new_text": "static_cast<const uint8_t*>(data)",
          "old_line_content": "            }",
          "new_line_content": "            err = writeEntryData(static_cast<const uint8_t*>(data), left);",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mEntryTable.get(i)",
          "old_line_content": "",
          "new_line_content": "        if (mEntryTable.get(i) != EntryState::WRITTEN) {",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": null,
          "new_api": "std::fill_n(item.rawData, ENTRY_SIZE, 0xff)",
          "old_text": null,
          "new_text": "std::fill_n(item.rawData, ENTRY_SIZE, 0xff)",
          "old_line_content": "            if (err != ESP_OK) {",
          "new_line_content": "            std::fill_n(item.rawData, ENTRY_SIZE, 0xff);",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": null,
          "new_api": "static_cast<const uint8_t*>(data)",
          "old_text": null,
          "new_text": "static_cast<const uint8_t*>(data)",
          "old_line_content": "                return err;",
          "new_line_content": "            memcpy(item.rawData, static_cast<const uint8_t*>(data) + left, tail);",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": null,
          "new_api": "writeEntry",
          "old_text": null,
          "new_text": "writeEntry(item)",
          "old_line_content": "            }",
          "new_line_content": "            err = writeEntry(item);",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": null,
          "new_api": "readEntry",
          "old_text": null,
          "new_text": "readEntry(i, item)",
          "old_line_content": "            return rc;",
          "new_line_content": "        auto rc = readEntry(i, item);",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": null,
          "new_api": "calculateCrc32",
          "old_text": null,
          "new_text": "item.calculateCrc32()",
          "old_line_content": "            if (rc != ESP_OK) {",
          "new_line_content": "        auto crc32 = item.calculateCrc32();",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": null,
          "new_api": "eraseEntryAndSpan",
          "old_text": null,
          "new_text": "eraseEntryAndSpan(i)",
          "old_line_content": "                return rc;",
          "new_line_content": "            rc = eraseEntryAndSpan(i);",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": null,
          "new_api": "isVariableLengthType",
          "old_text": null,
          "new_text": "isVariableLengthType(item.datatype)",
          "old_line_content": "",
          "new_line_content": "        if (isVariableLengthType(item.datatype)) {",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": null,
          "new_api": "findItem",
          "old_text": null,
          "new_text": "findItem(nsIndex, datatype, key, index, item, chunkIdx, chunkStart)",
          "old_line_content": "    }",
          "new_line_content": "    esp_err_t rc = findItem(nsIndex, datatype, key, index, item, chunkIdx, chunkStart);",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": null,
          "new_api": "isVariableLengthType",
          "old_text": null,
          "new_text": "isVariableLengthType(datatype)",
          "old_line_content": "        }",
          "new_line_content": "    if (!isVariableLengthType(datatype)) {",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": null,
          "new_api": "getAlignmentForType",
          "old_text": null,
          "new_text": "getAlignmentForType(datatype)",
          "old_line_content": "",
          "new_line_content": "        if (dataSize != getAlignmentForType(datatype)) {",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": null,
          "new_api": "strncmp",
          "old_text": null,
          "new_text": "strncmp(key, item.key, Item::MAX_KEY_LENGTH)",
          "old_line_content": "        /* For blob data, chunkIndex should match*/",
          "new_line_content": "        if (key != nullptr && strncmp(key, item.key, Item::MAX_KEY_LENGTH) != 0) {",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(data, item.data, dataSize)",
          "old_line_content": "",
          "new_line_content": "        memcpy(data, item.data, dataSize);",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": null,
          "new_api": "static_cast<size_t>(item.varLength.dataSize)",
          "old_text": null,
          "new_text": "static_cast<size_t>(item.varLength.dataSize)",
          "old_line_content": "",
          "new_line_content": "    if (dataSize < static_cast<size_t>(item.varLength.dataSize)) {",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": null,
          "new_api": "reinterpret_cast<uint8_t*>(data)",
          "old_text": null,
          "new_text": "reinterpret_cast<uint8_t*>(data)",
          "old_line_content": "        Item ditem;",
          "new_line_content": "    uint8_t* dst = reinterpret_cast<uint8_t*>(data);",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": null,
          "new_api": "readEntry",
          "old_text": null,
          "new_text": "readEntry(i, ditem)",
          "old_line_content": "        }",
          "new_line_content": "        rc = readEntry(i, ditem);",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(dst, ditem.rawData, willCopy)",
          "old_line_content": "    }",
          "new_line_content": "        memcpy(dst, ditem.rawData, willCopy);",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": null,
          "new_api": "reinterpret_cast<uint8_t*>(data)",
          "old_text": null,
          "new_text": "reinterpret_cast<uint8_t*>(data)",
          "old_line_content": "            return rc;",
          "new_line_content": "    if (Item::calculateCrc32(reinterpret_cast<uint8_t*>(data), item.varLength.dataSize) != item.varLength.dataCrc32) {",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": null,
          "new_api": "eraseEntryAndSpan",
          "old_text": null,
          "new_text": "eraseEntryAndSpan(index)",
          "old_line_content": "        }",
          "new_line_content": "        rc = eraseEntryAndSpan(index);",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": null,
          "new_api": "findItem",
          "old_text": null,
          "new_text": "findItem(nsIndex, datatype, key, index, item, chunkIdx, chunkStart)",
          "old_line_content": "    }",
          "new_line_content": "    esp_err_t rc = findItem(nsIndex, datatype, key, index, item, chunkIdx, chunkStart);",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": null,
          "new_api": "eraseEntryAndSpan",
          "old_text": null,
          "new_text": "eraseEntryAndSpan(index)",
          "old_line_content": "esp_err_t Page::findItem(uint8_t nsIndex, ItemType datatype, const char* key, uint8_t chunkIdx, VerOffset chunkStart)",
          "new_line_content": "    return eraseEntryAndSpan(index);",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": null,
          "new_api": "findItem",
          "old_text": null,
          "new_text": "findItem(nsIndex, datatype, key, index, item, chunkIdx, chunkStart)",
          "old_line_content": "esp_err_t Page::eraseEntryAndSpan(size_t index)",
          "new_line_content": "    return findItem(nsIndex, datatype, key, index, item, chunkIdx, chunkStart);",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mEntryTable.get(index)",
          "old_line_content": "    size_t span = 1;",
          "new_line_content": "    auto state = mEntryTable.get(index);",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(state == EntryState::WRITTEN || state == EntryState::EMPTY)",
          "old_line_content": "    if (state == EntryState::WRITTEN) {",
          "new_line_content": "    assert(state == EntryState::WRITTEN || state == EntryState::EMPTY);",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": null,
          "new_api": "readEntry",
          "old_text": null,
          "new_text": "readEntry(index, item)",
          "old_line_content": "        }",
          "new_line_content": "        auto rc = readEntry(index, item);",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": null,
          "new_api": "calculateCrc32",
          "old_text": null,
          "new_text": "item.calculateCrc32()",
          "old_line_content": "            --mUsedEntryCount;",
          "new_line_content": "        if (item.calculateCrc32() != item.crc32) {",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "mHashList.erase(index, false)",
          "old_line_content": "            ++mErasedEntryCount;",
          "new_line_content": "            mHashList.erase(index, false);",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": null,
          "new_api": "alterEntryState",
          "old_text": null,
          "new_text": "alterEntryState(index, EntryState::ERASED)",
          "old_line_content": "            if (rc != ESP_OK) {",
          "new_line_content": "            rc = alterEntryState(index, EntryState::ERASED);",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": null,
          "new_api": "spi_flash_erase_sector",
          "old_text": null,
          "new_text": "spi_flash_erase_sector(sector)",
          "old_line_content": "        return rc;",
          "new_line_content": "    auto rc = spi_flash_erase_sector(sector);",
          "content_same": false
        },
        {
          "line": 352,
          "old_api": null,
          "new_api": "static_cast<ptrdiff_t>(index)",
          "old_text": null,
          "new_text": "static_cast<ptrdiff_t>(index)",
          "old_line_content": "                }",
          "new_line_content": "            for (ptrdiff_t i = index + span - 1; i >= static_cast<ptrdiff_t>(index); --i) {",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mEntryTable.get(i)",
          "old_line_content": "                ++mErasedEntryCount;",
          "new_line_content": "                if (mEntryTable.get(i) == EntryState::WRITTEN) {",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "mHashList.clear()",
          "old_line_content": "",
          "new_line_content": "    mHashList.clear();",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": null,
          "new_api": "alterEntryState",
          "old_text": null,
          "new_text": "alterEntryState(index, EntryState::ERASED)",
          "old_line_content": "            }",
          "new_line_content": "                rc = alterEntryState(index, EntryState::ERASED);",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": null,
          "new_api": "alterEntryRangeState",
          "old_text": null,
          "new_text": "alterEntryRangeState(index, index + span, EntryState::ERASED)",
          "old_line_content": "                return rc;",
          "new_line_content": "                rc = alterEntryRangeState(index, index + span, EntryState::ERASED);",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": null,
          "new_api": "alterPageState",
          "old_text": null,
          "new_text": "alterPageState(PageState::FREEING)",
          "old_line_content": "esp_err_t Page::markFull()",
          "new_line_content": "    return alterPageState(PageState::FREEING);",
          "content_same": false
        },
        {
          "line": 368,
          "old_api": null,
          "new_api": "alterEntryState",
          "old_text": null,
          "new_text": "alterEntryState(index, EntryState::ERASED)",
          "old_line_content": "        }",
          "new_line_content": "        auto rc = alterEntryState(index, EntryState::ERASED);",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": null,
          "new_api": "alterPageState",
          "old_text": null,
          "new_text": "alterPageState(PageState::FULL)",
          "old_line_content": "size_t Page::getVarDataTailroom() const",
          "new_line_content": "    return alterPageState(PageState::FULL);",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": null,
          "new_api": "updateFirstUsedEntry",
          "old_text": null,
          "new_text": "updateFirstUsedEntry(index, span)",
          "old_line_content": "    if (index + span > mNextFreeEntry) {",
          "new_line_content": "        updateFirstUsedEntry(index, span);",
          "content_same": false
        },
        {
          "line": 387,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(index == mFirstUsedEntry)",
          "old_line_content": "    if (end > ENTRY_COUNT) {",
          "new_line_content": "    assert(index == mFirstUsedEntry);",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mEntryTable.get(i)",
          "old_line_content": "        }",
          "new_line_content": "        if (mEntryTable.get(i) == EntryState::WRITTEN) {",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": null,
          "new_api": "initialize",
          "old_text": null,
          "new_text": "other.initialize()",
          "old_line_content": "        }",
          "new_line_content": "        auto err = other.initialize();",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(0 && \"invalid state value\")",
          "old_line_content": "}",
          "new_line_content": "            assert(0 && \"invalid state value\");",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mEntryTable.get(readEntryIndex)",
          "old_line_content": "            continue;",
          "new_line_content": "        if (mEntryTable.get(readEntryIndex) != EntryState::WRITTEN) {",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(readEntryIndex != mFirstUsedEntry)",
          "old_line_content": "        }",
          "new_line_content": "            assert(readEntryIndex != mFirstUsedEntry);",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mEntryTable.get(i)",
          "old_line_content": "        } else if (state == EntryState::ERASED) {",
          "new_line_content": "        EntryState state = mEntryTable.get(i);",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": null,
          "new_api": "printf",
          "old_text": null,
          "new_text": "printf(\"E\\n\")",
          "old_line_content": "        } else if (state == EntryState::WRITTEN) {",
          "new_line_content": "            printf(\"E\\n\");",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": null,
          "new_api": "readEntry",
          "old_text": null,
          "new_text": "readEntry(readEntryIndex, entry)",
          "old_line_content": "        }",
          "new_line_content": "        auto err = readEntry(readEntryIndex, entry);",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "readEntry",
          "old_text": null,
          "new_text": "readEntry(i, item)",
          "old_line_content": "                if (item.span > 0 && item.span <= ENTRY_COUNT - i) {",
          "new_line_content": "            readEntry(i, item);",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": null,
          "new_api": "static_cast<unsigned>(item.datatype)",
          "old_text": null,
          "new_text": "static_cast<unsigned>(item.datatype)",
          "old_line_content": "                } else {",
          "new_line_content": "                printf(\"W ns=%2u type=%2u span=%3u key=\\\"%s\\\" chunkIdx=%d len=%d\\n\", item.nsIndex, static_cast<unsigned>(item.datatype), item.span, item.key, item.chunkIndex, (item.span != 1)?((int)item.varLength.dataSize):-1);",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "other.mHashList.insert(entry, other.mNextFreeEntry)",
          "old_line_content": "            return err;",
          "new_line_content": "        other.mHashList.insert(entry, other.mNextFreeEntry);",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": null,
          "new_api": "writeEntry",
          "old_text": null,
          "new_text": "other.writeEntry(entry)",
          "old_line_content": "        }",
          "new_line_content": "        err = other.writeEntry(entry);",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": null,
          "new_api": "printf",
          "old_text": null,
          "new_text": "printf(\"D\\n\")",
          "old_line_content": "        }",
          "new_line_content": "                printf(\"D\\n\");",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": null,
          "new_api": "readEntry",
          "old_text": null,
          "new_text": "readEntry(i, entry)",
          "old_line_content": "                return err;",
          "new_line_content": "            readEntry(i, entry);",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": null,
          "new_api": "writeEntry",
          "old_text": null,
          "new_text": "other.writeEntry(entry)",
          "old_line_content": "            }",
          "new_line_content": "            err = other.writeEntry(entry);",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(mState != PageState::FREEING)",
          "old_line_content": "",
          "new_line_content": "    assert(mState != PageState::FREEING);",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "mEntryTable.data()",
          "old_line_content": "            mState = PageState::INVALID;",
          "new_line_content": "        auto rc = spi_flash_read(mBaseAddress + ENTRY_TABLE_OFFSET, mEntryTable.data(),",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": null,
          "new_api": "byteSize",
          "old_text": null,
          "new_text": "mEntryTable.byteSize()",
          "old_line_content": "            return rc;",
          "new_line_content": "                                 mEntryTable.byteSize());",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(false && \"Unhandled state\")",
          "old_line_content": "    return ESP_OK;",
          "new_line_content": "            assert(false && \"Unhandled state\");",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mEntryTable.get(i)",
          "old_line_content": "                mFirstUsedEntry = i;",
          "new_line_content": "        auto s = mEntryTable.get(i);",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mEntryTable.get(i)",
          "old_line_content": "            }",
          "new_line_content": "            if (mEntryTable.get(i) == EntryState::EMPTY) {",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": null,
          "new_api": "getEntryAddress",
          "old_text": null,
          "new_text": "getEntryAddress(mNextFreeEntry)",
          "old_line_content": "            if (rc != ESP_OK) {",
          "new_line_content": "            uint32_t entryAddress = getEntryAddress(mNextFreeEntry);",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": null,
          "new_api": "spi_flash_read",
          "old_text": null,
          "new_text": "spi_flash_read(entryAddress, &header, sizeof(header))",
          "old_line_content": "                return rc;",
          "new_line_content": "            auto rc = spi_flash_read(entryAddress, &header, sizeof(header));",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mEntryTable.get(mNextFreeEntry)",
          "old_line_content": "                    mState = PageState::INVALID;",
          "new_line_content": "                auto oldState = mEntryTable.get(mNextFreeEntry);",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": null,
          "new_api": "alterEntryState",
          "old_text": null,
          "new_text": "alterEntryState(mNextFreeEntry, EntryState::ERASED)",
          "old_line_content": "                    return err;",
          "new_line_content": "                auto err = alterEntryState(mNextFreeEntry, EntryState::ERASED);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 527,
          "old_api": "get",
          "new_api": null,
          "old_text": "mEntryTable.get(i)",
          "new_text": null,
          "old_line_content": "            if (mEntryTable.get(i) == EntryState::ERASED) {",
          "new_line_content": "        size_t span;",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "readEntry",
          "new_api": null,
          "old_text": "readEntry(i, item)",
          "new_text": null,
          "old_line_content": "            auto err = readEntry(i, item);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": "calculateCrc32",
          "new_api": null,
          "old_text": "item.calculateCrc32()",
          "new_text": null,
          "old_line_content": "            if (item.crc32 != item.calculateCrc32()) {",
          "new_line_content": "                return err;",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": "eraseEntryAndSpan",
          "new_api": null,
          "old_text": "eraseEntryAndSpan(i)",
          "new_text": null,
          "old_line_content": "                err = eraseEntryAndSpan(i);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": "insert",
          "new_api": null,
          "old_text": "mHashList.insert(item, i)",
          "new_text": null,
          "old_line_content": "            mHashList.insert(item, i);",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": "isVariableLengthType",
          "new_api": null,
          "old_text": "isVariableLengthType(item.datatype)",
          "new_text": null,
          "old_line_content": "            if (isVariableLengthType(item.datatype)) {",
          "new_line_content": "            // search for potential duplicate item",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": "get",
          "new_api": null,
          "old_text": "mEntryTable.get(j)",
          "new_text": null,
          "old_line_content": "                    if (mEntryTable.get(j) != EntryState::WRITTEN) {",
          "new_line_content": "                span = item.span;",
          "content_same": false
        },
        {
          "line": 53,
          "old_api": "spi_flash_read",
          "new_api": null,
          "old_text": "spi_flash_read(mBaseAddress + i, line, sizeof(line))",
          "new_text": null,
          "old_line_content": "            rc = spi_flash_read(mBaseAddress + i, line, sizeof(line));",
          "new_line_content": "        for (uint32_t i = 0; i < SPI_FLASH_SEC_SIZE; i += 4 * BLOCK_SIZE) {",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": "eraseEntryAndSpan",
          "new_api": null,
          "old_text": "eraseEntryAndSpan(i)",
          "new_text": null,
          "old_line_content": "                    eraseEntryAndSpan(i);",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 58,
          "old_api": "std::any_of(line, line + 4, [](uint32_t val) -> bool { return val != 0xffffffff; })",
          "new_api": null,
          "old_text": "std::any_of(line, line + 4, [](uint32_t val) -> bool { return val != 0xffffffff; })",
          "new_text": null,
          "old_line_content": "            if (std::any_of(line, line + 4, [](uint32_t val) -> bool { return val != 0xffffffff; })) {",
          "new_line_content": "                return rc;",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "eraseEntryAndSpan",
          "new_api": null,
          "old_text": "eraseEntryAndSpan(duplicateIndex)",
          "new_text": null,
          "old_line_content": "                eraseEntryAndSpan(duplicateIndex);",
          "new_line_content": "             * for same key on active page. Since datatype is not used in hash calculation, ",
          "content_same": false
        },
        {
          "line": 64,
          "old_api": "calculateCrc32",
          "new_api": null,
          "old_text": "header.calculateCrc32()",
          "new_text": null,
          "old_line_content": "    } else if (header.mCrc32 != header.calculateCrc32()) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": "findItem",
          "new_api": null,
          "old_text": "findItem(item.nsIndex, item.datatype, item.key, findItemIndex, dupItem)",
          "new_text": null,
          "old_line_content": "            if (findItem(item.nsIndex, item.datatype, item.key, findItemIndex, dupItem) == ESP_OK) {",
          "new_line_content": "        if (lastItemIndex != INVALID_ENTRY) {",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": "eraseEntryAndSpan",
          "new_api": null,
          "old_text": "eraseEntryAndSpan(findItemIndex)",
          "new_text": null,
          "old_line_content": "                    auto err = eraseEntryAndSpan(findItemIndex);",
          "new_line_content": "            Item dupItem;",
          "content_same": false
        },
        {
          "line": 83,
          "old_api": "mLoadEntryTable",
          "new_api": null,
          "old_text": "mLoadEntryTable()",
          "new_text": null,
          "old_line_content": "        mLoadEntryTable();",
          "new_line_content": "    case PageState::FULL:",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": "get",
          "new_api": null,
          "old_text": "mEntryTable.get(i)",
          "new_text": null,
          "old_line_content": "            if (mEntryTable.get(i) != EntryState::WRITTEN) {",
          "new_line_content": "        // Do the same for the case when page is in full or freeing state.",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": "readEntry",
          "new_api": null,
          "old_text": "readEntry(i, item)",
          "new_text": null,
          "old_line_content": "            auto err = readEntry(i, item);",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": "calculateCrc32",
          "new_api": null,
          "old_text": "item.calculateCrc32()",
          "new_text": null,
          "old_line_content": "            if (item.crc32 != item.calculateCrc32()) {",
          "new_line_content": "                return err;",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": "eraseEntryAndSpan",
          "new_api": null,
          "old_text": "eraseEntryAndSpan(i)",
          "new_text": null,
          "old_line_content": "                err = eraseEntryAndSpan(i);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 98,
          "old_api": "getEntryAddress",
          "new_api": null,
          "old_text": "getEntryAddress(mNextFreeEntry)",
          "new_text": null,
          "old_line_content": "    err = nvs_flash_write(getEntryAddress(mNextFreeEntry), &item, sizeof(item));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 105,
          "old_api": "alterEntryState",
          "new_api": null,
          "old_text": "alterEntryState(mNextFreeEntry, EntryState::WRITTEN)",
          "new_text": null,
          "old_line_content": "    err = alterEntryState(mNextFreeEntry, EntryState::WRITTEN);",
          "new_line_content": "        return err;",
          "content_same": false
        },
        {
          "line": 617,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(item.span > 0)",
          "new_text": null,
          "old_line_content": "            assert(item.span > 0);",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": "insert",
          "new_api": null,
          "old_text": "mHashList.insert(item, i)",
          "new_text": null,
          "old_line_content": "            mHashList.insert(item, i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": "isVariableLengthType",
          "new_api": null,
          "old_text": "isVariableLengthType(item.datatype)",
          "new_text": null,
          "old_line_content": "            if (isVariableLengthType(item.datatype)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": "get",
          "new_api": null,
          "old_text": "mEntryTable.get(j)",
          "new_text": null,
          "old_line_content": "                    if (mEntryTable.get(j) != EntryState::WRITTEN) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 122,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(size % ENTRY_SIZE == 0)",
          "new_text": null,
          "old_line_content": "    assert(size % ENTRY_SIZE == 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 123,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(mNextFreeEntry != INVALID_ENTRY)",
          "new_text": null,
          "old_line_content": "    assert(mNextFreeEntry != INVALID_ENTRY);",
          "new_line_content": "esp_err_t Page::writeEntryData(const uint8_t* data, size_t size)",
          "content_same": false
        },
        {
          "line": 124,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(mFirstUsedEntry != INVALID_ENTRY)",
          "new_text": null,
          "old_line_content": "    assert(mFirstUsedEntry != INVALID_ENTRY);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(mState == PageState::UNINITIALIZED)",
          "new_text": null,
          "old_line_content": "    assert(mState == PageState::UNINITIALIZED);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": "calculateCrc32",
          "new_api": null,
          "old_text": "header.calculateCrc32()",
          "new_text": null,
          "old_line_content": "    header.mCrc32 = header.calculateCrc32();",
          "new_line_content": "    header.mState = mState;",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": "malloc",
          "new_api": null,
          "old_text": "malloc(size)",
          "new_text": null,
          "old_line_content": "        buf = (uint8_t*) malloc(size);",
          "new_line_content": "     * a platform-specific flash layer).",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": "spi_flash_write",
          "new_api": null,
          "old_text": "spi_flash_write(mBaseAddress, &header, sizeof(header))",
          "new_text": null,
          "old_line_content": "    auto rc = spi_flash_write(mBaseAddress, &header, sizeof(header));",
          "new_line_content": "    header.mVersion = mVersion;",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy((void*)buf, data, size)",
          "new_text": null,
          "old_line_content": "        memcpy((void*)buf, data, size);",
          "new_line_content": "        if (!buf) {",
          "content_same": false
        },
        {
          "line": 146,
          "old_api": "getEntryAddress",
          "new_api": null,
          "old_text": "getEntryAddress(mNextFreeEntry)",
          "new_text": null,
          "old_line_content": "    auto rc = nvs_flash_write(getEntryAddress(mNextFreeEntry), buf, size);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "byteSize",
          "new_api": null,
          "old_text": "mEntryTable.byteSize()",
          "new_text": null,
          "old_line_content": "    std::fill_n(mEntryTable.data(), mEntryTable.byteSize() / sizeof(uint32_t), 0xffffffff);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 150,
          "old_api": "free",
          "new_api": null,
          "old_text": "free((void*)buf)",
          "new_text": null,
          "old_line_content": "        free((void*)buf);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(index < ENTRY_COUNT)",
          "new_text": null,
          "old_line_content": "    assert(index < ENTRY_COUNT);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": "set",
          "new_api": null,
          "old_text": "mEntryTable.set(index, state)",
          "new_text": null,
          "old_line_content": "    mEntryTable.set(index, state);",
          "new_line_content": "esp_err_t Page::alterEntryState(size_t index, EntryState state)",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": "getWordIndex",
          "new_api": null,
          "old_text": "mEntryTable.getWordIndex(index)",
          "new_text": null,
          "old_line_content": "    size_t wordToWrite = mEntryTable.getWordIndex(index);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 157,
          "old_api": "alterEntryRangeState",
          "new_api": null,
          "old_text": "alterEntryRangeState(mNextFreeEntry, mNextFreeEntry + count, EntryState::WRITTEN)",
          "new_text": null,
          "old_line_content": "    auto err = alterEntryRangeState(mNextFreeEntry, mNextFreeEntry + count, EntryState::WRITTEN);",
          "new_line_content": "        mState = PageState::INVALID;",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(end <= ENTRY_COUNT)",
          "new_text": null,
          "old_line_content": "    assert(end <= ENTRY_COUNT);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(end > begin)",
          "new_text": null,
          "old_line_content": "    assert(end > begin);",
          "new_line_content": "esp_err_t Page::alterEntryRangeState(size_t begin, size_t end, EntryState state)",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": "getWordIndex",
          "new_api": null,
          "old_text": "mEntryTable.getWordIndex(end - 1)",
          "new_text": null,
          "old_line_content": "    size_t wordIndex = mEntryTable.getWordIndex(end - 1);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 176,
          "old_api": "initialize",
          "new_api": null,
          "old_text": "initialize()",
          "new_text": null,
          "old_line_content": "        err = initialize();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": "static_cast<uint32_t>(wordIndex)",
          "new_api": null,
          "old_text": "static_cast<uint32_t>(wordIndex)",
          "new_text": null,
          "old_line_content": "            auto rc = spi_flash_write(mBaseAddress + ENTRY_TABLE_OFFSET + static_cast<uint32_t>(wordIndex) * 4,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": "strlen",
          "new_api": null,
          "old_text": "strlen(key)",
          "new_text": null,
          "old_line_content": "    const size_t keySize = strlen(key);",
          "new_line_content": "        return ESP_ERR_NVS_PAGE_FULL;",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": "static_cast<uint32_t>(state)",
          "new_api": null,
          "old_text": "static_cast<uint32_t>(state)",
          "new_text": null,
          "old_line_content": "    uint32_t state_val = static_cast<uint32_t>(state);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": "spi_flash_write",
          "new_api": null,
          "old_text": "spi_flash_write(mBaseAddress, &state_val, sizeof(state))",
          "new_text": null,
          "old_line_content": "    auto rc = spi_flash_write(mBaseAddress, &state_val, sizeof(state));",
          "new_line_content": "esp_err_t Page::alterPageState(PageState state)",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": "isVariableLengthType",
          "new_api": null,
          "old_text": "isVariableLengthType(datatype)",
          "new_text": null,
          "old_line_content": "    if (isVariableLengthType(datatype)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(totalSize == ENTRY_SIZE ||\n       isVariableLengthType(datatype))",
          "new_text": null,
          "old_line_content": "    assert(totalSize == ENTRY_SIZE ||",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 205,
          "old_api": "isVariableLengthType",
          "new_api": null,
          "old_text": "isVariableLengthType(datatype)",
          "new_text": null,
          "old_line_content": "       isVariableLengthType(datatype));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "getEntryAddress",
          "new_api": null,
          "old_text": "getEntryAddress(index)",
          "new_text": null,
          "old_line_content": "    auto rc = nvs_flash_read(getEntryAddress(index), &dst, sizeof(dst));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": "Item",
          "new_api": null,
          "old_text": "Item(nsIndex, datatype, span, key, chunkIdx)",
          "new_text": null,
          "old_line_content": "    item = Item(nsIndex, datatype, span, key, chunkIdx);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": "insert",
          "new_api": null,
          "old_text": "mHashList.insert(item, mNextFreeEntry)",
          "new_text": null,
          "old_line_content": "    mHashList.insert(item, mNextFreeEntry);",
          "new_line_content": "    // write first item",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": "calculateCrc32",
          "new_api": null,
          "old_text": "item.calculateCrc32()",
          "new_text": null,
          "old_line_content": "        item.crc32 = item.calculateCrc32();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 225,
          "old_api": "reinterpret_cast<const uint8_t*>(data)",
          "new_api": null,
          "old_text": "reinterpret_cast<const uint8_t*>(data)",
          "new_text": null,
          "old_line_content": "        const uint8_t* src = reinterpret_cast<const uint8_t*>(data);",
          "new_line_content": "            return err;",
          "content_same": false
        },
        {
          "line": 226,
          "old_api": "Item::calculateCrc32(src, dataSize)",
          "new_api": null,
          "old_text": "Item::calculateCrc32(src, dataSize)",
          "new_text": null,
          "old_line_content": "        item.varLength.dataCrc32 = Item::calculateCrc32(src, dataSize);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": "writeEntry",
          "new_api": null,
          "old_text": "writeEntry(item)",
          "new_text": null,
          "old_line_content": "        err = writeEntry(item);",
          "new_line_content": "        item.varLength.dataSize = dataSize;",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": "Item",
          "new_api": null,
          "old_text": "Item(nsIndex, datatype, 0, key, chunkIdx)",
          "new_text": null,
          "old_line_content": "        size_t cachedIndex = mHashList.find(start, Item(nsIndex, datatype, 0, key, chunkIdx));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": "static_cast<const uint8_t*>(data)",
          "new_api": null,
          "old_text": "static_cast<const uint8_t*>(data)",
          "new_text": null,
          "old_line_content": "            err = writeEntryData(static_cast<const uint8_t*>(data), left);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": "std::fill_n(item.rawData, ENTRY_SIZE, 0xff)",
          "new_api": null,
          "old_text": "std::fill_n(item.rawData, ENTRY_SIZE, 0xff)",
          "new_text": null,
          "old_line_content": "            std::fill_n(item.rawData, ENTRY_SIZE, 0xff);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": "static_cast<const uint8_t*>(data)",
          "new_api": null,
          "old_text": "static_cast<const uint8_t*>(data)",
          "new_text": null,
          "old_line_content": "            memcpy(item.rawData, static_cast<const uint8_t*>(data) + left, tail);",
          "new_line_content": "        size_t tail = dataSize - left;",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": "writeEntry",
          "new_api": null,
          "old_text": "writeEntry(item)",
          "new_text": null,
          "old_line_content": "            err = writeEntry(item);",
          "new_line_content": "        if (tail > 0) {",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "get",
          "new_api": null,
          "old_text": "mEntryTable.get(i)",
          "new_text": null,
          "old_line_content": "        if (mEntryTable.get(i) != EntryState::WRITTEN) {",
          "new_line_content": "    size_t next;",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "readEntry",
          "new_api": null,
          "old_text": "readEntry(i, item)",
          "new_text": null,
          "old_line_content": "        auto rc = readEntry(i, item);",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": "calculateCrc32",
          "new_api": null,
          "old_text": "item.calculateCrc32()",
          "new_text": null,
          "old_line_content": "        auto crc32 = item.calculateCrc32();",
          "new_line_content": "            return rc;",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": "eraseEntryAndSpan",
          "new_api": null,
          "old_text": "eraseEntryAndSpan(i)",
          "new_text": null,
          "old_line_content": "            rc = eraseEntryAndSpan(i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": "isVariableLengthType",
          "new_api": null,
          "old_text": "isVariableLengthType(item.datatype)",
          "new_text": null,
          "old_line_content": "        if (isVariableLengthType(item.datatype)) {",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": "findItem",
          "new_api": null,
          "old_text": "findItem(nsIndex, datatype, key, index, item, chunkIdx, chunkStart)",
          "new_text": null,
          "old_line_content": "    esp_err_t rc = findItem(nsIndex, datatype, key, index, item, chunkIdx, chunkStart);",
          "new_line_content": "        return ESP_ERR_NVS_INVALID_STATE;",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "isVariableLengthType",
          "new_api": null,
          "old_text": "isVariableLengthType(datatype)",
          "new_text": null,
          "old_line_content": "    if (!isVariableLengthType(datatype)) {",
          "new_line_content": "        return rc;",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "getAlignmentForType",
          "new_api": null,
          "old_text": "getAlignmentForType(datatype)",
          "new_text": null,
          "old_line_content": "        if (dataSize != getAlignmentForType(datatype)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "strncmp",
          "new_api": null,
          "old_text": "strncmp(key, item.key, Item::MAX_KEY_LENGTH)",
          "new_text": null,
          "old_line_content": "        if (key != nullptr && strncmp(key, item.key, Item::MAX_KEY_LENGTH) != 0) {",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(data, item.data, dataSize)",
          "new_text": null,
          "old_line_content": "        memcpy(data, item.data, dataSize);",
          "new_line_content": "            return ESP_ERR_NVS_TYPE_MISMATCH;",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": "static_cast<size_t>(item.varLength.dataSize)",
          "new_api": null,
          "old_text": "static_cast<size_t>(item.varLength.dataSize)",
          "new_text": null,
          "old_line_content": "    if (dataSize < static_cast<size_t>(item.varLength.dataSize)) {",
          "new_line_content": "        return ESP_OK;",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "reinterpret_cast<uint8_t*>(data)",
          "new_api": null,
          "old_text": "reinterpret_cast<uint8_t*>(data)",
          "new_text": null,
          "old_line_content": "    uint8_t* dst = reinterpret_cast<uint8_t*>(data);",
          "new_line_content": "        return ESP_ERR_NVS_INVALID_LENGTH;",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": "readEntry",
          "new_api": null,
          "old_text": "readEntry(i, ditem)",
          "new_text": null,
          "old_line_content": "        rc = readEntry(i, ditem);",
          "new_line_content": "    size_t left = item.varLength.dataSize;",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(dst, ditem.rawData, willCopy)",
          "new_text": null,
          "old_line_content": "        memcpy(dst, ditem.rawData, willCopy);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": "reinterpret_cast<uint8_t*>(data)",
          "new_api": null,
          "old_text": "reinterpret_cast<uint8_t*>(data)",
          "new_text": null,
          "old_line_content": "    if (Item::calculateCrc32(reinterpret_cast<uint8_t*>(data), item.varLength.dataSize) != item.varLength.dataCrc32) {",
          "new_line_content": "        left -= willCopy;",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": "eraseEntryAndSpan",
          "new_api": null,
          "old_text": "eraseEntryAndSpan(index)",
          "new_text": null,
          "old_line_content": "        rc = eraseEntryAndSpan(index);",
          "new_line_content": "        dst += willCopy;",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "findItem",
          "new_api": null,
          "old_text": "findItem(nsIndex, datatype, key, index, item, chunkIdx, chunkStart)",
          "new_text": null,
          "old_line_content": "    esp_err_t rc = findItem(nsIndex, datatype, key, index, item, chunkIdx, chunkStart);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": "eraseEntryAndSpan",
          "new_api": null,
          "old_text": "eraseEntryAndSpan(index)",
          "new_text": null,
          "old_line_content": "    return eraseEntryAndSpan(index);",
          "new_line_content": "    if (rc != ESP_OK) {",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": "findItem",
          "new_api": null,
          "old_text": "findItem(nsIndex, datatype, key, index, item, chunkIdx, chunkStart)",
          "new_text": null,
          "old_line_content": "    return findItem(nsIndex, datatype, key, index, item, chunkIdx, chunkStart);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 328,
          "old_api": "get",
          "new_api": null,
          "old_text": "mEntryTable.get(index)",
          "new_text": null,
          "old_line_content": "    auto state = mEntryTable.get(index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(state == EntryState::WRITTEN || state == EntryState::EMPTY)",
          "new_text": null,
          "old_line_content": "    assert(state == EntryState::WRITTEN || state == EntryState::EMPTY);",
          "new_line_content": "esp_err_t Page::eraseEntryAndSpan(size_t index)",
          "content_same": false
        },
        {
          "line": 334,
          "old_api": "readEntry",
          "new_api": null,
          "old_text": "readEntry(index, item)",
          "new_text": null,
          "old_line_content": "        auto rc = readEntry(index, item);",
          "new_line_content": "    size_t span = 1;",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": "calculateCrc32",
          "new_api": null,
          "old_text": "item.calculateCrc32()",
          "new_text": null,
          "old_line_content": "        if (item.calculateCrc32() != item.crc32) {",
          "new_line_content": "        if (rc != ESP_OK) {",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": "erase",
          "new_api": null,
          "old_text": "mHashList.erase(index, false)",
          "new_text": null,
          "old_line_content": "            mHashList.erase(index, false);",
          "new_line_content": "            return rc;",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": "alterEntryState",
          "new_api": null,
          "old_text": "alterEntryState(index, EntryState::ERASED)",
          "new_text": null,
          "old_line_content": "            rc = alterEntryState(index, EntryState::ERASED);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": "spi_flash_erase_sector",
          "new_api": null,
          "old_text": "spi_flash_erase_sector(sector)",
          "new_text": null,
          "old_line_content": "    auto rc = spi_flash_erase_sector(sector);",
          "new_line_content": "esp_err_t Page::erase()",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": "erase",
          "new_api": null,
          "old_text": "mHashList.erase(index)",
          "new_text": null,
          "old_line_content": "            mHashList.erase(index);",
          "new_line_content": "                return rc;",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": "static_cast<ptrdiff_t>(index)",
          "new_api": null,
          "old_text": "static_cast<ptrdiff_t>(index)",
          "new_text": null,
          "old_line_content": "            for (ptrdiff_t i = index + span - 1; i >= static_cast<ptrdiff_t>(index); --i) {",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": "clear",
          "new_api": null,
          "old_text": "mHashList.clear()",
          "new_text": null,
          "old_line_content": "    mHashList.clear();",
          "new_line_content": "    mFirstUsedEntry = INVALID_ENTRY;",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": "alterEntryState",
          "new_api": null,
          "old_text": "alterEntryState(index, EntryState::ERASED)",
          "new_text": null,
          "old_line_content": "                rc = alterEntryState(index, EntryState::ERASED);",
          "new_line_content": "                ++mErasedEntryCount;",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": "alterEntryRangeState",
          "new_api": null,
          "old_text": "alterEntryRangeState(index, index + span, EntryState::ERASED)",
          "new_text": null,
          "old_line_content": "                rc = alterEntryRangeState(index, index + span, EntryState::ERASED);",
          "new_line_content": "            if (span == 1) {",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": "alterPageState",
          "new_api": null,
          "old_text": "alterPageState(PageState::FREEING)",
          "new_text": null,
          "old_line_content": "    return alterPageState(PageState::FREEING);",
          "new_line_content": "    if (mState != PageState::FULL && mState != PageState::ACTIVE) {",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "alterEntryState",
          "new_api": null,
          "old_text": "alterEntryState(index, EntryState::ERASED)",
          "new_text": null,
          "old_line_content": "        auto rc = alterEntryState(index, EntryState::ERASED);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": "alterPageState",
          "new_api": null,
          "old_text": "alterPageState(PageState::FULL)",
          "new_text": null,
          "old_line_content": "    return alterPageState(PageState::FULL);",
          "new_line_content": "    if (mState != PageState::ACTIVE) {",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "updateFirstUsedEntry",
          "new_api": null,
          "old_text": "updateFirstUsedEntry(index, span)",
          "new_text": null,
          "old_line_content": "        updateFirstUsedEntry(index, span);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(index == mFirstUsedEntry)",
          "new_text": null,
          "old_line_content": "    assert(index == mFirstUsedEntry);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": "get",
          "new_api": null,
          "old_text": "mEntryTable.get(i)",
          "new_text": null,
          "old_line_content": "        if (mEntryTable.get(i) == EntryState::WRITTEN) {",
          "new_line_content": "        end = ENTRY_COUNT;",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": "initialize",
          "new_api": null,
          "old_text": "other.initialize()",
          "new_text": null,
          "old_line_content": "        auto err = other.initialize();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(0 && \"invalid state value\")",
          "new_text": null,
          "old_line_content": "            assert(0 && \"invalid state value\");",
          "new_line_content": "            return \"UNINITIALIZED\";",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": "static_cast<int>(mNextFreeEntry)",
          "new_api": null,
          "old_text": "static_cast<int>(mNextFreeEntry)",
          "new_text": null,
          "old_line_content": "    printf(\"state=%x (%s) addr=%x seq=%d\\nfirstUsed=%d nextFree=%d used=%d erased=%d\\n\", (uint32_t) mState, pageStateToName(mState), mBaseAddress, mSeqNumber, static_cast<int>(mFirstUsedEntry), static_cast<int>(mNextFreeEntry), mUsedEntryCount, mErasedEntryCount);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": "get",
          "new_api": null,
          "old_text": "mEntryTable.get(readEntryIndex)",
          "new_text": null,
          "old_line_content": "        if (mEntryTable.get(readEntryIndex) != EntryState::WRITTEN) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(readEntryIndex != mFirstUsedEntry)",
          "new_text": null,
          "old_line_content": "            assert(readEntryIndex != mFirstUsedEntry);",
          "new_line_content": "    while (readEntryIndex < ENTRY_COUNT) {",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": "get",
          "new_api": null,
          "old_text": "mEntryTable.get(i)",
          "new_text": null,
          "old_line_content": "        EntryState state = mEntryTable.get(i);",
          "new_line_content": "    size_t skip = 0;",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "printf",
          "new_api": null,
          "old_text": "printf(\"X\\n\")",
          "new_text": null,
          "old_line_content": "            printf(\"X\\n\");",
          "new_line_content": "        if (state == EntryState::EMPTY) {",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": "readEntry",
          "new_api": null,
          "old_text": "readEntry(readEntryIndex, entry)",
          "new_text": null,
          "old_line_content": "        auto err = readEntry(readEntryIndex, entry);",
          "new_line_content": "            readEntryIndex++;",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": "static_cast<unsigned>(item.datatype)",
          "new_api": null,
          "old_text": "static_cast<unsigned>(item.datatype)",
          "new_text": null,
          "old_line_content": "                printf(\"W ns=%2u type=%2u span=%3u key=\\\"%s\\\" chunkIdx=%d len=%d\\n\", item.nsIndex, static_cast<unsigned>(item.datatype), item.span, item.key, item.chunkIndex, (item.span != 1)?((int)item.varLength.dataSize):-1);",
          "new_line_content": "            Item item;",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": "insert",
          "new_api": null,
          "old_text": "other.mHashList.insert(entry, other.mNextFreeEntry)",
          "new_text": null,
          "old_line_content": "        other.mHashList.insert(entry, other.mNextFreeEntry);",
          "new_line_content": "            return err;",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": "writeEntry",
          "new_api": null,
          "old_text": "other.writeEntry(entry)",
          "new_text": null,
          "old_line_content": "        err = other.writeEntry(entry);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "printf",
          "new_api": null,
          "old_text": "printf(\"D\\n\")",
          "new_text": null,
          "old_line_content": "                printf(\"D\\n\");",
          "new_line_content": "                    skip = 0;",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(end <= ENTRY_COUNT)",
          "new_text": null,
          "old_line_content": "        assert(end <= ENTRY_COUNT);",
          "new_line_content": "        size_t span = entry.span;",
          "content_same": false
        },
        {
          "line": 438,
          "old_api": "writeEntry",
          "new_api": null,
          "old_text": "other.writeEntry(entry)",
          "new_text": null,
          "old_line_content": "            err = other.writeEntry(entry);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(mState != PageState::FREEING)",
          "new_text": null,
          "old_line_content": "    assert(mState != PageState::FREEING);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": "data",
          "new_api": null,
          "old_text": "mEntryTable.data()",
          "new_text": null,
          "old_line_content": "        auto rc = spi_flash_read(mBaseAddress + ENTRY_TABLE_OFFSET, mEntryTable.data(),",
          "new_line_content": "    if (mState == PageState::ACTIVE ||",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": "byteSize",
          "new_api": null,
          "old_text": "mEntryTable.byteSize()",
          "new_text": null,
          "old_line_content": "                                 mEntryTable.byteSize());",
          "new_line_content": "            mState == PageState::FULL ||",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(false && \"Unhandled state\")",
          "new_text": null,
          "old_line_content": "            assert(false && \"Unhandled state\");",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "get",
          "new_api": null,
          "old_text": "mEntryTable.get(i)",
          "new_text": null,
          "old_line_content": "        auto s = mEntryTable.get(i);",
          "new_line_content": "    mErasedEntryCount = 0;",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": "get",
          "new_api": null,
          "old_text": "mEntryTable.get(i)",
          "new_text": null,
          "old_line_content": "            if (mEntryTable.get(i) == EntryState::EMPTY) {",
          "new_line_content": "    // as such, we need to figure out where the first unused entry is",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": "getEntryAddress",
          "new_api": null,
          "old_text": "getEntryAddress(mNextFreeEntry)",
          "new_text": null,
          "old_line_content": "            uint32_t entryAddress = getEntryAddress(mNextFreeEntry);",
          "new_line_content": "        // entry state table may actually be half-written.",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "spi_flash_read",
          "new_api": null,
          "old_text": "spi_flash_read(entryAddress, &header, sizeof(header))",
          "new_text": null,
          "old_line_content": "            auto rc = spi_flash_read(entryAddress, &header, sizeof(header));",
          "new_line_content": "        while (mNextFreeEntry < ENTRY_COUNT) {",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "get",
          "new_api": null,
          "old_text": "mEntryTable.get(mNextFreeEntry)",
          "new_text": null,
          "old_line_content": "                auto oldState = mEntryTable.get(mNextFreeEntry);",
          "new_line_content": "                return rc;",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "alterEntryState",
          "new_api": null,
          "old_text": "alterEntryState(mNextFreeEntry, EntryState::ERASED)",
          "new_text": null,
          "old_line_content": "                auto err = alterEntryState(mNextFreeEntry, EntryState::ERASED);",
          "new_line_content": "            }",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 17,
      "total_additions": 124,
      "total_deletions": 124,
      "total_api_changes": 265
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 265,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          57,
          66,
          51,
          52
        ]
      }
    },
    "api_calls_before": 165,
    "api_calls_after": 165,
    "diff_info": {
      "added_lines": 7,
      "removed_lines": 4,
      "total_diff_lines": 32
    }
  }
}