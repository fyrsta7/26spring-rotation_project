{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/sumatrapdf/modified_file/9b9814fce9d5b6e22147210f696334518b637d8a",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/sumatrapdf/modified_file/9b9814fce9d5b6e22147210f696334518b637d8a/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/sumatrapdf/modified_file/9b9814fce9d5b6e22147210f696334518b637d8a/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/sumatrapdf/modified_file/9b9814fce9d5b6e22147210f696334518b637d8a/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1125,
          "old_api": "chBufOutSize)\n{\n    CrashIf(0 ==",
          "new_api": "cchBufOutSize)\n{\n    CrashIf(0 ==",
          "old_text": "chBufOutSize)\n{\n    CrashIf(0 == ",
          "new_text": "cchBufOutSize)\n{\n    CrashIf(0 ==",
          "old_line_content": null,
          "new_line_content": "            va_arg(args, ScopedMem<WCHAR> *)->Set(ExtractUntil(str, *(f + 1), &end));",
          "content_same": true
        },
        {
          "line": 1130,
          "old_api": "0, s, (int)sLen",
          "new_api": "Size - 1;\n    }",
          "old_text": "0, s, (int)sLen",
          "new_text": "Size - 1;\n    }",
          "old_line_content": null,
          "new_line_content": "        else if (' ' == *f && str::IsWs(*str))",
          "content_same": true
        },
        {
          "line": 1133,
          "old_api": "ed;\n}\n\nsize_t W",
          "new_api": "8Buf",
          "old_text": "ed;\n}\n\nsize_t W",
          "new_text": "8Buf(const WCHA",
          "old_line_content": null,
          "new_line_content": "            if (!str::IsWs(*str))",
          "content_same": true
        },
        {
          "line": 1135,
          "old_api": ");\n    int cbCo",
          "new_api": "WideCharToMult",
          "old_text": ");\n    int cbCo",
          "new_text": " WideCharToMult",
          "old_line_content": null,
          "new_line_content": "            for (end = str + 1; str::IsWs(*end); end++);",
          "content_same": true
        },
        {
          "line": 1144,
          "old_api": "code below\n\n/*",
          "new_api": "ght 2001-2004 Un",
          "old_text": "code below\n\n/*\n ",
          "new_text": "ght 2001-2004 Un",
          "old_line_content": null,
          "new_line_content": "        else if (str::IsDigit(*f))",
          "content_same": true
        },
        {
          "line": 1145,
          "old_api": "r\n * \n * This source",
          "new_api": "e is provided as is",
          "old_text": "r\n * \n * This source",
          "new_text": "e is provided as is ",
          "old_line_content": null,
          "new_line_content": "            f = ParseLimitedNumber(str, f, &end, va_arg(args, void *)) - 1;",
          "content_same": true
        },
        {
          "line": 1150,
          "old_api": "pose. No war",
          "new_api": "ny\n * kind a",
          "old_text": "pose. No war",
          "new_text": "ny\n * kind a",
          "old_line_content": null,
          "new_line_content": "    va_end(args);",
          "content_same": true
        },
        {
          "line": 1154,
          "old_api": "or implied.",
          "new_api": "nt agrees to",
          "old_text": " or implied.",
          "new_text": "nt agrees to",
          "old_line_content": null,
          "new_line_content": "    va_end(args);",
          "content_same": true
        },
        {
          "line": 1160,
          "old_api": "ic or optical media from Un",
          "new_api": "Unicode, Inc., the\n * sole",
          "old_text": "ic or optical media from Un",
          "new_text": "Unicode, Inc., the\n * sole ",
          "old_line_content": null,
          "new_line_content": "    CrashIf(0 == cchBufOutSize);",
          "content_same": true
        },
        {
          "line": 1172,
          "old_api": "typedef unsigned char UTF8; /* typically 8 bits */\n\n/*\n *",
          "new_api": "al distribution as long as this notice",
          "old_text": "\n\ntypedef unsigned char UTF8; /* typically 8 bits */\n\n/*\n *",
          "new_text": "al distribution as long as this notice\n",
          "old_line_content": "    int cbConverted = WideCharToMultiByte(CP_UTF8, 0, s, -1, NULL, 0, NULL, NULL);",
          "new_line_content": "    CrashIf(!bufOut || (0 == cbBufOutSize));",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": "nd int->string.\n// it's",
          "new_api": "e-efficient implementat",
          "old_text": "nd int->string.\n// it's",
          "new_text": "e-efficient implementat",
          "old_line_content": "    const WCHAR *hash = str::FindChar(url, '#');",
          "new_line_content": "    const WCHAR *colon = str::FindChar(url, ':');",
          "content_same": false
        },
        {
          "line": 1371,
          "old_api": ") {",
          "new_api": "const char *",
          "old_text": ") {\n         ",
          "new_text": " const char *",
          "old_line_content": "    MultiByteToWideChar(CP_UTF8, 0, urlUtf8, -1, url, (int)str::Len(url) + 1);",
          "new_line_content": "    CrashIf(str::Len(url) >= INT_MAX);",
          "content_same": false
        },
        {
          "line": 1377,
          "old_api": "(c != *toFind++) {\n            while",
          "new_api": "}",
          "old_text": " (c != *toFind++) {\n            while",
          "new_text": "       }\n    ",
          "old_line_content": "    str::TransChars(path, L\"#?\", L\"\\0\\0\");",
          "new_line_content": "    WCHAR *path = str::Dup(url);",
          "content_same": false
        },
        {
          "line": 1378,
          "old_api": "s+",
          "new_api": "(c != *toFind++) {\n            while",
          "old_text": "\n                s+",
          "new_text": "(c != *toFind++) {\n            while ",
          "old_line_content": "    DecodeInPlace(path);",
          "new_line_content": "    str::TransChars(path, L\"#?\", L\"\\0\\0\");",
          "content_same": false
        },
        {
          "line": 1386,
          "old_api": "s end of s + 1",
          "new_api": "NULL if s is the same as toFind\n// If",
          "old_text": "s end of s + 1",
          "new_text": "NULL if s is the same as toFind\n// If",
          "old_line_content": "    WCHAR *base = path + str::Len(path);",
          "new_line_content": "    str::TransChars(path, L\"#?\", L\"\\0\\0\");",
          "content_same": false
        },
        {
          "line": 1394,
          "old_api": "return NUL",
          "new_api": "if (0 == *toFind)",
          "old_text": "    return NUL",
          "new_text": "  if (0 == *toFind)",
          "old_line_content": "    return str::Dup(base);",
          "new_line_content": "    DecodeInPlace(base);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1283,
          "old_api": null,
          "new_api": "ltiByteToWideChar",
          "old_text": null,
          "new_text": "ltiByteToWideChar(cp, 0, s, ",
          "old_line_content": "            return false;",
          "new_line_content": "        if (length > sourceEnd - *source || !isLegalUTF8(*source, length))",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": null,
          "new_api": "* within 90 days of receipt.\n * \n * Limitations on Rights to Re",
          "old_text": null,
          "new_text": "\n * within 90 days of receipt.\n * \n * Limitations on Rights to Re",
          "old_line_content": "    if ((size_t)cchConverted >= cchBufOutSize)",
          "new_line_content": "    int cchConverted = MultiByteToWideChar(CP_UTF8, 0, s, iCbLen, bufOut, cchBufOutSize);",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": null,
          "new_api": "typedef unsigned char UTF8; /* typically 8 bits */\n\n/*\n *",
          "old_text": null,
          "new_text": "\ntypedef unsigned char UTF8; /* typically 8 bits */\n\n/*\n * ",
          "old_line_content": "    if ((size_t)cbConverted >= cbBufOutSize)",
          "new_line_content": "    int cbConverted = WideCharToMultiByte(CP_UTF8, 0, s, -1, NULL, 0, NULL, NULL);",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": null,
          "new_api": "src += 2;",
          "old_text": null,
          "new_text": " src += 2;\n",
          "old_line_content": "",
          "new_line_content": "        len = str::Len(s);",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "bytes that are supposed to follow it.\n * Note that *legal* UTF-8 value",
          "old_text": null,
          "new_text": " bytes that are supposed to follow it.\n * Note that *legal* UTF-8 value",
          "old_line_content": "    bufOut[cbConverted] = '\\0';",
          "new_line_content": "    WideCharToMultiByte(CP_UTF8, 0, s, -1, bufOut, cbConverted, NULL, NULL);",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": null,
          "new_api": "*url = '\\0';\n}\n\nvoid Deco",
          "old_text": null,
          "new_text": "   *url = '\\0';\n}\n\nvoid Deco",
          "old_line_content": "        return (char*)s;",
          "new_line_content": "    if (str::StartsWith(s, UTF8_BOM))",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": null,
          "new_api": "eturn;\n    // URLs are usuall",
          "old_text": null,
          "new_text": "eturn;\n    // URLs are usuall",
          "old_line_content": "        s += 2;",
          "new_line_content": "    if (str::StartsWith(s, UTF16_BOM)) {",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": null,
          "new_api": "Place",
          "old_text": null,
          "new_text": "Place(urlUtf8);\n    // convert back in plac",
          "old_line_content": "    }",
          "new_line_content": "        return str::conv::ToUtf8((const WCHAR *)s, cchLen);",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": null,
          "new_api": "r::Len(url) + 1);\n}\n\nWCHAR *GetFul",
          "old_text": null,
          "new_text": "r::Len(url) + 1);\n}\n\nWCHAR *GetFul",
          "old_line_content": "        return (char*)s;",
          "new_line_content": "    if (isLegalUTF8String(&tmp, tmp + len))",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": null,
          "new_api": "ace",
          "old_text": null,
          "new_text": "ace(path)",
          "old_line_content": "}",
          "new_line_content": "    return str::conv::ToUtf8(uni.Get());",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": null,
          "new_api": "url));\n    str::TransChars(path, L\"#?\", L\"\\0\\0\");\n    WCHAR *",
          "old_text": null,
          "new_text": "url));\n    str::TransChars(path, L\"#?\", L\"\\0\\0\");\n    WCHAR *",
          "old_line_content": "}",
          "new_line_content": "    return WideCharToMultiByte(cp, 0, s, -1, buf, cbBufSize, NULL, NULL);",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": null,
          "new_api": "\\\\' == base[-1])\n            break;\n    }\n    if (",
          "old_text": null,
          "new_text": "\\\\' == base[-1])\n            break;\n    }\n    if (",
          "old_line_content": "}",
          "new_line_content": "    return MultiByteToWideChar(cp, 0, s, -1, buf, cchBufSize);",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": null,
          "new_api": "d int->string.\n// it's",
          "old_text": null,
          "new_text": "d int->string.\n// it's ",
          "old_line_content": "    return colon && (!hash || hash > colon);",
          "new_line_content": "    const WCHAR *hash = str::FindChar(url, '#');",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": null,
          "new_api": "ad: linear scanning of memory",
          "old_text": null,
          "new_text": "ad: linear scanning of memory ",
          "old_line_content": "            *url = (char)val;",
          "new_line_content": "        if (*src == '%' && str::Parse(src, \"%%%2x\", &val)) {",
          "content_same": false
        },
        {
          "line": 1483,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "        if (NULL == s)",
          "new_line_content": "        s = StrEqWeird(s, toFind);",
          "content_same": false
        },
        {
          "line": 1365,
          "old_api": null,
          "new_api": "kipStr",
          "old_text": null,
          "new_text": "kipStr(const char *& s)",
          "old_line_content": "        return;",
          "new_line_content": "    if (!str::FindChar(url, '%'))",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": null,
          "new_api": "ns end of s + 1\nstatic",
          "old_text": null,
          "new_text": "ns end of s + 1\nstatic",
          "old_line_content": "    // convert back in place",
          "new_line_content": "    DecodeInPlace(urlUtf8);",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "        if (NULL == s)",
          "new_line_content": "        s = StrEqWeird(s, toFind);",
          "content_same": false
        },
        {
          "line": 1372,
          "old_api": null,
          "new_api": "{",
          "old_text": null,
          "new_text": " {\n          ",
          "old_line_content": "}",
          "new_line_content": "    MultiByteToWideChar(CP_UTF8, 0, urlUtf8, -1, url, (int)str::Len(url) + 1);",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": null,
          "new_api": "s++",
          "old_text": null,
          "new_text": "                s++",
          "old_line_content": "    return path;",
          "new_line_content": "    DecodeInPlace(path);",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": null,
          "new_api": "end of s + 1",
          "old_text": null,
          "new_text": " end of s + 1\n",
          "old_line_content": "    for (; base > path; base--) {",
          "new_line_content": "    WCHAR *base = path + str::Len(path);",
          "content_same": false
        },
        {
          "line": 1392,
          "old_api": null,
          "new_api": "c = *s++;",
          "old_text": null,
          "new_text": "     c = *s++;\n   ",
          "old_line_content": "        return NULL;",
          "new_line_content": "    if (str::IsEmpty(base))",
          "content_same": false
        },
        {
          "line": 1395,
          "old_api": null,
          "new_api": "return NULL",
          "old_text": null,
          "new_text": "   return NULL",
          "old_line_content": "}",
          "new_line_content": "    return str::Dup(base);",
          "content_same": false
        },
        {
          "line": 1273,
          "old_api": null,
          "new_api": "n))\n        return (char*)s",
          "old_text": null,
          "new_text": "n))\n        return (char*)s",
          "old_line_content": "}",
          "new_line_content": "    return isLegalUTF8(source, length);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1282,
          "old_api": "ultiByteToWideChar",
          "new_api": null,
          "old_text": "ultiByteToWideChar(cp, 0, s,",
          "new_text": null,
          "old_line_content": "        if (length > sourceEnd - *source || !isLegalUTF8(*source, length))",
          "new_line_content": "        int length = trailingBytesForUTF8[**source] + 1;",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": "emedy for any claim will be exchange of defective medi",
          "new_api": null,
          "old_text": "emedy for any claim will be exchange of defective medi",
          "new_text": null,
          "old_line_content": "    int cchConverted = MultiByteToWideChar(CP_UTF8, 0, s, (int)sLen, NULL, 0);",
          "new_line_content": "    int iCbLen = (int)cbLen;",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "Inc. hereby grants the right to freely use the information\n * suppl",
          "new_api": null,
          "old_text": "Inc. hereby grants the right to freely use the information\n * suppl",
          "new_text": null,
          "old_line_content": "    MultiByteToWideChar(CP_UTF8, 0, s, (int)sLen, bufOut, cchConverted);",
          "new_line_content": "        cchConverted = (int)cchBufOutSize - 1;",
          "content_same": false
        },
        {
          "line": 1171,
          "old_api": "nal distribution as long as this notice",
          "new_api": null,
          "old_text": "nal distribution as long as this notice",
          "new_text": null,
          "old_line_content": "    CrashIf(!bufOut || (0 == cbBufOutSize));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1301,
          "old_api": "src += 2;",
          "new_api": null,
          "old_text": "  src += 2;",
          "new_text": null,
          "old_line_content": "        len = str::Len(s);",
          "new_line_content": "    if (0 == len)",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": "g bytes that are supposed to follow it.\n * Note that *legal* UTF-8 valu",
          "new_api": null,
          "old_text": "g bytes that are supposed to follow it.\n * Note that *legal* UTF-8 valu",
          "new_text": null,
          "old_line_content": "    WideCharToMultiByte(CP_UTF8, 0, s, -1, bufOut, cbConverted, NULL, NULL);",
          "new_line_content": "        cbConverted = (int)cbBufOutSize - 1;",
          "content_same": false
        },
        {
          "line": 1306,
          "old_api": "*url = '\\0';\n}\n\nvoid Dec",
          "new_api": null,
          "old_text": "    *url = '\\0';\n}\n\nvoid Dec",
          "new_text": null,
          "old_line_content": "    if (str::StartsWith(s, UTF8_BOM))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1311,
          "old_api": "return;\n    // URLs are usual",
          "new_api": null,
          "old_text": "return;\n    // URLs are usual",
          "new_text": null,
          "old_line_content": "    if (str::StartsWith(s, UTF16_BOM)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": "nPlace",
          "new_api": null,
          "old_text": "nPlace(urlUtf8);\n    // convert back in pla",
          "new_text": null,
          "old_line_content": "        return str::conv::ToUtf8((const WCHAR *)s, cchLen);",
          "new_line_content": "        int cchLen = (int)((len - 2) / 2);",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": "tr::Len(url) + 1);\n}\n\nWCHAR *GetFu",
          "new_api": null,
          "old_text": "tr::Len(url) + 1);\n}\n\nWCHAR *GetFu",
          "new_text": null,
          "old_line_content": "    if (isLegalUTF8String(&tmp, tmp + len))",
          "new_line_content": "    const UTF8 *tmp = (const UTF8*)s;",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": "lace",
          "new_api": null,
          "old_text": "lace(path",
          "new_text": null,
          "old_line_content": "    return str::conv::ToUtf8(uni.Get());",
          "new_line_content": "    ScopedMem<WCHAR> uni(str::conv::FromAnsi(s, len));",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": "(url));\n    str::TransChars(path, L\"#?\", L\"\\0\\0\");\n    WCHAR",
          "new_api": null,
          "old_text": "(url));\n    str::TransChars(path, L\"#?\", L\"\\0\\0\");\n    WCHAR ",
          "new_text": null,
          "old_line_content": "    return WideCharToMultiByte(cp, 0, s, -1, buf, cbBufSize, NULL, NULL);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1332,
          "old_api": "'\\\\' == base[-1])\n            break;\n    }\n    if",
          "new_api": null,
          "old_text": "'\\\\' == base[-1])\n            break;\n    }\n    if ",
          "new_text": null,
          "old_line_content": "    return MultiByteToWideChar(cp, 0, s, -1, buf, cchBufSize);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": "ze-efficient implementa",
          "new_api": null,
          "old_text": "ze-efficient implementa",
          "new_text": null,
          "old_line_content": "    const WCHAR *colon = str::FindChar(url, ':');",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1352,
          "old_api": "bad: linear scanning of memory",
          "new_api": null,
          "old_text": "bad: linear scanning of memory",
          "new_text": null,
          "old_line_content": "        if (*src == '%' && str::Parse(src, \"%%%2x\", &val)) {",
          "new_line_content": "        int val;",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "        s = StrEqWeird(s, toFind);",
          "new_line_content": "    while (*s) {",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": "SkipStr",
          "new_api": null,
          "old_text": "SkipStr(const char *& s",
          "new_text": null,
          "old_line_content": "    if (!str::FindChar(url, '%'))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": "rns end of s + 1\nstati",
          "new_api": null,
          "old_text": "rns end of s + 1\nstati",
          "new_text": null,
          "old_line_content": "    DecodeInPlace(urlUtf8);",
          "new_line_content": "    ScopedMem<char> urlUtf8(str::conv::ToUtf8(url));",
          "content_same": false
        },
        {
          "line": 1370,
          "old_api": ", const char",
          "new_api": null,
          "old_text": ", const char ",
          "new_text": null,
          "old_line_content": "    CrashIf(str::Len(url) >= INT_MAX);",
          "new_line_content": "    // convert back in place",
          "content_same": false
        },
        {
          "line": 1498,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "        s = StrEqWeird(s, toFind);",
          "new_line_content": "    while (*s) {",
          "content_same": false
        },
        {
          "line": 1376,
          "old_api": "}",
          "new_api": null,
          "old_text": "        }\n   ",
          "new_text": null,
          "old_line_content": "    WCHAR *path = str::Dup(url);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1385,
          "old_api": "NULL if s is the same as toFind\n// I",
          "new_api": null,
          "old_text": " NULL if s is the same as toFind\n// I",
          "new_text": null,
          "old_line_content": "    str::TransChars(path, L\"#?\", L\"\\0\\0\");",
          "new_line_content": "    ScopedMem<WCHAR> path(str::Dup(url));",
          "content_same": false
        },
        {
          "line": 1391,
          "old_api": "c = *s++;",
          "new_api": null,
          "old_text": "      c = *s++;\n  ",
          "new_text": null,
          "old_line_content": "    if (str::IsEmpty(base))",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1393,
          "old_api": "if (0 == *toFind",
          "new_api": null,
          "old_text": "   if (0 == *toFind",
          "new_text": null,
          "old_line_content": "    DecodeInPlace(base);",
          "new_line_content": "        return NULL;",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": "en))\n        return (char*)",
          "new_api": null,
          "old_text": "en))\n        return (char*)",
          "new_text": null,
          "old_line_content": "    return isLegalUTF8(source, length);",
          "new_line_content": "    if (source+length > sourceEnd) return false;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 16,
      "total_additions": 24,
      "total_deletions": 25,
      "total_api_changes": 65
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 65,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          1163,
          1165,
          1158
        ]
      }
    },
    "api_calls_before": 296,
    "api_calls_after": 295,
    "diff_info": {
      "added_lines": 5,
      "removed_lines": 4,
      "total_diff_lines": 24
    }
  }
}