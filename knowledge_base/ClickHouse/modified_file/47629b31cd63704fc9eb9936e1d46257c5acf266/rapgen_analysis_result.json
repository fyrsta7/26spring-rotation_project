{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/47629b31cd63704fc9eb9936e1d46257c5acf266",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/47629b31cd63704fc9eb9936e1d46257c5acf266/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/47629b31cd63704fc9eb9936e1d46257c5acf266/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/47629b31cd63704fc9eb9936e1d46257c5acf266/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 60,
          "old_api": "size",
          "new_api": "empty",
          "old_text": ".size() == 0)\n\t\treal_column_names",
          "new_text": ".empty())\n\t\treal_column_names.pus",
          "old_line_content": null,
          "new_line_content": "\t\t\tvirt_column_names.push_back(name);",
          "content_same": true
        },
        {
          "line": 63,
          "old_api": "один виртуальный столбец",
          "new_api": "dition from WHERE to PREW",
          "old_text": "один виртуальный столбец",
          "new_text": "dition from WHERE to PREW",
          "old_line_content": "\tif (real_column_names.size() == 0)",
          "new_line_content": "\tif (real_column_names.empty())",
          "content_same": false
        },
        {
          "line": 64,
          "old_api": "ils::filterBlockWithQ",
          "new_api": "if (select.where_exp",
          "old_text": "ils::filterBlockWithQ",
          "new_text": "\tif (select.where_exp",
          "old_line_content": null,
          "new_line_content": "\t\treal_column_names.push_back(ExpressionActions::getSmallestColumn(data.getColumnsList()));",
          "content_same": true
        },
        {
          "line": 66,
          "old_api": "_block, data.context);\n\n\tstd::mul",
          "new_api": "ssion)\n\t\t\tMergeTreeWhereOptimizer{sel",
          "old_text": "_block, data.context);\n\n\tstd::mul",
          "new_text": "ssion)\n\t\t\tMergeTreeWhereOptimizer{sel",
          "old_line_content": "\tBlock virtual_columns_block = getBlockWithVirtualColumns(parts);",
          "new_line_content": "\tASTSelectQuery & select = *typeid_cast<ASTSelectQuery*>(&*query);",
          "content_same": false
        },
        {
          "line": 77,
          "old_api": "овие на _part.\n\t{\n\t\tauto",
          "new_api": "key_condition",
          "old_text": "овие на _part.\n\t{\n\t\tauto ",
          "new_text": "key_condition(",
          "old_line_content": "\tPKCondition key_condition(query, data.context, data.getColumnsList(), data.getSortDescription());",
          "new_line_content": "\t\tVirtualColumnUtils::filterBlockWithQuery(query->clone(), virtual_columns_block, data.context);",
          "content_same": false
        },
        {
          "line": 90,
          "old_api": "ionPtr;\n\tASTFunctionPtr filter_funct",
          "new_api": ".\n\tNames colu",
          "old_text": "ionPtr;\n\tASTFunctionPtr filter_funct",
          "new_text": ".\n\tNames colu",
          "old_line_content": "\t\t\tField left = static_cast<UInt64>(part->left_date);",
          "new_line_content": "\t\tparts.clear();",
          "content_same": false
        },
        {
          "line": 127,
          "old_api": "ample size:",
          "new_api": "double>(requested_count)",
          "old_text": "ample size: ",
          "new_text": "double>(requested_count)",
          "old_line_content": "\t\t\tfor (size_t i = 0; i < parts.size(); ++i)",
          "new_line_content": "\t\t\tLOG_DEBUG(log, \"Preliminary index scan with condition: \" << key_condition.toString());",
          "content_same": false
        },
        {
          "line": 132,
          "old_api": "me",
          "new_api": "getByName",
          "old_text": "me()).type;\n\n",
          "new_text": "yExpression()->getSampleBlock().getByName(data.sa",
          "old_line_content": "\t\t\t\tfor (size_t j = 0; j < ranges.size(); ++j)",
          "new_line_content": "\t\t\t\tMarkRanges ranges = markRangesFromPkRange(part->index, key_condition);",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": "getName",
          "new_api": "32\")\n\t\t\tsampling_column_max = std::n",
          "old_text": "::max();\n\t\telse if (type->getName() == \"UInt16\")\n\t\t\tsampl",
          "new_text": "32\")\n\t\t\tsampling_column_max = std::n",
          "old_line_content": "\t\t\tLOG_DEBUG(log, \"Selected relative sample size: \" << size);",
          "new_line_content": "\t\t\tsize = std::min(1., static_cast<double>(requested_count) / total_count);",
          "content_same": false
        },
        {
          "line": 145,
          "old_api": "ion",
          "new_api": "td::numeric_limits<UInt8>::max();\n\t\telse",
          "old_text": "ion(\"Invalid sa",
          "new_text": "td::numeric_limits<UInt8>::max();\n\t\telse\n",
          "old_line_content": "\t\tif (type->getName() == \"UInt64\")",
          "new_line_content": "\t\tDataTypePtr type = data.getPrimaryExpression()->getSampleBlock().getByName(data.sampling_expression->getColumnName()).type;",
          "content_same": false
        },
        {
          "line": 147,
          "old_api": "teger type.\", E",
          "new_api": "ion",
          "old_text": "teger type.\", E",
          "new_text": "ion(\"Invalid sa",
          "old_line_content": "\t\telse if (type->getName() == \"UInt32\")",
          "new_line_content": "\t\tif (type->getName() == \"UInt64\")",
          "content_same": false
        },
        {
          "line": 148,
          "old_api": "ILTER);\n\n\t\t/// Добавим условие, чт",
          "new_api": "getName",
          "old_text": "ILTER);\n\n\t\t/// Добавим условие, чт",
          "new_text": "s: \" + type->getName() + \". Must b",
          "old_line_content": "\t\t\tsampling_column_max = std::numeric_limits<UInt32>::max();",
          "new_line_content": "\t\t\tsampling_column_max = std::numeric_limits<UInt64>::max();",
          "content_same": false
        },
        {
          "line": 149,
          "old_api": "е что-нибудь пр",
          "new_api": "teger type.\", E",
          "old_text": "е что-нибудь пр",
          "new_text": "teger type.\", E",
          "old_line_content": "\t\telse if (type->getName() == \"UInt16\")",
          "new_line_content": "\t\telse if (type->getName() == \"UInt32\")",
          "content_same": false
        },
        {
          "line": 150,
          "old_api": "ng_column_value_limit = static_cas",
          "new_api": "ILTER);\n\n\t\t/// Добавим условие, чт",
          "old_text": "ng_column_value_limit = static_cas",
          "new_text": "ILTER);\n\n\t\t/// Добавим условие, чт",
          "old_line_content": "\t\t\tsampling_column_max = std::numeric_limits<UInt16>::max();",
          "new_line_content": "\t\t\tsampling_column_max = std::numeric_limits<UInt32>::max();",
          "content_same": false
        },
        {
          "line": 151,
          "old_api": "e * sampling_co",
          "new_api": "е что-нибудь пр",
          "old_text": "e * sampling_co",
          "new_text": "е что-нибудь пр",
          "old_line_content": "\t\telse if (type->getName() == \"UInt8\")",
          "new_line_content": "\t\telse if (type->getName() == \"UInt16\")",
          "content_same": false
        },
        {
          "line": 152,
          "old_api": "dition",
          "new_api": "ng_column_value_limit = static_cas",
          "old_text": "dition(data.sampling_expression->",
          "new_text": "ng_column_value_limit = static_cas",
          "old_line_content": "\t\t\tsampling_column_max = std::numeric_limits<UInt8>::max();",
          "new_line_content": "\t\t\tsampling_column_max = std::numeric_limits<UInt16>::max();",
          "content_same": false
        },
        {
          "line": 154,
          "old_api": "throw Exceptio",
          "new_api": "dition",
          "old_text": "\tthrow Exceptio",
          "new_text": "dition(data.sampling_expression->",
          "old_line_content": "\t\t\tthrow Exception(\"Invalid sampling column type in storage parameters: \" + type->getName() + \". Must be unsigned integer type.\", ErrorCodes::ILLEGAL_TYPE_OF_COLUMN_FOR_FILTER);",
          "new_line_content": "\t\t\tsampling_column_max = std::numeric_limits<UInt8>::max();",
          "content_same": false
        },
        {
          "line": 159,
          "old_api": "ion = new ASTFunction;\n\t\tfilter_function->name = \"lessOrEqua",
          "new_api": "ression);\n\t\tfilter_function_args->children.push",
          "old_text": "ion = new ASTFunction;\n\t\tfilter_function->name = \"lessOrEqua",
          "new_text": "ression);\n\t\tfilter_function_args->children.push",
          "old_line_content": "\t\t\tRange::createRightBounded(sampling_column_value_limit, true)))",
          "new_line_content": "\t\tsampling_column_value_limit = static_cast<UInt64>(size * sampling_column_max);",
          "content_same": false
        },
        {
          "line": 160,
          "old_api": "r_function->arguments = filter_function_args;\n\t\tfilter_function->children.p",
          "new_api": "sampling_column_value_limit));\n\n\t\tfilter_",
          "old_text": "r_function->arguments = filter_function_args;\n\t\tfilter_function->children.p",
          "new_text": "sampling_column_value_limit));\n\n\t\tfilter_",
          "old_line_content": "\t\t\tthrow Exception(\"Sampling column not in primary key\", ErrorCodes::ILLEGAL_COLUMN);",
          "new_line_content": "\t\tif (!key_condition.addCondition(data.sampling_expression->getColumnName(),",
          "content_same": false
        },
        {
          "line": 173,
          "old_api": "ondition: \" << key_co",
          "new_api": "erase",
          "old_text": "ondition: \" << key_co",
          "new_text": "_read.erase(std::unique(column_names_to_read.begin(), column_na",
          "old_line_content": "\t\tfilter_expression = ExpressionAnalyzer(filter_function, data.context, data.getColumnsList()).getActions(false);",
          "new_line_content": "\t\tfilter_function->children.push_back(filter_function->arguments);",
          "content_same": false
        },
        {
          "line": 178,
          "old_api": "getActions",
          "new_api": "ions;\n\tString prewhere_column;\n\tif (sel",
          "old_text": "= analyzer.getActions(fals",
          "new_text": "ions;\n\tString prewhere_column;\n\tif (sel",
          "old_line_content": "\t\tstd::sort(column_names_to_read.begin(), column_names_to_read.end());",
          "new_line_content": "\t\tstd::vector<String> add_columns = filter_expression->getRequiredColumns();",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": "осы в PREWHERE, можно тут",
          "new_api": "ion, data.context",
          "old_text": "осы в PREWHERE, можно тут ",
          "new_text": "ion, data.context",
          "old_line_content": "\t\tcolumn_names_to_read.erase(std::unique(column_names_to_read.begin(), column_names_to_read.end()), column_names_to_read.end());",
          "new_line_content": "\t\tcolumn_names_to_read.insert(column_names_to_read.end(), add_columns.begin(), add_columns.end());",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": "empty",
          "new_api": "ges",
          "old_text": "n);\n\n\t\tif (!ranges.ranges.empty())\n\t\t{\n\t\t\tp",
          "new_text": "ges(part, (*part_inde",
          "old_line_content": "\t\tprewhere_column = select.prewhere_expression->getColumnName();",
          "new_line_content": "\t\tExpressionAnalyzer analyzer(select.prewhere_expression, data.context, data.getColumnsList());",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": "uiredColumns",
          "new_api": "r<String> add_columns = data.getPrimaryExpression",
          "old_text": "uiredColumns();\n\t\tcol",
          "new_text": "r<String> add_columns = data.getPrimaryExpression",
          "old_line_content": "\t\tif (!ranges.ranges.empty())",
          "new_line_content": "\t\tranges.ranges = markRangesFromPkRange(part->index, key_condition);",
          "content_same": false
        },
        {
          "line": 209,
          "old_api": "insert",
          "new_api": "uiredColumns",
          "old_text": "_to_read.insert(column_names_to_rea",
          "new_text": "uiredColumns();\n\t\tcol",
          "old_line_content": "\t\t\tparts_with_ranges.push_back(ranges);",
          "new_line_content": "\t\tif (!ranges.ranges.empty())",
          "content_same": false
        },
        {
          "line": 211,
          "old_api": "begin",
          "new_api": "insert",
          "old_text": ".begin(), add_column",
          "new_text": "_to_read.insert(column_names_to_rea",
          "old_line_content": "\t\t\tsum_ranges += ranges.ranges.size();",
          "new_line_content": "\t\t\tparts_with_ranges.push_back(ranges);",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": "n,\n\t\t\tvirt_column_names);\n\t}\n\n\tif (select.sample",
          "new_api": "parts_with_ranges,\n\t\t\tthreads,\n\t\t\tcolumn_names",
          "old_text": "n,\n\t\t\tvirt_column_names);\n\t}\n\n\tif (select.sample",
          "new_text": "\t\t\tparts_with_ranges,\n\t\t\tthreads,\n\t\t\tcolumn_names",
          "old_line_content": "\t\tcolumn_names_to_read.push_back(data.sign_column);",
          "new_line_content": "\t\tstd::vector<String> add_columns = data.getPrimaryExpression()->getRequiredColumns();",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": "); ++i)\n\t\t{\n\t\t\tBlockInputS",
          "new_api": "ons,\n\t\t\tprewhere_",
          "old_text": "); ++i)\n\t\t{\n\t\t\tBlockInputS",
          "new_text": "ons,\n\t\t\tprewhere_",
          "old_line_content": "\t\tstd::sort(column_names_to_read.begin(), column_names_to_read.end());",
          "new_line_content": "\t\tcolumn_names_to_read.insert(column_names_to_read.end(), add_columns.begin(), add_columns.end());",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": "tream",
          "new_api": "n,\n\t\t\tvirt_column_names);\n\t}\n\n\tif (select.sample",
          "old_text": "tream(original_stream, fil",
          "new_text": "n,\n\t\t\tvirt_column_names);\n\t}\n\n\tif (select.sample",
          "old_line_content": "\t\tcolumn_names_to_read.erase(std::unique(column_names_to_read.begin(), column_names_to_read.end()), column_names_to_read.end());",
          "new_line_content": "\t\tcolumn_names_to_read.push_back(data.sign_column);",
          "content_same": false
        },
        {
          "line": 233,
          "old_api": "getColumnName",
          "new_api": "tream",
          "old_text": "on);\n\t\t\tBlockInputStreamPtr filter_stream = new FilterBlockInputStream(expression_stream, filter_function->getColumnName());\n\t\t\tres[i] = filter_stream;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nBlockInputStreams MergeTreeDataSele",
          "new_text": "tream(original_stream, fil",
          "old_line_content": "\t\tres = spreadMarkRangesAmongThreadsFinal(",
          "new_line_content": "\t\tcolumn_names_to_read.erase(std::unique(column_names_to_read.begin(), column_names_to_read.end()), column_names_to_read.end());",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": "BlockInpu",
          "new_api": "mpty",
          "old_text": "\t\t\tBlockInpu",
          "new_text": "mpty(); ++i)",
          "old_line_content": "\tfor (size_t i = 0; i < parts.size(); ++i)",
          "new_line_content": "\tstd::vector<size_t> sum_marks_in_parts(parts.size());",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": "_back",
          "new_api": "parts.po",
          "old_text": "_back();\n\t\t\t",
          "new_text": "\t\t\t\t\tparts.po",
          "old_line_content": "\t\t\t\tRangesInDataPart & part = parts.back();",
          "new_line_content": "\t\t\twhile (need_marks > 0 && !parts.empty())",
          "content_same": false
        },
        {
          "line": 352,
          "old_api": "lumn == \"_part_ind",
          "new_api": "back",
          "old_text": "lumn == \"_part_ind",
          "new_text": "tColumnBlockInputStream<String>(\n\t\t\t\t\t\t\tstreams.back(), new DataTypeString, part.data_part->name, \"_",
          "old_line_content": "\t\t\t\t\t\tMarkRange & range = part.ranges.back();",
          "new_line_content": "\t\t\t\t\t\t\tthrow Exception(\"Unexpected end of ranges while spreading marks among threads\", ErrorCodes::LOGICAL_ERROR);",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": "e;\n\n\tExpressio",
          "new_api": "i].ranges[j].e",
          "old_text": "e;\n\n\tExpressio",
          "new_text": "i].ranges[j].e",
          "old_line_content": "\t\t\t\t\t\tstreams.back() = new AddingConstColumnBlockInputStream<UInt64>(",
          "new_line_content": "\t\t\t\t\t\t\tstreams.back(), new DataTypeString, part.data_part->name, \"_part\");",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": "size",
          "new_api": "ize_t part_index = 0; par",
          "old_text": "s.size(); ++part_index)\n\t{\n\t\tRangesInDataPart & pa",
          "new_text": "ize_t part_index = 0; par",
          "old_line_content": "\t\t\t\tres.push_back(new ConcatBlockInputStream(streams));",
          "new_line_content": "\t\t\t\tres.push_back(streams[0]);",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": "etColumnsList",
          "new_api": "ASTIdentifier::Co",
          "old_text": "etColumnsList()).g",
          "new_text": " ASTIdentifier::Co",
          "old_line_content": "\telse if (to_collapse.size() > 1)",
          "new_line_content": "\tif (to_collapse.size() == 1)",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": "ает набор диапазонов засе",
          "new_api": "ne->type = new DataTypeInt8;\n\tone->value = Field(static_cast<Int64>(1));\n\n\tout_expression = ExpressionAnalyzer(function_ptr, data.con",
          "old_text": "ает набор диапазонов засе",
          "new_text": "ne->type = new DataTypeInt8;\n\tone->value = Field(static_cast<Int64>(1));\n\n\tout_expression = ExpressionAnalyzer(function_ptr, data.con",
          "old_line_content": "\t\tres.push_back(new CollapsingFinalBlockInputStream(to_collapse, data.getSortDescription(), data.sign_column));",
          "new_line_content": "\t\tres.push_back(new FilterBlockInputStream(new ExpressionBlockInputStream(to_collapse[0], sign_filter_expression), sign_filter_column));",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": "ге берем левый отрезок и проверяем, под",
          "new_api": ", самый левый наверху (back).\n\t\t\t* На каждо",
          "old_text": "ге берем левый отрезок и проверяем, под",
          "new_text": ", самый левый наверху (back).\n\t\t\t* На каждо",
          "old_line_content": "\targuments->children.push_back(sign_ptr);",
          "new_line_content": "\tfunction->children.push_back(arguments_ptr);",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": "sh_back",
          "new_api": "его в ответ и выбрас",
          "old_text": "sh_back(MarkRange(0, ",
          "new_text": " его в ответ и выбрас",
          "old_line_content": "\tout_expression = ExpressionAnalyzer(function_ptr, data.context, data.getColumnsList()).getActions(false);",
          "new_line_content": "\tone->value = Field(static_cast<Int64>(1));",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": "back",
          "new_api": "м новый диапазон.\n\t\t\t\tif (",
          "old_text": "begin - res.back().end > ",
          "new_text": "м новый диапазон.\n\t\t\t\tif (",
          "old_line_content": "\t\tres.push_back(MarkRange(0, marks_count));",
          "new_line_content": "\tif (key_condition.alwaysTrue())",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 519,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\t\telse",
          "new_line_content": "\t\t\t\tif (res.empty() || range.begin - res.back().end > min_marks_for_seek)",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\telse",
          "new_line_content": "\t\t\t\t\tres.back().end = range.end;",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\t\tranges_stack.push_back(MarkRange(range.begin, end));",
          "content_same": false
        },
        {
          "line": 73,
          "old_api": null,
          "new_api": "_block, data.context);\n\n\tstd::mul",
          "old_text": null,
          "new_text": "_block, data.context);\n\n\tstd::mul",
          "old_line_content": "",
          "new_line_content": "\tBlock virtual_columns_block = getBlockWithVirtualColumns(parts);",
          "content_same": false
        },
        {
          "line": 76,
          "old_api": null,
          "new_api": "processed_stage = Query",
          "old_text": null,
          "new_text": "\n\tprocessed_stage = Query",
          "old_line_content": "",
          "new_line_content": "\tif (!virt_column_names.empty())",
          "content_same": false
        },
        {
          "line": 79,
          "old_api": null,
          "new_api": "getColumnsList",
          "old_text": null,
          "new_text": "PKCondition date_condition(query, data.context, data.getColumnsList(), SortDescription(",
          "old_line_content": "",
          "new_line_content": "\tstd::multiset<String> values = VirtualColumnUtils::extractSingleValueFromBlock<String>(virtual_columns_block, \"_part\");",
          "content_same": false
        },
        {
          "line": 81,
          "old_api": null,
          "new_api": "ortColumnDescription",
          "old_text": null,
          "new_text": "ortColumnDescription(data.dat",
          "old_line_content": "\t{",
          "new_line_content": "\tdata.check(real_column_names);",
          "content_same": false
        },
        {
          "line": 84,
          "old_api": null,
          "new_api": "овие на _part.\n\t{\n\t\tauto",
          "old_text": null,
          "new_text": "овие на _part.\n\t{\n\t\tauto ",
          "old_line_content": "",
          "new_line_content": "\tPKCondition key_condition(query, data.context, data.getColumnsList(), data.getSortDescription());",
          "content_same": false
        },
        {
          "line": 85,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": ".find(part->name) == values.end())\n\t\t\t\tcontinue",
          "old_line_content": "\t\tfor (const auto & part : prev_parts)",
          "new_line_content": "\tPKCondition date_condition(query, data.context, data.getColumnsList(), SortDescription(1, SortColumnDescription(data.date_column_name, 1)));",
          "content_same": false
        },
        {
          "line": 94,
          "old_api": null,
          "new_api": "typedef Poco",
          "old_text": null,
          "new_text": "typedef Poco",
          "old_line_content": "\t\t\t\tcontinue;",
          "new_line_content": "\t\t\tif (values.find(part->name) == values.end())",
          "content_same": false
        },
        {
          "line": 97,
          "old_api": null,
          "new_api": "ionPtr;\n\tASTFunctionPtr filter_funct",
          "old_text": null,
          "new_text": "ionPtr;\n\tASTFunctionPtr filter_funct",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tField left = static_cast<UInt64>(part->left_date);",
          "content_same": false
        },
        {
          "line": 98,
          "old_api": null,
          "new_api": "ionsPtr filter_expression;\n\n\tif (sele",
          "old_text": null,
          "new_text": "ionsPtr filter_expression;\n\n\tif (sele",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\tField right = static_cast<UInt64>(part->right_date);",
          "content_same": false
        },
        {
          "line": 100,
          "old_api": null,
          "new_api": "ize)\n\t{\n\t\tdouble size = apply_visitor(FieldVis",
          "old_text": null,
          "new_text": "ize)\n\t{\n\t\tdouble size = apply_visitor(FieldVis",
          "old_line_content": "\t/// Семплирование.",
          "new_line_content": "\t\t\tif (!date_condition.mayBeTrueInRange(&left, &right))",
          "content_same": false
        },
        {
          "line": 103,
          "old_api": null,
          "new_api": "double>(),\n\t\t\ttypeid_",
          "old_text": null,
          "new_text": "double>(),\n\t\t\ttypeid_",
          "old_line_content": "\ttypedef Poco::SharedPtr<ASTFunction> ASTFunctionPtr;",
          "new_line_content": "\t\t\tparts.push_back(part);",
          "content_same": false
        },
        {
          "line": 116,
          "old_api": null,
          "new_api": "ко строк мы бы прочли без семплирован",
          "old_text": null,
          "new_text": "ко строк мы бы прочли без семплирован",
          "old_line_content": "",
          "new_line_content": "\t\tdouble size = apply_visitor(FieldVisitorConvertToNumber<double>(),",
          "content_same": false
        },
        {
          "line": 117,
          "old_api": null,
          "new_api": "LOG_DEBUG(log, \"Preliminary index scan with",
          "old_text": null,
          "new_text": "\t\tLOG_DEBUG(log, \"Preliminary index scan with",
          "old_line_content": "\t\tif (size < 0)",
          "new_line_content": "\t\t\ttypeid_cast<ASTLiteral&>(*select.sample_size).value);",
          "content_same": false
        },
        {
          "line": 120,
          "old_api": null,
          "new_api": "ring",
          "old_text": null,
          "new_text": "ring());\n\t\t\tsize_t total_count = 0;\n\t\t\tfor (size_t i = 0; i < parts.",
          "old_line_content": "\t\tif (size > 1)",
          "new_line_content": "\t\t\tthrow Exception(\"Negative sample size\", ErrorCodes::ARGUMENT_OUT_OF_BOUND);",
          "content_same": false
        },
        {
          "line": 124,
          "old_api": null,
          "new_api": "omPkRange",
          "old_text": null,
          "new_text": "omPkRange(part->index, key_condition);\n\n\t\t\t\tf",
          "old_line_content": "\t\t\t/// Узнаем, сколько строк мы бы прочли без семплирования.",
          "new_line_content": "\t\t\tsize_t requested_count = apply_visitor(FieldVisitorConvertToNumber<UInt64>(), typeid_cast<ASTLiteral&>(*select.sample_size).value);",
          "content_same": false
        },
        {
          "line": 129,
          "old_api": null,
          "new_api": "ample size:",
          "old_text": null,
          "new_text": "ample size: ",
          "old_line_content": "\t\t\t\tMergeTreeData::DataPartPtr & part = parts[i];",
          "new_line_content": "\t\t\tfor (size_t i = 0; i < parts.size(); ++i)",
          "content_same": false
        },
        {
          "line": 134,
          "old_api": null,
          "new_api": "me",
          "old_text": null,
          "new_text": "me()).type;\n\n",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\tfor (size_t j = 0; j < ranges.size(); ++j)",
          "content_same": false
        },
        {
          "line": 141,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "::max();\n\t\telse if (type->getName() == \"UInt16\")\n\t\t\tsampl",
          "old_line_content": "",
          "new_line_content": "\t\t\tLOG_DEBUG(log, \"Selected relative sample size: \" << size);",
          "content_same": false
        },
        {
          "line": 153,
          "old_api": null,
          "new_api": "e * sampling_co",
          "old_text": null,
          "new_text": "e * sampling_co",
          "old_line_content": "\t\telse",
          "new_line_content": "\t\telse if (type->getName() == \"UInt8\")",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": null,
          "new_api": "throw Exceptio",
          "old_text": null,
          "new_text": "\tthrow Exceptio",
          "old_line_content": "\t\t/// Добавим условие, чтобы отсечь еще что-нибудь при повторном просмотре индекса.",
          "new_line_content": "\t\t\tthrow Exception(\"Invalid sampling column type in storage parameters: \" + type->getName() + \". Must be unsigned integer type.\", ErrorCodes::ILLEGAL_TYPE_OF_COLUMN_FOR_FILTER);",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": null,
          "new_api": "ion = new ASTFunction;\n\t\tfilter_function->name = \"lessOrEqua",
          "old_text": null,
          "new_text": "ion = new ASTFunction;\n\t\tfilter_function->name = \"lessOrEqua",
          "old_line_content": "",
          "new_line_content": "\t\t\tRange::createRightBounded(sampling_column_value_limit, true)))",
          "content_same": false
        },
        {
          "line": 162,
          "old_api": null,
          "new_api": "r_function->arguments = filter_function_args;\n\t\tfilter_function->children.p",
          "old_text": null,
          "new_text": "r_function->arguments = filter_function_args;\n\t\tfilter_function->children.p",
          "old_line_content": "\t\t/// Выражение для фильтрации: sampling_expression <= sampling_column_value_limit",
          "new_line_content": "\t\t\tthrow Exception(\"Sampling column not in primary key\", ErrorCodes::ILLEGAL_COLUMN);",
          "content_same": false
        },
        {
          "line": 167,
          "old_api": null,
          "new_api": "м столбцы, нужные для sampling_expression.\n\t\tstd::vector<String> a",
          "old_text": null,
          "new_text": "м столбцы, нужные для sampling_expression.\n\t\tstd::vector<String> a",
          "old_line_content": "",
          "new_line_content": "\t\tfilter_function_args->children.push_back(data.sampling_expression);",
          "content_same": false
        },
        {
          "line": 168,
          "old_api": null,
          "new_api": "mn_names_to_r",
          "old_text": null,
          "new_text": "mn_names_to_r",
          "old_line_content": "\t\tfilter_function = new ASTFunction;",
          "new_line_content": "\t\tfilter_function_args->children.push_back(new ASTLiteral(StringRange(), sampling_column_value_limit));",
          "content_same": false
        },
        {
          "line": 175,
          "old_api": null,
          "new_api": "ondition: \" << key_co",
          "old_text": null,
          "new_text": "ondition: \" << key_co",
          "old_line_content": "\t\t/// Добавим столбцы, нужные для sampling_expression.",
          "new_line_content": "\t\tfilter_expression = ExpressionAnalyzer(filter_function, data.context, data.getColumnsList()).getActions(false);",
          "content_same": false
        },
        {
          "line": 180,
          "old_api": null,
          "new_api": "getActions",
          "old_text": null,
          "new_text": "= analyzer.getActions(fals",
          "old_line_content": "\t}",
          "new_line_content": "\t\tstd::sort(column_names_to_read.begin(), column_names_to_read.end());",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": null,
          "new_api": "осы в PREWHERE, можно тут",
          "old_text": null,
          "new_text": "осы в PREWHERE, можно тут ",
          "old_line_content": "",
          "new_line_content": "\t\tcolumn_names_to_read.erase(std::unique(column_names_to_read.begin(), column_names_to_read.end()), column_names_to_read.end());",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": null,
          "new_api": "а потом их выполнить.\n\t}",
          "old_text": null,
          "new_text": "а потом их выполнить.\n\t}",
          "old_line_content": "",
          "new_line_content": "\tLOG_DEBUG(log, \"Key condition: \" << key_condition.toString());",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": null,
          "new_api": "/// Найдем, какой диапаз",
          "old_text": null,
          "new_text": "\t/// Найдем, какой диапаз",
          "old_line_content": "\t/// PREWHERE",
          "new_line_content": "\tLOG_DEBUG(log, \"Date condition: \" << date_condition.toString());",
          "content_same": false
        },
        {
          "line": 193,
          "old_api": null,
          "new_api": "markRangesFromPkRange(par",
          "old_text": null,
          "new_text": " markRangesFromPkRange(par",
          "old_line_content": "\t\t/// TODO: Чтобы работали подзапросы в PREWHERE, можно тут сохранить analyzer.getSetsWithSubqueries(), а потом их выполнить.",
          "new_line_content": "\t\tprewhere_actions = analyzer.getActions(false);",
          "content_same": false
        },
        {
          "line": 194,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "n);\n\n\t\tif (!ranges.ranges.empty())\n\t\t{\n\t\t\tp",
          "old_line_content": "\t}",
          "new_line_content": "\t\tprewhere_column = select.prewhere_expression->getColumnName();",
          "content_same": false
        },
        {
          "line": 203,
          "old_api": null,
          "new_api": "ges\");\n\n\tBlo",
          "old_text": null,
          "new_text": "ges\");\n\n\tBlo",
          "old_line_content": "\t\tMergeTreeData::DataPartPtr & part = parts[i];",
          "new_line_content": "\tfor (size_t i = 0; i < parts.size(); ++i)",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": ".begin(), add_column",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\tsum_ranges += ranges.ranges.size();",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "read.push_back(data.",
          "old_line_content": "\t\t\t\tsum_marks += ranges.ranges[j].end - ranges.ranges[j].begin;",
          "new_line_content": "\t\t\tfor (size_t j = 0; j < ranges.ranges.size(); ++j)",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "lumn_names_to_read.end()",
          "old_line_content": "",
          "new_line_content": "\tLOG_DEBUG(log, \"Selected \" << parts.size() << \" parts by date, \" << parts_with_ranges.size() << \" parts by key, \"",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": null,
          "new_api": "); ++i)\n\t\t{\n\t\t\tBlockInputS",
          "old_text": null,
          "new_text": "); ++i)\n\t\t{\n\t\t\tBlockInputS",
          "old_line_content": "",
          "new_line_content": "\t\tstd::sort(column_names_to_read.begin(), column_names_to_read.end());",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": null,
          "new_api": "getColumnName",
          "old_text": null,
          "new_text": "on);\n\t\t\tBlockInputStreamPtr filter_stream = new FilterBlockInputStream(expression_stream, filter_function->getColumnName());\n\t\t\tres[i] = filter_stream;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nBlockInputStreams MergeTreeDataSele",
          "old_line_content": "\t\t\tthreads,",
          "new_line_content": "\t\tres = spreadMarkRangesAmongThreadsFinal(",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": null,
          "new_api": "RangesAmongThreads",
          "old_text": null,
          "new_text": "RangesAmongThreads(\n\tRangesInDataParts parts,\n\tsize_t threads,\n\tconst Names & column_names,\n\tsize_t max_block_size,\n\tbool use_uncompressed_cache,\n\tExpressionActionsPtr prewhere_actions,\n\tconst String & prew",
          "old_line_content": "\t\t\tthreads,",
          "new_line_content": "\t\tres = spreadMarkRangesAmongThreads(",
          "content_same": false
        },
        {
          "line": 260,
          "old_api": null,
          "new_api": "случай пер",
          "old_text": null,
          "new_text": "случай пер",
          "old_line_content": "\t\t\tBlockInputStreamPtr original_stream = res[i];",
          "new_line_content": "\t\tfor (size_t i = 0; i < res.size(); ++i)",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": null,
          "new_api": "т перечислены справа налево, что",
          "old_text": null,
          "new_text": "т перечислены справа налево, что",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tBlockInputStreamPtr filter_stream = new FilterBlockInputStream(expression_stream, filter_function->getColumnName());",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": null,
          "new_api": "(sum_marks",
          "old_text": null,
          "new_text": " (sum_marks",
          "old_line_content": "\t/// Посчитаем засечки для каждого куска.",
          "new_line_content": "\tstd::random_shuffle(parts.begin(), parts.end());",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": null,
          "new_api": "BlockInpu",
          "old_text": null,
          "new_text": "\t\t\tBlockInpu",
          "old_line_content": "\t\t/// Пусть отрезки будут перечислены справа налево, чтобы можно было выбрасывать самый левый отрезок с помощью pop_back().",
          "new_line_content": "\tfor (size_t i = 0; i < parts.size(); ++i)",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": null,
          "new_api": "t >= min_marks_for_co",
          "old_text": null,
          "new_text": "t >= min_marks_for_co",
          "old_line_content": "\t\tsum_marks_in_parts[i] = 0;",
          "new_line_content": "\t\tstd::reverse(parts[i].ranges.begin(), parts[i].ranges.end());",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": null,
          "new_api": "t_read)\n\t\t\t\t\tneed_mark",
          "old_text": null,
          "new_text": "t_read)\n\t\t\t\t\tneed_mark",
          "old_line_content": "\t\t\tMarkRange & range = parts[i].ranges[j];",
          "new_line_content": "\t\tfor (size_t j = 0; j < parts[i].ranges.size(); ++j)",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": null,
          "new_api": "ановим порядо",
          "old_text": null,
          "new_text": "ановим порядо",
          "old_line_content": "\t\t\tsize_t need_marks = min_marks_per_thread;",
          "new_line_content": "\t\tfor (size_t i = 0; i < threads && !parts.empty(); ++i)",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": null,
          "new_api": "_back",
          "old_text": null,
          "new_text": "_back();\n\t\t\t",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tRangesInDataPart & part = parts.back();",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": null,
          "new_api": "по отрезкам куска.",
          "old_text": null,
          "new_text": " по отрезкам куска.\n\t\t\t\t\t",
          "old_line_content": "\t\t\t\t/// Не будем брать из куска слишком мало строк.",
          "new_line_content": "\t\t\t\tsize_t & marks_in_part = sum_marks_in_parts.back();",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": null,
          "new_api": "th",
          "old_text": null,
          "new_text": "th() + part.data_",
          "old_line_content": "\t\t\t\t\tranges_to_get_from_part = part.ranges;",
          "new_line_content": "\t\t\t\t\tstd::reverse(part.ranges.begin(), part.ranges.end());",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": null,
          "new_api": "_from_part, use_",
          "old_text": null,
          "new_text": "_from_part, use_",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\t\t\tparts.pop_back();",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": null,
          "new_api": "essed_cache,\n\t\t\t\t\tprewhere_ac",
          "old_text": null,
          "new_text": "essed_cache,\n\t\t\t\t\tprewhere_ac",
          "old_line_content": "\t\t\t\telse",
          "new_line_content": "\t\t\t\t\tsum_marks_in_parts.pop_back();",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "\t\t\tstreams.back() =",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\tif (part.ranges.empty())",
          "content_same": false
        },
        {
          "line": 354,
          "old_api": null,
          "new_api": "lumn == \"_part_ind",
          "old_text": null,
          "new_text": "lumn == \"_part_ind",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\tMarkRange & range = part.ranges.back();",
          "content_same": false
        },
        {
          "line": 357,
          "old_api": null,
          "new_api": "new DataTypeUInt64, part.part_index",
          "old_text": null,
          "new_text": " new DataTypeUInt64, part.part_index",
          "old_line_content": "\t\t\t\t\t\trange.begin += marks_to_get_from_range;",
          "new_line_content": "\t\t\t\t\t\tsize_t marks_to_get_from_range = std::min(marks_in_range, need_marks);",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "if (streams.size() == 1)\n\t\t\t\tres.push_back(streams[0]);\n\t\t\tel",
          "old_line_content": "\t\t\t\t\t\tmarks_in_part -= marks_to_get_from_range;",
          "new_line_content": "\t\t\t\t\t\tranges_to_get_from_part.push_back(MarkRange(range.begin, range.begin + marks_to_get_from_range));",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": null,
          "new_api": "es;\n}\n\nBlockInputStrea",
          "old_text": null,
          "new_text": "es;\n}\n\nBlockInputStrea",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\t\tpart.ranges.pop_back();",
          "content_same": false
        },
        {
          "line": 367,
          "old_api": null,
          "new_api": "ctExecutor::spreadMarkRangesAmongThreadsFinal(\n\tRangesInDataParts parts,\n\tsize_t threads,\n\tconst Names & column_names,\n\tsize_t max_block_size,\n\tbool use_uncompressed_cache,\n\tExpressionActionsPtr prewhere_actions,\n\tconst String & prewhere_column,\n\tco",
          "old_text": null,
          "new_text": "ctExecutor::spreadMarkRangesAmongThreadsFinal(\n\tRangesInDataParts parts,\n\tsize_t threads,\n\tconst Names & column_names,\n\tsize_t max_block_size,\n\tbool use_uncompressed_cache,\n\tExpressionActionsPtr prewhere_actions,\n\tconst String & prewhere_column,\n\tco",
          "old_line_content": "\t\t\t\t\tpart.data_part, ranges_to_get_from_part, use_uncompressed_cache,",
          "new_line_content": "\t\t\t\tstreams.push_back(new MergeTreeBlockInputStream(",
          "content_same": false
        },
        {
          "line": 368,
          "old_api": null,
          "new_api": "InDataParts parts,",
          "old_text": null,
          "new_text": "InDataParts parts,",
          "old_line_content": "\t\t\t\t\tprewhere_actions, prewhere_column));",
          "new_line_content": "\t\t\t\t\tdata.getFullPath() + part.data_part->name + '/', max_block_size, column_names, data,",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": null,
          "new_api": "(size_t j = 0",
          "old_text": null,
          "new_text": " (size_t j = 0",
          "old_line_content": "\t\t\t\t\telse if (virt_column == \"_part_index\")",
          "new_line_content": "\t\t\t\t\t\tstreams.back() = new AddingConstColumnBlockInputStream<String>(",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": null,
          "new_api": "e;\n\n\tExpressio",
          "old_text": null,
          "new_text": "e;\n\n\tExpressio",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\tstreams.back() = new AddingConstColumnBlockInputStream<UInt64>(",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": null,
          "new_api": "olumn;\n\tcreate",
          "old_text": null,
          "new_text": "olumn;\n\tcreate",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\t\t\t\tstreams.back(), new DataTypeUInt64, part.part_index_in_query, \"_part_index\");",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": null,
          "new_api": "ams to_collaps",
          "old_text": null,
          "new_text": "ams to_collaps",
          "old_line_content": "\t\t\telse",
          "new_line_content": "\t\t\tif (streams.size() == 1)",
          "content_same": false
        },
        {
          "line": 385,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "s.size(); ++part_index)\n\t{\n\t\tRangesInDataPart & pa",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tres.push_back(new ConcatBlockInputStream(streams));",
          "content_same": false
        },
        {
          "line": 388,
          "old_api": null,
          "new_api": "t_index];",
          "old_text": null,
          "new_text": "t_index];\n\n\t\t",
          "old_line_content": "\t}",
          "new_line_content": "\t\tif (!parts.empty())",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": null,
          "new_api": "treamPtr source_stream = new MergeTreeBlockInputStream(\n\t\t\tdata.getFullPath",
          "old_text": null,
          "new_text": "treamPtr source_stream = new MergeTreeBlockInputStream(\n\t\t\tdata.getFullPath",
          "old_line_content": "",
          "new_line_content": "\t\t\tthrow Exception(\"Couldn't spread marks among threads\", ErrorCodes::LOGICAL_ERROR);",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": null,
          "new_api": "art\");\n\t\t\tel",
          "old_text": null,
          "new_text": "art\");\n\t\t\tel",
          "old_line_content": "\t\t\tsum_marks += parts[i].ranges[j].end - parts[i].ranges[j].begin;",
          "new_line_content": "\tfor (size_t i = 0; i < parts.size(); ++i)",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": null,
          "new_api": "ex\")\n\t\t\t\tsource_stream",
          "old_text": null,
          "new_text": "ex\")\n\t\t\t\tsource_stream",
          "old_line_content": "",
          "new_line_content": "\t\tfor (size_t j = 0; j < parts[i].ranges.size(); ++j)",
          "content_same": false
        },
        {
          "line": 415,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ession()));\n\t}\n\n\tBlockInputStreams res;\n\tif (to_collapse.size() == 1)\n\t",
          "old_line_content": "\tBlockInputStreams to_collapse;",
          "new_line_content": "\tcreatePositiveSignCondition(sign_filter_expression, sign_filter_column);",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": null,
          "new_api": "llapse[0], s",
          "old_text": null,
          "new_text": "llapse[0], s",
          "old_line_content": "\t\tRangesInDataPart & part = parts[part_index];",
          "new_line_content": "\tfor (size_t part_index = 0; part_index < parts.size(); ++part_index)",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": null,
          "new_api": "apse, data.getSort",
          "old_text": null,
          "new_text": "apse, data.getSort",
          "old_line_content": "\t\t\tprewhere_actions, prewhere_column);",
          "new_line_content": "\t\t\tdata.getFullPath() + part.data_part->name + '/', max_block_size, column_names, data,",
          "content_same": false
        },
        {
          "line": 437,
          "old_api": null,
          "new_api": "sh_back",
          "old_text": null,
          "new_text": "sh_back(one_ptr);\n\n\tsign->n",
          "old_line_content": "",
          "new_line_content": "\t\tto_collapse.push_back(new ExpressionBlockInputStream(source_stream, data.getPrimaryExpression()));",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": null,
          "new_api": "etColumnsList",
          "old_text": null,
          "new_text": "etColumnsList()).g",
          "old_line_content": "",
          "new_line_content": "\telse if (to_collapse.size() > 1)",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": null,
          "new_api": "ает набор диапазонов засе",
          "old_text": null,
          "new_text": "ает набор диапазонов засе",
          "old_line_content": "\treturn res;",
          "new_line_content": "\t\tres.push_back(new CollapsingFinalBlockInputStream(to_collapse, data.getSortDescription(), data.sign_column));",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": null,
          "new_api": "ге берем левый отрезок и проверяем, под",
          "old_text": null,
          "new_text": "ге берем левый отрезок и проверяем, под",
          "old_line_content": "",
          "new_line_content": "\targuments->children.push_back(sign_ptr);",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": null,
          "new_api": "ит ли он.\n\t\t\t* Если подходит, разбивае",
          "old_text": null,
          "new_text": "ит ли он.\n\t\t\t* Если подходит, разбивае",
          "old_line_content": "\tsign->name = data.sign_column;",
          "new_line_content": "\targuments->children.push_back(one_ptr);",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": null,
          "new_api": "sh_back",
          "old_text": null,
          "new_text": "sh_back(MarkRange(0, ",
          "old_line_content": "}",
          "new_line_content": "\tout_expression = ExpressionAnalyzer(function_ptr, data.context, data.getColumnsList()).getActions(false);",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "ck.empty())\n\t\t{\n\t\t\tMarkRa",
          "old_line_content": "",
          "new_line_content": "\tout_column = function->getColumnName();",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": null,
          "new_api": "e.end == range.begin + 1)\n\t\t\t{",
          "old_text": null,
          "new_text": "e.end == range.begin + 1)\n\t\t\t{\n\t",
          "old_line_content": "",
          "new_line_content": "\tsize_t key_size = data.getSortDescription().size();",
          "content_same": false
        },
        {
          "line": 486,
          "old_api": null,
          "new_api": "промежуток м",
          "old_text": null,
          "new_text": "промежуток м",
          "old_line_content": "\t/// Если индекс не используется.",
          "new_line_content": "\tsize_t marks_count = index.size() / key_size;",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "begin - res.back().end > ",
          "old_line_content": "\telse",
          "new_line_content": "\t\tres.push_back(MarkRange(0, marks_count));",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\tranges_stack.push_back(MarkRange(0, marks_count));",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\t\tMarkRange range = ranges_stack.back();",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\tbool may_be_true;",
          "new_line_content": "\t\t\tranges_stack.pop_back();",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\tif (!may_be_true)",
          "new_line_content": "\t\t\t\tmay_be_true = key_condition.mayBeTrueInRange(&index[range.begin * key_size], &index[range.end * key_size]);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 517,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (res.empty() || range.begin - res.back().end > min_marks_for_seek)",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tres.push_back(range);",
          "new_line_content": "\t\t\t\t/// Увидели полезный промежуток между соседними засечками. Либо добавим его к последнему диапазону, либо начнем новый диапазон.",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tranges_stack.push_back(MarkRange(end - step, end));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 69,
          "old_api": "processed_stage = Query",
          "new_api": null,
          "old_text": "\n\tprocessed_stage = Query",
          "new_text": null,
          "old_line_content": "\tif (!virt_column_names.empty())",
          "new_line_content": "\tif (settings.optimize_move_to_prewhere)",
          "content_same": false
        },
        {
          "line": 70,
          "old_api": "key_condition",
          "new_api": null,
          "old_text": "key_condition(",
          "new_text": null,
          "old_line_content": "\t\tVirtualColumnUtils::filterBlockWithQuery(query->clone(), virtual_columns_block, data.context);",
          "new_line_content": "\t\tif (select.where_expression && !select.prewhere_expression)",
          "content_same": false
        },
        {
          "line": 72,
          "old_api": "getColumnsList",
          "new_api": null,
          "old_text": "PKCondition date_condition(query, data.context, data.getColumnsList(), SortDescription(",
          "new_text": null,
          "old_line_content": "\tstd::multiset<String> values = VirtualColumnUtils::extractSingleValueFromBlock<String>(virtual_columns_block, \"_part\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 74,
          "old_api": "ortColumnDescription",
          "new_api": null,
          "old_text": "ortColumnDescription(data.dat",
          "new_text": null,
          "old_line_content": "\tdata.check(real_column_names);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 78,
          "old_api": "find",
          "new_api": null,
          "old_text": ".find(part->name) == values.end())\n\t\t\t\tcontinue",
          "new_text": null,
          "old_line_content": "\tPKCondition date_condition(query, data.context, data.getColumnsList(), SortDescription(1, SortColumnDescription(data.date_column_name, 1)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 83,
          "old_api": ".\n\tNames colu",
          "new_api": null,
          "old_text": ".\n\tNames colu",
          "new_text": null,
          "old_line_content": "\t\tparts.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 87,
          "old_api": "typedef Poco",
          "new_api": null,
          "old_text": "typedef Poco",
          "new_text": null,
          "old_line_content": "\t\t\tif (values.find(part->name) == values.end())",
          "new_line_content": "\t/// Выберем куски, в которых могут быть данные, удовлетворяющие date_condition, и которые подходят под условие на _part.",
          "content_same": false
        },
        {
          "line": 91,
          "old_api": "ionsPtr filter_expression;\n\n\tASTSelec",
          "new_api": null,
          "old_text": "ionsPtr filter_expression;\n\n\tASTSelec",
          "new_text": null,
          "old_line_content": "\t\t\tField right = static_cast<UInt64>(part->right_date);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 93,
          "old_api": "lect = *typeid_cast<ASTSelectQuery*>(&*query);",
          "new_api": null,
          "old_text": "lect = *typeid_cast<ASTSelectQuery*>(&*query);",
          "new_text": null,
          "old_line_content": "\t\t\tif (!date_condition.mayBeTrueInRange(&left, &right))",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 96,
          "old_api": "ize_move_to_prewhere)",
          "new_api": null,
          "old_text": "ize_move_to_prewhere)",
          "new_text": null,
          "old_line_content": "\t\t\tparts.push_back(part);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 107,
          "old_api": "if (size < 0)\n\t\t\tthrow Exception(\"N",
          "new_api": null,
          "old_text": "\t\tif (size < 0)\n\t\t\tthrow Exception(\"N",
          "new_text": null,
          "old_line_content": "\tASTSelectQuery & select = *typeid_cast<ASTSelectQuery*>(&*query);",
          "new_line_content": "\t/// Семплирование.",
          "content_same": false
        },
        {
          "line": 114,
          "old_api": "ко строк мы бы прочли без семплирован",
          "new_api": null,
          "old_text": "ко строк мы бы прочли без семплирован",
          "new_text": null,
          "old_line_content": "\t\tdouble size = apply_visitor(FieldVisitorConvertToNumber<double>(),",
          "new_line_content": "\tif (select.sample_size)",
          "content_same": false
        },
        {
          "line": 115,
          "old_api": "LOG_DEBUG(log, \"Preliminary index scan with",
          "new_api": null,
          "old_text": "\t\tLOG_DEBUG(log, \"Preliminary index scan with",
          "new_text": null,
          "old_line_content": "\t\t\ttypeid_cast<ASTLiteral&>(*select.sample_size).value);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 118,
          "old_api": "ring",
          "new_api": null,
          "old_text": "ring());\n\t\t\tsize_t total_count = 0;\n\t\t\tfor (size_t i = 0; i < parts.",
          "new_text": null,
          "old_line_content": "\t\t\tthrow Exception(\"Negative sample size\", ErrorCodes::ARGUMENT_OUT_OF_BOUND);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 122,
          "old_api": "omPkRange",
          "new_api": null,
          "old_text": "omPkRange(part->index, key_condition);\n\n\t\t\t\tf",
          "new_text": null,
          "old_line_content": "\t\t\tsize_t requested_count = apply_visitor(FieldVisitorConvertToNumber<UInt64>(), typeid_cast<ASTLiteral&>(*select.sample_size).value);",
          "new_line_content": "\t\tif (size > 1)",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": "double>(requested_count)",
          "new_api": null,
          "old_text": "double>(requested_count)",
          "new_text": null,
          "old_line_content": "\t\t\tLOG_DEBUG(log, \"Preliminary index scan with condition: \" << key_condition.toString());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 130,
          "old_api": "getByName",
          "new_api": null,
          "old_text": "yExpression()->getSampleBlock().getByName(data.sa",
          "new_text": null,
          "old_line_content": "\t\t\t\tMarkRanges ranges = markRangesFromPkRange(part->index, key_condition);",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 137,
          "old_api": "32\")\n\t\t\tsampling_column_max = std::n",
          "new_api": null,
          "old_text": "32\")\n\t\t\tsampling_column_max = std::n",
          "new_text": null,
          "old_line_content": "\t\t\tsize = std::min(1., static_cast<double>(requested_count) / total_count);",
          "new_line_content": "\t\t\ttotal_count *= data.index_granularity;",
          "content_same": false
        },
        {
          "line": 143,
          "old_api": "td::numeric_limits<UInt8>::max();\n\t\telse",
          "new_api": null,
          "old_text": "td::numeric_limits<UInt8>::max();\n\t\telse\n",
          "new_text": null,
          "old_line_content": "\t\tDataTypePtr type = data.getPrimaryExpression()->getSampleBlock().getByName(data.sampling_expression->getColumnName()).type;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 146,
          "old_api": "getName",
          "new_api": null,
          "old_text": "s: \" + type->getName() + \". Must b",
          "new_text": null,
          "old_line_content": "\t\t\tsampling_column_max = std::numeric_limits<UInt64>::max();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 157,
          "old_api": "ression);\n\t\tfilter_function_args->children.push",
          "new_api": null,
          "old_text": "ression);\n\t\tfilter_function_args->children.push",
          "new_text": null,
          "old_line_content": "\t\tsampling_column_value_limit = static_cast<UInt64>(size * sampling_column_max);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": "sampling_column_value_limit));\n\n\t\tfilter_",
          "new_api": null,
          "old_text": "sampling_column_value_limit));\n\n\t\tfilter_",
          "new_text": null,
          "old_line_content": "\t\tif (!key_condition.addCondition(data.sampling_expression->getColumnName(),",
          "new_line_content": "\t\t/// Добавим условие, чтобы отсечь еще что-нибудь при повторном просмотре индекса.",
          "content_same": false
        },
        {
          "line": 165,
          "old_api": "м столбцы, нужные для sampling_expression.\n\t\tstd::vector<String> a",
          "new_api": null,
          "old_text": "м столбцы, нужные для sampling_expression.\n\t\tstd::vector<String> a",
          "new_text": null,
          "old_line_content": "\t\tfilter_function_args->children.push_back(data.sampling_expression);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 166,
          "old_api": "mn_names_to_r",
          "new_api": null,
          "old_text": "mn_names_to_r",
          "new_text": null,
          "old_line_content": "\t\tfilter_function_args->children.push_back(new ASTLiteral(StringRange(), sampling_column_value_limit));",
          "new_line_content": "\t\tASTPtr filter_function_args = new ASTExpressionList;",
          "content_same": false
        },
        {
          "line": 171,
          "old_api": "erase",
          "new_api": null,
          "old_text": "_read.erase(std::unique(column_names_to_read.begin(), column_na",
          "new_text": null,
          "old_line_content": "\t\tfilter_function->children.push_back(filter_function->arguments);",
          "new_line_content": "\t\tfilter_function->name = \"lessOrEquals\";",
          "content_same": false
        },
        {
          "line": 176,
          "old_api": "ions;\n\tString prewhere_column;\n\tif (sel",
          "new_api": null,
          "old_text": "ions;\n\tString prewhere_column;\n\tif (sel",
          "new_text": null,
          "old_line_content": "\t\tstd::vector<String> add_columns = filter_expression->getRequiredColumns();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 177,
          "old_api": "ion, data.context",
          "new_api": null,
          "old_text": "ion, data.context",
          "new_text": null,
          "old_line_content": "\t\tcolumn_names_to_read.insert(column_names_to_read.end(), add_columns.begin(), add_columns.end());",
          "new_line_content": "\t\t/// Добавим столбцы, нужные для sampling_expression.",
          "content_same": false
        },
        {
          "line": 182,
          "old_api": "а потом их выполнить.\n\t}",
          "new_api": null,
          "old_text": "а потом их выполнить.\n\t}",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Key condition: \" << key_condition.toString());",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 183,
          "old_api": "/// Найдем, какой диапаз",
          "new_api": null,
          "old_text": "\t/// Найдем, какой диапаз",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Date condition: \" << date_condition.toString());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": "ges",
          "new_api": null,
          "old_text": "ges(part, (*part_inde",
          "new_text": null,
          "old_line_content": "\t\tExpressionAnalyzer analyzer(select.prewhere_expression, data.context, data.getColumnsList());",
          "new_line_content": "\tif (select.prewhere_expression)",
          "content_same": false
        },
        {
          "line": 191,
          "old_api": "markRangesFromPkRange(par",
          "new_api": null,
          "old_text": " markRangesFromPkRange(par",
          "new_text": null,
          "old_line_content": "\t\tprewhere_actions = analyzer.getActions(false);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": "ges\");\n\n\tBlo",
          "new_api": null,
          "old_text": "ges\");\n\n\tBlo",
          "new_text": null,
          "old_line_content": "\tfor (size_t i = 0; i < parts.size(); ++i)",
          "new_line_content": "\tsize_t sum_marks = 0;",
          "content_same": false
        },
        {
          "line": 205,
          "old_api": "r<String> add_columns = data.getPrimaryExpression",
          "new_api": null,
          "old_text": "r<String> add_columns = data.getPrimaryExpression",
          "new_text": null,
          "old_line_content": "\t\tranges.ranges = markRangesFromPkRange(part->index, key_condition);",
          "new_line_content": "\t\tMergeTreeData::DataPartPtr & part = parts[i];",
          "content_same": false
        },
        {
          "line": 212,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "read.push_back(data.",
          "new_text": null,
          "old_line_content": "\t\t\tfor (size_t j = 0; j < ranges.ranges.size(); ++j)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": "end",
          "new_api": null,
          "old_text": "lumn_names_to_read.end()",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Selected \" << parts.size() << \" parts by date, \" << parts_with_ranges.size() << \" parts by key, \"",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": "parts_with_ranges,\n\t\t\tthreads,\n\t\t\tcolumn_names",
          "new_api": null,
          "old_text": "\t\t\tparts_with_ranges,\n\t\t\tthreads,\n\t\t\tcolumn_names",
          "new_text": null,
          "old_line_content": "\t\tstd::vector<String> add_columns = data.getPrimaryExpression()->getRequiredColumns();",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": "ons,\n\t\t\tprewhere_",
          "new_api": null,
          "old_text": "ons,\n\t\t\tprewhere_",
          "new_text": null,
          "old_line_content": "\t\tcolumn_names_to_read.insert(column_names_to_read.end(), add_columns.begin(), add_columns.end());",
          "new_line_content": "\t\t/// Добавим столбцы, нужные для вычисления первичного ключа и знака.",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": "RangesAmongThreads",
          "new_api": null,
          "old_text": "RangesAmongThreads(\n\tRangesInDataParts parts,\n\tsize_t threads,\n\tconst Names & column_names,\n\tsize_t max_block_size,\n\tbool use_uncompressed_cache,\n\tExpressionActionsPtr prewhere_actions,\n\tconst String & prew",
          "new_text": null,
          "old_line_content": "\t\tres = spreadMarkRangesAmongThreads(",
          "new_line_content": "\telse",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": "случай пер",
          "new_api": null,
          "old_text": "случай пер",
          "new_text": null,
          "old_line_content": "\t\tfor (size_t i = 0; i < res.size(); ++i)",
          "new_line_content": "\tif (select.sample_size)",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": "т перечислены справа налево, что",
          "new_api": null,
          "old_text": "т перечислены справа налево, что",
          "new_text": null,
          "old_line_content": "\t\t\tBlockInputStreamPtr filter_stream = new FilterBlockInputStream(expression_stream, filter_function->getColumnName());",
          "new_line_content": "\t\t\tBlockInputStreamPtr original_stream = res[i];",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": "(sum_marks",
          "new_api": null,
          "old_text": " (sum_marks",
          "new_text": null,
          "old_line_content": "\tstd::random_shuffle(parts.begin(), parts.end());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "mpty",
          "new_api": null,
          "old_text": "mpty(); ++i)",
          "new_text": null,
          "old_line_content": "\tstd::vector<size_t> sum_marks_in_parts(parts.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "t >= min_marks_for_co",
          "new_api": null,
          "old_text": "t >= min_marks_for_co",
          "new_text": null,
          "old_line_content": "\t\tstd::reverse(parts[i].ranges.begin(), parts[i].ranges.end());",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": "t_read)\n\t\t\t\t\tneed_mark",
          "new_api": null,
          "old_text": "t_read)\n\t\t\t\t\tneed_mark",
          "new_text": null,
          "old_line_content": "\t\tfor (size_t j = 0; j < parts[i].ranges.size(); ++j)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": "ановим порядо",
          "new_api": null,
          "old_text": "ановим порядо",
          "new_text": null,
          "old_line_content": "\t\tfor (size_t i = 0; i < threads && !parts.empty(); ++i)",
          "new_line_content": "\t\tsize_t min_marks_per_thread = (sum_marks - 1) / threads + 1;",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": "parts.po",
          "new_api": null,
          "old_text": "\t\t\t\t\tparts.po",
          "new_text": null,
          "old_line_content": "\t\t\twhile (need_marks > 0 && !parts.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": "по отрезкам куска.",
          "new_api": null,
          "old_text": " по отрезкам куска.\n\t\t\t\t\t",
          "new_text": null,
          "old_line_content": "\t\t\t\tsize_t & marks_in_part = sum_marks_in_parts.back();",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": "th",
          "new_api": null,
          "old_text": "th() + part.data_",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tstd::reverse(part.ranges.begin(), part.ranges.end());",
          "new_line_content": "\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": "_from_part, use_",
          "new_api": null,
          "old_text": "_from_part, use_",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tparts.pop_back();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": "essed_cache,\n\t\t\t\t\tprewhere_ac",
          "new_api": null,
          "old_text": "essed_cache,\n\t\t\t\t\tprewhere_ac",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tsum_marks_in_parts.pop_back();",
          "new_line_content": "\t\t\t\t\tneed_marks -= marks_in_part;",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": "back",
          "new_api": null,
          "old_text": "\t\t\tstreams.back() =",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tif (part.ranges.empty())",
          "new_line_content": "\t\t\t\t\twhile (need_marks > 0)",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": "back",
          "new_api": null,
          "old_text": "tColumnBlockInputStream<String>(\n\t\t\t\t\t\t\tstreams.back(), new DataTypeString, part.data_part->name, \"_",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tthrow Exception(\"Unexpected end of ranges while spreading marks among threads\", ErrorCodes::LOGICAL_ERROR);",
          "new_line_content": "\t\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": "new DataTypeUInt64, part.part_index",
          "new_api": null,
          "old_text": " new DataTypeUInt64, part.part_index",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tsize_t marks_to_get_from_range = std::min(marks_in_range, need_marks);",
          "new_line_content": "\t\t\t\t\t\tsize_t marks_in_range = range.end - range.begin;",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": "size",
          "new_api": null,
          "old_text": "if (streams.size() == 1)\n\t\t\t\tres.push_back(streams[0]);\n\t\t\tel",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tranges_to_get_from_part.push_back(MarkRange(range.begin, range.begin + marks_to_get_from_range));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": "es;\n}\n\nBlockInputStrea",
          "new_api": null,
          "old_text": "es;\n}\n\nBlockInputStrea",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tpart.ranges.pop_back();",
          "new_line_content": "\t\t\t\t\t\tneed_marks -= marks_to_get_from_range;",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "ctExecutor::spreadMarkRangesAmongThreadsFinal(\n\tRangesInDataParts parts,\n\tsize_t threads,\n\tconst Names & column_names,\n\tsize_t max_block_size,\n\tbool use_uncompressed_cache,\n\tExpressionActionsPtr prewhere_actions,\n\tconst String & prewhere_column,\n\tco",
          "new_api": null,
          "old_text": "ctExecutor::spreadMarkRangesAmongThreadsFinal(\n\tRangesInDataParts parts,\n\tsize_t threads,\n\tconst Names & column_names,\n\tsize_t max_block_size,\n\tbool use_uncompressed_cache,\n\tExpressionActionsPtr prewhere_actions,\n\tconst String & prewhere_column,\n\tco",
          "new_text": null,
          "old_line_content": "\t\t\t\tstreams.push_back(new MergeTreeBlockInputStream(",
          "new_line_content": "\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": "InDataParts parts,",
          "new_api": null,
          "old_text": "InDataParts parts,",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tdata.getFullPath() + part.data_part->name + '/', max_block_size, column_names, data,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "(size_t j = 0",
          "new_api": null,
          "old_text": " (size_t j = 0",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tstreams.back() = new AddingConstColumnBlockInputStream<String>(",
          "new_line_content": "\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": "i].ranges[j].e",
          "new_api": null,
          "old_text": "i].ranges[j].e",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tstreams.back(), new DataTypeString, part.data_part->name, \"_part\");",
          "new_line_content": "\t\t\t\t\tif (virt_column == \"_part\")",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": "olumn;\n\tcreate",
          "new_api": null,
          "old_text": "olumn;\n\tcreate",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tstreams.back(), new DataTypeUInt64, part.part_index_in_query, \"_part_index\");",
          "new_line_content": "\t\t\t\t\telse if (virt_column == \"_part_index\")",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "ams to_collaps",
          "new_api": null,
          "old_text": "ams to_collaps",
          "new_text": null,
          "old_line_content": "\t\t\tif (streams.size() == 1)",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": "ize_t part_index = 0; par",
          "new_api": null,
          "old_text": "ize_t part_index = 0; par",
          "new_text": null,
          "old_line_content": "\t\t\t\tres.push_back(streams[0]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 386,
          "old_api": "t_index];",
          "new_api": null,
          "old_text": "t_index];\n\n\t\t",
          "new_text": null,
          "old_line_content": "\t\tif (!parts.empty())",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 387,
          "old_api": "treamPtr source_stream = new MergeTreeBlockInputStream(\n\t\t\tdata.getFullPath",
          "new_api": null,
          "old_text": "treamPtr source_stream = new MergeTreeBlockInputStream(\n\t\t\tdata.getFullPath",
          "new_text": null,
          "old_line_content": "\t\t\tthrow Exception(\"Couldn't spread marks among threads\", ErrorCodes::LOGICAL_ERROR);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": "art\");\n\t\t\tel",
          "new_api": null,
          "old_text": "art\");\n\t\t\tel",
          "new_text": null,
          "old_line_content": "\tfor (size_t i = 0; i < parts.size(); ++i)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": "ex\")\n\t\t\t\tsource_stream",
          "new_api": null,
          "old_text": "ex\")\n\t\t\t\tsource_stream",
          "new_text": null,
          "old_line_content": "\t\tfor (size_t j = 0; j < parts[i].ranges.size(); ++j)",
          "new_line_content": "\tsize_t sum_marks = 0;",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "size",
          "new_api": null,
          "old_text": "ession()));\n\t}\n\n\tBlockInputStreams res;\n\tif (to_collapse.size() == 1)\n\t",
          "new_text": null,
          "old_line_content": "\tcreatePositiveSignCondition(sign_filter_expression, sign_filter_column);",
          "new_line_content": "\tExpressionActionsPtr sign_filter_expression;",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": "llapse[0], s",
          "new_api": null,
          "old_text": "llapse[0], s",
          "new_text": null,
          "old_line_content": "\tfor (size_t part_index = 0; part_index < parts.size(); ++part_index)",
          "new_line_content": "\tBlockInputStreams to_collapse;",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "apse, data.getSort",
          "new_api": null,
          "old_text": "apse, data.getSort",
          "new_text": null,
          "old_line_content": "\t\t\tdata.getFullPath() + part.data_part->name + '/', max_block_size, column_names, data,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": "sh_back",
          "new_api": null,
          "old_text": "sh_back(one_ptr);\n\n\tsign->n",
          "new_text": null,
          "old_line_content": "\t\tto_collapse.push_back(new ExpressionBlockInputStream(source_stream, data.getPrimaryExpression()));",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 439,
          "old_api": "ASTIdentifier::Co",
          "new_api": null,
          "old_text": " ASTIdentifier::Co",
          "new_text": null,
          "old_line_content": "\tif (to_collapse.size() == 1)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": "ne->type = new DataTypeInt8;\n\tone->value = Field(static_cast<Int64>(1));\n\n\tout_expression = ExpressionAnalyzer(function_ptr, data.con",
          "new_api": null,
          "old_text": "ne->type = new DataTypeInt8;\n\tone->value = Field(static_cast<Int64>(1));\n\n\tout_expression = ExpressionAnalyzer(function_ptr, data.con",
          "new_text": null,
          "old_line_content": "\t\tres.push_back(new FilterBlockInputStream(new ExpressionBlockInputStream(to_collapse[0], sign_filter_expression), sign_filter_column));",
          "new_line_content": "\tBlockInputStreams res;",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": ", самый левый наверху (back).\n\t\t\t* На каждо",
          "new_api": null,
          "old_text": ", самый левый наверху (back).\n\t\t\t* На каждо",
          "new_text": null,
          "old_line_content": "\tfunction->children.push_back(arguments_ptr);",
          "new_line_content": "\tfunction->name = \"equals\";",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "ит ли он.\n\t\t\t* Если подходит, разбивае",
          "new_api": null,
          "old_text": "ит ли он.\n\t\t\t* Если подходит, разбивае",
          "new_text": null,
          "old_line_content": "\targuments->children.push_back(one_ptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": "его в ответ и выбрас",
          "new_api": null,
          "old_text": " его в ответ и выбрас",
          "new_text": null,
          "old_line_content": "\tone->value = Field(static_cast<Int64>(1));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": "empty",
          "new_api": null,
          "old_text": "ck.empty())\n\t\t{\n\t\t\tMarkRa",
          "new_text": null,
          "old_line_content": "\tout_column = function->getColumnName();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": "e.end == range.begin + 1)\n\t\t\t{",
          "new_api": null,
          "old_text": "e.end == range.begin + 1)\n\t\t\t{\n\t",
          "new_text": null,
          "old_line_content": "\tsize_t key_size = data.getSortDescription().size();",
          "new_line_content": "\tMarkRanges res;",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "промежуток м",
          "new_api": null,
          "old_text": "промежуток м",
          "new_text": null,
          "old_line_content": "\tsize_t marks_count = index.size() / key_size;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "м новый диапазон.\n\t\t\t\tif (",
          "new_api": null,
          "old_text": "м новый диапазон.\n\t\t\t\tif (",
          "new_text": null,
          "old_line_content": "\tif (key_condition.alwaysTrue())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tranges_stack.push_back(MarkRange(0, marks_count));",
          "new_line_content": "\t\t\t*/",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\twhile (!ranges_stack.empty())",
          "new_line_content": "\t\tstd::vector<MarkRange> ranges_stack;",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tranges_stack.pop_back();",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\t\tmay_be_true = key_condition.mayBeTrueAfter(&index[range.begin * key_size]);",
          "new_line_content": "\t\t\tbool may_be_true;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 40,
      "total_additions": 86,
      "total_deletions": 86,
      "total_api_changes": 212
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 13,
        "api_related_lines": 212,
        "non_api_lines": 7,
        "non_api_line_numbers": [
          67,
          68,
          71,
          108,
          109,
          110,
          111
        ]
      }
    },
    "api_calls_before": 197,
    "api_calls_after": 197,
    "diff_info": {
      "added_lines": 8,
      "removed_lines": 6,
      "total_diff_lines": 35
    }
  }
}