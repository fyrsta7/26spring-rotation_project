{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/6338368a1c0262409b9a584b85ff26c4479f2fd7",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/6338368a1c0262409b9a584b85ff26c4479f2fd7/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/6338368a1c0262409b9a584b85ff26c4479f2fd7/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/6338368a1c0262409b9a584b85ff26c4479f2fd7/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 285,
          "old_api": "getOrSetDownloader",
          "new_api": "getDownloadOffset",
          "old_text": "file_segment->getOrSetDownloader()",
          "new_text": "file_segment->getDownloadOffset()",
          "old_line_content": "                auto downloader_id = file_segment->getOrSetDownloader();",
          "new_line_content": "                if (file_segment->getDownloadOffset() > file_offset_of_buffer_end)",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": "getCacheReadBuffer",
          "new_api": "LOG_TEST",
          "old_text": "getCacheReadBuffer(range.left)",
          "new_text": "LOG_TEST(log, \"Current download offset: {}, file offset of buffer end: {}\", download_offset, file_offset_of_buffer_end)",
          "old_line_content": "                        return getCacheReadBuffer(range.left);",
          "new_line_content": "                    LOG_TEST(log, \"Current download offset: {}, file offset of buffer end: {}\", download_offset, file_offset_of_buffer_end);",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": "getDownloadOffset",
          "new_api": "resetDownloader",
          "old_text": "file_segment->getDownloadOffset()",
          "new_text": "file_segment->resetDownloader()",
          "old_line_content": "                        assert(file_offset_of_buffer_end > file_segment->getDownloadOffset());",
          "new_line_content": "                        file_segment->resetDownloader();",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": "getDownloadOffset",
          "new_api": "getCacheReadBuffer",
          "old_text": "file_segment->getDownloadOffset()",
          "new_text": "getCacheReadBuffer(range.left)",
          "old_line_content": "                        bytes_to_predownload = file_offset_of_buffer_end - file_segment->getDownloadOffset();",
          "new_line_content": "                        return getCacheReadBuffer(range.left);",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": "getCacheReadBuffer",
          "new_api": "getRemoteFSReadBuffer",
          "old_text": "getCacheReadBuffer(range.left)",
          "new_text": "getRemoteFSReadBuffer(file_segment, read_type)",
          "old_line_content": "                    return getCacheReadBuffer(range.left);",
          "new_line_content": "                    return getRemoteFSReadBuffer(file_segment, read_type);",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": "isDownloader",
          "new_api": "getCacheReadBuffer",
          "old_text": "file_segment->isDownloader()",
          "new_text": "getCacheReadBuffer(range.left)",
          "old_line_content": "    assert(!file_segment->isDownloader());",
          "new_line_content": "                    return getCacheReadBuffer(range.left);",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "assert",
          "new_api": "range",
          "old_text": "assert(file_offset_of_buffer_end >= range.left && file_offset_of_buffer_end <= range.right)",
          "new_text": "file_segment->range()",
          "old_line_content": "    assert(file_offset_of_buffer_end >= range.left && file_offset_of_buffer_end <= range.right);",
          "new_line_content": "    auto range = file_segment->range();",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": "toString",
          "new_api": "getReadBufferForFileSegment",
          "old_text": "range.toString()",
          "new_text": "getReadBufferForFileSegment(file_segment)",
          "old_line_content": "        range.toString(),",
          "new_line_content": "    auto read_buffer_for_file_segment = getReadBufferForFileSegment(file_segment);",
          "content_same": false
        },
        {
          "line": 388,
          "old_api": "get",
          "new_api": "toString",
          "old_text": "read_buffer_for_file_segment.get()",
          "new_text": "LOG_TEST(\n        log,\n        \"Current file segment: {}, read type: {}, current file offset: {}\",\n        range.toString(),\n        toString(read_type),\n        file_offset_of_buffer_end)",
          "old_line_content": "            auto * file_reader = dynamic_cast<ReadBufferFromFileDescriptor *>(read_buffer_for_file_segment.get());",
          "new_line_content": "    LOG_TEST(",
          "content_same": false
        },
        {
          "line": 392,
          "old_api": "Exception",
          "new_api": "toString",
          "old_text": "Exception(\n                    ErrorCodes::LOGICAL_ERROR,\n                    \"Unexpected state of cache file. Cache file size: {}, cache file offset: {}, \"\n                    \"expected file size to be non-zero and file downloaded size to exceed current file read offset (expected: {} > {})\",\n                    file_size,\n                    range.left,\n                    range.left + file_size,\n                    file_offset_of_buffer_end)",
          "new_text": "toString(read_type)",
          "old_line_content": "                throw Exception(",
          "new_line_content": "        toString(read_type),",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": "getPosition",
          "new_api": "seek",
          "old_text": "read_buffer_for_file_segment->getPosition()",
          "new_text": "read_buffer_for_file_segment->seek(file_offset_of_buffer_end, SEEK_SET)",
          "old_line_content": "                    read_buffer_for_file_segment->getPosition(),",
          "new_line_content": "                read_buffer_for_file_segment->seek(file_offset_of_buffer_end, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": "getInfoForLog",
          "new_api": "getDownloadOffset",
          "old_text": "file_segment->getInfoForLog()",
          "new_text": "file_segment->getDownloadOffset()",
          "old_line_content": "                    file_segment->getInfoForLog());",
          "new_line_content": "            auto download_offset = file_segment->getDownloadOffset();",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": "end",
          "new_api": "range",
          "old_text": "file_segments_holder->file_segments.end()",
          "new_text": "file_segment->range()",
          "old_line_content": "    if (current_file_segment_it == file_segments_holder->file_segments.end())",
          "new_line_content": "    [[maybe_unused]] const auto & range = file_segment->range();",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": "getImplementationBuffer",
          "new_api": "toString",
          "old_text": "getImplementationBuffer(*current_file_segment_it)",
          "new_text": "LOG_TEST(\n        log,\n        \"Removing file segment: {}, downloader: {}, state: {}\",\n        file_segment->range().toString(),\n        file_segment->getDownloader(),\n        file_segment->state())",
          "old_line_content": "    implementation_buffer = getImplementationBuffer(*current_file_segment_it);",
          "new_line_content": "    LOG_TEST(",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": "incrementHitsCount",
          "new_api": "toString",
          "old_text": "*current_file_segment_it)->incrementHitsCount()",
          "new_text": "file_segment->range().toString()",
          "old_line_content": "        (*current_file_segment_it)->incrementHitsCount();",
          "new_line_content": "        file_segment->range().toString(),",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": "toString",
          "new_api": "state",
          "old_text": "*current_file_segment_it)->range().toString()",
          "new_text": "file_segment->state()",
          "old_line_content": "    LOG_TEST(log, \"New segment: {}\", (*current_file_segment_it)->range().toString());",
          "new_line_content": "        file_segment->state());",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": "getDownloadOffset",
          "new_api": "stop",
          "old_text": "file_segment->getDownloadOffset()",
          "new_text": "predownload_watch.stop()",
          "old_line_content": "        assert(implementation_buffer->getFileOffsetOfBufferEnd() == file_segment->getDownloadOffset());",
          "new_line_content": "        predownload_watch.stop();",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": "getDownloadOffset",
          "new_api": "elapsedMicroseconds",
          "old_text": "file_segment->getDownloadOffset()",
          "new_text": "predownload_watch.elapsedMicroseconds()",
          "old_line_content": "        size_t current_offset = file_segment->getDownloadOffset();",
          "new_line_content": "        current_file_segment_counters.increment(ProfileEvents::FileSegmentPredownloadMicroseconds, predownload_watch.elapsedMicroseconds());",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "elapsedMicroseconds",
          "new_api": "FileSegment::getCallerId()",
          "old_text": "watch.elapsedMicroseconds()",
          "new_text": "FileSegment::getCallerId()",
          "old_line_content": "                auto elapsed = watch.elapsedMicroseconds();",
          "new_line_content": "        LOG_TEST(log, \"Bytes to predownload: {}, caller_id: {}\", bytes_to_predownload, FileSegment::getCallerId());",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceMicroseconds, elapsed)",
          "new_api": "getDownloadOffset",
          "old_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceMicroseconds, elapsed)",
          "new_text": "file_segment->getDownloadOffset()",
          "old_line_content": "                ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceMicroseconds, elapsed);",
          "new_line_content": "        assert(implementation_buffer->getFileOffsetOfBufferEnd() == file_segment->getDownloadOffset());",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": "toString",
          "new_api": "stop",
          "old_text": "file_segment->range().toString()",
          "new_text": "watch.stop()",
          "old_line_content": "                        file_segment->range().toString(),",
          "new_line_content": "                watch.stop();",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": "getDownloadOffset",
          "new_api": "elapsedMicroseconds",
          "old_text": "file_segment->getDownloadOffset()",
          "new_text": "watch.elapsedMicroseconds()",
          "old_line_content": "                        file_segment->getDownloadOffset(),",
          "new_line_content": "                auto elapsed = watch.elapsedMicroseconds();",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": "eof",
          "new_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceMicroseconds, elapsed)",
          "old_text": "implementation_buffer->eof()",
          "new_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceMicroseconds, elapsed)",
          "old_line_content": "                        implementation_buffer->eof());",
          "new_line_content": "                ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceMicroseconds, elapsed);",
          "content_same": false
        },
        {
          "line": 556,
          "old_api": "offset",
          "new_api": "toString",
          "old_text": "implementation_buffer->offset()",
          "new_text": "Exception(\n                        ErrorCodes::LOGICAL_ERROR,\n                        \"Failed to predownload remaining {} bytes. Current file segment: {}, current download offset: {}, expected: {}, \"\n                        \"eof: {}\",\n                        bytes_to_predownload,\n                        file_segment->range().toString(),\n                        file_segment->getDownloadOffset(),\n                        file_offset_of_buffer_end,\n                        implementation_buffer->eof())",
          "old_line_content": "                    nextimpl_working_buffer_offset = implementation_buffer->offset();",
          "new_line_content": "                    throw Exception(",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": "getPosition",
          "new_api": "toString",
          "old_text": "Exception(\n                            ErrorCodes::LOGICAL_ERROR,\n                            \"Buffer's offsets mismatch after predownloading; download offset: {}, cached buffer offset: {}, implementation \"\n                            \"buffer offset: {}, \"\n                            \"file segment info: {}\",\n                            download_offset,\n                            file_offset_of_buffer_end,\n                            implementation_buffer->getPosition(),\n                            file_segment->getInfoForLog())",
          "new_text": "file_segment->range().toString()",
          "old_line_content": "                        throw Exception(",
          "new_line_content": "                        file_segment->range().toString(),",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "size",
          "new_api": "getPosition",
          "old_text": "implementation_buffer->buffer().size()",
          "new_text": "Exception(\n                            ErrorCodes::LOGICAL_ERROR,\n                            \"Buffer's offsets mismatch after predownloading; download offset: {}, cached buffer offset: {}, implementation \"\n                            \"buffer offset: {}, \"\n                            \"file segment info: {}\",\n                            download_offset,\n                            file_offset_of_buffer_end,\n                            implementation_buffer->getPosition(),\n                            file_segment->getInfoForLog())",
          "old_line_content": "            size_t current_impl_buffer_size = implementation_buffer->buffer().size();",
          "new_line_content": "                        throw Exception(",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": "LOG_TEST",
          "new_api": "getPosition",
          "old_text": "LOG_TEST(log, \"Left to predownload: {}, buffer size: {}\", bytes_to_predownload, current_impl_buffer_size)",
          "new_text": "implementation_buffer->getPosition()",
          "old_line_content": "                LOG_TEST(log, \"Left to predownload: {}, buffer size: {}\", bytes_to_predownload, current_impl_buffer_size);",
          "new_line_content": "                            implementation_buffer->getPosition(),",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": "stop",
          "new_api": "std::min(current_impl_buffer_size, bytes_to_predownload)",
          "old_text": "watch.stop()",
          "new_text": "std::min(current_impl_buffer_size, bytes_to_predownload)",
          "old_line_content": "                watch.stop();",
          "new_line_content": "            size_t current_predownload_size = std::min(current_impl_buffer_size, bytes_to_predownload);",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": "increment",
          "new_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceBytes, current_impl_buffer_size)",
          "old_text": "current_file_segment_counters.increment(ProfileEvents::FileSegmentCacheWriteMicroseconds, elapsed)",
          "new_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceBytes, current_impl_buffer_size)",
          "old_line_content": "                current_file_segment_counters.increment(ProfileEvents::FileSegmentCacheWriteMicroseconds, elapsed);",
          "new_line_content": "            ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceBytes, current_impl_buffer_size);",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteBytes, current_predownload_size)",
          "new_api": "reserve",
          "old_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteBytes, current_predownload_size)",
          "new_text": "file_segment->reserve(current_predownload_size)",
          "old_line_content": "                ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteBytes, current_predownload_size);",
          "new_line_content": "            if (file_segment->reserve(current_predownload_size))",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": "LOG_TEST",
          "new_api": "complete",
          "old_text": "LOG_TEST(\n                    log,\n                    \"Predownload failed because of space limit. Will read from remote filesystem starting from offset: {}\",\n                    file_offset_of_buffer_end)",
          "new_text": "file_segment->complete(FileSegment::State::PARTIALLY_DOWNLOADED_NO_CONTINUATION)",
          "old_line_content": "                LOG_TEST(",
          "new_line_content": "                file_segment->complete(FileSegment::State::PARTIALLY_DOWNLOADED_NO_CONTINUATION);",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "range",
          "new_api": "LOG_TEST",
          "old_text": "file_segment->range()",
          "new_text": "LOG_TEST(\n                    log,\n                    \"Predownload failed because of space limit. Will read from remote filesystem starting from offset: {}\",\n                    file_offset_of_buffer_end)",
          "old_line_content": "    auto current_read_range = file_segment->range();",
          "new_line_content": "                LOG_TEST(",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": "addMessage",
          "new_api": "getImplementationBuffer",
          "old_text": "e.addMessage(\"Cache info: {}\", nextimpl_step_log_info)",
          "new_text": "getImplementationBuffer(*current_file_segment_it)",
          "old_line_content": "        e.addMessage(\"Cache info: {}\", nextimpl_step_log_info);",
          "new_line_content": "        implementation_buffer = getImplementationBuffer(*current_file_segment_it);",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": "end",
          "new_api": "addMessage",
          "old_text": "file_segments_holder->file_segments.end()",
          "new_text": "e.addMessage(\"Cache info: {}\", nextimpl_step_log_info)",
          "old_line_content": "    if (current_file_segment_it == file_segments_holder->file_segments.end())",
          "new_line_content": "        e.addMessage(\"Cache info: {}\", nextimpl_step_log_info);",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "getInfoForLog",
          "new_api": "FileSegment::getCallerId()",
          "old_text": "getInfoForLog()",
          "new_text": "FileSegment::getCallerId()",
          "old_line_content": "            nextimpl_step_log_info = getInfoForLog();",
          "new_line_content": "    last_caller_id = FileSegment::getCallerId();",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": "end",
          "new_api": "assertCorrectness",
          "old_text": "file_segments_holder->file_segments.end()",
          "new_text": "assertCorrectness()",
          "old_line_content": "            if (current_file_segment_it == file_segments_holder->file_segments.end())",
          "new_line_content": "    assertCorrectness();",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "isDownloader",
          "new_api": "end",
          "old_text": "file_segment->isDownloader()",
          "new_text": "SCOPE_EXIT({\n        try\n        {\n            /// Save state of current file segment before it is completed.\n            nextimpl_step_log_info = getInfoForLog();\n\n            if (current_file_segment_it == file_segments_holder->file_segments.end())\n                return;\n\n            auto & file_segment = *current_file_segment_it;\n\n            bool download_current_segment = read_type == ReadType::REMOTE_FS_READ_AND_PUT_IN_CACHE;\n            if (download_current_segment)\n            {\n                bool need_complete_file_segment = file_segment->isDownloader();\n                if (need_complete_file_segment)\n                {\n                    LOG_TEST(log, \"Resetting downloader {} from scope exit\", file_segment->getDownloader());\n                    file_segment->completeBatchAndResetDownloader();\n                }\n            }\n\n            assert(!file_segment->isDownloader());\n        }\n        catch (...)\n        {\n            tryLogCurrentException(__PRETTY_FUNCTION__);\n        }\n    })",
          "old_line_content": "                bool need_complete_file_segment = file_segment->isDownloader();",
          "new_line_content": "    SCOPE_EXIT({",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": "completeBatchAndResetDownloader",
          "new_api": "getInfoForLog",
          "old_text": "file_segment->completeBatchAndResetDownloader()",
          "new_text": "getInfoForLog()",
          "old_line_content": "                    file_segment->completeBatchAndResetDownloader();",
          "new_line_content": "            nextimpl_step_log_info = getInfoForLog();",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": "getImplementationBuffer",
          "new_api": "tryLogCurrentException",
          "old_text": "getImplementationBuffer(*current_file_segment_it)",
          "new_text": "tryLogCurrentException(__PRETTY_FUNCTION__)",
          "old_line_content": "        implementation_buffer = getImplementationBuffer(*current_file_segment_it);",
          "new_line_content": "            tryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": "count",
          "new_api": "incrementHitsCount",
          "old_text": "implementation_buffer->count()",
          "new_text": "*current_file_segment_it)->incrementHitsCount()",
          "old_line_content": "        implementation_buffer->count(),",
          "new_line_content": "            (*current_file_segment_it)->incrementHitsCount();",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": "assert",
          "new_api": "empty",
          "old_text": "assert(current_read_range.left <= file_offset_of_buffer_end)",
          "new_text": "internal_buffer.empty()",
          "old_line_content": "    assert(current_read_range.left <= file_offset_of_buffer_end);",
          "new_line_content": "    assert(!internal_buffer.empty());",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "assert",
          "new_api": "swap",
          "old_text": "assert(current_read_range.right >= file_offset_of_buffer_end)",
          "new_text": "swap(*implementation_buffer)",
          "old_line_content": "    assert(current_read_range.right >= file_offset_of_buffer_end);",
          "new_line_content": "    swap(*implementation_buffer);",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": "predownload",
          "new_api": "toString",
          "old_text": "predownload(file_segment)",
          "new_text": "current_read_range.toString()",
          "old_line_content": "        predownload(file_segment);",
          "new_line_content": "        current_read_range.toString(),",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": "hasPendingData",
          "new_api": "count",
          "old_text": "implementation_buffer->hasPendingData()",
          "new_text": "implementation_buffer->count()",
          "old_line_content": "        result = implementation_buffer->hasPendingData();",
          "new_line_content": "        implementation_buffer->count(),",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "available",
          "new_api": "getPosition",
          "old_text": "implementation_buffer->available()",
          "new_text": "implementation_buffer->getPosition()",
          "old_line_content": "        size = implementation_buffer->available();",
          "new_line_content": "        implementation_buffer->getPosition());",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": "elapsedMicroseconds",
          "new_api": "get",
          "old_text": "watch.elapsedMicroseconds()",
          "new_text": "implementation_buffer.get()",
          "old_line_content": "        auto elapsed = watch.elapsedMicroseconds();",
          "new_line_content": "        if (auto * cache_file_reader = dynamic_cast<ReadBufferFromFileDescriptor *>(implementation_buffer.get()))",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceMicroseconds, elapsed)",
          "new_api": "stop",
          "old_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceMicroseconds, elapsed)",
          "new_text": "watch.stop()",
          "old_line_content": "            ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceMicroseconds, elapsed);",
          "new_line_content": "        watch.stop();",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": "range",
          "new_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromCacheBytes, size)",
          "old_text": "file_segment->range()",
          "new_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromCacheBytes, size)",
          "old_line_content": "            assert(file_offset_of_buffer_end + size - 1 <= file_segment->range().right);",
          "new_line_content": "            ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromCacheBytes, size);",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "elapsedMicroseconds",
          "new_api": "range",
          "old_text": "watch.elapsedMicroseconds()",
          "new_text": "file_segment->range()",
          "old_line_content": "                auto elapsed = watch.elapsedMicroseconds();",
          "new_line_content": "            assert(file_offset_of_buffer_end + size - 1 <= file_segment->range().right);",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteMicroseconds, elapsed)",
          "new_api": "reserve",
          "old_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteMicroseconds, elapsed)",
          "new_text": "file_segment->reserve(size)",
          "old_line_content": "                ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteMicroseconds, elapsed);",
          "new_line_content": "            if (file_segment->reserve(size))",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": "getFileOffsetOfBufferEnd",
          "new_api": "begin",
          "old_text": "implementation_buffer->getFileOffsetOfBufferEnd()",
          "new_text": "file_segment->write(\n                    needed_to_predownload ? implementation_buffer->position() : implementation_buffer->buffer().begin(),\n                    size,\n                    file_offset_of_buffer_end)",
          "old_line_content": "                    || file_segment->getDownloadOffset() == implementation_buffer->getFileOffsetOfBufferEnd());",
          "new_line_content": "                file_segment->write(",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": "complete",
          "new_api": "stop",
          "old_text": "file_segment->complete(FileSegment::State::PARTIALLY_DOWNLOADED_NO_CONTINUATION)",
          "new_text": "watch.stop()",
          "old_line_content": "                file_segment->complete(FileSegment::State::PARTIALLY_DOWNLOADED_NO_CONTINUATION);",
          "new_line_content": "                watch.stop();",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": "LOG_DEBUG",
          "new_api": "elapsedMicroseconds",
          "old_text": "LOG_DEBUG(log, \"No space left in cache, will continue without cache download\")",
          "new_text": "watch.elapsedMicroseconds()",
          "old_line_content": "                LOG_DEBUG(log, \"No space left in cache, will continue without cache download\");",
          "new_line_content": "                auto elapsed = watch.elapsedMicroseconds();",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "end",
          "new_api": "getFileOffsetOfBufferEnd",
          "old_text": "file_segments_holder->file_segments.end()",
          "new_text": "implementation_buffer->getFileOffsetOfBufferEnd()",
          "old_line_content": "        if (std::next(current_file_segment_it) == file_segments_holder->file_segments.end())",
          "new_line_content": "                    || file_segment->getDownloadOffset() == implementation_buffer->getFileOffsetOfBufferEnd());",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": "resize",
          "new_api": "complete",
          "old_text": "implementation_buffer->buffer().resize(nextimpl_working_buffer_offset + size)",
          "new_text": "file_segment->complete(FileSegment::State::PARTIALLY_DOWNLOADED_NO_CONTINUATION)",
          "old_line_content": "            implementation_buffer->buffer().resize(nextimpl_working_buffer_offset + size);",
          "new_line_content": "                file_segment->complete(FileSegment::State::PARTIALLY_DOWNLOADED_NO_CONTINUATION);",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": "available",
          "new_api": "end",
          "old_text": "available()",
          "new_text": "file_segments_holder->file_segments.end()",
          "old_line_content": "    current_file_segment_counters.increment(ProfileEvents::FileSegmentUsedBytes, available());",
          "new_line_content": "        if (std::next(current_file_segment_it) == file_segments_holder->file_segments.end())",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": "completeBatchAndResetDownloader",
          "new_api": "std::min(size, remaining_size_to_read)",
          "old_text": "file_segment->completeBatchAndResetDownloader()",
          "new_text": "std::min(size, remaining_size_to_read)",
          "old_line_content": "        file_segment->completeBatchAndResetDownloader();",
          "new_line_content": "            size = std::min(size, remaining_size_to_read);",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": "isDownloader",
          "new_api": "resize",
          "old_text": "file_segment->isDownloader()",
          "new_text": "implementation_buffer->buffer().resize(nextimpl_working_buffer_offset + size)",
          "old_line_content": "    assert(!file_segment->isDownloader());",
          "new_line_content": "            implementation_buffer->buffer().resize(nextimpl_working_buffer_offset + size);",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": "getHexUIntLowercase",
          "new_api": "swap",
          "old_text": "getHexUIntLowercase(cache_key)",
          "new_text": "swap(*implementation_buffer)",
          "old_line_content": "        getHexUIntLowercase(cache_key),",
          "new_line_content": "    swap(*implementation_buffer);",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": "getPosition",
          "new_api": "available",
          "old_text": "getPosition()",
          "new_text": "available()",
          "old_line_content": "        getPosition(),",
          "new_line_content": "    current_file_segment_counters.increment(ProfileEvents::FileSegmentUsedBytes, available());",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": "available",
          "new_api": "completeBatchAndResetDownloader",
          "old_text": "available()",
          "new_text": "file_segment->completeBatchAndResetDownloader()",
          "old_line_content": "        available(),",
          "new_line_content": "        file_segment->completeBatchAndResetDownloader();",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "getDownloadOffset",
          "new_api": "size",
          "old_text": "file_segment->getDownloadOffset()",
          "new_text": "LOG_TEST(\n        log,\n        \"Key: {}. Returning with {} bytes, buffer position: {} (offset: {}, predownloaded: {}), \"\n        \"buffer available: {}, current range: {}, current offset: {}, file segment state: {}, download offset: {}, read_type: {}, \"\n        \"reading until position: {}, started with offset: {}, remaining ranges: {}\",\n        getHexUIntLowercase(cache_key),\n        working_buffer.size(),\n        getPosition(),\n        offset(),\n        needed_to_predownload,\n        available(),\n        current_read_range.toString(),\n        file_offset_of_buffer_end,\n        FileSegment::stateToString(file_segment->state()),\n        file_segment->getDownloadOffset(),\n        toString(read_type),\n        read_until_position,\n        first_offset,\n        file_segments_holder->toString())",
          "old_line_content": "        file_segment->getDownloadOffset(),",
          "new_line_content": "    LOG_TEST(",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "size",
          "new_api": "available",
          "old_text": "cache_file_reader->size()",
          "new_text": "available()",
          "old_line_content": "            cache_file_size = cache_file_reader->size();",
          "new_line_content": "        available(),",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "std::to_string(*cache_file_size)",
          "new_api": "toString",
          "old_text": "std::to_string(*cache_file_size)",
          "new_text": "file_segments_holder->toString()",
          "old_line_content": "            cache_file_size ? std::to_string(*cache_file_size) : \"None\");",
          "new_line_content": "        file_segments_holder->toString());",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": "Exception",
          "new_api": "getTotalSizeToRead",
          "old_text": "Exception(\n            ErrorCodes::LOGICAL_ERROR, \"Read boundaries mismatch. Expected {} < {}\", file_offset_of_buffer_end, read_until_position)",
          "new_text": "getTotalSizeToRead()",
          "old_line_content": "        throw Exception(",
          "new_line_content": "    size_t size = getTotalSizeToRead();",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": "rend",
          "new_api": "Exception",
          "old_text": "file_segments.rend()",
          "new_text": "Exception(ErrorCodes::LOGICAL_ERROR, \"Method `setReadUntilPosition()` not allowed\")",
          "old_line_content": "    for (auto it = file_segments.rbegin(); it != file_segments.rend(); ++it)",
          "new_line_content": "    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Method `setReadUntilPosition()` not allowed\");",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": "getHexUIntLowercase",
          "new_api": "getRemainingReadRange",
          "old_text": "getHexUIntLowercase(cache_key)",
          "new_text": "implementation_buffer->getRemainingReadRange()",
          "old_line_content": "        getHexUIntLowercase(cache_key),",
          "new_line_content": "        auto read_range = implementation_buffer->getRemainingReadRange();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 512,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "file_segments_holder->file_segments.end()",
          "old_line_content": "    if (bytes_to_predownload)",
          "new_line_content": "        && current_file_segment_it != file_segments_holder->file_segments.end())",
          "content_same": false
        },
        {
          "line": 514,
          "old_api": null,
          "new_api": "range",
          "old_text": null,
          "new_text": "*current_file_segment_it)->range()",
          "old_line_content": "        /// Consider this case. Some user needed segment [a, b] and downloaded it partially.",
          "new_line_content": "        appendFilesystemCacheLog((*current_file_segment_it)->range(), read_type);",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": null,
          "new_api": "std::to_string(*read_range.right)",
          "old_text": null,
          "new_text": "std::to_string(*read_range.right)",
          "old_line_content": "        implementation_buffer_read_range_str,",
          "new_line_content": "            = std::to_string(read_range.left) + '-' + (read_range.right ? std::to_string(*read_range.right) : \"None\");",
          "content_same": false
        },
        {
          "line": 521,
          "old_api": null,
          "new_api": "stop",
          "old_text": null,
          "new_text": "SCOPE_EXIT({\n        predownload_watch.stop();\n        current_file_segment_counters.increment(ProfileEvents::FileSegmentPredownloadMicroseconds, predownload_watch.elapsedMicroseconds());\n    })",
          "old_line_content": "",
          "new_line_content": "    SCOPE_EXIT({",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "getInfoForLog",
          "old_text": null,
          "new_text": "*current_file_segment_it)->getInfoForLog()",
          "old_line_content": "}",
          "new_line_content": "        = current_file_segment_it == file_segments_holder->file_segments.end() ? \"None\" : (*current_file_segment_it)->getInfoForLog();",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": null,
          "new_api": "fmt::format(\n        \"Buffer path: {}, hash key: {}, file_offset_of_buffer_end: {}, internal buffer remaining read range: {}, \"\n        \"read_type: {}, last caller: {}, file segment info: {}\",\n        remote_fs_object_path,\n        getHexUIntLowercase(cache_key),\n        file_offset_of_buffer_end,\n        implementation_buffer_read_range_str,\n        toString(read_type),\n        last_caller_id,\n        current_file_segment_info)",
          "old_text": null,
          "new_text": "fmt::format(\n        \"Buffer path: {}, hash key: {}, file_offset_of_buffer_end: {}, internal buffer remaining read range: {}, \"\n        \"read_type: {}, last caller: {}, file segment info: {}\",\n        remote_fs_object_path,\n        getHexUIntLowercase(cache_key),\n        file_offset_of_buffer_end,\n        implementation_buffer_read_range_str,\n        toString(read_type),\n        last_caller_id,\n        current_file_segment_info)",
          "old_line_content": "",
          "new_line_content": "    return fmt::format(",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": null,
          "new_api": "getHexUIntLowercase",
          "old_text": null,
          "new_text": "getHexUIntLowercase(cache_key)",
          "old_line_content": "",
          "new_line_content": "        getHexUIntLowercase(cache_key),",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "toString(read_type)",
          "old_line_content": "",
          "new_line_content": "        toString(read_type),",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": null,
          "new_api": "getDownloadOffset",
          "old_text": null,
          "new_text": "file_segment->getDownloadOffset()",
          "old_line_content": "            }",
          "new_line_content": "        size_t current_offset = file_segment->getDownloadOffset();",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": null,
          "new_api": "eof",
          "old_text": null,
          "new_text": "implementation_buffer->eof()",
          "old_line_content": "                        \"eof: {}\",",
          "new_line_content": "                has_more_data = !implementation_buffer->eof();",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": null,
          "new_api": "increment",
          "old_text": null,
          "new_text": "current_file_segment_counters.increment(ProfileEvents::FileSegmentReadMicroseconds, elapsed)",
          "old_line_content": "                        file_offset_of_buffer_end,",
          "new_line_content": "                current_file_segment_counters.increment(ProfileEvents::FileSegmentReadMicroseconds, elapsed);",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": null,
          "new_api": "getDownloadOffset",
          "old_text": null,
          "new_text": "file_segment->getDownloadOffset()",
          "old_line_content": "                            ErrorCodes::LOGICAL_ERROR,",
          "new_line_content": "                        file_segment->getDownloadOffset(),",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": null,
          "new_api": "eof",
          "old_text": null,
          "new_text": "implementation_buffer->eof()",
          "old_line_content": "                            \"buffer offset: {}, \"",
          "new_line_content": "                        implementation_buffer->eof());",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": null,
          "new_api": "hasPendingData",
          "old_text": null,
          "new_text": "implementation_buffer->hasPendingData()",
          "old_line_content": "                            download_offset,",
          "new_line_content": "                auto result = implementation_buffer->hasPendingData();",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": null,
          "new_api": "offset",
          "old_text": null,
          "new_text": "implementation_buffer->offset()",
          "old_line_content": "                }",
          "new_line_content": "                    nextimpl_working_buffer_offset = implementation_buffer->offset();",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "getDownloadOffset",
          "old_text": null,
          "new_text": "file_segment->getDownloadOffset()",
          "old_line_content": "                break;",
          "new_line_content": "                    auto download_offset = file_segment->getDownloadOffset();",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": null,
          "new_api": "getPosition",
          "old_text": null,
          "new_text": "implementation_buffer->getPosition()",
          "old_line_content": "            }",
          "new_line_content": "                    if (download_offset != static_cast<size_t>(implementation_buffer->getPosition())",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": null,
          "new_api": "getInfoForLog",
          "old_text": null,
          "new_text": "file_segment->getInfoForLog()",
          "old_line_content": "",
          "new_line_content": "                            file_segment->getInfoForLog());",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "implementation_buffer->buffer().size()",
          "old_line_content": "",
          "new_line_content": "            size_t current_impl_buffer_size = implementation_buffer->buffer().size();",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": null,
          "new_api": "LOG_TEST",
          "old_text": null,
          "new_text": "LOG_TEST(log, \"Left to predownload: {}, buffer size: {}\", bytes_to_predownload, current_impl_buffer_size)",
          "old_line_content": "                current_offset += current_predownload_size;",
          "new_line_content": "                LOG_TEST(log, \"Left to predownload: {}, buffer size: {}\", bytes_to_predownload, current_impl_buffer_size);",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": null,
          "new_api": "getPosition",
          "old_text": null,
          "new_text": "implementation_buffer->getPosition()",
          "old_line_content": "                bytes_to_predownload -= current_predownload_size;",
          "new_line_content": "                assert(file_segment->getDownloadOffset() == static_cast<size_t>(implementation_buffer->getPosition()));",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "implementation_buffer->buffer().begin()",
          "old_line_content": "            {",
          "new_line_content": "                file_segment->write(implementation_buffer->buffer().begin(), current_predownload_size, current_offset);",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": null,
          "new_api": "stop",
          "old_text": null,
          "new_text": "watch.stop()",
          "old_line_content": "                ///                   segment{1}",
          "new_line_content": "                watch.stop();",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": null,
          "new_api": "elapsedMicroseconds",
          "old_text": null,
          "new_text": "watch.elapsedMicroseconds()",
          "old_line_content": "                /// cache:         [_____|___________",
          "new_line_content": "                auto elapsed = watch.elapsedMicroseconds();",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": null,
          "new_api": "increment",
          "old_text": null,
          "new_text": "current_file_segment_counters.increment(ProfileEvents::FileSegmentCacheWriteMicroseconds, elapsed)",
          "old_line_content": "                ///                      ^",
          "new_line_content": "                current_file_segment_counters.increment(ProfileEvents::FileSegmentCacheWriteMicroseconds, elapsed);",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": null,
          "new_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteMicroseconds, elapsed)",
          "old_text": null,
          "new_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteMicroseconds, elapsed)",
          "old_line_content": "                ///                      download_offset",
          "new_line_content": "                ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteMicroseconds, elapsed);",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": null,
          "new_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteBytes, current_predownload_size)",
          "old_text": null,
          "new_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteBytes, current_predownload_size)",
          "old_line_content": "                /// requested_range:          [__________]",
          "new_line_content": "                ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteBytes, current_predownload_size);",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": null,
          "new_api": "position",
          "old_text": null,
          "new_text": "implementation_buffer->position()",
          "old_line_content": "                /// return buffer back, seek to actual position.",
          "new_line_content": "                implementation_buffer->position() += current_predownload_size;",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": null,
          "new_api": "swap",
          "old_text": null,
          "new_text": "swap(*implementation_buffer)",
          "old_line_content": "",
          "new_line_content": "                swap(*implementation_buffer);",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "working_buffer.resize(0)",
          "old_line_content": "                break;",
          "new_line_content": "                working_buffer.resize(0);",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "working_buffer.end()",
          "old_line_content": "            }",
          "new_line_content": "                position() = working_buffer.end();",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": null,
          "new_api": "getRemoteFSReadBuffer",
          "old_text": null,
          "new_text": "getRemoteFSReadBuffer(file_segment, read_type)",
          "old_line_content": "    }",
          "new_line_content": "                implementation_buffer = getRemoteFSReadBuffer(file_segment, read_type);",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": null,
          "new_api": "swap",
          "old_text": null,
          "new_text": "swap(*implementation_buffer)",
          "old_line_content": "",
          "new_line_content": "                swap(*implementation_buffer);",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": null,
          "new_api": "seek",
          "old_text": null,
          "new_text": "implementation_buffer->seek(file_offset_of_buffer_end, SEEK_SET)",
          "old_line_content": "{",
          "new_line_content": "                implementation_buffer->seek(file_offset_of_buffer_end, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": null,
          "new_api": "range",
          "old_text": null,
          "new_text": "file_segment->range()",
          "old_line_content": "        /// it means the following case, e.g. we started from CacheReadBuffer and continue with RemoteFSReadBuffer.",
          "new_line_content": "    auto current_read_range = file_segment->range();",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": null,
          "new_api": "state",
          "old_text": null,
          "new_text": "file_segment->state()",
          "old_line_content": "        ///                      segment{k}",
          "new_line_content": "    auto current_state = file_segment->state();",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(current_read_range.left <= file_offset_of_buffer_end)",
          "old_line_content": "        ///                         ^",
          "new_line_content": "    assert(current_read_range.left <= file_offset_of_buffer_end);",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": null,
          "new_api": "isDownloader",
          "old_text": null,
          "new_text": "file_segment->isDownloader()",
          "old_line_content": "        ///                         download_offset",
          "new_line_content": "    assert(!file_segment->isDownloader());",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": null,
          "new_api": "completeFileSegmentAndGetNext",
          "old_text": null,
          "new_text": "completeFileSegmentAndGetNext()",
          "old_line_content": "",
          "new_line_content": "        return completeFileSegmentAndGetNext();",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "getDownloadOffset",
          "old_text": null,
          "new_text": "file_segment->getDownloadOffset()",
          "old_line_content": "    {",
          "new_line_content": "        auto download_offset = file_segment->getDownloadOffset();",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": null,
          "new_api": "getImplementationBuffer",
          "old_text": null,
          "new_text": "getImplementationBuffer(*current_file_segment_it)",
          "old_line_content": "        * for this file segment. However, the downloader's term has a lifespan of 1 nextImpl() call,",
          "new_line_content": "            implementation_buffer = getImplementationBuffer(*current_file_segment_it);",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\n                ErrorCodes::LOGICAL_ERROR, \"Expected {} >= {} ({})\", download_offset, file_offset_of_buffer_end, getInfoForLog())",
          "old_line_content": "        * because there is no guarantee on a higher level, that current buffer will not disappear without",
          "new_line_content": "            throw Exception(",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": null,
          "new_api": "getInfoForLog",
          "old_text": null,
          "new_text": "getInfoForLog()",
          "old_line_content": "        * being destructed till the end of query or without finishing the read range, which he was supposed",
          "new_line_content": "                ErrorCodes::LOGICAL_ERROR, \"Expected {} >= {} ({})\", download_offset, file_offset_of_buffer_end, getInfoForLog());",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": null,
          "new_api": "nextImplStep",
          "old_text": null,
          "new_text": "nextImplStep()",
          "old_line_content": "",
          "new_line_content": "        return nextImplStep();",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": null,
          "new_api": "getTotalSizeToRead",
          "old_text": null,
          "new_text": "getTotalSizeToRead()",
          "old_line_content": "            auto & file_segment = *current_file_segment_it;",
          "new_line_content": "        initialize(file_offset_of_buffer_end, getTotalSizeToRead());",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "file_segments_holder->file_segments.end()",
          "old_line_content": "            bool download_current_segment = read_type == ReadType::REMOTE_FS_READ_AND_PUT_IN_CACHE;",
          "new_line_content": "    if (current_file_segment_it == file_segments_holder->file_segments.end())",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "file_segments_holder->file_segments.end()",
          "old_line_content": "            }",
          "new_line_content": "            if (current_file_segment_it == file_segments_holder->file_segments.end())",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": null,
          "new_api": "isDownloader",
          "old_text": null,
          "new_text": "file_segment->isDownloader()",
          "old_line_content": "    });",
          "new_line_content": "                bool need_complete_file_segment = file_segment->isDownloader();",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "getDownloader",
          "old_text": null,
          "new_text": "file_segment->getDownloader()",
          "old_line_content": "",
          "new_line_content": "                    LOG_TEST(log, \"Resetting downloader {} from scope exit\", file_segment->getDownloader());",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": null,
          "new_api": "completeBatchAndResetDownloader",
          "old_text": null,
          "new_text": "file_segment->completeBatchAndResetDownloader()",
          "old_line_content": "    if (implementation_buffer)",
          "new_line_content": "                    file_segment->completeBatchAndResetDownloader();",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": null,
          "new_api": "isDownloader",
          "old_text": null,
          "new_text": "file_segment->isDownloader()",
          "old_line_content": "            return false;",
          "new_line_content": "            assert(!file_segment->isDownloader());",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": null,
          "new_api": "updateImplementationBufferIfNeeded",
          "old_text": null,
          "new_text": "updateImplementationBufferIfNeeded()",
          "old_line_content": "",
          "new_line_content": "        bool can_read_further = updateImplementationBufferIfNeeded();",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": null,
          "new_api": "getImplementationBuffer",
          "old_text": null,
          "new_text": "getImplementationBuffer(*current_file_segment_it)",
          "old_line_content": "        \"Current segment: {}, downloader: {}, current count: {}, position: {}\",",
          "new_line_content": "        implementation_buffer = getImplementationBuffer(*current_file_segment_it);",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": null,
          "new_api": "range",
          "old_text": null,
          "new_text": "file_segment->range()",
          "old_line_content": "    size_t size = 0;",
          "new_line_content": "    auto current_read_range = file_segment->range();",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "LOG_TEST(\n        log,\n        \"Current segment: {}, downloader: {}, current count: {}, position: {}\",\n        current_read_range.toString(),\n        file_segment->getDownloader(),\n        implementation_buffer->count(),\n        implementation_buffer->getPosition())",
          "old_line_content": "    size_t needed_to_predownload = bytes_to_predownload;",
          "new_line_content": "    LOG_TEST(",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": null,
          "new_api": "getDownloader",
          "old_text": null,
          "new_text": "file_segment->getDownloader()",
          "old_line_content": "",
          "new_line_content": "        file_segment->getDownloader(),",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(current_read_range.left <= file_offset_of_buffer_end)",
          "old_line_content": "",
          "new_line_content": "    assert(current_read_range.left <= file_offset_of_buffer_end);",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(current_read_range.right >= file_offset_of_buffer_end)",
          "old_line_content": "    auto download_current_segment = read_type == ReadType::REMOTE_FS_READ_AND_PUT_IN_CACHE;",
          "new_line_content": "    assert(current_read_range.right >= file_offset_of_buffer_end);",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": null,
          "new_api": "getCacheReadBuffer",
          "old_text": null,
          "new_text": "getCacheReadBuffer(range.left)",
          "old_line_content": "                        /// cache:           [______|___________",
          "new_line_content": "                    return getCacheReadBuffer(range.left);",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": null,
          "new_api": "getOrSetDownloader",
          "old_text": null,
          "new_text": "file_segment->getOrSetDownloader()",
          "old_line_content": "                        /// requested_range:    [__________]",
          "new_line_content": "                auto downloader_id = file_segment->getOrSetDownloader();",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": null,
          "new_api": "getCallerId",
          "old_text": null,
          "new_text": "file_segment->getCallerId()",
          "old_line_content": "                        ///                     ^",
          "new_line_content": "                if (downloader_id == file_segment->getCallerId())",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": null,
          "new_api": "predownload",
          "old_text": null,
          "new_text": "predownload(file_segment)",
          "old_line_content": "",
          "new_line_content": "        predownload(file_segment);",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": null,
          "new_api": "getDownloadOffset",
          "old_text": null,
          "new_text": "file_segment->getDownloadOffset()",
          "old_line_content": "",
          "new_line_content": "                    size_t download_offset = file_segment->getDownloadOffset();",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": null,
          "new_api": "hasPendingData",
          "old_text": null,
          "new_text": "implementation_buffer->hasPendingData()",
          "old_line_content": "    {",
          "new_line_content": "        result = implementation_buffer->hasPendingData();",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": null,
          "new_api": "available",
          "old_text": null,
          "new_text": "implementation_buffer->available()",
          "old_line_content": "#ifndef NDEBUG",
          "new_line_content": "        size = implementation_buffer->available();",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": null,
          "new_api": "isDownloader",
          "old_text": null,
          "new_text": "file_segment->isDownloader()",
          "old_line_content": "            if (cache_file_size == 0)",
          "new_line_content": "    if (download_current_segment != file_segment->isDownloader())",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": null,
          "new_api": "getInfoForLog",
          "old_text": null,
          "new_text": "Exception(\n            ErrorCodes::LOGICAL_ERROR,\n            \"Incorrect segment state. Having read type: {}, file segment info: {}\",\n            toString(read_type), file_segment->getInfoForLog())",
          "old_line_content": "                    ErrorCodes::LOGICAL_ERROR, \"Attempt to read from an empty cache file: {} (just before actual read)\", cache_file_size);",
          "new_line_content": "        throw Exception(",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": null,
          "new_api": "getInfoForLog",
          "old_text": null,
          "new_text": "file_segment->getInfoForLog()",
          "old_line_content": "",
          "new_line_content": "            toString(read_type), file_segment->getInfoForLog());",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "cache_file_reader->size()",
          "old_line_content": "",
          "new_line_content": "            auto cache_file_size = cache_file_reader->size();",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\n                    ErrorCodes::LOGICAL_ERROR, \"Attempt to read from an empty cache file: {} (just before actual read)\", cache_file_size)",
          "old_line_content": "",
          "new_line_content": "                throw Exception(",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "implementation_buffer->next()",
          "old_line_content": "        {",
          "new_line_content": "        result = implementation_buffer->next();",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": null,
          "new_api": "getDownloadOffset",
          "old_text": null,
          "new_text": "file_segment->getDownloadOffset()",
          "old_line_content": "            }",
          "new_line_content": "                        assert(file_offset_of_buffer_end > file_segment->getDownloadOffset());",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": null,
          "new_api": "getDownloadOffset",
          "old_text": null,
          "new_text": "file_segment->getDownloadOffset()",
          "old_line_content": "            case FileSegment::State::PARTIALLY_DOWNLOADED_NO_CONTINUATION:",
          "new_line_content": "                        bytes_to_predownload = file_offset_of_buffer_end - file_segment->getDownloadOffset();",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": null,
          "new_api": "elapsedMicroseconds",
          "old_text": null,
          "new_text": "watch.elapsedMicroseconds()",
          "old_line_content": "        }",
          "new_line_content": "        auto elapsed = watch.elapsedMicroseconds();",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": null,
          "new_api": "increment",
          "old_text": null,
          "new_text": "current_file_segment_counters.increment(ProfileEvents::FileSegmentReadMicroseconds, elapsed)",
          "old_line_content": "    }",
          "new_line_content": "        current_file_segment_counters.increment(ProfileEvents::FileSegmentReadMicroseconds, elapsed);",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": null,
          "new_api": "getDownloadOffset",
          "old_text": null,
          "new_text": "file_segment->getDownloadOffset()",
          "old_line_content": "                bool can_start_from_cache = download_offset > file_offset_of_buffer_end;",
          "new_line_content": "                    download_offset = file_segment->getDownloadOffset();",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "implementation_buffer->buffer().size()",
          "old_line_content": "    if (result)",
          "new_line_content": "        size = implementation_buffer->buffer().size();",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(!can_start_from_cache)",
          "old_line_content": "                if (can_start_from_cache)",
          "new_line_content": "                    assert(!can_start_from_cache);",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": null,
          "new_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromCacheMicroseconds, elapsed)",
          "old_text": null,
          "new_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromCacheMicroseconds, elapsed)",
          "old_line_content": "",
          "new_line_content": "            ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromCacheMicroseconds, elapsed);",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": null,
          "new_api": "state",
          "old_text": null,
          "new_text": "file_segment->state()",
          "old_line_content": "                {",
          "new_line_content": "                download_state = file_segment->state();",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": null,
          "new_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceBytes, size)",
          "old_text": null,
          "new_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceBytes, size)",
          "old_line_content": "",
          "new_line_content": "            ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceBytes, size);",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": null,
          "new_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceMicroseconds, elapsed)",
          "old_text": null,
          "new_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceMicroseconds, elapsed)",
          "old_line_content": "                Stopwatch watch(CLOCK_MONOTONIC);",
          "new_line_content": "            ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceMicroseconds, elapsed);",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": null,
          "new_api": "getDownloadOffset",
          "old_text": null,
          "new_text": "file_segment->getDownloadOffset()",
          "old_line_content": "        }",
          "new_line_content": "                size_t download_offset = file_segment->getDownloadOffset();",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": null,
          "new_api": "getPosition",
          "old_text": null,
          "new_text": "implementation_buffer->getPosition()",
          "old_line_content": "",
          "new_line_content": "                assert(file_segment->getDownloadOffset() == static_cast<size_t>(implementation_buffer->getPosition()));",
          "content_same": false
        },
        {
          "line": 360,
          "old_api": null,
          "new_api": "getRemoteFSReadBuffer",
          "old_text": null,
          "new_text": "getRemoteFSReadBuffer(file_segment, read_type)",
          "old_line_content": "",
          "new_line_content": "                    return getRemoteFSReadBuffer(file_segment, read_type);",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "implementation_buffer->buffer().begin()",
          "old_line_content": "            }",
          "new_line_content": "                    needed_to_predownload ? implementation_buffer->position() : implementation_buffer->buffer().begin(),",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": null,
          "new_api": "increment",
          "old_text": null,
          "new_text": "current_file_segment_counters.increment(ProfileEvents::FileSegmentCacheWriteMicroseconds, elapsed)",
          "old_line_content": "            }",
          "new_line_content": "                current_file_segment_counters.increment(ProfileEvents::FileSegmentCacheWriteMicroseconds, elapsed);",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": null,
          "new_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteMicroseconds, elapsed)",
          "old_text": null,
          "new_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteMicroseconds, elapsed)",
          "old_line_content": "        }",
          "new_line_content": "                ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteMicroseconds, elapsed);",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": null,
          "new_api": "range",
          "old_text": null,
          "new_text": "file_segment->range()",
          "old_line_content": "",
          "new_line_content": "    assert(file_offset_of_buffer_end >= file_segment->range().left);",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": null,
          "new_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteBytes, size)",
          "old_text": null,
          "new_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteBytes, size)",
          "old_line_content": "",
          "new_line_content": "                ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteBytes, size);",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": null,
          "new_api": "range",
          "old_text": null,
          "new_text": "file_segment->range()",
          "old_line_content": "        /// the requested right boundary could be segment->range().left < requested_right_boundary <  segment->range().right.",
          "new_line_content": "                assert(file_segment->getDownloadOffset() <= file_segment->range().right + 1);",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "assert(\n                    std::next(current_file_segment_it) == file_segments_holder->file_segments.end()\n                    || file_segment->getDownloadOffset() == implementation_buffer->getFileOffsetOfBufferEnd())",
          "old_line_content": "        /// Therefore need to resize to a smaller size. And resize must be done after write into cache.",
          "new_line_content": "                assert(",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "file_segments_holder->file_segments.end()",
          "old_line_content": "        /// - If last file segment was read from local fs, then we could read more than file_segemnt->range().right, so resize is also needed.",
          "new_line_content": "                    std::next(current_file_segment_it) == file_segments_holder->file_segments.end()",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": null,
          "new_api": "stop",
          "old_text": null,
          "new_text": "watch.stop()",
          "old_line_content": "        file_offset_of_buffer_end);",
          "new_line_content": "    watch.stop();",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": null,
          "new_api": "elapsedMicroseconds",
          "old_text": null,
          "new_text": "watch.elapsedMicroseconds()",
          "old_line_content": "",
          "new_line_content": "    current_file_segment_counters.increment(ProfileEvents::FileSegmentWaitReadBufferMicroseconds, watch.elapsedMicroseconds());",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"No space left in cache, will continue without cache download\")",
          "old_line_content": "        }",
          "new_line_content": "                LOG_DEBUG(log, \"No space left in cache, will continue without cache download\");",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": null,
          "new_api": "maybe_unused",
          "old_text": null,
          "new_text": "maybe_unused",
          "old_line_content": "",
          "new_line_content": "    [[maybe_unused]] auto download_current_segment = read_type == ReadType::REMOTE_FS_READ_AND_PUT_IN_CACHE;",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": null,
          "new_api": "isDownloader",
          "old_text": null,
          "new_text": "file_segment->isDownloader()",
          "old_line_content": "    switch (read_type)",
          "new_line_content": "    assert(download_current_segment == file_segment->isDownloader());",
          "content_same": false
        },
        {
          "line": 385,
          "old_api": null,
          "new_api": "range",
          "old_text": null,
          "new_text": "file_segment->range()",
          "old_line_content": "        case ReadType::CACHED:",
          "new_line_content": "    assert(file_segment->range() == range);",
          "content_same": false
        },
        {
          "line": 386,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(file_offset_of_buffer_end >= range.left && file_offset_of_buffer_end <= range.right)",
          "old_line_content": "        {",
          "new_line_content": "    assert(file_offset_of_buffer_end >= range.left && file_offset_of_buffer_end <= range.right);",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "range.toString()",
          "old_line_content": "            if (file_size == 0 || range.left + file_size <= file_offset_of_buffer_end)",
          "new_line_content": "        range.toString(),",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": null,
          "new_api": "std::min(current_read_range.right, read_until_position - 1)",
          "old_text": null,
          "new_text": "std::min(current_read_range.right, read_until_position - 1)",
          "old_line_content": "    if (download_current_segment)",
          "new_line_content": "            size_t remaining_size_to_read = std::min(current_read_range.right, read_until_position - 1) - file_offset_of_buffer_end + 1;",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "implementation_buffer->buffer().size()",
          "old_line_content": "",
          "new_line_content": "            assert(implementation_buffer->buffer().size() >= nextimpl_working_buffer_offset + size);",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": null,
          "new_api": "setReadUntilPosition",
          "old_text": null,
          "new_text": "read_buffer_for_file_segment->setReadUntilPosition(range.right + 1)",
          "old_line_content": "                    \"expected file size to be non-zero and file downloaded size to exceed current file read offset (expected: {} > {})\",",
          "new_line_content": "    read_buffer_for_file_segment->setReadUntilPosition(range.right + 1); /// [..., range.right]",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "read_buffer_for_file_segment.get()",
          "old_line_content": "            size_t seek_offset = file_offset_of_buffer_end - range.left;",
          "new_line_content": "            auto * file_reader = dynamic_cast<ReadBufferFromFileDescriptor *>(read_buffer_for_file_segment.get());",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "file_reader->size()",
          "old_line_content": "",
          "new_line_content": "            size_t file_size = file_reader->size();",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\n                    ErrorCodes::LOGICAL_ERROR,\n                    \"Unexpected state of cache file. Cache file size: {}, cache file offset: {}, \"\n                    \"expected file size to be non-zero and file downloaded size to exceed current file read offset (expected: {} > {})\",\n                    file_size,\n                    range.left,\n                    range.left + file_size,\n                    file_offset_of_buffer_end)",
          "old_line_content": "                    ErrorCodes::LOGICAL_ERROR,",
          "new_line_content": "                throw Exception(",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "isDownloader",
          "old_text": null,
          "new_text": "file_segment->isDownloader()",
          "old_line_content": "        file_offset_of_buffer_end,",
          "new_line_content": "    assert(!file_segment->isDownloader());",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": null,
          "new_api": "getHexUIntLowercase",
          "old_text": null,
          "new_text": "getHexUIntLowercase(cache_key)",
          "old_line_content": "",
          "new_line_content": "        getHexUIntLowercase(cache_key),",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "working_buffer.size()",
          "old_line_content": "    if (size == 0 && file_offset_of_buffer_end < read_until_position)",
          "new_line_content": "        working_buffer.size(),",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": null,
          "new_api": "getPosition",
          "old_text": null,
          "new_text": "getPosition()",
          "old_line_content": "    {",
          "new_line_content": "        getPosition(),",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": null,
          "new_api": "offset",
          "old_text": null,
          "new_text": "offset()",
          "old_line_content": "        std::optional<size_t> cache_file_size;",
          "new_line_content": "        offset(),",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\n                    ErrorCodes::LOGICAL_ERROR,\n                    \"Invariant failed. Expected {} > {} (current offset > file segment's start offset)\",\n                    file_offset_of_buffer_end,\n                    range.left)",
          "old_line_content": "        }",
          "new_line_content": "                throw Exception(",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "current_read_range.toString()",
          "old_line_content": "",
          "new_line_content": "        current_read_range.toString(),",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": null,
          "new_api": "state",
          "old_text": null,
          "new_text": "file_segment->state()",
          "old_line_content": "            ErrorCodes::LOGICAL_ERROR,",
          "new_line_content": "        FileSegment::stateToString(file_segment->state()),",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "getDownloadOffset",
          "old_text": null,
          "new_text": "file_segment->getDownloadOffset()",
          "old_line_content": "            \"Having zero bytes, but range is not finished: file offset: {}, reading until: {}, read type: {}, cache file size: {}\",",
          "new_line_content": "        file_segment->getDownloadOffset(),",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": null,
          "new_api": "seek",
          "old_text": null,
          "new_text": "read_buffer_for_file_segment->seek(seek_offset, SEEK_SET)",
          "old_line_content": "            {",
          "new_line_content": "            read_buffer_for_file_segment->seek(seek_offset, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "toString(read_type)",
          "old_line_content": "            file_offset_of_buffer_end,",
          "new_line_content": "        toString(read_type),",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "implementation_buffer.get()",
          "old_line_content": "",
          "new_line_content": "        if (auto * cache_file_reader = dynamic_cast<ReadBufferFromFileDescriptor *>(implementation_buffer.get()))",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "cache_file_reader->size()",
          "old_line_content": "off_t CachedReadBufferFromRemoteFS::seek(off_t offset, int whence)",
          "new_line_content": "            cache_file_size = cache_file_reader->size();",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": null,
          "new_api": "isDownloader",
          "old_text": null,
          "new_text": "file_segment->isDownloader()",
          "old_line_content": "            {",
          "new_line_content": "            assert(file_segment->isDownloader());",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\n            ErrorCodes::LOGICAL_ERROR,\n            \"Having zero bytes, but range is not finished: file offset: {}, reading until: {}, read type: {}, cache file size: {}\",\n            file_offset_of_buffer_end,\n            read_until_position,\n            toString(read_type),\n            cache_file_size ? std::to_string(*cache_file_size) : \"None\")",
          "old_line_content": "    if (initialized)",
          "new_line_content": "        throw Exception(",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": null,
          "new_api": "getDownloadOffset",
          "old_text": null,
          "new_text": "file_segment->getDownloadOffset()",
          "old_line_content": "                    \"Buffer's offsets mismatch; cached buffer offset: {}, download_offset: {}, position: {}, implementation buffer offset: \"",
          "new_line_content": "                size_t download_offset = file_segment->getDownloadOffset();",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": null,
          "new_api": "seek",
          "old_text": null,
          "new_text": "read_buffer_for_file_segment->seek(download_offset, SEEK_SET)",
          "old_line_content": "                    \"{}, \"",
          "new_line_content": "                read_buffer_for_file_segment->seek(download_offset, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "toString(read_type)",
          "old_line_content": "",
          "new_line_content": "            toString(read_type),",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": null,
          "new_api": "std::to_string(*cache_file_size)",
          "old_text": null,
          "new_text": "std::to_string(*cache_file_size)",
          "old_line_content": "    first_offset = offset;",
          "new_line_content": "            cache_file_size ? std::to_string(*cache_file_size) : \"None\");",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": null,
          "new_api": "getPosition",
          "old_text": null,
          "new_text": "read_buffer_for_file_segment->getPosition()",
          "old_line_content": "            }",
          "new_line_content": "            if (download_offset != static_cast<size_t>(read_buffer_for_file_segment->getPosition()))",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": null,
          "new_api": "getRemainingReadRange",
          "old_text": null,
          "new_text": "read_buffer_for_file_segment->getRemainingReadRange()",
          "old_line_content": "            break;",
          "new_line_content": "                auto impl_range = read_buffer_for_file_segment->getRemainingReadRange();",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": null,
          "new_api": "getPosition",
          "old_text": null,
          "new_text": "Exception(\n                    ErrorCodes::LOGICAL_ERROR,\n                    \"Buffer's offsets mismatch; cached buffer offset: {}, download_offset: {}, position: {}, implementation buffer offset: \"\n                    \"{}, \"\n                    \"implementation buffer reading until: {}, file segment info: {}\",\n                    file_offset_of_buffer_end,\n                    download_offset,\n                    read_buffer_for_file_segment->getPosition(),\n                    impl_range.left,\n                    *impl_range.right,\n                    file_segment->getInfoForLog())",
          "old_line_content": "        }",
          "new_line_content": "                throw Exception(",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::CANNOT_SEEK_THROUGH_FILE, \"Seek is allowed only before first read attempt from the buffer\")",
          "old_line_content": "{",
          "new_line_content": "        throw Exception(ErrorCodes::CANNOT_SEEK_THROUGH_FILE, \"Seek is allowed only before first read attempt from the buffer\");",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": null,
          "new_api": "getPosition",
          "old_text": null,
          "new_text": "read_buffer_for_file_segment->getPosition()",
          "old_line_content": "{",
          "new_line_content": "                    read_buffer_for_file_segment->getPosition(),",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": null,
          "new_api": "initialize",
          "old_text": null,
          "new_text": "initialize(offset, size)",
          "old_line_content": "            ErrorCodes::LOGICAL_ERROR, \"Read boundaries mismatch. Expected {} < {}\", file_offset_of_buffer_end, read_until_position);",
          "new_line_content": "    initialize(offset, size);",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": null,
          "new_api": "getInfoForLog",
          "old_text": null,
          "new_text": "file_segment->getInfoForLog()",
          "old_line_content": "    if (enable_logging)",
          "new_line_content": "                    file_segment->getInfoForLog());",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::LOGICAL_ERROR, \"Last position was not set\")",
          "old_line_content": "",
          "new_line_content": "        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Last position was not set\");",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\n            ErrorCodes::LOGICAL_ERROR, \"Read boundaries mismatch. Expected {} < {}\", file_offset_of_buffer_end, read_until_position)",
          "old_line_content": "}",
          "new_line_content": "        throw Exception(",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": null,
          "new_api": "range",
          "old_text": null,
          "new_text": "*current_file_segment_it)->range()",
          "old_line_content": "",
          "new_line_content": "        appendFilesystemCacheLog((*current_file_segment_it)->range(), read_type);",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(file_offset_of_buffer_end > range.right)",
          "old_line_content": "        return false;",
          "new_line_content": "    assert(file_offset_of_buffer_end > range.right);",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": null,
          "new_api": "available",
          "old_text": null,
          "new_text": "available()",
          "old_line_content": "    }",
          "new_line_content": "    return file_offset_of_buffer_end - available();",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": null,
          "new_api": "getDownloader",
          "old_text": null,
          "new_text": "file_segment->getDownloader()",
          "old_line_content": "",
          "new_line_content": "        file_segment->getDownloader(),",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::LOGICAL_ERROR, \"File segments holder not initialized\")",
          "old_line_content": "{",
          "new_line_content": "        throw Exception(ErrorCodes::LOGICAL_ERROR, \"File segments holder not initialized\");",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "file_segments_holder->file_segments.erase(file_segment_it)",
          "old_line_content": "CachedReadBufferFromRemoteFS::~CachedReadBufferFromRemoteFS()",
          "new_line_content": "    file_segments_holder->file_segments.erase(file_segment_it);",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": null,
          "new_api": "rend",
          "old_text": null,
          "new_text": "file_segments.rend()",
          "old_line_content": "}",
          "new_line_content": "    for (auto it = file_segments.rbegin(); it != file_segments.rend(); ++it)",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "file_segments_holder->file_segments.end()",
          "old_line_content": "    if (enable_logging",
          "new_line_content": "    if (current_file_segment_it == file_segments_holder->file_segments.end())",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": null,
          "new_api": "state",
          "old_text": null,
          "new_text": "file_segment->state()",
          "old_line_content": "{",
          "new_line_content": "        if (file_segment->state() != FileSegment::State::DOWNLOADED)",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": null,
          "new_api": "range",
          "old_text": null,
          "new_text": "file_segment->range()",
          "old_line_content": "    String implementation_buffer_read_range_str;",
          "new_line_content": "            return file_segment->range().right;",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": null,
          "new_api": "getImplementationBuffer",
          "old_text": null,
          "new_text": "getImplementationBuffer(*current_file_segment_it)",
          "old_line_content": "    {",
          "new_line_content": "    implementation_buffer = getImplementationBuffer(*current_file_segment_it);",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": null,
          "new_api": "incrementHitsCount",
          "old_text": null,
          "new_text": "*current_file_segment_it)->incrementHitsCount()",
          "old_line_content": "}",
          "new_line_content": "        (*current_file_segment_it)->incrementHitsCount();",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "*current_file_segment_it)->range().toString()",
          "old_line_content": "void CachedReadBufferFromRemoteFS::predownload(FileSegmentPtr & file_segment)",
          "new_line_content": "    LOG_TEST(log, \"New segment: {}\", (*current_file_segment_it)->range().toString());",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": null,
          "new_api": "IFileCache::isReadOnly()",
          "old_text": null,
          "new_text": "IFileCache::isReadOnly()",
          "old_line_content": "        implementation_buffer_read_range_str = \"None\";",
          "new_line_content": "    if (IFileCache::isReadOnly() && !settings.read_from_filesystem_cache_if_exists_otherwise_bypass_cache)",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::LOGICAL_ERROR, \"Cache usage is not allowed\")",
          "old_line_content": "",
          "new_line_content": "        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cache usage is not allowed\");",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 509,
          "old_api": "elapsedMicroseconds",
          "new_api": null,
          "old_text": "predownload_watch.elapsedMicroseconds()",
          "new_text": null,
          "old_line_content": "        current_file_segment_counters.increment(ProfileEvents::FileSegmentPredownloadMicroseconds, predownload_watch.elapsedMicroseconds());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": "toString",
          "new_api": null,
          "old_text": "toString(read_type)",
          "new_text": null,
          "old_line_content": "        toString(read_type),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": "FileSegment::getCallerId()",
          "new_api": null,
          "old_text": "FileSegment::getCallerId()",
          "new_text": null,
          "old_line_content": "        LOG_TEST(log, \"Bytes to predownload: {}, caller_id: {}\", bytes_to_predownload, FileSegment::getCallerId());",
          "new_line_content": "    Stopwatch predownload_watch(CLOCK_MONOTONIC);",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "eof",
          "new_api": null,
          "old_text": "implementation_buffer->eof()",
          "new_text": null,
          "old_line_content": "                has_more_data = !implementation_buffer->eof();",
          "new_line_content": "        /// downloaded because it intersects with the range he needs.",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": "stop",
          "new_api": null,
          "old_text": "watch.stop()",
          "new_text": null,
          "old_line_content": "                watch.stop();",
          "new_line_content": "        /// download from offset a'' < a', but return buffer from offset a'.",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": "increment",
          "new_api": null,
          "old_text": "current_file_segment_counters.increment(ProfileEvents::FileSegmentReadMicroseconds, elapsed)",
          "new_text": null,
          "old_line_content": "                current_file_segment_counters.increment(ProfileEvents::FileSegmentReadMicroseconds, elapsed);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": "toString",
          "new_api": null,
          "old_text": "Exception(\n                        ErrorCodes::LOGICAL_ERROR,\n                        \"Failed to predownload remaining {} bytes. Current file segment: {}, current download offset: {}, expected: {}, \"\n                        \"eof: {}\",\n                        bytes_to_predownload,\n                        file_segment->range().toString(),\n                        file_segment->getDownloadOffset(),\n                        file_offset_of_buffer_end,\n                        implementation_buffer->eof())",
          "new_text": null,
          "old_line_content": "                    throw Exception(",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": "hasPendingData",
          "new_api": null,
          "old_text": "implementation_buffer->hasPendingData()",
          "new_text": null,
          "old_line_content": "                auto result = implementation_buffer->hasPendingData();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": "getDownloadOffset",
          "new_api": null,
          "old_text": "file_segment->getDownloadOffset()",
          "new_text": null,
          "old_line_content": "                    auto download_offset = file_segment->getDownloadOffset();",
          "new_line_content": "                        \"Failed to predownload remaining {} bytes. Current file segment: {}, current download offset: {}, expected: {}, \"",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": "getPosition",
          "new_api": null,
          "old_text": "implementation_buffer->getPosition()",
          "new_text": null,
          "old_line_content": "                    if (download_offset != static_cast<size_t>(implementation_buffer->getPosition())",
          "new_line_content": "                        \"eof: {}\",",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": "getPosition",
          "new_api": null,
          "old_text": "implementation_buffer->getPosition()",
          "new_text": null,
          "old_line_content": "                            implementation_buffer->getPosition(),",
          "new_line_content": "                if (result)",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": "getInfoForLog",
          "new_api": null,
          "old_text": "file_segment->getInfoForLog()",
          "new_text": null,
          "old_line_content": "                            file_segment->getInfoForLog());",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "std::min(current_impl_buffer_size, bytes_to_predownload)",
          "new_api": null,
          "old_text": "std::min(current_impl_buffer_size, bytes_to_predownload)",
          "new_text": null,
          "old_line_content": "            size_t current_predownload_size = std::min(current_impl_buffer_size, bytes_to_predownload);",
          "new_line_content": "                            ErrorCodes::LOGICAL_ERROR,",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceBytes, current_impl_buffer_size)",
          "new_api": null,
          "old_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceBytes, current_impl_buffer_size)",
          "new_text": null,
          "old_line_content": "            ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceBytes, current_impl_buffer_size);",
          "new_line_content": "                            \"buffer offset: {}, \"",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "file_segment->reserve(current_predownload_size)",
          "new_text": null,
          "old_line_content": "            if (file_segment->reserve(current_predownload_size))",
          "new_line_content": "                            download_offset,",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "getPosition",
          "new_api": null,
          "old_text": "implementation_buffer->getPosition()",
          "new_text": null,
          "old_line_content": "                assert(file_segment->getDownloadOffset() == static_cast<size_t>(implementation_buffer->getPosition()));",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": "begin",
          "new_api": null,
          "old_text": "implementation_buffer->buffer().begin()",
          "new_text": null,
          "old_line_content": "                file_segment->write(implementation_buffer->buffer().begin(), current_predownload_size, current_offset);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": "elapsedMicroseconds",
          "new_api": null,
          "old_text": "watch.elapsedMicroseconds()",
          "new_text": null,
          "old_line_content": "                auto elapsed = watch.elapsedMicroseconds();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteMicroseconds, elapsed)",
          "new_api": null,
          "old_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteMicroseconds, elapsed)",
          "new_text": null,
          "old_line_content": "                ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteMicroseconds, elapsed);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": "position",
          "new_api": null,
          "old_text": "implementation_buffer->position()",
          "new_text": null,
          "old_line_content": "                implementation_buffer->position() += current_predownload_size;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": "complete",
          "new_api": null,
          "old_text": "file_segment->complete(FileSegment::State::PARTIALLY_DOWNLOADED_NO_CONTINUATION)",
          "new_text": null,
          "old_line_content": "                file_segment->complete(FileSegment::State::PARTIALLY_DOWNLOADED_NO_CONTINUATION);",
          "new_line_content": "                /// cache:         [_____|___________",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": "swap",
          "new_api": null,
          "old_text": "swap(*implementation_buffer)",
          "new_text": null,
          "old_line_content": "                swap(*implementation_buffer);",
          "new_line_content": "                ///                           ^",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": "resize",
          "new_api": null,
          "old_text": "working_buffer.resize(0)",
          "new_text": null,
          "old_line_content": "                working_buffer.resize(0);",
          "new_line_content": "                ///                           file_offset_of_buffer_end",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": "end",
          "new_api": null,
          "old_text": "working_buffer.end()",
          "new_text": null,
          "old_line_content": "                position() = working_buffer.end();",
          "new_line_content": "                /// But space reservation failed.",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": "getRemoteFSReadBuffer",
          "new_api": null,
          "old_text": "getRemoteFSReadBuffer(file_segment, read_type)",
          "new_text": null,
          "old_line_content": "                implementation_buffer = getRemoteFSReadBuffer(file_segment, read_type);",
          "new_line_content": "                /// return buffer back, seek to actual position.",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "swap",
          "new_api": null,
          "old_text": "swap(*implementation_buffer)",
          "new_text": null,
          "old_line_content": "                swap(*implementation_buffer);",
          "new_line_content": "                /// seek is only allowed once for ReadBufferForS3 - before call to nextImpl.",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": "seek",
          "new_api": null,
          "old_text": "implementation_buffer->seek(file_offset_of_buffer_end, SEEK_SET)",
          "new_text": null,
          "old_line_content": "                implementation_buffer->seek(file_offset_of_buffer_end, SEEK_SET);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "state",
          "new_api": null,
          "old_text": "file_segment->state()",
          "new_text": null,
          "old_line_content": "    auto current_state = file_segment->state();",
          "new_line_content": "                    log,",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(current_read_range.left <= file_offset_of_buffer_end)",
          "new_text": null,
          "old_line_content": "    assert(current_read_range.left <= file_offset_of_buffer_end);",
          "new_line_content": "                    file_offset_of_buffer_end);",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": "isDownloader",
          "new_api": null,
          "old_text": "file_segment->isDownloader()",
          "new_text": null,
          "old_line_content": "    assert(!file_segment->isDownloader());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": "completeFileSegmentAndGetNext",
          "new_api": null,
          "old_text": "completeFileSegmentAndGetNext()",
          "new_text": null,
          "old_line_content": "        return completeFileSegmentAndGetNext();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "getDownloadOffset",
          "new_api": null,
          "old_text": "file_segment->getDownloadOffset()",
          "new_text": null,
          "old_line_content": "        auto download_offset = file_segment->getDownloadOffset();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": "getImplementationBuffer",
          "new_api": null,
          "old_text": "getImplementationBuffer(*current_file_segment_it)",
          "new_text": null,
          "old_line_content": "            implementation_buffer = getImplementationBuffer(*current_file_segment_it);",
          "new_line_content": "        /// If current read_type is ReadType::CACHED and file segment is not DOWNLOADED,",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\n                ErrorCodes::LOGICAL_ERROR, \"Expected {} >= {} ({})\", download_offset, file_offset_of_buffer_end, getInfoForLog())",
          "new_text": null,
          "old_line_content": "            throw Exception(",
          "new_line_content": "        ///                         download_offset",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": "getInfoForLog",
          "new_api": null,
          "old_text": "getInfoForLog()",
          "new_text": null,
          "old_line_content": "                ErrorCodes::LOGICAL_ERROR, \"Expected {} >= {} ({})\", download_offset, file_offset_of_buffer_end, getInfoForLog());",
          "new_line_content": "        /// requested_range:    [__________]",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": "getImplementationBuffer",
          "new_api": null,
          "old_text": "getImplementationBuffer(*current_file_segment_it)",
          "new_text": null,
          "old_line_content": "        implementation_buffer = getImplementationBuffer(*current_file_segment_it);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": "nextImplStep",
          "new_api": null,
          "old_text": "nextImplStep()",
          "new_text": null,
          "old_line_content": "        return nextImplStep();",
          "new_line_content": "        * being destructed till the end of query or without finishing the read range, which he was supposed",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": "FileSegment::getCallerId()",
          "new_api": null,
          "old_text": "FileSegment::getCallerId()",
          "new_text": null,
          "old_line_content": "    last_caller_id = FileSegment::getCallerId();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": "assertCorrectness",
          "new_api": null,
          "old_text": "assertCorrectness()",
          "new_text": null,
          "old_line_content": "    assertCorrectness();",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "getTotalSizeToRead",
          "new_api": null,
          "old_text": "getTotalSizeToRead()",
          "new_text": null,
          "old_line_content": "        initialize(file_offset_of_buffer_end, getTotalSizeToRead());",
          "new_line_content": "    catch (Exception & e)",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "end",
          "new_api": null,
          "old_text": "SCOPE_EXIT({\n        try\n        {\n            /// Save state of current file segment before it is completed.\n            nextimpl_step_log_info = getInfoForLog();\n\n            if (current_file_segment_it == file_segments_holder->file_segments.end())\n                return;\n\n            auto & file_segment = *current_file_segment_it;\n\n            bool download_current_segment = read_type == ReadType::REMOTE_FS_READ_AND_PUT_IN_CACHE;\n            if (download_current_segment)\n            {\n                bool need_complete_file_segment = file_segment->isDownloader();\n                if (need_complete_file_segment)\n                {\n                    LOG_TEST(log, \"Resetting downloader {} from scope exit\", file_segment->getDownloader());\n                    file_segment->completeBatchAndResetDownloader();\n                }\n            }\n\n            assert(!file_segment->isDownloader());\n        }\n        catch (...)\n        {\n            tryLogCurrentException(__PRETTY_FUNCTION__);\n        }\n    })",
          "new_text": null,
          "old_line_content": "    SCOPE_EXIT({",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": "getDownloader",
          "new_api": null,
          "old_text": "file_segment->getDownloader()",
          "new_text": null,
          "old_line_content": "                    LOG_TEST(log, \"Resetting downloader {} from scope exit\", file_segment->getDownloader());",
          "new_line_content": "            /// Save state of current file segment before it is completed.",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": "isDownloader",
          "new_api": null,
          "old_text": "file_segment->isDownloader()",
          "new_text": null,
          "old_line_content": "            assert(!file_segment->isDownloader());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": "tryLogCurrentException",
          "new_api": null,
          "old_text": "tryLogCurrentException(__PRETTY_FUNCTION__)",
          "new_text": null,
          "old_line_content": "            tryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "            if (download_current_segment)",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": "updateImplementationBufferIfNeeded",
          "new_api": null,
          "old_text": "updateImplementationBufferIfNeeded()",
          "new_text": null,
          "old_line_content": "        bool can_read_further = updateImplementationBufferIfNeeded();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": "incrementHitsCount",
          "new_api": null,
          "old_text": "*current_file_segment_it)->incrementHitsCount()",
          "new_text": null,
          "old_line_content": "            (*current_file_segment_it)->incrementHitsCount();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "empty",
          "new_api": null,
          "old_text": "internal_buffer.empty()",
          "new_text": null,
          "old_line_content": "    assert(!internal_buffer.empty());",
          "new_line_content": "    if (implementation_buffer)",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "swap",
          "new_api": null,
          "old_text": "swap(*implementation_buffer)",
          "new_text": null,
          "old_line_content": "    swap(*implementation_buffer);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": "range",
          "new_api": null,
          "old_text": "file_segment->range()",
          "new_text": null,
          "old_line_content": "    auto current_read_range = file_segment->range();",
          "new_line_content": "            return false;",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "toString",
          "new_api": null,
          "old_text": "LOG_TEST(\n        log,\n        \"Current segment: {}, downloader: {}, current count: {}, position: {}\",\n        current_read_range.toString(),\n        file_segment->getDownloader(),\n        implementation_buffer->count(),\n        implementation_buffer->getPosition())",
          "new_text": null,
          "old_line_content": "    LOG_TEST(",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "toString",
          "new_api": null,
          "old_text": "current_read_range.toString()",
          "new_text": null,
          "old_line_content": "        current_read_range.toString(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "getDownloader",
          "new_api": null,
          "old_text": "file_segment->getDownloader()",
          "new_text": null,
          "old_line_content": "        file_segment->getDownloader(),",
          "new_line_content": "        if (read_type == ReadType::CACHED)",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": "getPosition",
          "new_api": null,
          "old_text": "implementation_buffer->getPosition()",
          "new_text": null,
          "old_line_content": "        implementation_buffer->getPosition());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": "getCallerId",
          "new_api": null,
          "old_text": "file_segment->getCallerId()",
          "new_text": null,
          "old_line_content": "                if (downloader_id == file_segment->getCallerId())",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": "getDownloadOffset",
          "new_api": null,
          "old_text": "file_segment->getDownloadOffset()",
          "new_text": null,
          "old_line_content": "                    size_t download_offset = file_segment->getDownloadOffset();",
          "new_line_content": "                    /// cache:           [______|___________",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": "LOG_TEST",
          "new_api": null,
          "old_text": "LOG_TEST(log, \"Current download offset: {}, file offset of buffer end: {}\", download_offset, file_offset_of_buffer_end)",
          "new_text": null,
          "old_line_content": "                    LOG_TEST(log, \"Current download offset: {}, file offset of buffer end: {}\", download_offset, file_offset_of_buffer_end);",
          "new_line_content": "                    /// requested_range:    [__________]",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": "isDownloader",
          "new_api": null,
          "old_text": "file_segment->isDownloader()",
          "new_text": null,
          "old_line_content": "    if (download_current_segment != file_segment->isDownloader())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "getInfoForLog",
          "new_api": null,
          "old_text": "Exception(\n            ErrorCodes::LOGICAL_ERROR,\n            \"Incorrect segment state. Having read type: {}, file segment info: {}\",\n            toString(read_type), file_segment->getInfoForLog())",
          "new_text": null,
          "old_line_content": "        throw Exception(",
          "new_line_content": "    size_t size = 0;",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": "getInfoForLog",
          "new_api": null,
          "old_text": "file_segment->getInfoForLog()",
          "new_text": null,
          "old_line_content": "            toString(read_type), file_segment->getInfoForLog());",
          "new_line_content": "    if (needed_to_predownload)",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "resetDownloader",
          "new_api": null,
          "old_text": "file_segment->resetDownloader()",
          "new_text": null,
          "old_line_content": "                        file_segment->resetDownloader();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": "get",
          "new_api": null,
          "old_text": "implementation_buffer.get()",
          "new_text": null,
          "old_line_content": "        if (auto * cache_file_reader = dynamic_cast<ReadBufferFromFileDescriptor *>(implementation_buffer.get()))",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": "size",
          "new_api": null,
          "old_text": "cache_file_reader->size()",
          "new_text": null,
          "old_line_content": "            auto cache_file_size = cache_file_reader->size();",
          "new_line_content": "    auto download_current_segment = read_type == ReadType::REMOTE_FS_READ_AND_PUT_IN_CACHE;",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\n                    ErrorCodes::LOGICAL_ERROR, \"Attempt to read from an empty cache file: {} (just before actual read)\", cache_file_size)",
          "new_text": null,
          "old_line_content": "                throw Exception(",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": "next",
          "new_api": null,
          "old_text": "implementation_buffer->next()",
          "new_text": null,
          "old_line_content": "        result = implementation_buffer->next();",
          "new_line_content": "    if (!result)",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "stop",
          "new_api": null,
          "old_text": "watch.stop()",
          "new_text": null,
          "old_line_content": "        watch.stop();",
          "new_line_content": "#ifndef NDEBUG",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": "increment",
          "new_api": null,
          "old_text": "current_file_segment_counters.increment(ProfileEvents::FileSegmentReadMicroseconds, elapsed)",
          "new_text": null,
          "old_line_content": "        current_file_segment_counters.increment(ProfileEvents::FileSegmentReadMicroseconds, elapsed);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": "size",
          "new_api": null,
          "old_text": "implementation_buffer->buffer().size()",
          "new_text": null,
          "old_line_content": "        size = implementation_buffer->buffer().size();",
          "new_line_content": "            if (cache_file_size == 0)",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "getDownloadOffset",
          "new_api": null,
          "old_text": "file_segment->getDownloadOffset()",
          "new_text": null,
          "old_line_content": "                    download_offset = file_segment->getDownloadOffset();",
          "new_line_content": "                    if (download_offset < file_offset_of_buffer_end)",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(!can_start_from_cache)",
          "new_text": null,
          "old_line_content": "                    assert(!can_start_from_cache);",
          "new_line_content": "                        ///                   segment{1}",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromCacheBytes, size)",
          "new_api": null,
          "old_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromCacheBytes, size)",
          "new_text": null,
          "old_line_content": "            ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromCacheBytes, size);",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromCacheMicroseconds, elapsed)",
          "new_api": null,
          "old_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromCacheMicroseconds, elapsed)",
          "new_text": null,
          "old_line_content": "            ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromCacheMicroseconds, elapsed);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": "getRemoteFSReadBuffer",
          "new_api": null,
          "old_text": "getRemoteFSReadBuffer(file_segment, read_type)",
          "new_text": null,
          "old_line_content": "                    return getRemoteFSReadBuffer(file_segment, read_type);",
          "new_line_content": "                        ///                      download_offset",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": "state",
          "new_api": null,
          "old_text": "file_segment->state()",
          "new_text": null,
          "old_line_content": "                download_state = file_segment->state();",
          "new_line_content": "                        ///                           file_offset_of_buffer_end",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceBytes, size)",
          "new_api": null,
          "old_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceBytes, size)",
          "new_text": null,
          "old_line_content": "            ProfileEvents::increment(ProfileEvents::CachedReadBufferReadFromSourceBytes, size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": "getDownloadOffset",
          "new_api": null,
          "old_text": "file_segment->getDownloadOffset()",
          "new_text": null,
          "old_line_content": "                size_t download_offset = file_segment->getDownloadOffset();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 853,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "file_segment->reserve(size)",
          "new_text": null,
          "old_line_content": "            if (file_segment->reserve(size))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": "getPosition",
          "new_api": null,
          "old_text": "implementation_buffer->getPosition()",
          "new_text": null,
          "old_line_content": "                assert(file_segment->getDownloadOffset() == static_cast<size_t>(implementation_buffer->getPosition()));",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": "getRemoteFSReadBuffer",
          "new_api": null,
          "old_text": "getRemoteFSReadBuffer(file_segment, read_type)",
          "new_text": null,
          "old_line_content": "                    return getRemoteFSReadBuffer(file_segment, read_type);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": "begin",
          "new_api": null,
          "old_text": "file_segment->write(\n                    needed_to_predownload ? implementation_buffer->position() : implementation_buffer->buffer().begin(),\n                    size,\n                    file_offset_of_buffer_end)",
          "new_text": null,
          "old_line_content": "                file_segment->write(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": "begin",
          "new_api": null,
          "old_text": "implementation_buffer->buffer().begin()",
          "new_text": null,
          "old_line_content": "                    needed_to_predownload ? implementation_buffer->position() : implementation_buffer->buffer().begin(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": "stop",
          "new_api": null,
          "old_text": "watch.stop()",
          "new_text": null,
          "old_line_content": "                watch.stop();",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": "increment",
          "new_api": null,
          "old_text": "current_file_segment_counters.increment(ProfileEvents::FileSegmentCacheWriteMicroseconds, elapsed)",
          "new_text": null,
          "old_line_content": "                current_file_segment_counters.increment(ProfileEvents::FileSegmentCacheWriteMicroseconds, elapsed);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": "range",
          "new_api": null,
          "old_text": "file_segment->range()",
          "new_text": null,
          "old_line_content": "    assert(file_offset_of_buffer_end >= file_segment->range().left);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteBytes, size)",
          "new_api": null,
          "old_text": "ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteBytes, size)",
          "new_text": null,
          "old_line_content": "                ProfileEvents::increment(ProfileEvents::CachedReadBufferCacheWriteBytes, size);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": "range",
          "new_api": null,
          "old_text": "file_segment->range()",
          "new_text": null,
          "old_line_content": "    auto range = file_segment->range();",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": "range",
          "new_api": null,
          "old_text": "file_segment->range()",
          "new_text": null,
          "old_line_content": "                assert(file_segment->getDownloadOffset() <= file_segment->range().right + 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": "end",
          "new_api": null,
          "old_text": "assert(\n                    std::next(current_file_segment_it) == file_segments_holder->file_segments.end()\n                    || file_segment->getDownloadOffset() == implementation_buffer->getFileOffsetOfBufferEnd())",
          "new_text": null,
          "old_line_content": "                assert(",
          "new_line_content": "                Stopwatch watch(CLOCK_MONOTONIC);",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "end",
          "new_api": null,
          "old_text": "file_segments_holder->file_segments.end()",
          "new_text": null,
          "old_line_content": "                    std::next(current_file_segment_it) == file_segments_holder->file_segments.end()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": "getReadBufferForFileSegment",
          "new_api": null,
          "old_text": "getReadBufferForFileSegment(file_segment)",
          "new_text": null,
          "old_line_content": "    auto read_buffer_for_file_segment = getReadBufferForFileSegment(file_segment);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "stop",
          "new_api": null,
          "old_text": "watch.stop()",
          "new_text": null,
          "old_line_content": "    watch.stop();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": "elapsedMicroseconds",
          "new_api": null,
          "old_text": "watch.elapsedMicroseconds()",
          "new_text": null,
          "old_line_content": "    current_file_segment_counters.increment(ProfileEvents::FileSegmentWaitReadBufferMicroseconds, watch.elapsedMicroseconds());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 368,
          "old_api": "maybe_unused",
          "new_api": null,
          "old_text": "maybe_unused",
          "new_text": null,
          "old_line_content": "    [[maybe_unused]] auto download_current_segment = read_type == ReadType::REMOTE_FS_READ_AND_PUT_IN_CACHE;",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": "range",
          "new_api": null,
          "old_text": "file_segment->range()",
          "new_text": null,
          "old_line_content": "    assert(file_segment->range() == range);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": "toString",
          "new_api": null,
          "old_text": "LOG_TEST(\n        log,\n        \"Current file segment: {}, read type: {}, current file offset: {}\",\n        range.toString(),\n        toString(read_type),\n        file_offset_of_buffer_end)",
          "new_text": null,
          "old_line_content": "    LOG_TEST(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": "std::min(current_read_range.right, read_until_position - 1)",
          "new_api": null,
          "old_text": "std::min(current_read_range.right, read_until_position - 1)",
          "new_text": null,
          "old_line_content": "            size_t remaining_size_to_read = std::min(current_read_range.right, read_until_position - 1) - file_offset_of_buffer_end + 1;",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": "toString",
          "new_api": null,
          "old_text": "toString(read_type)",
          "new_text": null,
          "old_line_content": "        toString(read_type),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": "std::min(size, remaining_size_to_read)",
          "new_api": null,
          "old_text": "std::min(size, remaining_size_to_read)",
          "new_text": null,
          "old_line_content": "            size = std::min(size, remaining_size_to_read);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "size",
          "new_api": null,
          "old_text": "implementation_buffer->buffer().size()",
          "new_text": null,
          "old_line_content": "            assert(implementation_buffer->buffer().size() >= nextimpl_working_buffer_offset + size);",
          "new_line_content": "                download_current_segment = false;",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": "setReadUntilPosition",
          "new_api": null,
          "old_text": "read_buffer_for_file_segment->setReadUntilPosition(range.right + 1)",
          "new_text": null,
          "old_line_content": "    read_buffer_for_file_segment->setReadUntilPosition(range.right + 1); /// [..., range.right]",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": "swap",
          "new_api": null,
          "old_text": "swap(*implementation_buffer)",
          "new_text": null,
          "old_line_content": "    swap(*implementation_buffer);",
          "new_line_content": "        /// Therefore need to resize to a smaller size. And resize must be done after write into cache.",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": "size",
          "new_api": null,
          "old_text": "file_reader->size()",
          "new_text": null,
          "old_line_content": "            size_t file_size = file_reader->size();",
          "new_line_content": "        log,",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": "size",
          "new_api": null,
          "old_text": "LOG_TEST(\n        log,\n        \"Key: {}. Returning with {} bytes, buffer position: {} (offset: {}, predownloaded: {}), \"\n        \"buffer available: {}, current range: {}, current offset: {}, file segment state: {}, download offset: {}, read_type: {}, \"\n        \"reading until position: {}, started with offset: {}, remaining ranges: {}\",\n        getHexUIntLowercase(cache_key),\n        working_buffer.size(),\n        getPosition(),\n        offset(),\n        needed_to_predownload,\n        available(),\n        current_read_range.toString(),\n        file_offset_of_buffer_end,\n        FileSegment::stateToString(file_segment->state()),\n        file_segment->getDownloadOffset(),\n        toString(read_type),\n        read_until_position,\n        first_offset,\n        file_segments_holder->toString())",
          "new_text": null,
          "old_line_content": "    LOG_TEST(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": "size",
          "new_api": null,
          "old_text": "working_buffer.size()",
          "new_text": null,
          "old_line_content": "        working_buffer.size(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": "offset",
          "new_api": null,
          "old_text": "offset()",
          "new_text": null,
          "old_line_content": "        offset(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\n                    ErrorCodes::LOGICAL_ERROR,\n                    \"Invariant failed. Expected {} > {} (current offset > file segment's start offset)\",\n                    file_offset_of_buffer_end,\n                    range.left)",
          "new_text": null,
          "old_line_content": "                throw Exception(",
          "new_line_content": "            if (file_size == 0 || range.left + file_size <= file_offset_of_buffer_end)",
          "content_same": false
        },
        {
          "line": 919,
          "old_api": "toString",
          "new_api": null,
          "old_text": "current_read_range.toString()",
          "new_text": null,
          "old_line_content": "        current_read_range.toString(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": "state",
          "new_api": null,
          "old_text": "file_segment->state()",
          "new_text": null,
          "old_line_content": "        FileSegment::stateToString(file_segment->state()),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": "seek",
          "new_api": null,
          "old_text": "read_buffer_for_file_segment->seek(seek_offset, SEEK_SET)",
          "new_text": null,
          "old_line_content": "            read_buffer_for_file_segment->seek(seek_offset, SEEK_SET);",
          "new_line_content": "                    range.left,",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": "toString",
          "new_api": null,
          "old_text": "toString(read_type)",
          "new_text": null,
          "old_line_content": "        toString(read_type),",
          "new_line_content": "        log,",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "toString",
          "new_api": null,
          "old_text": "file_segments_holder->toString()",
          "new_text": null,
          "old_line_content": "        file_segments_holder->toString());",
          "new_line_content": "        \"reading until position: {}, started with offset: {}, remaining ranges: {}\",",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": "seek",
          "new_api": null,
          "old_text": "read_buffer_for_file_segment->seek(file_offset_of_buffer_end, SEEK_SET)",
          "new_text": null,
          "old_line_content": "            read_buffer_for_file_segment->seek(file_offset_of_buffer_end, SEEK_SET);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "get",
          "new_api": null,
          "old_text": "implementation_buffer.get()",
          "new_text": null,
          "old_line_content": "        if (auto * cache_file_reader = dynamic_cast<ReadBufferFromFileDescriptor *>(implementation_buffer.get()))",
          "new_line_content": "        needed_to_predownload,",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "isDownloader",
          "new_api": null,
          "old_text": "file_segment->isDownloader()",
          "new_text": null,
          "old_line_content": "            assert(file_segment->isDownloader());",
          "new_line_content": "                    file_offset_of_buffer_end,",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\n            ErrorCodes::LOGICAL_ERROR,\n            \"Having zero bytes, but range is not finished: file offset: {}, reading until: {}, read type: {}, cache file size: {}\",\n            file_offset_of_buffer_end,\n            read_until_position,\n            toString(read_type),\n            cache_file_size ? std::to_string(*cache_file_size) : \"None\")",
          "new_text": null,
          "old_line_content": "        throw Exception(",
          "new_line_content": "        file_offset_of_buffer_end,",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": "getDownloadOffset",
          "new_api": null,
          "old_text": "file_segment->getDownloadOffset()",
          "new_text": null,
          "old_line_content": "                size_t download_offset = file_segment->getDownloadOffset();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": "seek",
          "new_api": null,
          "old_text": "read_buffer_for_file_segment->seek(download_offset, SEEK_SET)",
          "new_text": null,
          "old_line_content": "                read_buffer_for_file_segment->seek(download_offset, SEEK_SET);",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "toString",
          "new_api": null,
          "old_text": "toString(read_type)",
          "new_text": null,
          "old_line_content": "            toString(read_type),",
          "new_line_content": "        first_offset,",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": "getDownloadOffset",
          "new_api": null,
          "old_text": "file_segment->getDownloadOffset()",
          "new_text": null,
          "old_line_content": "            auto download_offset = file_segment->getDownloadOffset();",
          "new_line_content": "        case ReadType::REMOTE_FS_READ_AND_PUT_IN_CACHE:",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": "getPosition",
          "new_api": null,
          "old_text": "read_buffer_for_file_segment->getPosition()",
          "new_text": null,
          "old_line_content": "            if (download_offset != static_cast<size_t>(read_buffer_for_file_segment->getPosition()))",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 437,
          "old_api": "getRemainingReadRange",
          "new_api": null,
          "old_text": "read_buffer_for_file_segment->getRemainingReadRange()",
          "new_text": null,
          "old_line_content": "                auto impl_range = read_buffer_for_file_segment->getRemainingReadRange();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 438,
          "old_api": "getPosition",
          "new_api": null,
          "old_text": "Exception(\n                    ErrorCodes::LOGICAL_ERROR,\n                    \"Buffer's offsets mismatch; cached buffer offset: {}, download_offset: {}, position: {}, implementation buffer offset: \"\n                    \"{}, \"\n                    \"implementation buffer reading until: {}, file segment info: {}\",\n                    file_offset_of_buffer_end,\n                    download_offset,\n                    read_buffer_for_file_segment->getPosition(),\n                    impl_range.left,\n                    *impl_range.right,\n                    file_segment->getInfoForLog())",
          "new_text": null,
          "old_line_content": "                throw Exception(",
          "new_line_content": "            if (bytes_to_predownload)",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::CANNOT_SEEK_THROUGH_FILE, \"Seek is allowed only before first read attempt from the buffer\")",
          "new_text": null,
          "old_line_content": "        throw Exception(ErrorCodes::CANNOT_SEEK_THROUGH_FILE, \"Seek is allowed only before first read attempt from the buffer\");",
          "new_line_content": "            ErrorCodes::LOGICAL_ERROR,",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::CANNOT_SEEK_THROUGH_FILE, \"Only SEEK_SET allowed\")",
          "new_text": null,
          "old_line_content": "        throw Exception(ErrorCodes::CANNOT_SEEK_THROUGH_FILE, \"Only SEEK_SET allowed\");",
          "new_line_content": "            read_until_position,",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "getTotalSizeToRead",
          "new_api": null,
          "old_text": "getTotalSizeToRead()",
          "new_text": null,
          "old_line_content": "    size_t size = getTotalSizeToRead();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": "initialize",
          "new_api": null,
          "old_text": "initialize(offset, size)",
          "new_text": null,
          "old_line_content": "    initialize(offset, size);",
          "new_line_content": "    return result;",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": "toString",
          "new_api": null,
          "old_text": "*current_file_segment_it)->range().toString()",
          "new_text": null,
          "old_line_content": "    LOG_TEST(log, \"Completed segment: {}\", (*current_file_segment_it)->range().toString());",
          "new_line_content": "                    impl_range.left,",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": "range",
          "new_api": null,
          "old_text": "*current_file_segment_it)->range()",
          "new_text": null,
          "old_line_content": "        appendFilesystemCacheLog((*current_file_segment_it)->range(), read_type);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::LOGICAL_ERROR, \"Method `setReadUntilPosition()` not allowed\")",
          "new_text": null,
          "old_line_content": "    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Method `setReadUntilPosition()` not allowed\");",
          "new_line_content": "    /// Last position should be guaranteed to be set, as at least we always know file size.",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": "range",
          "new_api": null,
          "old_text": "file_segment->range()",
          "new_text": null,
          "old_line_content": "    [[maybe_unused]] const auto & range = file_segment->range();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(file_offset_of_buffer_end > range.right)",
          "new_text": null,
          "old_line_content": "    assert(file_offset_of_buffer_end > range.right);",
          "new_line_content": "    return read_buffer_for_file_segment;",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": "toString",
          "new_api": null,
          "old_text": "LOG_TEST(\n        log,\n        \"Removing file segment: {}, downloader: {}, state: {}\",\n        file_segment->range().toString(),\n        file_segment->getDownloader(),\n        file_segment->state())",
          "new_text": null,
          "old_line_content": "    LOG_TEST(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "available",
          "new_api": null,
          "old_text": "available()",
          "new_text": null,
          "old_line_content": "    return file_offset_of_buffer_end - available();",
          "new_line_content": "    if (file_offset_of_buffer_end >= read_until_position)",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": "getDownloader",
          "new_api": null,
          "old_text": "file_segment->getDownloader()",
          "new_text": null,
          "old_line_content": "        file_segment->getDownloader(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": "state",
          "new_api": null,
          "old_text": "file_segment->state()",
          "new_text": null,
          "old_line_content": "        file_segment->state());",
          "new_line_content": "    if (enable_logging)",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::LOGICAL_ERROR, \"File segments holder not initialized\")",
          "new_text": null,
          "old_line_content": "        throw Exception(ErrorCodes::LOGICAL_ERROR, \"File segments holder not initialized\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": "erase",
          "new_api": null,
          "old_text": "file_segments_holder->file_segments.erase(file_segment_it)",
          "new_text": null,
          "old_line_content": "    file_segments_holder->file_segments.erase(file_segment_it);",
          "new_line_content": "    auto & file_segment = *file_segment_it;",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": "state",
          "new_api": null,
          "old_text": "file_segment->state()",
          "new_text": null,
          "old_line_content": "        if (file_segment->state() != FileSegment::State::DOWNLOADED)",
          "new_line_content": "off_t CachedReadBufferFromRemoteFS::getPosition()",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": "range",
          "new_api": null,
          "old_text": "file_segment->range()",
          "new_text": null,
          "old_line_content": "            return file_segment->range().right;",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": "IFileCache::isReadOnly()",
          "new_api": null,
          "old_text": "IFileCache::isReadOnly()",
          "new_text": null,
          "old_line_content": "    if (IFileCache::isReadOnly() && !settings.read_from_filesystem_cache_if_exists_otherwise_bypass_cache)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::LOGICAL_ERROR, \"Cache usage is not allowed\")",
          "new_text": null,
          "old_line_content": "        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cache usage is not allowed\");",
          "new_line_content": "    const auto & file_segments = file_segments_holder->file_segments;",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "end",
          "new_api": null,
          "old_text": "file_segments_holder->file_segments.end()",
          "new_text": null,
          "old_line_content": "        && current_file_segment_it != file_segments_holder->file_segments.end())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "range",
          "new_api": null,
          "old_text": "*current_file_segment_it)->range()",
          "new_text": null,
          "old_line_content": "        appendFilesystemCacheLog((*current_file_segment_it)->range(), read_type);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "getRemainingReadRange",
          "new_api": null,
          "old_text": "implementation_buffer->getRemainingReadRange()",
          "new_text": null,
          "old_line_content": "        auto read_range = implementation_buffer->getRemainingReadRange();",
          "new_line_content": "    return std::nullopt;",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": "std::to_string(*read_range.right)",
          "new_api": null,
          "old_text": "std::to_string(*read_range.right)",
          "new_text": null,
          "old_line_content": "            = std::to_string(read_range.left) + '-' + (read_range.right ? std::to_string(*read_range.right) : \"None\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "stop",
          "new_api": null,
          "old_text": "SCOPE_EXIT({\n        predownload_watch.stop();\n        current_file_segment_counters.increment(ProfileEvents::FileSegmentPredownloadMicroseconds, predownload_watch.elapsedMicroseconds());\n    })",
          "new_text": null,
          "old_line_content": "    SCOPE_EXIT({",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": "stop",
          "new_api": null,
          "old_text": "predownload_watch.stop()",
          "new_text": null,
          "old_line_content": "        predownload_watch.stop();",
          "new_line_content": "CachedReadBufferFromRemoteFS::~CachedReadBufferFromRemoteFS()",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": "getInfoForLog",
          "new_api": null,
          "old_text": "*current_file_segment_it)->getInfoForLog()",
          "new_text": null,
          "old_line_content": "        = current_file_segment_it == file_segments_holder->file_segments.end() ? \"None\" : (*current_file_segment_it)->getInfoForLog();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": "fmt::format(\n        \"Buffer path: {}, hash key: {}, file_offset_of_buffer_end: {}, internal buffer remaining read range: {}, \"\n        \"read_type: {}, last caller: {}, file segment info: {}\",\n        remote_fs_object_path,\n        getHexUIntLowercase(cache_key),\n        file_offset_of_buffer_end,\n        implementation_buffer_read_range_str,\n        toString(read_type),\n        last_caller_id,\n        current_file_segment_info)",
          "new_api": null,
          "old_text": "fmt::format(\n        \"Buffer path: {}, hash key: {}, file_offset_of_buffer_end: {}, internal buffer remaining read range: {}, \"\n        \"read_type: {}, last caller: {}, file segment info: {}\",\n        remote_fs_object_path,\n        getHexUIntLowercase(cache_key),\n        file_offset_of_buffer_end,\n        implementation_buffer_read_range_str,\n        toString(read_type),\n        last_caller_id,\n        current_file_segment_info)",
          "new_text": null,
          "old_line_content": "    return fmt::format(",
          "new_line_content": "{",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 67,
      "total_additions": 150,
      "total_deletions": 148,
      "total_api_changes": 365
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 14,
        "api_related_lines": 365,
        "non_api_lines": 9,
        "non_api_line_numbers": [
          289,
          290,
          292,
          293,
          294,
          295,
          297,
          298,
          287
        ]
      }
    },
    "api_calls_before": 332,
    "api_calls_after": 334,
    "diff_info": {
      "added_lines": 14,
      "removed_lines": 0,
      "total_diff_lines": 26
    }
  }
}