{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/344e975a598cf091728f3b3cce4d12de1819f4a5",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/344e975a598cf091728f3b3cce4d12de1819f4a5/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/344e975a598cf091728f3b3cce4d12de1819f4a5/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/344e975a598cf091728f3b3cce4d12de1819f4a5/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 116,
          "old_api": "аблиц. Обычно их мало.\n\t\t\t\t\tfor (c",
          "new_api": "MergeTree family.\n\t\t\t\t\t  * Select",
          "old_text": "аблиц. Обычно их мало.\n\t\t\t\t\tfor (c",
          "new_text": " MergeTree family.\n\t\t\t\t\t  * Select",
          "old_line_content": null,
          "new_line_content": "\t\t\ttime_t min_time = std::numeric_limits<time_t>::max();",
          "content_same": true
        },
        {
          "line": 121,
          "old_api": "ontinue;",
          "new_api": "* Remi",
          "old_text": "ontinue;\n\n\t\t\t",
          "new_text": "\t\t\t\t\t  * Remi",
          "old_line_content": null,
          "new_line_content": "\t\t\t\tif (!tasks.empty())",
          "content_same": true
        },
        {
          "line": 187,
          "old_api": "",
          "new_api": "entException",
          "old_text": "",
          "new_text": "entException(__PRETTY_F",
          "old_line_content": "\t\tif (!counters_diff.empty())",
          "new_line_content": "\t\t\t\tbool done_work = task->function(context);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 163,
          "old_api": null,
          "new_api": "з ничего не сделала, и поэтому ей назначено некоторое время спать.\n\t\t\ttime_t current_time = time(0);\n\t\t\tif (min_time > current_time)\n\t\t\t{\n\t\t\t\tstd::unique_lock",
          "old_text": null,
          "new_text": "з ничего не сделала, и поэтому ей назначено некоторое время спать.\n\t\t\ttime_t current_time = time(0);\n\t\t\tif (min_time > current_time)\n\t\t\t{\n\t\t\t\tstd::unique_lock",
          "old_line_content": "",
          "new_line_content": "\t\t\t\twake_event.wait_for(lock,",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": null,
          "new_api": "ей назначено некоторое время спать.\n\t\t\ttime_t current_time = time(0);\n\t\t\tif (min_time > current_time)\n\t\t\t{\n\t\t\t\tstd::unique_loc",
          "old_text": null,
          "new_text": "ей назначено некоторое время спать.\n\t\t\ttime_t current_time = time(0);\n\t\t\tif (min_time > current_time)\n\t\t\t{\n\t\t\t\tstd::unique_loc",
          "old_line_content": "\t\t\tPoco::ScopedReadRWLock rlock(task->rwlock);",
          "new_line_content": "\t\t\t\t\tstd::chrono::duration<double>(sleep_seconds",
          "content_same": false
        },
        {
          "line": 165,
          "old_api": null,
          "new_api": "t_time = time(0);\n\t\t\tif (min_time > current_time)\n\t\t\t{\n\t\t\t\tstd::unique_lo",
          "old_text": null,
          "new_text": "t_time = time(0);\n\t\t\tif (min_time > current_time)\n\t\t\t{\n\t\t\t\tstd::unique_lo",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t+ std::uniform_real_distribution<double>(0, sleep_seconds_random_part)(rng)));",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tif (has_exception)",
          "new_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tif (!counters_diff.empty())",
          "content_same": false
        },
        {
          "line": 170,
          "old_api": null,
          "new_api": ">remove",
          "old_text": null,
          "new_text": ">remove",
          "old_line_content": "\t\t\t\tCurrentMetrics::Increment metric_increment{CurrentMetrics::BackgroundPoolTask};",
          "new_line_content": "\t\t\ttime_t current_time = time(0);",
          "content_same": false
        },
        {
          "line": 174,
          "old_api": null,
          "new_api": "function",
          "old_text": null,
          "new_text": "ontext(*this, counters_diff);\n\t\t\t\tbool done_work = task->function(context);\n\n\t\t\t\t/// Если задача сделала полезную работу, то она сможет ",
          "old_line_content": "",
          "new_line_content": "\t\t\t\twake_event.wait_for(lock, std::chrono::duration<double>(",
          "content_same": false
        },
        {
          "line": 175,
          "old_api": null,
          "new_api": "ion",
          "old_text": null,
          "new_text": "ion(context);\n\n\t\t\t\t/// Если задача сделала полезную работу, то она сможет",
          "old_line_content": "\t\t\t\t/// Если задача сделала полезную работу, то она сможет выполняться в следующий раз хоть сразу.",
          "new_line_content": "\t\t\t\t\tmin_time - current_time + std::uniform_real_distribution<double>(0, sleep_seconds_random_part)(rng)));",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\t\twake_event.wait_for(lock, std::chrono::duration<double>(sleep_seconds));",
          "content_same": false
        },
        {
          "line": 153,
          "old_api": null,
          "new_api": "d::uniform_",
          "old_text": null,
          "new_text": "d::uniform_",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\t\t\ttasks.splice(tasks.end(), tasks, task->iterator);",
          "content_same": false
        },
        {
          "line": 191,
          "old_api": null,
          "new_api": "wake",
          "old_text": null,
          "new_text": "\t\t\twake",
          "old_line_content": "\t\t\t\tcounters[it.first] -= it.second;",
          "new_line_content": "\t\t\t\ttask->next_time_to_execute = time(0) + (done_work ? 0 : sleep_seconds);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 160,
          "old_api": "function",
          "new_api": null,
          "old_text": "work = task->function(context);\n\n\t\t\t\t/// Если задача сделала полезную работу, то она сможет выполняться в следующий раз хоть сразу.\n\t\t\t\t",
          "new_text": null,
          "old_line_content": "\t\t\t\twake_event.wait_for(lock, std::chrono::duration<double>(",
          "new_line_content": "\t\t\tif (!task)",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": "олезную работу, то она сможет выполняться в следующий раз хоть сразу.",
          "new_api": null,
          "old_text": "олезную работу, то она сможет выполняться в следующий раз хоть сразу.\n\t\t\t",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tmin_time - current_time + std::uniform_real_distribution<double>(0, sleep_seconds_random_part)(rng)));",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\twake_event.wait_for(lock, std::chrono::duration<double>(sleep_seconds));",
          "new_line_content": "\t\t/// Вычтем все счётчики обратно.",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": "p_seconds_r",
          "new_api": null,
          "old_text": "p_seconds_r",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\ttasks.splice(tasks.end(), tasks, task->iterator);",
          "new_line_content": "\t\t\t\t\t\ttime_t next_time_to_execute = handle->next_time_to_execute;",
          "content_same": false
        },
        {
          "line": 173,
          "old_api": "/ Вычтем все счётчики о",
          "new_api": null,
          "old_text": "/ Вычтем все счётчики о",
          "new_text": null,
          "old_line_content": "\t\t\t\tbool done_work = task->function(context);",
          "new_line_content": "\t\t\t\tstd::unique_lock<std::mutex> lock(tasks_mutex);",
          "content_same": false
        },
        {
          "line": 177,
          "old_api": "ration<",
          "new_api": null,
          "old_text": "ration<",
          "new_text": null,
          "old_line_content": "\t\t\t\ttask->next_time_to_execute = time(0) + (done_work ? 0 : sleep_seconds);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 149,
          "old_api": "некоторое время спать.\n\t\t\ttime_t current_time = time(0);\n\t\t\tif (min_time > current_time)\n\t\t\t{\n\t\t\t\tstd::unique_lock<std::mutex> lock(tasks_mutex);\n\t\t\t\twake_eve",
          "new_api": null,
          "old_text": "некоторое время спать.\n\t\t\ttime_t current_time = time(0);\n\t\t\tif (min_time > current_time)\n\t\t\t{\n\t\t\t\tstd::unique_lock<std::mutex> lock(tasks_mutex);\n\t\t\t\twake_eve",
          "new_text": null,
          "old_line_content": "\t\t\t\twake_event.wait_for(lock,",
          "new_line_content": "\t\t\t\t\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 150,
          "old_api": "t current_time = time(0);\n\t\t\tif (min_time > current_time)\n\t\t\t{\n\t\t\t\tstd::unique_lock<std::mutex> lock(tasks_mutex);\n\t\t\t\twake_ev",
          "new_api": null,
          "old_text": "t current_time = time(0);\n\t\t\tif (min_time > current_time)\n\t\t\t{\n\t\t\t\tstd::unique_lock<std::mutex> lock(tasks_mutex);\n\t\t\t\twake_ev",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tstd::chrono::duration<double>(sleep_seconds",
          "new_line_content": "\t\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 151,
          "old_api": "time)\n\t\t\t{\n\t\t\t\tstd::unique_lock<std::mutex> lock(tasks_mutex);\n\t\t\t\twake_e",
          "new_api": null,
          "old_text": "time)\n\t\t\t{\n\t\t\t\tstd::unique_lock<std::mutex> lock(tasks_mutex);\n\t\t\t\twake_e",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t+ std::uniform_real_distribution<double>(0, sleep_seconds_random_part)(rng)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 183,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": "rics::I",
          "new_api": null,
          "old_text": "rics::I",
          "new_text": null,
          "old_line_content": "\t\t\ttime_t current_time = time(0);",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 3,
      "total_additions": 11,
      "total_deletions": 11,
      "total_api_changes": 25
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 15,
        "api_related_lines": 25,
        "non_api_lines": 14,
        "non_api_line_numbers": [
          128,
          129,
          130,
          131,
          132,
          133,
          146,
          147,
          148,
          123,
          124,
          125,
          126,
          127
        ]
      }
    },
    "api_calls_before": 44,
    "api_calls_after": 44,
    "diff_info": {
      "added_lines": 15,
      "removed_lines": 1,
      "total_diff_lines": 35
    }
  }
}