{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/0a46d231eddb16f5261aba5bbb8d85c1a26f9b41",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/0a46d231eddb16f5261aba5bbb8d85c1a26f9b41/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/0a46d231eddb16f5261aba5bbb8d85c1a26f9b41/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/0a46d231eddb16f5261aba5bbb8d85c1a26f9b41/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 2299,
          "old_api": "enqueuePartForCheck",
          "new_api": "time",
          "old_text": "enqueuePartForCheck(part->name)",
          "new_text": "time(nullptr)",
          "old_line_content": "                enqueuePartForCheck(part->name);",
          "new_line_content": "            if (part->modification_time + MAX_AGE_OF_LOCAL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < time(nullptr))",
          "content_same": false
        },
        {
          "line": 2345,
          "old_api": "LOG_WARNING",
          "new_api": "getZooKeeper",
          "old_text": "LOG_WARNING(log, \"Part \" << part.name << \" (that was selected for mutation)\"\n                << \" with age \" << (time(nullptr) - part.modification_time)\n                << \" seconds exists locally but not in ZooKeeper.\"\n                << \" Won't mutate that part and will check it.\")",
          "new_text": "getZooKeeper()",
          "old_line_content": "            LOG_WARNING(log, \"Part \" << part.name << \" (that was selected for mutation)\"",
          "new_line_content": "    auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2365,
          "old_api": "time",
          "new_api": "getNewName",
          "old_text": "time(nullptr)",
          "new_text": "part.getNewName(new_part_info)",
          "old_line_content": "    entry.create_time = time(nullptr);",
          "new_line_content": "    String new_part_name = part.getNewName(new_part_info);",
          "content_same": false
        },
        {
          "line": 2384,
          "old_api": "getZooKeeper",
          "new_api": "zkutil::makeRemoveRequest(part_path + \"/columns\", -1)",
          "old_text": "getZooKeeper()",
          "new_text": "zkutil::makeRemoveRequest(part_path + \"/columns\", -1)",
          "old_line_content": "    auto zookeeper = getZooKeeper();",
          "new_line_content": "    ops.emplace_back(zkutil::makeRemoveRequest(part_path + \"/columns\", -1));",
          "content_same": false
        },
        {
          "line": 2395,
          "old_api": "toString",
          "new_api": "std::make_shared<LogEntry>()",
          "old_text": "zkutil::makeCreateRequest(\n        replica_path + \"/queue/queue-\", log_entry->toString(),\n        zkutil::CreateMode::PersistentSequential)",
          "new_text": "std::make_shared<LogEntry>()",
          "old_line_content": "    ops.emplace_back(zkutil::makeCreateRequest(",
          "new_line_content": "    LogEntryPtr log_entry = std::make_shared<LogEntry>();",
          "content_same": false
        },
        {
          "line": 2403,
          "old_api": "dynamic_cast<const zkutil::CreateResponse &>(*results[0])",
          "new_api": "toString",
          "old_text": "dynamic_cast<const zkutil::CreateResponse &>(*results[0])",
          "new_text": "log_entry->toString()",
          "old_line_content": "    String path_created = dynamic_cast<const zkutil::CreateResponse &>(*results[0]).path_created;",
          "new_line_content": "        replica_path + \"/queue/queue-\", log_entry->toString(),",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": "getSchedulePool",
          "new_api": "activate",
          "old_text": "context.getSchedulePool()",
          "new_text": "merge_selecting_task->activate()",
          "old_line_content": "            context.getSchedulePool(),",
          "new_line_content": "        merge_selecting_task->activate();",
          "content_same": false
        },
        {
          "line": 2500,
          "old_api": "exists",
          "new_api": "end",
          "old_text": "zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")",
          "new_text": "replicas.end()",
          "old_line_content": "        if (active && !zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\"))",
          "new_line_content": "    std::shuffle(replicas.begin(), replicas.end(), rng);",
          "content_same": false
        },
        {
          "line": 2511,
          "old_api": "MergeTreePartInfo::contains(part_on_replica, largest_part_found, data.format_version)",
          "new_api": "getChildren",
          "old_text": "MergeTreePartInfo::contains(part_on_replica, largest_part_found, data.format_version)",
          "new_text": "zookeeper->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/parts\")",
          "old_line_content": "                    || MergeTreePartInfo::contains(part_on_replica, largest_part_found, data.format_version))",
          "new_line_content": "        Strings parts = zookeeper->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/parts\");",
          "content_same": false
        },
        {
          "line": 2518,
          "old_api": "empty",
          "new_api": "MergeTreePartInfo::contains(part_on_replica, largest_part_found, data.format_version)",
          "old_text": "largest_part_found.empty()",
          "new_text": "MergeTreePartInfo::contains(part_on_replica, largest_part_found, data.format_version)",
          "old_line_content": "        if (!largest_part_found.empty())",
          "new_line_content": "                    || MergeTreePartInfo::contains(part_on_replica, largest_part_found, data.format_version))",
          "content_same": false
        },
        {
          "line": 2569,
          "old_api": "MergeTreePartInfo::contains(part_on_replica, part_name, data.format_version)",
          "new_api": "exists",
          "old_text": "MergeTreePartInfo::contains(part_on_replica, part_name, data.format_version)",
          "new_text": "zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")",
          "old_line_content": "                || MergeTreePartInfo::contains(part_on_replica, part_name, data.format_version))",
          "new_line_content": "        if (active && !zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\"))",
          "content_same": false
        },
        {
          "line": 2572,
          "old_api": "MergeTreePartInfo::contains(part_on_replica, largest_part_found, data.format_version)",
          "new_api": "getChildren",
          "old_text": "MergeTreePartInfo::contains(part_on_replica, largest_part_found, data.format_version)",
          "new_text": "zookeeper->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/parts\")",
          "old_line_content": "                    || MergeTreePartInfo::contains(part_on_replica, largest_part_found, data.format_version))",
          "new_line_content": "        Strings parts = zookeeper->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/parts\");",
          "content_same": false
        },
        {
          "line": 2622,
          "old_api": "zkutil::makeSetRequest(quorum_last_part_path, part_name, -1)",
          "new_api": "size",
          "old_text": "zkutil::makeSetRequest(quorum_last_part_path, part_name, -1)",
          "new_text": "quorum_entry.replicas.size()",
          "old_line_content": "            ops.emplace_back(zkutil::makeSetRequest(quorum_last_part_path, part_name, -1));",
          "new_line_content": "        if (quorum_entry.replicas.size() >= quorum_entry.required_number_of_replicas)",
          "content_same": false
        },
        {
          "line": 2687,
          "old_api": "erase",
          "new_api": "insert",
          "old_text": "SCOPE_EXIT\n    ({\n        std::lock_guard<std::mutex> lock(currently_fetching_parts_mutex);\n        currently_fetching_parts.erase(part_name);\n    })",
          "new_text": "currently_fetching_parts.insert(part_name)",
          "old_line_content": "    SCOPE_EXIT",
          "new_line_content": "        if (!currently_fetching_parts.insert(part_name).second)",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": "lockStructure",
          "new_api": "erase",
          "old_text": "lockStructure(true, __PRETTY_FUNCTION__)",
          "new_text": "currently_fetching_parts.erase(part_name)",
          "old_line_content": "        table_lock = lockStructure(true, __PRETTY_FUNCTION__);",
          "new_line_content": "        currently_fetching_parts.erase(part_name);",
          "content_same": false
        },
        {
          "line": 2728,
          "old_api": "checkPartChecksumsAndCommit",
          "new_api": "renameTempPartAndReplace",
          "old_text": "checkPartChecksumsAndCommit(transaction, part)",
          "new_text": "data.renameTempPartAndReplace(part, nullptr, &transaction)",
          "old_line_content": "            replaced_parts = checkPartChecksumsAndCommit(transaction, part);",
          "new_line_content": "            data.renameTempPartAndReplace(part, nullptr, &transaction);",
          "content_same": false
        },
        {
          "line": 2741,
          "old_api": "ProfileEvents::increment(ProfileEvents::ObsoleteReplicatedParts)",
          "new_api": "updateQuorum",
          "old_text": "ProfileEvents::increment(ProfileEvents::ObsoleteReplicatedParts)",
          "new_text": "updateQuorum(part_name)",
          "old_line_content": "                ProfileEvents::increment(ProfileEvents::ObsoleteReplicatedParts);",
          "new_line_content": "                updateQuorum(part_name);",
          "content_same": false
        },
        {
          "line": 2748,
          "old_api": "renameTo",
          "new_api": "ProfileEvents::increment(ProfileEvents::ObsoleteReplicatedParts)",
          "old_text": "part->renameTo(\"detached/\" + part_name)",
          "new_text": "ProfileEvents::increment(ProfileEvents::ObsoleteReplicatedParts)",
          "old_line_content": "            part->renameTo(\"detached/\" + part_name);",
          "new_line_content": "                ProfileEvents::increment(ProfileEvents::ObsoleteReplicatedParts);",
          "content_same": false
        },
        {
          "line": 2761,
          "old_api": "LOG_DEBUG",
          "new_api": "ExecutionStatus::fromCurrentException()",
          "old_text": "LOG_DEBUG(log, \"Fetched part \" << part_name << \" from \" << replica_path << (to_detached ? \" (to 'detached' directory)\" : \"\"))",
          "new_text": "ExecutionStatus::fromCurrentException()",
          "old_line_content": "    LOG_DEBUG(log, \"Fetched part \" << part_name << \" from \" << replica_path << (to_detached ? \" (to 'detached' directory)\" : \"\"));",
          "new_line_content": "            write_part_log(ExecutionStatus::fromCurrentException());",
          "content_same": false
        },
        {
          "line": 2781,
          "old_api": "shared_from_this",
          "new_api": "getDataParts",
          "old_text": "shared_from_this()",
          "new_text": "data.getDataParts()",
          "old_line_content": "    StoragePtr ptr = shared_from_this();",
          "new_line_content": "        data.getDataParts(), current_zookeeper);",
          "content_same": false
        },
        {
          "line": 2783,
          "old_api": "getInterserverIOHandler",
          "new_api": "pullLogsToQueue",
          "old_text": "std::make_shared<InterserverIOEndpointHolder>(\n        data_parts_exchange_endpoint->getId(replica_path), data_parts_exchange_endpoint, context.getInterserverIOHandler())",
          "new_text": "queue.pullLogsToQueue(current_zookeeper)",
          "old_line_content": "    data_parts_exchange_endpoint_holder = std::make_shared<InterserverIOEndpointHolder>(",
          "new_line_content": "    queue.pullLogsToQueue(current_zookeeper);",
          "content_same": false
        },
        {
          "line": 2784,
          "old_api": "getInterserverIOHandler",
          "new_api": "time",
          "old_text": "context.getInterserverIOHandler()",
          "new_text": "time(nullptr)",
          "old_line_content": "        data_parts_exchange_endpoint->getId(replica_path), data_parts_exchange_endpoint, context.getInterserverIOHandler());",
          "new_line_content": "    last_queue_update_finish_time.store(time(nullptr));",
          "content_same": false
        },
        {
          "line": 2790,
          "old_api": "wait",
          "new_api": "getInterserverIOHandler",
          "old_text": "startup_event.wait()",
          "new_text": "std::make_shared<InterserverIOEndpointHolder>(\n        data_parts_exchange_endpoint->getId(replica_path), data_parts_exchange_endpoint, context.getInterserverIOHandler())",
          "old_line_content": "    startup_event.wait();",
          "new_line_content": "    data_parts_exchange_endpoint_holder = std::make_shared<InterserverIOEndpointHolder>(",
          "content_same": false
        },
        {
          "line": 2855,
          "old_api": "tryGet",
          "new_api": "getActiveContainingPart",
          "old_text": "zookeeper->tryGet(zookeeper_path + \"/quorum/status\", quorum_str)",
          "new_text": "data.getActiveContainingPart(last_part)",
          "old_line_content": "            if (zookeeper->tryGet(zookeeper_path + \"/quorum/status\", quorum_str))",
          "new_line_content": "        if (!last_part.empty() && !data.getActiveContainingPart(last_part))    /// TODO Disable replica for distributed queries.",
          "content_same": false
        },
        {
          "line": 2859,
          "old_api": "MergeTreePartInfo::fromPartName(quorum_entry.part_name, data.format_version)",
          "new_api": "empty",
          "old_text": "MergeTreePartInfo::fromPartName(quorum_entry.part_name, data.format_version)",
          "new_text": "last_part.empty()",
          "old_line_content": "                auto part_info = MergeTreePartInfo::fromPartName(quorum_entry.part_name, data.format_version);",
          "new_line_content": "        if (last_part.empty())  /// If no part has been written with quorum.",
          "content_same": false
        },
        {
          "line": 2865,
          "old_api": "MergeTreePartInfo::fromPartName(last_part, data.format_version)",
          "new_api": "fromString",
          "old_text": "MergeTreePartInfo::fromPartName(last_part, data.format_version)",
          "new_text": "quorum_entry.fromString(quorum_str)",
          "old_line_content": "            auto part_info = MergeTreePartInfo::fromPartName(last_part, data.format_version);",
          "new_line_content": "                quorum_entry.fromString(quorum_str);",
          "content_same": false
        },
        {
          "line": 2895,
          "old_api": "assertNotReadonly",
          "new_api": "totalMilliseconds",
          "old_text": "assertNotReadonly()",
          "new_text": "std::make_shared<ReplicatedMergeTreeBlockOutputStream>(*this,\n        settings.insert_quorum, settings.insert_quorum_timeout.totalMilliseconds(), deduplicate)",
          "old_line_content": "    assertNotReadonly();",
          "new_line_content": "    return std::make_shared<ReplicatedMergeTreeBlockOutputStream>(*this,",
          "content_same": false
        },
        {
          "line": 2916,
          "old_api": "getMergePredicate",
          "new_api": "DiskSpaceMonitor::getUnreservedFreeSpace(full_path)",
          "old_text": "queue.getMergePredicate(zookeeper)",
          "new_text": "DiskSpaceMonitor::getUnreservedFreeSpace(full_path)",
          "old_line_content": "        ReplicatedMergeTreeMergePredicate can_merge = queue.getMergePredicate(zookeeper);",
          "new_line_content": "        size_t disk_space = DiskSpaceMonitor::getUnreservedFreeSpace(full_path);",
          "content_same": false
        },
        {
          "line": 2932,
          "old_api": "getSettingsRef",
          "new_api": "getPartitionIDFromQuery",
          "old_text": "context.getSettingsRef()",
          "new_text": "data.getPartitionIDFromQuery(partition, context)",
          "old_line_content": "            if (context.getSettingsRef().optimize_throw_if_noop)",
          "new_line_content": "            String partition_id = data.getPartitionIDFromQuery(partition, context);",
          "content_same": false
        },
        {
          "line": 2933,
          "old_api": "Exception",
          "new_api": "selectAllPartsToMergeWithinPartition",
          "old_text": "Exception(message, ErrorCodes::CANNOT_ASSIGN_OPTIMIZE)",
          "new_text": "merger_mutator.selectAllPartsToMergeWithinPartition(\n                future_merged_part, disk_space, can_merge, partition_id, final, &disable_reason)",
          "old_line_content": "                throw Exception(message, ErrorCodes::CANNOT_ASSIGN_OPTIMIZE);",
          "new_line_content": "            selected = merger_mutator.selectAllPartsToMergeWithinPartition(",
          "content_same": false
        },
        {
          "line": 2939,
          "old_api": "empty",
          "new_api": "getSettingsRef",
          "old_text": "disable_reason.empty()",
          "new_text": "context.getSettingsRef()",
          "old_line_content": "            LOG_INFO(log, \"Cannot select parts for optimization\" + (disable_reason.empty() ? \"\" : \": \" + disable_reason));",
          "new_line_content": "            if (context.getSettingsRef().optimize_throw_if_noop)",
          "content_same": false
        },
        {
          "line": 2940,
          "old_api": "handle_noop",
          "new_api": "Exception",
          "old_text": "handle_noop(disable_reason)",
          "new_text": "Exception(message, ErrorCodes::CANNOT_ASSIGN_OPTIMIZE)",
          "old_line_content": "            return handle_noop(disable_reason);",
          "new_line_content": "                throw Exception(message, ErrorCodes::CANNOT_ASSIGN_OPTIMIZE);",
          "content_same": false
        },
        {
          "line": 2980,
          "old_api": "apply",
          "new_api": "checkAlter",
          "old_text": "params.apply(new_columns)",
          "new_text": "data.checkAlter(params)",
          "old_line_content": "        params.apply(new_columns);",
          "new_line_content": "        data.checkAlter(params);",
          "content_same": false
        },
        {
          "line": 3021,
          "old_api": "LOG_WARNING",
          "new_api": "LOG_DEBUG",
          "old_text": "LOG_WARNING(log, \"Replica \" << replica << \" is not active during ALTER query.\"\n                    \" ALTER will be done asynchronously when replica becomes active.\")",
          "new_text": "LOG_DEBUG(log, \"Waiting for \" << replica << \" to apply changes\")",
          "old_line_content": "                LOG_WARNING(log, \"Replica \" << replica << \" is not active during ALTER query.\"",
          "new_line_content": "        LOG_DEBUG(log, \"Waiting for \" << replica << \" to apply changes\");",
          "content_same": false
        },
        {
          "line": 3031,
          "old_api": "tryGet",
          "new_api": "emplace",
          "old_text": "getZooKeeper()->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/columns\", replica_columns_str, &stat)",
          "new_text": "inactive_replicas.emplace(replica)",
          "old_line_content": "            if (!getZooKeeper()->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/columns\", replica_columns_str, &stat))",
          "new_line_content": "                inactive_replicas.emplace(replica);",
          "content_same": false
        },
        {
          "line": 3101,
          "old_api": "empty",
          "new_api": "end",
          "old_text": "timed_out_replicas.empty()",
          "new_text": "inactive_replicas.end()",
          "old_line_content": "            if (!timed_out_replicas.empty())",
          "new_line_content": "                for (auto it = inactive_replicas.begin(); it != inactive_replicas.end(); ++it)",
          "content_same": false
        },
        {
          "line": 3105,
          "old_api": "end",
          "new_api": "empty",
          "old_text": "timed_out_replicas.end()",
          "new_text": "inactive_replicas.empty()",
          "old_line_content": "                for (auto it = timed_out_replicas.begin(); it != timed_out_replicas.end(); ++it)",
          "new_line_content": "            if (!timed_out_replicas.empty() && !inactive_replicas.empty())",
          "content_same": false
        },
        {
          "line": 3113,
          "old_api": "str",
          "new_api": "begin",
          "old_text": "exception_message.str()",
          "new_text": "timed_out_replicas.begin()",
          "old_line_content": "            throw Exception(exception_message.str(), ErrorCodes::UNFINISHED);",
          "new_line_content": "                    exception_message << (it == timed_out_replicas.begin() ? \": \" : \", \") << *it;",
          "content_same": false
        },
        {
          "line": 3134,
          "old_api": "getPartName",
          "new_api": "DateLUT::instance()",
          "old_text": "part_info.getPartName()",
          "new_text": "DateLUT::instance()",
          "old_line_content": "    return part_info.getPartName();",
          "new_line_content": "        const auto & lut = DateLUT::instance();",
          "content_same": false
        },
        {
          "line": 3182,
          "old_api": "getFakePartCoveringAllPartsInPartition",
          "new_api": "assertNotReadonly",
          "old_text": "getFakePartCoveringAllPartsInPartition(partition_id, drop_range_info)",
          "new_text": "assertNotReadonly()",
          "old_line_content": "    if (!getFakePartCoveringAllPartsInPartition(partition_id, drop_range_info))",
          "new_line_content": "    assertNotReadonly();",
          "content_same": false
        },
        {
          "line": 3200,
          "old_api": "getSettingsRef",
          "new_api": "column_name.safeGet<String>()",
          "old_text": "context.getSettingsRef()",
          "new_text": "column_name.safeGet<String>()",
          "old_line_content": "    if (context.getSettingsRef().replication_alter_partitions_sync != 0)",
          "new_line_content": "    entry.column_name = column_name.safeGet<String>();",
          "content_same": false
        },
        {
          "line": 3203,
          "old_api": "waitForReplicaToProcessLogEntry",
          "new_api": "toString",
          "old_text": "waitForReplicaToProcessLogEntry(replica_name, entry)",
          "new_text": "entry.toString()",
          "old_line_content": "            waitForReplicaToProcessLogEntry(replica_name, entry);",
          "new_line_content": "    String log_znode_path = getZooKeeper()->create(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential);",
          "content_same": false
        },
        {
          "line": 3212,
          "old_api": "assertNotReadonly",
          "new_api": "waitForAllReplicasToProcessLogEntry",
          "old_text": "assertNotReadonly()",
          "new_text": "waitForAllReplicasToProcessLogEntry(entry)",
          "old_line_content": "    assertNotReadonly();",
          "new_line_content": "            waitForAllReplicasToProcessLogEntry(entry);",
          "content_same": false
        },
        {
          "line": 3225,
          "old_api": "dropPartsInPartition",
          "new_api": "getSettingsRef",
          "old_text": "dropPartsInPartition(*zookeeper, partition_id, entry, detach)",
          "new_text": "context.getSettingsRef()",
          "old_line_content": "    if (dropPartsInPartition(*zookeeper, partition_id, entry, detach))",
          "new_line_content": "        sendRequestToLeaderReplica(query, context.getSettingsRef());",
          "content_same": false
        },
        {
          "line": 3258,
          "old_api": "waitForAllReplicasToProcessLogEntry",
          "new_api": "getChildren",
          "old_text": "waitForAllReplicasToProcessLogEntry(entry)",
          "new_text": "zookeeper->getChildren(zookeeper_path + \"/block_numbers\")",
          "old_line_content": "            waitForAllReplicasToProcessLogEntry(entry);",
          "new_line_content": "    Strings partitions = zookeeper->getChildren(zookeeper_path + \"/block_numbers\");",
          "content_same": false
        },
        {
          "line": 3265,
          "old_api": "assertNotReadonly",
          "new_api": "waitForAllReplicasToProcessLogEntry",
          "old_text": "assertNotReadonly()",
          "new_text": "waitForAllReplicasToProcessLogEntry(entry)",
          "old_line_content": "    assertNotReadonly();",
          "new_line_content": "            waitForAllReplicasToProcessLogEntry(entry);",
          "content_same": false
        },
        {
          "line": 3272,
          "old_api": "getPartitionIDFromQuery",
          "new_api": "assertNotReadonly",
          "old_text": "data.getPartitionIDFromQuery(partition, context)",
          "new_text": "assertNotReadonly()",
          "old_line_content": "        partition_id = data.getPartitionIDFromQuery(partition, context);",
          "new_line_content": "    assertNotReadonly();",
          "content_same": false
        },
        {
          "line": 3297,
          "old_api": "add",
          "new_api": "name",
          "old_text": "active_parts.add(name)",
          "new_text": "it.name()",
          "old_line_content": "            active_parts.add(name);",
          "new_line_content": "            String name = it.name();",
          "content_same": false
        },
        {
          "line": 3307,
          "old_api": "empty",
          "new_api": "size",
          "old_text": "containing_part.empty()",
          "new_text": "active_parts.size()",
          "old_line_content": "            if (!containing_part.empty() && containing_part != name)",
          "new_line_content": "        LOG_DEBUG(log, active_parts.size() << \" of them are active\");",
          "content_same": false
        },
        {
          "line": 3308,
          "old_api": "renameTo",
          "new_api": "getParts",
          "old_text": "Poco::File(full_path + source_dir + name).renameTo(full_path + source_dir + \"inactive_\" + name)",
          "new_text": "active_parts.getParts()",
          "old_line_content": "                Poco::File(full_path + source_dir + name).renameTo(full_path + source_dir + \"inactive_\" + name);",
          "new_line_content": "        parts = active_parts.getParts();",
          "content_same": false
        },
        {
          "line": 3313,
          "old_api": "LOG_DEBUG",
          "new_api": "getContainingPart",
          "old_text": "LOG_DEBUG(log, \"Checking parts\")",
          "new_text": "active_parts.getContainingPart(name)",
          "old_line_content": "    LOG_DEBUG(log, \"Checking parts\");",
          "new_line_content": "            String containing_part = active_parts.getContainingPart(name);",
          "content_same": false
        },
        {
          "line": 3325,
          "old_api": "writeExistingPart",
          "new_api": "loadPartAndFixMetadata",
          "old_text": "output.writeExistingPart(part)",
          "new_text": "data.loadPartAndFixMetadata(source_dir + part)",
          "old_line_content": "        output.writeExistingPart(part);",
          "new_line_content": "        loaded_parts.push_back(data.loadPartAndFixMetadata(source_dir + part));",
          "content_same": false
        },
        {
          "line": 3350,
          "old_api": "shutdown",
          "new_api": "tryGetZooKeeper",
          "old_text": "shutdown()",
          "new_text": "tryGetZooKeeper()",
          "old_line_content": "        shutdown();",
          "new_line_content": "        auto zookeeper = tryGetZooKeeper();",
          "content_same": false
        },
        {
          "line": 3357,
          "old_api": "tryRemoveRecursive",
          "new_api": "shutdown",
          "old_text": "zookeeper->tryRemoveRecursive(replica_path)",
          "new_text": "shutdown()",
          "old_line_content": "        zookeeper->tryRemoveRecursive(replica_path);",
          "new_line_content": "        shutdown();",
          "content_same": false
        },
        {
          "line": 3368,
          "old_api": "dropAllData",
          "new_api": "empty",
          "old_text": "data.dropAllData()",
          "new_text": "replicas.empty()",
          "old_line_content": "    data.dropAllData();",
          "new_line_content": "        if (zookeeper->tryGetChildren(zookeeper_path + \"/replicas\", replicas) == ZooKeeperImpl::ZooKeeper::ZOK && replicas.empty())",
          "content_same": false
        },
        {
          "line": 3383,
          "old_api": "getZooKeeper",
          "new_api": "setPath",
          "old_text": "getZooKeeper()",
          "new_text": "data.setPath(new_full_path)",
          "old_line_content": "    auto zookeeper = getZooKeeper();",
          "new_line_content": "    data.setPath(new_full_path);",
          "content_same": false
        },
        {
          "line": 3425,
          "old_api": "existsNodeCached",
          "new_api": "zkutil::makeCreateRequest(zookeeper_block_id_path, \"\", zkutil::CreateMode::Persistent)",
          "old_text": "existsNodeCached(partition_path)",
          "new_text": "zkutil::makeCreateRequest(zookeeper_block_id_path, \"\", zkutil::CreateMode::Persistent)",
          "old_line_content": "    if (!existsNodeCached(partition_path))",
          "new_line_content": "        deduplication_check_ops.emplace_back(zkutil::makeCreateRequest(zookeeper_block_id_path, \"\", zkutil::CreateMode::Persistent));",
          "content_same": false
        },
        {
          "line": 3432,
          "old_api": "zkutil::makeSetRequest(block_numbers_path, \"\", -1)",
          "new_api": "existsNodeCached",
          "old_text": "zkutil::makeSetRequest(block_numbers_path, \"\", -1)",
          "new_text": "existsNodeCached(partition_path)",
          "old_line_content": "        ops.push_back(zkutil::makeSetRequest(block_numbers_path, \"\", -1));",
          "new_line_content": "    if (!existsNodeCached(partition_path))",
          "content_same": false
        },
        {
          "line": 3435,
          "old_api": "tryMulti",
          "new_api": "zkutil::makeCreateRequest(partition_path, \"\", zkutil::CreateMode::Persistent)",
          "old_text": "zookeeper->tryMulti(ops, responses)",
          "new_text": "zkutil::makeCreateRequest(partition_path, \"\", zkutil::CreateMode::Persistent)",
          "old_line_content": "        int code = zookeeper->tryMulti(ops, responses);",
          "new_line_content": "        ops.push_back(zkutil::makeCreateRequest(partition_path, \"\", zkutil::CreateMode::Persistent));",
          "content_same": false
        },
        {
          "line": 3444,
          "old_api": "AbandonableLockInZooKeeper",
          "new_api": "zkutil::KeeperMultiException::check(code, ops, responses)",
          "old_text": "AbandonableLockInZooKeeper(\n            partition_path + \"/block-\", zookeeper_path + \"/temp\", *zookeeper, &deduplication_check_ops)",
          "new_text": "zkutil::KeeperMultiException::check(code, ops, responses)",
          "old_line_content": "        lock = AbandonableLockInZooKeeper(",
          "new_line_content": "            zkutil::KeeperMultiException::check(code, ops, responses);",
          "content_same": false
        },
        {
          "line": 3456,
          "old_api": "displayText",
          "new_api": "getPathForFirstFailedOp",
          "old_text": "e.displayText()",
          "new_text": "e.getPathForFirstFailedOp()",
          "old_line_content": "        throw Exception(\"Cannot allocate block number in ZooKeeper: \" + e.displayText(), ErrorCodes::KEEPER_EXCEPTION);",
          "new_line_content": "        if (e.code == ZooKeeperImpl::ZooKeeper::ZNODEEXISTS && e.getPathForFirstFailedOp() == zookeeper_block_id_path)",
          "content_same": false
        },
        {
          "line": 3459,
          "old_api": "std::move(lock)",
          "new_api": "displayText",
          "old_text": "std::move(lock)",
          "new_text": "e.displayText()",
          "old_line_content": "    return {std::move(lock)};",
          "new_line_content": "        throw Exception(\"Cannot allocate block number in ZooKeeper: \" + e.displayText(), ErrorCodes::KEEPER_EXCEPTION);",
          "content_same": false
        },
        {
          "line": 3511,
          "old_api": "get",
          "new_api": "LOG_DEBUG",
          "old_text": "getZooKeeper()->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\", nullptr, event)",
          "new_text": "LOG_DEBUG(log, \"Waiting for \" << replica << \" to pull \" << log_node_name << \" to queue\")",
          "old_line_content": "            String log_pointer = getZooKeeper()->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\", nullptr, event);",
          "new_line_content": "        LOG_DEBUG(log, \"Waiting for \" << replica << \" to pull \" << log_node_name << \" to queue\");",
          "content_same": false
        },
        {
          "line": 3518,
          "old_api": "startsWith",
          "new_api": "get",
          "old_text": "startsWith(entry.znode_name, \"queue-\")",
          "new_text": "getZooKeeper()->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\", nullptr, event)",
          "old_line_content": "    else if (startsWith(entry.znode_name, \"queue-\"))",
          "new_line_content": "            String log_pointer = getZooKeeper()->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\", nullptr, event);",
          "content_same": false
        },
        {
          "line": 3556,
          "old_api": "get",
          "new_api": "LOG_DEBUG",
          "old_text": "getZooKeeper()->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\", nullptr, event)",
          "new_text": "LOG_DEBUG(log, \"Waiting for \" << replica << \" to pull \" << log_node_name << \" to queue\")",
          "old_line_content": "                String log_pointer = getZooKeeper()->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\", nullptr, event);",
          "new_line_content": "            LOG_DEBUG(log, \"Waiting for \" << replica << \" to pull \" << log_node_name << \" to queue\");",
          "content_same": false
        },
        {
          "line": 3567,
          "old_api": "empty",
          "new_api": "wait",
          "old_text": "log_node_name.empty()",
          "new_text": "event->wait()",
          "old_line_content": "    if (!log_node_name.empty())",
          "new_line_content": "                event->wait();",
          "content_same": false
        },
        {
          "line": 3577,
          "old_api": "getChildren",
          "new_api": "LOG_DEBUG",
          "old_text": "getZooKeeper()->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/queue\")",
          "new_text": "LOG_DEBUG(log, \"Looking for corresponding node in \" << replica << \" queue\")",
          "old_line_content": "    Strings queue_entries = getZooKeeper()->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/queue\");",
          "new_line_content": "        LOG_DEBUG(log, \"Looking for corresponding node in \" << replica << \" queue\");",
          "content_same": false
        },
        {
          "line": 3601,
          "old_api": "waitForDisappear",
          "new_api": "size",
          "old_text": "getZooKeeper()->waitForDisappear(zookeeper_path + \"/replicas/\" + replica + \"/queue/\" + queue_entry_to_wait_for)",
          "new_text": "queue_entries.size()",
          "old_line_content": "    getZooKeeper()->waitForDisappear(zookeeper_path + \"/replicas/\" + replica + \"/queue/\" + queue_entry_to_wait_for);",
          "new_line_content": "        LOG_DEBUG(log, \"No corresponding node found. Assuming it has been already processed.\" \" Found \" << queue_entries.size() << \" nodes.\");",
          "content_same": false
        },
        {
          "line": 3614,
          "old_api": "getAbsoluteDelay",
          "new_api": "tryGetZooKeeper",
          "old_text": "getAbsoluteDelay()",
          "new_text": "tryGetZooKeeper()",
          "old_line_content": "    res.absolute_delay = getAbsoluteDelay(); /// NOTE: may be slightly inconsistent with queue status.",
          "new_line_content": "    auto zookeeper = tryGetZooKeeper();",
          "content_same": false
        },
        {
          "line": 3641,
          "old_api": "strlen",
          "new_api": "empty",
          "old_text": "strlen(\"log-\")",
          "new_text": "log_entries.empty()",
          "old_line_content": "            res.log_max_index = parse<UInt64>(last_log_entry.substr(strlen(\"log-\")));",
          "new_line_content": "        if (log_entries.empty())",
          "content_same": false
        },
        {
          "line": 3647,
          "old_api": "getChildren",
          "new_api": "end",
          "old_text": "zookeeper->getChildren(zookeeper_path + \"/replicas\")",
          "new_text": "log_entries.end()",
          "old_line_content": "        auto all_replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "new_line_content": "            const String & last_log_entry = *std::max_element(log_entries.begin(), log_entries.end());",
          "content_same": false
        },
        {
          "line": 3648,
          "old_api": "size",
          "new_api": "strlen",
          "old_text": "all_replicas.size()",
          "new_text": "strlen(\"log-\")",
          "old_line_content": "        res.total_replicas = all_replicas.size();",
          "new_line_content": "            res.log_max_index = parse<UInt64>(last_log_entry.substr(strlen(\"log-\")));",
          "content_same": false
        },
        {
          "line": 3652,
          "old_api": "exists",
          "new_api": "parse<UInt64>(log_pointer_str)",
          "old_text": "zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")",
          "new_text": "parse<UInt64>(log_pointer_str)",
          "old_line_content": "            if (zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\"))",
          "new_line_content": "        res.log_pointer = log_pointer_str.empty() ? 0 : parse<UInt64>(log_pointer_str);",
          "content_same": false
        },
        {
          "line": 3669,
          "old_api": "Exception",
          "new_api": "empty",
          "old_text": "Exception(\"Leader was suddenly changed or logical error.\", ErrorCodes::LEADERSHIP_CHANGED)",
          "new_text": "live_replicas.empty()",
          "old_line_content": "        throw Exception(\"Leader was suddenly changed or logical error.\", ErrorCodes::LEADERSHIP_CHANGED);",
          "new_line_content": "    if (live_replicas.empty())",
          "content_same": false
        },
        {
          "line": 3697,
          "old_api": "formattedAST",
          "new_api": "getSettingsRef",
          "old_text": "formattedAST(new_query)",
          "new_text": "context.getSettingsRef()",
          "old_line_content": "    RemoteBlockInputStream stream(connection, formattedAST(new_query), {}, context, &settings);",
          "new_line_content": "    auto timeouts = ConnectionTimeouts::getTCPTimeoutsWithoutFailover(context.getSettingsRef());",
          "content_same": false
        },
        {
          "line": 3715,
          "old_api": "getInsertTimes",
          "new_api": "getEntries",
          "old_text": "queue.getInsertTimes(min_unprocessed_insert_time, max_processed_insert_time)",
          "new_text": "queue.getEntries(res)",
          "old_line_content": "    queue.getInsertTimes(min_unprocessed_insert_time, max_processed_insert_time);",
          "new_line_content": "    queue.getEntries(res);",
          "content_same": false
        },
        {
          "line": 3722,
          "old_api": "time",
          "new_api": "getInsertTimes",
          "old_text": "time(nullptr)",
          "new_text": "queue.getInsertTimes(min_unprocessed_insert_time, max_processed_insert_time)",
          "old_line_content": "    time_t current_time = time(nullptr);",
          "new_line_content": "    queue.getInsertTimes(min_unprocessed_insert_time, max_processed_insert_time);",
          "content_same": false
        },
        {
          "line": 3786,
          "old_api": "parse<time_t>(value)",
          "new_api": "exists",
          "old_text": "parse<time_t>(value)",
          "new_text": "zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")",
          "old_line_content": "        time_t replica_time = value.empty() ? 0 : parse<time_t>(value);",
          "new_line_content": "        if (!zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\"))",
          "content_same": false
        },
        {
          "line": 3855,
          "old_api": "push_back",
          "new_api": "getChildren",
          "old_text": "active_replicas.push_back(replica)",
          "new_text": "zookeeper->getChildren(from + \"/replicas\")",
          "old_line_content": "                active_replicas.push_back(replica);",
          "new_line_content": "        replicas = zookeeper->getChildren(from + \"/replicas\");",
          "content_same": false
        },
        {
          "line": 3858,
          "old_api": "Exception",
          "new_api": "size",
          "old_text": "Exception(\"No active replicas for shard \" + from, ErrorCodes::NO_ACTIVE_REPLICAS)",
          "new_text": "replicas.size()",
          "old_line_content": "            throw Exception(\"No active replicas for shard \" + from, ErrorCodes::NO_ACTIVE_REPLICAS);",
          "new_line_content": "        active_replicas.reserve(replicas.size());",
          "content_same": false
        },
        {
          "line": 3874,
          "old_api": "parse<UInt64>(log_pointer_str)",
          "new_api": "std::numeric_limits<UInt64>::max()",
          "old_text": "parse<UInt64>(log_pointer_str)",
          "new_text": "std::numeric_limits<UInt64>::max()",
          "old_line_content": "            Int64 log_pointer = log_pointer_str.empty() ? 0 : parse<UInt64>(log_pointer_str);",
          "new_line_content": "        UInt64 min_queue_size = std::numeric_limits<UInt64>::max();",
          "content_same": false
        },
        {
          "line": 3928,
          "old_api": "push_back",
          "new_api": "getParts",
          "old_text": "parts_to_fetch_partition.push_back(part)",
          "new_text": "active_parts_set.getParts()",
          "old_line_content": "                    parts_to_fetch_partition.push_back(part);",
          "new_line_content": "            parts_to_fetch = active_parts_set.getParts();",
          "content_same": false
        },
        {
          "line": 3934,
          "old_api": "Exception",
          "new_api": "MergeTreePartInfo::fromPartName(part, data.format_version)",
          "old_text": "Exception(\"Partition \" + partition_id + \" on \" + best_replica_path + \" doesn't exist\", ErrorCodes::PARTITION_DOESNT_EXIST)",
          "new_text": "MergeTreePartInfo::fromPartName(part, data.format_version)",
          "old_line_content": "                throw Exception(\"Partition \" + partition_id + \" on \" + best_replica_path + \" doesn't exist\", ErrorCodes::PARTITION_DOESNT_EXIST);",
          "new_line_content": "                if (MergeTreePartInfo::fromPartName(part, data.format_version).partition_id == partition_id)",
          "content_same": false
        },
        {
          "line": 3940,
          "old_api": "getContainingPart",
          "new_api": "empty",
          "old_text": "active_parts_set.getContainingPart(missing_part)",
          "new_text": "parts_to_fetch.empty()",
          "old_line_content": "                String containing_part = active_parts_set.getContainingPart(missing_part);",
          "new_line_content": "            if (parts_to_fetch.empty())",
          "content_same": false
        },
        {
          "line": 3941,
          "old_api": "empty",
          "new_api": "Exception",
          "old_text": "containing_part.empty()",
          "new_text": "Exception(\"Partition \" + partition_id + \" on \" + best_replica_path + \" doesn't exist\", ErrorCodes::PARTITION_DOESNT_EXIST)",
          "old_line_content": "                if (!containing_part.empty())",
          "new_line_content": "                throw Exception(\"Partition \" + partition_id + \" on \" + best_replica_path + \" doesn't exist\", ErrorCodes::PARTITION_DOESNT_EXIST);",
          "content_same": false
        },
        {
          "line": 3948,
          "old_api": "size",
          "new_api": "empty",
          "old_text": "parts_to_fetch.size()",
          "new_text": "containing_part.empty()",
          "old_line_content": "        LOG_INFO(log, \"Parts to fetch: \" << parts_to_fetch.size());",
          "new_line_content": "                if (!containing_part.empty())",
          "content_same": false
        },
        {
          "line": 3955,
          "old_api": "fetchPart",
          "new_api": "size",
          "old_text": "fetchPart(part, best_replica_path, true, 0)",
          "new_text": "parts_to_fetch.size()",
          "old_line_content": "                fetchPart(part, best_replica_path, true, 0);",
          "new_line_content": "        LOG_INFO(log, \"Parts to fetch: \" << parts_to_fetch.size());",
          "content_same": false
        },
        {
          "line": 3962,
          "old_api": "displayText",
          "new_api": "fetchPart",
          "old_text": "e.displayText()",
          "new_text": "fetchPart(part, best_replica_path, true, 0)",
          "old_line_content": "                LOG_INFO(log, e.displayText());",
          "new_line_content": "                fetchPart(part, best_replica_path, true, 0);",
          "content_same": false
        },
        {
          "line": 4060,
          "old_api": "toString",
          "new_api": "getLocks",
          "old_text": "zkutil::makeCreateRequest(\n            mutations_path + \"/\", entry.toString(), zkutil::CreateMode::PersistentSequential)",
          "new_text": "block_number_locks.getLocks()",
          "old_line_content": "        requests.emplace_back(zkutil::makeCreateRequest(",
          "new_line_content": "        for (const auto & lock : block_number_locks.getLocks())",
          "content_same": false
        },
        {
          "line": 4071,
          "old_api": "LOG_TRACE",
          "new_api": "tryMulti",
          "old_text": "LOG_TRACE(log, \"Created mutation with id \" << entry.znode_name)",
          "new_text": "zookeeper->tryMulti(requests, responses)",
          "old_line_content": "            LOG_TRACE(log, \"Created mutation with id \" << entry.znode_name);",
          "new_line_content": "        int32_t rc = zookeeper->tryMulti(requests, responses);",
          "content_same": false
        },
        {
          "line": 4076,
          "old_api": "LOG_TRACE",
          "new_api": "get",
          "old_text": "LOG_TRACE(log, \"Version conflict when trying to create a mutation node, retrying...\")",
          "new_text": "responses[1].get()",
          "old_line_content": "            LOG_TRACE(log, \"Version conflict when trying to create a mutation node, retrying...\");",
          "new_line_content": "                static_cast<const zkutil::CreateResponse *>(responses[1].get())->path_created;",
          "content_same": false
        },
        {
          "line": 4152,
          "old_api": "getCurrentExceptionMessage",
          "new_api": "emplace_back",
          "old_text": "getCurrentExceptionMessage(true)",
          "new_text": "part_names_to_delete_completely.emplace_back(part->name)",
          "old_line_content": "        LOG_ERROR(log, \"There is a problem with deleting parts from ZooKeeper: \" << getCurrentExceptionMessage(true));",
          "new_line_content": "            part_names_to_delete_completely.emplace_back(part->name);",
          "content_same": false
        },
        {
          "line": 4163,
          "old_api": "emplace_back",
          "new_api": "size",
          "old_text": "parts_to_remove_from_filesystem.emplace_back(part)",
          "new_text": "part_names_to_retry_deletion.size()",
          "old_line_content": "            parts_to_remove_from_filesystem.emplace_back(part);",
          "new_line_content": "    auto num_reliably_deleted_parts = parts_to_delete_completely.size() - part_names_to_retry_deletion.size();",
          "content_same": false
        },
        {
          "line": 4169,
          "old_api": "empty",
          "new_api": "count",
          "old_text": "parts_to_retry_deletion.empty()",
          "new_text": "part_names_to_retry_deletion.count(part->name)",
          "old_line_content": "    if (!parts_to_retry_deletion.empty())",
          "new_line_content": "        if (part_names_to_retry_deletion.count(part->name) == 0)",
          "content_same": false
        },
        {
          "line": 4172,
          "old_api": "size",
          "new_api": "emplace_back",
          "old_text": "parts_to_retry_deletion.size()",
          "new_text": "parts_to_retry_deletion.emplace_back(part)",
          "old_line_content": "        LOG_DEBUG(log, \"Will retry deletion of \" << parts_to_retry_deletion.size() << \" parts in the next time\");",
          "new_line_content": "            parts_to_retry_deletion.emplace_back(part);",
          "content_same": false
        },
        {
          "line": 4178,
          "old_api": "remove_parts_from_filesystem",
          "new_api": "rollbackDeletingParts",
          "old_text": "remove_parts_from_filesystem(parts_to_remove_from_filesystem)",
          "new_text": "data.rollbackDeletingParts(parts_to_retry_deletion)",
          "old_line_content": "        remove_parts_from_filesystem(parts_to_remove_from_filesystem);",
          "new_line_content": "        data.rollbackDeletingParts(parts_to_retry_deletion);",
          "content_same": false
        },
        {
          "line": 4179,
          "old_api": "removePartsFinally",
          "new_api": "size",
          "old_text": "data.removePartsFinally(parts_to_remove_from_filesystem)",
          "new_text": "parts_to_retry_deletion.size()",
          "old_line_content": "        data.removePartsFinally(parts_to_remove_from_filesystem);",
          "new_line_content": "        LOG_DEBUG(log, \"Will retry deletion of \" << parts_to_retry_deletion.size() << \" parts in the next time\");",
          "content_same": false
        },
        {
          "line": 4212,
          "old_api": "getZooKeeper",
          "new_api": "size",
          "old_text": "getZooKeeper()",
          "new_text": "part_names.size()",
          "old_line_content": "            auto zookeeper = getZooKeeper();",
          "new_line_content": "        futures.reserve(part_names.size());",
          "content_same": false
        },
        {
          "line": 4219,
          "old_api": "tryAsyncMulti",
          "new_api": "getZooKeeper",
          "old_text": "zookeeper->tryAsyncMulti(ops)",
          "new_text": "getZooKeeper()",
          "old_line_content": "                futures.emplace_back(zookeeper->tryAsyncMulti(ops));",
          "new_line_content": "            auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 4224,
          "old_api": "get",
          "new_api": "removePartFromZooKeeper",
          "old_text": "future.get()",
          "new_text": "removePartFromZooKeeper(part_name, ops)",
          "old_line_content": "                auto response = future.get();",
          "new_line_content": "                removePartFromZooKeeper(part_name, ops);",
          "content_same": false
        },
        {
          "line": 4242,
          "old_api": "zkutil::isHardwareError(e.code)",
          "new_api": "ZooKeeperImpl::Exception(response.error)",
          "old_text": "zkutil::isHardwareError(e.code)",
          "new_text": "ZooKeeperImpl::Exception(response.error)",
          "old_line_content": "            if (zkutil::isHardwareError(e.code))",
          "new_line_content": "                throw ZooKeeperImpl::Exception(response.error);",
          "content_same": false
        },
        {
          "line": 4249,
          "old_api": "std::chrono::milliseconds(1000)",
          "new_api": "zkutil::isHardwareError(e.code)",
          "old_text": "std::chrono::milliseconds(1000)",
          "new_text": "zkutil::isHardwareError(e.code)",
          "old_line_content": "            std::this_thread::sleep_for(std::chrono::milliseconds(1000));",
          "new_line_content": "            if (zkutil::isHardwareError(e.code))",
          "content_same": false
        },
        {
          "line": 4267,
          "old_api": "cend",
          "new_api": "cbegin",
          "old_text": "part_names.cend()",
          "new_text": "part_names.cbegin()",
          "old_line_content": "        if (ops.size() >= zkutil::MULTI_BATCH_SIZE || it_next == part_names.cend())",
          "new_line_content": "    auto it_first_node_in_batch = part_names.cbegin();",
          "content_same": false
        },
        {
          "line": 4271,
          "old_api": "clear",
          "new_api": "removePartFromZooKeeper",
          "old_text": "ops.clear()",
          "new_text": "removePartFromZooKeeper(*it, ops)",
          "old_line_content": "            ops.clear();",
          "new_line_content": "        removePartFromZooKeeper(*it, ops);",
          "content_same": false
        },
        {
          "line": 4288,
          "old_api": "zkutil::isHardwareError(cur_code)",
          "new_api": "removePartFromZooKeeper",
          "old_text": "zkutil::isHardwareError(cur_code)",
          "new_text": "removePartFromZooKeeper(*it_in_batch, cur_ops)",
          "old_line_content": "                    else if (parts_should_be_retried && zkutil::isHardwareError(cur_code))",
          "new_line_content": "                    removePartFromZooKeeper(*it_in_batch, cur_ops);",
          "content_same": false
        },
        {
          "line": 4301,
          "old_api": "emplace",
          "new_api": "zkutil::ZooKeeper::error2string(cur_code)",
          "old_text": "parts_should_be_retried->emplace(*it_in_batch)",
          "new_text": "zkutil::ZooKeeper::error2string(cur_code)",
          "old_line_content": "                    parts_should_be_retried->emplace(*it_in_batch);",
          "new_line_content": "                        LOG_WARNING(log, \"Cannot remove part \" << *it_in_batch << \" from ZooKeeper: \" << zkutil::ZooKeeper::error2string(cur_code));",
          "content_same": false
        },
        {
          "line": 4305,
          "old_api": "LOG_WARNING",
          "new_api": "zkutil::isHardwareError(code)",
          "old_text": "LOG_WARNING(log, \"There was a problem with deleting \" << (it_next - it_first_node_in_batch)\n                    << \" nodes from ZooKeeper: \" << ::zkutil::ZooKeeper::error2string(code))",
          "new_text": "zkutil::isHardwareError(code)",
          "old_line_content": "                LOG_WARNING(log, \"There was a problem with deleting \" << (it_next - it_first_node_in_batch)",
          "new_line_content": "            else if (parts_should_be_retried && zkutil::isHardwareError(code))",
          "content_same": false
        },
        {
          "line": 4326,
          "old_api": "startsWith",
          "new_api": "tryGetChildren",
          "old_text": "startsWith(block_id, partition_prefix)",
          "new_text": "zookeeper.tryGetChildren(zookeeper_path + \"/blocks\", blocks)",
          "old_line_content": "        if (startsWith(block_id, partition_prefix))",
          "new_line_content": "    if (zookeeper.tryGetChildren(zookeeper_path + \"/blocks\", blocks))",
          "content_same": false
        },
        {
          "line": 4344,
          "old_api": "eof",
          "new_api": "get",
          "old_text": "buf.eof()",
          "new_text": "pair.second.get()",
          "old_line_content": "        bool parsed = tryReadIntText(block_num, buf) && buf.eof();",
          "new_line_content": "        auto result = pair.second.get();",
          "content_same": false
        },
        {
          "line": 4359,
          "old_api": "LOG_WARNING",
          "new_api": "get",
          "old_text": "LOG_WARNING(log,\n                \"Error while deleting ZooKeeper path `\" << path << \"`: \" + zkutil::ZooKeeper::error2string(rc) << \", ignoring.\")",
          "new_text": "pair.second.get()",
          "old_line_content": "            LOG_WARNING(log,",
          "new_line_content": "        int32_t rc = pair.second.get().error;",
          "content_same": false
        },
        {
          "line": 4363,
          "old_api": "size",
          "new_api": "removeRecursive",
          "old_text": "to_delete_futures.size()",
          "new_text": "zookeeper.removeRecursive(path)",
          "old_line_content": "    LOG_TRACE(log, \"Deleted \" << to_delete_futures.size() << \" deduplication block IDs in partition ID \" << partition_id);",
          "new_line_content": "            zookeeper.removeRecursive(path);",
          "content_same": false
        },
        {
          "line": 4370,
          "old_api": "lockStructure",
          "new_api": "size",
          "old_text": "source_table->lockStructure(false, __PRETTY_FUNCTION__)",
          "new_text": "to_delete_futures.size()",
          "old_line_content": "    auto lock2 = source_table->lockStructure(false, __PRETTY_FUNCTION__);",
          "new_line_content": "    LOG_TRACE(log, \"Deleted \" << to_delete_futures.size() << \" deduplication block IDs in partition ID \" << partition_id);",
          "content_same": false
        },
        {
          "line": 4376,
          "old_api": "getDataPartsVectorInPartition",
          "new_api": "lockStructure",
          "old_text": "src_data->getDataPartsVectorInPartition(MergeTreeDataPartState::Committed, partition_id)",
          "new_text": "lockStructure(false, __PRETTY_FUNCTION__)",
          "old_line_content": "    MergeTreeData::DataPartsVector src_all_parts = src_data->getDataPartsVectorInPartition(MergeTreeDataPartState::Committed, partition_id);",
          "new_line_content": "    auto lock1 = lockStructure(false, __PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 4383,
          "old_api": "size",
          "new_api": "getDataPartsVectorInPartition",
          "old_text": "src_all_parts.size()",
          "new_text": "src_data->getDataPartsVectorInPartition(MergeTreeDataPartState::Committed, partition_id)",
          "old_line_content": "    LOG_DEBUG(log, \"Cloning \" << src_all_parts.size() << \" parts\");",
          "new_line_content": "    MergeTreeData::DataPartsVector src_all_parts = src_data->getDataPartsVectorInPartition(MergeTreeDataPartState::Committed, partition_id);",
          "content_same": false
        },
        {
          "line": 4393,
          "old_api": "getNumber",
          "new_api": "getZooKeeper",
          "old_text": "allocateBlockNumber(partition_id, zookeeper)->getNumber()",
          "new_text": "getZooKeeper()",
          "old_line_content": "    drop_range.max_block = allocateBlockNumber(partition_id, zookeeper)->getNumber();",
          "new_line_content": "    auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 4421,
          "old_api": "getTotalChecksumHex",
          "new_api": "size",
          "old_text": "src_part->checksums.getTotalChecksumHex()",
          "new_text": "src_all_parts.size()",
          "old_line_content": "        String hash_hex = src_part->checksums.getTotalChecksumHex();",
          "new_line_content": "    for (size_t i = 0; i < src_all_parts.size(); ++i)",
          "content_same": false
        },
        {
          "line": 4431,
          "old_api": "getNumber",
          "new_api": "allocateBlockNumber",
          "old_text": "lock->getNumber()",
          "new_text": "allocateBlockNumber(partition_id, zookeeper, block_id_path)",
          "old_line_content": "        UInt64 index = lock->getNumber();",
          "new_line_content": "        auto lock = allocateBlockNumber(partition_id, zookeeper, block_id_path);",
          "content_same": false
        },
        {
          "line": 4438,
          "old_api": "emplace_back",
          "new_api": "getNumber",
          "old_text": "block_id_paths.emplace_back(block_id_path)",
          "new_text": "lock->getNumber()",
          "old_line_content": "        block_id_paths.emplace_back(block_id_path);",
          "new_line_content": "        UInt64 index = lock->getNumber();",
          "content_same": false
        },
        {
          "line": 4446,
          "old_api": "time",
          "new_api": "emplace_back",
          "old_text": "time(nullptr)",
          "new_text": "part_checksums.emplace_back(hash_hex)",
          "old_line_content": "        entry.create_time = time(nullptr);",
          "new_line_content": "        part_checksums.emplace_back(hash_hex);",
          "content_same": false
        },
        {
          "line": 4454,
          "old_api": "emplace_back",
          "new_api": "std::make_shared<ReplicatedMergeTreeLogEntryData::ReplaceRangeEntry>()",
          "old_text": "entry_replace.src_part_names.emplace_back(part->name)",
          "new_text": "std::make_shared<ReplicatedMergeTreeLogEntryData::ReplaceRangeEntry>()",
          "old_line_content": "            entry_replace.src_part_names.emplace_back(part->name);",
          "new_line_content": "        entry.replace_range_entry = std::make_shared<ReplicatedMergeTreeLogEntryData::ReplaceRangeEntry>();",
          "content_same": false
        },
        {
          "line": 4463,
          "old_api": "removePartProducingOpsInRange",
          "new_api": "emplace_back",
          "old_text": "queue.removePartProducingOpsInRange(zookeeper, drop_range)",
          "new_text": "entry_replace.new_part_names.emplace_back(part->name)",
          "old_line_content": "    queue.removePartProducingOpsInRange(zookeeper, drop_range);",
          "new_line_content": "            entry_replace.new_part_names.emplace_back(part->name);",
          "content_same": false
        },
        {
          "line": 4484,
          "old_api": "clear",
          "new_api": "getCommitPartOps",
          "old_text": "ops.clear()",
          "new_text": "getCommitPartOps(ops, dst_parts[i], block_id_paths[i])",
          "old_line_content": "                ops.clear();",
          "new_line_content": "            getCommitPartOps(ops, dst_parts[i], block_id_paths[i]);",
          "content_same": false
        },
        {
          "line": 4495,
          "old_api": "renameTempPartAndReplace",
          "new_api": "toString",
          "old_text": "data.renameTempPartAndReplace(part, nullptr, &transaction, data_parts_lock)",
          "new_text": "entry.toString()",
          "old_line_content": "                data.renameTempPartAndReplace(part, nullptr, &transaction, data_parts_lock);",
          "new_line_content": "        ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential));",
          "content_same": false
        },
        {
          "line": 4505,
          "old_api": "removePartsInRangeFromWorkingSet",
          "new_api": "multi",
          "old_text": "data.removePartsInRangeFromWorkingSet(drop_range, true, false, data_parts_lock)",
          "new_text": "zookeeper->multi(ops)",
          "old_line_content": "                parts_to_remove = data.removePartsInRangeFromWorkingSet(drop_range, true, false, data_parts_lock);",
          "new_line_content": "        op_results = zookeeper->multi(ops);",
          "content_same": false
        },
        {
          "line": 4508,
          "old_api": "elapsed",
          "new_api": "lockParts",
          "old_text": "watch.elapsed()",
          "new_text": "data.lockParts()",
          "old_line_content": "        PartLog::addNewParts(this->context, dst_parts, watch.elapsed());",
          "new_line_content": "            auto data_parts_lock = data.lockParts();",
          "content_same": false
        },
        {
          "line": 4512,
          "old_api": "ExecutionStatus::fromCurrentException()",
          "new_api": "removePartsInRangeFromWorkingSet",
          "old_text": "ExecutionStatus::fromCurrentException()",
          "new_text": "data.removePartsInRangeFromWorkingSet(drop_range, true, false, data_parts_lock)",
          "old_line_content": "        PartLog::addNewParts(this->context, dst_parts, watch.elapsed(), ExecutionStatus::fromCurrentException());",
          "new_line_content": "                parts_to_remove = data.removePartsInRangeFromWorkingSet(drop_range, true, false, data_parts_lock);",
          "content_same": false
        },
        {
          "line": 4523,
          "old_api": "tryRemovePartsFromZooKeeperWithRetries",
          "new_api": "back",
          "old_text": "tryRemovePartsFromZooKeeperWithRetries(parts_to_remove)",
          "new_text": "op_results.back()",
          "old_line_content": "    tryRemovePartsFromZooKeeperWithRetries(parts_to_remove);",
          "new_line_content": "    String log_znode_path = dynamic_cast<const zkutil::CreateResponse &>(*op_results.back()).path_created;",
          "content_same": false
        },
        {
          "line": 4527,
          "old_api": "schedule",
          "new_api": "assumeUnlocked",
          "old_text": "cleanup_thread->schedule()",
          "new_text": "lock.assumeUnlocked()",
          "old_line_content": "    cleanup_thread->schedule();",
          "new_line_content": "        lock.assumeUnlocked();",
          "content_same": false
        },
        {
          "line": 4530,
          "old_api": "getSettingsRef",
          "new_api": "tryRemovePartsFromZooKeeperWithRetries",
          "old_text": "context.getSettingsRef()",
          "new_text": "tryRemovePartsFromZooKeeperWithRetries(parts_to_remove)",
          "old_line_content": "    if (context.getSettingsRef().replication_alter_partitions_sync > 1)",
          "new_line_content": "    tryRemovePartsFromZooKeeperWithRetries(parts_to_remove);",
          "content_same": false
        },
        {
          "line": 4560,
          "old_api": "toString",
          "new_api": "zkutil::makeCheckRequest(\n        zookeeper_path + \"/columns\",\n        columns_version)",
          "old_text": "zkutil::makeCreateRequest(\n        replica_path + \"/parts/\" + part->name + \"/columns\",\n        part->columns.toString(),\n        zkutil::CreateMode::Persistent)",
          "new_text": "zkutil::makeCheckRequest(\n        zookeeper_path + \"/columns\",\n        columns_version)",
          "old_line_content": "    ops.emplace_back(zkutil::makeCreateRequest(",
          "new_line_content": "    ops.emplace_back(zkutil::makeCheckRequest(",
          "content_same": false
        },
        {
          "line": 4622,
          "old_api": "tryWait",
          "new_api": "set",
          "old_text": "event.tryWait(50)",
          "new_text": "event.set()",
          "old_line_content": "        event.tryWait(50);",
          "new_line_content": "        event.set();",
          "content_same": false
        },
        {
          "line": 4631,
          "old_api": "Exception",
          "new_api": "elapsedMilliseconds",
          "old_text": "Exception(\"Shutdown is called for table\", ErrorCodes::ABORTED)",
          "new_text": "watch.elapsedMilliseconds()",
          "old_line_content": "            throw Exception(\"Shutdown is called for table\", ErrorCodes::ABORTED);",
          "new_line_content": "        if (max_wait_milliseconds && watch.elapsedMilliseconds() > max_wait_milliseconds)",
          "content_same": false
        },
        {
          "line": 4666,
          "old_api": "time",
          "new_api": "LOG_DEBUG",
          "old_text": "time(nullptr)",
          "new_text": "LOG_DEBUG(log, \"Disabled merges covered by range \" << drop_range_fake_part_name)",
          "old_line_content": "    entry.create_time = time(nullptr);",
          "new_line_content": "    LOG_DEBUG(log, \"Disabled merges covered by range \" << drop_range_fake_part_name);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 4101,
          "old_api": null,
          "new_api": "lockStructure",
          "old_text": null,
          "new_text": "lockStructure(false, __PRETTY_FUNCTION__)",
          "old_line_content": "    MergeTreeData::DataPartsVector parts_to_delete_only_from_filesystem;    // Only duplicates",
          "new_line_content": "    auto table_lock = lockStructure(false, __PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 4102,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "    MergeTreeData::DataPartsVector parts_to_delete_completely;              // All parts except duplicates",
          "new_line_content": "    auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 4104,
          "old_api": null,
          "new_api": "grabOldParts",
          "old_text": null,
          "new_text": "data.grabOldParts()",
          "old_line_content": "    MergeTreeData::DataPartsVector parts_to_remove_from_filesystem;         // Parts removed from ZK",
          "new_line_content": "    MergeTreeData::DataPartsVector parts = data.grabOldParts();",
          "content_same": false
        },
        {
          "line": 4105,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "parts.empty()",
          "old_line_content": "",
          "new_line_content": "    if (parts.empty())",
          "content_same": false
        },
        {
          "line": 4116,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "parts_to_delete_completely.emplace_back(part)",
          "old_line_content": "    {",
          "new_line_content": "            parts_to_delete_completely.emplace_back(part);",
          "content_same": false
        },
        {
          "line": 4118,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "parts_to_delete_only_from_filesystem.emplace_back(part)",
          "old_line_content": "        {",
          "new_line_content": "            parts_to_delete_only_from_filesystem.emplace_back(part);",
          "content_same": false
        },
        {
          "line": 4120,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "parts.clear()",
          "old_line_content": "            {",
          "new_line_content": "    parts.clear();",
          "content_same": false
        },
        {
          "line": 4128,
          "old_api": null,
          "new_api": "remove",
          "old_text": null,
          "new_text": "part->remove()",
          "old_line_content": "    };",
          "new_line_content": "                part->remove();",
          "content_same": false
        },
        {
          "line": 4132,
          "old_api": null,
          "new_api": "tryLogCurrentException",
          "old_text": null,
          "new_text": "tryLogCurrentException(log, \"There is a problem with deleting part \" + part->name + \" from filesystem\")",
          "old_line_content": "    {",
          "new_line_content": "                tryLogCurrentException(log, \"There is a problem with deleting part \" + part->name + \" from filesystem\");",
          "content_same": false
        },
        {
          "line": 4138,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "parts_to_delete_only_from_filesystem.empty()",
          "old_line_content": "",
          "new_line_content": "    if (!parts_to_delete_only_from_filesystem.empty())",
          "content_same": false
        },
        {
          "line": 4140,
          "old_api": null,
          "new_api": "remove_parts_from_filesystem",
          "old_text": null,
          "new_text": "remove_parts_from_filesystem(parts_to_delete_only_from_filesystem)",
          "old_line_content": "    NameSet part_names_to_retry_deletion;",
          "new_line_content": "        remove_parts_from_filesystem(parts_to_delete_only_from_filesystem);",
          "content_same": false
        },
        {
          "line": 4141,
          "old_api": null,
          "new_api": "removePartsFinally",
          "old_text": null,
          "new_text": "data.removePartsFinally(parts_to_delete_only_from_filesystem)",
          "old_line_content": "    try",
          "new_line_content": "        data.removePartsFinally(parts_to_delete_only_from_filesystem);",
          "content_same": false
        },
        {
          "line": 4143,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "parts_to_delete_only_from_filesystem.size()",
          "old_line_content": "        Strings part_names_to_delete_completely;",
          "new_line_content": "        LOG_DEBUG(log, \"Removed \" << parts_to_delete_only_from_filesystem.size() << \" old duplicate parts\");",
          "content_same": false
        },
        {
          "line": 4154,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "parts_to_delete_completely.size()",
          "old_line_content": "",
          "new_line_content": "        LOG_DEBUG(log, \"Removing \" << parts_to_delete_completely.size() << \" old parts from ZooKeeper\");",
          "content_same": false
        },
        {
          "line": 4155,
          "old_api": null,
          "new_api": "removePartsFromZooKeeper",
          "old_text": null,
          "new_text": "removePartsFromZooKeeper(zookeeper, part_names_to_delete_completely, &part_names_to_retry_deletion)",
          "old_line_content": "    /// Part names that were reliably deleted from ZooKeeper should be deleted from filesystem",
          "new_line_content": "        removePartsFromZooKeeper(zookeeper, part_names_to_delete_completely, &part_names_to_retry_deletion);",
          "content_same": false
        },
        {
          "line": 4159,
          "old_api": null,
          "new_api": "getCurrentExceptionMessage",
          "old_text": null,
          "new_text": "getCurrentExceptionMessage(true)",
          "old_line_content": "    /// Delete normal parts on two sets",
          "new_line_content": "        LOG_ERROR(log, \"There is a problem with deleting parts from ZooKeeper: \" << getCurrentExceptionMessage(true));",
          "content_same": false
        },
        {
          "line": 4164,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Removed \" << num_reliably_deleted_parts << \" old parts from ZooKeeper. Removing them from filesystem.\")",
          "old_line_content": "        else",
          "new_line_content": "    LOG_DEBUG(log, \"Removed \" << num_reliably_deleted_parts << \" old parts from ZooKeeper. Removing them from filesystem.\");",
          "content_same": false
        },
        {
          "line": 4170,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "parts_to_remove_from_filesystem.emplace_back(part)",
          "old_line_content": "    {",
          "new_line_content": "            parts_to_remove_from_filesystem.emplace_back(part);",
          "content_same": false
        },
        {
          "line": 4183,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "parts_to_remove_from_filesystem.empty()",
          "old_line_content": "}",
          "new_line_content": "    if (!parts_to_remove_from_filesystem.empty())",
          "content_same": false
        },
        {
          "line": 4185,
          "old_api": null,
          "new_api": "remove_parts_from_filesystem",
          "old_text": null,
          "new_text": "remove_parts_from_filesystem(parts_to_remove_from_filesystem)",
          "old_line_content": "",
          "new_line_content": "        remove_parts_from_filesystem(parts_to_remove_from_filesystem);",
          "content_same": false
        },
        {
          "line": 4186,
          "old_api": null,
          "new_api": "removePartsFinally",
          "old_text": null,
          "new_text": "data.removePartsFinally(parts_to_remove_from_filesystem)",
          "old_line_content": "bool StorageReplicatedMergeTree::tryRemovePartsFromZooKeeperWithRetries(MergeTreeData::DataPartsVector & parts, size_t max_retries)",
          "new_line_content": "        data.removePartsFinally(parts_to_remove_from_filesystem);",
          "content_same": false
        },
        {
          "line": 4188,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "parts_to_remove_from_filesystem.size()",
          "old_line_content": "    Strings part_names_to_remove;",
          "new_line_content": "        LOG_DEBUG(log, \"Removed \" << parts_to_remove_from_filesystem.size() << \" old parts\");",
          "content_same": false
        },
        {
          "line": 4197,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "part_names_to_remove.emplace_back(part->name)",
          "old_line_content": "    using MultiFuture = std::future<ZooKeeperImpl::ZooKeeper::MultiResponse>;",
          "new_line_content": "        part_names_to_remove.emplace_back(part->name);",
          "content_same": false
        },
        {
          "line": 4199,
          "old_api": null,
          "new_api": "tryRemovePartsFromZooKeeperWithRetries",
          "old_text": null,
          "new_text": "tryRemovePartsFromZooKeeperWithRetries(part_names_to_remove, max_retries)",
          "old_line_content": "    size_t num_tries = 0;",
          "new_line_content": "    return tryRemovePartsFromZooKeeperWithRetries(part_names_to_remove, max_retries);",
          "content_same": false
        },
        {
          "line": 4226,
          "old_api": null,
          "new_api": "tryAsyncMulti",
          "old_text": null,
          "new_text": "zookeeper->tryAsyncMulti(ops)",
          "old_line_content": "                if (response.error == 0 || response.error == ZooKeeperImpl::ZooKeeper::ZNONODE)",
          "new_line_content": "                futures.emplace_back(zookeeper->tryAsyncMulti(ops));",
          "content_same": false
        },
        {
          "line": 4231,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "future.get()",
          "old_line_content": "                    sucess = false;",
          "new_line_content": "                auto response = future.get();",
          "content_same": false
        },
        {
          "line": 4236,
          "old_api": null,
          "new_api": "zkutil::isHardwareError(response.error)",
          "old_text": null,
          "new_text": "zkutil::isHardwareError(response.error)",
          "old_line_content": "            }",
          "new_line_content": "                if (zkutil::isHardwareError(response.error))",
          "content_same": false
        },
        {
          "line": 4250,
          "old_api": null,
          "new_api": "tryLogCurrentException",
          "old_text": null,
          "new_text": "tryLogCurrentException(log, __PRETTY_FUNCTION__)",
          "old_line_content": "    }",
          "new_line_content": "                tryLogCurrentException(log, __PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 4256,
          "old_api": null,
          "new_api": "std::chrono::milliseconds(1000)",
          "old_text": null,
          "new_text": "std::chrono::milliseconds(1000)",
          "old_line_content": "void StorageReplicatedMergeTree::removePartsFromZooKeeper(zkutil::ZooKeeperPtr & zookeeper, const Strings & part_names,",
          "new_line_content": "            std::this_thread::sleep_for(std::chrono::milliseconds(1000));",
          "content_same": false
        },
        {
          "line": 4269,
          "old_api": null,
          "new_api": "cend",
          "old_text": null,
          "new_text": "part_names.cend()",
          "old_line_content": "            zkutil::Responses unused_responses;",
          "new_line_content": "    for (auto it = part_names.cbegin(); it != part_names.cend(); ++it)",
          "content_same": false
        },
        {
          "line": 4273,
          "old_api": null,
          "new_api": "std::next(it)",
          "old_text": null,
          "new_text": "std::next(it)",
          "old_line_content": "            if (code == ZooKeeperImpl::ZooKeeper::ZNONODE)",
          "new_line_content": "        auto it_next = std::next(it);",
          "content_same": false
        },
        {
          "line": 4274,
          "old_api": null,
          "new_api": "cend",
          "old_text": null,
          "new_text": "part_names.cend()",
          "old_line_content": "            {",
          "new_line_content": "        if (ops.size() >= zkutil::MULTI_BATCH_SIZE || it_next == part_names.cend())",
          "content_same": false
        },
        {
          "line": 4277,
          "old_api": null,
          "new_api": "tryMultiNoThrow",
          "old_text": null,
          "new_text": "zookeeper->tryMultiNoThrow(ops, unused_responses)",
          "old_line_content": "",
          "new_line_content": "            auto code = zookeeper->tryMultiNoThrow(ops, unused_responses);",
          "content_same": false
        },
        {
          "line": 4278,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "ops.clear()",
          "old_line_content": "                for (auto it_in_batch = it_first_node_in_batch; it_in_batch != it_next; ++it_in_batch)",
          "new_line_content": "            ops.clear();",
          "content_same": false
        },
        {
          "line": 4283,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"There are no some part nodes in ZooKeeper, will remove part nodes sequentially\")",
          "old_line_content": "",
          "new_line_content": "                LOG_DEBUG(log, \"There are no some part nodes in ZooKeeper, will remove part nodes sequentially\");",
          "content_same": false
        },
        {
          "line": 4289,
          "old_api": null,
          "new_api": "tryMultiNoThrow",
          "old_text": null,
          "new_text": "zookeeper->tryMultiNoThrow(cur_ops, unused_responses)",
          "old_line_content": "                    {",
          "new_line_content": "                    auto cur_code = zookeeper->tryMultiNoThrow(cur_ops, unused_responses);",
          "content_same": false
        },
        {
          "line": 4293,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"There is no part \" << *it_in_batch << \" in ZooKeeper, it was only in filesystem\")",
          "old_line_content": "                    {",
          "new_line_content": "                        LOG_DEBUG(log, \"There is no part \" << *it_in_batch << \" in ZooKeeper, it was only in filesystem\");",
          "content_same": false
        },
        {
          "line": 4295,
          "old_api": null,
          "new_api": "zkutil::isHardwareError(cur_code)",
          "old_text": null,
          "new_text": "zkutil::isHardwareError(cur_code)",
          "old_line_content": "                    }",
          "new_line_content": "                    else if (parts_should_be_retried && zkutil::isHardwareError(cur_code))",
          "content_same": false
        },
        {
          "line": 4297,
          "old_api": null,
          "new_api": "emplace",
          "old_text": null,
          "new_text": "parts_should_be_retried->emplace(*it_in_batch)",
          "old_line_content": "            }",
          "new_line_content": "                        parts_should_be_retried->emplace(*it_in_batch);",
          "content_same": false
        },
        {
          "line": 4308,
          "old_api": null,
          "new_api": "emplace",
          "old_text": null,
          "new_text": "parts_should_be_retried->emplace(*it_in_batch)",
          "old_line_content": "",
          "new_line_content": "                    parts_should_be_retried->emplace(*it_in_batch);",
          "content_same": false
        },
        {
          "line": 4312,
          "old_api": null,
          "new_api": "LOG_WARNING",
          "old_text": null,
          "new_text": "LOG_WARNING(log, \"There was a problem with deleting \" << (it_next - it_first_node_in_batch)\n                    << \" nodes from ZooKeeper: \" << ::zkutil::ZooKeeper::error2string(code))",
          "old_line_content": "}",
          "new_line_content": "                LOG_WARNING(log, \"There was a problem with deleting \" << (it_next - it_first_node_in_batch)",
          "content_same": false
        },
        {
          "line": 4313,
          "old_api": null,
          "new_api": "::zkutil::ZooKeeper::error2string(code)",
          "old_text": null,
          "new_text": "::zkutil::ZooKeeper::error2string(code)",
          "old_line_content": "",
          "new_line_content": "                    << \" nodes from ZooKeeper: \" << ::zkutil::ZooKeeper::error2string(code));",
          "content_same": false
        },
        {
          "line": 4327,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(zookeeper_path + \"/blocks doesn't exist\", ErrorCodes::NOT_FOUND_NODE)",
          "old_line_content": "        {",
          "new_line_content": "        throw Exception(zookeeper_path + \"/blocks doesn't exist\", ErrorCodes::NOT_FOUND_NODE);",
          "content_same": false
        },
        {
          "line": 4333,
          "old_api": null,
          "new_api": "startsWith",
          "old_text": null,
          "new_text": "startsWith(block_id, partition_prefix)",
          "old_line_content": "    zkutil::AsyncResponses<zkutil::RemoveResponse> to_delete_futures;",
          "new_line_content": "        if (startsWith(block_id, partition_prefix))",
          "content_same": false
        },
        {
          "line": 2286,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "parts.size()",
          "old_line_content": "    for (const auto & part : parts)",
          "new_line_content": "    exists_futures.reserve(parts.size());",
          "content_same": false
        },
        {
          "line": 2288,
          "old_api": null,
          "new_api": "asyncExists",
          "old_text": null,
          "new_text": "zookeeper->asyncExists(replica_path + \"/parts/\" + part->name)",
          "old_line_content": "        /// If there is no information about part in ZK, we will not merge it.",
          "new_line_content": "        exists_futures.emplace_back(zookeeper->asyncExists(replica_path + \"/parts/\" + part->name));",
          "content_same": false
        },
        {
          "line": 4336,
          "old_api": null,
          "new_api": "asyncTryGet",
          "old_text": null,
          "new_text": "zookeeper.asyncTryGet(path)",
          "old_line_content": "        const String & path = pair.first;",
          "new_line_content": "            get_futures.emplace_back(path, zookeeper.asyncTryGet(path));",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "parts.size()",
          "old_line_content": "            all_in_zk = false;",
          "new_line_content": "    for (size_t i = 0; i < parts.size(); ++i)",
          "content_same": false
        },
        {
          "line": 2294,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "exists_futures[i].get()",
          "old_line_content": "            {",
          "new_line_content": "        if (exists_futures[i].get().error == ZooKeeperImpl::ZooKeeper::ZNONODE)",
          "content_same": false
        },
        {
          "line": 2301,
          "old_api": null,
          "new_api": "LOG_WARNING",
          "old_text": null,
          "new_text": "LOG_WARNING(log, \"Part \" << part->name << \" (that was selected for merge)\"\n                    << \" with age \" << (time(nullptr) - part->modification_time)\n                    << \" seconds exists locally but not in ZooKeeper.\"\n                    << \" Won't do merge with that part and will check it.\")",
          "old_line_content": "        }",
          "new_line_content": "                LOG_WARNING(log, \"Part \" << part->name << \" (that was selected for merge)\"",
          "content_same": false
        },
        {
          "line": 2302,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(nullptr)",
          "old_line_content": "    }",
          "new_line_content": "                    << \" with age \" << (time(nullptr) - part->modification_time)",
          "content_same": false
        },
        {
          "line": 4351,
          "old_api": null,
          "new_api": "eof",
          "old_text": null,
          "new_text": "buf.eof()",
          "old_line_content": "        const String & path = pair.first;",
          "new_line_content": "        bool parsed = tryReadIntText(block_num, buf) && buf.eof();",
          "content_same": false
        },
        {
          "line": 2305,
          "old_api": null,
          "new_api": "enqueuePartForCheck",
          "old_text": null,
          "new_text": "enqueuePartForCheck(part->name)",
          "old_line_content": "",
          "new_line_content": "                enqueuePartForCheck(part->name);",
          "content_same": false
        },
        {
          "line": 4353,
          "old_api": null,
          "new_api": "asyncTryRemove",
          "old_text": null,
          "new_text": "zookeeper.asyncTryRemove(path)",
          "old_line_content": "        if (rc == ZooKeeperImpl::ZooKeeper::ZNOTEMPTY)",
          "new_line_content": "            to_delete_futures.emplace_back(path, zookeeper.asyncTryRemove(path));",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(nullptr)",
          "old_line_content": "",
          "new_line_content": "    entry.create_time = time(nullptr);",
          "content_same": false
        },
        {
          "line": 4366,
          "old_api": null,
          "new_api": "LOG_WARNING",
          "old_text": null,
          "new_text": "LOG_WARNING(log,\n                \"Error while deleting ZooKeeper path `\" << path << \"`: \" + zkutil::ZooKeeper::error2string(rc) << \", ignoring.\")",
          "old_line_content": "void StorageReplicatedMergeTree::replacePartitionFrom(const StoragePtr & source_table, const ASTPtr & partition, bool replace,",
          "new_line_content": "            LOG_WARNING(log,",
          "content_same": false
        },
        {
          "line": 4367,
          "old_api": null,
          "new_api": "zkutil::ZooKeeper::error2string(rc)",
          "old_text": null,
          "new_text": "zkutil::ZooKeeper::error2string(rc)",
          "old_line_content": "                                                      const Context & context)",
          "new_line_content": "                \"Error while deleting ZooKeeper path `\" << path << \"`: \" + zkutil::ZooKeeper::error2string(rc) << \", ignoring.\");",
          "content_same": false
        },
        {
          "line": 2321,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "entry.source_parts.push_back(part->name)",
          "old_line_content": "    {",
          "new_line_content": "        entry.source_parts.push_back(part->name);",
          "content_same": false
        },
        {
          "line": 2323,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "entry.toString()",
          "old_line_content": "        for (Int64 number = parts[i]->info.max_block + 1; number <= parts[i + 1]->info.min_block - 1; ++number)",
          "new_line_content": "    String path_created = zookeeper->create(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential);",
          "content_same": false
        },
        {
          "line": 2324,
          "old_api": null,
          "new_api": "find_last_of",
          "old_text": null,
          "new_text": "path_created.find_last_of('/')",
          "old_line_content": "        {",
          "new_line_content": "    entry.znode_name = path_created.substr(path_created.find_last_of('/') + 1);",
          "content_same": false
        },
        {
          "line": 2327,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "parts.size()",
          "old_line_content": "    }",
          "new_line_content": "    for (size_t i = 0; i + 1 < parts.size(); ++i)",
          "content_same": false
        },
        {
          "line": 4377,
          "old_api": null,
          "new_api": "lockStructure",
          "old_text": null,
          "new_text": "source_table->lockStructure(false, __PRETTY_FUNCTION__)",
          "old_line_content": "    MergeTreeData::DataPartsVector src_parts;",
          "new_line_content": "    auto lock2 = source_table->lockStructure(false, __PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": null,
          "new_api": "padIndex",
          "old_text": null,
          "new_text": "padIndex(number)",
          "old_line_content": "    return true;",
          "new_line_content": "            zookeeper->tryRemove(zookeeper_path + \"/block_numbers/\" + partition_id + \"/block-\" + padIndex(number));",
          "content_same": false
        },
        {
          "line": 4380,
          "old_api": null,
          "new_api": "checkStructureAndGetMergeTreeData",
          "old_text": null,
          "new_text": "data.checkStructureAndGetMergeTreeData(source_table)",
          "old_line_content": "    Strings part_checksums;",
          "new_line_content": "    MergeTreeData * src_data = data.checkStructureAndGetMergeTreeData(source_table);",
          "content_same": false
        },
        {
          "line": 4381,
          "old_api": null,
          "new_api": "getPartitionIDFromQuery",
          "old_text": null,
          "new_text": "data.getPartitionIDFromQuery(partition, context)",
          "old_line_content": "    std::vector<AbandonableLockInZooKeeper> abandonable_locks;",
          "new_line_content": "    String partition_id = data.getPartitionIDFromQuery(partition, context);",
          "content_same": false
        },
        {
          "line": 4390,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "src_all_parts.size()",
          "old_line_content": "    /// So, such case has special meaning, if drop_range contains only one block it means that nothing to drop.",
          "new_line_content": "    LOG_DEBUG(log, \"Cloning \" << src_all_parts.size() << \" parts\");",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "zookeeper->exists(replica_path + \"/parts/\" + part.name)",
          "old_line_content": "                << \" Won't mutate that part and will check it.\");",
          "new_line_content": "    if (!zookeeper->exists(replica_path + \"/parts/\" + part.name))",
          "content_same": false
        },
        {
          "line": 2350,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(nullptr)",
          "old_line_content": "        }",
          "new_line_content": "        if (part.modification_time + MAX_AGE_OF_LOCAL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < time(nullptr))",
          "content_same": false
        },
        {
          "line": 2352,
          "old_api": null,
          "new_api": "LOG_WARNING",
          "old_text": null,
          "new_text": "LOG_WARNING(log, \"Part \" << part.name << \" (that was selected for mutation)\"\n                << \" with age \" << (time(nullptr) - part.modification_time)\n                << \" seconds exists locally but not in ZooKeeper.\"\n                << \" Won't mutate that part and will check it.\")",
          "old_line_content": "        return false;",
          "new_line_content": "            LOG_WARNING(log, \"Part \" << part.name << \" (that was selected for mutation)\"",
          "content_same": false
        },
        {
          "line": 2353,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(nullptr)",
          "old_line_content": "    }",
          "new_line_content": "                << \" with age \" << (time(nullptr) - part.modification_time)",
          "content_same": false
        },
        {
          "line": 4402,
          "old_api": null,
          "new_api": "std::numeric_limits<decltype(drop_range.level)>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<decltype(drop_range.level)>::max()",
          "old_line_content": "        ///  could produce new merged part instead in place of just deleted parts.",
          "new_line_content": "    drop_range.level = std::numeric_limits<decltype(drop_range.level)>::max();",
          "content_same": false
        },
        {
          "line": 4400,
          "old_api": null,
          "new_api": "getNumber",
          "old_text": null,
          "new_text": "allocateBlockNumber(partition_id, zookeeper)->getNumber()",
          "old_line_content": "    {",
          "new_line_content": "    drop_range.max_block = allocateBlockNumber(partition_id, zookeeper)->getNumber();",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": null,
          "new_api": "enqueuePartForCheck",
          "old_text": null,
          "new_text": "enqueuePartForCheck(part.name)",
          "old_line_content": "    new_part_info.mutation = mutation_version;",
          "new_line_content": "            enqueuePartForCheck(part.name);",
          "content_same": false
        },
        {
          "line": 4404,
          "old_api": null,
          "new_api": "getPartNamePossiblyFake",
          "old_text": null,
          "new_text": "getPartNamePossiblyFake(data.format_version, drop_range)",
          "old_line_content": "        ///  but it is inconvenient for a user since he could actually use source table from this replica.",
          "new_line_content": "    String drop_range_fake_part_name = getPartNamePossiblyFake(data.format_version, drop_range);",
          "content_same": false
        },
        {
          "line": 4406,
          "old_api": null,
          "new_api": "getBlocksCount",
          "old_text": null,
          "new_text": "drop_range.getBlocksCount()",
          "old_line_content": "        /// It does not provides strong guarantees, but is suitable for intended use case (assume merges are quite rare).",
          "new_line_content": "    if (drop_range.getBlocksCount() > 1)",
          "content_same": false
        },
        {
          "line": 4417,
          "old_api": null,
          "new_api": "disableMergesInRange",
          "old_text": null,
          "new_text": "queue.disableMergesInRange(drop_range_fake_part_name)",
          "old_line_content": "        /// Assume that merges in the partiton are quite rare",
          "new_line_content": "            queue.disableMergesInRange(drop_range_fake_part_name);",
          "content_same": false
        },
        {
          "line": 2370,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "entry.source_parts.push_back(part.name)",
          "old_line_content": "",
          "new_line_content": "    entry.source_parts.push_back(part.name);",
          "content_same": false
        },
        {
          "line": 2372,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(nullptr)",
          "old_line_content": "void StorageReplicatedMergeTree::removePartFromZooKeeper(const String & part_name, zkutil::Requests & ops)",
          "new_line_content": "    entry.create_time = time(nullptr);",
          "content_same": false
        },
        {
          "line": 2374,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "entry.toString()",
          "old_line_content": "    String part_path = replica_path + \"/parts/\" + part_name;",
          "new_line_content": "    zookeeper->create(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential);",
          "content_same": false
        },
        {
          "line": 4428,
          "old_api": null,
          "new_api": "getTotalChecksumHex",
          "old_text": null,
          "new_text": "src_part->checksums.getTotalChecksumHex()",
          "old_line_content": "            continue;",
          "new_line_content": "        String hash_hex = src_part->checksums.getTotalChecksumHex();",
          "content_same": false
        },
        {
          "line": 2383,
          "old_api": null,
          "new_api": "zkutil::makeRemoveRequest(part_path + \"/checksums\", -1)",
          "old_text": null,
          "new_text": "zkutil::makeRemoveRequest(part_path + \"/checksums\", -1)",
          "old_line_content": "{",
          "new_line_content": "    ops.emplace_back(zkutil::makeRemoveRequest(part_path + \"/checksums\", -1));",
          "content_same": false
        },
        {
          "line": 2385,
          "old_api": null,
          "new_api": "zkutil::makeRemoveRequest(part_path, -1)",
          "old_text": null,
          "new_text": "zkutil::makeRemoveRequest(part_path, -1)",
          "old_line_content": "",
          "new_line_content": "    ops.emplace_back(zkutil::makeRemoveRequest(part_path, -1));",
          "content_same": false
        },
        {
          "line": 4434,
          "old_api": null,
          "new_api": "LOG_INFO",
          "old_text": null,
          "new_text": "LOG_INFO(log, \"Part \" << src_part->name << \" (hash \" << hash_hex << \") has been already attached\")",
          "old_line_content": "",
          "new_line_content": "            LOG_INFO(log, \"Part \" << src_part->name << \" (hash \" << hash_hex << \") has been already attached\");",
          "content_same": false
        },
        {
          "line": 2391,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "    log_entry->source_replica = \"\";",
          "new_line_content": "    auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 4440,
          "old_api": null,
          "new_api": "cloneAndLoadDataPart",
          "old_text": null,
          "new_text": "data.cloneAndLoadDataPart(src_part, TMP_PREFIX, dst_part_info)",
          "old_line_content": "    }",
          "new_line_content": "        auto dst_part = data.cloneAndLoadDataPart(src_part, TMP_PREFIX, dst_part_info);",
          "content_same": false
        },
        {
          "line": 4442,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "src_parts.emplace_back(src_part)",
          "old_line_content": "    ReplicatedMergeTreeLogEntryData entry;",
          "new_line_content": "        src_parts.emplace_back(src_part);",
          "content_same": false
        },
        {
          "line": 4443,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "dst_parts.emplace_back(dst_part)",
          "old_line_content": "    {",
          "new_line_content": "        dst_parts.emplace_back(dst_part);",
          "content_same": false
        },
        {
          "line": 4444,
          "old_api": null,
          "new_api": "std::move(*lock)",
          "old_text": null,
          "new_text": "std::move(*lock)",
          "old_line_content": "        entry.type = ReplicatedMergeTreeLogEntryData::REPLACE_RANGE;",
          "new_line_content": "        abandonable_locks.emplace_back(std::move(*lock));",
          "content_same": false
        },
        {
          "line": 2397,
          "old_api": null,
          "new_api": "tryGetPartCreateTime",
          "old_text": null,
          "new_text": "tryGetPartCreateTime(zookeeper, replica_path, part_name)",
          "old_line_content": "        zkutil::CreateMode::PersistentSequential));",
          "new_line_content": "    log_entry->create_time = tryGetPartCreateTime(zookeeper, replica_path, part_name);",
          "content_same": false
        },
        {
          "line": 4445,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "block_id_paths.emplace_back(block_id_path)",
          "old_line_content": "        entry.source_replica = replica_name;",
          "new_line_content": "        block_id_paths.emplace_back(block_id_path);",
          "content_same": false
        },
        {
          "line": 2402,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "zkutil::makeCreateRequest(\n        replica_path + \"/queue/queue-\", log_entry->toString(),\n        zkutil::CreateMode::PersistentSequential)",
          "old_line_content": "",
          "new_line_content": "    ops.emplace_back(zkutil::makeCreateRequest(",
          "content_same": false
        },
        {
          "line": 4453,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(nullptr)",
          "old_line_content": "        for (const auto & part : src_parts)",
          "new_line_content": "        entry.create_time = time(nullptr);",
          "content_same": false
        },
        {
          "line": 2406,
          "old_api": null,
          "new_api": "removePartFromZooKeeper",
          "old_text": null,
          "new_text": "removePartFromZooKeeper(part_name, ops)",
          "old_line_content": "}",
          "new_line_content": "    removePartFromZooKeeper(part_name, ops);",
          "content_same": false
        },
        {
          "line": 2408,
          "old_api": null,
          "new_api": "multi",
          "old_text": null,
          "new_text": "zookeeper->multi(ops)",
          "old_line_content": "",
          "new_line_content": "    auto results = zookeeper->multi(ops);",
          "content_same": false
        },
        {
          "line": 2410,
          "old_api": null,
          "new_api": "dynamic_cast<const zkutil::CreateResponse &>(*results[0])",
          "old_text": null,
          "new_text": "dynamic_cast<const zkutil::CreateResponse &>(*results[0])",
          "old_line_content": "{",
          "new_line_content": "    String path_created = dynamic_cast<const zkutil::CreateResponse &>(*results[0]).path_created;",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": null,
          "new_api": "find_last_of",
          "old_text": null,
          "new_text": "path_created.find_last_of('/')",
          "old_line_content": "    auto callback = [this]()",
          "new_line_content": "    log_entry->znode_name = path_created.substr(path_created.find_last_of('/') + 1);",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "queue.insert(zookeeper, log_entry)",
          "old_line_content": "    {",
          "new_line_content": "    queue.insert(zookeeper, log_entry);",
          "content_same": false
        },
        {
          "line": 4461,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "entry_replace.src_part_names.emplace_back(part->name)",
          "old_line_content": "",
          "new_line_content": "            entry_replace.src_part_names.emplace_back(part->name);",
          "content_same": false
        },
        {
          "line": 4465,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "entry_replace.part_names_checksums.emplace_back(checksum)",
          "old_line_content": "    /// Remove deduplication block_ids of replacing parts",
          "new_line_content": "            entry_replace.part_names_checksums.emplace_back(checksum);",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": null,
          "new_api": "CurrentMetrics::add(CurrentMetrics::LeaderReplica)",
          "old_text": null,
          "new_text": "CurrentMetrics::add(CurrentMetrics::LeaderReplica)",
          "old_line_content": "",
          "new_line_content": "        CurrentMetrics::add(CurrentMetrics::LeaderReplica);",
          "content_same": false
        },
        {
          "line": 2421,
          "old_api": null,
          "new_api": "LOG_INFO",
          "old_text": null,
          "new_text": "LOG_INFO(log, \"Became leader\")",
          "old_line_content": "    try",
          "new_line_content": "        LOG_INFO(log, \"Became leader\");",
          "content_same": false
        },
        {
          "line": 4470,
          "old_api": null,
          "new_api": "removePartProducingOpsInRange",
          "old_text": null,
          "new_text": "queue.removePartProducingOpsInRange(zookeeper, drop_range)",
          "old_line_content": "    zkutil::Responses op_results;",
          "new_line_content": "    queue.removePartProducingOpsInRange(zookeeper, drop_range);",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": null,
          "new_api": "schedule",
          "old_text": null,
          "new_text": "merge_selecting_task->schedule()",
          "old_line_content": "            zookeeper_path + \"/leader_election\",",
          "new_line_content": "        merge_selecting_task->schedule();",
          "content_same": false
        },
        {
          "line": 4474,
          "old_api": null,
          "new_api": "clearBlocksInPartition",
          "old_text": null,
          "new_text": "clearBlocksInPartition(*zookeeper, drop_range.partition_id, drop_range.max_block, drop_range.max_block)",
          "old_line_content": "        zkutil::Requests ops;",
          "new_line_content": "        clearBlocksInPartition(*zookeeper, drop_range.partition_id, drop_range.max_block, drop_range.max_block);",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": null,
          "new_api": "getSchedulePool",
          "old_text": null,
          "new_text": "std::make_shared<zkutil::LeaderElection>(\n            context.getSchedulePool(),\n            zookeeper_path + \"/leader_election\",\n            *current_zookeeper,    /// current_zookeeper lives for the lifetime of leader_election,\n                                   ///  since before changing `current_zookeeper`, `leader_election` object is destroyed in `partialShutdown` method.\n            callback,\n            replica_name)",
          "old_line_content": "    }",
          "new_line_content": "        leader_election = std::make_shared<zkutil::LeaderElection>(",
          "content_same": false
        },
        {
          "line": 2431,
          "old_api": null,
          "new_api": "getSchedulePool",
          "old_text": null,
          "new_text": "context.getSchedulePool()",
          "old_line_content": "    catch (...)",
          "new_line_content": "            context.getSchedulePool(),",
          "content_same": false
        },
        {
          "line": 4482,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "dst_parts.size()",
          "old_line_content": "                /// It is unnecessary to add parts to working set until we commit log entry",
          "new_line_content": "        for (size_t i = 0; i < dst_parts.size(); ++i)",
          "content_same": false
        },
        {
          "line": 4485,
          "old_api": null,
          "new_api": "getUnlockOps",
          "old_text": null,
          "new_text": "abandonable_locks[i].getUnlockOps(ops)",
          "old_line_content": "            }",
          "new_line_content": "            abandonable_locks[i].getUnlockOps(ops);",
          "content_same": false
        },
        {
          "line": 4487,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ops.size()",
          "old_line_content": "",
          "new_line_content": "            if (ops.size() > zkutil::MULTI_BATCH_SIZE)",
          "content_same": false
        },
        {
          "line": 4490,
          "old_api": null,
          "new_api": "multi",
          "old_text": null,
          "new_text": "zookeeper->multi(ops)",
          "old_line_content": "        MergeTreeData::Transaction transaction;",
          "new_line_content": "                zookeeper->multi(ops);",
          "content_same": false
        },
        {
          "line": 4491,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "ops.clear()",
          "old_line_content": "        {",
          "new_line_content": "                ops.clear();",
          "content_same": false
        },
        {
          "line": 4499,
          "old_api": null,
          "new_api": "lockParts",
          "old_text": null,
          "new_text": "data.lockParts()",
          "old_line_content": "",
          "new_line_content": "            auto data_parts_lock = data.lockParts();",
          "content_same": false
        },
        {
          "line": 2452,
          "old_api": null,
          "new_api": "shutdown",
          "old_text": null,
          "new_text": "leader_election->shutdown()",
          "old_line_content": "        is_leader = false;",
          "new_line_content": "    leader_election->shutdown();",
          "content_same": false
        },
        {
          "line": 4502,
          "old_api": null,
          "new_api": "renameTempPartAndReplace",
          "old_text": null,
          "new_text": "data.renameTempPartAndReplace(part, nullptr, &transaction, data_parts_lock)",
          "old_line_content": "",
          "new_line_content": "                data.renameTempPartAndReplace(part, nullptr, &transaction, data_parts_lock);",
          "content_same": false
        },
        {
          "line": 2456,
          "old_api": null,
          "new_api": "CurrentMetrics::sub(CurrentMetrics::LeaderReplica)",
          "old_text": null,
          "new_text": "CurrentMetrics::sub(CurrentMetrics::LeaderReplica)",
          "old_line_content": "    /// Delete the node in ZK only after we have stopped the merge_selecting_thread - so that only one",
          "new_line_content": "        CurrentMetrics::sub(CurrentMetrics::LeaderReplica);",
          "content_same": false
        },
        {
          "line": 2457,
          "old_api": null,
          "new_api": "LOG_INFO",
          "old_text": null,
          "new_text": "LOG_INFO(log, \"Stopped being leader\")",
          "old_line_content": "    /// replica assigns merges at any given time.",
          "new_line_content": "        LOG_INFO(log, \"Stopped being leader\");",
          "content_same": false
        },
        {
          "line": 2460,
          "old_api": null,
          "new_api": "deactivate",
          "old_text": null,
          "new_text": "merge_selecting_task->deactivate()",
          "old_line_content": "",
          "new_line_content": "        merge_selecting_task->deactivate();",
          "content_same": false
        },
        {
          "line": 4510,
          "old_api": null,
          "new_api": "commit",
          "old_text": null,
          "new_text": "transaction.commit(&data_parts_lock)",
          "old_line_content": "    catch (...)",
          "new_line_content": "            transaction.commit(&data_parts_lock);",
          "content_same": false
        },
        {
          "line": 4515,
          "old_api": null,
          "new_api": "elapsed",
          "old_text": null,
          "new_text": "watch.elapsed()",
          "old_line_content": "",
          "new_line_content": "        PartLog::addNewParts(this->context, dst_parts, watch.elapsed());",
          "content_same": false
        },
        {
          "line": 2471,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "    {",
          "new_line_content": "    auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2472,
          "old_api": null,
          "new_api": "getChildren",
          "old_text": null,
          "new_text": "zookeeper->getChildren(zookeeper_path + \"/replicas\")",
          "old_line_content": "        /// We don't interested in ourself.",
          "new_line_content": "    Strings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "content_same": false
        },
        {
          "line": 4519,
          "old_api": null,
          "new_api": "ExecutionStatus::fromCurrentException()",
          "old_text": null,
          "new_text": "ExecutionStatus::fromCurrentException()",
          "old_line_content": "    for (auto & lock : abandonable_locks)",
          "new_line_content": "        PartLog::addNewParts(this->context, dst_parts, watch.elapsed(), ExecutionStatus::fromCurrentException());",
          "content_same": false
        },
        {
          "line": 2475,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "replicas.end()",
          "old_line_content": "",
          "new_line_content": "    std::shuffle(replicas.begin(), replicas.end(), rng);",
          "content_same": false
        },
        {
          "line": 4524,
          "old_api": null,
          "new_api": "find_last_of",
          "old_text": null,
          "new_text": "log_znode_path.find_last_of('/')",
          "old_line_content": "",
          "new_line_content": "    entry.znode_name = log_znode_path.substr(log_znode_path.find_last_of('/') + 1);",
          "content_same": false
        },
        {
          "line": 2483,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/parts/\" + part_name)",
          "old_line_content": "    return {};",
          "new_line_content": "        if (zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/parts/\" + part_name) &&",
          "content_same": false
        },
        {
          "line": 2484,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")",
          "old_line_content": "}",
          "new_line_content": "            (!active || zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")))",
          "content_same": false
        },
        {
          "line": 4533,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "parts_to_remove.clear()",
          "old_line_content": "",
          "new_line_content": "    parts_to_remove.clear();",
          "content_same": false
        },
        {
          "line": 4534,
          "old_api": null,
          "new_api": "schedule",
          "old_text": null,
          "new_text": "cleanup_thread->schedule()",
          "old_line_content": "void StorageReplicatedMergeTree::getCommitPartOps(",
          "new_line_content": "    cleanup_thread->schedule();",
          "content_same": false
        },
        {
          "line": 4537,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context.getSettingsRef()",
          "old_line_content": "    const String & block_id_path) const",
          "new_line_content": "    if (context.getSettingsRef().replication_alter_partitions_sync > 1)",
          "content_same": false
        },
        {
          "line": 4538,
          "old_api": null,
          "new_api": "waitForAllReplicasToProcessLogEntry",
          "old_text": null,
          "new_text": "waitForAllReplicasToProcessLogEntry(entry)",
          "old_line_content": "{",
          "new_line_content": "        waitForAllReplicasToProcessLogEntry(entry);",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "    {",
          "new_line_content": "    auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2497,
          "old_api": null,
          "new_api": "getChildren",
          "old_text": null,
          "new_text": "zookeeper->getChildren(zookeeper_path + \"/replicas\")",
          "old_line_content": "        if (replica == replica_name)",
          "new_line_content": "    Strings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "content_same": false
        },
        {
          "line": 4548,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "block_id_path.empty()",
          "old_line_content": "                zkutil::CreateMode::Persistent));",
          "new_line_content": "    if (!block_id_path.empty())",
          "content_same": false
        },
        {
          "line": 4551,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "ops.emplace_back(\n            zkutil::makeCreateRequest(\n                block_id_path,\n                part_name,  /// We will be able to know original part number for duplicate blocks, if we want.\n                zkutil::CreateMode::Persistent))",
          "old_line_content": "    /// Information about the part, in the replica data.",
          "new_line_content": "        ops.emplace_back(",
          "content_same": false
        },
        {
          "line": 4552,
          "old_api": null,
          "new_api": "zkutil::makeCreateRequest(\n                block_id_path,\n                part_name,  /// We will be able to know original part number for duplicate blocks, if we want.\n                zkutil::CreateMode::Persistent)",
          "old_text": null,
          "new_text": "zkutil::makeCreateRequest(\n                block_id_path,\n                part_name,  /// We will be able to know original part number for duplicate blocks, if we want.\n                zkutil::CreateMode::Persistent)",
          "old_line_content": "",
          "new_line_content": "            zkutil::makeCreateRequest(",
          "content_same": false
        },
        {
          "line": 2507,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")",
          "old_line_content": "            if (part_on_replica == entry.new_part_name",
          "new_line_content": "        if (active && !zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\"))",
          "content_same": false
        },
        {
          "line": 2515,
          "old_api": null,
          "new_api": "MergeTreePartInfo::contains(part_on_replica, entry.new_part_name, data.format_version)",
          "old_text": null,
          "new_text": "MergeTreePartInfo::contains(part_on_replica, entry.new_part_name, data.format_version)",
          "old_line_content": "            }",
          "new_line_content": "                || MergeTreePartInfo::contains(part_on_replica, entry.new_part_name, data.format_version))",
          "content_same": false
        },
        {
          "line": 4563,
          "old_api": null,
          "new_api": "zkutil::makeCreateRequest(\n        replica_path + \"/parts/\" + part->name,\n        \"\",\n        zkutil::CreateMode::Persistent)",
          "old_text": null,
          "new_text": "zkutil::makeCreateRequest(\n        replica_path + \"/parts/\" + part->name,\n        \"\",\n        zkutil::CreateMode::Persistent)",
          "old_line_content": "        zkutil::CreateMode::Persistent));",
          "new_line_content": "    ops.emplace_back(zkutil::makeCreateRequest(",
          "content_same": false
        },
        {
          "line": 2517,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "largest_part_found.empty()",
          "old_line_content": "",
          "new_line_content": "                if (largest_part_found.empty()",
          "content_same": false
        },
        {
          "line": 4567,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "zkutil::makeCreateRequest(\n        replica_path + \"/parts/\" + part->name + \"/columns\",\n        part->columns.toString(),\n        zkutil::CreateMode::Persistent)",
          "old_line_content": "        zkutil::CreateMode::Persistent));",
          "new_line_content": "    ops.emplace_back(zkutil::makeCreateRequest(",
          "content_same": false
        },
        {
          "line": 4569,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "part->columns.toString()",
          "old_line_content": "",
          "new_line_content": "        part->columns.toString(),",
          "content_same": false
        },
        {
          "line": 4571,
          "old_api": null,
          "new_api": "zkutil::makeCreateRequest(\n        replica_path + \"/parts/\" + part->name + \"/checksums\",\n        getChecksumsForZooKeeper(part->checksums),\n        zkutil::CreateMode::Persistent)",
          "old_text": null,
          "new_text": "zkutil::makeCreateRequest(\n        replica_path + \"/parts/\" + part->name + \"/checksums\",\n        getChecksumsForZooKeeper(part->checksums),\n        zkutil::CreateMode::Persistent)",
          "old_line_content": "{",
          "new_line_content": "    ops.emplace_back(zkutil::makeCreateRequest(",
          "content_same": false
        },
        {
          "line": 2525,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "largest_part_found.empty()",
          "old_line_content": "                String reject_reason;",
          "new_line_content": "        if (!largest_part_found.empty())",
          "content_same": false
        },
        {
          "line": 4573,
          "old_api": null,
          "new_api": "getChecksumsForZooKeeper",
          "old_text": null,
          "new_text": "getChecksumsForZooKeeper(part->checksums)",
          "old_line_content": "",
          "new_line_content": "        getChecksumsForZooKeeper(part->checksums),",
          "content_same": false
        },
        {
          "line": 4579,
          "old_api": null,
          "new_api": "getInterserverIOAddress",
          "old_text": null,
          "new_text": "context.getInterserverIOAddress()",
          "old_line_content": "    res.table = table_name;",
          "new_line_content": "    auto host_port = context.getInterserverIOAddress();",
          "content_same": false
        },
        {
          "line": 2533,
          "old_api": null,
          "new_api": "addFuturePartIfNotCoveredByThem",
          "old_text": null,
          "new_text": "queue.addFuturePartIfNotCoveredByThem(largest_part_found, entry, reject_reason)",
          "old_line_content": "            {",
          "new_line_content": "                if (!queue.addFuturePartIfNotCoveredByThem(largest_part_found, entry, reject_reason))",
          "content_same": false
        },
        {
          "line": 2535,
          "old_api": null,
          "new_api": "LOG_INFO",
          "old_text": null,
          "new_text": "LOG_INFO(log, \"Will not fetch part \" << largest_part_found << \" covering \" << entry.new_part_name << \". \" << reject_reason)",
          "old_line_content": "            }",
          "new_line_content": "                    LOG_INFO(log, \"Will not fetch part \" << largest_part_found << \" covering \" << entry.new_part_name << \". \" << reject_reason);",
          "content_same": false
        },
        {
          "line": 4584,
          "old_api": null,
          "new_api": "getTCPPort",
          "old_text": null,
          "new_text": "context.getTCPPort()",
          "old_line_content": "{",
          "new_line_content": "    res.queries_port = context.getTCPPort();",
          "content_same": false
        },
        {
          "line": 4593,
          "old_api": null,
          "new_api": "cancel",
          "old_text": null,
          "new_text": "merger_mutator.actions_blocker.cancel()",
          "old_line_content": "",
          "new_line_content": "        return merger_mutator.actions_blocker.cancel();",
          "content_same": false
        },
        {
          "line": 4596,
          "old_api": null,
          "new_api": "cancel",
          "old_text": null,
          "new_text": "fetcher.blocker.cancel()",
          "old_line_content": "",
          "new_line_content": "        return fetcher.blocker.cancel();",
          "content_same": false
        },
        {
          "line": 4599,
          "old_api": null,
          "new_api": "ActionLock",
          "old_text": null,
          "new_text": "ActionLock()",
          "old_line_content": "",
          "new_line_content": "        return data_parts_exchange_endpoint_holder ? data_parts_exchange_endpoint_holder->getBlocker().cancel() : ActionLock();",
          "content_same": false
        },
        {
          "line": 4602,
          "old_api": null,
          "new_api": "cancel",
          "old_text": null,
          "new_text": "queue.actions_blocker.cancel()",
          "old_line_content": "{",
          "new_line_content": "        return queue.actions_blocker.cancel();",
          "content_same": false
        },
        {
          "line": 2555,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "    String largest_replica_found;",
          "new_line_content": "    auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2556,
          "old_api": null,
          "new_api": "getChildren",
          "old_text": null,
          "new_text": "zookeeper->getChildren(zookeeper_path + \"/replicas\")",
          "old_line_content": "",
          "new_line_content": "    Strings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "content_same": false
        },
        {
          "line": 2559,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "replicas.end()",
          "old_line_content": "        if (replica == replica_name)",
          "new_line_content": "    std::shuffle(replicas.begin(), replicas.end(), rng);",
          "content_same": false
        },
        {
          "line": 4611,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "    {",
          "new_line_content": "    queue.pullLogsToQueue(getZooKeeper());",
          "content_same": false
        },
        {
          "line": 4620,
          "old_api": null,
          "new_api": "store",
          "old_text": null,
          "new_text": "cond_reached.store(true, std::memory_order_relaxed)",
          "old_line_content": "    while (true)",
          "new_line_content": "            cond_reached.store(true, std::memory_order_relaxed);",
          "content_same": false
        },
        {
          "line": 2576,
          "old_api": null,
          "new_api": "MergeTreePartInfo::contains(part_on_replica, part_name, data.format_version)",
          "old_text": null,
          "new_text": "MergeTreePartInfo::contains(part_on_replica, part_name, data.format_version)",
          "old_line_content": "                }",
          "new_line_content": "                || MergeTreePartInfo::contains(part_on_replica, part_name, data.format_version))",
          "content_same": false
        },
        {
          "line": 4625,
          "old_api": null,
          "new_api": "std::move(callback)",
          "old_text": null,
          "new_text": "std::move(callback)",
          "old_line_content": "            break;",
          "new_line_content": "    auto handler = queue.addSubscriber(std::move(callback));",
          "content_same": false
        },
        {
          "line": 2578,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "largest_part_found.empty()",
          "old_line_content": "        }",
          "new_line_content": "                if (largest_part_found.empty()",
          "content_same": false
        },
        {
          "line": 2579,
          "old_api": null,
          "new_api": "MergeTreePartInfo::contains(part_on_replica, largest_part_found, data.format_version)",
          "old_text": null,
          "new_text": "MergeTreePartInfo::contains(part_on_replica, largest_part_found, data.format_version)",
          "old_line_content": "    }",
          "new_line_content": "                    || MergeTreePartInfo::contains(part_on_replica, largest_part_found, data.format_version))",
          "content_same": false
        },
        {
          "line": 4629,
          "old_api": null,
          "new_api": "tryWait",
          "old_text": null,
          "new_text": "event.tryWait(50)",
          "old_line_content": "",
          "new_line_content": "        event.tryWait(50);",
          "content_same": false
        },
        {
          "line": 4638,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Shutdown is called for table\", ErrorCodes::ABORTED)",
          "old_line_content": "bool StorageReplicatedMergeTree::dropPartsInPartition(",
          "new_line_content": "            throw Exception(\"Shutdown is called for table\", ErrorCodes::ABORTED);",
          "content_same": false
        },
        {
          "line": 4641,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "cond_reached.load(std::memory_order_relaxed)",
          "old_line_content": "    MergeTreePartInfo drop_range_info;",
          "new_line_content": "    return cond_reached.load(std::memory_order_relaxed);",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "    String value;",
          "new_line_content": "    auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 4649,
          "old_api": null,
          "new_api": "getFakePartCoveringAllPartsInPartition",
          "old_text": null,
          "new_text": "getFakePartCoveringAllPartsInPartition(partition_id, drop_range_info)",
          "old_line_content": "",
          "new_line_content": "    if (!getFakePartCoveringAllPartsInPartition(partition_id, drop_range_info))",
          "content_same": false
        },
        {
          "line": 4651,
          "old_api": null,
          "new_api": "LOG_INFO",
          "old_text": null,
          "new_text": "LOG_INFO(log, \"Will not drop partition \" << partition_id << \", it is empty.\")",
          "old_line_content": "      * Invariant: after the `DROP_RANGE` entry appears in the log, merge of deleted parts will not appear in the log.",
          "new_line_content": "        LOG_INFO(log, \"Will not drop partition \" << partition_id << \", it is empty.\");",
          "content_same": false
        },
        {
          "line": 4655,
          "old_api": null,
          "new_api": "clearBlocksInPartition",
          "old_text": null,
          "new_text": "clearBlocksInPartition(zookeeper, partition_id, drop_range_info.min_block, drop_range_info.max_block)",
          "old_line_content": "        std::lock_guard<std::mutex> merge_selecting_lock(merge_selecting_mutex);",
          "new_line_content": "    clearBlocksInPartition(zookeeper, partition_id, drop_range_info.min_block, drop_range_info.max_block);",
          "content_same": false
        },
        {
          "line": 2609,
          "old_api": null,
          "new_api": "tryGet",
          "old_text": null,
          "new_text": "zookeeper->tryGet(quorum_status_path, value, &stat)",
          "old_line_content": "            /// The quorum has already been achieved. Moreover, another INSERT with a quorum has already started.",
          "new_line_content": "    while (zookeeper->tryGet(quorum_status_path, value, &stat))",
          "content_same": false
        },
        {
          "line": 2612,
          "old_api": null,
          "new_api": "fromString",
          "old_text": null,
          "new_text": "quorum_entry.fromString(value)",
          "old_line_content": "",
          "new_line_content": "        quorum_entry.fromString(value);",
          "content_same": false
        },
        {
          "line": 4660,
          "old_api": null,
          "new_api": "getPartNamePossiblyFake",
          "old_text": null,
          "new_text": "getPartNamePossiblyFake(data.format_version, drop_range_info)",
          "old_line_content": "",
          "new_line_content": "    String drop_range_fake_part_name = getPartNamePossiblyFake(data.format_version, drop_range_info);",
          "content_same": false
        },
        {
          "line": 4663,
          "old_api": null,
          "new_api": "disableMergesInRange",
          "old_text": null,
          "new_text": "queue.disableMergesInRange(drop_range_fake_part_name)",
          "old_line_content": "    entry.source_replica = replica_name;",
          "new_line_content": "        queue.disableMergesInRange(drop_range_fake_part_name);",
          "content_same": false
        },
        {
          "line": 2620,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "quorum_entry.replicas.insert(replica_name)",
          "old_line_content": "            zkutil::Responses responses;",
          "new_line_content": "        quorum_entry.replicas.insert(replica_name);",
          "content_same": false
        },
        {
          "line": 4673,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(nullptr)",
          "old_line_content": "",
          "new_line_content": "    entry.create_time = time(nullptr);",
          "content_same": false
        },
        {
          "line": 4675,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "entry.toString()",
          "old_line_content": "",
          "new_line_content": "    String log_znode_path = zookeeper.create(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential);",
          "content_same": false
        },
        {
          "line": 2628,
          "old_api": null,
          "new_api": "zkutil::makeRemoveRequest(quorum_status_path, stat.version)",
          "old_text": null,
          "new_text": "zkutil::makeRemoveRequest(quorum_status_path, stat.version)",
          "old_line_content": "            }",
          "new_line_content": "            ops.emplace_back(zkutil::makeRemoveRequest(quorum_status_path, stat.version));",
          "content_same": false
        },
        {
          "line": 2629,
          "old_api": null,
          "new_api": "zkutil::makeSetRequest(quorum_last_part_path, part_name, -1)",
          "old_text": null,
          "new_text": "zkutil::makeSetRequest(quorum_last_part_path, part_name, -1)",
          "old_line_content": "            else if (code == ZooKeeperImpl::ZooKeeper::ZNONODE)",
          "new_line_content": "            ops.emplace_back(zkutil::makeSetRequest(quorum_last_part_path, part_name, -1));",
          "content_same": false
        },
        {
          "line": 2630,
          "old_api": null,
          "new_api": "tryMulti",
          "old_text": null,
          "new_text": "zookeeper->tryMulti(ops, responses)",
          "old_line_content": "            {",
          "new_line_content": "            auto code = zookeeper->tryMulti(ops, responses);",
          "content_same": false
        },
        {
          "line": 4676,
          "old_api": null,
          "new_api": "find_last_of",
          "old_text": null,
          "new_text": "log_znode_path.find_last_of('/')",
          "old_line_content": "",
          "new_line_content": "    entry.znode_name = log_znode_path.substr(log_znode_path.find_last_of('/') + 1);",
          "content_same": false
        },
        {
          "line": 2647,
          "old_api": null,
          "new_api": "zkutil::KeeperException(code, quorum_status_path)",
          "old_text": null,
          "new_text": "zkutil::KeeperException(code, quorum_status_path)",
          "old_line_content": "            if (code == ZooKeeperImpl::ZooKeeper::ZOK)",
          "new_line_content": "                throw zkutil::KeeperException(code, quorum_status_path);",
          "content_same": false
        },
        {
          "line": 2652,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "quorum_entry.toString()",
          "old_line_content": "            {",
          "new_line_content": "            auto code = zookeeper->trySet(quorum_status_path, quorum_entry.toString(), stat.version);",
          "content_same": false
        },
        {
          "line": 2669,
          "old_api": null,
          "new_api": "zkutil::KeeperException(code, quorum_status_path)",
          "old_text": null,
          "new_text": "zkutil::KeeperException(code, quorum_status_path)",
          "old_line_content": "{",
          "new_line_content": "                throw zkutil::KeeperException(code, quorum_status_path);",
          "content_same": false
        },
        {
          "line": 2677,
          "old_api": null,
          "new_api": "getPartIfExists",
          "old_text": null,
          "new_text": "data.getPartIfExists(part_name, {MergeTreeDataPart::State::Outdated, MergeTreeDataPart::State::Deleting})",
          "old_line_content": "",
          "new_line_content": "    if (auto part = data.getPartIfExists(part_name, {MergeTreeDataPart::State::Outdated, MergeTreeDataPart::State::Deleting}))",
          "content_same": false
        },
        {
          "line": 2679,
          "old_api": null,
          "new_api": "getNameWithState",
          "old_text": null,
          "new_text": "part->getNameWithState()",
          "old_line_content": "        std::lock_guard<std::mutex> lock(currently_fetching_parts_mutex);",
          "new_line_content": "        LOG_DEBUG(log, \"Part \" << part->getNameWithState() << \" should be deleted after previous attempt before fetch\");",
          "content_same": false
        },
        {
          "line": 2681,
          "old_api": null,
          "new_api": "schedule",
          "old_text": null,
          "new_text": "cleanup_thread->schedule()",
          "old_line_content": "        {",
          "new_line_content": "        cleanup_thread->schedule();",
          "content_same": false
        },
        {
          "line": 2689,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Part \" << part_name << \" is already fetching right now\")",
          "old_line_content": "        std::lock_guard<std::mutex> lock(currently_fetching_parts_mutex);",
          "new_line_content": "            LOG_DEBUG(log, \"Part \" << part_name << \" is already fetching right now\");",
          "content_same": false
        },
        {
          "line": 2694,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "SCOPE_EXIT\n    ({\n        std::lock_guard<std::mutex> lock(currently_fetching_parts_mutex);\n        currently_fetching_parts.erase(part_name);\n    })",
          "old_line_content": "",
          "new_line_content": "    SCOPE_EXIT",
          "content_same": false
        },
        {
          "line": 2700,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Fetching part \" << part_name << \" from \" << replica_path)",
          "old_line_content": "    Stopwatch stopwatch;",
          "new_line_content": "    LOG_DEBUG(log, \"Fetching part \" << part_name << \" from \" << replica_path);",
          "content_same": false
        },
        {
          "line": 2704,
          "old_api": null,
          "new_api": "lockStructure",
          "old_text": null,
          "new_text": "lockStructure(true, __PRETTY_FUNCTION__)",
          "old_line_content": "    auto write_part_log = [&] (const ExecutionStatus & execution_status)",
          "new_line_content": "        table_lock = lockStructure(true, __PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 2713,
          "old_api": null,
          "new_api": "elapsed",
          "old_text": null,
          "new_text": "writePartLog(\n            PartLogElement::DOWNLOAD_PART, execution_status, stopwatch.elapsed(),\n            part_name, part, replaced_parts, nullptr)",
          "old_line_content": "",
          "new_line_content": "        writePartLog(",
          "content_same": false
        },
        {
          "line": 2714,
          "old_api": null,
          "new_api": "elapsed",
          "old_text": null,
          "new_text": "stopwatch.elapsed()",
          "old_line_content": "    try",
          "new_line_content": "            PartLogElement::DOWNLOAD_PART, execution_status, stopwatch.elapsed(),",
          "content_same": false
        },
        {
          "line": 2718,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "getZooKeeper()->get(replica_path + \"/host\")",
          "old_line_content": "        if (!to_detached)",
          "new_line_content": "    ReplicatedMergeTreeAddress address(getZooKeeper()->get(replica_path + \"/host\"));",
          "content_same": false
        },
        {
          "line": 2719,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context.getSettingsRef()",
          "old_line_content": "        {",
          "new_line_content": "    auto timeouts = ConnectionTimeouts::getHTTPTimeouts(context.getSettingsRef());",
          "content_same": false
        },
        {
          "line": 2723,
          "old_api": null,
          "new_api": "fetchPart",
          "old_text": null,
          "new_text": "fetcher.fetchPart(part_name, replica_path, address.host, address.replication_port, timeouts, to_detached)",
          "old_line_content": "            /** NOTE",
          "new_line_content": "        part = fetcher.fetchPart(part_name, replica_path, address.host, address.replication_port, timeouts, to_detached);",
          "content_same": false
        },
        {
          "line": 2735,
          "old_api": null,
          "new_api": "checkPartChecksumsAndCommit",
          "old_text": null,
          "new_text": "checkPartChecksumsAndCommit(transaction, part)",
          "old_line_content": "",
          "new_line_content": "            replaced_parts = checkPartChecksumsAndCommit(transaction, part);",
          "content_same": false
        },
        {
          "line": 2743,
          "old_api": null,
          "new_api": "schedule",
          "old_text": null,
          "new_text": "merge_selecting_task->schedule()",
          "old_line_content": "",
          "new_line_content": "            merge_selecting_task->schedule();",
          "content_same": false
        },
        {
          "line": 2747,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Part \" << replaced_part->name << \" is rendered obsolete by fetching part \" << part_name)",
          "old_line_content": "        {",
          "new_line_content": "                LOG_DEBUG(log, \"Part \" << replaced_part->name << \" is rendered obsolete by fetching part \" << part_name);",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": null,
          "new_api": "write_part_log",
          "old_text": null,
          "new_text": "write_part_log({})",
          "old_line_content": "    catch (...)",
          "new_line_content": "            write_part_log({});",
          "content_same": false
        },
        {
          "line": 2755,
          "old_api": null,
          "new_api": "renameTo",
          "old_text": null,
          "new_text": "part->renameTo(\"detached/\" + part_name)",
          "old_line_content": "",
          "new_line_content": "            part->renameTo(\"detached/\" + part_name);",
          "content_same": false
        },
        {
          "line": 2766,
          "old_api": null,
          "new_api": "ProfileEvents::increment(ProfileEvents::ReplicatedPartFetches)",
          "old_text": null,
          "new_text": "ProfileEvents::increment(ProfileEvents::ReplicatedPartFetches)",
          "old_line_content": "void StorageReplicatedMergeTree::startup()",
          "new_line_content": "    ProfileEvents::increment(ProfileEvents::ReplicatedPartFetches);",
          "content_same": false
        },
        {
          "line": 2768,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Fetched part \" << part_name << \" from \" << replica_path << (to_detached ? \" (to 'detached' directory)\" : \"\"))",
          "old_line_content": "    if (is_readonly)",
          "new_line_content": "    LOG_DEBUG(log, \"Fetched part \" << part_name << \" from \" << replica_path << (to_detached ? \" (to 'detached' directory)\" : \"\"));",
          "content_same": false
        },
        {
          "line": 2778,
          "old_api": null,
          "new_api": "initialize",
          "old_text": null,
          "new_text": "queue.initialize(\n        zookeeper_path, replica_path,\n        database_name + \".\" + table_name + \" (ReplicatedMergeTreeQueue)\",\n        data.getDataParts(), current_zookeeper)",
          "old_line_content": "    /// NOTE: not updating last_queue_update_start_time because it must contain the time when",
          "new_line_content": "    queue.initialize(",
          "content_same": false
        },
        {
          "line": 2788,
          "old_api": null,
          "new_api": "shared_from_this",
          "old_text": null,
          "new_text": "shared_from_this()",
          "old_line_content": "",
          "new_line_content": "    StoragePtr ptr = shared_from_this();",
          "content_same": false
        },
        {
          "line": 2789,
          "old_api": null,
          "new_api": "std::make_shared<DataPartsExchange::Service>(data, ptr)",
          "old_text": null,
          "new_text": "std::make_shared<DataPartsExchange::Service>(data, ptr)",
          "old_line_content": "    /// Wait while restarting_thread initializes LeaderElection (and so on) or makes first attmept to do it",
          "new_line_content": "    InterserverIOEndpointPtr data_parts_exchange_endpoint = std::make_shared<DataPartsExchange::Service>(data, ptr);",
          "content_same": false
        },
        {
          "line": 2791,
          "old_api": null,
          "new_api": "getInterserverIOHandler",
          "old_text": null,
          "new_text": "context.getInterserverIOHandler()",
          "old_line_content": "}",
          "new_line_content": "        data_parts_exchange_endpoint->getId(replica_path), data_parts_exchange_endpoint, context.getInterserverIOHandler());",
          "content_same": false
        },
        {
          "line": 2794,
          "old_api": null,
          "new_api": "std::make_unique<ReplicatedMergeTreeRestartingThread>(*this)",
          "old_text": null,
          "new_text": "std::make_unique<ReplicatedMergeTreeRestartingThread>(*this)",
          "old_line_content": "void StorageReplicatedMergeTree::shutdown()",
          "new_line_content": "    restarting_thread = std::make_unique<ReplicatedMergeTreeRestartingThread>(*this);",
          "content_same": false
        },
        {
          "line": 2797,
          "old_api": null,
          "new_api": "wait",
          "old_text": null,
          "new_text": "startup_event.wait()",
          "old_line_content": "    {",
          "new_line_content": "    startup_event.wait();",
          "content_same": false
        },
        {
          "line": 2805,
          "old_api": null,
          "new_api": "stop",
          "old_text": null,
          "new_text": "restarting_thread->stop()",
          "old_line_content": "        data_parts_exchange_endpoint_holder = nullptr;",
          "new_line_content": "        restarting_thread->stop();",
          "content_same": false
        },
        {
          "line": 2806,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "restarting_thread.reset()",
          "old_line_content": "    }",
          "new_line_content": "        restarting_thread.reset();",
          "content_same": false
        },
        {
          "line": 2811,
          "old_api": null,
          "new_api": "cancelForever",
          "old_text": null,
          "new_text": "data_parts_exchange_endpoint_holder->getBlocker().cancelForever()",
          "old_line_content": "",
          "new_line_content": "        data_parts_exchange_endpoint_holder->getBlocker().cancelForever();",
          "content_same": false
        },
        {
          "line": 2815,
          "old_api": null,
          "new_api": "cancelForever",
          "old_text": null,
          "new_text": "fetcher.blocker.cancelForever()",
          "old_line_content": "    {",
          "new_line_content": "    fetcher.blocker.cancelForever();",
          "content_same": false
        },
        {
          "line": 2823,
          "old_api": null,
          "new_api": "shutdown",
          "old_text": null,
          "new_text": "shutdown()",
          "old_line_content": "",
          "new_line_content": "        shutdown();",
          "content_same": false
        },
        {
          "line": 2827,
          "old_api": null,
          "new_api": "tryLogCurrentException",
          "old_text": null,
          "new_text": "tryLogCurrentException(__PRETTY_FUNCTION__)",
          "old_line_content": "    const SelectQueryInfo & query_info,",
          "new_line_content": "        tryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 2840,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context.getSettingsRef()",
          "old_line_content": "    Int64 max_block_number_to_read = 0;",
          "new_line_content": "    const Settings & settings = context.getSettingsRef();",
          "content_same": false
        },
        {
          "line": 2850,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "                \" Send query to another replica or disable 'select_sequential_consistency' setting.\", ErrorCodes::REPLICA_IS_NOT_IN_QUORUM);",
          "new_line_content": "        auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2853,
          "old_api": null,
          "new_api": "tryGet",
          "old_text": null,
          "new_text": "zookeeper->tryGet(zookeeper_path + \"/quorum/last_part\", last_part)",
          "old_line_content": "        {",
          "new_line_content": "        zookeeper->tryGet(zookeeper_path + \"/quorum/last_part\", last_part);",
          "content_same": false
        },
        {
          "line": 2856,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Replica doesn't have part \" + last_part + \" which was successfully written to quorum of other replicas.\"\n                \" Send query to another replica or disable 'select_sequential_consistency' setting.\", ErrorCodes::REPLICA_IS_NOT_IN_QUORUM)",
          "old_line_content": "            {",
          "new_line_content": "            throw Exception(\"Replica doesn't have part \" + last_part + \" which was successfully written to quorum of other replicas.\"",
          "content_same": false
        },
        {
          "line": 2862,
          "old_api": null,
          "new_api": "tryGet",
          "old_text": null,
          "new_text": "zookeeper->tryGet(zookeeper_path + \"/quorum/status\", quorum_str)",
          "old_line_content": "        }",
          "new_line_content": "            if (zookeeper->tryGet(zookeeper_path + \"/quorum/status\", quorum_str))",
          "content_same": false
        },
        {
          "line": 2866,
          "old_api": null,
          "new_api": "MergeTreePartInfo::fromPartName(quorum_entry.part_name, data.format_version)",
          "old_text": null,
          "new_text": "MergeTreePartInfo::fromPartName(quorum_entry.part_name, data.format_version)",
          "old_line_content": "            max_block_number_to_read = part_info.max_block;",
          "new_line_content": "                auto part_info = MergeTreePartInfo::fromPartName(quorum_entry.part_name, data.format_version);",
          "content_same": false
        },
        {
          "line": 2872,
          "old_api": null,
          "new_api": "MergeTreePartInfo::fromPartName(last_part, data.format_version)",
          "old_text": null,
          "new_text": "MergeTreePartInfo::fromPartName(last_part, data.format_version)",
          "old_line_content": "}",
          "new_line_content": "            auto part_info = MergeTreePartInfo::fromPartName(last_part, data.format_version);",
          "content_same": false
        },
        {
          "line": 2877,
          "old_api": null,
          "new_api": "read",
          "old_text": null,
          "new_text": "reader.read(\n        column_names, query_info, context, processed_stage, max_block_size, num_streams, max_block_number_to_read)",
          "old_line_content": "    if (is_readonly)",
          "new_line_content": "    return reader.read(",
          "content_same": false
        },
        {
          "line": 2885,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Table is in readonly mode\", ErrorCodes::TABLE_IS_READ_ONLY)",
          "old_line_content": "",
          "new_line_content": "        throw Exception(\"Table is in readonly mode\", ErrorCodes::TABLE_IS_READ_ONLY);",
          "content_same": false
        },
        {
          "line": 2891,
          "old_api": null,
          "new_api": "assertNotReadonly",
          "old_text": null,
          "new_text": "assertNotReadonly()",
          "old_line_content": "",
          "new_line_content": "    assertNotReadonly();",
          "content_same": false
        },
        {
          "line": 2896,
          "old_api": null,
          "new_api": "totalMilliseconds",
          "old_text": null,
          "new_text": "settings.insert_quorum_timeout.totalMilliseconds()",
          "old_line_content": "",
          "new_line_content": "        settings.insert_quorum, settings.insert_quorum_timeout.totalMilliseconds(), deduplicate);",
          "content_same": false
        },
        {
          "line": 2902,
          "old_api": null,
          "new_api": "assertNotReadonly",
          "old_text": null,
          "new_text": "assertNotReadonly()",
          "old_line_content": "",
          "new_line_content": "    assertNotReadonly();",
          "content_same": false
        },
        {
          "line": 2906,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context.getSettingsRef()",
          "old_line_content": "        /// (merge_selecting_thread or OPTIMIZE queries) could assign new merges.",
          "new_line_content": "        sendRequestToLeaderReplica(query, context.getSettingsRef());",
          "content_same": false
        },
        {
          "line": 2922,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "        }",
          "new_line_content": "        auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2923,
          "old_api": null,
          "new_api": "getMergePredicate",
          "old_text": null,
          "new_text": "queue.getMergePredicate(zookeeper)",
          "old_line_content": "        else",
          "new_line_content": "        ReplicatedMergeTreeMergePredicate can_merge = queue.getMergePredicate(zookeeper);",
          "content_same": false
        },
        {
          "line": 2927,
          "old_api": null,
          "new_api": "selectPartsToMerge",
          "old_text": null,
          "new_text": "merger_mutator.selectPartsToMerge(\n                future_merged_part, true, data.settings.max_bytes_to_merge_at_max_space_in_pool, can_merge, &disable_reason)",
          "old_line_content": "                future_merged_part, disk_space, can_merge, partition_id, final, &disable_reason);",
          "new_line_content": "            selected = merger_mutator.selectPartsToMerge(",
          "content_same": false
        },
        {
          "line": 2946,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "disable_reason.empty()",
          "old_line_content": "",
          "new_line_content": "            LOG_INFO(log, \"Cannot select parts for optimization\" + (disable_reason.empty() ? \"\" : \": \" + disable_reason));",
          "content_same": false
        },
        {
          "line": 2947,
          "old_api": null,
          "new_api": "handle_noop",
          "old_text": null,
          "new_text": "handle_noop(disable_reason)",
          "old_line_content": "    /// TODO: Bad setting name for such purpose",
          "new_line_content": "            return handle_noop(disable_reason);",
          "content_same": false
        },
        {
          "line": 2950,
          "old_api": null,
          "new_api": "createLogEntryToMergeParts",
          "old_text": null,
          "new_text": "createLogEntryToMergeParts(zookeeper, future_merged_part.parts, future_merged_part.name, deduplicate, &merge_entry)",
          "old_line_content": "",
          "new_line_content": "        if (!createLogEntryToMergeParts(zookeeper, future_merged_part.parts, future_merged_part.name, deduplicate, &merge_entry))",
          "content_same": false
        },
        {
          "line": 2951,
          "old_api": null,
          "new_api": "handle_noop",
          "old_text": null,
          "new_text": "handle_noop(\"Can't create merge queue node in ZooKeeper\")",
          "old_line_content": "    return true;",
          "new_line_content": "            return handle_noop(\"Can't create merge queue node in ZooKeeper\");",
          "content_same": false
        },
        {
          "line": 2955,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context.getSettingsRef()",
          "old_line_content": "void StorageReplicatedMergeTree::alter(const AlterCommands & params,",
          "new_line_content": "    if (context.getSettingsRef().replication_alter_partitions_sync != 0)",
          "content_same": false
        },
        {
          "line": 2956,
          "old_api": null,
          "new_api": "waitForAllReplicasToProcessLogEntry",
          "old_text": null,
          "new_text": "waitForAllReplicasToProcessLogEntry(merge_entry)",
          "old_line_content": "    const String & /*database_name*/, const String & /*table_name*/, const Context & context)",
          "new_line_content": "        waitForAllReplicasToProcessLogEntry(merge_entry);",
          "content_same": false
        },
        {
          "line": 2965,
          "old_api": null,
          "new_api": "assertNotReadonly",
          "old_text": null,
          "new_text": "assertNotReadonly()",
          "old_line_content": "",
          "new_line_content": "    assertNotReadonly();",
          "content_same": false
        },
        {
          "line": 2967,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Doing ALTER\")",
          "old_line_content": "        /// Just to read current structure. Alter will be done in separate thread.",
          "new_line_content": "    LOG_DEBUG(log, \"Doing ALTER\");",
          "content_same": false
        },
        {
          "line": 2975,
          "old_api": null,
          "new_api": "lockStructure",
          "old_text": null,
          "new_text": "lockStructure(false, __PRETTY_FUNCTION__)",
          "old_line_content": "        for (const AlterCommand & param : params)",
          "new_line_content": "        auto table_lock = lockStructure(false, __PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 2978,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Can't ALTER readonly table\", ErrorCodes::TABLE_IS_READ_ONLY)",
          "old_line_content": "",
          "new_line_content": "            throw Exception(\"Can't ALTER readonly table\", ErrorCodes::TABLE_IS_READ_ONLY);",
          "content_same": false
        },
        {
          "line": 2984,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Modification of primary key is not supported for replicated tables\", ErrorCodes::NOT_IMPLEMENTED)",
          "old_line_content": "        /// Do ALTER.",
          "new_line_content": "                throw Exception(\"Modification of primary key is not supported for replicated tables\", ErrorCodes::NOT_IMPLEMENTED);",
          "content_same": false
        },
        {
          "line": 2986,
          "old_api": null,
          "new_api": "getColumns",
          "old_text": null,
          "new_text": "data.getColumns()",
          "old_line_content": "",
          "new_line_content": "        ColumnsDescription new_columns = data.getColumns();",
          "content_same": false
        },
        {
          "line": 2987,
          "old_api": null,
          "new_api": "apply",
          "old_text": null,
          "new_text": "params.apply(new_columns)",
          "old_line_content": "        new_columns_version = stat.version;",
          "new_line_content": "        params.apply(new_columns);",
          "content_same": false
        },
        {
          "line": 2989,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "new_columns.toString()",
          "old_line_content": "",
          "new_line_content": "        new_columns_str = new_columns.toString();",
          "content_same": false
        },
        {
          "line": 2992,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "getZooKeeper()->set(zookeeper_path + \"/columns\", new_columns_str, -1, &stat)",
          "old_line_content": "    /// Wait until all replicas will apply ALTER.",
          "new_line_content": "        getZooKeeper()->set(zookeeper_path + \"/columns\", new_columns_str, -1, &stat);",
          "content_same": false
        },
        {
          "line": 2997,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Updated columns in ZooKeeper. Waiting for replicas to apply changes.\")",
          "old_line_content": "",
          "new_line_content": "    LOG_DEBUG(log, \"Updated columns in ZooKeeper. Waiting for replicas to apply changes.\");",
          "content_same": false
        },
        {
          "line": 3002,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "getZooKeeper()->exists(zookeeper_path + \"/columns\", &stat, alter_query_event)",
          "old_line_content": "        return;",
          "new_line_content": "    if (!getZooKeeper()->exists(zookeeper_path + \"/columns\", &stat, alter_query_event))",
          "content_same": false
        },
        {
          "line": 3003,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(zookeeper_path + \"/columns doesn't exist\", ErrorCodes::NOT_FOUND_NODE)",
          "old_line_content": "    }",
          "new_line_content": "        throw Exception(zookeeper_path + \"/columns doesn't exist\", ErrorCodes::NOT_FOUND_NODE);",
          "content_same": false
        },
        {
          "line": 3007,
          "old_api": null,
          "new_api": "LOG_WARNING",
          "old_text": null,
          "new_text": "LOG_WARNING(log, zookeeper_path + \"/columns changed before this ALTER finished; \"\n            \"overlapping ALTER-s are fine but use caution with nontransitive changes\")",
          "old_line_content": "    std::set<String> inactive_replicas;",
          "new_line_content": "        LOG_WARNING(log, zookeeper_path + \"/columns changed before this ALTER finished; \"",
          "content_same": false
        },
        {
          "line": 3012,
          "old_api": null,
          "new_api": "getChildren",
          "old_text": null,
          "new_text": "getZooKeeper()->getChildren(zookeeper_path + \"/replicas\")",
          "old_line_content": "    for (const String & replica : replicas)",
          "new_line_content": "    Strings replicas = getZooKeeper()->getChildren(zookeeper_path + \"/replicas\");",
          "content_same": false
        },
        {
          "line": 3017,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context.getSettingsRef()",
          "old_line_content": "        {",
          "new_line_content": "    time_t replication_alter_columns_timeout = context.getSettingsRef().replication_alter_columns_timeout;",
          "content_same": false
        },
        {
          "line": 3026,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "getZooKeeper()->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")",
          "old_line_content": "            }",
          "new_line_content": "            if (!getZooKeeper()->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\"))",
          "content_same": false
        },
        {
          "line": 3028,
          "old_api": null,
          "new_api": "LOG_WARNING",
          "old_text": null,
          "new_text": "LOG_WARNING(log, \"Replica \" << replica << \" is not active during ALTER query.\"\n                    \" ALTER will be done asynchronously when replica becomes active.\")",
          "old_line_content": "            String replica_columns_str;",
          "new_line_content": "                LOG_WARNING(log, \"Replica \" << replica << \" is not active during ALTER query.\"",
          "content_same": false
        },
        {
          "line": 3038,
          "old_api": null,
          "new_api": "tryGet",
          "old_text": null,
          "new_text": "getZooKeeper()->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/columns\", replica_columns_str, &stat)",
          "old_line_content": "",
          "new_line_content": "            if (!getZooKeeper()->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/columns\", replica_columns_str, &stat))",
          "content_same": false
        },
        {
          "line": 3040,
          "old_api": null,
          "new_api": "LOG_WARNING",
          "old_text": null,
          "new_text": "LOG_WARNING(log, replica << \" was removed\")",
          "old_line_content": "            if (replica_columns_str == new_columns_str)",
          "new_line_content": "                LOG_WARNING(log, replica << \" was removed\");",
          "content_same": false
        },
        {
          "line": 3050,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "getZooKeeper()->exists(zookeeper_path + \"/columns\", &stat)",
          "old_line_content": "                return;",
          "new_line_content": "            if (!getZooKeeper()->exists(zookeeper_path + \"/columns\", &stat))",
          "content_same": false
        },
        {
          "line": 3051,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(zookeeper_path + \"/columns doesn't exist\", ErrorCodes::NOT_FOUND_NODE)",
          "old_line_content": "            }",
          "new_line_content": "                throw Exception(zookeeper_path + \"/columns doesn't exist\", ErrorCodes::NOT_FOUND_NODE);",
          "content_same": false
        },
        {
          "line": 3060,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "getZooKeeper()->exists(zookeeper_path + \"/replicas/\" + replica + \"/columns\", &stat, alter_query_event)",
          "old_line_content": "                continue;",
          "new_line_content": "            if (!getZooKeeper()->exists(zookeeper_path + \"/replicas/\" + replica + \"/columns\", &stat, alter_query_event))",
          "content_same": false
        },
        {
          "line": 3062,
          "old_api": null,
          "new_api": "LOG_WARNING",
          "old_text": null,
          "new_text": "LOG_WARNING(log, replica << \" was removed\")",
          "old_line_content": "            if (!replication_alter_columns_timeout)",
          "new_line_content": "                LOG_WARNING(log, replica << \" was removed\");",
          "content_same": false
        },
        {
          "line": 3071,
          "old_api": null,
          "new_api": "wait",
          "old_text": null,
          "new_text": "alter_query_event->wait()",
          "old_line_content": "            else",
          "new_line_content": "                alter_query_event->wait();",
          "content_same": false
        },
        {
          "line": 3074,
          "old_api": null,
          "new_api": "tryWait",
          "old_text": null,
          "new_text": "alter_query_event->tryWait(replication_alter_columns_timeout * 1000)",
          "old_line_content": "                    \" ALTER will be done asynchronously.\");",
          "new_line_content": "            else if (alter_query_event->tryWait(replication_alter_columns_timeout * 1000))",
          "content_same": false
        },
        {
          "line": 3080,
          "old_api": null,
          "new_api": "LOG_WARNING",
          "old_text": null,
          "new_text": "LOG_WARNING(log, \"Timeout when waiting for replica \" << replica << \" to apply ALTER.\"\n                    \" ALTER will be done asynchronously.\")",
          "old_line_content": "",
          "new_line_content": "                LOG_WARNING(log, \"Timeout when waiting for replica \" << replica << \" to apply ALTER.\"",
          "content_same": false
        },
        {
          "line": 3083,
          "old_api": null,
          "new_api": "emplace",
          "old_text": null,
          "new_text": "timed_out_replicas.emplace(replica)",
          "old_line_content": "                ErrorCodes::UNFINISHED);",
          "new_line_content": "                timed_out_replicas.emplace(replica);",
          "content_same": false
        },
        {
          "line": 3089,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Alter is not finished because table shutdown was called. Alter will be done after table restart.\",\n                ErrorCodes::UNFINISHED)",
          "old_line_content": "",
          "new_line_content": "            throw Exception(\"Alter is not finished because table shutdown was called. Alter will be done after table restart.\",",
          "content_same": false
        },
        {
          "line": 3092,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "timed_out_replicas.empty()",
          "old_line_content": "                exception_message << \" some replicas are inactive right now\";",
          "new_line_content": "        if (!inactive_replicas.empty() || !timed_out_replicas.empty())",
          "content_same": false
        },
        {
          "line": 3097,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "inactive_replicas.empty()",
          "old_line_content": "",
          "new_line_content": "            if (!inactive_replicas.empty())",
          "content_same": false
        },
        {
          "line": 3102,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "inactive_replicas.begin()",
          "old_line_content": "            {",
          "new_line_content": "                    exception_message << (it == inactive_replicas.begin() ? \": \" : \", \") << *it;",
          "content_same": false
        },
        {
          "line": 3108,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "timed_out_replicas.empty()",
          "old_line_content": "                exception_message << \" (replication_alter_columns_timeout = \" << replication_alter_columns_timeout << \")\";",
          "new_line_content": "            if (!timed_out_replicas.empty())",
          "content_same": false
        },
        {
          "line": 3112,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "timed_out_replicas.end()",
          "old_line_content": "",
          "new_line_content": "                for (auto it = timed_out_replicas.begin(); it != timed_out_replicas.end(); ++it)",
          "content_same": false
        },
        {
          "line": 3120,
          "old_api": null,
          "new_api": "str",
          "old_text": null,
          "new_text": "exception_message.str()",
          "old_line_content": "",
          "new_line_content": "            throw Exception(exception_message.str(), ErrorCodes::UNFINISHED);",
          "content_same": false
        },
        {
          "line": 3124,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"ALTER finished\")",
          "old_line_content": "    if (format_version < MERGE_TREE_DATA_MIN_FORMAT_VERSION_WITH_CUSTOM_PARTITIONING)",
          "new_line_content": "    LOG_DEBUG(log, \"ALTER finished\");",
          "content_same": false
        },
        {
          "line": 3135,
          "old_api": null,
          "new_api": "parse<UInt32>(part_info.partition_id + \"01\")",
          "old_text": null,
          "new_text": "parse<UInt32>(part_info.partition_id + \"01\")",
          "old_line_content": "}",
          "new_line_content": "        time_t start_time = lut.YYYYMMDDToDate(parse<UInt32>(part_info.partition_id + \"01\"));",
          "content_same": false
        },
        {
          "line": 3136,
          "old_api": null,
          "new_api": "toDayNum",
          "old_text": null,
          "new_text": "lut.toDayNum(start_time)",
          "old_line_content": "",
          "new_line_content": "        DayNum left_date = lut.toDayNum(start_time);",
          "content_same": false
        },
        {
          "line": 3137,
          "old_api": null,
          "new_api": "daysInMonth",
          "old_text": null,
          "new_text": "lut.daysInMonth(start_time)",
          "old_line_content": "bool StorageReplicatedMergeTree::getFakePartCoveringAllPartsInPartition(const String & partition_id, MergeTreePartInfo & part_info)",
          "new_line_content": "        DayNum right_date = DayNum(static_cast<size_t>(left_date) + lut.daysInMonth(start_time) - 1);",
          "content_same": false
        },
        {
          "line": 3138,
          "old_api": null,
          "new_api": "getPartNameV0",
          "old_text": null,
          "new_text": "part_info.getPartNameV0(left_date, right_date)",
          "old_line_content": "{",
          "new_line_content": "        return part_info.getPartNameV0(left_date, right_date);",
          "content_same": false
        },
        {
          "line": 3141,
          "old_api": null,
          "new_api": "getPartName",
          "old_text": null,
          "new_text": "part_info.getPartName()",
          "old_line_content": "    Int64 left = 0;",
          "new_line_content": "    return part_info.getPartName();",
          "content_same": false
        },
        {
          "line": 3160,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "    /// Empty partition.",
          "new_line_content": "        auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 3161,
          "old_api": null,
          "new_api": "allocateBlockNumber",
          "old_text": null,
          "new_text": "allocateBlockNumber(partition_id, zookeeper)",
          "old_line_content": "    if (right == 0)",
          "new_line_content": "        auto block_number_lock = allocateBlockNumber(partition_id, zookeeper);",
          "content_same": false
        },
        {
          "line": 3162,
          "old_api": null,
          "new_api": "getNumber",
          "old_text": null,
          "new_text": "block_number_lock->getNumber()",
          "old_line_content": "        return false;",
          "new_line_content": "        right = block_number_lock->getNumber();",
          "content_same": false
        },
        {
          "line": 3163,
          "old_api": null,
          "new_api": "unlock",
          "old_text": null,
          "new_text": "block_number_lock->unlock()",
          "old_line_content": "",
          "new_line_content": "        block_number_lock->unlock();",
          "content_same": false
        },
        {
          "line": 3164,
          "old_api": null,
          "new_api": "getCurrentMutationVersion",
          "old_text": null,
          "new_text": "queue.getCurrentMutationVersion(partition_id, right)",
          "old_line_content": "    --right;",
          "new_line_content": "        mutation_version = queue.getCurrentMutationVersion(partition_id, right);",
          "content_same": false
        },
        {
          "line": 3174,
          "old_api": null,
          "new_api": "MergeTreePartInfo",
          "old_text": null,
          "new_text": "MergeTreePartInfo(partition_id, left, right, MergeTreePartInfo::MAX_LEVEL, mutation_version)",
          "old_line_content": "{",
          "new_line_content": "    part_info = MergeTreePartInfo(partition_id, left, right, MergeTreePartInfo::MAX_LEVEL, mutation_version);",
          "content_same": false
        },
        {
          "line": 3186,
          "old_api": null,
          "new_api": "getPartitionIDFromQuery",
          "old_text": null,
          "new_text": "data.getPartitionIDFromQuery(partition, context)",
          "old_line_content": "    }",
          "new_line_content": "    String partition_id = data.getPartitionIDFromQuery(partition, context);",
          "content_same": false
        },
        {
          "line": 3189,
          "old_api": null,
          "new_api": "getFakePartCoveringAllPartsInPartition",
          "old_text": null,
          "new_text": "getFakePartCoveringAllPartsInPartition(partition_id, drop_range_info)",
          "old_line_content": "",
          "new_line_content": "    if (!getFakePartCoveringAllPartsInPartition(partition_id, drop_range_info))",
          "content_same": false
        },
        {
          "line": 3191,
          "old_api": null,
          "new_api": "LOG_INFO",
          "old_text": null,
          "new_text": "LOG_INFO(log, \"Will not clear partition \" << partition_id << \", it is empty.\")",
          "old_line_content": "    entry.type = LogEntry::CLEAR_COLUMN;",
          "new_line_content": "        LOG_INFO(log, \"Will not clear partition \" << partition_id << \", it is empty.\");",
          "content_same": false
        },
        {
          "line": 3199,
          "old_api": null,
          "new_api": "getPartNamePossiblyFake",
          "old_text": null,
          "new_text": "getPartNamePossiblyFake(data.format_version, drop_range_info)",
          "old_line_content": "    /// If necessary, wait until the operation is performed on itself or on all replicas.",
          "new_line_content": "    entry.new_part_name = getPartNamePossiblyFake(data.format_version, drop_range_info);",
          "content_same": false
        },
        {
          "line": 3201,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(nullptr)",
          "old_line_content": "    {",
          "new_line_content": "    entry.create_time = time(nullptr);",
          "content_same": false
        },
        {
          "line": 3204,
          "old_api": null,
          "new_api": "find_last_of",
          "old_text": null,
          "new_text": "log_znode_path.find_last_of('/')",
          "old_line_content": "        else",
          "new_line_content": "    entry.znode_name = log_znode_path.substr(log_znode_path.find_last_of('/') + 1);",
          "content_same": false
        },
        {
          "line": 3207,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context.getSettingsRef()",
          "old_line_content": "}",
          "new_line_content": "    if (context.getSettingsRef().replication_alter_partitions_sync != 0)",
          "content_same": false
        },
        {
          "line": 3209,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context.getSettingsRef()",
          "old_line_content": "",
          "new_line_content": "        if (context.getSettingsRef().replication_alter_partitions_sync == 1)",
          "content_same": false
        },
        {
          "line": 3210,
          "old_api": null,
          "new_api": "waitForReplicaToProcessLogEntry",
          "old_text": null,
          "new_text": "waitForReplicaToProcessLogEntry(replica_name, entry)",
          "old_line_content": "void StorageReplicatedMergeTree::dropPartition(const ASTPtr & query, const ASTPtr & partition, bool detach, const Context & context)",
          "new_line_content": "            waitForReplicaToProcessLogEntry(replica_name, entry);",
          "content_same": false
        },
        {
          "line": 3219,
          "old_api": null,
          "new_api": "assertNotReadonly",
          "old_text": null,
          "new_text": "assertNotReadonly()",
          "old_line_content": "        return;",
          "new_line_content": "    assertNotReadonly();",
          "content_same": false
        },
        {
          "line": 3221,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "",
          "new_line_content": "    zkutil::ZooKeeperPtr zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 3229,
          "old_api": null,
          "new_api": "getPartitionIDFromQuery",
          "old_text": null,
          "new_text": "data.getPartitionIDFromQuery(partition, context)",
          "old_line_content": "        {",
          "new_line_content": "    String partition_id = data.getPartitionIDFromQuery(partition, context);",
          "content_same": false
        },
        {
          "line": 3232,
          "old_api": null,
          "new_api": "dropPartsInPartition",
          "old_text": null,
          "new_text": "dropPartsInPartition(*zookeeper, partition_id, entry, detach)",
          "old_line_content": "            else",
          "new_line_content": "    if (dropPartsInPartition(*zookeeper, partition_id, entry, detach))",
          "content_same": false
        },
        {
          "line": 3235,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context.getSettingsRef()",
          "old_line_content": "    }",
          "new_line_content": "        if (context.getSettingsRef().replication_alter_partitions_sync != 0)",
          "content_same": false
        },
        {
          "line": 3237,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context.getSettingsRef()",
          "old_line_content": "",
          "new_line_content": "            if (context.getSettingsRef().replication_alter_partitions_sync == 1)",
          "content_same": false
        },
        {
          "line": 3238,
          "old_api": null,
          "new_api": "waitForReplicaToProcessLogEntry",
          "old_text": null,
          "new_text": "waitForReplicaToProcessLogEntry(replica_name, entry)",
          "old_line_content": "",
          "new_line_content": "                waitForReplicaToProcessLogEntry(replica_name, entry);",
          "content_same": false
        },
        {
          "line": 3240,
          "old_api": null,
          "new_api": "waitForAllReplicasToProcessLogEntry",
          "old_text": null,
          "new_text": "waitForAllReplicasToProcessLogEntry(entry)",
          "old_line_content": "{",
          "new_line_content": "                waitForAllReplicasToProcessLogEntry(entry);",
          "content_same": false
        },
        {
          "line": 3248,
          "old_api": null,
          "new_api": "assertNotReadonly",
          "old_text": null,
          "new_text": "assertNotReadonly()",
          "old_line_content": "        return;",
          "new_line_content": "    assertNotReadonly();",
          "content_same": false
        },
        {
          "line": 3250,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "",
          "new_line_content": "    zkutil::ZooKeeperPtr zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 3254,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context.getSettingsRef()",
          "old_line_content": "    {",
          "new_line_content": "        sendRequestToLeaderReplica(query, context.getSettingsRef());",
          "content_same": false
        },
        {
          "line": 3264,
          "old_api": null,
          "new_api": "dropPartsInPartition",
          "old_text": null,
          "new_text": "dropPartsInPartition(*zookeeper, partition_id, entry, false)",
          "old_line_content": "{",
          "new_line_content": "        if (dropPartsInPartition(*zookeeper, partition_id, entry, false))",
          "content_same": false
        },
        {
          "line": 3277,
          "old_api": null,
          "new_api": "typeid_cast<const ASTLiteral &>(*partition).value.safeGet<String>()",
          "old_text": null,
          "new_text": "typeid_cast<const ASTLiteral &>(*partition).value.safeGet<String>()",
          "old_line_content": "    Strings parts;",
          "new_line_content": "        partition_id = typeid_cast<const ASTLiteral &>(*partition).value.safeGet<String>();",
          "content_same": false
        },
        {
          "line": 3279,
          "old_api": null,
          "new_api": "getPartitionIDFromQuery",
          "old_text": null,
          "new_text": "data.getPartitionIDFromQuery(partition, context)",
          "old_line_content": "    {",
          "new_line_content": "        partition_id = data.getPartitionIDFromQuery(partition, context);",
          "content_same": false
        },
        {
          "line": 3287,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "parts.push_back(partition_id)",
          "old_line_content": "        std::set<String> part_names;",
          "new_line_content": "        parts.push_back(partition_id);",
          "content_same": false
        },
        {
          "line": 3291,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Looking for parts for partition \" << partition_id << \" in \" << source_dir)",
          "old_line_content": "            MergeTreePartInfo part_info;",
          "new_line_content": "        LOG_DEBUG(log, \"Looking for parts for partition \" << partition_id << \" in \" << source_dir);",
          "content_same": false
        },
        {
          "line": 3295,
          "old_api": null,
          "new_api": "Poco::DirectoryIterator()",
          "old_text": null,
          "new_text": "Poco::DirectoryIterator()",
          "old_line_content": "                continue;",
          "new_line_content": "        for (Poco::DirectoryIterator it = Poco::DirectoryIterator(full_path + source_dir); it != Poco::DirectoryIterator(); ++it)",
          "content_same": false
        },
        {
          "line": 3299,
          "old_api": null,
          "new_api": "MergeTreePartInfo::tryParsePartName(name, &part_info, data.format_version)",
          "old_text": null,
          "new_text": "MergeTreePartInfo::tryParsePartName(name, &part_info, data.format_version)",
          "old_line_content": "        }",
          "new_line_content": "            if (!MergeTreePartInfo::tryParsePartName(name, &part_info, data.format_version))",
          "content_same": false
        },
        {
          "line": 3303,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Found part \" << name)",
          "old_line_content": "        /// Inactive parts rename so they can not be attached in case of repeated ATTACH.",
          "new_line_content": "            LOG_DEBUG(log, \"Found part \" << name);",
          "content_same": false
        },
        {
          "line": 3304,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "active_parts.add(name)",
          "old_line_content": "        for (const auto & name : part_names)",
          "new_line_content": "            active_parts.add(name);",
          "content_same": false
        },
        {
          "line": 3305,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "part_names.insert(name)",
          "old_line_content": "        {",
          "new_line_content": "            part_names.insert(name);",
          "content_same": false
        },
        {
          "line": 3314,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "containing_part.empty()",
          "old_line_content": "    std::vector<MergeTreeData::MutableDataPartPtr> loaded_parts;",
          "new_line_content": "            if (!containing_part.empty() && containing_part != name)",
          "content_same": false
        },
        {
          "line": 3315,
          "old_api": null,
          "new_api": "renameTo",
          "old_text": null,
          "new_text": "Poco::File(full_path + source_dir + name).renameTo(full_path + source_dir + \"inactive_\" + name)",
          "old_line_content": "    for (const String & part : parts)",
          "new_line_content": "                Poco::File(full_path + source_dir + name).renameTo(full_path + source_dir + \"inactive_\" + name);",
          "content_same": false
        },
        {
          "line": 3320,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Checking parts\")",
          "old_line_content": "",
          "new_line_content": "    LOG_DEBUG(log, \"Checking parts\");",
          "content_same": false
        },
        {
          "line": 3324,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Checking part \" << part)",
          "old_line_content": "        String old_name = part->name;",
          "new_line_content": "        LOG_DEBUG(log, \"Checking part \" << part);",
          "content_same": false
        },
        {
          "line": 3332,
          "old_api": null,
          "new_api": "writeExistingPart",
          "old_text": null,
          "new_text": "output.writeExistingPart(part)",
          "old_line_content": "{",
          "new_line_content": "        output.writeExistingPart(part);",
          "content_same": false
        },
        {
          "line": 3333,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Attached part \" << old_name << \" as \" << part->name)",
          "old_line_content": "    /// Consider only synchronized data",
          "new_line_content": "        LOG_DEBUG(log, \"Attached part \" << old_name << \" as \" << part->name);",
          "content_same": false
        },
        {
          "line": 3341,
          "old_api": null,
          "new_api": "getData",
          "old_text": null,
          "new_text": "getData()",
          "old_line_content": "{",
          "new_line_content": "    const_cast<MergeTreeData &>(getData()).recalculateColumnSizes();",
          "content_same": false
        },
        {
          "line": 3342,
          "old_api": null,
          "new_api": "getTotalActiveSizeInBytes",
          "old_text": null,
          "new_text": "getData().getTotalActiveSizeInBytes()",
          "old_line_content": "    {",
          "new_line_content": "    context.checkTableCanBeDropped(database_name, table_name, getData().getTotalActiveSizeInBytes());",
          "content_same": false
        },
        {
          "line": 3359,
          "old_api": null,
          "new_api": "expired",
          "old_text": null,
          "new_text": "zookeeper->expired()",
          "old_line_content": "        /// Check that `zookeeper_path` exists: it could have been deleted by another replica after execution of previous line.",
          "new_line_content": "        if (zookeeper->expired())",
          "content_same": false
        },
        {
          "line": 3360,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Table was not dropped because ZooKeeper session has expired.\", ErrorCodes::TABLE_WAS_NOT_DROPPED)",
          "old_line_content": "        Strings replicas;",
          "new_line_content": "            throw Exception(\"Table was not dropped because ZooKeeper session has expired.\", ErrorCodes::TABLE_WAS_NOT_DROPPED);",
          "content_same": false
        },
        {
          "line": 3362,
          "old_api": null,
          "new_api": "LOG_INFO",
          "old_text": null,
          "new_text": "LOG_INFO(log, \"Removing replica \" << replica_path)",
          "old_line_content": "        {",
          "new_line_content": "        LOG_INFO(log, \"Removing replica \" << replica_path);",
          "content_same": false
        },
        {
          "line": 3370,
          "old_api": null,
          "new_api": "LOG_INFO",
          "old_text": null,
          "new_text": "LOG_INFO(log, \"Removing table \" << zookeeper_path << \" (this might take several minutes)\")",
          "old_line_content": "",
          "new_line_content": "            LOG_INFO(log, \"Removing table \" << zookeeper_path << \" (this might take several minutes)\");",
          "content_same": false
        },
        {
          "line": 3371,
          "old_api": null,
          "new_api": "tryRemoveRecursive",
          "old_text": null,
          "new_text": "zookeeper->tryRemoveRecursive(zookeeper_path)",
          "old_line_content": "",
          "new_line_content": "            zookeeper->tryRemoveRecursive(zookeeper_path);",
          "content_same": false
        },
        {
          "line": 3375,
          "old_api": null,
          "new_api": "dropAllData",
          "old_text": null,
          "new_text": "data.dropAllData()",
          "old_line_content": "",
          "new_line_content": "    data.dropAllData();",
          "content_same": false
        },
        {
          "line": 3381,
          "old_api": null,
          "new_api": "escapeForFileName",
          "old_text": null,
          "new_text": "escapeForFileName(new_table_name)",
          "old_line_content": "",
          "new_line_content": "    std::string new_full_path = new_path_to_db + escapeForFileName(new_table_name) + '/';",
          "content_same": false
        },
        {
          "line": 3390,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "bool StorageReplicatedMergeTree::existsNodeCached(const std::string & path)",
          "new_line_content": "    auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 3391,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "getReplicatedMergeTreeAddress().toString()",
          "old_line_content": "{",
          "new_line_content": "    zookeeper->set(replica_path + \"/host\", getReplicatedMergeTreeAddress().toString());",
          "content_same": false
        },
        {
          "line": 3401,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "existing_nodes_cache.count(path)",
          "old_line_content": "    {",
          "new_line_content": "        if (existing_nodes_cache.count(path))",
          "content_same": false
        },
        {
          "line": 3405,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "getZooKeeper()->exists(path)",
          "old_line_content": "",
          "new_line_content": "    bool res = getZooKeeper()->exists(path);",
          "content_same": false
        },
        {
          "line": 3410,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "existing_nodes_cache.insert(path)",
          "old_line_content": "std::optional<AbandonableLockInZooKeeper>",
          "new_line_content": "        existing_nodes_cache.insert(path);",
          "content_same": false
        },
        {
          "line": 3423,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "zookeeper_block_id_path.empty()",
          "old_line_content": "    String partition_path = block_numbers_path + \"/\" + partition_id;",
          "new_line_content": "    if (!zookeeper_block_id_path.empty())",
          "content_same": false
        },
        {
          "line": 3426,
          "old_api": null,
          "new_api": "zkutil::makeRemoveRequest(zookeeper_block_id_path, -1)",
          "old_text": null,
          "new_text": "zkutil::makeRemoveRequest(zookeeper_block_id_path, -1)",
          "old_line_content": "    {",
          "new_line_content": "        deduplication_check_ops.emplace_back(zkutil::makeRemoveRequest(zookeeper_block_id_path, -1));",
          "content_same": false
        },
        {
          "line": 3439,
          "old_api": null,
          "new_api": "zkutil::makeSetRequest(block_numbers_path, \"\", -1)",
          "old_text": null,
          "new_text": "zkutil::makeSetRequest(block_numbers_path, \"\", -1)",
          "old_line_content": "",
          "new_line_content": "        ops.push_back(zkutil::makeSetRequest(block_numbers_path, \"\", -1));",
          "content_same": false
        },
        {
          "line": 3442,
          "old_api": null,
          "new_api": "tryMulti",
          "old_text": null,
          "new_text": "zookeeper->tryMulti(ops, responses)",
          "old_line_content": "    try",
          "new_line_content": "        int code = zookeeper->tryMulti(ops, responses);",
          "content_same": false
        },
        {
          "line": 3451,
          "old_api": null,
          "new_api": "AbandonableLockInZooKeeper",
          "old_text": null,
          "new_text": "AbandonableLockInZooKeeper(\n            partition_path + \"/block-\", zookeeper_path + \"/temp\", *zookeeper, &deduplication_check_ops)",
          "old_line_content": "",
          "new_line_content": "        lock = AbandonableLockInZooKeeper(",
          "content_same": false
        },
        {
          "line": 3463,
          "old_api": null,
          "new_api": "displayText",
          "old_text": null,
          "new_text": "e.displayText()",
          "old_line_content": "void StorageReplicatedMergeTree::waitForAllReplicasToProcessLogEntry(const ReplicatedMergeTreeLogEntryData & entry)",
          "new_line_content": "        throw Exception(\"Cannot allocate block number in ZooKeeper: \" + e.displayText(), ErrorCodes::KEEPER_EXCEPTION);",
          "content_same": false
        },
        {
          "line": 3466,
          "old_api": null,
          "new_api": "std::move(lock)",
          "old_text": null,
          "new_text": "std::move(lock)",
          "old_line_content": "",
          "new_line_content": "    return {std::move(lock)};",
          "content_same": false
        },
        {
          "line": 3472,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Waiting for all replicas to process \" << entry.znode_name)",
          "old_line_content": "}",
          "new_line_content": "    LOG_DEBUG(log, \"Waiting for all replicas to process \" << entry.znode_name);",
          "content_same": false
        },
        {
          "line": 3474,
          "old_api": null,
          "new_api": "getChildren",
          "old_text": null,
          "new_text": "getZooKeeper()->getChildren(zookeeper_path + \"/replicas\")",
          "old_line_content": "",
          "new_line_content": "    Strings replicas = getZooKeeper()->getChildren(zookeeper_path + \"/replicas\");",
          "content_same": false
        },
        {
          "line": 3476,
          "old_api": null,
          "new_api": "waitForReplicaToProcessLogEntry",
          "old_text": null,
          "new_text": "waitForReplicaToProcessLogEntry(replica, entry)",
          "old_line_content": "{",
          "new_line_content": "        waitForReplicaToProcessLogEntry(replica, entry);",
          "content_same": false
        },
        {
          "line": 3478,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Finished waiting for all replicas to process \" << entry.znode_name)",
          "old_line_content": "    String log_node_name;",
          "new_line_content": "    LOG_DEBUG(log, \"Finished waiting for all replicas to process \" << entry.znode_name);",
          "content_same": false
        },
        {
          "line": 3484,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "entry.toString()",
          "old_line_content": "      * The problem is that the numbers (`sequential` node) of the queue elements in `log` and in `queue` do not match.",
          "new_line_content": "    String entry_str = entry.toString();",
          "content_same": false
        },
        {
          "line": 3503,
          "old_api": null,
          "new_api": "startsWith",
          "old_text": null,
          "new_text": "startsWith(entry.znode_name, \"log-\")",
          "old_line_content": "",
          "new_line_content": "    if (startsWith(entry.znode_name, \"log-\"))",
          "content_same": false
        },
        {
          "line": 3508,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "entry.znode_name.size()",
          "old_line_content": "        {",
          "new_line_content": "        UInt64 log_index = parse<UInt64>(entry.znode_name.substr(entry.znode_name.size() - 10));",
          "content_same": false
        },
        {
          "line": 3516,
          "old_api": null,
          "new_api": "std::make_shared<Poco::Event>()",
          "old_text": null,
          "new_text": "std::make_shared<Poco::Event>()",
          "old_line_content": "        }",
          "new_line_content": "            zkutil::EventPtr event = std::make_shared<Poco::Event>();",
          "content_same": false
        },
        {
          "line": 3519,
          "old_api": null,
          "new_api": "parse<UInt64>(log_pointer)",
          "old_text": null,
          "new_text": "parse<UInt64>(log_pointer)",
          "old_line_content": "    {",
          "new_line_content": "            if (!log_pointer.empty() && parse<UInt64>(log_pointer) > log_index)",
          "content_same": false
        },
        {
          "line": 3522,
          "old_api": null,
          "new_api": "wait",
          "old_text": null,
          "new_text": "event->wait()",
          "old_line_content": "          */",
          "new_line_content": "            event->wait();",
          "content_same": false
        },
        {
          "line": 3525,
          "old_api": null,
          "new_api": "startsWith",
          "old_text": null,
          "new_text": "startsWith(entry.znode_name, \"queue-\")",
          "old_line_content": "",
          "new_line_content": "    else if (startsWith(entry.znode_name, \"queue-\"))",
          "content_same": false
        },
        {
          "line": 3531,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "getZooKeeper()->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\")",
          "old_line_content": "        {",
          "new_line_content": "        String log_pointer = getZooKeeper()->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\");",
          "content_same": false
        },
        {
          "line": 3533,
          "old_api": null,
          "new_api": "getChildren",
          "old_text": null,
          "new_text": "getZooKeeper()->getChildren(zookeeper_path + \"/log\")",
          "old_line_content": "",
          "new_line_content": "        Strings log_entries = getZooKeeper()->getChildren(zookeeper_path + \"/log\");",
          "content_same": false
        },
        {
          "line": 3539,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "log_entry_name.size()",
          "old_line_content": "            if (exists && entry_str == log_entry_str)",
          "new_line_content": "            log_index = parse<UInt64>(log_entry_name.substr(log_entry_name.size() - 10));",
          "content_same": false
        },
        {
          "line": 3541,
          "old_api": null,
          "new_api": "parse<UInt64>(log_pointer)",
          "old_text": null,
          "new_text": "parse<UInt64>(log_pointer)",
          "old_line_content": "                found = true;",
          "new_line_content": "            if (!log_pointer.empty() && log_index < parse<UInt64>(log_pointer))",
          "content_same": false
        },
        {
          "line": 3545,
          "old_api": null,
          "new_api": "tryGet",
          "old_text": null,
          "new_text": "getZooKeeper()->tryGet(zookeeper_path + \"/log/\" + log_entry_name, log_entry_str)",
          "old_line_content": "        }",
          "new_line_content": "            bool exists = getZooKeeper()->tryGet(zookeeper_path + \"/log/\" + log_entry_name, log_entry_str);",
          "content_same": false
        },
        {
          "line": 3561,
          "old_api": null,
          "new_api": "std::make_shared<Poco::Event>()",
          "old_text": null,
          "new_text": "std::make_shared<Poco::Event>()",
          "old_line_content": "            }",
          "new_line_content": "                zkutil::EventPtr event = std::make_shared<Poco::Event>();",
          "content_same": false
        },
        {
          "line": 3563,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "getZooKeeper()->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\", nullptr, event)",
          "old_line_content": "    }",
          "new_line_content": "                String log_pointer = getZooKeeper()->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\", nullptr, event);",
          "content_same": false
        },
        {
          "line": 3564,
          "old_api": null,
          "new_api": "parse<UInt64>(log_pointer)",
          "old_text": null,
          "new_text": "parse<UInt64>(log_pointer)",
          "old_line_content": "    else",
          "new_line_content": "                if (!log_pointer.empty() && parse<UInt64>(log_pointer) > log_index)",
          "content_same": false
        },
        {
          "line": 3572,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Logical error: unexpected name of log node: \" + entry.znode_name, ErrorCodes::LOGICAL_ERROR)",
          "old_line_content": "    /** Second - find the corresponding entry in the queue of the specified replica.",
          "new_line_content": "        throw Exception(\"Logical error: unexpected name of log node: \" + entry.znode_name, ErrorCodes::LOGICAL_ERROR);",
          "content_same": false
        },
        {
          "line": 3574,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "log_node_name.empty()",
          "old_line_content": "      * Therefore, we search by comparing the content.",
          "new_line_content": "    if (!log_node_name.empty())",
          "content_same": false
        },
        {
          "line": 3575,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Looking for node corresponding to \" << log_node_name << \" in \" << replica << \" queue\")",
          "old_line_content": "      */",
          "new_line_content": "        LOG_DEBUG(log, \"Looking for node corresponding to \" << log_node_name << \" in \" << replica << \" queue\");",
          "content_same": false
        },
        {
          "line": 3584,
          "old_api": null,
          "new_api": "getChildren",
          "old_text": null,
          "new_text": "getZooKeeper()->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/queue\")",
          "old_line_content": "        if (exists && queue_entry_str == entry_str)",
          "new_line_content": "    Strings queue_entries = getZooKeeper()->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/queue\");",
          "content_same": false
        },
        {
          "line": 3590,
          "old_api": null,
          "new_api": "tryGet",
          "old_text": null,
          "new_text": "getZooKeeper()->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/queue/\" + entry_name, queue_entry_str)",
          "old_line_content": "",
          "new_line_content": "        bool exists = getZooKeeper()->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/queue/\" + entry_name, queue_entry_str);",
          "content_same": false
        },
        {
          "line": 3599,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "queue_entry_to_wait_for.empty()",
          "old_line_content": "",
          "new_line_content": "    if (queue_entry_to_wait_for.empty())",
          "content_same": false
        },
        {
          "line": 3605,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Waiting for \" << queue_entry_to_wait_for << \" to disappear from \" << replica << \" queue\")",
          "old_line_content": "void StorageReplicatedMergeTree::getStatus(Status & res, bool with_zk_fields)",
          "new_line_content": "    LOG_DEBUG(log, \"Waiting for \" << queue_entry_to_wait_for << \" to disappear from \" << replica << \" queue\");",
          "content_same": false
        },
        {
          "line": 3608,
          "old_api": null,
          "new_api": "waitForDisappear",
          "old_text": null,
          "new_text": "getZooKeeper()->waitForDisappear(zookeeper_path + \"/replicas/\" + replica + \"/queue/\" + queue_entry_to_wait_for)",
          "old_line_content": "",
          "new_line_content": "    getZooKeeper()->waitForDisappear(zookeeper_path + \"/replicas/\" + replica + \"/queue/\" + queue_entry_to_wait_for);",
          "content_same": false
        },
        {
          "line": 3618,
          "old_api": null,
          "new_api": "expired",
          "old_text": null,
          "new_text": "zookeeper->expired()",
          "old_line_content": "    res.zookeeper_path = zookeeper_path;",
          "new_line_content": "    res.is_session_expired = !zookeeper || zookeeper->expired();",
          "content_same": false
        },
        {
          "line": 3620,
          "old_api": null,
          "new_api": "getStatus",
          "old_text": null,
          "new_text": "queue.getStatus()",
          "old_line_content": "    res.replica_path = replica_path;",
          "new_line_content": "    res.queue = queue.getStatus();",
          "content_same": false
        },
        {
          "line": 3621,
          "old_api": null,
          "new_api": "getAbsoluteDelay",
          "old_text": null,
          "new_text": "getAbsoluteDelay()",
          "old_line_content": "    res.columns_version = columns_version;",
          "new_line_content": "    res.absolute_delay = getAbsoluteDelay(); /// NOTE: may be slightly inconsistent with queue status.",
          "content_same": false
        },
        {
          "line": 3623,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "part_check_thread.size()",
          "old_line_content": "    if (res.is_session_expired || !with_zk_fields)",
          "new_line_content": "    res.parts_to_check = part_check_thread.size();",
          "content_same": false
        },
        {
          "line": 3639,
          "old_api": null,
          "new_api": "getChildren",
          "old_text": null,
          "new_text": "zookeeper->getChildren(zookeeper_path + \"/log\")",
          "old_line_content": "        {",
          "new_line_content": "        auto log_entries = zookeeper->getChildren(zookeeper_path + \"/log\");",
          "content_same": false
        },
        {
          "line": 3651,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "zookeeper->get(replica_path + \"/log_pointer\")",
          "old_line_content": "        for (const String & replica : all_replicas)",
          "new_line_content": "        String log_pointer_str = zookeeper->get(replica_path + \"/log_pointer\");",
          "content_same": false
        },
        {
          "line": 3654,
          "old_api": null,
          "new_api": "getChildren",
          "old_text": null,
          "new_text": "zookeeper->getChildren(zookeeper_path + \"/replicas\")",
          "old_line_content": "    }",
          "new_line_content": "        auto all_replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "content_same": false
        },
        {
          "line": 3655,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "all_replicas.size()",
          "old_line_content": "}",
          "new_line_content": "        res.total_replicas = all_replicas.size();",
          "content_same": false
        },
        {
          "line": 3659,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")",
          "old_line_content": "void StorageReplicatedMergeTree::sendRequestToLeaderReplica(const ASTPtr & query, const Settings & settings)",
          "new_line_content": "            if (zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\"))",
          "content_same": false
        },
        {
          "line": 3668,
          "old_api": null,
          "new_api": "getChildren",
          "old_text": null,
          "new_text": "getZooKeeper()->getChildren(zookeeper_path + \"/leader_election\")",
          "old_line_content": "    if (leader == replica_name)",
          "new_line_content": "    auto live_replicas = getZooKeeper()->getChildren(zookeeper_path + \"/leader_election\");",
          "content_same": false
        },
        {
          "line": 3670,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"No active replicas\", ErrorCodes::NO_ACTIVE_REPLICAS)",
          "old_line_content": "",
          "new_line_content": "        throw Exception(\"No active replicas\", ErrorCodes::NO_ACTIVE_REPLICAS);",
          "content_same": false
        },
        {
          "line": 3672,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "live_replicas.end()",
          "old_line_content": "",
          "new_line_content": "    std::sort(live_replicas.begin(), live_replicas.end());",
          "content_same": false
        },
        {
          "line": 3673,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "live_replicas.front()",
          "old_line_content": "    /// TODO: add setters and getters interface for database and table fields of AST",
          "new_line_content": "    const auto leader = getZooKeeper()->get(zookeeper_path + \"/leader_election/\" + live_replicas.front());",
          "content_same": false
        },
        {
          "line": 3676,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Leader was suddenly changed or logical error.\", ErrorCodes::LEADERSHIP_CHANGED)",
          "old_line_content": "    {",
          "new_line_content": "        throw Exception(\"Leader was suddenly changed or logical error.\", ErrorCodes::LEADERSHIP_CHANGED);",
          "content_same": false
        },
        {
          "line": 3678,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "getZooKeeper()->get(zookeeper_path + \"/replicas/\" + leader + \"/host\")",
          "old_line_content": "        alter->table = leader_address.table;",
          "new_line_content": "    ReplicatedMergeTreeAddress leader_address(getZooKeeper()->get(zookeeper_path + \"/replicas/\" + leader + \"/host\"));",
          "content_same": false
        },
        {
          "line": 3681,
          "old_api": null,
          "new_api": "clone",
          "old_text": null,
          "new_text": "query->clone()",
          "old_line_content": "    {",
          "new_line_content": "    auto new_query = query->clone();",
          "content_same": false
        },
        {
          "line": 3682,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "new_query.get()",
          "old_line_content": "        optimize->database = leader_address.database;",
          "new_line_content": "    if (auto * alter = typeid_cast<ASTAlterQuery *>(new_query.get()))",
          "content_same": false
        },
        {
          "line": 3687,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "new_query.get()",
          "old_line_content": "",
          "new_line_content": "    else if (auto * optimize = typeid_cast<ASTOptimizeQuery *>(new_query.get()))",
          "content_same": false
        },
        {
          "line": 3693,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Can't proxy this query. Unsupported query type\", ErrorCodes::NOT_IMPLEMENTED)",
          "old_line_content": "        leader_address.queries_port,",
          "new_line_content": "        throw Exception(\"Can't proxy this query. Unsupported query type\", ErrorCodes::NOT_IMPLEMENTED);",
          "content_same": false
        },
        {
          "line": 3702,
          "old_api": null,
          "new_api": "getClientInfo",
          "old_text": null,
          "new_text": "context.getClientInfo()",
          "old_line_content": "}",
          "new_line_content": "        context.getClientInfo().current_user, context.getClientInfo().current_password, timeouts, \"ClickHouse replica\");",
          "content_same": false
        },
        {
          "line": 3704,
          "old_api": null,
          "new_api": "formattedAST",
          "old_text": null,
          "new_text": "formattedAST(new_query)",
          "old_line_content": "",
          "new_line_content": "    RemoteBlockInputStream stream(connection, formattedAST(new_query), {}, context, &settings);",
          "content_same": false
        },
        {
          "line": 3707,
          "old_api": null,
          "new_api": "copyData",
          "old_text": null,
          "new_text": "copyData(stream, output)",
          "old_line_content": "    replica_name_ = replica_name;",
          "new_line_content": "    copyData(stream, output);",
          "content_same": false
        },
        {
          "line": 3726,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "last_queue_update_start_time.load()",
          "old_line_content": "        /// We have not updated queue even once yet (perhaps replica is readonly).",
          "new_line_content": "    time_t queue_update_start_time = last_queue_update_start_time.load();",
          "content_same": false
        },
        {
          "line": 3727,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "last_queue_update_finish_time.load()",
          "old_line_content": "        /// As we have no info about the current state of replication log, return effectively infinite delay.",
          "new_line_content": "    time_t queue_update_finish_time = last_queue_update_finish_time.load();",
          "content_same": false
        },
        {
          "line": 3729,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(nullptr)",
          "old_line_content": "    }",
          "new_line_content": "    time_t current_time = time(nullptr);",
          "content_same": false
        },
        {
          "line": 3758,
          "old_api": null,
          "new_api": "assertNotReadonly",
          "old_text": null,
          "new_text": "assertNotReadonly()",
          "old_line_content": "    /** Relative delay is the maximum difference of absolute delay from any other replica,",
          "new_line_content": "    assertNotReadonly();",
          "content_same": false
        },
        {
          "line": 3760,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(nullptr)",
          "old_line_content": "      * Calculated only if the absolute delay is large enough.",
          "new_line_content": "    time_t current_time = time(nullptr);",
          "content_same": false
        },
        {
          "line": 3762,
          "old_api": null,
          "new_api": "getAbsoluteDelay",
          "old_text": null,
          "new_text": "getAbsoluteDelay()",
          "old_line_content": "",
          "new_line_content": "    out_absolute_delay = getAbsoluteDelay();",
          "content_same": false
        },
        {
          "line": 3770,
          "old_api": null,
          "new_api": "static_cast<time_t>(data.settings.min_relative_delay_to_yield_leadership)",
          "old_text": null,
          "new_text": "static_cast<time_t>(data.settings.min_relative_delay_to_yield_leadership)",
          "old_line_content": "",
          "new_line_content": "    if (out_absolute_delay < static_cast<time_t>(data.settings.min_relative_delay_to_yield_leadership))",
          "content_same": false
        },
        {
          "line": 3773,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "    for (const auto & replica : replicas)",
          "new_line_content": "    auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 3778,
          "old_api": null,
          "new_api": "getChildren",
          "old_text": null,
          "new_text": "zookeeper->getChildren(zookeeper_path + \"/replicas\")",
          "old_line_content": "        /// Skip dead replicas.",
          "new_line_content": "    Strings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "content_same": false
        },
        {
          "line": 3790,
          "old_api": null,
          "new_api": "tryGet",
          "old_text": null,
          "new_text": "zookeeper->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/min_unprocessed_insert_time\", value)",
          "old_line_content": "            /** Note",
          "new_line_content": "        if (!zookeeper->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/min_unprocessed_insert_time\", value))",
          "content_same": false
        },
        {
          "line": 3793,
          "old_api": null,
          "new_api": "parse<time_t>(value)",
          "old_text": null,
          "new_text": "parse<time_t>(value)",
          "old_line_content": "              *  only from that part of the log that has been moved to the queue.",
          "new_line_content": "        time_t replica_time = value.empty() ? 0 : parse<time_t>(value);",
          "content_same": false
        },
        {
          "line": 3817,
          "old_api": null,
          "new_api": "std::min(current_time, max_replicas_unprocessed_insert_time)",
          "old_text": null,
          "new_text": "std::min(current_time, max_replicas_unprocessed_insert_time)",
          "old_line_content": "",
          "new_line_content": "        max_replicas_unprocessed_insert_time = std::min(current_time, max_replicas_unprocessed_insert_time);",
          "content_same": false
        },
        {
          "line": 3827,
          "old_api": null,
          "new_api": "getPartitionIDFromQuery",
          "old_text": null,
          "new_text": "data.getPartitionIDFromQuery(partition, context)",
          "old_line_content": "",
          "new_line_content": "    String partition_id = data.getPartitionIDFromQuery(partition, context);",
          "content_same": false
        },
        {
          "line": 3830,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "from.back()",
          "old_line_content": "      */",
          "new_line_content": "    if (from.back() == '/')",
          "content_same": false
        },
        {
          "line": 3831,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "from.size()",
          "old_line_content": "    Poco::DirectoryIterator dir_end;",
          "new_line_content": "        from.resize(from.size() - 1);",
          "content_same": false
        },
        {
          "line": 3833,
          "old_api": null,
          "new_api": "LOG_INFO",
          "old_text": null,
          "new_text": "LOG_INFO(log, \"Will fetch partition \" << partition_id << \" from shard \" << from_)",
          "old_line_content": "    {",
          "new_line_content": "    LOG_INFO(log, \"Will fetch partition \" << partition_id << \" from shard \" << from_);",
          "content_same": false
        },
        {
          "line": 3839,
          "old_api": null,
          "new_api": "getFullPath",
          "old_text": null,
          "new_text": "data.getFullPath()",
          "old_line_content": "",
          "new_line_content": "    for (Poco::DirectoryIterator dir_it{data.getFullPath() + \"detached/\"}; dir_it != dir_end; ++dir_it)",
          "content_same": false
        },
        {
          "line": 3842,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "dir_it.name()",
          "old_line_content": "    String best_replica;",
          "new_line_content": "        if (MergeTreePartInfo::tryParsePartName(dir_it.name(), &part_info, data.format_version)",
          "content_same": false
        },
        {
          "line": 3844,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Detached partition \" + partition_id + \" already exists.\", ErrorCodes::PARTITION_ALREADY_EXISTS)",
          "old_line_content": "    {",
          "new_line_content": "            throw Exception(\"Detached partition \" + partition_id + \" already exists.\", ErrorCodes::PARTITION_ALREADY_EXISTS);",
          "content_same": false
        },
        {
          "line": 3852,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "",
          "new_line_content": "        auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 3861,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "zookeeper->exists(from + \"/replicas/\" + replica + \"/is_active\")",
          "old_line_content": "        * This is a replica with the maximum `log_pointer`, then with the minimum `queue` size.",
          "new_line_content": "            if (zookeeper->exists(from + \"/replicas/\" + replica + \"/is_active\"))",
          "content_same": false
        },
        {
          "line": 3862,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "active_replicas.push_back(replica)",
          "old_line_content": "        * NOTE This is not exactly the best criteria. It does not make sense to download old partitions,",
          "new_line_content": "                active_replicas.push_back(replica);",
          "content_same": false
        },
        {
          "line": 3864,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "active_replicas.empty()",
          "old_line_content": "        * NOTE Of course, there are data races here. You can solve it by retrying.",
          "new_line_content": "        if (active_replicas.empty())",
          "content_same": false
        },
        {
          "line": 3865,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"No active replicas for shard \" + from, ErrorCodes::NO_ACTIVE_REPLICAS)",
          "old_line_content": "        */",
          "new_line_content": "            throw Exception(\"No active replicas for shard \" + from, ErrorCodes::NO_ACTIVE_REPLICAS);",
          "content_same": false
        },
        {
          "line": 3880,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "zookeeper->get(current_replica_path + \"/log_pointer\")",
          "old_line_content": "            if (log_pointer > max_log_pointer",
          "new_line_content": "            String log_pointer_str = zookeeper->get(current_replica_path + \"/log_pointer\");",
          "content_same": false
        },
        {
          "line": 3881,
          "old_api": null,
          "new_api": "parse<UInt64>(log_pointer_str)",
          "old_text": null,
          "new_text": "parse<UInt64>(log_pointer_str)",
          "old_line_content": "                || (log_pointer == max_log_pointer && queue_size < min_queue_size))",
          "new_line_content": "            Int64 log_pointer = log_pointer_str.empty() ? 0 : parse<UInt64>(log_pointer_str);",
          "content_same": false
        },
        {
          "line": 3884,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "zookeeper->get(current_replica_path + \"/queue\", &stat)",
          "old_line_content": "                min_queue_size = queue_size;",
          "new_line_content": "            zookeeper->get(current_replica_path + \"/queue\", &stat);",
          "content_same": false
        },
        {
          "line": 3897,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "best_replica.empty()",
          "old_line_content": "",
          "new_line_content": "    if (best_replica.empty())",
          "content_same": false
        },
        {
          "line": 3898,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Logical error: cannot choose best replica.\", ErrorCodes::LOGICAL_ERROR)",
          "old_line_content": "    /// Let's find out which parts are on the best replica.",
          "new_line_content": "        throw Exception(\"Logical error: cannot choose best replica.\", ErrorCodes::LOGICAL_ERROR);",
          "content_same": false
        },
        {
          "line": 3900,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "active_replicas.size()",
          "old_line_content": "    /** Trying to download these parts.",
          "new_line_content": "    LOG_INFO(log, \"Found \" << replicas.size() << \" replicas, \" << active_replicas.size() << \" of them are active.\"",
          "content_same": false
        },
        {
          "line": 3917,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "missing_parts.size()",
          "old_line_content": "        Strings parts_to_fetch;",
          "new_line_content": "            LOG_INFO(log, \"Some of parts (\" << missing_parts.size() << \") are missing. Will try to fetch covering parts.\");",
          "content_same": false
        },
        {
          "line": 3920,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Too many retries to fetch parts from \" + best_replica_path, ErrorCodes::TOO_MANY_RETRIES_TO_FETCH_PARTS)",
          "old_line_content": "        {",
          "new_line_content": "            throw Exception(\"Too many retries to fetch parts from \" + best_replica_path, ErrorCodes::TOO_MANY_RETRIES_TO_FETCH_PARTS);",
          "content_same": false
        },
        {
          "line": 3922,
          "old_api": null,
          "new_api": "getChildren",
          "old_text": null,
          "new_text": "getZooKeeper()->getChildren(best_replica_path + \"/parts\")",
          "old_line_content": "",
          "new_line_content": "        Strings parts = getZooKeeper()->getChildren(best_replica_path + \"/parts\");",
          "content_same": false
        },
        {
          "line": 3926,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "missing_parts.empty()",
          "old_line_content": "            {",
          "new_line_content": "        if (missing_parts.empty())",
          "content_same": false
        },
        {
          "line": 3935,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "parts_to_fetch_partition.push_back(part)",
          "old_line_content": "        }",
          "new_line_content": "                    parts_to_fetch_partition.push_back(part);",
          "content_same": false
        },
        {
          "line": 3938,
          "old_api": null,
          "new_api": "std::move(parts_to_fetch_partition)",
          "old_text": null,
          "new_text": "std::move(parts_to_fetch_partition)",
          "old_line_content": "            for (const String & missing_part : missing_parts)",
          "new_line_content": "            parts_to_fetch = std::move(parts_to_fetch_partition);",
          "content_same": false
        },
        {
          "line": 3947,
          "old_api": null,
          "new_api": "getContainingPart",
          "old_text": null,
          "new_text": "active_parts_set.getContainingPart(missing_part)",
          "old_line_content": "",
          "new_line_content": "                String containing_part = active_parts_set.getContainingPart(missing_part);",
          "content_same": false
        },
        {
          "line": 3949,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "parts_to_fetch.push_back(containing_part)",
          "old_line_content": "",
          "new_line_content": "                    parts_to_fetch.push_back(containing_part);",
          "content_same": false
        },
        {
          "line": 3951,
          "old_api": null,
          "new_api": "LOG_WARNING",
          "old_text": null,
          "new_text": "LOG_WARNING(log, \"Part \" << missing_part << \" on replica \" << best_replica_path << \" has been vanished.\")",
          "old_line_content": "        for (const String & part : parts_to_fetch)",
          "new_line_content": "                    LOG_WARNING(log, \"Part \" << missing_part << \" on replica \" << best_replica_path << \" has been vanished.\");",
          "content_same": false
        },
        {
          "line": 3957,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "missing_parts.clear()",
          "old_line_content": "            catch (const DB::Exception & e)",
          "new_line_content": "        missing_parts.clear();",
          "content_same": false
        },
        {
          "line": 3966,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "e.code()",
          "old_line_content": "",
          "new_line_content": "                if (e.code() != ErrorCodes::RECEIVED_ERROR_FROM_REMOTE_IO_SERVER && e.code() != ErrorCodes::RECEIVED_ERROR_TOO_MANY_REQUESTS)",
          "content_same": false
        },
        {
          "line": 3969,
          "old_api": null,
          "new_api": "displayText",
          "old_text": null,
          "new_text": "e.displayText()",
          "old_line_content": "}",
          "new_line_content": "                LOG_INFO(log, e.displayText());",
          "content_same": false
        },
        {
          "line": 3970,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "missing_parts.push_back(part)",
          "old_line_content": "",
          "new_line_content": "                missing_parts.push_back(part);",
          "content_same": false
        },
        {
          "line": 3975,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "missing_parts.empty()",
          "old_line_content": "}",
          "new_line_content": "    } while (!missing_parts.empty());",
          "content_same": false
        },
        {
          "line": 3981,
          "old_api": null,
          "new_api": "freezePartition",
          "old_text": null,
          "new_text": "data.freezePartition(partition, with_name, context)",
          "old_line_content": "    ///",
          "new_line_content": "    data.freezePartition(partition, with_name, context);",
          "content_same": false
        },
        {
          "line": 4052,
          "old_api": null,
          "new_api": "getZooKeeper",
          "old_text": null,
          "new_text": "getZooKeeper()",
          "old_line_content": "",
          "new_line_content": "        auto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 4055,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "zookeeper->get(mutations_path, &mutations_stat)",
          "old_line_content": "",
          "new_line_content": "        zookeeper->get(mutations_path, &mutations_stat);",
          "content_same": false
        },
        {
          "line": 4063,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(nullptr)",
          "old_line_content": "        zkutil::Responses responses;",
          "new_line_content": "        entry.create_time = time(nullptr);",
          "content_same": false
        },
        {
          "line": 4066,
          "old_api": null,
          "new_api": "String",
          "old_text": null,
          "new_text": "String()",
          "old_line_content": "        if (rc == ZooKeeperImpl::ZooKeeper::ZOK)",
          "new_line_content": "        requests.emplace_back(zkutil::makeSetRequest(mutations_path, String(), mutations_stat.version));",
          "content_same": false
        },
        {
          "line": 4067,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "zkutil::makeCreateRequest(\n            mutations_path + \"/\", entry.toString(), zkutil::CreateMode::PersistentSequential)",
          "old_line_content": "        {",
          "new_line_content": "        requests.emplace_back(zkutil::makeCreateRequest(",
          "content_same": false
        },
        {
          "line": 4068,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "entry.toString()",
          "old_line_content": "            const String & path_created =",
          "new_line_content": "            mutations_path + \"/\", entry.toString(), zkutil::CreateMode::PersistentSequential));",
          "content_same": false
        },
        {
          "line": 4077,
          "old_api": null,
          "new_api": "find_last_of",
          "old_text": null,
          "new_text": "path_created.find_last_of('/')",
          "old_line_content": "            continue;",
          "new_line_content": "            entry.znode_name = path_created.substr(path_created.find_last_of('/') + 1);",
          "content_same": false
        },
        {
          "line": 4078,
          "old_api": null,
          "new_api": "LOG_TRACE",
          "old_text": null,
          "new_text": "LOG_TRACE(log, \"Created mutation with id \" << entry.znode_name)",
          "old_line_content": "        }",
          "new_line_content": "            LOG_TRACE(log, \"Created mutation with id \" << entry.znode_name);",
          "content_same": false
        },
        {
          "line": 4083,
          "old_api": null,
          "new_api": "LOG_TRACE",
          "old_text": null,
          "new_text": "LOG_TRACE(log, \"Version conflict when trying to create a mutation node, retrying...\")",
          "old_line_content": "",
          "new_line_content": "            LOG_TRACE(log, \"Version conflict when trying to create a mutation node, retrying...\");",
          "content_same": false
        },
        {
          "line": 4087,
          "old_api": null,
          "new_api": "zkutil::KeeperException(\"Unable to create a mutation znode\", rc)",
          "old_text": null,
          "new_text": "zkutil::KeeperException(\"Unable to create a mutation znode\", rc)",
          "old_line_content": "}",
          "new_line_content": "            throw zkutil::KeeperException(\"Unable to create a mutation znode\", rc);",
          "content_same": false
        },
        {
          "line": 4093,
          "old_api": null,
          "new_api": "getMutationsStatus",
          "old_text": null,
          "new_text": "queue.getMutationsStatus()",
          "old_line_content": "",
          "new_line_content": "    return queue.getMutationsStatus();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 4097,
          "old_api": "grabOldParts",
          "new_api": null,
          "old_text": "data.grabOldParts()",
          "new_text": null,
          "old_line_content": "    MergeTreeData::DataPartsVector parts = data.grabOldParts();",
          "new_line_content": "void StorageReplicatedMergeTree::clearOldPartsAndRemoveFromZK()",
          "content_same": false
        },
        {
          "line": 4098,
          "old_api": "empty",
          "new_api": null,
          "old_text": "parts.empty()",
          "new_text": null,
          "old_line_content": "    if (parts.empty())",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4109,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "parts_to_delete_completely.emplace_back(part)",
          "new_text": null,
          "old_line_content": "            parts_to_delete_completely.emplace_back(part);",
          "new_line_content": "    MergeTreeData::DataPartsVector parts_to_delete_completely;              // All parts except duplicates",
          "content_same": false
        },
        {
          "line": 4111,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "parts_to_delete_only_from_filesystem.emplace_back(part)",
          "new_text": null,
          "old_line_content": "            parts_to_delete_only_from_filesystem.emplace_back(part);",
          "new_line_content": "    MergeTreeData::DataPartsVector parts_to_remove_from_filesystem;         // Parts removed from ZK",
          "content_same": false
        },
        {
          "line": 4113,
          "old_api": "clear",
          "new_api": null,
          "old_text": "parts.clear()",
          "new_text": null,
          "old_line_content": "    parts.clear();",
          "new_line_content": "    for (const auto & part : parts)",
          "content_same": false
        },
        {
          "line": 4121,
          "old_api": "remove",
          "new_api": null,
          "old_text": "part->remove()",
          "new_text": null,
          "old_line_content": "                part->remove();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4125,
          "old_api": "tryLogCurrentException",
          "new_api": null,
          "old_text": "tryLogCurrentException(log, \"There is a problem with deleting part \" + part->name + \" from filesystem\")",
          "new_text": null,
          "old_line_content": "                tryLogCurrentException(log, \"There is a problem with deleting part \" + part->name + \" from filesystem\");",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 4131,
          "old_api": "empty",
          "new_api": null,
          "old_text": "parts_to_delete_only_from_filesystem.empty()",
          "new_text": null,
          "old_line_content": "    if (!parts_to_delete_only_from_filesystem.empty())",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 4133,
          "old_api": "remove_parts_from_filesystem",
          "new_api": null,
          "old_text": "remove_parts_from_filesystem(parts_to_delete_only_from_filesystem)",
          "new_text": null,
          "old_line_content": "        remove_parts_from_filesystem(parts_to_delete_only_from_filesystem);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 4134,
          "old_api": "removePartsFinally",
          "new_api": null,
          "old_text": "data.removePartsFinally(parts_to_delete_only_from_filesystem)",
          "new_text": null,
          "old_line_content": "        data.removePartsFinally(parts_to_delete_only_from_filesystem);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 4136,
          "old_api": "size",
          "new_api": null,
          "old_text": "parts_to_delete_only_from_filesystem.size()",
          "new_text": null,
          "old_line_content": "        LOG_DEBUG(log, \"Removed \" << parts_to_delete_only_from_filesystem.size() << \" old duplicate parts\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4145,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "part_names_to_delete_completely.emplace_back(part->name)",
          "new_text": null,
          "old_line_content": "            part_names_to_delete_completely.emplace_back(part->name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4147,
          "old_api": "size",
          "new_api": null,
          "old_text": "parts_to_delete_completely.size()",
          "new_text": null,
          "old_line_content": "        LOG_DEBUG(log, \"Removing \" << parts_to_delete_completely.size() << \" old parts from ZooKeeper\");",
          "new_line_content": "    NameSet part_names_to_retry_deletion;",
          "content_same": false
        },
        {
          "line": 4148,
          "old_api": "removePartsFromZooKeeper",
          "new_api": null,
          "old_text": "removePartsFromZooKeeper(zookeeper, part_names_to_delete_completely, &part_names_to_retry_deletion)",
          "new_text": null,
          "old_line_content": "        removePartsFromZooKeeper(zookeeper, part_names_to_delete_completely, &part_names_to_retry_deletion);",
          "new_line_content": "    try",
          "content_same": false
        },
        {
          "line": 4156,
          "old_api": "size",
          "new_api": null,
          "old_text": "part_names_to_retry_deletion.size()",
          "new_text": null,
          "old_line_content": "    auto num_reliably_deleted_parts = parts_to_delete_completely.size() - part_names_to_retry_deletion.size();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4157,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Removed \" << num_reliably_deleted_parts << \" old parts from ZooKeeper. Removing them from filesystem.\")",
          "new_text": null,
          "old_line_content": "    LOG_DEBUG(log, \"Removed \" << num_reliably_deleted_parts << \" old parts from ZooKeeper. Removing them from filesystem.\");",
          "new_line_content": "    catch (...)",
          "content_same": false
        },
        {
          "line": 4162,
          "old_api": "count",
          "new_api": null,
          "old_text": "part_names_to_retry_deletion.count(part->name)",
          "new_text": null,
          "old_line_content": "        if (part_names_to_retry_deletion.count(part->name) == 0)",
          "new_line_content": "    /// Part names that were reliably deleted from ZooKeeper should be deleted from filesystem",
          "content_same": false
        },
        {
          "line": 4165,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "parts_to_retry_deletion.emplace_back(part)",
          "new_text": null,
          "old_line_content": "            parts_to_retry_deletion.emplace_back(part);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4171,
          "old_api": "rollbackDeletingParts",
          "new_api": null,
          "old_text": "data.rollbackDeletingParts(parts_to_retry_deletion)",
          "new_text": null,
          "old_line_content": "        data.rollbackDeletingParts(parts_to_retry_deletion);",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 4181,
          "old_api": "size",
          "new_api": null,
          "old_text": "parts_to_remove_from_filesystem.size()",
          "new_text": null,
          "old_line_content": "        LOG_DEBUG(log, \"Removed \" << parts_to_remove_from_filesystem.size() << \" old parts\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4190,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "part_names_to_remove.emplace_back(part->name)",
          "new_text": null,
          "old_line_content": "        part_names_to_remove.emplace_back(part->name);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 4192,
          "old_api": "tryRemovePartsFromZooKeeperWithRetries",
          "new_api": null,
          "old_text": "tryRemovePartsFromZooKeeperWithRetries(part_names_to_remove, max_retries)",
          "new_text": null,
          "old_line_content": "    return tryRemovePartsFromZooKeeperWithRetries(part_names_to_remove, max_retries);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4205,
          "old_api": "size",
          "new_api": null,
          "old_text": "part_names.size()",
          "new_text": null,
          "old_line_content": "        futures.reserve(part_names.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4217,
          "old_api": "removePartFromZooKeeper",
          "new_api": null,
          "old_text": "removePartFromZooKeeper(part_name, ops)",
          "new_text": null,
          "old_line_content": "                removePartFromZooKeeper(part_name, ops);",
          "new_line_content": "        try",
          "content_same": false
        },
        {
          "line": 4229,
          "old_api": "zkutil::isHardwareError(response.error)",
          "new_api": null,
          "old_text": "zkutil::isHardwareError(response.error)",
          "new_text": null,
          "old_line_content": "                if (zkutil::isHardwareError(response.error))",
          "new_line_content": "            for (auto & future : futures)",
          "content_same": false
        },
        {
          "line": 4235,
          "old_api": "ZooKeeperImpl::Exception(response.error)",
          "new_api": null,
          "old_text": "ZooKeeperImpl::Exception(response.error)",
          "new_text": null,
          "old_line_content": "                throw ZooKeeperImpl::Exception(response.error);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4243,
          "old_api": "tryLogCurrentException",
          "new_api": null,
          "old_text": "tryLogCurrentException(log, __PRETTY_FUNCTION__)",
          "new_text": null,
          "old_line_content": "                tryLogCurrentException(log, __PRETTY_FUNCTION__);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 4260,
          "old_api": "cbegin",
          "new_api": null,
          "old_text": "part_names.cbegin()",
          "new_text": null,
          "old_line_content": "    auto it_first_node_in_batch = part_names.cbegin();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 4262,
          "old_api": "cend",
          "new_api": null,
          "old_text": "part_names.cend()",
          "new_text": null,
          "old_line_content": "    for (auto it = part_names.cbegin(); it != part_names.cend(); ++it)",
          "new_line_content": "/// TODO: rewrite this code using async Multi ops after final ZooKeeper library update",
          "content_same": false
        },
        {
          "line": 4264,
          "old_api": "removePartFromZooKeeper",
          "new_api": null,
          "old_text": "removePartFromZooKeeper(*it, ops)",
          "new_text": null,
          "old_line_content": "        removePartFromZooKeeper(*it, ops);",
          "new_line_content": "                                                          NameSet * parts_should_be_retried)",
          "content_same": false
        },
        {
          "line": 4266,
          "old_api": "std::next(it)",
          "new_api": null,
          "old_text": "std::next(it)",
          "new_text": null,
          "old_line_content": "        auto it_next = std::next(it);",
          "new_line_content": "    zkutil::Requests ops;",
          "content_same": false
        },
        {
          "line": 4270,
          "old_api": "tryMultiNoThrow",
          "new_api": null,
          "old_text": "zookeeper->tryMultiNoThrow(ops, unused_responses)",
          "new_text": null,
          "old_line_content": "            auto code = zookeeper->tryMultiNoThrow(ops, unused_responses);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 4276,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"There are no some part nodes in ZooKeeper, will remove part nodes sequentially\")",
          "new_text": null,
          "old_line_content": "                LOG_DEBUG(log, \"There are no some part nodes in ZooKeeper, will remove part nodes sequentially\");",
          "new_line_content": "            zkutil::Responses unused_responses;",
          "content_same": false
        },
        {
          "line": 4281,
          "old_api": "removePartFromZooKeeper",
          "new_api": null,
          "old_text": "removePartFromZooKeeper(*it_in_batch, cur_ops)",
          "new_text": null,
          "old_line_content": "                    removePartFromZooKeeper(*it_in_batch, cur_ops);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 4282,
          "old_api": "tryMultiNoThrow",
          "new_api": null,
          "old_text": "zookeeper->tryMultiNoThrow(cur_ops, unused_responses)",
          "new_text": null,
          "old_line_content": "                    auto cur_code = zookeeper->tryMultiNoThrow(cur_ops, unused_responses);",
          "new_line_content": "                /// Fallback",
          "content_same": false
        },
        {
          "line": 4286,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"There is no part \" << *it_in_batch << \" in ZooKeeper, it was only in filesystem\")",
          "new_text": null,
          "old_line_content": "                        LOG_DEBUG(log, \"There is no part \" << *it_in_batch << \" in ZooKeeper, it was only in filesystem\");",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 4290,
          "old_api": "emplace",
          "new_api": null,
          "old_text": "parts_should_be_retried->emplace(*it_in_batch)",
          "new_text": null,
          "old_line_content": "                        parts_should_be_retried->emplace(*it_in_batch);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4294,
          "old_api": "zkutil::ZooKeeper::error2string(cur_code)",
          "new_api": null,
          "old_text": "zkutil::ZooKeeper::error2string(cur_code)",
          "new_text": null,
          "old_line_content": "                        LOG_WARNING(log, \"Cannot remove part \" << *it_in_batch << \" from ZooKeeper: \" << zkutil::ZooKeeper::error2string(cur_code));",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 4298,
          "old_api": "zkutil::isHardwareError(code)",
          "new_api": null,
          "old_text": "zkutil::isHardwareError(code)",
          "new_text": null,
          "old_line_content": "            else if (parts_should_be_retried && zkutil::isHardwareError(code))",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 4306,
          "old_api": "::zkutil::ZooKeeper::error2string(code)",
          "new_api": null,
          "old_text": "::zkutil::ZooKeeper::error2string(code)",
          "new_text": null,
          "old_line_content": "                    << \" nodes from ZooKeeper: \" << ::zkutil::ZooKeeper::error2string(code));",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 4319,
          "old_api": "tryGetChildren",
          "new_api": null,
          "old_text": "zookeeper.tryGetChildren(zookeeper_path + \"/blocks\", blocks)",
          "new_text": null,
          "old_line_content": "    if (zookeeper.tryGetChildren(zookeeper_path + \"/blocks\", blocks))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 4320,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(zookeeper_path + \"/blocks doesn't exist\", ErrorCodes::NOT_FOUND_NODE)",
          "new_text": null,
          "old_line_content": "        throw Exception(zookeeper_path + \"/blocks doesn't exist\", ErrorCodes::NOT_FOUND_NODE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4329,
          "old_api": "asyncTryGet",
          "new_api": null,
          "old_text": "zookeeper.asyncTryGet(path)",
          "new_text": null,
          "old_line_content": "            get_futures.emplace_back(path, zookeeper.asyncTryGet(path));",
          "new_line_content": "    String partition_prefix = partition_id + \"_\";",
          "content_same": false
        },
        {
          "line": 2289,
          "old_api": "exists",
          "new_api": null,
          "old_text": "zookeeper->exists(replica_path + \"/parts/\" + part->name)",
          "new_text": null,
          "old_line_content": "        if (!zookeeper->exists(replica_path + \"/parts/\" + part->name))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4337,
          "old_api": "get",
          "new_api": null,
          "old_text": "pair.second.get()",
          "new_text": null,
          "old_line_content": "        auto result = pair.second.get();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2293,
          "old_api": "time",
          "new_api": null,
          "old_text": "time(nullptr)",
          "new_text": null,
          "old_line_content": "            if (part->modification_time + MAX_AGE_OF_LOCAL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < time(nullptr))",
          "new_line_content": "        /// If there is no information about part in ZK, we will not merge it.",
          "content_same": false
        },
        {
          "line": 2295,
          "old_api": "LOG_WARNING",
          "new_api": null,
          "old_text": "LOG_WARNING(log, \"Part \" << part->name << \" (that was selected for merge)\"\n                    << \" with age \" << (time(nullptr) - part->modification_time)\n                    << \" seconds exists locally but not in ZooKeeper.\"\n                    << \" Won't do merge with that part and will check it.\")",
          "new_text": null,
          "old_line_content": "                LOG_WARNING(log, \"Part \" << part->name << \" (that was selected for merge)\"",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2296,
          "old_api": "time",
          "new_api": null,
          "old_text": "time(nullptr)",
          "new_text": null,
          "old_line_content": "                    << \" with age \" << (time(nullptr) - part->modification_time)",
          "new_line_content": "            all_in_zk = false;",
          "content_same": false
        },
        {
          "line": 4346,
          "old_api": "asyncTryRemove",
          "new_api": null,
          "old_text": "zookeeper.asyncTryRemove(path)",
          "new_text": null,
          "old_line_content": "            to_delete_futures.emplace_back(path, zookeeper.asyncTryRemove(path));",
          "new_line_content": "        if (result.error == ZooKeeperImpl::ZooKeeper::ZNONODE)",
          "content_same": false
        },
        {
          "line": 4352,
          "old_api": "get",
          "new_api": null,
          "old_text": "pair.second.get()",
          "new_text": null,
          "old_line_content": "        int32_t rc = pair.second.get().error;",
          "new_line_content": "        if (!parsed || (min_block_num <= block_num && block_num <= max_block_num))",
          "content_same": false
        },
        {
          "line": 4356,
          "old_api": "removeRecursive",
          "new_api": null,
          "old_text": "zookeeper.removeRecursive(path)",
          "new_text": null,
          "old_line_content": "            zookeeper.removeRecursive(path);",
          "new_line_content": "    for (auto & pair : to_delete_futures)",
          "content_same": false
        },
        {
          "line": 2311,
          "old_api": "time",
          "new_api": null,
          "old_text": "time(nullptr)",
          "new_text": null,
          "old_line_content": "    entry.create_time = time(nullptr);",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 4360,
          "old_api": "zkutil::ZooKeeper::error2string(rc)",
          "new_api": null,
          "old_text": "zkutil::ZooKeeper::error2string(rc)",
          "new_text": null,
          "old_line_content": "                \"Error while deleting ZooKeeper path `\" << path << \"`: \" + zkutil::ZooKeeper::error2string(rc) << \", ignoring.\");",
          "new_line_content": "        if (rc == ZooKeeperImpl::ZooKeeper::ZNOTEMPTY)",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "entry.source_parts.push_back(part->name)",
          "new_text": null,
          "old_line_content": "        entry.source_parts.push_back(part->name);",
          "new_line_content": "    entry.type = LogEntry::MERGE_PARTS;",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": "toString",
          "new_api": null,
          "old_text": "entry.toString()",
          "new_text": null,
          "old_line_content": "    String path_created = zookeeper->create(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential);",
          "new_line_content": "    entry.new_part_name = merged_name;",
          "content_same": false
        },
        {
          "line": 2317,
          "old_api": "find_last_of",
          "new_api": null,
          "old_text": "path_created.find_last_of('/')",
          "new_text": null,
          "old_line_content": "    entry.znode_name = path_created.substr(path_created.find_last_of('/') + 1);",
          "new_line_content": "    entry.deduplicate = deduplicate;",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": "size",
          "new_api": null,
          "old_text": "parts.size()",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i + 1 < parts.size(); ++i)",
          "new_line_content": "    for (const auto & part : parts)",
          "content_same": false
        },
        {
          "line": 4369,
          "old_api": "lockStructure",
          "new_api": null,
          "old_text": "lockStructure(false, __PRETTY_FUNCTION__)",
          "new_text": null,
          "old_line_content": "    auto lock1 = lockStructure(false, __PRETTY_FUNCTION__);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2325,
          "old_api": "padIndex",
          "new_api": null,
          "old_text": "padIndex(number)",
          "new_text": null,
          "old_line_content": "            zookeeper->tryRemove(zookeeper_path + \"/block_numbers/\" + partition_id + \"/block-\" + padIndex(number));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4373,
          "old_api": "checkStructureAndGetMergeTreeData",
          "new_api": null,
          "old_text": "data.checkStructureAndGetMergeTreeData(source_table)",
          "new_text": null,
          "old_line_content": "    MergeTreeData * src_data = data.checkStructureAndGetMergeTreeData(source_table);",
          "new_line_content": "void StorageReplicatedMergeTree::replacePartitionFrom(const StoragePtr & source_table, const ASTPtr & partition, bool replace,",
          "content_same": false
        },
        {
          "line": 4374,
          "old_api": "getPartitionIDFromQuery",
          "new_api": null,
          "old_text": "data.getPartitionIDFromQuery(partition, context)",
          "new_text": null,
          "old_line_content": "    String partition_id = data.getPartitionIDFromQuery(partition, context);",
          "new_line_content": "                                                      const Context & context)",
          "content_same": false
        },
        {
          "line": 2338,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "    auto zookeeper = getZooKeeper();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4386,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "    auto zookeeper = getZooKeeper();",
          "new_line_content": "    Strings block_id_paths;",
          "content_same": false
        },
        {
          "line": 2341,
          "old_api": "exists",
          "new_api": null,
          "old_text": "zookeeper->exists(replica_path + \"/parts/\" + part.name)",
          "new_text": null,
          "old_line_content": "    if (!zookeeper->exists(replica_path + \"/parts/\" + part.name))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2343,
          "old_api": "time",
          "new_api": null,
          "old_text": "time(nullptr)",
          "new_text": null,
          "old_line_content": "        if (part.modification_time + MAX_AGE_OF_LOCAL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < time(nullptr))",
          "new_line_content": "bool StorageReplicatedMergeTree::createLogEntryToMutatePart(const MergeTreeDataPart & part, Int64 mutation_version)",
          "content_same": false
        },
        {
          "line": 2346,
          "old_api": "time",
          "new_api": null,
          "old_text": "time(nullptr)",
          "new_text": null,
          "old_line_content": "                << \" with age \" << (time(nullptr) - part.modification_time)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4395,
          "old_api": "std::numeric_limits<decltype(drop_range.level)>::max()",
          "new_api": null,
          "old_text": "std::numeric_limits<decltype(drop_range.level)>::max()",
          "new_text": null,
          "old_line_content": "    drop_range.level = std::numeric_limits<decltype(drop_range.level)>::max();",
          "new_line_content": "    /// Firstly, generate last block number and compute drop_range",
          "content_same": false
        },
        {
          "line": 2349,
          "old_api": "enqueuePartForCheck",
          "new_api": null,
          "old_text": "enqueuePartForCheck(part.name)",
          "new_text": null,
          "old_line_content": "            enqueuePartForCheck(part.name);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 4397,
          "old_api": "getPartNamePossiblyFake",
          "new_api": null,
          "old_text": "getPartNamePossiblyFake(data.format_version, drop_range)",
          "new_text": null,
          "old_line_content": "    String drop_range_fake_part_name = getPartNamePossiblyFake(data.format_version, drop_range);",
          "new_line_content": "    /// So, such case has special meaning, if drop_range contains only one block it means that nothing to drop.",
          "content_same": false
        },
        {
          "line": 4399,
          "old_api": "getBlocksCount",
          "new_api": null,
          "old_text": "drop_range.getBlocksCount()",
          "new_text": null,
          "old_line_content": "    if (drop_range.getBlocksCount() > 1)",
          "new_line_content": "    drop_range.partition_id = partition_id;",
          "content_same": false
        },
        {
          "line": 2358,
          "old_api": "getNewName",
          "new_api": null,
          "old_text": "part.getNewName(new_part_info)",
          "new_text": null,
          "old_line_content": "    String new_part_name = part.getNewName(new_part_info);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4410,
          "old_api": "disableMergesInRange",
          "new_api": null,
          "old_text": "queue.disableMergesInRange(drop_range_fake_part_name)",
          "new_text": null,
          "old_line_content": "            queue.disableMergesInRange(drop_range_fake_part_name);",
          "new_line_content": "        /// It is better to prohibit them on leader replica (like DROP PARTITION makes),",
          "content_same": false
        },
        {
          "line": 2363,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "entry.source_parts.push_back(part.name)",
          "new_text": null,
          "old_line_content": "    entry.source_parts.push_back(part.name);",
          "new_line_content": "    new_part_info.mutation = mutation_version;",
          "content_same": false
        },
        {
          "line": 4414,
          "old_api": "size",
          "new_api": null,
          "old_text": "src_all_parts.size()",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < src_all_parts.size(); ++i)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2367,
          "old_api": "toString",
          "new_api": null,
          "old_text": "entry.toString()",
          "new_text": null,
          "old_line_content": "    zookeeper->create(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential);",
          "new_line_content": "    ReplicatedMergeTreeLogEntryData entry;",
          "content_same": false
        },
        {
          "line": 2376,
          "old_api": "zkutil::makeRemoveRequest(part_path + \"/checksums\", -1)",
          "new_api": null,
          "old_text": "zkutil::makeRemoveRequest(part_path + \"/checksums\", -1)",
          "new_text": null,
          "old_line_content": "    ops.emplace_back(zkutil::makeRemoveRequest(part_path + \"/checksums\", -1));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2377,
          "old_api": "zkutil::makeRemoveRequest(part_path + \"/columns\", -1)",
          "new_api": null,
          "old_text": "zkutil::makeRemoveRequest(part_path + \"/columns\", -1)",
          "new_text": null,
          "old_line_content": "    ops.emplace_back(zkutil::makeRemoveRequest(part_path + \"/columns\", -1));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2378,
          "old_api": "zkutil::makeRemoveRequest(part_path, -1)",
          "new_api": null,
          "old_text": "zkutil::makeRemoveRequest(part_path, -1)",
          "new_text": null,
          "old_line_content": "    ops.emplace_back(zkutil::makeRemoveRequest(part_path, -1));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4424,
          "old_api": "allocateBlockNumber",
          "new_api": null,
          "old_text": "allocateBlockNumber(partition_id, zookeeper, block_id_path)",
          "new_text": null,
          "old_line_content": "        auto lock = allocateBlockNumber(partition_id, zookeeper, block_id_path);",
          "new_line_content": "        /// Assume that merges in the partiton are quite rare",
          "content_same": false
        },
        {
          "line": 4427,
          "old_api": "LOG_INFO",
          "new_api": null,
          "old_text": "LOG_INFO(log, \"Part \" << src_part->name << \" (hash \" << hash_hex << \") has been already attached\")",
          "new_text": null,
          "old_line_content": "            LOG_INFO(log, \"Part \" << src_part->name << \" (hash \" << hash_hex << \") has been already attached\");",
          "new_line_content": "        auto & src_part = src_all_parts[i];",
          "content_same": false
        },
        {
          "line": 4433,
          "old_api": "cloneAndLoadDataPart",
          "new_api": null,
          "old_text": "data.cloneAndLoadDataPart(src_part, TMP_PREFIX, dst_part_info)",
          "new_text": null,
          "old_line_content": "        auto dst_part = data.cloneAndLoadDataPart(src_part, TMP_PREFIX, dst_part_info);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 4435,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "src_parts.emplace_back(src_part)",
          "new_text": null,
          "old_line_content": "        src_parts.emplace_back(src_part);",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 2388,
          "old_api": "std::make_shared<LogEntry>()",
          "new_api": null,
          "old_text": "std::make_shared<LogEntry>()",
          "new_text": null,
          "old_line_content": "    LogEntryPtr log_entry = std::make_shared<LogEntry>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4436,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "dst_parts.emplace_back(dst_part)",
          "new_text": null,
          "old_line_content": "        dst_parts.emplace_back(dst_part);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": "tryGetPartCreateTime",
          "new_api": null,
          "old_text": "tryGetPartCreateTime(zookeeper, replica_path, part_name)",
          "new_text": null,
          "old_line_content": "    log_entry->create_time = tryGetPartCreateTime(zookeeper, replica_path, part_name);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4437,
          "old_api": "std::move(*lock)",
          "new_api": null,
          "old_text": "std::move(*lock)",
          "new_text": null,
          "old_line_content": "        abandonable_locks.emplace_back(std::move(*lock));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4439,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "part_checksums.emplace_back(hash_hex)",
          "new_text": null,
          "old_line_content": "        part_checksums.emplace_back(hash_hex);",
          "new_line_content": "        MergeTreePartInfo dst_part_info(partition_id, index, index, src_part->info.level);",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": "toString",
          "new_api": null,
          "old_text": "log_entry->toString()",
          "new_text": null,
          "old_line_content": "        replica_path + \"/queue/queue-\", log_entry->toString(),",
          "new_line_content": "    log_entry->type = LogEntry::GET_PART;",
          "content_same": false
        },
        {
          "line": 2399,
          "old_api": "removePartFromZooKeeper",
          "new_api": null,
          "old_text": "removePartFromZooKeeper(part_name, ops)",
          "new_text": null,
          "old_line_content": "    removePartFromZooKeeper(part_name, ops);",
          "new_line_content": "    log_entry->new_part_name = part_name;",
          "content_same": false
        },
        {
          "line": 4447,
          "old_api": "std::make_shared<ReplicatedMergeTreeLogEntryData::ReplaceRangeEntry>()",
          "new_api": null,
          "old_text": "std::make_shared<ReplicatedMergeTreeLogEntryData::ReplaceRangeEntry>()",
          "new_text": null,
          "old_line_content": "        entry.replace_range_entry = std::make_shared<ReplicatedMergeTreeLogEntryData::ReplaceRangeEntry>();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": "multi",
          "new_api": null,
          "old_text": "zookeeper->multi(ops)",
          "new_text": null,
          "old_line_content": "    auto results = zookeeper->multi(ops);",
          "new_line_content": "    zkutil::Requests ops;",
          "content_same": false
        },
        {
          "line": 2404,
          "old_api": "find_last_of",
          "new_api": null,
          "old_text": "path_created.find_last_of('/')",
          "new_text": null,
          "old_line_content": "    log_entry->znode_name = path_created.substr(path_created.find_last_of('/') + 1);",
          "new_line_content": "        zkutil::CreateMode::PersistentSequential));",
          "content_same": false
        },
        {
          "line": 2405,
          "old_api": "insert",
          "new_api": null,
          "old_text": "queue.insert(zookeeper, log_entry)",
          "new_text": null,
          "old_line_content": "    queue.insert(zookeeper, log_entry);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4456,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "entry_replace.new_part_names.emplace_back(part->name)",
          "new_text": null,
          "old_line_content": "            entry_replace.new_part_names.emplace_back(part->name);",
          "new_line_content": "        auto & entry_replace = *entry.replace_range_entry;",
          "content_same": false
        },
        {
          "line": 4458,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "entry_replace.part_names_checksums.emplace_back(checksum)",
          "new_text": null,
          "old_line_content": "            entry_replace.part_names_checksums.emplace_back(checksum);",
          "new_line_content": "        entry_replace.from_database = src_data->database_name;",
          "content_same": false
        },
        {
          "line": 2413,
          "old_api": "CurrentMetrics::add(CurrentMetrics::LeaderReplica)",
          "new_api": null,
          "old_text": "CurrentMetrics::add(CurrentMetrics::LeaderReplica)",
          "new_text": null,
          "old_line_content": "        CurrentMetrics::add(CurrentMetrics::LeaderReplica);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2414,
          "old_api": "LOG_INFO",
          "new_api": null,
          "old_text": "LOG_INFO(log, \"Became leader\")",
          "new_text": null,
          "old_line_content": "        LOG_INFO(log, \"Became leader\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2417,
          "old_api": "activate",
          "new_api": null,
          "old_text": "merge_selecting_task->activate()",
          "new_text": null,
          "old_line_content": "        merge_selecting_task->activate();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2418,
          "old_api": "schedule",
          "new_api": null,
          "old_text": "merge_selecting_task->schedule()",
          "new_text": null,
          "old_line_content": "        merge_selecting_task->schedule();",
          "new_line_content": "    auto callback = [this]()",
          "content_same": false
        },
        {
          "line": 4467,
          "old_api": "clearBlocksInPartition",
          "new_api": null,
          "old_text": "clearBlocksInPartition(*zookeeper, drop_range.partition_id, drop_range.max_block, drop_range.max_block)",
          "new_text": null,
          "old_line_content": "        clearBlocksInPartition(*zookeeper, drop_range.partition_id, drop_range.max_block, drop_range.max_block);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": "getSchedulePool",
          "new_api": null,
          "old_text": "std::make_shared<zkutil::LeaderElection>(\n            context.getSchedulePool(),\n            zookeeper_path + \"/leader_election\",\n            *current_zookeeper,    /// current_zookeeper lives for the lifetime of leader_election,\n                                   ///  since before changing `current_zookeeper`, `leader_election` object is destroyed in `partialShutdown` method.\n            callback,\n            replica_name)",
          "new_text": null,
          "old_line_content": "        leader_election = std::make_shared<zkutil::LeaderElection>(",
          "new_line_content": "        is_leader = true;",
          "content_same": false
        },
        {
          "line": 4475,
          "old_api": "size",
          "new_api": null,
          "old_text": "dst_parts.size()",
          "new_text": null,
          "old_line_content": "        for (size_t i = 0; i < dst_parts.size(); ++i)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4477,
          "old_api": "getCommitPartOps",
          "new_api": null,
          "old_text": "getCommitPartOps(ops, dst_parts[i], block_id_paths[i])",
          "new_text": null,
          "old_line_content": "            getCommitPartOps(ops, dst_parts[i], block_id_paths[i]);",
          "new_line_content": "    zkutil::Responses op_results;",
          "content_same": false
        },
        {
          "line": 4478,
          "old_api": "getUnlockOps",
          "new_api": null,
          "old_text": "abandonable_locks[i].getUnlockOps(ops)",
          "new_text": null,
          "old_line_content": "            abandonable_locks[i].getUnlockOps(ops);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4480,
          "old_api": "size",
          "new_api": null,
          "old_text": "ops.size()",
          "new_text": null,
          "old_line_content": "            if (ops.size() > zkutil::MULTI_BATCH_SIZE)",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 4483,
          "old_api": "multi",
          "new_api": null,
          "old_text": "zookeeper->multi(ops)",
          "new_text": null,
          "old_line_content": "                zookeeper->multi(ops);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 4488,
          "old_api": "toString",
          "new_api": null,
          "old_text": "entry.toString()",
          "new_text": null,
          "old_line_content": "        ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential));",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 4492,
          "old_api": "lockParts",
          "new_api": null,
          "old_text": "data.lockParts()",
          "new_text": null,
          "old_line_content": "            auto data_parts_lock = data.lockParts();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": "shutdown",
          "new_api": null,
          "old_text": "leader_election->shutdown()",
          "new_text": null,
          "old_line_content": "    leader_election->shutdown();",
          "new_line_content": "void StorageReplicatedMergeTree::exitLeaderElection()",
          "content_same": false
        },
        {
          "line": 2449,
          "old_api": "CurrentMetrics::sub(CurrentMetrics::LeaderReplica)",
          "new_api": null,
          "old_text": "CurrentMetrics::sub(CurrentMetrics::LeaderReplica)",
          "new_text": null,
          "old_line_content": "        CurrentMetrics::sub(CurrentMetrics::LeaderReplica);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2450,
          "old_api": "LOG_INFO",
          "new_api": null,
          "old_text": "LOG_INFO(log, \"Stopped being leader\")",
          "new_text": null,
          "old_line_content": "        LOG_INFO(log, \"Stopped being leader\");",
          "new_line_content": "    /// Shut down the leader election thread to avoid suddenly becoming the leader again after",
          "content_same": false
        },
        {
          "line": 4498,
          "old_api": "multi",
          "new_api": null,
          "old_text": "zookeeper->multi(ops)",
          "new_text": null,
          "old_line_content": "        op_results = zookeeper->multi(ops);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2453,
          "old_api": "deactivate",
          "new_api": null,
          "old_text": "merge_selecting_task->deactivate()",
          "new_text": null,
          "old_line_content": "        merge_selecting_task->deactivate();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4501,
          "old_api": "lockParts",
          "new_api": null,
          "old_text": "data.lockParts()",
          "new_text": null,
          "old_line_content": "            auto data_parts_lock = data.lockParts();",
          "new_line_content": "            for (MergeTreeData::MutableDataPartPtr & part : dst_parts)",
          "content_same": false
        },
        {
          "line": 4503,
          "old_api": "commit",
          "new_api": null,
          "old_text": "transaction.commit(&data_parts_lock)",
          "new_text": null,
          "old_line_content": "            transaction.commit(&data_parts_lock);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2464,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "    auto zookeeper = getZooKeeper();",
          "new_line_content": "    /// replica assigns merges at any given time.",
          "content_same": false
        },
        {
          "line": 2465,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "zookeeper->getChildren(zookeeper_path + \"/replicas\")",
          "new_text": null,
          "old_line_content": "    Strings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "new_line_content": "    leader_election = nullptr;",
          "content_same": false
        },
        {
          "line": 2468,
          "old_api": "end",
          "new_api": null,
          "old_text": "replicas.end()",
          "new_text": null,
          "old_line_content": "    std::shuffle(replicas.begin(), replicas.end(), rng);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4516,
          "old_api": "back",
          "new_api": null,
          "old_text": "op_results.back()",
          "new_text": null,
          "old_line_content": "    String log_znode_path = dynamic_cast<const zkutil::CreateResponse &>(*op_results.back()).path_created;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4517,
          "old_api": "find_last_of",
          "new_api": null,
          "old_text": "log_znode_path.find_last_of('/')",
          "new_text": null,
          "old_line_content": "    entry.znode_name = log_znode_path.substr(log_znode_path.find_last_of('/') + 1);",
          "new_line_content": "    catch (...)",
          "content_same": false
        },
        {
          "line": 4520,
          "old_api": "assumeUnlocked",
          "new_api": null,
          "old_text": "lock.assumeUnlocked()",
          "new_text": null,
          "old_line_content": "        lock.assumeUnlocked();",
          "new_line_content": "        throw;",
          "content_same": false
        },
        {
          "line": 2476,
          "old_api": "exists",
          "new_api": null,
          "old_text": "zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/parts/\" + part_name)",
          "new_text": null,
          "old_line_content": "        if (zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/parts/\" + part_name) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2477,
          "old_api": "exists",
          "new_api": null,
          "old_text": "zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")",
          "new_text": null,
          "old_line_content": "            (!active || zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")))",
          "new_line_content": "    for (const String & replica : replicas)",
          "content_same": false
        },
        {
          "line": 4526,
          "old_api": "clear",
          "new_api": null,
          "old_text": "parts_to_remove.clear()",
          "new_text": null,
          "old_line_content": "    parts_to_remove.clear();",
          "new_line_content": "    for (auto & lock : abandonable_locks)",
          "content_same": false
        },
        {
          "line": 4531,
          "old_api": "waitForAllReplicasToProcessLogEntry",
          "new_api": null,
          "old_text": "waitForAllReplicasToProcessLogEntry(entry)",
          "new_text": null,
          "old_line_content": "        waitForAllReplicasToProcessLogEntry(entry);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2489,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "    auto zookeeper = getZooKeeper();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2490,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "zookeeper->getChildren(zookeeper_path + \"/replicas\")",
          "new_text": null,
          "old_line_content": "    Strings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "new_line_content": "    return {};",
          "content_same": false
        },
        {
          "line": 2493,
          "old_api": "end",
          "new_api": null,
          "old_text": "replicas.end()",
          "new_text": null,
          "old_line_content": "    std::shuffle(replicas.begin(), replicas.end(), rng);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4541,
          "old_api": "empty",
          "new_api": null,
          "old_text": "block_id_path.empty()",
          "new_text": null,
          "old_line_content": "    if (!block_id_path.empty())",
          "new_line_content": "void StorageReplicatedMergeTree::getCommitPartOps(",
          "content_same": false
        },
        {
          "line": 4544,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "ops.emplace_back(\n            zkutil::makeCreateRequest(\n                block_id_path,\n                part_name,  /// We will be able to know original part number for duplicate blocks, if we want.\n                zkutil::CreateMode::Persistent))",
          "new_text": null,
          "old_line_content": "        ops.emplace_back(",
          "new_line_content": "    const String & block_id_path) const",
          "content_same": false
        },
        {
          "line": 4545,
          "old_api": "zkutil::makeCreateRequest(\n                block_id_path,\n                part_name,  /// We will be able to know original part number for duplicate blocks, if we want.\n                zkutil::CreateMode::Persistent)",
          "new_api": null,
          "old_text": "zkutil::makeCreateRequest(\n                block_id_path,\n                part_name,  /// We will be able to know original part number for duplicate blocks, if we want.\n                zkutil::CreateMode::Persistent)",
          "new_text": null,
          "old_line_content": "            zkutil::makeCreateRequest(",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "zookeeper->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/parts\")",
          "new_text": null,
          "old_line_content": "        Strings parts = zookeeper->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/parts\");",
          "new_line_content": "        if (replica == replica_name)",
          "content_same": false
        },
        {
          "line": 4553,
          "old_api": "zkutil::makeCheckRequest(\n        zookeeper_path + \"/columns\",\n        columns_version)",
          "new_api": null,
          "old_text": "zkutil::makeCheckRequest(\n        zookeeper_path + \"/columns\",\n        columns_version)",
          "new_text": null,
          "old_line_content": "    ops.emplace_back(zkutil::makeCheckRequest(",
          "new_line_content": "                block_id_path,",
          "content_same": false
        },
        {
          "line": 2508,
          "old_api": "MergeTreePartInfo::contains(part_on_replica, entry.new_part_name, data.format_version)",
          "new_api": null,
          "old_text": "MergeTreePartInfo::contains(part_on_replica, entry.new_part_name, data.format_version)",
          "new_text": null,
          "old_line_content": "                || MergeTreePartInfo::contains(part_on_replica, entry.new_part_name, data.format_version))",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 4556,
          "old_api": "zkutil::makeCreateRequest(\n        replica_path + \"/parts/\" + part->name,\n        \"\",\n        zkutil::CreateMode::Persistent)",
          "new_api": null,
          "old_text": "zkutil::makeCreateRequest(\n        replica_path + \"/parts/\" + part->name,\n        \"\",\n        zkutil::CreateMode::Persistent)",
          "new_text": null,
          "old_line_content": "    ops.emplace_back(zkutil::makeCreateRequest(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2510,
          "old_api": "empty",
          "new_api": null,
          "old_text": "largest_part_found.empty()",
          "new_text": null,
          "old_line_content": "                if (largest_part_found.empty()",
          "new_line_content": "        String largest_part_found;",
          "content_same": false
        },
        {
          "line": 4562,
          "old_api": "toString",
          "new_api": null,
          "old_text": "part->columns.toString()",
          "new_text": null,
          "old_line_content": "        part->columns.toString(),",
          "new_line_content": "        columns_version));",
          "content_same": false
        },
        {
          "line": 4564,
          "old_api": "zkutil::makeCreateRequest(\n        replica_path + \"/parts/\" + part->name + \"/checksums\",\n        getChecksumsForZooKeeper(part->checksums),\n        zkutil::CreateMode::Persistent)",
          "new_api": null,
          "old_text": "zkutil::makeCreateRequest(\n        replica_path + \"/parts/\" + part->name + \"/checksums\",\n        getChecksumsForZooKeeper(part->checksums),\n        zkutil::CreateMode::Persistent)",
          "new_text": null,
          "old_line_content": "    ops.emplace_back(zkutil::makeCreateRequest(",
          "new_line_content": "        replica_path + \"/parts/\" + part->name,",
          "content_same": false
        },
        {
          "line": 4566,
          "old_api": "getChecksumsForZooKeeper",
          "new_api": null,
          "old_text": "getChecksumsForZooKeeper(part->checksums)",
          "new_text": null,
          "old_line_content": "        getChecksumsForZooKeeper(part->checksums),",
          "new_line_content": "        zkutil::CreateMode::Persistent));",
          "content_same": false
        },
        {
          "line": 4572,
          "old_api": "getInterserverIOAddress",
          "new_api": null,
          "old_text": "context.getInterserverIOAddress()",
          "new_text": null,
          "old_line_content": "    auto host_port = context.getInterserverIOAddress();",
          "new_line_content": "        replica_path + \"/parts/\" + part->name + \"/checksums\",",
          "content_same": false
        },
        {
          "line": 2526,
          "old_api": "addFuturePartIfNotCoveredByThem",
          "new_api": null,
          "old_text": "queue.addFuturePartIfNotCoveredByThem(largest_part_found, entry, reject_reason)",
          "new_text": null,
          "old_line_content": "                if (!queue.addFuturePartIfNotCoveredByThem(largest_part_found, entry, reject_reason))",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2528,
          "old_api": "LOG_INFO",
          "new_api": null,
          "old_text": "LOG_INFO(log, \"Will not fetch part \" << largest_part_found << \" covering \" << entry.new_part_name << \". \" << reject_reason)",
          "new_text": null,
          "old_line_content": "                    LOG_INFO(log, \"Will not fetch part \" << largest_part_found << \" covering \" << entry.new_part_name << \". \" << reject_reason);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4577,
          "old_api": "getTCPPort",
          "new_api": null,
          "old_text": "context.getTCPPort()",
          "new_text": null,
          "old_line_content": "    res.queries_port = context.getTCPPort();",
          "new_line_content": "ReplicatedMergeTreeAddress StorageReplicatedMergeTree::getReplicatedMergeTreeAddress() const",
          "content_same": false
        },
        {
          "line": 4586,
          "old_api": "cancel",
          "new_api": null,
          "old_text": "merger_mutator.actions_blocker.cancel()",
          "new_text": null,
          "old_line_content": "        return merger_mutator.actions_blocker.cancel();",
          "new_line_content": "    res.table = table_name;",
          "content_same": false
        },
        {
          "line": 4589,
          "old_api": "cancel",
          "new_api": null,
          "old_text": "fetcher.blocker.cancel()",
          "new_text": null,
          "old_line_content": "        return fetcher.blocker.cancel();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4592,
          "old_api": "ActionLock",
          "new_api": null,
          "old_text": "ActionLock()",
          "new_text": null,
          "old_line_content": "        return data_parts_exchange_endpoint_holder ? data_parts_exchange_endpoint_holder->getBlocker().cancel() : ActionLock();",
          "new_line_content": "    if (action_type == ActionLocks::PartsMerge)",
          "content_same": false
        },
        {
          "line": 4595,
          "old_api": "cancel",
          "new_api": null,
          "old_text": "queue.actions_blocker.cancel()",
          "new_text": null,
          "old_line_content": "        return queue.actions_blocker.cancel();",
          "new_line_content": "    if (action_type == ActionLocks::PartsFetch)",
          "content_same": false
        },
        {
          "line": 2548,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "    auto zookeeper = getZooKeeper();",
          "new_line_content": "    return {};",
          "content_same": false
        },
        {
          "line": 2549,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "zookeeper->getChildren(zookeeper_path + \"/replicas\")",
          "new_text": null,
          "old_line_content": "    Strings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2552,
          "old_api": "end",
          "new_api": null,
          "old_text": "replicas.end()",
          "new_text": null,
          "old_line_content": "    std::shuffle(replicas.begin(), replicas.end(), rng);",
          "new_line_content": "String StorageReplicatedMergeTree::findReplicaHavingCoveringPart(",
          "content_same": false
        },
        {
          "line": 4604,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "    queue.pullLogsToQueue(getZooKeeper());",
          "new_line_content": "    return {};",
          "content_same": false
        },
        {
          "line": 2562,
          "old_api": "exists",
          "new_api": null,
          "old_text": "zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")",
          "new_text": null,
          "old_line_content": "        if (active && !zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\"))",
          "new_line_content": "    String largest_replica_found;",
          "content_same": false
        },
        {
          "line": 2565,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "zookeeper->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/parts\")",
          "new_text": null,
          "old_line_content": "        Strings parts = zookeeper->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/parts\");",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 4613,
          "old_api": "store",
          "new_api": null,
          "old_text": "cond_reached.store(true, std::memory_order_relaxed)",
          "new_text": null,
          "old_line_content": "            cond_reached.store(true, std::memory_order_relaxed);",
          "new_line_content": "    Stopwatch watch;",
          "content_same": false
        },
        {
          "line": 4615,
          "old_api": "set",
          "new_api": null,
          "old_text": "event.set()",
          "new_text": null,
          "old_line_content": "        event.set();",
          "new_line_content": "    std::atomic<bool> cond_reached{false};",
          "content_same": false
        },
        {
          "line": 4618,
          "old_api": "std::move(callback)",
          "new_api": null,
          "old_text": "std::move(callback)",
          "new_text": null,
          "old_line_content": "    auto handler = queue.addSubscriber(std::move(callback));",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2571,
          "old_api": "empty",
          "new_api": null,
          "old_text": "largest_part_found.empty()",
          "new_text": null,
          "old_line_content": "                if (largest_part_found.empty()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4624,
          "old_api": "elapsedMilliseconds",
          "new_api": null,
          "old_text": "watch.elapsedMilliseconds()",
          "new_text": null,
          "old_line_content": "        if (max_wait_milliseconds && watch.elapsedMilliseconds() > max_wait_milliseconds)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4634,
          "old_api": "load",
          "new_api": null,
          "old_text": "cond_reached.load(std::memory_order_relaxed)",
          "new_text": null,
          "old_line_content": "    return cond_reached.load(std::memory_order_relaxed);",
          "new_line_content": "        if (cond_reached)",
          "content_same": false
        },
        {
          "line": 2591,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "    auto zookeeper = getZooKeeper();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4642,
          "old_api": "getFakePartCoveringAllPartsInPartition",
          "new_api": null,
          "old_text": "getFakePartCoveringAllPartsInPartition(partition_id, drop_range_info)",
          "new_text": null,
          "old_line_content": "    if (!getFakePartCoveringAllPartsInPartition(partition_id, drop_range_info))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 4644,
          "old_api": "LOG_INFO",
          "new_api": null,
          "old_text": "LOG_INFO(log, \"Will not drop partition \" << partition_id << \", it is empty.\")",
          "new_text": null,
          "old_line_content": "        LOG_INFO(log, \"Will not drop partition \" << partition_id << \", it is empty.\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4648,
          "old_api": "clearBlocksInPartition",
          "new_api": null,
          "old_text": "clearBlocksInPartition(zookeeper, partition_id, drop_range_info.min_block, drop_range_info.max_block)",
          "new_text": null,
          "old_line_content": "    clearBlocksInPartition(zookeeper, partition_id, drop_range_info.min_block, drop_range_info.max_block);",
          "new_line_content": "    MergeTreePartInfo drop_range_info;",
          "content_same": false
        },
        {
          "line": 2602,
          "old_api": "tryGet",
          "new_api": null,
          "old_text": "zookeeper->tryGet(quorum_status_path, value, &stat)",
          "new_text": null,
          "old_line_content": "    while (zookeeper->tryGet(quorum_status_path, value, &stat))",
          "new_line_content": "    /// The name of the previous part for which the quorum was reached.",
          "content_same": false
        },
        {
          "line": 2605,
          "old_api": "fromString",
          "new_api": null,
          "old_text": "quorum_entry.fromString(value)",
          "new_text": null,
          "old_line_content": "        quorum_entry.fromString(value);",
          "new_line_content": "    String value;",
          "content_same": false
        },
        {
          "line": 4653,
          "old_api": "getPartNamePossiblyFake",
          "new_api": null,
          "old_text": "getPartNamePossiblyFake(data.format_version, drop_range_info)",
          "new_text": null,
          "old_line_content": "    String drop_range_fake_part_name = getPartNamePossiblyFake(data.format_version, drop_range_info);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4656,
          "old_api": "disableMergesInRange",
          "new_api": null,
          "old_text": "queue.disableMergesInRange(drop_range_fake_part_name)",
          "new_text": null,
          "old_line_content": "        queue.disableMergesInRange(drop_range_fake_part_name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4659,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Disabled merges covered by range \" << drop_range_fake_part_name)",
          "new_text": null,
          "old_line_content": "    LOG_DEBUG(log, \"Disabled merges covered by range \" << drop_range_fake_part_name);",
          "new_line_content": "      */",
          "content_same": false
        },
        {
          "line": 2613,
          "old_api": "insert",
          "new_api": null,
          "old_text": "quorum_entry.replicas.insert(replica_name)",
          "new_text": null,
          "old_line_content": "        quorum_entry.replicas.insert(replica_name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2615,
          "old_api": "size",
          "new_api": null,
          "old_text": "quorum_entry.replicas.size()",
          "new_text": null,
          "old_line_content": "        if (quorum_entry.replicas.size() >= quorum_entry.required_number_of_replicas)",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 4668,
          "old_api": "toString",
          "new_api": null,
          "old_text": "entry.toString()",
          "new_text": null,
          "old_line_content": "    String log_znode_path = zookeeper.create(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential);",
          "new_line_content": "    /// Finally, having achieved the necessary invariants, you can put an entry in the log.",
          "content_same": false
        },
        {
          "line": 2621,
          "old_api": "zkutil::makeRemoveRequest(quorum_status_path, stat.version)",
          "new_api": null,
          "old_text": "zkutil::makeRemoveRequest(quorum_status_path, stat.version)",
          "new_text": null,
          "old_line_content": "            ops.emplace_back(zkutil::makeRemoveRequest(quorum_status_path, stat.version));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4669,
          "old_api": "find_last_of",
          "new_api": null,
          "old_text": "log_znode_path.find_last_of('/')",
          "new_text": null,
          "old_line_content": "    entry.znode_name = log_znode_path.substr(log_znode_path.find_last_of('/') + 1);",
          "new_line_content": "    entry.type = LogEntry::DROP_RANGE;",
          "content_same": false
        },
        {
          "line": 2623,
          "old_api": "tryMulti",
          "new_api": null,
          "old_text": "zookeeper->tryMulti(ops, responses)",
          "new_text": null,
          "old_line_content": "            auto code = zookeeper->tryMulti(ops, responses);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2640,
          "old_api": "zkutil::KeeperException(code, quorum_status_path)",
          "new_api": null,
          "old_text": "zkutil::KeeperException(code, quorum_status_path)",
          "new_text": null,
          "old_line_content": "                throw zkutil::KeeperException(code, quorum_status_path);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2645,
          "old_api": "toString",
          "new_api": null,
          "old_text": "quorum_entry.toString()",
          "new_text": null,
          "old_line_content": "            auto code = zookeeper->trySet(quorum_status_path, quorum_entry.toString(), stat.version);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2662,
          "old_api": "zkutil::KeeperException(code, quorum_status_path)",
          "new_api": null,
          "old_text": "zkutil::KeeperException(code, quorum_status_path)",
          "new_text": null,
          "old_line_content": "                throw zkutil::KeeperException(code, quorum_status_path);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2670,
          "old_api": "getPartIfExists",
          "new_api": null,
          "old_text": "data.getPartIfExists(part_name, {MergeTreeDataPart::State::Outdated, MergeTreeDataPart::State::Deleting})",
          "new_text": null,
          "old_line_content": "    if (auto part = data.getPartIfExists(part_name, {MergeTreeDataPart::State::Outdated, MergeTreeDataPart::State::Deleting}))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2672,
          "old_api": "getNameWithState",
          "new_api": null,
          "old_text": "part->getNameWithState()",
          "new_text": null,
          "old_line_content": "        LOG_DEBUG(log, \"Part \" << part->getNameWithState() << \" should be deleted after previous attempt before fetch\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2674,
          "old_api": "schedule",
          "new_api": null,
          "old_text": "cleanup_thread->schedule()",
          "new_text": null,
          "old_line_content": "        cleanup_thread->schedule();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2680,
          "old_api": "insert",
          "new_api": null,
          "old_text": "currently_fetching_parts.insert(part_name)",
          "new_text": null,
          "old_line_content": "        if (!currently_fetching_parts.insert(part_name).second)",
          "new_line_content": "        /// Force immediate parts cleanup to delete the part that was left from the previous fetch attempt.",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Part \" << part_name << \" is already fetching right now\")",
          "new_text": null,
          "old_line_content": "            LOG_DEBUG(log, \"Part \" << part_name << \" is already fetching right now\");",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 2690,
          "old_api": "erase",
          "new_api": null,
          "old_text": "currently_fetching_parts.erase(part_name)",
          "new_text": null,
          "old_line_content": "        currently_fetching_parts.erase(part_name);",
          "new_line_content": "            return false;",
          "content_same": false
        },
        {
          "line": 2693,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Fetching part \" << part_name << \" from \" << replica_path)",
          "new_text": null,
          "old_line_content": "    LOG_DEBUG(log, \"Fetching part \" << part_name << \" from \" << replica_path);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2706,
          "old_api": "elapsed",
          "new_api": null,
          "old_text": "writePartLog(\n            PartLogElement::DOWNLOAD_PART, execution_status, stopwatch.elapsed(),\n            part_name, part, replaced_parts, nullptr)",
          "new_text": null,
          "old_line_content": "        writePartLog(",
          "new_line_content": "    /// Logging",
          "content_same": false
        },
        {
          "line": 2707,
          "old_api": "elapsed",
          "new_api": null,
          "old_text": "stopwatch.elapsed()",
          "new_text": null,
          "old_line_content": "            PartLogElement::DOWNLOAD_PART, execution_status, stopwatch.elapsed(),",
          "new_line_content": "    Stopwatch stopwatch;",
          "content_same": false
        },
        {
          "line": 2711,
          "old_api": "get",
          "new_api": null,
          "old_text": "getZooKeeper()->get(replica_path + \"/host\")",
          "new_text": null,
          "old_line_content": "    ReplicatedMergeTreeAddress address(getZooKeeper()->get(replica_path + \"/host\"));",
          "new_line_content": "    auto write_part_log = [&] (const ExecutionStatus & execution_status)",
          "content_same": false
        },
        {
          "line": 2712,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context.getSettingsRef()",
          "new_text": null,
          "old_line_content": "    auto timeouts = ConnectionTimeouts::getHTTPTimeouts(context.getSettingsRef());",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2716,
          "old_api": "fetchPart",
          "new_api": null,
          "old_text": "fetcher.fetchPart(part_name, replica_path, address.host, address.replication_port, timeouts, to_detached)",
          "new_text": null,
          "old_line_content": "        part = fetcher.fetchPart(part_name, replica_path, address.host, address.replication_port, timeouts, to_detached);",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 2721,
          "old_api": "renameTempPartAndReplace",
          "new_api": null,
          "old_text": "data.renameTempPartAndReplace(part, nullptr, &transaction)",
          "new_text": null,
          "old_line_content": "            data.renameTempPartAndReplace(part, nullptr, &transaction);",
          "new_line_content": "    try",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": "updateQuorum",
          "new_api": null,
          "old_text": "updateQuorum(part_name)",
          "new_text": null,
          "old_line_content": "                updateQuorum(part_name);",
          "new_line_content": "              */",
          "content_same": false
        },
        {
          "line": 2736,
          "old_api": "schedule",
          "new_api": null,
          "old_text": "merge_selecting_task->schedule()",
          "new_text": null,
          "old_line_content": "            merge_selecting_task->schedule();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2740,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Part \" << replaced_part->name << \" is rendered obsolete by fetching part \" << part_name)",
          "new_text": null,
          "old_line_content": "                LOG_DEBUG(log, \"Part \" << replaced_part->name << \" is rendered obsolete by fetching part \" << part_name);",
          "new_line_content": "            if (quorum)",
          "content_same": false
        },
        {
          "line": 2744,
          "old_api": "write_part_log",
          "new_api": null,
          "old_text": "write_part_log({})",
          "new_text": null,
          "old_line_content": "            write_part_log({});",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2754,
          "old_api": "ExecutionStatus::fromCurrentException()",
          "new_api": null,
          "old_text": "ExecutionStatus::fromCurrentException()",
          "new_text": null,
          "old_line_content": "            write_part_log(ExecutionStatus::fromCurrentException());",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2759,
          "old_api": "ProfileEvents::increment(ProfileEvents::ReplicatedPartFetches)",
          "new_api": null,
          "old_text": "ProfileEvents::increment(ProfileEvents::ReplicatedPartFetches)",
          "new_text": null,
          "old_line_content": "    ProfileEvents::increment(ProfileEvents::ReplicatedPartFetches);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2771,
          "old_api": "initialize",
          "new_api": null,
          "old_text": "queue.initialize(\n        zookeeper_path, replica_path,\n        database_name + \".\" + table_name + \" (ReplicatedMergeTreeQueue)\",\n        data.getDataParts(), current_zookeeper)",
          "new_text": null,
          "old_line_content": "    queue.initialize(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2774,
          "old_api": "getDataParts",
          "new_api": null,
          "old_text": "data.getDataParts()",
          "new_text": null,
          "old_line_content": "        data.getDataParts(), current_zookeeper);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2776,
          "old_api": "pullLogsToQueue",
          "new_api": null,
          "old_text": "queue.pullLogsToQueue(current_zookeeper)",
          "new_text": null,
          "old_line_content": "    queue.pullLogsToQueue(current_zookeeper);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 2777,
          "old_api": "time",
          "new_api": null,
          "old_text": "time(nullptr)",
          "new_text": null,
          "old_line_content": "    last_queue_update_finish_time.store(time(nullptr));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2782,
          "old_api": "std::make_shared<DataPartsExchange::Service>(data, ptr)",
          "new_api": null,
          "old_text": "std::make_shared<DataPartsExchange::Service>(data, ptr)",
          "new_text": null,
          "old_line_content": "    InterserverIOEndpointPtr data_parts_exchange_endpoint = std::make_shared<DataPartsExchange::Service>(data, ptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2787,
          "old_api": "std::make_unique<ReplicatedMergeTreeRestartingThread>(*this)",
          "new_api": null,
          "old_text": "std::make_unique<ReplicatedMergeTreeRestartingThread>(*this)",
          "new_text": null,
          "old_line_content": "    restarting_thread = std::make_unique<ReplicatedMergeTreeRestartingThread>(*this);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2798,
          "old_api": "stop",
          "new_api": null,
          "old_text": "restarting_thread->stop()",
          "new_text": null,
          "old_line_content": "        restarting_thread->stop();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2799,
          "old_api": "reset",
          "new_api": null,
          "old_text": "restarting_thread.reset()",
          "new_text": null,
          "old_line_content": "        restarting_thread.reset();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2804,
          "old_api": "cancelForever",
          "new_api": null,
          "old_text": "data_parts_exchange_endpoint_holder->getBlocker().cancelForever()",
          "new_text": null,
          "old_line_content": "        data_parts_exchange_endpoint_holder->getBlocker().cancelForever();",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2808,
          "old_api": "cancelForever",
          "new_api": null,
          "old_text": "fetcher.blocker.cancelForever()",
          "new_text": null,
          "old_line_content": "    fetcher.blocker.cancelForever();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2816,
          "old_api": "shutdown",
          "new_api": null,
          "old_text": "shutdown()",
          "new_text": null,
          "old_line_content": "        shutdown();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2820,
          "old_api": "tryLogCurrentException",
          "new_api": null,
          "old_text": "tryLogCurrentException(__PRETTY_FUNCTION__)",
          "new_text": null,
          "old_line_content": "        tryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2833,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context.getSettingsRef()",
          "new_text": null,
          "old_line_content": "    const Settings & settings = context.getSettingsRef();",
          "new_line_content": "    const Names & column_names,",
          "content_same": false
        },
        {
          "line": 2843,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "        auto zookeeper = getZooKeeper();",
          "new_line_content": "    * 1. To throw an exception if on a replica there are not all parts which have been written down on quorum of remaining replicas.",
          "content_same": false
        },
        {
          "line": 2846,
          "old_api": "tryGet",
          "new_api": null,
          "old_text": "zookeeper->tryGet(zookeeper_path + \"/quorum/last_part\", last_part)",
          "new_text": null,
          "old_line_content": "        zookeeper->tryGet(zookeeper_path + \"/quorum/last_part\", last_part);",
          "new_line_content": "    */",
          "content_same": false
        },
        {
          "line": 2848,
          "old_api": "getActiveContainingPart",
          "new_api": null,
          "old_text": "data.getActiveContainingPart(last_part)",
          "new_text": null,
          "old_line_content": "        if (!last_part.empty() && !data.getActiveContainingPart(last_part))    /// TODO Disable replica for distributed queries.",
          "new_line_content": "    if (settings.select_sequential_consistency)",
          "content_same": false
        },
        {
          "line": 2849,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Replica doesn't have part \" + last_part + \" which was successfully written to quorum of other replicas.\"\n                \" Send query to another replica or disable 'select_sequential_consistency' setting.\", ErrorCodes::REPLICA_IS_NOT_IN_QUORUM)",
          "new_text": null,
          "old_line_content": "            throw Exception(\"Replica doesn't have part \" + last_part + \" which was successfully written to quorum of other replicas.\"",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2852,
          "old_api": "empty",
          "new_api": null,
          "old_text": "last_part.empty()",
          "new_text": null,
          "old_line_content": "        if (last_part.empty())  /// If no part has been written with quorum.",
          "new_line_content": "        String last_part;",
          "content_same": false
        },
        {
          "line": 2858,
          "old_api": "fromString",
          "new_api": null,
          "old_text": "quorum_entry.fromString(quorum_str)",
          "new_text": null,
          "old_line_content": "                quorum_entry.fromString(quorum_str);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2870,
          "old_api": "read",
          "new_api": null,
          "old_text": "reader.read(\n        column_names, query_info, context, processed_stage, max_block_size, num_streams, max_block_number_to_read)",
          "new_text": null,
          "old_line_content": "    return reader.read(",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 2878,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Table is in readonly mode\", ErrorCodes::TABLE_IS_READ_ONLY)",
          "new_text": null,
          "old_line_content": "        throw Exception(\"Table is in readonly mode\", ErrorCodes::TABLE_IS_READ_ONLY);",
          "new_line_content": "        column_names, query_info, context, processed_stage, max_block_size, num_streams, max_block_number_to_read);",
          "content_same": false
        },
        {
          "line": 2884,
          "old_api": "assertNotReadonly",
          "new_api": null,
          "old_text": "assertNotReadonly()",
          "new_text": null,
          "old_line_content": "    assertNotReadonly();",
          "new_line_content": "    if (is_readonly)",
          "content_same": false
        },
        {
          "line": 2888,
          "old_api": "totalMilliseconds",
          "new_api": null,
          "old_text": "std::make_shared<ReplicatedMergeTreeBlockOutputStream>(*this,\n        settings.insert_quorum, settings.insert_quorum_timeout.totalMilliseconds(), deduplicate)",
          "new_text": null,
          "old_line_content": "    return std::make_shared<ReplicatedMergeTreeBlockOutputStream>(*this,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2889,
          "old_api": "totalMilliseconds",
          "new_api": null,
          "old_text": "settings.insert_quorum_timeout.totalMilliseconds()",
          "new_text": null,
          "old_line_content": "        settings.insert_quorum, settings.insert_quorum_timeout.totalMilliseconds(), deduplicate);",
          "new_line_content": "BlockOutputStreamPtr StorageReplicatedMergeTree::write(const ASTPtr & /*query*/, const Settings & settings)",
          "content_same": false
        },
        {
          "line": 2899,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context.getSettingsRef()",
          "new_text": null,
          "old_line_content": "        sendRequestToLeaderReplica(query, context.getSettingsRef());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2909,
          "old_api": "DiskSpaceMonitor::getUnreservedFreeSpace(full_path)",
          "new_api": null,
          "old_text": "DiskSpaceMonitor::getUnreservedFreeSpace(full_path)",
          "new_text": null,
          "old_line_content": "        size_t disk_space = DiskSpaceMonitor::getUnreservedFreeSpace(full_path);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2915,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "        auto zookeeper = getZooKeeper();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2920,
          "old_api": "selectPartsToMerge",
          "new_api": null,
          "old_text": "merger_mutator.selectPartsToMerge(\n                future_merged_part, true, data.settings.max_bytes_to_merge_at_max_space_in_pool, can_merge, &disable_reason)",
          "new_text": null,
          "old_line_content": "            selected = merger_mutator.selectPartsToMerge(",
          "new_line_content": "        bool selected = false;",
          "content_same": false
        },
        {
          "line": 2925,
          "old_api": "getPartitionIDFromQuery",
          "new_api": null,
          "old_text": "data.getPartitionIDFromQuery(partition, context)",
          "new_text": null,
          "old_line_content": "            String partition_id = data.getPartitionIDFromQuery(partition, context);",
          "new_line_content": "        if (!partition)",
          "content_same": false
        },
        {
          "line": 2926,
          "old_api": "selectAllPartsToMergeWithinPartition",
          "new_api": null,
          "old_text": "merger_mutator.selectAllPartsToMergeWithinPartition(\n                future_merged_part, disk_space, can_merge, partition_id, final, &disable_reason)",
          "new_text": null,
          "old_line_content": "            selected = merger_mutator.selectAllPartsToMergeWithinPartition(",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2943,
          "old_api": "createLogEntryToMergeParts",
          "new_api": null,
          "old_text": "createLogEntryToMergeParts(zookeeper, future_merged_part.parts, future_merged_part.name, deduplicate, &merge_entry)",
          "new_text": null,
          "old_line_content": "        if (!createLogEntryToMergeParts(zookeeper, future_merged_part.parts, future_merged_part.name, deduplicate, &merge_entry))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2944,
          "old_api": "handle_noop",
          "new_api": null,
          "old_text": "handle_noop(\"Can't create merge queue node in ZooKeeper\")",
          "new_text": null,
          "old_line_content": "            return handle_noop(\"Can't create merge queue node in ZooKeeper\");",
          "new_line_content": "        if (!selected)",
          "content_same": false
        },
        {
          "line": 2948,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context.getSettingsRef()",
          "new_text": null,
          "old_line_content": "    if (context.getSettingsRef().replication_alter_partitions_sync != 0)",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2949,
          "old_api": "waitForAllReplicasToProcessLogEntry",
          "new_api": null,
          "old_text": "waitForAllReplicasToProcessLogEntry(merge_entry)",
          "new_text": null,
          "old_line_content": "        waitForAllReplicasToProcessLogEntry(merge_entry);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2958,
          "old_api": "assertNotReadonly",
          "new_api": null,
          "old_text": "assertNotReadonly()",
          "new_text": null,
          "old_line_content": "    assertNotReadonly();",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 2960,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Doing ALTER\")",
          "new_text": null,
          "old_line_content": "    LOG_DEBUG(log, \"Doing ALTER\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2968,
          "old_api": "lockStructure",
          "new_api": null,
          "old_text": "lockStructure(false, __PRETTY_FUNCTION__)",
          "new_text": null,
          "old_line_content": "        auto table_lock = lockStructure(false, __PRETTY_FUNCTION__);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2971,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Can't ALTER readonly table\", ErrorCodes::TABLE_IS_READ_ONLY)",
          "new_text": null,
          "old_line_content": "            throw Exception(\"Can't ALTER readonly table\", ErrorCodes::TABLE_IS_READ_ONLY);",
          "new_line_content": "    zkutil::Stat stat;",
          "content_same": false
        },
        {
          "line": 2973,
          "old_api": "checkAlter",
          "new_api": null,
          "old_text": "data.checkAlter(params)",
          "new_text": null,
          "old_line_content": "        data.checkAlter(params);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2977,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Modification of primary key is not supported for replicated tables\", ErrorCodes::NOT_IMPLEMENTED)",
          "new_text": null,
          "old_line_content": "                throw Exception(\"Modification of primary key is not supported for replicated tables\", ErrorCodes::NOT_IMPLEMENTED);",
          "new_line_content": "        if (is_readonly)",
          "content_same": false
        },
        {
          "line": 2979,
          "old_api": "getColumns",
          "new_api": null,
          "old_text": "data.getColumns()",
          "new_text": null,
          "old_line_content": "        ColumnsDescription new_columns = data.getColumns();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2982,
          "old_api": "toString",
          "new_api": null,
          "old_text": "new_columns.toString()",
          "new_text": null,
          "old_line_content": "        new_columns_str = new_columns.toString();",
          "new_line_content": "        for (const AlterCommand & param : params)",
          "content_same": false
        },
        {
          "line": 2985,
          "old_api": "set",
          "new_api": null,
          "old_text": "getZooKeeper()->set(zookeeper_path + \"/columns\", new_columns_str, -1, &stat)",
          "new_text": null,
          "old_line_content": "        getZooKeeper()->set(zookeeper_path + \"/columns\", new_columns_str, -1, &stat);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2990,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Updated columns in ZooKeeper. Waiting for replicas to apply changes.\")",
          "new_text": null,
          "old_line_content": "    LOG_DEBUG(log, \"Updated columns in ZooKeeper. Waiting for replicas to apply changes.\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2995,
          "old_api": "exists",
          "new_api": null,
          "old_text": "getZooKeeper()->exists(zookeeper_path + \"/columns\", &stat, alter_query_event)",
          "new_text": null,
          "old_line_content": "    if (!getZooKeeper()->exists(zookeeper_path + \"/columns\", &stat, alter_query_event))",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2996,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(zookeeper_path + \"/columns doesn't exist\", ErrorCodes::NOT_FOUND_NODE)",
          "new_text": null,
          "old_line_content": "        throw Exception(zookeeper_path + \"/columns doesn't exist\", ErrorCodes::NOT_FOUND_NODE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3000,
          "old_api": "LOG_WARNING",
          "new_api": null,
          "old_text": "LOG_WARNING(log, zookeeper_path + \"/columns changed before this ALTER finished; \"\n            \"overlapping ALTER-s are fine but use caution with nontransitive changes\")",
          "new_text": null,
          "old_line_content": "        LOG_WARNING(log, zookeeper_path + \"/columns changed before this ALTER finished; \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3005,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "getZooKeeper()->getChildren(zookeeper_path + \"/replicas\")",
          "new_text": null,
          "old_line_content": "    Strings replicas = getZooKeeper()->getChildren(zookeeper_path + \"/replicas\");",
          "new_line_content": "    if (stat.version != new_columns_version)",
          "content_same": false
        },
        {
          "line": 3010,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context.getSettingsRef()",
          "new_text": null,
          "old_line_content": "    time_t replication_alter_columns_timeout = context.getSettingsRef().replication_alter_columns_timeout;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3014,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Waiting for \" << replica << \" to apply changes\")",
          "new_text": null,
          "old_line_content": "        LOG_DEBUG(log, \"Waiting for \" << replica << \" to apply changes\");",
          "new_line_content": "    std::set<String> inactive_replicas;",
          "content_same": false
        },
        {
          "line": 3019,
          "old_api": "exists",
          "new_api": null,
          "old_text": "getZooKeeper()->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")",
          "new_text": null,
          "old_line_content": "            if (!getZooKeeper()->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\"))",
          "new_line_content": "    for (const String & replica : replicas)",
          "content_same": false
        },
        {
          "line": 3024,
          "old_api": "emplace",
          "new_api": null,
          "old_text": "inactive_replicas.emplace(replica)",
          "new_text": null,
          "old_line_content": "                inactive_replicas.emplace(replica);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3033,
          "old_api": "LOG_WARNING",
          "new_api": null,
          "old_text": "LOG_WARNING(log, replica << \" was removed\")",
          "new_text": null,
          "old_line_content": "                LOG_WARNING(log, replica << \" was removed\");",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3043,
          "old_api": "exists",
          "new_api": null,
          "old_text": "getZooKeeper()->exists(zookeeper_path + \"/columns\", &stat)",
          "new_text": null,
          "old_line_content": "            if (!getZooKeeper()->exists(zookeeper_path + \"/columns\", &stat))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3044,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(zookeeper_path + \"/columns doesn't exist\", ErrorCodes::NOT_FOUND_NODE)",
          "new_text": null,
          "old_line_content": "                throw Exception(zookeeper_path + \"/columns doesn't exist\", ErrorCodes::NOT_FOUND_NODE);",
          "new_line_content": "            int replica_columns_version = stat.version;",
          "content_same": false
        },
        {
          "line": 3048,
          "old_api": "LOG_WARNING",
          "new_api": null,
          "old_text": "LOG_WARNING(log, zookeeper_path + \"/columns changed before ALTER finished; \"\n                    \"overlapping ALTER-s are fine but use caution with nontransitive changes\")",
          "new_text": null,
          "old_line_content": "                LOG_WARNING(log, zookeeper_path + \"/columns changed before ALTER finished; \"",
          "new_line_content": "                break;",
          "content_same": false
        },
        {
          "line": 3053,
          "old_api": "exists",
          "new_api": null,
          "old_text": "getZooKeeper()->exists(zookeeper_path + \"/replicas/\" + replica + \"/columns\", &stat, alter_query_event)",
          "new_text": null,
          "old_line_content": "            if (!getZooKeeper()->exists(zookeeper_path + \"/replicas/\" + replica + \"/columns\", &stat, alter_query_event))",
          "new_line_content": "            if (stat.version != new_columns_version)",
          "content_same": false
        },
        {
          "line": 3064,
          "old_api": "wait",
          "new_api": null,
          "old_text": "alter_query_event->wait()",
          "new_text": null,
          "old_line_content": "                alter_query_event->wait();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3067,
          "old_api": "tryWait",
          "new_api": null,
          "old_text": "alter_query_event->tryWait(replication_alter_columns_timeout * 1000)",
          "new_text": null,
          "old_line_content": "            else if (alter_query_event->tryWait(replication_alter_columns_timeout * 1000))",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 3073,
          "old_api": "LOG_WARNING",
          "new_api": null,
          "old_text": "LOG_WARNING(log, \"Timeout when waiting for replica \" << replica << \" to apply ALTER.\"\n                    \" ALTER will be done asynchronously.\")",
          "new_text": null,
          "old_line_content": "                LOG_WARNING(log, \"Timeout when waiting for replica \" << replica << \" to apply ALTER.\"",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3076,
          "old_api": "emplace",
          "new_api": null,
          "old_text": "timed_out_replicas.emplace(replica)",
          "new_text": null,
          "old_line_content": "                timed_out_replicas.emplace(replica);",
          "new_line_content": "                /// Everything is fine.",
          "content_same": false
        },
        {
          "line": 3082,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Alter is not finished because table shutdown was called. Alter will be done after table restart.\",\n                ErrorCodes::UNFINISHED)",
          "new_text": null,
          "old_line_content": "            throw Exception(\"Alter is not finished because table shutdown was called. Alter will be done after table restart.\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3085,
          "old_api": "empty",
          "new_api": null,
          "old_text": "timed_out_replicas.empty()",
          "new_text": null,
          "old_line_content": "        if (!inactive_replicas.empty() || !timed_out_replicas.empty())",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3090,
          "old_api": "empty",
          "new_api": null,
          "old_text": "inactive_replicas.empty()",
          "new_text": null,
          "old_line_content": "            if (!inactive_replicas.empty())",
          "new_line_content": "                ErrorCodes::UNFINISHED);",
          "content_same": false
        },
        {
          "line": 3094,
          "old_api": "end",
          "new_api": null,
          "old_text": "inactive_replicas.end()",
          "new_text": null,
          "old_line_content": "                for (auto it = inactive_replicas.begin(); it != inactive_replicas.end(); ++it)",
          "new_line_content": "            std::stringstream exception_message;",
          "content_same": false
        },
        {
          "line": 3095,
          "old_api": "begin",
          "new_api": null,
          "old_text": "inactive_replicas.begin()",
          "new_text": null,
          "old_line_content": "                    exception_message << (it == inactive_replicas.begin() ? \": \" : \", \") << *it;",
          "new_line_content": "            exception_message << \"Alter is not finished because\";",
          "content_same": false
        },
        {
          "line": 3098,
          "old_api": "empty",
          "new_api": null,
          "old_text": "inactive_replicas.empty()",
          "new_text": null,
          "old_line_content": "            if (!timed_out_replicas.empty() && !inactive_replicas.empty())",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 3106,
          "old_api": "begin",
          "new_api": null,
          "old_text": "timed_out_replicas.begin()",
          "new_text": null,
          "old_line_content": "                    exception_message << (it == timed_out_replicas.begin() ? \": \" : \", \") << *it;",
          "new_line_content": "                exception_message << \" and\";",
          "content_same": false
        },
        {
          "line": 3117,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"ALTER finished\")",
          "new_text": null,
          "old_line_content": "    LOG_DEBUG(log, \"ALTER finished\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3127,
          "old_api": "DateLUT::instance()",
          "new_api": null,
          "old_text": "DateLUT::instance()",
          "new_text": null,
          "old_line_content": "        const auto & lut = DateLUT::instance();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3128,
          "old_api": "parse<UInt32>(part_info.partition_id + \"01\")",
          "new_api": null,
          "old_text": "parse<UInt32>(part_info.partition_id + \"01\")",
          "new_text": null,
          "old_line_content": "        time_t start_time = lut.YYYYMMDDToDate(parse<UInt32>(part_info.partition_id + \"01\"));",
          "new_line_content": "/// If new version returns ordinary name, else returns part name containing the first and last month of the month",
          "content_same": false
        },
        {
          "line": 3129,
          "old_api": "toDayNum",
          "new_api": null,
          "old_text": "lut.toDayNum(start_time)",
          "new_text": null,
          "old_line_content": "        DayNum left_date = lut.toDayNum(start_time);",
          "new_line_content": "static String getPartNamePossiblyFake(MergeTreeDataFormatVersion format_version, const MergeTreePartInfo & part_info)",
          "content_same": false
        },
        {
          "line": 3130,
          "old_api": "daysInMonth",
          "new_api": null,
          "old_text": "lut.daysInMonth(start_time)",
          "new_text": null,
          "old_line_content": "        DayNum right_date = DayNum(static_cast<size_t>(left_date) + lut.daysInMonth(start_time) - 1);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3131,
          "old_api": "getPartNameV0",
          "new_api": null,
          "old_text": "part_info.getPartNameV0(left_date, right_date)",
          "new_text": null,
          "old_line_content": "        return part_info.getPartNameV0(left_date, right_date);",
          "new_line_content": "    if (format_version < MERGE_TREE_DATA_MIN_FORMAT_VERSION_WITH_CUSTOM_PARTITIONING)",
          "content_same": false
        },
        {
          "line": 3153,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "        auto zookeeper = getZooKeeper();",
          "new_line_content": "      * NOTE: If you need to similarly support a `DROP PART` request, you will have to think of some new mechanism for it,",
          "content_same": false
        },
        {
          "line": 3154,
          "old_api": "allocateBlockNumber",
          "new_api": null,
          "old_text": "allocateBlockNumber(partition_id, zookeeper)",
          "new_text": null,
          "old_line_content": "        auto block_number_lock = allocateBlockNumber(partition_id, zookeeper);",
          "new_line_content": "      *     to guarantee this invariant.",
          "content_same": false
        },
        {
          "line": 3155,
          "old_api": "getNumber",
          "new_api": null,
          "old_text": "block_number_lock->getNumber()",
          "new_text": null,
          "old_line_content": "        right = block_number_lock->getNumber();",
          "new_line_content": "      */",
          "content_same": false
        },
        {
          "line": 3156,
          "old_api": "unlock",
          "new_api": null,
          "old_text": "block_number_lock->unlock()",
          "new_text": null,
          "old_line_content": "        block_number_lock->unlock();",
          "new_line_content": "    Int64 right;",
          "content_same": false
        },
        {
          "line": 3157,
          "old_api": "getCurrentMutationVersion",
          "new_api": null,
          "old_text": "queue.getCurrentMutationVersion(partition_id, right)",
          "new_text": null,
          "old_line_content": "        mutation_version = queue.getCurrentMutationVersion(partition_id, right);",
          "new_line_content": "    Int64 mutation_version;",
          "content_same": false
        },
        {
          "line": 3167,
          "old_api": "MergeTreePartInfo",
          "new_api": null,
          "old_text": "MergeTreePartInfo(partition_id, left, right, MergeTreePartInfo::MAX_LEVEL, mutation_version)",
          "new_text": null,
          "old_line_content": "    part_info = MergeTreePartInfo(partition_id, left, right, MergeTreePartInfo::MAX_LEVEL, mutation_version);",
          "new_line_content": "    /// Empty partition.",
          "content_same": false
        },
        {
          "line": 3175,
          "old_api": "assertNotReadonly",
          "new_api": null,
          "old_text": "assertNotReadonly()",
          "new_text": null,
          "old_line_content": "    assertNotReadonly();",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 3179,
          "old_api": "getPartitionIDFromQuery",
          "new_api": null,
          "old_text": "data.getPartitionIDFromQuery(partition, context)",
          "new_text": null,
          "old_line_content": "    String partition_id = data.getPartitionIDFromQuery(partition, context);",
          "new_line_content": "void StorageReplicatedMergeTree::clearColumnInPartition(",
          "content_same": false
        },
        {
          "line": 3184,
          "old_api": "LOG_INFO",
          "new_api": null,
          "old_text": "LOG_INFO(log, \"Will not clear partition \" << partition_id << \", it is empty.\")",
          "new_text": null,
          "old_line_content": "        LOG_INFO(log, \"Will not clear partition \" << partition_id << \", it is empty.\");",
          "new_line_content": "    /// We don't block merges, so anyone can manage this task (not only leader)",
          "content_same": false
        },
        {
          "line": 3192,
          "old_api": "getPartNamePossiblyFake",
          "new_api": null,
          "old_text": "getPartNamePossiblyFake(data.format_version, drop_range_info)",
          "new_text": null,
          "old_line_content": "    entry.new_part_name = getPartNamePossiblyFake(data.format_version, drop_range_info);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 3193,
          "old_api": "column_name.safeGet<String>()",
          "new_api": null,
          "old_text": "column_name.safeGet<String>()",
          "new_text": null,
          "old_line_content": "    entry.column_name = column_name.safeGet<String>();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3194,
          "old_api": "time",
          "new_api": null,
          "old_text": "time(nullptr)",
          "new_text": null,
          "old_line_content": "    entry.create_time = time(nullptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3196,
          "old_api": "toString",
          "new_api": null,
          "old_text": "entry.toString()",
          "new_text": null,
          "old_line_content": "    String log_znode_path = getZooKeeper()->create(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3197,
          "old_api": "find_last_of",
          "new_api": null,
          "old_text": "log_znode_path.find_last_of('/')",
          "new_text": null,
          "old_line_content": "    entry.znode_name = log_znode_path.substr(log_znode_path.find_last_of('/') + 1);",
          "new_line_content": "    LogEntry entry;",
          "content_same": false
        },
        {
          "line": 3202,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context.getSettingsRef()",
          "new_text": null,
          "old_line_content": "        if (context.getSettingsRef().replication_alter_partitions_sync == 1)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3205,
          "old_api": "waitForAllReplicasToProcessLogEntry",
          "new_api": null,
          "old_text": "waitForAllReplicasToProcessLogEntry(entry)",
          "new_text": null,
          "old_line_content": "            waitForAllReplicasToProcessLogEntry(entry);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3214,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "    zkutil::ZooKeeperPtr zookeeper = getZooKeeper();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3218,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context.getSettingsRef()",
          "new_text": null,
          "old_line_content": "        sendRequestToLeaderReplica(query, context.getSettingsRef());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3222,
          "old_api": "getPartitionIDFromQuery",
          "new_api": null,
          "old_text": "data.getPartitionIDFromQuery(partition, context)",
          "new_text": null,
          "old_line_content": "    String partition_id = data.getPartitionIDFromQuery(partition, context);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3228,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context.getSettingsRef()",
          "new_text": null,
          "old_line_content": "        if (context.getSettingsRef().replication_alter_partitions_sync != 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3230,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context.getSettingsRef()",
          "new_text": null,
          "old_line_content": "            if (context.getSettingsRef().replication_alter_partitions_sync == 1)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3231,
          "old_api": "waitForReplicaToProcessLogEntry",
          "new_api": null,
          "old_text": "waitForReplicaToProcessLogEntry(replica_name, entry)",
          "new_text": null,
          "old_line_content": "                waitForReplicaToProcessLogEntry(replica_name, entry);",
          "new_line_content": "    LogEntry entry;",
          "content_same": false
        },
        {
          "line": 3233,
          "old_api": "waitForAllReplicasToProcessLogEntry",
          "new_api": null,
          "old_text": "waitForAllReplicasToProcessLogEntry(entry)",
          "new_text": null,
          "old_line_content": "                waitForAllReplicasToProcessLogEntry(entry);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3241,
          "old_api": "assertNotReadonly",
          "new_api": null,
          "old_text": "assertNotReadonly()",
          "new_text": null,
          "old_line_content": "    assertNotReadonly();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3243,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "    zkutil::ZooKeeperPtr zookeeper = getZooKeeper();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3247,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context.getSettingsRef()",
          "new_text": null,
          "old_line_content": "        sendRequestToLeaderReplica(query, context.getSettingsRef());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3251,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "zookeeper->getChildren(zookeeper_path + \"/block_numbers\")",
          "new_text": null,
          "old_line_content": "    Strings partitions = zookeeper->getChildren(zookeeper_path + \"/block_numbers\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3257,
          "old_api": "dropPartsInPartition",
          "new_api": null,
          "old_text": "dropPartsInPartition(*zookeeper, partition_id, entry, false)",
          "new_text": null,
          "old_line_content": "        if (dropPartsInPartition(*zookeeper, partition_id, entry, false))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3270,
          "old_api": "typeid_cast<const ASTLiteral &>(*partition).value.safeGet<String>()",
          "new_api": null,
          "old_text": "typeid_cast<const ASTLiteral &>(*partition).value.safeGet<String>()",
          "new_text": null,
          "old_line_content": "        partition_id = typeid_cast<const ASTLiteral &>(*partition).value.safeGet<String>();",
          "new_line_content": "void StorageReplicatedMergeTree::attachPartition(const ASTPtr & partition, bool attach_part, const Context & context)",
          "content_same": false
        },
        {
          "line": 3280,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "parts.push_back(partition_id)",
          "new_text": null,
          "old_line_content": "        parts.push_back(partition_id);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3284,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Looking for parts for partition \" << partition_id << \" in \" << source_dir)",
          "new_text": null,
          "old_line_content": "        LOG_DEBUG(log, \"Looking for parts for partition \" << partition_id << \" in \" << source_dir);",
          "new_line_content": "    Strings parts;",
          "content_same": false
        },
        {
          "line": 3288,
          "old_api": "Poco::DirectoryIterator()",
          "new_api": null,
          "old_text": "Poco::DirectoryIterator()",
          "new_text": null,
          "old_line_content": "        for (Poco::DirectoryIterator it = Poco::DirectoryIterator(full_path + source_dir); it != Poco::DirectoryIterator(); ++it)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3290,
          "old_api": "name",
          "new_api": null,
          "old_text": "it.name()",
          "new_text": null,
          "old_line_content": "            String name = it.name();",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3292,
          "old_api": "MergeTreePartInfo::tryParsePartName(name, &part_info, data.format_version)",
          "new_api": null,
          "old_text": "MergeTreePartInfo::tryParsePartName(name, &part_info, data.format_version)",
          "new_text": null,
          "old_line_content": "            if (!MergeTreePartInfo::tryParsePartName(name, &part_info, data.format_version))",
          "new_line_content": "        ActiveDataPartSet active_parts(data.format_version);",
          "content_same": false
        },
        {
          "line": 3296,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Found part \" << name)",
          "new_text": null,
          "old_line_content": "            LOG_DEBUG(log, \"Found part \" << name);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3298,
          "old_api": "insert",
          "new_api": null,
          "old_text": "part_names.insert(name)",
          "new_text": null,
          "old_line_content": "            part_names.insert(name);",
          "new_line_content": "            MergeTreePartInfo part_info;",
          "content_same": false
        },
        {
          "line": 3300,
          "old_api": "size",
          "new_api": null,
          "old_text": "active_parts.size()",
          "new_text": null,
          "old_line_content": "        LOG_DEBUG(log, active_parts.size() << \" of them are active\");",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 3301,
          "old_api": "getParts",
          "new_api": null,
          "old_text": "active_parts.getParts()",
          "new_text": null,
          "old_line_content": "        parts = active_parts.getParts();",
          "new_line_content": "            if (part_info.partition_id != partition_id)",
          "content_same": false
        },
        {
          "line": 3306,
          "old_api": "getContainingPart",
          "new_api": null,
          "old_text": "active_parts.getContainingPart(name)",
          "new_text": null,
          "old_line_content": "            String containing_part = active_parts.getContainingPart(name);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3317,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Checking part \" << part)",
          "new_text": null,
          "old_line_content": "        LOG_DEBUG(log, \"Checking part \" << part);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3318,
          "old_api": "loadPartAndFixMetadata",
          "new_api": null,
          "old_text": "data.loadPartAndFixMetadata(source_dir + part)",
          "new_text": null,
          "old_line_content": "        loaded_parts.push_back(data.loadPartAndFixMetadata(source_dir + part));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3326,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Attached part \" << old_name << \" as \" << part->name)",
          "new_text": null,
          "old_line_content": "        LOG_DEBUG(log, \"Attached part \" << old_name << \" as \" << part->name);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3334,
          "old_api": "getData",
          "new_api": null,
          "old_text": "getData()",
          "new_text": null,
          "old_line_content": "    const_cast<MergeTreeData &>(getData()).recalculateColumnSizes();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3335,
          "old_api": "getTotalActiveSizeInBytes",
          "new_api": null,
          "old_text": "getData().getTotalActiveSizeInBytes()",
          "new_text": null,
          "old_line_content": "    context.checkTableCanBeDropped(database_name, table_name, getData().getTotalActiveSizeInBytes());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3343,
          "old_api": "tryGetZooKeeper",
          "new_api": null,
          "old_text": "tryGetZooKeeper()",
          "new_text": null,
          "old_line_content": "        auto zookeeper = tryGetZooKeeper();",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 3346,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Can't drop readonly replicated table (need to drop data in ZooKeeper as well)\", ErrorCodes::TABLE_IS_READ_ONLY)",
          "new_text": null,
          "old_line_content": "            throw Exception(\"Can't drop readonly replicated table (need to drop data in ZooKeeper as well)\", ErrorCodes::TABLE_IS_READ_ONLY);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3352,
          "old_api": "expired",
          "new_api": null,
          "old_text": "zookeeper->expired()",
          "new_text": null,
          "old_line_content": "        if (zookeeper->expired())",
          "new_line_content": "        if (is_readonly || !zookeeper)",
          "content_same": false
        },
        {
          "line": 3355,
          "old_api": "LOG_INFO",
          "new_api": null,
          "old_text": "LOG_INFO(log, \"Removing replica \" << replica_path)",
          "new_text": null,
          "old_line_content": "        LOG_INFO(log, \"Removing replica \" << replica_path);",
          "new_line_content": "        // checkTableCanBeDropped(); // uncomment to feel yourself safe",
          "content_same": false
        },
        {
          "line": 3361,
          "old_api": "empty",
          "new_api": null,
          "old_text": "replicas.empty()",
          "new_text": null,
          "old_line_content": "        if (zookeeper->tryGetChildren(zookeeper_path + \"/replicas\", replicas) == ZooKeeperImpl::ZooKeeper::ZOK && replicas.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3363,
          "old_api": "LOG_INFO",
          "new_api": null,
          "old_text": "LOG_INFO(log, \"Removing table \" << zookeeper_path << \" (this might take several minutes)\")",
          "new_text": null,
          "old_line_content": "            LOG_INFO(log, \"Removing table \" << zookeeper_path << \" (this might take several minutes)\");",
          "new_line_content": "        replica_is_active_node = nullptr;",
          "content_same": false
        },
        {
          "line": 3374,
          "old_api": "escapeForFileName",
          "new_api": null,
          "old_text": "escapeForFileName(new_table_name)",
          "new_text": null,
          "old_line_content": "    std::string new_full_path = new_path_to_db + escapeForFileName(new_table_name) + '/';",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3376,
          "old_api": "setPath",
          "new_api": null,
          "old_text": "data.setPath(new_full_path)",
          "new_text": null,
          "old_line_content": "    data.setPath(new_full_path);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3384,
          "old_api": "toString",
          "new_api": null,
          "old_text": "getReplicatedMergeTreeAddress().toString()",
          "new_text": null,
          "old_line_content": "    zookeeper->set(replica_path + \"/host\", getReplicatedMergeTreeAddress().toString());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3394,
          "old_api": "count",
          "new_api": null,
          "old_text": "existing_nodes_cache.count(path)",
          "new_text": null,
          "old_line_content": "        if (existing_nodes_cache.count(path))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3398,
          "old_api": "exists",
          "new_api": null,
          "old_text": "getZooKeeper()->exists(path)",
          "new_text": null,
          "old_line_content": "    bool res = getZooKeeper()->exists(path);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3403,
          "old_api": "insert",
          "new_api": null,
          "old_text": "existing_nodes_cache.insert(path)",
          "new_text": null,
          "old_line_content": "        existing_nodes_cache.insert(path);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3416,
          "old_api": "empty",
          "new_api": null,
          "old_text": "zookeeper_block_id_path.empty()",
          "new_text": null,
          "old_line_content": "    if (!zookeeper_block_id_path.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3418,
          "old_api": "zkutil::makeCreateRequest(zookeeper_block_id_path, \"\", zkutil::CreateMode::Persistent)",
          "new_api": null,
          "old_text": "zkutil::makeCreateRequest(zookeeper_block_id_path, \"\", zkutil::CreateMode::Persistent)",
          "new_text": null,
          "old_line_content": "        deduplication_check_ops.emplace_back(zkutil::makeCreateRequest(zookeeper_block_id_path, \"\", zkutil::CreateMode::Persistent));",
          "new_line_content": "StorageReplicatedMergeTree::allocateBlockNumber(",
          "content_same": false
        },
        {
          "line": 3419,
          "old_api": "zkutil::makeRemoveRequest(zookeeper_block_id_path, -1)",
          "new_api": null,
          "old_text": "zkutil::makeRemoveRequest(zookeeper_block_id_path, -1)",
          "new_text": null,
          "old_line_content": "        deduplication_check_ops.emplace_back(zkutil::makeRemoveRequest(zookeeper_block_id_path, -1));",
          "new_line_content": "    const String & partition_id, zkutil::ZooKeeperPtr & zookeeper, const String & zookeeper_block_id_path)",
          "content_same": false
        },
        {
          "line": 3428,
          "old_api": "zkutil::makeCreateRequest(partition_path, \"\", zkutil::CreateMode::Persistent)",
          "new_api": null,
          "old_text": "zkutil::makeCreateRequest(partition_path, \"\", zkutil::CreateMode::Persistent)",
          "new_text": null,
          "old_line_content": "        ops.push_back(zkutil::makeCreateRequest(partition_path, \"\", zkutil::CreateMode::Persistent));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3437,
          "old_api": "zkutil::KeeperMultiException::check(code, ops, responses)",
          "new_api": null,
          "old_text": "zkutil::KeeperMultiException::check(code, ops, responses)",
          "new_text": null,
          "old_line_content": "            zkutil::KeeperMultiException::check(code, ops, responses);",
          "new_line_content": "        /// to check in a ZK transaction that the set of partitions didn't change",
          "content_same": false
        },
        {
          "line": 3449,
          "old_api": "getPathForFirstFailedOp",
          "new_api": null,
          "old_text": "e.getPathForFirstFailedOp()",
          "new_text": null,
          "old_line_content": "        if (e.code == ZooKeeperImpl::ZooKeeper::ZNODEEXISTS && e.getPathForFirstFailedOp() == zookeeper_block_id_path)",
          "new_line_content": "    try",
          "content_same": false
        },
        {
          "line": 3452,
          "old_api": "displayText",
          "new_api": null,
          "old_text": "e.displayText()",
          "new_text": null,
          "old_line_content": "        throw Exception(\"Cannot allocate block number in ZooKeeper: \" + e.displayText(), ErrorCodes::KEEPER_EXCEPTION);",
          "new_line_content": "            partition_path + \"/block-\", zookeeper_path + \"/temp\", *zookeeper, &deduplication_check_ops);",
          "content_same": false
        },
        {
          "line": 3465,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Waiting for all replicas to process \" << entry.znode_name)",
          "new_text": null,
          "old_line_content": "    LOG_DEBUG(log, \"Waiting for all replicas to process \" << entry.znode_name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3467,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "getZooKeeper()->getChildren(zookeeper_path + \"/replicas\")",
          "new_text": null,
          "old_line_content": "    Strings replicas = getZooKeeper()->getChildren(zookeeper_path + \"/replicas\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3469,
          "old_api": "waitForReplicaToProcessLogEntry",
          "new_api": null,
          "old_text": "waitForReplicaToProcessLogEntry(replica, entry)",
          "new_text": null,
          "old_line_content": "        waitForReplicaToProcessLogEntry(replica, entry);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3471,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Finished waiting for all replicas to process \" << entry.znode_name)",
          "new_text": null,
          "old_line_content": "    LOG_DEBUG(log, \"Finished waiting for all replicas to process \" << entry.znode_name);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3477,
          "old_api": "toString",
          "new_api": null,
          "old_text": "entry.toString()",
          "new_text": null,
          "old_line_content": "    String entry_str = entry.toString();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3496,
          "old_api": "startsWith",
          "new_api": null,
          "old_text": "startsWith(entry.znode_name, \"log-\")",
          "new_text": null,
          "old_line_content": "    if (startsWith(entry.znode_name, \"log-\"))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3501,
          "old_api": "size",
          "new_api": null,
          "old_text": "entry.znode_name.size()",
          "new_text": null,
          "old_line_content": "        UInt64 log_index = parse<UInt64>(entry.znode_name.substr(entry.znode_name.size() - 10));",
          "new_line_content": "      */",
          "content_same": false
        },
        {
          "line": 3504,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Waiting for \" << replica << \" to pull \" << log_node_name << \" to queue\")",
          "new_text": null,
          "old_line_content": "        LOG_DEBUG(log, \"Waiting for \" << replica << \" to pull \" << log_node_name << \" to queue\");",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3509,
          "old_api": "std::make_shared<Poco::Event>()",
          "new_api": null,
          "old_text": "std::make_shared<Poco::Event>()",
          "new_text": null,
          "old_line_content": "            zkutil::EventPtr event = std::make_shared<Poco::Event>();",
          "new_line_content": "        log_node_name = entry.znode_name;",
          "content_same": false
        },
        {
          "line": 3512,
          "old_api": "parse<UInt64>(log_pointer)",
          "new_api": null,
          "old_text": "parse<UInt64>(log_pointer)",
          "new_text": null,
          "old_line_content": "            if (!log_pointer.empty() && parse<UInt64>(log_pointer) > log_index)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3515,
          "old_api": "wait",
          "new_api": null,
          "old_text": "event->wait()",
          "new_text": null,
          "old_line_content": "            event->wait();",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3524,
          "old_api": "get",
          "new_api": null,
          "old_text": "getZooKeeper()->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\")",
          "new_text": null,
          "old_line_content": "        String log_pointer = getZooKeeper()->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3526,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "getZooKeeper()->getChildren(zookeeper_path + \"/log\")",
          "new_text": null,
          "old_line_content": "        Strings log_entries = getZooKeeper()->getChildren(zookeeper_path + \"/log\");",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3532,
          "old_api": "size",
          "new_api": null,
          "old_text": "log_entry_name.size()",
          "new_text": null,
          "old_line_content": "            log_index = parse<UInt64>(log_entry_name.substr(log_entry_name.size() - 10));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3534,
          "old_api": "parse<UInt64>(log_pointer)",
          "new_api": null,
          "old_text": "parse<UInt64>(log_pointer)",
          "new_text": null,
          "old_line_content": "            if (!log_pointer.empty() && log_index < parse<UInt64>(log_pointer))",
          "new_line_content": "        UInt64 log_index = 0;",
          "content_same": false
        },
        {
          "line": 3538,
          "old_api": "tryGet",
          "new_api": null,
          "old_text": "getZooKeeper()->tryGet(zookeeper_path + \"/log/\" + log_entry_name, log_entry_str)",
          "new_text": null,
          "old_line_content": "            bool exists = getZooKeeper()->tryGet(zookeeper_path + \"/log/\" + log_entry_name, log_entry_str);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3549,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Waiting for \" << replica << \" to pull \" << log_node_name << \" to queue\")",
          "new_text": null,
          "old_line_content": "            LOG_DEBUG(log, \"Waiting for \" << replica << \" to pull \" << log_node_name << \" to queue\");",
          "new_line_content": "                log_node_name = log_entry_name;",
          "content_same": false
        },
        {
          "line": 3554,
          "old_api": "std::make_shared<Poco::Event>()",
          "new_api": null,
          "old_text": "std::make_shared<Poco::Event>()",
          "new_text": null,
          "old_line_content": "                zkutil::EventPtr event = std::make_shared<Poco::Event>();",
          "new_line_content": "        if (found)",
          "content_same": false
        },
        {
          "line": 3557,
          "old_api": "parse<UInt64>(log_pointer)",
          "new_api": null,
          "old_text": "parse<UInt64>(log_pointer)",
          "new_text": null,
          "old_line_content": "                if (!log_pointer.empty() && parse<UInt64>(log_pointer) > log_index)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3560,
          "old_api": "wait",
          "new_api": null,
          "old_text": "event->wait()",
          "new_text": null,
          "old_line_content": "                event->wait();",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 3565,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Logical error: unexpected name of log node: \" + entry.znode_name, ErrorCodes::LOGICAL_ERROR)",
          "new_text": null,
          "old_line_content": "        throw Exception(\"Logical error: unexpected name of log node: \" + entry.znode_name, ErrorCodes::LOGICAL_ERROR);",
          "new_line_content": "                    break;",
          "content_same": false
        },
        {
          "line": 3568,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Looking for node corresponding to \" << log_node_name << \" in \" << replica << \" queue\")",
          "new_text": null,
          "old_line_content": "        LOG_DEBUG(log, \"Looking for node corresponding to \" << log_node_name << \" in \" << replica << \" queue\");",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3570,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Looking for corresponding node in \" << replica << \" queue\")",
          "new_text": null,
          "old_line_content": "        LOG_DEBUG(log, \"Looking for corresponding node in \" << replica << \" queue\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3583,
          "old_api": "tryGet",
          "new_api": null,
          "old_text": "getZooKeeper()->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/queue/\" + entry_name, queue_entry_str)",
          "new_text": null,
          "old_line_content": "        bool exists = getZooKeeper()->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/queue/\" + entry_name, queue_entry_str);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3592,
          "old_api": "empty",
          "new_api": null,
          "old_text": "queue_entry_to_wait_for.empty()",
          "new_text": null,
          "old_line_content": "    if (queue_entry_to_wait_for.empty())",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3594,
          "old_api": "size",
          "new_api": null,
          "old_text": "queue_entries.size()",
          "new_text": null,
          "old_line_content": "        LOG_DEBUG(log, \"No corresponding node found. Assuming it has been already processed.\" \" Found \" << queue_entries.size() << \" nodes.\");",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 3598,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Waiting for \" << queue_entry_to_wait_for << \" to disappear from \" << replica << \" queue\")",
          "new_text": null,
          "old_line_content": "    LOG_DEBUG(log, \"Waiting for \" << queue_entry_to_wait_for << \" to disappear from \" << replica << \" queue\");",
          "new_line_content": "    /// While looking for the record, it has already been executed and deleted.",
          "content_same": false
        },
        {
          "line": 3607,
          "old_api": "tryGetZooKeeper",
          "new_api": null,
          "old_text": "tryGetZooKeeper()",
          "new_text": null,
          "old_line_content": "    auto zookeeper = tryGetZooKeeper();",
          "new_line_content": "    /// Third - wait until the entry disappears from the replica queue.",
          "content_same": false
        },
        {
          "line": 3611,
          "old_api": "expired",
          "new_api": null,
          "old_text": "zookeeper->expired()",
          "new_text": null,
          "old_line_content": "    res.is_session_expired = !zookeeper || zookeeper->expired();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3613,
          "old_api": "getStatus",
          "new_api": null,
          "old_text": "queue.getStatus()",
          "new_text": null,
          "old_line_content": "    res.queue = queue.getStatus();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3616,
          "old_api": "size",
          "new_api": null,
          "old_text": "part_check_thread.size()",
          "new_text": null,
          "old_line_content": "    res.parts_to_check = part_check_thread.size();",
          "new_line_content": "    res.is_leader = is_leader;",
          "content_same": false
        },
        {
          "line": 3632,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "zookeeper->getChildren(zookeeper_path + \"/log\")",
          "new_text": null,
          "old_line_content": "        auto log_entries = zookeeper->getChildren(zookeeper_path + \"/log\");",
          "new_line_content": "        res.log_max_index = 0;",
          "content_same": false
        },
        {
          "line": 3634,
          "old_api": "empty",
          "new_api": null,
          "old_text": "log_entries.empty()",
          "new_text": null,
          "old_line_content": "        if (log_entries.empty())",
          "new_line_content": "        res.total_replicas = 0;",
          "content_same": false
        },
        {
          "line": 3640,
          "old_api": "end",
          "new_api": null,
          "old_text": "log_entries.end()",
          "new_text": null,
          "old_line_content": "            const String & last_log_entry = *std::max_element(log_entries.begin(), log_entries.end());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3644,
          "old_api": "get",
          "new_api": null,
          "old_text": "zookeeper->get(replica_path + \"/log_pointer\")",
          "new_text": null,
          "old_line_content": "        String log_pointer_str = zookeeper->get(replica_path + \"/log_pointer\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3645,
          "old_api": "parse<UInt64>(log_pointer_str)",
          "new_api": null,
          "old_text": "parse<UInt64>(log_pointer_str)",
          "new_text": null,
          "old_line_content": "        res.log_pointer = log_pointer_str.empty() ? 0 : parse<UInt64>(log_pointer_str);",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 3661,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "getZooKeeper()->getChildren(zookeeper_path + \"/leader_election\")",
          "new_text": null,
          "old_line_content": "    auto live_replicas = getZooKeeper()->getChildren(zookeeper_path + \"/leader_election\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3662,
          "old_api": "empty",
          "new_api": null,
          "old_text": "live_replicas.empty()",
          "new_text": null,
          "old_line_content": "    if (live_replicas.empty())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3663,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"No active replicas\", ErrorCodes::NO_ACTIVE_REPLICAS)",
          "new_text": null,
          "old_line_content": "        throw Exception(\"No active replicas\", ErrorCodes::NO_ACTIVE_REPLICAS);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3665,
          "old_api": "end",
          "new_api": null,
          "old_text": "live_replicas.end()",
          "new_text": null,
          "old_line_content": "    std::sort(live_replicas.begin(), live_replicas.end());",
          "new_line_content": "/// TODO: Probably it is better to have queue in ZK with tasks for leader (like DDL)",
          "content_same": false
        },
        {
          "line": 3666,
          "old_api": "front",
          "new_api": null,
          "old_text": "live_replicas.front()",
          "new_text": null,
          "old_line_content": "    const auto leader = getZooKeeper()->get(zookeeper_path + \"/leader_election/\" + live_replicas.front());",
          "new_line_content": "void StorageReplicatedMergeTree::sendRequestToLeaderReplica(const ASTPtr & query, const Settings & settings)",
          "content_same": false
        },
        {
          "line": 3671,
          "old_api": "get",
          "new_api": null,
          "old_text": "getZooKeeper()->get(zookeeper_path + \"/replicas/\" + leader + \"/host\")",
          "new_text": null,
          "old_line_content": "    ReplicatedMergeTreeAddress leader_address(getZooKeeper()->get(zookeeper_path + \"/replicas/\" + leader + \"/host\"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3674,
          "old_api": "clone",
          "new_api": null,
          "old_text": "query->clone()",
          "new_text": null,
          "old_line_content": "    auto new_query = query->clone();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3675,
          "old_api": "get",
          "new_api": null,
          "old_text": "new_query.get()",
          "new_text": null,
          "old_line_content": "    if (auto * alter = typeid_cast<ASTAlterQuery *>(new_query.get()))",
          "new_line_content": "    if (leader == replica_name)",
          "content_same": false
        },
        {
          "line": 3680,
          "old_api": "get",
          "new_api": null,
          "old_text": "new_query.get()",
          "new_text": null,
          "old_line_content": "    else if (auto * optimize = typeid_cast<ASTOptimizeQuery *>(new_query.get()))",
          "new_line_content": "    /// TODO: add setters and getters interface for database and table fields of AST",
          "content_same": false
        },
        {
          "line": 3686,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Can't proxy this query. Unsupported query type\", ErrorCodes::NOT_IMPLEMENTED)",
          "new_text": null,
          "old_line_content": "        throw Exception(\"Can't proxy this query. Unsupported query type\", ErrorCodes::NOT_IMPLEMENTED);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3690,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context.getSettingsRef()",
          "new_text": null,
          "old_line_content": "    auto timeouts = ConnectionTimeouts::getTCPTimeoutsWithoutFailover(context.getSettingsRef());",
          "new_line_content": "        optimize->table = leader_address.table;",
          "content_same": false
        },
        {
          "line": 3695,
          "old_api": "getClientInfo",
          "new_api": null,
          "old_text": "context.getClientInfo()",
          "new_text": null,
          "old_line_content": "        context.getClientInfo().current_user, context.getClientInfo().current_password, timeouts, \"ClickHouse replica\");",
          "new_line_content": "    /// Query send with current user credentials",
          "content_same": false
        },
        {
          "line": 3700,
          "old_api": "copyData",
          "new_api": null,
          "old_text": "copyData(stream, output)",
          "new_text": null,
          "old_line_content": "    copyData(stream, output);",
          "new_line_content": "        leader_address.queries_port,",
          "content_same": false
        },
        {
          "line": 3708,
          "old_api": "getEntries",
          "new_api": null,
          "old_text": "queue.getEntries(res)",
          "new_text": null,
          "old_line_content": "    queue.getEntries(res);",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 3719,
          "old_api": "load",
          "new_api": null,
          "old_text": "last_queue_update_start_time.load()",
          "new_text": null,
          "old_line_content": "    time_t queue_update_start_time = last_queue_update_start_time.load();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3720,
          "old_api": "load",
          "new_api": null,
          "old_text": "last_queue_update_finish_time.load()",
          "new_text": null,
          "old_line_content": "    time_t queue_update_finish_time = last_queue_update_finish_time.load();",
          "new_line_content": "    time_t min_unprocessed_insert_time = 0;",
          "content_same": false
        },
        {
          "line": 3751,
          "old_api": "assertNotReadonly",
          "new_api": null,
          "old_text": "assertNotReadonly()",
          "new_text": null,
          "old_line_content": "    assertNotReadonly();",
          "new_line_content": "        /// Everything is up-to-date.",
          "content_same": false
        },
        {
          "line": 3753,
          "old_api": "time",
          "new_api": null,
          "old_text": "time(nullptr)",
          "new_text": null,
          "old_line_content": "    time_t current_time = time(nullptr);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3755,
          "old_api": "getAbsoluteDelay",
          "new_api": null,
          "old_text": "getAbsoluteDelay()",
          "new_text": null,
          "old_line_content": "    out_absolute_delay = getAbsoluteDelay();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3763,
          "old_api": "static_cast<time_t>(data.settings.min_relative_delay_to_yield_leadership)",
          "new_api": null,
          "old_text": "static_cast<time_t>(data.settings.min_relative_delay_to_yield_leadership)",
          "new_text": null,
          "old_line_content": "    if (out_absolute_delay < static_cast<time_t>(data.settings.min_relative_delay_to_yield_leadership))",
          "new_line_content": "    out_relative_delay = 0;",
          "content_same": false
        },
        {
          "line": 3766,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "    auto zookeeper = getZooKeeper();",
          "new_line_content": "      *  (if this replica lags behind any other live replica, or zero, otherwise).",
          "content_same": false
        },
        {
          "line": 3771,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "zookeeper->getChildren(zookeeper_path + \"/replicas\")",
          "new_text": null,
          "old_line_content": "    Strings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 3779,
          "old_api": "exists",
          "new_api": null,
          "old_text": "zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")",
          "new_text": null,
          "old_line_content": "        if (!zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\"))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3783,
          "old_api": "tryGet",
          "new_api": null,
          "old_text": "zookeeper->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/min_unprocessed_insert_time\", value)",
          "new_text": null,
          "old_line_content": "        if (!zookeeper->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/min_unprocessed_insert_time\", value))",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 3810,
          "old_api": "std::min(current_time, max_replicas_unprocessed_insert_time)",
          "new_api": null,
          "old_text": "std::min(current_time, max_replicas_unprocessed_insert_time)",
          "new_text": null,
          "old_line_content": "        max_replicas_unprocessed_insert_time = std::min(current_time, max_replicas_unprocessed_insert_time);",
          "new_line_content": "            max_replicas_unprocessed_insert_time = replica_time;",
          "content_same": false
        },
        {
          "line": 3820,
          "old_api": "getPartitionIDFromQuery",
          "new_api": null,
          "old_text": "data.getPartitionIDFromQuery(partition, context)",
          "new_text": null,
          "old_line_content": "    String partition_id = data.getPartitionIDFromQuery(partition, context);",
          "new_line_content": "            out_relative_delay = out_absolute_delay - min_replicas_delay;",
          "content_same": false
        },
        {
          "line": 3823,
          "old_api": "back",
          "new_api": null,
          "old_text": "from.back()",
          "new_text": null,
          "old_line_content": "    if (from.back() == '/')",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3824,
          "old_api": "size",
          "new_api": null,
          "old_text": "from.size()",
          "new_text": null,
          "old_line_content": "        from.resize(from.size() - 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3826,
          "old_api": "LOG_INFO",
          "new_api": null,
          "old_text": "LOG_INFO(log, \"Will fetch partition \" << partition_id << \" from shard \" << from_)",
          "new_text": null,
          "old_line_content": "    LOG_INFO(log, \"Will fetch partition \" << partition_id << \" from shard \" << from_);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3832,
          "old_api": "getFullPath",
          "new_api": null,
          "old_text": "data.getFullPath()",
          "new_text": null,
          "old_line_content": "    for (Poco::DirectoryIterator dir_it{data.getFullPath() + \"detached/\"}; dir_it != dir_end; ++dir_it)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3835,
          "old_api": "name",
          "new_api": null,
          "old_text": "dir_it.name()",
          "new_text": null,
          "old_line_content": "        if (MergeTreePartInfo::tryParsePartName(dir_it.name(), &part_info, data.format_version)",
          "new_line_content": "    /** Let's check that there is no such partition in the `detached` directory (where we will write the downloaded parts).",
          "content_same": false
        },
        {
          "line": 3837,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Detached partition \" + partition_id + \" already exists.\", ErrorCodes::PARTITION_ALREADY_EXISTS)",
          "new_text": null,
          "old_line_content": "            throw Exception(\"Detached partition \" + partition_id + \" already exists.\", ErrorCodes::PARTITION_ALREADY_EXISTS);",
          "new_line_content": "      */",
          "content_same": false
        },
        {
          "line": 3845,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "        auto zookeeper = getZooKeeper();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3848,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "zookeeper->getChildren(from + \"/replicas\")",
          "new_text": null,
          "old_line_content": "        replicas = zookeeper->getChildren(from + \"/replicas\");",
          "new_line_content": "    zkutil::Strings active_replicas;",
          "content_same": false
        },
        {
          "line": 3851,
          "old_api": "size",
          "new_api": null,
          "old_text": "replicas.size()",
          "new_text": null,
          "old_line_content": "        active_replicas.reserve(replicas.size());",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3854,
          "old_api": "exists",
          "new_api": null,
          "old_text": "zookeeper->exists(from + \"/replicas/\" + replica + \"/is_active\")",
          "new_text": null,
          "old_line_content": "            if (zookeeper->exists(from + \"/replicas/\" + replica + \"/is_active\"))",
          "new_line_content": "        /// List of replicas of source shard.",
          "content_same": false
        },
        {
          "line": 3857,
          "old_api": "empty",
          "new_api": null,
          "old_text": "active_replicas.empty()",
          "new_text": null,
          "old_line_content": "        if (active_replicas.empty())",
          "new_line_content": "        /// Leave only active replicas.",
          "content_same": false
        },
        {
          "line": 3867,
          "old_api": "std::numeric_limits<UInt64>::max()",
          "new_api": null,
          "old_text": "std::numeric_limits<UInt64>::max()",
          "new_text": null,
          "old_line_content": "        UInt64 min_queue_size = std::numeric_limits<UInt64>::max();",
          "new_line_content": "        /** You must select the best (most relevant) replica.",
          "content_same": false
        },
        {
          "line": 3873,
          "old_api": "get",
          "new_api": null,
          "old_text": "zookeeper->get(current_replica_path + \"/log_pointer\")",
          "new_text": null,
          "old_line_content": "            String log_pointer_str = zookeeper->get(current_replica_path + \"/log_pointer\");",
          "new_line_content": "        Int64 max_log_pointer = -1;",
          "content_same": false
        },
        {
          "line": 3877,
          "old_api": "get",
          "new_api": null,
          "old_text": "zookeeper->get(current_replica_path + \"/queue\", &stat)",
          "new_text": null,
          "old_line_content": "            zookeeper->get(current_replica_path + \"/queue\", &stat);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3890,
          "old_api": "empty",
          "new_api": null,
          "old_text": "best_replica.empty()",
          "new_text": null,
          "old_line_content": "    if (best_replica.empty())",
          "new_line_content": "                max_log_pointer = log_pointer;",
          "content_same": false
        },
        {
          "line": 3891,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Logical error: cannot choose best replica.\", ErrorCodes::LOGICAL_ERROR)",
          "new_text": null,
          "old_line_content": "        throw Exception(\"Logical error: cannot choose best replica.\", ErrorCodes::LOGICAL_ERROR);",
          "new_line_content": "                min_queue_size = queue_size;",
          "content_same": false
        },
        {
          "line": 3893,
          "old_api": "size",
          "new_api": null,
          "old_text": "active_replicas.size()",
          "new_text": null,
          "old_line_content": "    LOG_INFO(log, \"Found \" << replicas.size() << \" replicas, \" << active_replicas.size() << \" of them are active.\"",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3910,
          "old_api": "size",
          "new_api": null,
          "old_text": "missing_parts.size()",
          "new_text": null,
          "old_line_content": "            LOG_INFO(log, \"Some of parts (\" << missing_parts.size() << \") are missing. Will try to fetch covering parts.\");",
          "new_line_content": "      */",
          "content_same": false
        },
        {
          "line": 3913,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Too many retries to fetch parts from \" + best_replica_path, ErrorCodes::TOO_MANY_RETRIES_TO_FETCH_PARTS)",
          "new_text": null,
          "old_line_content": "            throw Exception(\"Too many retries to fetch parts from \" + best_replica_path, ErrorCodes::TOO_MANY_RETRIES_TO_FETCH_PARTS);",
          "new_line_content": "    Strings missing_parts;",
          "content_same": false
        },
        {
          "line": 3915,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "getZooKeeper()->getChildren(best_replica_path + \"/parts\")",
          "new_text": null,
          "old_line_content": "        Strings parts = getZooKeeper()->getChildren(best_replica_path + \"/parts\");",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3919,
          "old_api": "empty",
          "new_api": null,
          "old_text": "missing_parts.empty()",
          "new_text": null,
          "old_line_content": "        if (missing_parts.empty())",
          "new_line_content": "        if (try_no >= 5)",
          "content_same": false
        },
        {
          "line": 3921,
          "old_api": "getParts",
          "new_api": null,
          "old_text": "active_parts_set.getParts()",
          "new_text": null,
          "old_line_content": "            parts_to_fetch = active_parts_set.getParts();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3927,
          "old_api": "MergeTreePartInfo::fromPartName(part, data.format_version)",
          "new_api": null,
          "old_text": "MergeTreePartInfo::fromPartName(part, data.format_version)",
          "new_text": null,
          "old_line_content": "                if (MergeTreePartInfo::fromPartName(part, data.format_version).partition_id == partition_id)",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3931,
          "old_api": "std::move(parts_to_fetch_partition)",
          "new_api": null,
          "old_text": "std::move(parts_to_fetch_partition)",
          "new_text": null,
          "old_line_content": "            parts_to_fetch = std::move(parts_to_fetch_partition);",
          "new_line_content": "            Strings parts_to_fetch_partition;",
          "content_same": false
        },
        {
          "line": 3933,
          "old_api": "empty",
          "new_api": null,
          "old_text": "parts_to_fetch.empty()",
          "new_text": null,
          "old_line_content": "            if (parts_to_fetch.empty())",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 3942,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "parts_to_fetch.push_back(containing_part)",
          "new_text": null,
          "old_line_content": "                    parts_to_fetch.push_back(containing_part);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3944,
          "old_api": "LOG_WARNING",
          "new_api": null,
          "old_text": "LOG_WARNING(log, \"Part \" << missing_part << \" on replica \" << best_replica_path << \" has been vanished.\")",
          "new_text": null,
          "old_line_content": "                    LOG_WARNING(log, \"Part \" << missing_part << \" on replica \" << best_replica_path << \" has been vanished.\");",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3950,
          "old_api": "clear",
          "new_api": null,
          "old_text": "missing_parts.clear()",
          "new_text": null,
          "old_line_content": "        missing_parts.clear();",
          "new_line_content": "                else",
          "content_same": false
        },
        {
          "line": 3959,
          "old_api": "code",
          "new_api": null,
          "old_text": "e.code()",
          "new_text": null,
          "old_line_content": "                if (e.code() != ErrorCodes::RECEIVED_ERROR_FROM_REMOTE_IO_SERVER && e.code() != ErrorCodes::RECEIVED_ERROR_TOO_MANY_REQUESTS)",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3963,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "missing_parts.push_back(part)",
          "new_text": null,
          "old_line_content": "                missing_parts.push_back(part);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3968,
          "old_api": "empty",
          "new_api": null,
          "old_text": "missing_parts.empty()",
          "new_text": null,
          "old_line_content": "    } while (!missing_parts.empty());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3974,
          "old_api": "freezePartition",
          "new_api": null,
          "old_text": "data.freezePartition(partition, with_name, context)",
          "new_text": null,
          "old_line_content": "    data.freezePartition(partition, with_name, context);",
          "new_line_content": "        ++try_no;",
          "content_same": false
        },
        {
          "line": 4045,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "        auto zookeeper = getZooKeeper();",
          "new_line_content": "    String mutations_path = zookeeper_path + \"/mutations\";",
          "content_same": false
        },
        {
          "line": 4048,
          "old_api": "get",
          "new_api": null,
          "old_text": "zookeeper->get(mutations_path, &mutations_stat)",
          "new_text": null,
          "old_line_content": "        zookeeper->get(mutations_path, &mutations_stat);",
          "new_line_content": "    /// nodes for mutations are created in the same order as the corresponding block numbers.",
          "content_same": false
        },
        {
          "line": 4053,
          "old_api": "getLocks",
          "new_api": null,
          "old_text": "block_number_locks.getLocks()",
          "new_text": null,
          "old_line_content": "        for (const auto & lock : block_number_locks.getLocks())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4056,
          "old_api": "time",
          "new_api": null,
          "old_text": "time(nullptr)",
          "new_text": null,
          "old_line_content": "        entry.create_time = time(nullptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4059,
          "old_api": "String",
          "new_api": null,
          "old_text": "String()",
          "new_text": null,
          "old_line_content": "        requests.emplace_back(zkutil::makeSetRequest(mutations_path, String(), mutations_stat.version));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4061,
          "old_api": "toString",
          "new_api": null,
          "old_text": "entry.toString()",
          "new_text": null,
          "old_line_content": "            mutations_path + \"/\", entry.toString(), zkutil::CreateMode::PersistentSequential));",
          "new_line_content": "            entry.block_numbers[lock.partition_id] = lock.number;",
          "content_same": false
        },
        {
          "line": 4064,
          "old_api": "tryMulti",
          "new_api": null,
          "old_text": "zookeeper->tryMulti(requests, responses)",
          "new_text": null,
          "old_line_content": "        int32_t rc = zookeeper->tryMulti(requests, responses);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4069,
          "old_api": "get",
          "new_api": null,
          "old_text": "responses[1].get()",
          "new_text": null,
          "old_line_content": "                static_cast<const zkutil::CreateResponse *>(responses[1].get())->path_created;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4070,
          "old_api": "find_last_of",
          "new_api": null,
          "old_text": "path_created.find_last_of('/')",
          "new_text": null,
          "old_line_content": "            entry.znode_name = path_created.substr(path_created.find_last_of('/') + 1);",
          "new_line_content": "        zkutil::Responses responses;",
          "content_same": false
        },
        {
          "line": 4080,
          "old_api": "zkutil::KeeperException(\"Unable to create a mutation znode\", rc)",
          "new_api": null,
          "old_text": "zkutil::KeeperException(\"Unable to create a mutation znode\", rc)",
          "new_text": null,
          "old_line_content": "            throw zkutil::KeeperException(\"Unable to create a mutation znode\", rc);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 4086,
          "old_api": "getMutationsStatus",
          "new_api": null,
          "old_text": "queue.getMutationsStatus()",
          "new_text": null,
          "old_line_content": "    return queue.getMutationsStatus();",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 4094,
          "old_api": "lockStructure",
          "new_api": null,
          "old_text": "lockStructure(false, __PRETTY_FUNCTION__)",
          "new_text": null,
          "old_line_content": "    auto table_lock = lockStructure(false, __PRETTY_FUNCTION__);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 4095,
          "old_api": "getZooKeeper",
          "new_api": null,
          "old_text": "getZooKeeper()",
          "new_text": null,
          "old_line_content": "    auto zookeeper = getZooKeeper();",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 133,
      "total_additions": 443,
      "total_deletions": 440,
      "total_api_changes": 1016
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 9,
        "api_related_lines": 1016,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          2285,
          2290,
          2298,
          2309
        ]
      }
    },
    "api_calls_before": 1365,
    "api_calls_after": 1370,
    "diff_info": {
      "added_lines": 9,
      "removed_lines": 2,
      "total_diff_lines": 36
    }
  }
}