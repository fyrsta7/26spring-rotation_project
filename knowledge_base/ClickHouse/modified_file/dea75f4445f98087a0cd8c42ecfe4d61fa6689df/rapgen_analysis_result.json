{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/dea75f4445f98087a0cd8c42ecfe4d61fa6689df",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/dea75f4445f98087a0cd8c42ecfe4d61fa6689df/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/dea75f4445f98087a0cd8c42ecfe4d61fa6689df/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/dea75f4445f98087a0cd8c42ecfe4d61fa6689df/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 442,
          "old_api": "ize_t i = 0; i < rows; ++i)\n\t\t\t{\n\t\t\t\t/// Строим",
          "new_api": "ev_result;\n\n\t\t\t/// Для всех строчек\n\t\t\tfor (siz",
          "old_text": "ize_t i = 0; i < rows; ++i)\n\t\t\t{\n\t\t\t\t/// Строим",
          "new_text": "ev_result;\n\n\t\t\t/// Для всех строчек\n\t\t\tfor (siz",
          "old_line_content": null,
          "new_line_content": "\t\texecuteOrdinary(key_columns, vec_res, negative);",
          "content_same": true
        },
        {
          "line": 448,
          "old_api": "find",
          "new_api": "])) - 1);\n\n\t\t\t\tif",
          "old_text": "d() != set.find(r",
          "new_text": "])) - 1);\n\n\t\t\t\tif",
          "old_line_content": null,
          "new_line_content": "\tsize_t keys_size = data_types.size();",
          "content_same": true
        },
        {
          "line": 449,
          "old_api": "else if (const ColumnF",
          "new_api": "= prev_key)\n\t\t\t\t\tvec_r",
          "old_text": "else if (const ColumnF",
          "new_text": "= prev_key)\n\t\t\t\t\tvec_r",
          "old_line_content": null,
          "new_line_content": "\tsize_t rows = key_columns[0]->size();",
          "content_same": true
        },
        {
          "line": 461,
          "old_api": "+i)\n\t\t\t{\n\t\t\t\t//",
          "new_api": "ng *>(&column))",
          "old_text": "+i)\n\t\t\t{\n\t\t\t\t//",
          "new_text": "ng *>(&column))",
          "old_line_content": null,
          "new_line_content": "\t\t\tUInt64 key = column.get64(i);",
          "content_same": true
        },
        {
          "line": 462,
          "old_api": "], n);\n\t\t\t\tve",
          "new_api": "const Colum",
          "old_text": "], n);\n\t\t\t\tve",
          "new_text": "\t\tconst Colum",
          "old_line_content": null,
          "new_line_content": "\t\t\tvec_res[i] = negative ^ (set.end() != set.find(key));",
          "content_same": true
        },
        {
          "line": 470,
          "old_api": "end",
          "new_api": "* n], n);\n\t\t\t\tvec_res[i] = negative ^ (se",
          "old_text": "bool res = negative ^ (set.end() != set.fi",
          "new_text": " * n], n);\n\t\t\t\tvec_res[i] = negative ^ (se",
          "old_line_content": null,
          "new_line_content": "\t\tif (const ColumnString * column_string = typeid_cast<const ColumnString *>(&column))",
          "content_same": true
        },
        {
          "line": 472,
          "old_api": "ля всех строчек\n\t\t\tfor (siz",
          "new_api": "t ColumnConstString * colum",
          "old_text": "ля всех строчек\n\t\t\tfor (siz",
          "new_text": "t ColumnConstString * colum",
          "old_line_content": null,
          "new_line_content": "\t\t\tconst ColumnString::Offsets_t & offsets = column_string->getOffsets();",
          "content_same": true
        },
        {
          "line": 473,
          "old_api": "res;\n\t\t}\n\t\telse\n\t\t\tthrow",
          "new_api": "ring *>(&column))\n\t\t{",
          "old_text": " res;\n\t\t}\n\t\telse\n\t\t\tthrow",
          "new_text": "ring *>(&column))\n\t\t{\n\t\t\t",
          "old_line_content": null,
          "new_line_content": "\t\t\tconst ColumnString::Chars_t & data = column_string->getChars();",
          "content_same": true
        },
        {
          "line": 496,
          "old_api": "type == KEY_64)\n\t{\n\t\tconst SetUInt64 & set = *k",
          "new_api": "throw Exception(\"Unk",
          "old_text": "type == KEY_64)\n\t{\n\t\tconst SetUInt64 & set = *k",
          "new_text": "\tthrow Exception(\"Unk",
          "old_line_content": "\t\telse if (const ColumnConstString * column_string = typeid_cast<const ColumnConstString *>(&column))",
          "new_line_content": "\t\t\tsize_t n = column_string->getN();",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": "getChars",
          "new_api": "end",
          "old_text": "s();\n\t\t\tconst ColumnString::Chars_t & data = column_string->getChars();",
          "new_text": "t.end() != set.f",
          "old_line_content": "\t\tthrow Exception(\"Unknown set variant.\", ErrorCodes::UNKNOWN_SET_DATA_VARIANT);",
          "new_line_content": "\t\t\tthrow Exception(\"Illegal type of column when creating set with string key: \" + column.getName(), ErrorCodes::ILLEGAL_COLUMN);",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": "ts[i];\n\t\t}\n\t}\n\telse\n\t\tthr",
          "new_api": "ех элементов",
          "old_text": "ts[i];\n\t\t}\n\t}\n\telse\n\t\tthr",
          "new_text": "ех элементов\n",
          "old_line_content": "\t\t\tconst ColumnFixedString::Chars_t & data = column_string->getChars();",
          "new_line_content": "\t\t\t\t\tres |= negative ^ (set.end() != set.find(ref));",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "begin",
          "new_api": "if (std::binary_s",
          "old_text": "begin(), orde",
          "new_text": "\tif (std::binary_s",
          "old_line_content": "\t\t\tres |= negative ^ (set.end() != set.find(key));",
          "new_line_content": "\tsize_t rows = key_column->size();",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": "end",
          "new_api": "e;\n\t\t}\n\t\telse",
          "old_text": "et_elements->end() && ",
          "new_text": "e;\n\t\t}\n\t\telse",
          "old_line_content": "\t\t\tres |= negative ^ (set.end() != set.find(StringRef(get<String>(values[j]))));",
          "new_line_content": "\tfor (size_t j = 0; j < values.size(); ++j)",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": "",
          "new_api": "begin",
          "old_text": "",
          "new_text": "s->begin() && *(right",
          "old_line_content": "\t\tif (std::binary_search(ordered_set_elements->begin(), ordered_set_elements->end(), left))",
          "new_line_content": "\t\treturn BoolMask(false, true);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 643,
          "old_api": null,
          "new_api": "n и не выбираем для notIn\n\tif (ra",
          "old_text": null,
          "new_text": "n и не выбираем для notIn\n\tif (ra",
          "old_line_content": "\t{",
          "new_line_content": "\t\tColumnPtr full_column = key_column->convertToFullColumn();",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": null,
          "new_api": "&& range.right_bounded && range.right_inc",
          "old_text": null,
          "new_text": "&& range.right_bounded && range.right_inc",
          "old_line_content": "\t\tif (type == KEY_64)",
          "new_line_content": "\t\texecuteArray(typeid_cast<ColumnArray *>(&*full_column), vec_res, negative);",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "elements->begin(), or",
          "old_line_content": "\t\t}",
          "new_line_content": "\tArray values = key_column->getData();",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": null,
          "new_api": "::Offsets_t & nested_offsets = col",
          "old_text": null,
          "new_text": "::Offsets_t & nested_offsets = col",
          "old_line_content": "",
          "new_line_content": "\t\t\tvec_res[i] = negative ^ (set.end() != set.find(keys_fit_128_bits ? pack128(i, keys_size, key_columns, key_sizes) : hash128(i, keys_size, key_columns)));",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": null,
          "new_api": "getChars",
          "old_text": null,
          "new_text": "s();\n\t\t\tconst ColumnString::Chars_t & data = column_string->getChars();",
          "old_line_content": "\t\tconst SetUInt64 & set = *key64;",
          "new_line_content": "\t\tthrow Exception(\"Unknown set variant.\", ErrorCodes::UNKNOWN_SET_DATA_VARIANT);",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": null,
          "new_api": "ange.left_bounded ? st",
          "old_text": null,
          "new_text": "ange.left_bounded ? st",
          "old_line_content": "\t\tif (res)",
          "new_line_content": "\t\t\tUInt64 key = get<UInt64>(values[j]);",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "begin(), orde",
          "old_line_content": "\t\t\tbreak;",
          "new_line_content": "\t\t\tres |= negative ^ (set.end() != set.find(key));",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": null,
          "new_api": "ментов\n\t\t\t\tfor (si",
          "old_text": null,
          "new_text": "ментов\n\t\t\t\tfor (si",
          "old_line_content": "\t\t{",
          "new_line_content": "\tsize_t rows = key_column->size();",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": null,
          "new_api": "{\n\t\t\t\t\t/// Строим клю",
          "old_text": null,
          "new_text": "\t\t\t{\n\t\t\t\t\t/// Строим клю",
          "old_line_content": "\t\t\tUInt8 res = 0;",
          "new_line_content": "\tconst ColumnArray::Offsets_t & offsets = key_column->getOffsets();",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": null,
          "new_api": "nested_offsets[j - 1]",
          "old_text": null,
          "new_text": "nested_offsets[j - 1]",
          "old_line_content": "\t\t\t/// Для всех элементов",
          "new_line_content": "\tconst IColumn & nested_column = key_column->getData();",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "et_elements->end() && ",
          "old_line_content": "\t\tvec_res[i] = res;",
          "new_line_content": "\t\t\tres |= negative ^ (set.end() != set.find(StringRef(get<String>(values[j]))));",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": null,
          "new_api": "ft_it;\n\n\t\t/// если весь диапазон, правее in\n\t\tif (left_it == ordered_se",
          "old_text": null,
          "new_text": "ft_it;\n\n\t\t/// если весь диапазон, правее in\n\t\tif (left_it == ordered_se",
          "old_line_content": "BoolMask Set::mayBeTrueInRange(const Range & range)",
          "new_line_content": "\t\t\tthrow Exception(\"Unknown set variant.\", ErrorCodes::UNKNOWN_SET_DATA_VARIANT);",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": null,
          "new_api": "nested_column))\n\t\t{",
          "old_text": null,
          "new_text": "nested_column))\n\t\t{\n\t\t",
          "old_line_content": "\t\tconst SetString & set = *key_string;",
          "new_line_content": "\t\t\t\tUInt64 key = nested_column.get64(j);",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": null,
          "new_api": "const ColumnF",
          "old_text": null,
          "new_text": "const ColumnF",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tres |= negative ^ (set.end() != set.find(key));",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": null,
          "new_api": "nd",
          "old_text": null,
          "new_text": "nd();\n\t\t\tif (range.right_bounded && !range.r",
          "old_line_content": "\t/// Если во всем диапазоне одинаковый ключ и он есть в Set, то выбираем блок для in и не выбираем для notIn",
          "new_line_content": "\t\tthrow DB::Exception(\"Ordered set in not created.\");",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": null,
          "new_api": "luded && right_it != ordered_",
          "old_text": null,
          "new_text": "luded && right_it != ordered_",
          "old_line_content": "\t{",
          "new_line_content": "\tif (ordered_set_elements->empty())",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": null,
          "new_api": "ize_t j = prev_offset; j < offsets[i]; ++j)\n\t\t\t\t{",
          "old_text": null,
          "new_text": "ize_t j = prev_offset; j < offsets[i]; ++j)\n\t\t\t\t{",
          "old_line_content": "\t\t\t\tfor (size_t j = prev_offset; j < offsets[i]; ++j)",
          "new_line_content": "\t\tif (const ColumnString * column_string = typeid_cast<const ColumnString *>(&nested_column))",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": null,
          "new_api": "res |= negative ^ (se",
          "old_text": null,
          "new_text": "\n\t\t\t\t\tres |= negative ^ (se",
          "old_line_content": "\t\t\t\t\t/// Строим ключ",
          "new_line_content": "\t\t\tconst ColumnString::Offsets_t & nested_offsets = column_string->getOffsets();",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": null,
          "new_api": "break;\n\t\t\t\t}\n\t\t\t\tvec",
          "old_text": null,
          "new_text": "\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvec",
          "old_line_content": "\t\t\t\t\tsize_t begin = j == 0 ? 0 : nested_offsets[j - 1];",
          "new_line_content": "\t\t\tconst ColumnString::Chars_t & data = column_string->getChars();",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\telse",
          "new_line_content": "\t\tif (std::binary_search(ordered_set_elements->begin(), ordered_set_elements->end(), left))",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": null,
          "new_api": "(i, 1, nested_columns, key_sizes) : hash128(i, 1, nest",
          "old_text": null,
          "new_text": "(i, 1, nested_columns, key_sizes) : hash128(i, 1, nest",
          "old_line_content": "\t\t\t\tfor (size_t j = prev_offset; j < offsets[i]; ++j)",
          "new_line_content": "\t\telse if (const ColumnFixedString * column_string = typeid_cast<const ColumnFixedString *>(&nested_column))",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": null,
          "new_api": "f (res)\n\t\t\t\t\tbreak;",
          "old_text": null,
          "new_text": "f (res)\n\t\t\t\t\tbreak;\n\t",
          "old_line_content": "\t\t\t\t\t/// Строим ключ",
          "new_line_content": "\t\t\tsize_t n = column_string->getN();",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": null,
          "new_api": "ts[i];\n\t\t}\n\t}\n\telse\n\t\tthr",
          "old_text": null,
          "new_text": "ts[i];\n\t\t}\n\t}\n\telse\n\t\tthr",
          "old_line_content": "\t\t\t\t\tStringRef ref(&data[j * n], n);",
          "new_line_content": "\t\t\tconst ColumnFixedString::Chars_t & data = column_string->getChars();",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\t\t--right_it;",
          "new_line_content": "\t\t\tauto right_it = range.right_bounded ? std::upper_bound(ordered_set_elements->begin(), ordered_set_elements->end(), right) : ordered_set_elements->end();",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\t\t/// в диапазон не попадает ни одного ключа из in",
          "new_line_content": "\t\t\tif (range.right_bounded && !range.right_included && right_it != ordered_set_elements->begin() && *(right_it--) == right)",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\tif (right_it == ordered_set_elements->begin())",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": null,
          "new_api": "column), vec_",
          "old_text": null,
          "new_text": "column), vec_",
          "old_line_content": "\telse if (type == HASHED)",
          "new_line_content": "\t\t\t\t\tres |= negative ^ (set.end() != set.find(ref));",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": null,
          "new_api": ")\n\t{\n\t\tif (type == KEY_",
          "old_text": null,
          "new_text": ")\n\t{\n\t\tif (type == KEY_",
          "old_line_content": "\t\t\tUInt8 res = 0;",
          "new_line_content": "\t\t\tthrow Exception(\"Illegal type of column when looking for Array(String) key: \" + nested_column.getName(), ErrorCodes::ILLEGAL_COLUMN);",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\treturn BoolMask(can_be_true, can_be_false);",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": null,
          "new_api": "for (size_",
          "old_text": null,
          "new_text": "\n\t\tfor (size_",
          "old_line_content": "\t\t\t/// Для всех строчек",
          "new_line_content": "\t\t\t\t\tprev_result = negative ^ (set.end() != set.find(ref));",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": null,
          "new_api": "umns, key_sizes) : hash128(i, keys_size, key_co",
          "old_text": null,
          "new_text": "umns, key_sizes) : hash128(i, keys_size, key_co",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\telse if (const ColumnFixedString * column_string = typeid_cast<const ColumnFixedString *>(&column))",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": null,
          "new_api": "A_VARIANT);\n}\n\nvoid Set::",
          "old_text": null,
          "new_text": "A_VARIANT);\n}\n\nvoid Set::",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\tconst ColumnFixedString::Chars_t & data = column_string->getChars();",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": null,
          "new_api": "InRange",
          "old_text": null,
          "new_text": "InRange(const Range & range)\n",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tres |= negative ^ (set.end() != set.find(keys_fit_128_bits ? pack128(i, 1, nested_columns, key_sizes) : hash128(i, 1, nested_columns)));",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": null,
          "new_api": "getOffsets",
          "old_text": null,
          "new_text": "->getOffsets(",
          "old_line_content": "\t\telse",
          "new_line_content": "\t\t\t\tvec_res[i] = negative ^ (set.end() != set.find(ref));",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": null,
          "new_api": "type == KEY_64)\n\t{\n\t\tconst SetUInt64 & set = *k",
          "old_text": null,
          "new_text": "type == KEY_64)\n\t{\n\t\tconst SetUInt64 & set = *k",
          "old_line_content": "\telse if (type == HASHED)",
          "new_line_content": "\t\telse if (const ColumnConstString * column_string = typeid_cast<const ColumnConstString *>(&column))",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "ments->empty())\n\t\treturn BoolMask(false, true);\n\n\tconst Field & left = ",
          "old_line_content": "",
          "new_line_content": "\t\tthrow Exception(\"Unknown set variant.\", ErrorCodes::UNKNOWN_SET_DATA_VARIANT);",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": null,
          "new_api": "ize_t i = 0; i < rows; +",
          "old_text": null,
          "new_text": "ize_t i = 0; i < rows; +",
          "old_line_content": "\t\tconst SetHashed & set = *hashed;",
          "new_line_content": "\t\t\tbool res = negative ^ (set.end() != set.find(StringRef(column_string->getData())));",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 513,
          "old_api": "::Offsets_t & nested_offsets = col",
          "new_api": null,
          "old_text": "::Offsets_t & nested_offsets = col",
          "new_text": null,
          "old_line_content": "\t\t\tvec_res[i] = negative ^ (set.end() != set.find(keys_fit_128_bits ? pack128(i, keys_size, key_columns, key_sizes) : hash128(i, keys_size, key_columns)));",
          "new_line_content": "\t\t\t\tvec_res[i] = res;",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "e;\n\t\t}\n\t\telse",
          "new_api": null,
          "old_text": "e;\n\t\t}\n\t\telse",
          "new_text": null,
          "old_line_content": "\tfor (size_t j = 0; j < values.size(); ++j)",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "ange.left_bounded ? st",
          "new_api": null,
          "old_text": "ange.left_bounded ? st",
          "new_text": null,
          "old_line_content": "\t\t\tUInt64 key = get<UInt64>(values[j]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 521,
          "old_api": "ментов\n\t\t\t\tfor (si",
          "new_api": null,
          "old_text": "ментов\n\t\t\t\tfor (si",
          "new_text": null,
          "old_line_content": "\tsize_t rows = key_column->size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": "{\n\t\t\t\t\t/// Строим клю",
          "new_api": null,
          "old_text": "\t\t\t{\n\t\t\t\t\t/// Строим клю",
          "new_text": null,
          "old_line_content": "\tconst ColumnArray::Offsets_t & offsets = key_column->getOffsets();",
          "new_line_content": "\t\t/// Для всех строчек",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": "nested_offsets[j - 1]",
          "new_api": null,
          "old_text": "nested_offsets[j - 1]",
          "new_text": null,
          "old_line_content": "\tconst IColumn & nested_column = key_column->getData();",
          "new_line_content": "\t\tfor (size_t i = 0; i < rows; ++i)",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": "ft_it;\n\n\t\t/// если весь диапазон, правее in\n\t\tif (left_it == ordered_se",
          "new_api": null,
          "old_text": "ft_it;\n\n\t\t/// если весь диапазон, правее in\n\t\tif (left_it == ordered_se",
          "new_text": null,
          "old_line_content": "\t\t\tthrow Exception(\"Unknown set variant.\", ErrorCodes::UNKNOWN_SET_DATA_VARIANT);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "nested_column))\n\t\t{",
          "new_api": null,
          "old_text": "nested_column))\n\t\t{\n\t\t",
          "new_text": null,
          "old_line_content": "\t\t\t\tUInt64 key = nested_column.get64(j);",
          "new_line_content": "\t\tconst SetUInt64 & set = *key64;",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "const ColumnF",
          "new_api": null,
          "old_text": "const ColumnF",
          "new_text": null,
          "old_line_content": "\t\t\t\tres |= negative ^ (set.end() != set.find(key));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "nd",
          "new_api": null,
          "old_text": "nd();\n\t\t\tif (range.right_bounded && !range.r",
          "new_text": null,
          "old_line_content": "\t\tthrow DB::Exception(\"Ordered set in not created.\");",
          "new_line_content": "\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": "luded && right_it != ordered_",
          "new_api": null,
          "old_text": "luded && right_it != ordered_",
          "new_text": null,
          "old_line_content": "\tif (ordered_set_elements->empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": "begin",
          "new_api": null,
          "old_text": "s->begin() && *(right",
          "new_text": null,
          "old_line_content": "\t\treturn BoolMask(false, true);",
          "new_line_content": "\t/// Для всех строчек",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "ize_t j = prev_offset; j < offsets[i]; ++j)\n\t\t\t\t{",
          "new_api": null,
          "old_text": "ize_t j = prev_offset; j < offsets[i]; ++j)\n\t\t\t\t{",
          "new_text": null,
          "old_line_content": "\t\tif (const ColumnString * column_string = typeid_cast<const ColumnString *>(&nested_column))",
          "new_line_content": "\t\t\t\tif (res)",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": "res |= negative ^ (se",
          "new_api": null,
          "old_text": "\n\t\t\t\t\tres |= negative ^ (se",
          "new_text": null,
          "old_line_content": "\t\t\tconst ColumnString::Offsets_t & nested_offsets = column_string->getOffsets();",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": "break;\n\t\t\t\t}\n\t\t\t\tvec",
          "new_api": null,
          "old_text": "\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvec",
          "new_text": null,
          "old_line_content": "\t\t\tconst ColumnString::Chars_t & data = column_string->getChars();",
          "new_line_content": "\t\t\tvec_res[i] = res;",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": "ех элементов",
          "new_api": null,
          "old_text": "ех элементов\n",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tres |= negative ^ (set.end() != set.find(ref));",
          "new_line_content": "\t\t\t/// Для всех строчек",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tauto left_it = range.left_bounded ? std::lower_bound(ordered_set_elements->begin(), ordered_set_elements->end(), left) : ordered_set_elements->begin();",
          "new_line_content": "\t\t\tcan_be_false = false;",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tif (range.left_bounded && !range.left_included && left_it != ordered_set_elements->end() && *left_it == left)",
          "new_line_content": "\t\t\tcan_be_true = true;",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tif (left_it == ordered_set_elements->end())",
          "new_line_content": "\t\t\tcan_be_true = false;",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "(i, 1, nested_columns, key_sizes) : hash128(i, 1, nest",
          "new_api": null,
          "old_text": "(i, 1, nested_columns, key_sizes) : hash128(i, 1, nest",
          "new_text": null,
          "old_line_content": "\t\telse if (const ColumnFixedString * column_string = typeid_cast<const ColumnFixedString *>(&nested_column))",
          "new_line_content": "\t\t\t\t\tsize_t begin = j == 0 ? 0 : nested_offsets[j - 1];",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "f (res)\n\t\t\t\t\tbreak;",
          "new_api": null,
          "old_text": "f (res)\n\t\t\t\t\tbreak;\n\t",
          "new_text": null,
          "old_line_content": "\t\t\tsize_t n = column_string->getN();",
          "new_line_content": "\t\t\t\t\tStringRef ref(&data[begin], end - begin - 1);",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": "column), vec_",
          "new_api": null,
          "old_text": "column), vec_",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tres |= negative ^ (set.end() != set.find(ref));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": ")\n\t{\n\t\tif (type == KEY_",
          "new_api": null,
          "old_text": ")\n\t{\n\t\tif (type == KEY_",
          "new_text": null,
          "old_line_content": "\t\t\tthrow Exception(\"Illegal type of column when looking for Array(String) key: \" + nested_column.getName(), ErrorCodes::ILLEGAL_COLUMN);",
          "new_line_content": "\t\t\t\t\t/// Строим ключ",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\treturn BoolMask(can_be_true, can_be_false);",
          "new_line_content": "\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": "ive ^ (set.en",
          "new_api": null,
          "old_text": "ive ^ (set.en",
          "new_text": null,
          "old_line_content": "\t\t\t\tvec_res[i] = negative ^ (set.end() != set.find(ref));",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": "umns, key_sizes) : hash128(i, keys_size, key_co",
          "new_api": null,
          "old_text": "umns, key_sizes) : hash128(i, keys_size, key_co",
          "new_text": null,
          "old_line_content": "\t\telse if (const ColumnFixedString * column_string = typeid_cast<const ColumnFixedString *>(&column))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": "throw Exception(\"Unk",
          "new_api": null,
          "old_text": "\tthrow Exception(\"Unk",
          "new_text": null,
          "old_line_content": "\t\t\tsize_t n = column_string->getN();",
          "new_line_content": "\t\t\t\t\tvec_res[i] = prev_result;",
          "content_same": false
        },
        {
          "line": 486,
          "old_api": "A_VARIANT);\n}\n\nvoid Set::",
          "new_api": null,
          "old_text": "A_VARIANT);\n}\n\nvoid Set::",
          "new_text": null,
          "old_line_content": "\t\t\tconst ColumnFixedString::Chars_t & data = column_string->getChars();",
          "new_line_content": "\t\t\t\telse",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": "InRange",
          "new_api": null,
          "old_text": "InRange(const Range & range)\n",
          "new_text": null,
          "old_line_content": "\t\t\t\tres |= negative ^ (set.end() != set.find(keys_fit_128_bits ? pack128(i, 1, nested_columns, key_sizes) : hash128(i, 1, nested_columns)));",
          "new_line_content": "\t\tConstColumnPlainPtrs nested_columns(1, &nested_column);",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": "getOffsets",
          "new_api": null,
          "old_text": "->getOffsets(",
          "new_text": null,
          "old_line_content": "\t\t\t\tvec_res[i] = negative ^ (set.end() != set.find(ref));",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": "end",
          "new_api": null,
          "old_text": "t.end() != set.f",
          "new_text": null,
          "old_line_content": "\t\t\tthrow Exception(\"Illegal type of column when creating set with string key: \" + column.getName(), ErrorCodes::ILLEGAL_COLUMN);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": "empty",
          "new_api": null,
          "old_text": "ments->empty())\n\t\treturn BoolMask(false, true);\n\n\tconst Field & left = ",
          "new_text": null,
          "old_line_content": "\t\tthrow Exception(\"Unknown set variant.\", ErrorCodes::UNKNOWN_SET_DATA_VARIANT);",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "ize_t i = 0; i < rows; +",
          "new_api": null,
          "old_text": "ize_t i = 0; i < rows; +",
          "new_text": null,
          "old_line_content": "\t\t\tbool res = negative ^ (set.end() != set.find(StringRef(column_string->getData())));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": "n и не выбираем для notIn\n\tif (ra",
          "new_api": null,
          "old_text": "n и не выбираем для notIn\n\tif (ra",
          "new_text": null,
          "old_line_content": "\t\tColumnPtr full_column = key_column->convertToFullColumn();",
          "new_line_content": "\t\t\tprev_offset = offsets[i];",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": "&& range.right_bounded && range.right_inc",
          "new_api": null,
          "old_text": "&& range.right_bounded && range.right_inc",
          "new_text": null,
          "old_line_content": "\t\texecuteArray(typeid_cast<ColumnArray *>(&*full_column), vec_res, negative);",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": "if (std::binary_s",
          "new_api": null,
          "old_text": "\tif (std::binary_s",
          "new_text": null,
          "old_line_content": "\tsize_t rows = key_column->size();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": "begin",
          "new_api": null,
          "old_text": "elements->begin(), or",
          "new_text": null,
          "old_line_content": "\tArray values = key_column->getData();",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 14,
      "total_additions": 37,
      "total_deletions": 37,
      "total_api_changes": 88
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 13,
        "api_related_lines": 88,
        "non_api_lines": 8,
        "non_api_line_numbers": [
          484,
          487,
          489,
          490,
          491,
          475,
          476,
          477
        ]
      }
    },
    "api_calls_before": 285,
    "api_calls_after": 285,
    "diff_info": {
      "added_lines": 12,
      "removed_lines": 1,
      "total_diff_lines": 30
    }
  }
}