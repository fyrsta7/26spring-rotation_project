{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/45df745011b8ae70255fe7083955cf3c8c0a9c21",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/45df745011b8ae70255fe7083955cf3c8c0a9c21/before.h",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/45df745011b8ae70255fe7083955cf3c8c0a9c21/after.h",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/45df745011b8ae70255fe7083955cf3c8c0a9c21/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 168,
          "old_api": "getAnalyzeResult",
          "new_api": "size",
          "old_text": "regexp.getAnalyzeResult(required_substring, is_trivial, required_substring_is_prefix)",
          "new_text": "res.size()",
          "old_line_content": "        regexp.getAnalyzeResult(required_substring, is_trivial, required_substring_is_prefix);",
          "new_line_content": "            if (i < res.size())",
          "content_same": false
        },
        {
          "line": 180,
          "old_api": "reinterpret_cast<const char *>(&haystack_data[prev_offset])",
          "new_api": "getAnalyzeResult",
          "old_text": "reinterpret_cast<const char *>(&haystack_data[prev_offset])",
          "new_text": "regexp.getAnalyzeResult(required_substring, is_trivial, required_substring_is_prefix)",
          "old_line_content": "                            {reinterpret_cast<const char *>(&haystack_data[prev_offset]), haystack_offsets[i] - prev_offset - 1},",
          "new_line_content": "        regexp.getAnalyzeResult(required_substring, is_trivial, required_substring_is_prefix);",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "size",
          "new_api": "impl::likePatternIsSubstring(needle, strstr_pattern)",
          "old_text": "strstr_pattern.size()",
          "new_text": "impl::likePatternIsSubstring(needle, strstr_pattern)",
          "old_line_content": "                Searcher searcher(strstr_pattern.data(), strstr_pattern.size(), end - pos);",
          "new_line_content": "        if (is_like && impl::likePatternIsSubstring(needle, strstr_pattern))",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": "search",
          "new_api": "size",
          "old_text": "searcher.search(pos, end - pos)",
          "new_text": "haystack.size()",
          "old_line_content": "                while (pos < end && end != (pos = searcher.search(pos, end - pos)))",
          "new_line_content": "            const UInt8 * const end = haystack.data() + haystack.size();",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": "size",
          "new_api": "search",
          "old_text": "strstr_pattern.size()",
          "new_text": "searcher.search(pos, end - pos)",
          "old_line_content": "                    if (pos + strstr_pattern.size() <= next_pos)",
          "new_line_content": "                while (pos < end && end != (pos = searcher.search(pos, end - pos)))",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "getAnalyzeResult",
          "new_api": "size",
          "old_text": "regexp.getAnalyzeResult(required_substring, is_trivial, required_substring_is_prefix)",
          "new_text": "res.size()",
          "old_line_content": "        regexp.getAnalyzeResult(required_substring, is_trivial, required_substring_is_prefix);",
          "new_line_content": "            if (i < res.size())",
          "content_same": false
        },
        {
          "line": 334,
          "old_api": "reinterpret_cast<const char *>(&haystack[offset])",
          "new_api": "getAnalyzeResult",
          "old_text": "reinterpret_cast<const char *>(&haystack[offset])",
          "new_text": "regexp.getAnalyzeResult(required_substring, is_trivial, required_substring_is_prefix)",
          "old_line_content": "                            {reinterpret_cast<const char *>(&haystack[offset]), N},",
          "new_line_content": "        regexp.getAnalyzeResult(required_substring, is_trivial, required_substring_is_prefix);",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": "search",
          "new_api": "size",
          "old_text": "searcher.search(pos, end - pos)",
          "new_text": "haystack.size()",
          "old_line_content": "                while (pos < end && end != (pos = searcher.search(pos, end - pos)))",
          "new_line_content": "            const UInt8 * const end = haystack.data() + haystack.size();",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "getAnalyzeResult",
          "new_api": "size",
          "old_text": "regexp->getAnalyzeResult(required_substr, is_trivial, required_substring_is_prefix)",
          "new_text": "required_substr.size()",
          "old_line_content": "                regexp->getAnalyzeResult(required_substr, is_trivial, required_substring_is_prefix);",
          "new_line_content": "                if (required_substr.size() > cur_haystack_length)",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": "getRE2",
          "new_api": "size",
          "old_text": "regexp->getRE2()",
          "new_text": "required_substr.size()",
          "old_line_content": "                    if (!regexp->getRE2()) /// An empty regexp. Always matches.",
          "new_line_content": "                    Searcher searcher(required_substr.data(), required_substr.size(), cur_haystack_length);",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "size",
          "new_api": "getRE2",
          "old_text": "required_substr.size()",
          "new_text": "regexp->getRE2()->Match(\n                                {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},\n                                0,\n                                cur_haystack_length,\n                                re2_st::RE2::UNANCHORED,\n                                nullptr,\n                                0)",
          "old_line_content": "                    Searcher searcher(required_substr.data(), required_substr.size(), cur_haystack_length);",
          "new_line_content": "                        const bool match = regexp->getRE2()->Match(",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": "search",
          "new_api": "reinterpret_cast<const char *>(cur_haystack_data)",
          "old_text": "searcher.search(cur_haystack_data, cur_haystack_length)",
          "new_text": "reinterpret_cast<const char *>(cur_haystack_data)",
          "old_line_content": "                    const auto * match = searcher.search(cur_haystack_data, cur_haystack_length);",
          "new_line_content": "                                {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": "getAnalyzeResult",
          "new_api": "size",
          "old_text": "regexp->getAnalyzeResult(required_substr, is_trivial, required_substring_is_prefix)",
          "new_text": "required_substr.size()",
          "old_line_content": "                regexp->getAnalyzeResult(required_substr, is_trivial, required_substring_is_prefix);",
          "new_line_content": "                if (required_substr.size() > cur_haystack_length)",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "getRE2",
          "new_api": "size",
          "old_text": "regexp->getRE2()",
          "new_text": "required_substr.size()",
          "old_line_content": "                    if (!regexp->getRE2()) /// An empty regexp. Always matches.",
          "new_line_content": "                    Searcher searcher(required_substr.data(), required_substr.size(), cur_haystack_length);",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": "size",
          "new_api": "getRE2",
          "old_text": "required_substr.size()",
          "new_text": "regexp->getRE2()->Match(\n                                {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},\n                                0,\n                                cur_haystack_length,\n                                re2_st::RE2::UNANCHORED,\n                                nullptr,\n                                0)",
          "old_line_content": "                    Searcher searcher(required_substr.data(), required_substr.size(), cur_haystack_length);",
          "new_line_content": "                        const bool match = regexp->getRE2()->Match(",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": "search",
          "new_api": "reinterpret_cast<const char *>(cur_haystack_data)",
          "old_text": "searcher.search(cur_haystack_data, cur_haystack_length)",
          "new_text": "reinterpret_cast<const char *>(cur_haystack_data)",
          "old_line_content": "                    const auto * match = searcher.search(cur_haystack_data, cur_haystack_length);",
          "new_line_content": "                                {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 513,
          "old_api": null,
          "new_api": "getRE2",
          "old_text": null,
          "new_text": "regexp->getRE2()->Match(\n                                    {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},\n                                    start_pos,\n                                    end_pos,\n                                    re2_st::RE2::UNANCHORED,\n                                    nullptr,\n                                    0)",
          "old_line_content": "",
          "new_line_content": "                            const bool match2 = regexp->getRE2()->Match(",
          "content_same": false
        },
        {
          "line": 514,
          "old_api": null,
          "new_api": "reinterpret_cast<const char *>(cur_haystack_data)",
          "old_text": null,
          "new_text": "reinterpret_cast<const char *>(cur_haystack_data)",
          "old_line_content": "            prev_haystack_offset = haystack_offsets[i];",
          "new_line_content": "                                    {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": null,
          "new_api": "maybe_unused",
          "old_text": null,
          "new_text": "maybe_unused",
          "old_line_content": "        String required_substr;",
          "new_line_content": "        [[maybe_unused]] const ColumnPtr & start_pos_,",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "haystack.size()",
          "old_line_content": "",
          "new_line_content": "        const size_t haystack_size = haystack.size()/N;",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "needle_offset.size()",
          "old_line_content": "        size_t prev_needle_offset = 0;",
          "new_line_content": "        assert(haystack_size == needle_offset.size());",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "res.size()",
          "old_line_content": "",
          "new_line_content": "        assert(haystack_size == res.size());",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(start_pos_ == nullptr)",
          "old_line_content": "        Regexps::LocalCacheTable cache;",
          "new_line_content": "        assert(start_pos_ == nullptr);",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "haystack.empty()",
          "old_line_content": "",
          "new_line_content": "        if (haystack.empty())",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": null,
          "new_api": "String",
          "old_text": null,
          "new_text": "String(\n                    reinterpret_cast<const char *>(cur_needle_data),\n                    cur_needle_length)",
          "old_line_content": "                    res[i] = negate ^ (match != cur_haystack_data + cur_haystack_length);",
          "new_line_content": "            const auto & needle = String(",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": null,
          "new_api": "reinterpret_cast<const char *>(cur_needle_data)",
          "old_text": null,
          "new_text": "reinterpret_cast<const char *>(cur_needle_data)",
          "old_line_content": "                }",
          "new_line_content": "                    reinterpret_cast<const char *>(cur_needle_data),",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": null,
          "new_api": "impl::likePatternIsSubstring(needle, required_substr)",
          "old_text": null,
          "new_text": "impl::likePatternIsSubstring(needle, required_substr)",
          "old_line_content": "            {",
          "new_line_content": "            if (is_like && impl::likePatternIsSubstring(needle, required_substr))",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": null,
          "new_api": "search",
          "old_text": null,
          "new_text": "searcher.search(cur_haystack_data, cur_haystack_length)",
          "old_line_content": "                        res[i] = !negate;",
          "new_line_content": "                    const auto * match = searcher.search(cur_haystack_data, cur_haystack_length);",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": null,
          "new_api": "cache.getOrSet<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "old_text": null,
          "new_text": "cache.getOrSet<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "old_line_content": "                                cur_haystack_length,",
          "new_line_content": "                regexp = cache.getOrSet<is_like, /*no_capture*/ true, case_insensitive>(needle);",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": null,
          "new_api": "getAnalyzeResult",
          "old_text": null,
          "new_text": "regexp->getAnalyzeResult(required_substr, is_trivial, required_substring_is_prefix)",
          "old_line_content": "                                re2_st::RE2::UNANCHORED,",
          "new_line_content": "                regexp->getAnalyzeResult(required_substr, is_trivial, required_substring_is_prefix);",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "required_substr.empty()",
          "old_line_content": "                                0);",
          "new_line_content": "                if (required_substr.empty())",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": null,
          "new_api": "getRE2",
          "old_text": null,
          "new_text": "regexp->getRE2()",
          "old_line_content": "                    }",
          "new_line_content": "                    if (!regexp->getRE2()) /// An empty regexp. Always matches.",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "required_substr.size()",
          "old_line_content": "                            const size_t end_pos = cur_haystack_length;",
          "new_line_content": "                    Searcher searcher(required_substr.data(), required_substr.size(), cur_haystack_length);",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": null,
          "new_api": "search",
          "old_text": null,
          "new_text": "searcher.search(cur_haystack_data, cur_haystack_length)",
          "old_line_content": "",
          "new_line_content": "                    const auto * match = searcher.search(cur_haystack_data, cur_haystack_length);",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": null,
          "new_api": "getRE2",
          "old_text": null,
          "new_text": "regexp->getRE2()->Match(\n                                    {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},\n                                    start_pos,\n                                    end_pos,\n                                    re2_st::RE2::UNANCHORED,\n                                    nullptr,\n                                    0)",
          "old_line_content": "            prev_haystack_offset += N;",
          "new_line_content": "                            const bool match2 = regexp->getRE2()->Match(",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": null,
          "new_api": "reinterpret_cast<const char *>(cur_haystack_data)",
          "old_text": null,
          "new_text": "reinterpret_cast<const char *>(cur_haystack_data)",
          "old_line_content": "            prev_needle_offset = needle_offset[i];",
          "new_line_content": "                                    {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support search with non-constant needles in constant haystack\", name)",
          "old_line_content": "",
          "new_line_content": "        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support search with non-constant needles in constant haystack\", name);",
          "content_same": false
        },
        {
          "line": 135,
          "old_api": null,
          "new_api": "impl::likePatternIsSubstring(needle, strstr_pattern)",
          "old_text": null,
          "new_text": "impl::likePatternIsSubstring(needle, strstr_pattern)",
          "old_line_content": "            /// We will search for the next occurrence in all rows at once.",
          "new_line_content": "        if (is_like && impl::likePatternIsSubstring(needle, strstr_pattern))",
          "content_same": false
        },
        {
          "line": 137,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "haystack_data.data()",
          "old_line_content": "            {",
          "new_line_content": "            const UInt8 * const begin = haystack_data.data();",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "haystack_data.size()",
          "old_line_content": "                /// Let's determine which index it refers to.",
          "new_line_content": "            const UInt8 * const end = haystack_data.data() + haystack_data.size();",
          "content_same": false
        },
        {
          "line": 145,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "strstr_pattern.size()",
          "old_line_content": "                /// We check that the entry does not pass through the boundaries of strings.",
          "new_line_content": "            Searcher searcher(strstr_pattern.data(), strstr_pattern.size(), end - pos);",
          "content_same": false
        },
        {
          "line": 148,
          "old_api": null,
          "new_api": "search",
          "old_text": null,
          "new_text": "searcher.search(pos, end - pos)",
          "old_line_content": "                else",
          "new_line_content": "            while (pos < end && end != (pos = searcher.search(pos, end - pos)))",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "strstr_pattern.size()",
          "old_line_content": "",
          "new_line_content": "                if (pos + strstr_pattern.size() < begin + haystack_offsets[i])",
          "content_same": false
        },
        {
          "line": 169,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "res.size()",
          "old_line_content": "",
          "new_line_content": "                memset(&res[i], negate, (res.size() - i) * sizeof(res[0]));",
          "content_same": false
        },
        {
          "line": 174,
          "old_api": null,
          "new_api": "Regexps::createRegexp<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "old_text": null,
          "new_text": "Regexps::createRegexp<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "old_line_content": "            else",
          "new_line_content": "        const auto & regexp = Regexps::Regexp(Regexps::createRegexp<is_like, /*no_capture*/ true, case_insensitive>(needle));",
          "content_same": false
        },
        {
          "line": 182,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "required_substring.empty()",
          "old_line_content": "                            haystack_offsets[i] - prev_offset - 1,",
          "new_line_content": "        if (required_substring.empty())",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": null,
          "new_api": "getRE2",
          "old_text": null,
          "new_text": "regexp.getRE2()",
          "old_line_content": "                            nullptr,",
          "new_line_content": "            if (!regexp.getRE2()) /// An empty regexp. Always matches.",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "res.data()",
          "old_line_content": "                            0);",
          "new_line_content": "                memset(res.data(), !negate, haystack_size * sizeof(res[0]));",
          "content_same": false
        },
        {
          "line": 191,
          "old_api": null,
          "new_api": "getRE2",
          "old_text": null,
          "new_text": "regexp.getRE2()->Match(\n                            {reinterpret_cast<const char *>(&haystack_data[prev_offset]), haystack_offsets[i] - prev_offset - 1},\n                            0,\n                            haystack_offsets[i] - prev_offset - 1,\n                            re2_st::RE2::UNANCHORED,\n                            nullptr,\n                            0)",
          "old_line_content": "        }",
          "new_line_content": "                    const bool match = regexp.getRE2()->Match(",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": null,
          "new_api": "reinterpret_cast<const char *>(&haystack_data[prev_offset])",
          "old_text": null,
          "new_text": "reinterpret_cast<const char *>(&haystack_data[prev_offset])",
          "old_line_content": "        else",
          "new_line_content": "                            {reinterpret_cast<const char *>(&haystack_data[prev_offset]), haystack_offsets[i] - prev_offset - 1},",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "haystack_data.data()",
          "old_line_content": "                /// Determine which index it refers to.",
          "new_line_content": "            const UInt8 * const begin = haystack_data.data();",
          "content_same": false
        },
        {
          "line": 209,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "haystack_data.size()",
          "old_line_content": "                while (begin + haystack_offsets[i] <= pos)",
          "new_line_content": "            const UInt8 * const end = haystack_data.begin() + haystack_data.size();",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "required_substring.size()",
          "old_line_content": "                /// We check that the entry does not pass through the boundaries of strings.",
          "new_line_content": "            Searcher searcher(required_substring.data(), required_substring.size(), end - pos);",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": null,
          "new_api": "search",
          "old_text": null,
          "new_text": "searcher.search(pos, end - pos)",
          "old_line_content": "                    /// And if it does not, if necessary, we check the regexp.",
          "new_line_content": "            while (pos < end && end != (pos = searcher.search(pos, end - pos)))",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "required_substring.size()",
          "old_line_content": "                          *  and at the first occurrence, the regexp is not a match.",
          "new_line_content": "                if (pos + required_substring.size() < begin + haystack_offsets[i])",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": null,
          "new_api": "reinterpret_cast<const char *>(&haystack_data[haystack_offsets[i - 1]])",
          "old_text": null,
          "new_text": "reinterpret_cast<const char *>(&haystack_data[haystack_offsets[i - 1]])",
          "old_line_content": "                                start_pos,",
          "new_line_content": "                        const char * str_data = reinterpret_cast<const char *>(&haystack_data[haystack_offsets[i - 1]]);",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": null,
          "new_api": "reinterpret_cast<const char *>(pos)",
          "old_text": null,
          "new_text": "reinterpret_cast<const char *>(pos)",
          "old_line_content": "                }",
          "new_line_content": "                        const size_t start_pos = (required_substring_is_prefix) ? (reinterpret_cast<const char *>(pos) - str_data) : 0;",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": null,
          "new_api": "getRE2",
          "old_text": null,
          "new_text": "regexp.getRE2()->Match(\n                                {str_data, str_size},\n                                start_pos,\n                                end_pos,\n                                re2_st::RE2::UNANCHORED,\n                                nullptr,\n                                0)",
          "old_line_content": "",
          "new_line_content": "                        const bool match = regexp.getRE2()->Match(",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "res.size()",
          "old_line_content": "",
          "new_line_content": "                memset(&res[i], negate, (res.size() - i) * sizeof(res[0]));",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "res.size()",
          "old_line_content": "",
          "new_line_content": "        assert(haystack_size == res.size());",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "haystack.empty()",
          "old_line_content": "            const UInt8 * next_pos = begin;",
          "new_line_content": "        if (haystack.empty())",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "haystack.data()",
          "old_line_content": "                /// We will search for the next occurrence in all rows at once.",
          "new_line_content": "            const UInt8 * const begin = haystack.data();",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "strstr_pattern.size()",
          "old_line_content": "                        ++i;",
          "new_line_content": "            if (strstr_pattern.size() <= N)",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "strstr_pattern.size()",
          "old_line_content": "                    next_pos += N;",
          "new_line_content": "                Searcher searcher(strstr_pattern.data(), strstr_pattern.size(), end - pos);",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "res.size()",
          "old_line_content": "",
          "new_line_content": "                memset(&res[i], negate, (res.size() - i) * sizeof(res[0]));",
          "content_same": false
        },
        {
          "line": 328,
          "old_api": null,
          "new_api": "Regexps::createRegexp<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "old_text": null,
          "new_text": "Regexps::createRegexp<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "old_line_content": "            else",
          "new_line_content": "        const auto & regexp = Regexps::Regexp(Regexps::createRegexp<is_like, /*no_capture*/ true, case_insensitive>(needle));",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "required_substring.empty()",
          "old_line_content": "                            N,",
          "new_line_content": "        if (required_substring.empty())",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": null,
          "new_api": "getRE2",
          "old_text": null,
          "new_text": "regexp.getRE2()",
          "old_line_content": "                            nullptr,",
          "new_line_content": "            if (!regexp.getRE2()) /// An empty regexp. Always matches.",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "res.data()",
          "old_line_content": "                            0);",
          "new_line_content": "                memset(res.data(), !negate, haystack_size * sizeof(res[0]));",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": null,
          "new_api": "getRE2",
          "old_text": null,
          "new_text": "regexp.getRE2()->Match(\n                            {reinterpret_cast<const char *>(&haystack[offset]), N},\n                            0,\n                            N,\n                            re2_st::RE2::UNANCHORED,\n                            nullptr,\n                            0)",
          "old_line_content": "        }",
          "new_line_content": "                    const bool match = regexp.getRE2()->Match(",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": null,
          "new_api": "reinterpret_cast<const char *>(&haystack[offset])",
          "old_text": null,
          "new_text": "reinterpret_cast<const char *>(&haystack[offset])",
          "old_line_content": "        else",
          "new_line_content": "                            {reinterpret_cast<const char *>(&haystack[offset]), N},",
          "content_same": false
        },
        {
          "line": 362,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "haystack.data()",
          "old_line_content": "                /// We will search for the next occurrence in all rows at once.",
          "new_line_content": "            const UInt8 * const begin = haystack.data();",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "required_substring.size()",
          "old_line_content": "                        ++i;",
          "new_line_content": "            if (required_substring.size() <= N)",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "required_substring.size()",
          "old_line_content": "                    next_pos += N;",
          "new_line_content": "                Searcher searcher(required_substring.data(), required_substring.size(), end - pos);",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": null,
          "new_api": "search",
          "old_text": null,
          "new_text": "searcher.search(pos, end - pos)",
          "old_line_content": "                    {",
          "new_line_content": "                while (pos < end && end != (pos = searcher.search(pos, end - pos)))",
          "content_same": false
        },
        {
          "line": 386,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "required_substring.size()",
          "old_line_content": "                            */",
          "new_line_content": "                    if (pos + required_substring.size() <= next_pos)",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": null,
          "new_api": "reinterpret_cast<const char *>(next_pos - N)",
          "old_text": null,
          "new_text": "reinterpret_cast<const char *>(next_pos - N)",
          "old_line_content": "                                    end_pos,",
          "new_line_content": "                            const char * str_data = reinterpret_cast<const char *>(next_pos - N);",
          "content_same": false
        },
        {
          "line": 399,
          "old_api": null,
          "new_api": "reinterpret_cast<const char *>(pos)",
          "old_text": null,
          "new_text": "reinterpret_cast<const char *>(pos)",
          "old_line_content": "                    }",
          "new_line_content": "                            const size_t start_pos = (required_substring_is_prefix) ? (reinterpret_cast<const char *>(pos) - str_data) : 0;",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": null,
          "new_api": "getRE2",
          "old_text": null,
          "new_text": "regexp.getRE2()->Match(\n                                    {str_data, N},\n                                    start_pos,\n                                    end_pos,\n                                    re2_st::RE2::UNANCHORED,\n                                    nullptr,\n                                    0)",
          "old_line_content": "",
          "new_line_content": "                            const bool match = regexp.getRE2()->Match(",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "res.size()",
          "old_line_content": "    {",
          "new_line_content": "            if (i < res.size())",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": null,
          "new_api": "maybe_unused",
          "old_text": null,
          "new_text": "maybe_unused",
          "old_line_content": "        String required_substr;",
          "new_line_content": "        [[maybe_unused]] const ColumnPtr & start_pos_,",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "haystack_offsets.size()",
          "old_line_content": "",
          "new_line_content": "        const size_t haystack_size = haystack_offsets.size();",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "needle_offset.size()",
          "old_line_content": "        size_t prev_needle_offset = 0;",
          "new_line_content": "        assert(haystack_size == needle_offset.size());",
          "content_same": false
        },
        {
          "line": 437,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "res.size()",
          "old_line_content": "",
          "new_line_content": "        assert(haystack_size == res.size());",
          "content_same": false
        },
        {
          "line": 438,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(start_pos_ == nullptr)",
          "old_line_content": "        Regexps::LocalCacheTable cache;",
          "new_line_content": "        assert(start_pos_ == nullptr);",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "haystack_offsets.empty()",
          "old_line_content": "",
          "new_line_content": "        if (haystack_offsets.empty())",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": null,
          "new_api": "String",
          "old_text": null,
          "new_text": "String(\n                    reinterpret_cast<const char *>(cur_needle_data),\n                    cur_needle_length)",
          "old_line_content": "                    res[i] = negate ^ (match != cur_haystack_data + cur_haystack_length);",
          "new_line_content": "            const auto & needle = String(",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": null,
          "new_api": "reinterpret_cast<const char *>(cur_needle_data)",
          "old_text": null,
          "new_text": "reinterpret_cast<const char *>(cur_needle_data)",
          "old_line_content": "                }",
          "new_line_content": "                    reinterpret_cast<const char *>(cur_needle_data),",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": null,
          "new_api": "impl::likePatternIsSubstring(needle, required_substr)",
          "old_text": null,
          "new_text": "impl::likePatternIsSubstring(needle, required_substr)",
          "old_line_content": "            {",
          "new_line_content": "            if (is_like && impl::likePatternIsSubstring(needle, required_substr))",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": null,
          "new_api": "search",
          "old_text": null,
          "new_text": "searcher.search(cur_haystack_data, cur_haystack_length)",
          "old_line_content": "                        res[i] = !negate;",
          "new_line_content": "                    const auto * match = searcher.search(cur_haystack_data, cur_haystack_length);",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": null,
          "new_api": "cache.getOrSet<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "old_text": null,
          "new_text": "cache.getOrSet<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "old_line_content": "                                cur_haystack_length,",
          "new_line_content": "                regexp = cache.getOrSet<is_like, /*no_capture*/ true, case_insensitive>(needle);",
          "content_same": false
        },
        {
          "line": 479,
          "old_api": null,
          "new_api": "getAnalyzeResult",
          "old_text": null,
          "new_text": "regexp->getAnalyzeResult(required_substr, is_trivial, required_substring_is_prefix)",
          "old_line_content": "                                re2_st::RE2::UNANCHORED,",
          "new_line_content": "                regexp->getAnalyzeResult(required_substr, is_trivial, required_substring_is_prefix);",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "required_substr.empty()",
          "old_line_content": "                                0);",
          "new_line_content": "                if (required_substr.empty())",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": null,
          "new_api": "getRE2",
          "old_text": null,
          "new_text": "regexp->getRE2()",
          "old_line_content": "                    }",
          "new_line_content": "                    if (!regexp->getRE2()) /// An empty regexp. Always matches.",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "required_substr.size()",
          "old_line_content": "                            const size_t end_pos = cur_haystack_length;",
          "new_line_content": "                    Searcher searcher(required_substr.data(), required_substr.size(), cur_haystack_length);",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": null,
          "new_api": "search",
          "old_text": null,
          "new_text": "searcher.search(cur_haystack_data, cur_haystack_length)",
          "old_line_content": "",
          "new_line_content": "                    const auto * match = searcher.search(cur_haystack_data, cur_haystack_length);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 524,
          "old_api": "maybe_unused",
          "new_api": null,
          "old_text": "maybe_unused",
          "new_text": null,
          "old_line_content": "        [[maybe_unused]] const ColumnPtr & start_pos_,",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": "size",
          "new_api": null,
          "old_text": "haystack.size()",
          "new_text": null,
          "old_line_content": "        const size_t haystack_size = haystack.size()/N;",
          "new_line_content": "            prev_needle_offset = needle_offset[i];",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": "size",
          "new_api": null,
          "old_text": "needle_offset.size()",
          "new_text": null,
          "old_line_content": "        assert(haystack_size == needle_offset.size());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": "size",
          "new_api": null,
          "old_text": "res.size()",
          "new_text": null,
          "old_line_content": "        assert(haystack_size == res.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(start_pos_ == nullptr)",
          "new_text": null,
          "old_line_content": "        assert(start_pos_ == nullptr);",
          "new_line_content": "    static void vectorFixedVector(",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": "empty",
          "new_api": null,
          "old_text": "haystack.empty()",
          "new_text": null,
          "old_line_content": "        if (haystack.empty())",
          "new_line_content": "        size_t N,",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": "String",
          "new_api": null,
          "old_text": "String(\n                    reinterpret_cast<const char *>(cur_needle_data),\n                    cur_needle_length)",
          "new_text": null,
          "old_line_content": "            const auto & needle = String(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": "reinterpret_cast<const char *>(cur_needle_data)",
          "new_api": null,
          "old_text": "reinterpret_cast<const char *>(cur_needle_data)",
          "new_text": null,
          "old_line_content": "                    reinterpret_cast<const char *>(cur_needle_data),",
          "new_line_content": "        Regexps::LocalCacheTable cache;",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": "impl::likePatternIsSubstring(needle, required_substr)",
          "new_api": null,
          "old_text": "impl::likePatternIsSubstring(needle, required_substr)",
          "new_text": null,
          "old_line_content": "            if (is_like && impl::likePatternIsSubstring(needle, required_substr))",
          "new_line_content": "        for (size_t i = 0; i < haystack_size; ++i)",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": "size",
          "new_api": null,
          "old_text": "required_substr.size()",
          "new_text": null,
          "old_line_content": "                if (required_substr.size() > cur_haystack_length)",
          "new_line_content": "            const auto * const cur_haystack_data = &haystack[prev_haystack_offset];",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "size",
          "new_api": null,
          "old_text": "required_substr.size()",
          "new_text": null,
          "old_line_content": "                    Searcher searcher(required_substr.data(), required_substr.size(), cur_haystack_length);",
          "new_line_content": "            const size_t cur_needle_length = needle_offset[i] - prev_needle_offset - 1;",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": "search",
          "new_api": null,
          "old_text": "searcher.search(cur_haystack_data, cur_haystack_length)",
          "new_text": null,
          "old_line_content": "                    const auto * match = searcher.search(cur_haystack_data, cur_haystack_length);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": "cache.getOrSet<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "new_api": null,
          "old_text": "cache.getOrSet<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "new_text": null,
          "old_line_content": "                regexp = cache.getOrSet<is_like, /*no_capture*/ true, case_insensitive>(needle);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": "empty",
          "new_api": null,
          "old_text": "required_substr.empty()",
          "new_text": null,
          "old_line_content": "                if (required_substr.empty())",
          "new_line_content": "                else",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": "getRE2",
          "new_api": null,
          "old_text": "regexp->getRE2()->Match(\n                                {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},\n                                0,\n                                cur_haystack_length,\n                                re2_st::RE2::UNANCHORED,\n                                nullptr,\n                                0)",
          "new_text": null,
          "old_line_content": "                        const bool match = regexp->getRE2()->Match(",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": "reinterpret_cast<const char *>(cur_haystack_data)",
          "new_api": null,
          "old_text": "reinterpret_cast<const char *>(cur_haystack_data)",
          "new_text": null,
          "old_line_content": "                                {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": "getRE2",
          "new_api": null,
          "old_text": "regexp->getRE2()->Match(\n                                    {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},\n                                    start_pos,\n                                    end_pos,\n                                    re2_st::RE2::UNANCHORED,\n                                    nullptr,\n                                    0)",
          "new_text": null,
          "old_line_content": "                            const bool match2 = regexp->getRE2()->Match(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": "reinterpret_cast<const char *>(cur_haystack_data)",
          "new_api": null,
          "old_text": "reinterpret_cast<const char *>(cur_haystack_data)",
          "new_text": null,
          "old_line_content": "                                    {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},",
          "new_line_content": "                    if (match == cur_haystack_data + cur_haystack_length)",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support search with non-constant needles in constant haystack\", name)",
          "new_text": null,
          "old_line_content": "        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support search with non-constant needles in constant haystack\", name);",
          "new_line_content": "                        }",
          "content_same": false
        },
        {
          "line": 123,
          "old_api": "impl::likePatternIsSubstring(needle, strstr_pattern)",
          "new_api": null,
          "old_text": "impl::likePatternIsSubstring(needle, strstr_pattern)",
          "new_text": null,
          "old_line_content": "        if (is_like && impl::likePatternIsSubstring(needle, strstr_pattern))",
          "new_line_content": "        /// col not [i]like '%%'",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": "data",
          "new_api": null,
          "old_text": "haystack_data.data()",
          "new_text": null,
          "old_line_content": "            const UInt8 * const begin = haystack_data.data();",
          "new_line_content": "        /// col not [i]like '%'",
          "content_same": false
        },
        {
          "line": 126,
          "old_api": "size",
          "new_api": null,
          "old_text": "haystack_data.size()",
          "new_text": null,
          "old_line_content": "            const UInt8 * const end = haystack_data.data() + haystack_data.size();",
          "new_line_content": "        if (is_like && (needle == \"%%\" or needle == \"%\"))",
          "content_same": false
        },
        {
          "line": 133,
          "old_api": "size",
          "new_api": null,
          "old_text": "strstr_pattern.size()",
          "new_text": null,
          "old_line_content": "            Searcher searcher(strstr_pattern.data(), strstr_pattern.size(), end - pos);",
          "new_line_content": "        /// Special case that the [I]LIKE expression reduces to finding a substring in a string",
          "content_same": false
        },
        {
          "line": 136,
          "old_api": "search",
          "new_api": null,
          "old_text": "searcher.search(pos, end - pos)",
          "new_text": null,
          "old_line_content": "            while (pos < end && end != (pos = searcher.search(pos, end - pos)))",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 146,
          "old_api": "size",
          "new_api": null,
          "old_text": "strstr_pattern.size()",
          "new_text": null,
          "old_line_content": "                if (pos + strstr_pattern.size() < begin + haystack_offsets[i])",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": "size",
          "new_api": null,
          "old_text": "res.size()",
          "new_text": null,
          "old_line_content": "            if (i < res.size())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 157,
          "old_api": "size",
          "new_api": null,
          "old_text": "res.size()",
          "new_text": null,
          "old_line_content": "                memset(&res[i], negate, (res.size() - i) * sizeof(res[0]));",
          "new_line_content": "                /// We check that the entry does not pass through the boundaries of strings.",
          "content_same": false
        },
        {
          "line": 162,
          "old_api": "Regexps::createRegexp<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "new_api": null,
          "old_text": "Regexps::createRegexp<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "new_text": null,
          "old_line_content": "        const auto & regexp = Regexps::Regexp(Regexps::createRegexp<is_like, /*no_capture*/ true, case_insensitive>(needle));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 170,
          "old_api": "empty",
          "new_api": null,
          "old_text": "required_substring.empty()",
          "new_text": null,
          "old_line_content": "        if (required_substring.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 172,
          "old_api": "getRE2",
          "new_api": null,
          "old_text": "regexp.getRE2()",
          "new_text": null,
          "old_line_content": "            if (!regexp.getRE2()) /// An empty regexp. Always matches.",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 173,
          "old_api": "data",
          "new_api": null,
          "old_text": "res.data()",
          "new_text": null,
          "old_line_content": "                memset(res.data(), !negate, haystack_size * sizeof(res[0]));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": "getRE2",
          "new_api": null,
          "old_text": "regexp.getRE2()->Match(\n                            {reinterpret_cast<const char *>(&haystack_data[prev_offset]), haystack_offsets[i] - prev_offset - 1},\n                            0,\n                            haystack_offsets[i] - prev_offset - 1,\n                            re2_st::RE2::UNANCHORED,\n                            nullptr,\n                            0)",
          "new_text": null,
          "old_line_content": "                    const bool match = regexp.getRE2()->Match(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": "data",
          "new_api": null,
          "old_text": "haystack_data.data()",
          "new_text": null,
          "old_line_content": "            const UInt8 * const begin = haystack_data.data();",
          "new_line_content": "                            nullptr,",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": "size",
          "new_api": null,
          "old_text": "haystack_data.size()",
          "new_text": null,
          "old_line_content": "            const UInt8 * const end = haystack_data.begin() + haystack_data.size();",
          "new_line_content": "                            0);",
          "content_same": false
        },
        {
          "line": 203,
          "old_api": "size",
          "new_api": null,
          "old_text": "required_substring.size()",
          "new_text": null,
          "old_line_content": "            Searcher searcher(required_substring.data(), required_substring.size(), end - pos);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 206,
          "old_api": "search",
          "new_api": null,
          "old_text": "searcher.search(pos, end - pos)",
          "new_text": null,
          "old_line_content": "            while (pos < end && end != (pos = searcher.search(pos, end - pos)))",
          "new_line_content": "            /// NOTE This almost matches with the case of impl::likePatternIsSubstring.",
          "content_same": false
        },
        {
          "line": 216,
          "old_api": "size",
          "new_api": null,
          "old_text": "required_substring.size()",
          "new_text": null,
          "old_line_content": "                if (pos + required_substring.size() < begin + haystack_offsets[i])",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": "reinterpret_cast<const char *>(&haystack_data[haystack_offsets[i - 1]])",
          "new_api": null,
          "old_text": "reinterpret_cast<const char *>(&haystack_data[haystack_offsets[i - 1]])",
          "new_text": null,
          "old_line_content": "                        const char * str_data = reinterpret_cast<const char *>(&haystack_data[haystack_offsets[i - 1]]);",
          "new_line_content": "                    res[i] = negate;",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": "reinterpret_cast<const char *>(pos)",
          "new_api": null,
          "old_text": "reinterpret_cast<const char *>(pos)",
          "new_text": null,
          "old_line_content": "                        const size_t start_pos = (required_substring_is_prefix) ? (reinterpret_cast<const char *>(pos) - str_data) : 0;",
          "new_line_content": "                    /// And if it does not, if necessary, we check the regexp.",
          "content_same": false
        },
        {
          "line": 233,
          "old_api": "getRE2",
          "new_api": null,
          "old_text": "regexp.getRE2()->Match(\n                                {str_data, str_size},\n                                start_pos,\n                                end_pos,\n                                re2_st::RE2::UNANCHORED,\n                                nullptr,\n                                0)",
          "new_text": null,
          "old_line_content": "                        const bool match = regexp.getRE2()->Match(",
          "new_line_content": "                    else",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": "size",
          "new_api": null,
          "old_text": "res.size()",
          "new_text": null,
          "old_line_content": "            if (i < res.size())",
          "new_line_content": "                                0);",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": "size",
          "new_api": null,
          "old_text": "res.size()",
          "new_text": null,
          "old_line_content": "                memset(&res[i], negate, (res.size() - i) * sizeof(res[0]));",
          "new_line_content": "                        res[i] = negate ^ match;",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": "size",
          "new_api": null,
          "old_text": "res.size()",
          "new_text": null,
          "old_line_content": "        assert(haystack_size == res.size());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "empty",
          "new_api": null,
          "old_text": "haystack.empty()",
          "new_text": null,
          "old_line_content": "        if (haystack.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "impl::likePatternIsSubstring(needle, strstr_pattern)",
          "new_api": null,
          "old_text": "impl::likePatternIsSubstring(needle, strstr_pattern)",
          "new_text": null,
          "old_line_content": "        if (is_like && impl::likePatternIsSubstring(needle, strstr_pattern))",
          "new_line_content": "        const String & needle,",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": "data",
          "new_api": null,
          "old_text": "haystack.data()",
          "new_text": null,
          "old_line_content": "            const UInt8 * const begin = haystack.data();",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": "size",
          "new_api": null,
          "old_text": "strstr_pattern.size()",
          "new_text": null,
          "old_line_content": "            if (strstr_pattern.size() <= N)",
          "new_line_content": "        /// Special case that the [I]LIKE expression reduces to finding a substring in a string",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "size",
          "new_api": null,
          "old_text": "res.size()",
          "new_text": null,
          "old_line_content": "            if (i < res.size())",
          "new_line_content": "                    /// We check that the entry does not pass through the boundaries of strings.",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": "Regexps::createRegexp<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "new_api": null,
          "old_text": "Regexps::createRegexp<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "new_text": null,
          "old_line_content": "        const auto & regexp = Regexps::Regexp(Regexps::createRegexp<is_like, /*no_capture*/ true, case_insensitive>(needle));",
          "new_line_content": "                    pos = next_pos;",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": "empty",
          "new_api": null,
          "old_text": "required_substring.empty()",
          "new_text": null,
          "old_line_content": "        if (required_substring.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": "getRE2",
          "new_api": null,
          "old_text": "regexp.getRE2()",
          "new_text": null,
          "old_line_content": "            if (!regexp.getRE2()) /// An empty regexp. Always matches.",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": "data",
          "new_api": null,
          "old_text": "res.data()",
          "new_text": null,
          "old_line_content": "                memset(res.data(), !negate, haystack_size * sizeof(res[0]));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": "getRE2",
          "new_api": null,
          "old_text": "regexp.getRE2()->Match(\n                            {reinterpret_cast<const char *>(&haystack[offset]), N},\n                            0,\n                            N,\n                            re2_st::RE2::UNANCHORED,\n                            nullptr,\n                            0)",
          "new_text": null,
          "old_line_content": "                    const bool match = regexp.getRE2()->Match(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": "data",
          "new_api": null,
          "old_text": "haystack.data()",
          "new_text": null,
          "old_line_content": "            const UInt8 * const begin = haystack.data();",
          "new_line_content": "                            nullptr,",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": "size",
          "new_api": null,
          "old_text": "haystack.size()",
          "new_text": null,
          "old_line_content": "            const UInt8 * const end = haystack.data() + haystack.size();",
          "new_line_content": "                            0);",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": "size",
          "new_api": null,
          "old_text": "required_substring.size()",
          "new_text": null,
          "old_line_content": "            if (required_substring.size() <= N)",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 360,
          "old_api": "size",
          "new_api": null,
          "old_text": "required_substring.size()",
          "new_text": null,
          "old_line_content": "                Searcher searcher(required_substring.data(), required_substring.size(), end - pos);",
          "new_line_content": "            /// NOTE This almost matches with the case of likePatternIsSubstring.",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": "size",
          "new_api": null,
          "old_text": "required_substring.size()",
          "new_text": null,
          "old_line_content": "                    if (pos + required_substring.size() <= next_pos)",
          "new_line_content": "                /// We will search for the next occurrence in all rows at once.",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": "reinterpret_cast<const char *>(next_pos - N)",
          "new_api": null,
          "old_text": "reinterpret_cast<const char *>(next_pos - N)",
          "new_text": null,
          "old_line_content": "                            const char * str_data = reinterpret_cast<const char *>(next_pos - N);",
          "new_line_content": "                        next_pos += N;",
          "content_same": false
        },
        {
          "line": 387,
          "old_api": "reinterpret_cast<const char *>(pos)",
          "new_api": null,
          "old_text": "reinterpret_cast<const char *>(pos)",
          "new_text": null,
          "old_line_content": "                            const size_t start_pos = (required_substring_is_prefix) ? (reinterpret_cast<const char *>(pos) - str_data) : 0;",
          "new_line_content": "                    {",
          "content_same": false
        },
        {
          "line": 390,
          "old_api": "getRE2",
          "new_api": null,
          "old_text": "regexp.getRE2()->Match(\n                                    {str_data, N},\n                                    start_pos,\n                                    end_pos,\n                                    re2_st::RE2::UNANCHORED,\n                                    nullptr,\n                                    0)",
          "new_text": null,
          "old_line_content": "                            const bool match = regexp.getRE2()->Match(",
          "new_line_content": "                            res[i] = !negate;",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": "size",
          "new_api": null,
          "old_text": "res.size()",
          "new_text": null,
          "old_line_content": "            if (i < res.size())",
          "new_line_content": "                            res[i] = negate ^ match;",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "size",
          "new_api": null,
          "old_text": "res.size()",
          "new_text": null,
          "old_line_content": "                memset(&res[i], negate, (res.size() - i) * sizeof(res[0]));",
          "new_line_content": "                        }",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": "maybe_unused",
          "new_api": null,
          "old_text": "maybe_unused",
          "new_text": null,
          "old_line_content": "        [[maybe_unused]] const ColumnPtr & start_pos_,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": "size",
          "new_api": null,
          "old_text": "needle_offset.size()",
          "new_text": null,
          "old_line_content": "        assert(haystack_size == needle_offset.size());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": "size",
          "new_api": null,
          "old_text": "res.size()",
          "new_text": null,
          "old_line_content": "        assert(haystack_size == res.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(start_pos_ == nullptr)",
          "new_text": null,
          "old_line_content": "        assert(start_pos_ == nullptr);",
          "new_line_content": "    static void vectorVector(",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": "empty",
          "new_api": null,
          "old_text": "haystack_offsets.empty()",
          "new_text": null,
          "old_line_content": "        if (haystack_offsets.empty())",
          "new_line_content": "        const ColumnString::Offsets & haystack_offsets,",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": "String",
          "new_api": null,
          "old_text": "String(\n                    reinterpret_cast<const char *>(cur_needle_data),\n                    cur_needle_length)",
          "new_text": null,
          "old_line_content": "            const auto & needle = String(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": "reinterpret_cast<const char *>(cur_needle_data)",
          "new_api": null,
          "old_text": "reinterpret_cast<const char *>(cur_needle_data)",
          "new_text": null,
          "old_line_content": "                    reinterpret_cast<const char *>(cur_needle_data),",
          "new_line_content": "        Regexps::LocalCacheTable cache;",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": "impl::likePatternIsSubstring(needle, required_substr)",
          "new_api": null,
          "old_text": "impl::likePatternIsSubstring(needle, required_substr)",
          "new_text": null,
          "old_line_content": "            if (is_like && impl::likePatternIsSubstring(needle, required_substr))",
          "new_line_content": "        for (size_t i = 0; i < haystack_size; ++i)",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": "size",
          "new_api": null,
          "old_text": "required_substr.size()",
          "new_text": null,
          "old_line_content": "                if (required_substr.size() > cur_haystack_length)",
          "new_line_content": "            const auto * const cur_haystack_data = &haystack_data[prev_haystack_offset];",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "size",
          "new_api": null,
          "old_text": "required_substr.size()",
          "new_text": null,
          "old_line_content": "                    Searcher searcher(required_substr.data(), required_substr.size(), cur_haystack_length);",
          "new_line_content": "            const size_t cur_needle_length = needle_offset[i] - prev_needle_offset - 1;",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": "search",
          "new_api": null,
          "old_text": "searcher.search(cur_haystack_data, cur_haystack_length)",
          "new_text": null,
          "old_line_content": "                    const auto * match = searcher.search(cur_haystack_data, cur_haystack_length);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "cache.getOrSet<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "new_api": null,
          "old_text": "cache.getOrSet<is_like, /*no_capture*/ true, case_insensitive>(needle)",
          "new_text": null,
          "old_line_content": "                regexp = cache.getOrSet<is_like, /*no_capture*/ true, case_insensitive>(needle);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "empty",
          "new_api": null,
          "old_text": "required_substr.empty()",
          "new_text": null,
          "old_line_content": "                if (required_substr.empty())",
          "new_line_content": "                else",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": "getRE2",
          "new_api": null,
          "old_text": "regexp->getRE2()->Match(\n                                {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},\n                                0,\n                                cur_haystack_length,\n                                re2_st::RE2::UNANCHORED,\n                                nullptr,\n                                0)",
          "new_text": null,
          "old_line_content": "                        const bool match = regexp->getRE2()->Match(",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": "reinterpret_cast<const char *>(cur_haystack_data)",
          "new_api": null,
          "old_text": "reinterpret_cast<const char *>(cur_haystack_data)",
          "new_text": null,
          "old_line_content": "                                {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "getRE2",
          "new_api": null,
          "old_text": "regexp->getRE2()->Match(\n                                    {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},\n                                    start_pos,\n                                    end_pos,\n                                    re2_st::RE2::UNANCHORED,\n                                    nullptr,\n                                    0)",
          "new_text": null,
          "old_line_content": "                            const bool match2 = regexp->getRE2()->Match(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": "reinterpret_cast<const char *>(cur_haystack_data)",
          "new_api": null,
          "old_text": "reinterpret_cast<const char *>(cur_haystack_data)",
          "new_text": null,
          "old_line_content": "                                    {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},",
          "new_line_content": "                    if (match == cur_haystack_data + cur_haystack_length)",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 16,
      "total_additions": 80,
      "total_deletions": 80,
      "total_api_changes": 176
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 12,
        "api_related_lines": 176,
        "non_api_lines": 9,
        "non_api_line_numbers": [
          128,
          129,
          130,
          131,
          132,
          121,
          122,
          124,
          127
        ]
      }
    },
    "api_calls_before": 154,
    "api_calls_after": 154,
    "diff_info": {
      "added_lines": 12,
      "removed_lines": 0,
      "total_diff_lines": 24
    }
  }
}