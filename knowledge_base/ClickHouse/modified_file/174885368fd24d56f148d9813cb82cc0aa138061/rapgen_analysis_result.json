{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/174885368fd24d56f148d9813cb82cc0aa138061",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/174885368fd24d56f148d9813cb82cc0aa138061/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/174885368fd24d56f148d9813cb82cc0aa138061/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/174885368fd24d56f148d9813cb82cc0aa138061/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 156,
          "old_api": "std::move(read_step)",
          "new_api": "getSampleBlockForColumns",
          "old_text": "std::move(read_step)",
          "new_text": "storage_snapshot->getSampleBlockForColumns(column_names)",
          "old_line_content": "        query_plan.addStep(std::move(read_step));",
          "new_line_content": "        auto header = storage_snapshot->getSampleBlockForColumns(column_names);",
          "content_same": false
        },
        {
          "line": 176,
          "old_api": "getInMemoryMetadata",
          "new_api": "getName",
          "old_text": "getInMemoryMetadata()",
          "new_text": "getName()",
          "old_line_content": "    StorageInMemoryMetadata new_metadata = getInMemoryMetadata();",
          "new_line_content": "    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Partition operations are not supported by storage {}\", getName());",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": "getInMemoryMetadataPtr",
          "new_api": "getDependentViews",
          "old_text": "view->getInMemoryMetadataPtr()",
          "new_text": "DatabaseCatalog::instance().getDependentViews(storage_id)",
          "old_line_content": "            const auto & select_query = view->getInMemoryMetadataPtr()->select.inner_query;",
          "new_line_content": "    auto view_ids = DatabaseCatalog::instance().getDependentViews(storage_id);",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": "push_back",
          "new_api": "getTable",
          "old_text": "name_deps[col_name].push_back(view_id.table_name)",
          "new_text": "DatabaseCatalog::instance().getTable(view_id, context)",
          "old_line_content": "                name_deps[col_name].push_back(view_id.table_name);",
          "new_line_content": "        auto view = DatabaseCatalog::instance().getTable(view_id, context);",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": "str",
          "new_api": "dumpDAG",
          "old_text": "ss.str()",
          "new_text": "prewhere_actions->dumpDAG()",
          "old_line_content": "    return ss.str();",
          "new_line_content": "        ss << \"prewhere_actions \" << prewhere_actions->dumpDAG() << \"\\n\";",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 258,
          "old_api": null,
          "new_api": "getDisks",
          "old_text": null,
          "new_text": "storage_policy->getDisks()",
          "old_line_content": "}",
          "new_line_content": "        for (const auto & disk : storage_policy->getDisks())",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": null,
          "new_api": "isWriteOnce",
          "old_text": null,
          "new_text": "disk->isWriteOnce()",
          "old_line_content": "",
          "new_line_content": "            if (!(disk->isReadOnly() || disk->isWriteOnce()))",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": null,
          "new_api": "numOutputPorts",
          "old_text": null,
          "new_text": "pipe.numOutputPorts()",
          "old_line_content": "",
          "new_line_content": "    const size_t output_ports = pipe.numOutputPorts();",
          "content_same": false
        },
        {
          "line": 140,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "pipe.resize(num_streams)",
          "old_line_content": "    QueryPlan & query_plan,",
          "new_line_content": "        pipe.resize(num_streams);",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "getName()",
          "old_line_content": "    const Names & column_names,",
          "new_line_content": "    readFromPipe(query_plan, std::move(pipe), column_names, storage_snapshot, query_info, context, getName());",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": null,
          "new_api": "getBackup",
          "old_text": null,
          "new_text": "restorer.getBackup()->listFiles(data_path_in_backup)",
          "old_line_content": "std::string PrewhereInfo::dump() const",
          "new_line_content": "    auto filenames = restorer.getBackup()->listFiles(data_path_in_backup);",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "filenames.empty()",
          "old_line_content": "{",
          "new_line_content": "    if (!filenames.empty())",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "getFullTableName",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::CANNOT_RESTORE_TABLE, \"Cannot restore table {}: Folder {} in backup must be empty\",\n                        getStorageID().getFullTableName(), data_path_in_backup)",
          "old_line_content": "    WriteBufferFromOwnString ss;",
          "new_line_content": "        throw Exception(ErrorCodes::CANNOT_RESTORE_TABLE, \"Cannot restore table {}: Folder {} in backup must be empty\",",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": null,
          "new_api": "getFullTableName",
          "old_text": null,
          "new_text": "getStorageID().getFullTableName()",
          "old_line_content": "    ss << \"PrewhereDagInfo\\n\";",
          "new_line_content": "                        getStorageID().getFullTableName(), data_path_in_backup);",
          "content_same": false
        },
        {
          "line": 154,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "pipe.empty()",
          "old_line_content": "    {",
          "new_line_content": "    if (pipe.empty())",
          "content_same": false
        },
        {
          "line": 157,
          "old_api": null,
          "new_api": "InterpreterSelectQuery::addEmptySourceToQueryPlan(query_plan, header, query_info, context)",
          "old_text": null,
          "new_text": "InterpreterSelectQuery::addEmptySourceToQueryPlan(query_plan, header, query_info, context)",
          "old_line_content": "    }",
          "new_line_content": "        InterpreterSelectQuery::addEmptySourceToQueryPlan(query_plan, header, query_info, context);",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": null,
          "new_api": "std::move(pipe)",
          "old_text": null,
          "new_text": "std::move(pipe)",
          "old_line_content": "    const ASTInsertQuery & /*query*/,",
          "new_line_content": "        auto read_step = std::make_unique<ReadFromStorageStep>(std::move(pipe), storage_name, query_info.storage_limits);",
          "content_same": false
        },
        {
          "line": 162,
          "old_api": null,
          "new_api": "std::move(read_step)",
          "old_text": null,
          "new_text": "std::move(read_step)",
          "old_line_content": "    ContextPtr /*context*/)",
          "new_line_content": "        query_plan.addStep(std::move(read_step));",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": null,
          "new_api": "dumpDAG",
          "old_text": null,
          "new_text": "row_level_filter->dumpDAG()",
          "old_line_content": "    }",
          "new_line_content": "        ss << \"row_level_filter \" << row_level_filter->dumpDAG() << \"\\n\";",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": null,
          "new_api": "str",
          "old_text": null,
          "new_text": "ss.str()",
          "old_line_content": "    ss << \"FilterDAGInfo for column '\" << column_name <<\"', do_remove_column \"",
          "new_line_content": "    return ss.str();",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": null,
          "new_api": "getStorageID",
          "old_text": null,
          "new_text": "getStorageID()",
          "old_line_content": "",
          "new_line_content": "    auto table_id = getStorageID();",
          "content_same": false
        },
        {
          "line": 182,
          "old_api": null,
          "new_api": "getInMemoryMetadata",
          "old_text": null,
          "new_text": "getInMemoryMetadata()",
          "old_line_content": "void IStorage::checkAlterIsPossible(const AlterCommands & commands, ContextPtr /* context */) const",
          "new_line_content": "    StorageInMemoryMetadata new_metadata = getInMemoryMetadata();",
          "content_same": false
        },
        {
          "line": 183,
          "old_api": null,
          "new_api": "apply",
          "old_text": null,
          "new_text": "params.apply(new_metadata, context)",
          "old_line_content": "{",
          "new_line_content": "    params.apply(new_metadata, context);",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": null,
          "new_api": "getDatabase",
          "old_text": null,
          "new_text": "DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(context, table_id, new_metadata)",
          "old_line_content": "    for (const auto & command : commands)",
          "new_line_content": "    DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(context, table_id, new_metadata);",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": null,
          "new_api": "setInMemoryMetadata",
          "old_text": null,
          "new_text": "setInMemoryMetadata(new_metadata)",
          "old_line_content": "    {",
          "new_line_content": "    setInMemoryMetadata(new_metadata);",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": null,
          "new_api": "dumpDAG",
          "old_text": null,
          "new_text": "actions->dumpDAG()",
          "old_line_content": "}",
          "new_line_content": "        ss << \"actions \" << actions->dumpDAG() << \"\\n\";",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": null,
          "new_api": "str",
          "old_text": null,
          "new_text": "ss.str()",
          "old_line_content": "",
          "new_line_content": "    return ss.str();",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": null,
          "new_api": "isCommentAlter",
          "old_text": null,
          "new_text": "command.isCommentAlter()",
          "old_line_content": "void IStorage::checkMutationIsPossible(const MutationCommands & /*commands*/, const Settings & /*settings*/) const",
          "new_line_content": "        if (!command.isCommentAlter())",
          "content_same": false
        },
        {
          "line": 193,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::NOT_IMPLEMENTED, \"Alter of type '{}' is not supported by storage {}\",\n                command.type, getName())",
          "old_line_content": "{",
          "new_line_content": "            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Alter of type '{}' is not supported by storage {}\",",
          "content_same": false
        },
        {
          "line": 206,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "getName()",
          "old_line_content": "    return storage_id;",
          "new_line_content": "    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Table engine {} doesn't support partitioning\", getName());",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": null,
          "new_api": "getColumns",
          "old_text": null,
          "new_text": "getInMemoryMetadata().getColumns().getAllPhysical()",
          "old_line_content": "{",
          "new_line_content": "    const NamesAndTypesList & available_columns = getInMemoryMetadata().getColumns().getAllPhysical();",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": null,
          "new_api": "std::back_inserter(result)",
          "old_text": null,
          "new_text": "std::back_inserter(result)",
          "old_line_content": "    NameDependencies name_deps;",
          "new_line_content": "    std::transform(available_columns.begin(), available_columns.end(), std::back_inserter(result), getter);",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": null,
          "new_api": "getInMemoryMetadataPtr",
          "old_text": null,
          "new_text": "view->getInMemoryMetadataPtr()",
          "old_line_content": "        }",
          "new_line_content": "        if (view->getInMemoryMetadataPtr()->select.inner_query)",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": null,
          "new_api": "getInMemoryMetadataPtr",
          "old_text": null,
          "new_text": "view->getInMemoryMetadataPtr()",
          "old_line_content": "    return name_deps;",
          "new_line_content": "            const auto & select_query = view->getInMemoryMetadataPtr()->select.inner_query;",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": null,
          "new_api": "noModify",
          "old_text": null,
          "new_text": "SelectQueryOptions{}.noModify()",
          "old_line_content": "}",
          "new_line_content": "            auto required_columns = InterpreterSelectQuery(select_query, context, SelectQueryOptions{}.noModify()).getRequiredColumns();",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "name_deps[col_name].push_back(view_id.table_name)",
          "old_line_content": "bool IStorage::isStaticStorage() const",
          "new_line_content": "                name_deps[col_name].push_back(view_id.table_name);",
          "content_same": false
        },
        {
          "line": 255,
          "old_api": null,
          "new_api": "getStoragePolicy",
          "old_text": null,
          "new_text": "getStoragePolicy()",
          "old_line_content": "        return true;",
          "new_line_content": "    auto storage_policy = getStoragePolicy();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 136,
          "old_api": "getName",
          "new_api": null,
          "old_text": "getName()",
          "new_text": null,
          "old_line_content": "    readFromPipe(query_plan, std::move(pipe), column_names, storage_snapshot, query_info, context, getName());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "getBackup",
          "new_api": null,
          "old_text": "restorer.getBackup()->listFiles(data_path_in_backup)",
          "new_text": null,
          "old_line_content": "    auto filenames = restorer.getBackup()->listFiles(data_path_in_backup);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "empty",
          "new_api": null,
          "old_text": "filenames.empty()",
          "new_text": null,
          "old_line_content": "    if (!filenames.empty())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": "getFullTableName",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::CANNOT_RESTORE_TABLE, \"Cannot restore table {}: Folder {} in backup must be empty\",\n                        getStorageID().getFullTableName(), data_path_in_backup)",
          "new_text": null,
          "old_line_content": "        throw Exception(ErrorCodes::CANNOT_RESTORE_TABLE, \"Cannot restore table {}: Folder {} in backup must be empty\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": "getFullTableName",
          "new_api": null,
          "old_text": "getStorageID().getFullTableName()",
          "new_text": null,
          "old_line_content": "                        getStorageID().getFullTableName(), data_path_in_backup);",
          "new_line_content": "void IStorage::restoreDataFromBackup(RestorerFromBackup & restorer, const String & data_path_in_backup, const std::optional<ASTs> &)",
          "content_same": false
        },
        {
          "line": 148,
          "old_api": "empty",
          "new_api": null,
          "old_text": "pipe.empty()",
          "new_text": null,
          "old_line_content": "    if (pipe.empty())",
          "new_line_content": "    const Names & column_names,",
          "content_same": false
        },
        {
          "line": 150,
          "old_api": "getSampleBlockForColumns",
          "new_api": null,
          "old_text": "storage_snapshot->getSampleBlockForColumns(column_names)",
          "new_text": null,
          "old_line_content": "        auto header = storage_snapshot->getSampleBlockForColumns(column_names);",
          "new_line_content": "    SelectQueryInfo & query_info,",
          "content_same": false
        },
        {
          "line": 151,
          "old_api": "InterpreterSelectQuery::addEmptySourceToQueryPlan(query_plan, header, query_info, context)",
          "new_api": null,
          "old_text": "InterpreterSelectQuery::addEmptySourceToQueryPlan(query_plan, header, query_info, context)",
          "new_text": null,
          "old_line_content": "        InterpreterSelectQuery::addEmptySourceToQueryPlan(query_plan, header, query_info, context);",
          "new_line_content": "    ContextPtr context,",
          "content_same": false
        },
        {
          "line": 155,
          "old_api": "std::move(pipe)",
          "new_api": null,
          "old_text": "std::move(pipe)",
          "new_text": null,
          "old_line_content": "        auto read_step = std::make_unique<ReadFromStorageStep>(std::move(pipe), storage_name, query_info.storage_limits);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "dumpDAG",
          "new_api": null,
          "old_text": "row_level_filter->dumpDAG()",
          "new_text": null,
          "old_line_content": "        ss << \"row_level_filter \" << row_level_filter->dumpDAG() << \"\\n\";",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "dumpDAG",
          "new_api": null,
          "old_text": "prewhere_actions->dumpDAG()",
          "new_text": null,
          "old_line_content": "        ss << \"prewhere_actions \" << prewhere_actions->dumpDAG() << \"\\n\";",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 170,
          "old_api": "getName",
          "new_api": null,
          "old_text": "getName()",
          "new_text": null,
          "old_line_content": "    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Partition operations are not supported by storage {}\", getName());",
          "new_line_content": "    return {};",
          "content_same": false
        },
        {
          "line": 175,
          "old_api": "getStorageID",
          "new_api": null,
          "old_text": "getStorageID()",
          "new_text": null,
          "old_line_content": "    auto table_id = getStorageID();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 177,
          "old_api": "apply",
          "new_api": null,
          "old_text": "params.apply(new_metadata, context)",
          "new_text": null,
          "old_line_content": "    params.apply(new_metadata, context);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 178,
          "old_api": "getDatabase",
          "new_api": null,
          "old_text": "DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(context, table_id, new_metadata)",
          "new_text": null,
          "old_line_content": "    DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(context, table_id, new_metadata);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": "setInMemoryMetadata",
          "new_api": null,
          "old_text": "setInMemoryMetadata(new_metadata)",
          "new_text": null,
          "old_line_content": "    setInMemoryMetadata(new_metadata);",
          "new_line_content": "void IStorage::alter(const AlterCommands & params, ContextPtr context, AlterLockHolder &)",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": "dumpDAG",
          "new_api": null,
          "old_text": "actions->dumpDAG()",
          "new_text": null,
          "old_line_content": "        ss << \"actions \" << actions->dumpDAG() << \"\\n\";",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": "str",
          "new_api": null,
          "old_text": "ss.str()",
          "new_text": null,
          "old_line_content": "    return ss.str();",
          "new_line_content": "       << do_remove_column << \"\\n\";",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": "isCommentAlter",
          "new_api": null,
          "old_text": "command.isCommentAlter()",
          "new_text": null,
          "old_line_content": "        if (!command.isCommentAlter())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 187,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::NOT_IMPLEMENTED, \"Alter of type '{}' is not supported by storage {}\",\n                command.type, getName())",
          "new_text": null,
          "old_line_content": "            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Alter of type '{}' is not supported by storage {}\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": "getName",
          "new_api": null,
          "old_text": "getName()",
          "new_text": null,
          "old_line_content": "                command.type, getName());",
          "new_line_content": "void IStorage::checkAlterIsPossible(const AlterCommands & commands, ContextPtr /* context */) const",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": "getColumns",
          "new_api": null,
          "old_text": "getInMemoryMetadata().getColumns().getAllPhysical()",
          "new_text": null,
          "old_line_content": "    const NamesAndTypesList & available_columns = getInMemoryMetadata().getColumns().getAllPhysical();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 225,
          "old_api": "std::back_inserter(result)",
          "new_api": null,
          "old_text": "std::back_inserter(result)",
          "new_text": null,
          "old_line_content": "    std::transform(available_columns.begin(), available_columns.end(), std::back_inserter(result), getter);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": "getDependentViews",
          "new_api": null,
          "old_text": "DatabaseCatalog::instance().getDependentViews(storage_id)",
          "new_text": null,
          "old_line_content": "    auto view_ids = DatabaseCatalog::instance().getDependentViews(storage_id);",
          "new_line_content": "    return result;",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": "getTable",
          "new_api": null,
          "old_text": "DatabaseCatalog::instance().getTable(view_id, context)",
          "new_text": null,
          "old_line_content": "        auto view = DatabaseCatalog::instance().getTable(view_id, context);",
          "new_line_content": "NameDependencies IStorage::getDependentViewsByColumn(ContextPtr context) const",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": "getInMemoryMetadataPtr",
          "new_api": null,
          "old_text": "view->getInMemoryMetadataPtr()",
          "new_text": null,
          "old_line_content": "        if (view->getInMemoryMetadataPtr()->select.inner_query)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": "noModify",
          "new_api": null,
          "old_text": "SelectQueryOptions{}.noModify()",
          "new_text": null,
          "old_line_content": "            auto required_columns = InterpreterSelectQuery(select_query, context, SelectQueryOptions{}.noModify()).getRequiredColumns();",
          "new_line_content": "    for (const auto & view_id : view_ids)",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": "getStoragePolicy",
          "new_api": null,
          "old_text": "getStoragePolicy()",
          "new_text": null,
          "old_line_content": "    auto storage_policy = getStoragePolicy();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": "getDisks",
          "new_api": null,
          "old_text": "storage_policy->getDisks()",
          "new_text": null,
          "old_line_content": "        for (const auto & disk : storage_policy->getDisks())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 253,
          "old_api": "isWriteOnce",
          "new_api": null,
          "old_text": "disk->isWriteOnce()",
          "new_text": null,
          "old_line_content": "            if (!(disk->isReadOnly() || disk->isWriteOnce()))",
          "new_line_content": "bool IStorage::isStaticStorage() const",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 5,
      "total_additions": 32,
      "total_deletions": 30,
      "total_api_changes": 67
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 67,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          137,
          139,
          141
        ]
      }
    },
    "api_calls_before": 85,
    "api_calls_after": 87,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 0,
      "total_diff_lines": 18
    }
  }
}