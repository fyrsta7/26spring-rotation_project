{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/7f401579e0b21bd749ef17f3a8c2efc693d29173",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/7f401579e0b21bd749ef17f3a8c2efc693d29173/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/7f401579e0b21bd749ef17f3a8c2efc693d29173/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/7f401579e0b21bd749ef17f3a8c2efc693d29173/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 136,
          "old_api": "unalignedLoad<T>(source)",
          "new_api": "Exception",
          "old_text": "unalignedLoad<T>(source)",
          "new_text": "Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot GCD decompress, data size {} is less than {}\", source_size, sizeof(T))",
          "old_line_content": "    const T gcd = unalignedLoad<T>(source);",
          "new_line_content": "        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot GCD decompress, data size {} is less than {}\", source_size, sizeof(T));",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": "compressDataForType<UInt16>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "new_api": "compressDataForType<UInt8>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "old_text": "compressDataForType<UInt16>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "new_text": "compressDataForType<UInt8>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "old_line_content": "        compressDataForType<UInt16>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);",
          "new_line_content": "        compressDataForType<UInt8>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);",
          "content_same": false
        },
        {
          "line": 167,
          "old_api": "compressDataForType<UInt32>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "new_api": "compressDataForType<UInt16>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "old_text": "compressDataForType<UInt32>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "new_text": "compressDataForType<UInt16>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "old_line_content": "        compressDataForType<UInt32>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);",
          "new_line_content": "        compressDataForType<UInt16>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);",
          "content_same": false
        },
        {
          "line": 170,
          "old_api": "compressDataForType<UInt64>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "new_api": "compressDataForType<UInt32>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "old_text": "compressDataForType<UInt64>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "new_text": "compressDataForType<UInt32>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "old_line_content": "        compressDataForType<UInt64>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);",
          "new_line_content": "        compressDataForType<UInt32>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);",
          "content_same": false
        },
        {
          "line": 173,
          "old_api": "compressDataForType<UInt128>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "new_api": "compressDataForType<UInt64>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "old_text": "compressDataForType<UInt128>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "new_text": "compressDataForType<UInt64>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "old_line_content": "        compressDataForType<UInt128>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);",
          "new_line_content": "        compressDataForType<UInt64>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);",
          "content_same": false
        },
        {
          "line": 176,
          "old_api": "compressDataForType<UInt256>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "new_api": "compressDataForType<UInt128>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "old_text": "compressDataForType<UInt256>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "new_text": "compressDataForType<UInt128>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "old_line_content": "        compressDataForType<UInt256>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);",
          "new_line_content": "        compressDataForType<UInt128>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": "memcpy",
          "new_api": "static_cast<UInt32>(2 + bytes_to_skip)",
          "old_text": "memcpy(dest, &source[2], bytes_to_skip)",
          "new_text": "static_cast<UInt32>(2 + bytes_to_skip)",
          "old_line_content": "    memcpy(dest, &source[2], bytes_to_skip);",
          "new_line_content": "    if (static_cast<UInt32>(2 + bytes_to_skip) > source_size)",
          "content_same": false
        },
        {
          "line": 209,
          "old_api": "decompressDataForType<UInt16>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "new_api": "decompressDataForType<UInt8>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "old_text": "decompressDataForType<UInt16>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "new_text": "decompressDataForType<UInt8>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "old_line_content": "        decompressDataForType<UInt16>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size);",
          "new_line_content": "        decompressDataForType<UInt8>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size);",
          "content_same": false
        },
        {
          "line": 212,
          "old_api": "decompressDataForType<UInt32>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "new_api": "decompressDataForType<UInt16>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "old_text": "decompressDataForType<UInt32>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "new_text": "decompressDataForType<UInt16>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "old_line_content": "        decompressDataForType<UInt32>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size);",
          "new_line_content": "        decompressDataForType<UInt16>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size);",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": "decompressDataForType<UInt64>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "new_api": "decompressDataForType<UInt32>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "old_text": "decompressDataForType<UInt64>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "new_text": "decompressDataForType<UInt32>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "old_line_content": "        decompressDataForType<UInt64>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size);",
          "new_line_content": "        decompressDataForType<UInt32>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size);",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": "decompressDataForType<UInt128>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "new_api": "decompressDataForType<UInt64>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "old_text": "decompressDataForType<UInt128>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "new_text": "decompressDataForType<UInt64>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "old_line_content": "        decompressDataForType<UInt128>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size);",
          "new_line_content": "        decompressDataForType<UInt64>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size);",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": "decompressDataForType<UInt256>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "new_api": "decompressDataForType<UInt128>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "old_text": "decompressDataForType<UInt256>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "new_text": "decompressDataForType<UInt128>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "old_line_content": "        decompressDataForType<UInt256>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size);",
          "new_line_content": "        decompressDataForType<UInt128>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size);",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": "getSizeOfValueInMemory",
          "new_api": "getName",
          "old_text": "column_type->getSizeOfValueInMemory()",
          "new_text": "Exception(ErrorCodes::BAD_ARGUMENTS, \"Codec GCD is not applicable for {} because the data type is not of fixed size\",\n            column_type->getName())",
          "old_line_content": "    size_t max_size = column_type->getSizeOfValueInMemory();",
          "new_line_content": "        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Codec GCD is not applicable for {} because the data type is not of fixed size\",",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": "getName",
          "new_api": "static_cast<UInt8>(max_size)",
          "old_text": "column_type->getName()",
          "new_text": "static_cast<UInt8>(max_size)",
          "old_line_content": "            column_type->getName());",
          "new_line_content": "        return static_cast<UInt8>(max_size);",
          "content_same": false
        },
        {
          "line": 257,
          "old_api": "size",
          "new_api": "getGCDBytesSize",
          "old_text": "arguments->children.size()",
          "new_text": "getGCDBytesSize(column_type)",
          "old_line_content": "        if (arguments && arguments->children.size() > 1)",
          "new_line_content": "            gcd_bytes_size = getGCDBytesSize(column_type);",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": "registerCompressionCodecWithType",
          "new_api": "size",
          "old_text": "factory.registerCompressionCodecWithType(\"GCD\", method_code, codec_builder)",
          "new_text": "arguments->children.size()",
          "old_line_content": "    factory.registerCompressionCodecWithType(\"GCD\", method_code, codec_builder);",
          "new_line_content": "            throw Exception(ErrorCodes::ILLEGAL_SYNTAX_FOR_CODEC_TYPE, \"GCD codec must have 1 parameter, given {}\", arguments->children.size());",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 260,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "arguments->children.size()",
          "old_line_content": "    };",
          "new_line_content": "        if (arguments && arguments->children.size() > 1)",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": null,
          "new_api": "std::make_shared<CompressionCodecGCD>(gcd_bytes_size)",
          "old_text": null,
          "new_text": "std::make_shared<CompressionCodecGCD>(gcd_bytes_size)",
          "old_line_content": "}",
          "new_line_content": "        return std::make_shared<CompressionCodecGCD>(gcd_bytes_size);",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": null,
          "new_api": "registerCompressionCodecWithType",
          "old_text": null,
          "new_text": "factory.registerCompressionCodecWithType(\"GCD\", method_code, codec_builder)",
          "old_line_content": "CompressionCodecPtr getCompressionCodecGCD(UInt8 gcd_bytes_size)",
          "new_line_content": "    factory.registerCompressionCodecWithType(\"GCD\", method_code, codec_builder);",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": null,
          "new_api": "unalignedLoad<T>(source)",
          "old_text": null,
          "new_text": "unalignedLoad<T>(source)",
          "old_line_content": "    {",
          "new_line_content": "    const T gcd = unalignedLoad<T>(source);",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": null,
          "new_api": "std::make_shared<CompressionCodecGCD>(gcd_bytes_size)",
          "old_text": null,
          "new_text": "std::make_shared<CompressionCodecGCD>(gcd_bytes_size)",
          "old_line_content": "}",
          "new_line_content": "    return std::make_shared<CompressionCodecGCD>(gcd_bytes_size);",
          "content_same": false
        },
        {
          "line": 144,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress the data\")",
          "old_line_content": "        source += sizeof(T);",
          "new_line_content": "            throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress the data\");",
          "content_same": false
        },
        {
          "line": 145,
          "old_api": null,
          "new_api": "unalignedLoad<T>(source)",
          "old_text": null,
          "new_text": "unalignedLoad<T>(source)",
          "old_line_content": "        dest += sizeof(T);",
          "new_line_content": "        unalignedStore<T>(dest, unalignedLoad<T>(source) * gcd);",
          "content_same": false
        },
        {
          "line": 159,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(&dest[2], source, bytes_to_skip)",
          "old_line_content": "    {",
          "new_line_content": "    memcpy(&dest[2], source, bytes_to_skip);",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": null,
          "new_api": "compressDataForType<UInt256>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "old_text": null,
          "new_text": "compressDataForType<UInt256>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "old_line_content": "    return 2 + source_size;",
          "new_line_content": "        compressDataForType<UInt256>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\")",
          "old_line_content": "        return;",
          "new_line_content": "        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\")",
          "old_line_content": "    UInt32 output_size = uncompressed_size - bytes_to_skip;",
          "new_line_content": "        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");",
          "content_same": false
        },
        {
          "line": 202,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\")",
          "old_line_content": "    UInt32 source_size_no_header = source_size - bytes_to_skip - 2;",
          "new_line_content": "        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(dest, &source[2], bytes_to_skip)",
          "old_line_content": "    {",
          "new_line_content": "    memcpy(dest, &source[2], bytes_to_skip);",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": null,
          "new_api": "decompressDataForType<UInt256>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "old_text": null,
          "new_text": "decompressDataForType<UInt256>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "old_line_content": "}",
          "new_line_content": "        decompressDataForType<UInt256>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size);",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": null,
          "new_api": "isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion",
          "old_text": null,
          "new_text": "column_type->isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion()",
          "old_line_content": "",
          "new_line_content": "    if (!column_type->isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion())",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "column_type->getName()",
          "old_line_content": "    if (max_size == 1 || max_size == 2 || max_size == 4 || max_size == 8 || max_size == 16 || max_size == 32)",
          "new_line_content": "            column_type->getName());",
          "content_same": false
        },
        {
          "line": 110,
          "old_api": null,
          "new_api": "T",
          "old_text": null,
          "new_text": "T(1)",
          "old_line_content": "    }",
          "new_line_content": "        if (gcd == T(1)) {",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": null,
          "new_api": "getSizeOfValueInMemory",
          "old_text": null,
          "new_text": "column_type->getSizeOfValueInMemory()",
          "old_line_content": "    else",
          "new_line_content": "    size_t max_size = column_type->getSizeOfValueInMemory();",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::BAD_ARGUMENTS, \"Codec GCD is only applicable for data types of size 1, 2, 4, 8, 16, 32 bytes. Given type {}\",\n            column_type->getName())",
          "old_line_content": "",
          "new_line_content": "        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Codec GCD is only applicable for data types of size 1, 2, 4, 8, 16, 32 bytes. Given type {}\",",
          "content_same": false
        },
        {
          "line": 115,
          "old_api": null,
          "new_api": "unalignedStore<T>(dest, gcd)",
          "old_text": null,
          "new_text": "unalignedStore<T>(dest, gcd)",
          "old_line_content": "    cur_source = source;",
          "new_line_content": "    unalignedStore<T>(dest, gcd);",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "column_type->getName()",
          "old_line_content": "}",
          "new_line_content": "            column_type->getName());",
          "content_same": false
        },
        {
          "line": 121,
          "old_api": null,
          "new_api": "unalignedLoad<T>(cur_source)",
          "old_text": null,
          "new_text": "unalignedLoad<T>(cur_source)",
          "old_line_content": "    }",
          "new_line_content": "        unalignedStore<T>(dest, unalignedLoad<T>(cur_source) / gcd);",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": null,
          "new_api": "static_cast<UInt8>(CompressionMethodByte::GCD)",
          "old_text": null,
          "new_text": "static_cast<UInt8>(CompressionMethodByte::GCD)",
          "old_line_content": "        /// Default bytes size is 1.",
          "new_line_content": "    UInt8 method_code = static_cast<UInt8>(CompressionMethodByte::GCD);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 130,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot GCD decompress, data size {}  is not aligned to {}\", source_size, sizeof(T))",
          "new_text": null,
          "old_line_content": "        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot GCD decompress, data size {}  is not aligned to {}\", source_size, sizeof(T));",
          "new_line_content": "    const char * const output_end = dest + output_size;",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": "std::make_shared<CompressionCodecGCD>(gcd_bytes_size)",
          "new_api": null,
          "old_text": "std::make_shared<CompressionCodecGCD>(gcd_bytes_size)",
          "new_text": null,
          "old_line_content": "        return std::make_shared<CompressionCodecGCD>(gcd_bytes_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": "size",
          "new_api": null,
          "old_text": "arguments->children.size()",
          "new_text": null,
          "old_line_content": "            throw Exception(ErrorCodes::ILLEGAL_SYNTAX_FOR_CODEC_TYPE, \"GCD codec must have 1 parameter, given {}\", arguments->children.size());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": "std::make_shared<CompressionCodecGCD>(gcd_bytes_size)",
          "new_api": null,
          "old_text": "std::make_shared<CompressionCodecGCD>(gcd_bytes_size)",
          "new_text": null,
          "old_line_content": "    return std::make_shared<CompressionCodecGCD>(gcd_bytes_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 141,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress the data\")",
          "new_text": null,
          "old_line_content": "            throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress the data\");",
          "new_line_content": "    while (source < source_end)",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": "unalignedLoad<T>(source)",
          "new_api": null,
          "old_text": "unalignedLoad<T>(source)",
          "new_text": null,
          "old_line_content": "        unalignedStore<T>(dest, unalignedLoad<T>(source) * gcd);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(&dest[2], source, bytes_to_skip)",
          "new_text": null,
          "old_line_content": "    memcpy(&dest[2], source, bytes_to_skip);",
          "new_line_content": "    UInt8 bytes_to_skip = source_size % gcd_bytes_size;",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": "compressDataForType<UInt8>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "new_api": null,
          "old_text": "compressDataForType<UInt8>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos])",
          "new_text": null,
          "old_line_content": "        compressDataForType<UInt8>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);",
          "new_line_content": "    switch (gcd_bytes_size)",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\")",
          "new_text": null,
          "old_line_content": "        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");",
          "new_line_content": "void CompressionCodecGCD::doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const",
          "content_same": false
        },
        {
          "line": 193,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\")",
          "new_text": null,
          "old_line_content": "        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");",
          "new_line_content": "    UInt8 bytes_size = source[0];",
          "content_same": false
        },
        {
          "line": 198,
          "old_api": "static_cast<UInt32>(2 + bytes_to_skip)",
          "new_api": null,
          "old_text": "static_cast<UInt32>(2 + bytes_to_skip)",
          "new_text": null,
          "old_line_content": "    if (static_cast<UInt32>(2 + bytes_to_skip) > source_size)",
          "new_line_content": "    UInt8 bytes_to_skip = uncompressed_size % bytes_size;",
          "content_same": false
        },
        {
          "line": 199,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\")",
          "new_text": null,
          "old_line_content": "        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");",
          "new_line_content": "    UInt32 output_size = uncompressed_size - bytes_to_skip;",
          "content_same": false
        },
        {
          "line": 206,
          "old_api": "decompressDataForType<UInt8>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "new_api": null,
          "old_text": "decompressDataForType<UInt8>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size)",
          "new_text": null,
          "old_line_content": "        decompressDataForType<UInt8>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], output_size);",
          "new_line_content": "    switch (bytes_size)",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": "isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion",
          "new_api": null,
          "old_text": "column_type->isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion()",
          "new_text": null,
          "old_line_content": "    if (!column_type->isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": "getName",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::BAD_ARGUMENTS, \"Codec GCD is not applicable for {} because the data type is not of fixed size\",\n            column_type->getName())",
          "new_text": null,
          "old_line_content": "        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Codec GCD is not applicable for {} because the data type is not of fixed size\",",
          "new_line_content": "UInt8 getGCDBytesSize(const IDataType * column_type)",
          "content_same": false
        },
        {
          "line": 233,
          "old_api": "getName",
          "new_api": null,
          "old_text": "column_type->getName()",
          "new_text": null,
          "old_line_content": "            column_type->getName());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": "static_cast<UInt8>(max_size)",
          "new_api": null,
          "old_text": "static_cast<UInt8>(max_size)",
          "new_text": null,
          "old_line_content": "        return static_cast<UInt8>(max_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": "getName",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::BAD_ARGUMENTS, \"Codec GCD is only applicable for data types of size 1, 2, 4, 8, 16, 32 bytes. Given type {}\",\n            column_type->getName())",
          "new_text": null,
          "old_line_content": "        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Codec GCD is only applicable for data types of size 1, 2, 4, 8, 16, 32 bytes. Given type {}\",",
          "new_line_content": "    if (max_size == 1 || max_size == 2 || max_size == 4 || max_size == 8 || max_size == 16 || max_size == 32)",
          "content_same": false
        },
        {
          "line": 112,
          "old_api": "unalignedStore<T>(dest, gcd)",
          "new_api": null,
          "old_text": "unalignedStore<T>(dest, gcd)",
          "new_text": null,
          "old_line_content": "    unalignedStore<T>(dest, gcd);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 118,
          "old_api": "unalignedLoad<T>(cur_source)",
          "new_api": null,
          "old_text": "unalignedLoad<T>(cur_source)",
          "new_text": null,
          "old_line_content": "        unalignedStore<T>(dest, unalignedLoad<T>(cur_source) / gcd);",
          "new_line_content": "    cur_source = source;",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": "static_cast<UInt8>(CompressionMethodByte::GCD)",
          "new_api": null,
          "old_text": "static_cast<UInt8>(CompressionMethodByte::GCD)",
          "new_text": null,
          "old_line_content": "    UInt8 method_code = static_cast<UInt8>(CompressionMethodByte::GCD);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": "getGCDBytesSize",
          "new_api": null,
          "old_text": "getGCDBytesSize(column_type)",
          "new_text": null,
          "old_line_content": "            gcd_bytes_size = getGCDBytesSize(column_type);",
          "new_line_content": "        UInt8 gcd_bytes_size = 1;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 16,
      "total_additions": 23,
      "total_deletions": 22,
      "total_api_changes": 61
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 3,
        "api_related_lines": 61,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          111
        ]
      }
    },
    "api_calls_before": 54,
    "api_calls_after": 55,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 0,
      "total_diff_lines": 15
    }
  }
}