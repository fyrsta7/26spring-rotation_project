{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/d4dd6b05b27b41c4db47bae627992d500983fcaf",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/d4dd6b05b27b41c4db47bae627992d500983fcaf/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/d4dd6b05b27b41c4db47bae627992d500983fcaf/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/d4dd6b05b27b41c4db47bae627992d500983fcaf/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 485,
          "old_api": "back",
          "new_api": "set",
          "old_text": "stages.back().column_to_updated.empty()",
          "new_text": "mutation_kind.set(MutationKind::MUTATE_OTHER)",
          "old_line_content": "            if (stages.empty() || !stages.back().column_to_updated.empty())",
          "new_line_content": "            mutation_kind.set(MutationKind::MUTATE_OTHER);",
          "content_same": false
        },
        {
          "line": 486,
          "old_api": "emplace_back",
          "new_api": "back",
          "old_text": "stages.emplace_back(context)",
          "new_text": "stages.back().column_to_updated.empty()",
          "old_line_content": "                stages.emplace_back(context);",
          "new_line_content": "            if (stages.empty() || !stages.back().column_to_updated.empty())",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "back",
          "new_api": "set",
          "old_text": "stages.back().column_to_updated.empty()",
          "new_text": "mutation_kind.set(MutationKind::MUTATE_OTHER)",
          "old_line_content": "            if (stages.empty() || !stages.back().column_to_updated.empty())",
          "new_line_content": "            mutation_kind.set(MutationKind::MUTATE_OTHER);",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": "emplace_back",
          "new_api": "back",
          "old_text": "stages.emplace_back(context)",
          "new_text": "stages.back().column_to_updated.empty()",
          "old_line_content": "                stages.emplace_back(context);",
          "new_line_content": "            if (stages.empty() || !stages.back().column_to_updated.empty())",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "size",
          "new_api": "emplace_back",
          "old_text": "stages.size()",
          "new_text": "stages.emplace_back(context)",
          "old_line_content": "            if (stages.size() == 1) /// First stage only supports filtering and can't update columns.",
          "new_line_content": "                stages.emplace_back(context);",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "emplace_back",
          "new_api": "size",
          "old_text": "stages.emplace_back(context)",
          "new_text": "stages.size()",
          "old_line_content": "                stages.emplace_back(context);",
          "new_line_content": "            if (stages.size() == 1) /// First stage only supports filtering and can't update columns.",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": "end",
          "new_api": "find",
          "old_text": "column_to_affected_materialized.end()",
          "new_text": "column_to_affected_materialized.find(column)",
          "old_line_content": "                if (materialized_it != column_to_affected_materialized.end())",
          "new_line_content": "                auto materialized_it = column_to_affected_materialized.find(column);",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "std::make_shared<ASTIdentifier>(column)",
          "new_api": "clone",
          "old_text": "std::make_shared<ASTIdentifier>(column)",
          "new_text": "update_expr->clone()",
          "old_line_content": "                            std::make_shared<ASTIdentifier>(column));",
          "new_line_content": "                            update_expr->clone(),",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": "makeASTFunction",
          "new_api": "std::make_shared<ASTIdentifier>(column)",
          "old_text": "makeASTFunction(\"and\", condition, function)",
          "new_text": "std::make_shared<ASTIdentifier>(column)",
          "old_line_content": "                        condition = makeASTFunction(\"and\", condition, function);",
          "new_line_content": "                            std::make_shared<ASTIdentifier>(column));",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": "push_back",
          "new_api": "std::make_shared<ASTExpressionList>()",
          "old_text": "function->children.push_back(function->arguments)",
          "new_text": "std::make_shared<ASTExpressionList>()",
          "old_line_content": "                        function->children.push_back(function->arguments);",
          "new_line_content": "                        function->arguments = std::make_shared<ASTExpressionList>();",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": "makeASTFunction",
          "new_api": "clone",
          "old_text": "makeASTFunction(\"and\", condition, function)",
          "new_text": "it->clone()",
          "old_line_content": "                        condition = makeASTFunction(\"and\", condition, function);",
          "new_line_content": "                            function->arguments->children.push_back(it->clone());",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": "back",
          "new_api": "set",
          "old_text": "stages.back().column_to_updated.empty()",
          "new_text": "mutation_kind.set(MutationKind::MUTATE_OTHER)",
          "old_line_content": "            if (stages.empty() || !stages.back().column_to_updated.empty())",
          "new_line_content": "            mutation_kind.set(MutationKind::MUTATE_OTHER);",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": "emplace_back",
          "new_api": "back",
          "old_text": "stages.emplace_back(context)",
          "new_text": "stages.back().column_to_updated.empty()",
          "old_line_content": "                stages.emplace_back(context);",
          "new_line_content": "            if (stages.empty() || !stages.back().column_to_updated.empty())",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": "size",
          "new_api": "emplace_back",
          "old_text": "stages.size()",
          "new_text": "stages.emplace_back(context)",
          "old_line_content": "            if (stages.size() == 1) /// First stage only supports filtering and can't update columns.",
          "new_line_content": "                stages.emplace_back(context);",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": "emplace_back",
          "new_api": "size",
          "old_text": "stages.emplace_back(context)",
          "new_text": "stages.size()",
          "old_line_content": "                stages.emplace_back(context);",
          "new_line_content": "            if (stages.size() == 1) /// First stage only supports filtering and can't update columns.",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": "getName",
          "new_api": "clone",
          "old_text": "column.type->getName()",
          "new_text": "makeASTFunction(\n                \"_CAST\", column.default_desc.expression->clone(), std::make_shared<ASTLiteral>(column.type->getName()))",
          "old_line_content": "                \"_CAST\", column.default_desc.expression->clone(), std::make_shared<ASTLiteral>(column.type->getName()));",
          "new_line_content": "            auto materialized_column = makeASTFunction(",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": "std::find_if(\n                    std::cbegin(indices_desc), std::end(indices_desc),\n                    [&](const IndexDescription & index)\n                    {\n                        return index.name == command.index_name;\n                    })",
          "new_api": "set",
          "old_text": "std::find_if(\n                    std::cbegin(indices_desc), std::end(indices_desc),\n                    [&](const IndexDescription & index)\n                    {\n                        return index.name == command.index_name;\n                    })",
          "new_text": "mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION)",
          "old_line_content": "            auto it = std::find_if(",
          "new_line_content": "            mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION);",
          "content_same": false
        },
        {
          "line": 617,
          "old_api": "std::end(indices_desc)",
          "new_api": "std::find_if(\n                    std::cbegin(indices_desc), std::end(indices_desc),\n                    [&](const IndexDescription & index)\n                    {\n                        return index.name == command.index_name;\n                    })",
          "old_text": "std::end(indices_desc)",
          "new_text": "std::find_if(\n                    std::cbegin(indices_desc), std::end(indices_desc),\n                    [&](const IndexDescription & index)\n                    {\n                        return index.name == command.index_name;\n                    })",
          "old_line_content": "                    std::cbegin(indices_desc), std::end(indices_desc),",
          "new_line_content": "            auto it = std::find_if(",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": "Exception",
          "new_api": "std::cend(indices_desc)",
          "old_text": "Exception(\"Unknown index: \" + command.index_name, ErrorCodes::BAD_ARGUMENTS)",
          "new_text": "std::cend(indices_desc)",
          "old_line_content": "                throw Exception(\"Unknown index: \" + command.index_name, ErrorCodes::BAD_ARGUMENTS);",
          "new_line_content": "            if (it == std::cend(indices_desc))",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": "analyze",
          "new_api": "clone",
          "old_text": "TreeRewriter(context).analyze(query, all_columns)",
          "new_text": "*it).expression_list_ast->clone()",
          "old_line_content": "            auto syntax_result = TreeRewriter(context).analyze(query, all_columns);",
          "new_line_content": "            auto query = (*it).expression_list_ast->clone();",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": "requiredSourceColumns",
          "new_api": "analyze",
          "old_text": "syntax_result->requiredSourceColumns()",
          "new_text": "TreeRewriter(context).analyze(query, all_columns)",
          "old_line_content": "            const auto required_columns = syntax_result->requiredSourceColumns();",
          "new_line_content": "            auto syntax_result = TreeRewriter(context).analyze(query, all_columns);",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": "get",
          "new_api": "set",
          "old_text": "projections_desc.get(command.projection_name)",
          "new_text": "mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION)",
          "old_line_content": "            const auto & projection = projections_desc.get(command.projection_name);",
          "new_line_content": "            mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION);",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "erase",
          "new_api": "set",
          "old_text": "materialized_indices.erase(command.index_name)",
          "new_text": "mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION)",
          "old_line_content": "            materialized_indices.erase(command.index_name);",
          "new_line_content": "            mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION);",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "erase",
          "new_api": "set",
          "old_text": "materialized_projections.erase(command.projection_name)",
          "new_text": "mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION)",
          "old_line_content": "            materialized_projections.erase(command.projection_name);",
          "new_line_content": "            mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION);",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": "end",
          "new_api": "getNames",
          "old_text": "all_columns_vec.end()",
          "new_text": "all_columns.getNames()",
          "old_line_content": "                auto new_dependencies = metadata_snapshot->getColumnDependencies(NameSet(all_columns_vec.begin(), all_columns_vec.end()), false);",
          "new_line_content": "                auto all_columns_vec = all_columns.getNames();",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": "hasAnyRowsWhereTTL",
          "new_api": "hasRowsTTL",
          "old_text": "metadata_snapshot->hasAnyRowsWhereTTL()",
          "new_text": "metadata_snapshot->hasRowsTTL()",
          "old_line_content": "                || metadata_snapshot->hasAnyRowsWhereTTL()",
          "new_line_content": "            else if (metadata_snapshot->hasRowsTTL()",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": "hasAnyGroupByTTL",
          "new_api": "hasAnyRowsWhereTTL",
          "old_text": "metadata_snapshot->hasAnyGroupByTTL()",
          "new_text": "metadata_snapshot->hasAnyRowsWhereTTL()",
          "old_line_content": "                || metadata_snapshot->hasAnyGroupByTTL())",
          "new_line_content": "                || metadata_snapshot->hasAnyRowsWhereTTL()",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": "insert",
          "new_api": "emplace",
          "old_text": "new_updated_columns.insert(elem.first)",
          "new_text": "dependencies.emplace(elem.first, ColumnDependency::TTL_TARGET)",
          "old_line_content": "                    new_updated_columns.insert(elem.first);",
          "new_line_content": "                    dependencies.emplace(elem.first, ColumnDependency::TTL_TARGET);",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": "end",
          "new_api": "getNames",
          "old_text": "all_columns_vec.end()",
          "new_text": "all_columns.getNames()",
          "old_line_content": "                auto all_dependencies = getAllColumnDependencies(metadata_snapshot, NameSet(all_columns_vec.begin(), all_columns_vec.end()));",
          "new_line_content": "                auto all_columns_vec = all_columns.getNames();",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": "back",
          "new_api": "set",
          "old_text": "stages.back().column_to_updated.empty()",
          "new_text": "mutation_kind.set(MutationKind::MUTATE_OTHER)",
          "old_line_content": "            if (stages.empty() || !stages.back().column_to_updated.empty())",
          "new_line_content": "            mutation_kind.set(MutationKind::MUTATE_OTHER);",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": "insert",
          "new_api": "empty",
          "old_text": "unchanged_columns.insert(dependency.column_name)",
          "new_text": "dependencies.empty()",
          "old_line_content": "                unchanged_columns.insert(dependency.column_name);",
          "new_line_content": "    if (!dependencies.empty())",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": "back",
          "new_api": "insert",
          "old_text": "stages.back().column_to_updated.empty()",
          "new_text": "unchanged_columns.insert(dependency.column_name)",
          "old_line_content": "            if (stages.empty() || !stages.back().column_to_updated.empty())",
          "new_line_content": "                unchanged_columns.insert(dependency.column_name);",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "size",
          "new_api": "insert",
          "old_text": "stages.size()",
          "new_text": "changed_columns.insert(dependency.column_name)",
          "old_line_content": "            if (stages.size() == 1) /// First stage only supports filtering and can't update columns.",
          "new_line_content": "                changed_columns.insert(dependency.column_name);",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": "std::make_shared<ASTIdentifier>(column)",
          "new_api": "back",
          "old_text": "std::make_shared<ASTIdentifier>(column)",
          "new_text": "stages.back().column_to_updated.empty()",
          "old_line_content": "                    column, std::make_shared<ASTIdentifier>(column));",
          "new_line_content": "            if (stages.empty() || !stages.back().column_to_updated.empty())",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": "empty",
          "new_api": "emplace_back",
          "old_text": "unchanged_columns.empty()",
          "new_text": "stages.emplace_back(context)",
          "old_line_content": "        if (!unchanged_columns.empty())",
          "new_line_content": "                stages.emplace_back(context);",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": "back",
          "new_api": "empty",
          "old_text": "stages_copy.back()",
          "new_text": "stages.empty()",
          "old_line_content": "                    stages_copy.back().column_to_updated = stage.column_to_updated;",
          "new_line_content": "            if (!stages.empty())",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": "analyze",
          "new_api": "back",
          "old_text": "SelectQueryOptions().analyze(/* dry_run = */ false).ignoreLimits().ignoreProjections()",
          "new_text": "stages_copy.back()",
          "old_line_content": "                    SelectQueryOptions().analyze(/* dry_run = */ false).ignoreLimits().ignoreProjections()};",
          "new_line_content": "                    stages_copy.back().output_columns = stage.output_columns;",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": "std::make_shared<NullSource>(first_stage_header)",
          "new_api": "prepareInterpreterSelectQuery",
          "old_text": "std::make_shared<NullSource>(first_stage_header)",
          "new_text": "prepareInterpreterSelectQuery(stages_copy, /* dry_run = */ true)",
          "old_line_content": "                auto source = std::make_shared<NullSource>(first_stage_header);",
          "new_line_content": "                const ASTPtr select_query = prepareInterpreterSelectQuery(stages_copy, /* dry_run = */ true);",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": "getHeader",
          "new_api": "analyze",
          "old_text": "pipeline.getHeader()",
          "new_text": "SelectQueryOptions().analyze(/* dry_run = */ false).ignoreLimits().ignoreProjections()",
          "old_line_content": "                updated_header = std::make_unique<Block>(pipeline.getHeader());",
          "new_line_content": "                    SelectQueryOptions().analyze(/* dry_run = */ false).ignoreLimits().ignoreProjections()};",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "emplace_back",
          "new_api": "std::make_shared<NullSource>(first_stage_header)",
          "old_text": "stages.emplace_back(context)",
          "new_text": "std::make_shared<NullSource>(first_stage_header)",
          "old_line_content": "            stages.emplace_back(context);",
          "new_line_content": "                auto source = std::make_shared<NullSource>(first_stage_header);",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": "back",
          "new_api": "addStreamsForLaterStages",
          "old_text": "stages.back().column_to_updated.emplace(\n                    column, std::make_shared<ASTIdentifier>(column))",
          "new_text": "addStreamsForLaterStages(stages_copy, plan)",
          "old_line_content": "                stages.back().column_to_updated.emplace(",
          "new_line_content": "                auto pipeline = addStreamsForLaterStages(stages_copy, plan);",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": "std::make_shared<ASTIdentifier>(column)",
          "new_api": "getHeader",
          "old_text": "std::make_shared<ASTIdentifier>(column)",
          "new_text": "pipeline.getHeader()",
          "old_line_content": "                    column, std::make_shared<ASTIdentifier>(column));",
          "new_line_content": "                updated_header = std::make_unique<Block>(pipeline.getHeader());",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "prepareInterpreterSelectQuery",
          "new_api": "back",
          "old_text": "prepareInterpreterSelectQuery(stages, dry_run)",
          "new_text": "stages.back().column_to_updated.emplace(\n                    column, std::make_shared<ASTIdentifier>(column))",
          "old_line_content": "    return prepareInterpreterSelectQuery(stages, dry_run);",
          "new_line_content": "                stages.back().column_to_updated.emplace(",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": "getColumns",
          "new_api": "prepareInterpreterSelectQuery",
          "old_text": "storage_snapshot->getColumns(options)",
          "new_text": "prepareInterpreterSelectQuery(stages, dry_run)",
          "old_line_content": "    auto all_columns = storage_snapshot->getColumns(options);",
          "new_line_content": "    return prepareInterpreterSelectQuery(stages, dry_run);",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "hasLightweightDeletedMask",
          "new_api": "getStorageSnapshot",
          "old_text": "part_storage->hasLightweightDeletedMask()",
          "new_text": "storage->getStorageSnapshot(metadata_snapshot, context)",
          "old_line_content": "        if (part_storage->hasLightweightDeletedMask())",
          "new_line_content": "    auto storage_snapshot = storage->getStorageSnapshot(metadata_snapshot, context);",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "push_back",
          "new_api": "withExtendedObjects",
          "old_text": "all_columns.push_back({LightweightDeleteDescription::FILTER_COLUMN})",
          "new_text": "GetColumnsOptions(GetColumnsOptions::AllPhysical).withExtendedObjects()",
          "old_line_content": "            all_columns.push_back({LightweightDeleteDescription::FILTER_COLUMN});",
          "new_line_content": "    auto options = GetColumnsOptions(GetColumnsOptions::AllPhysical).withExtendedObjects();",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "size",
          "new_api": "dynamic_pointer_cast<DB::StorageFromMergeTreeDataPart>(storage)",
          "old_text": "prepared_stages.size()",
          "new_text": "dynamic_pointer_cast<DB::StorageFromMergeTreeDataPart>(storage)",
          "old_line_content": "    for (size_t i = 0; i < prepared_stages.size(); ++i)",
          "new_line_content": "    if (auto part_storage = dynamic_pointer_cast<DB::StorageFromMergeTreeDataPart>(storage))",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": "empty",
          "new_api": "hasLightweightDeletedMask",
          "old_text": "prepared_stages[i].filters.empty()",
          "new_text": "part_storage->hasLightweightDeletedMask()",
          "old_line_content": "        if (return_all_columns || !prepared_stages[i].filters.empty())",
          "new_line_content": "        if (part_storage->hasLightweightDeletedMask())",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "push_back",
          "new_api": "size",
          "old_text": "all_asts->children.push_back(ast)",
          "new_text": "prepared_stages.size()",
          "old_line_content": "            all_asts->children.push_back(ast);",
          "new_line_content": "    for (size_t i = prepared_stages.size() - 1; i > 0; --i)",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": "std::make_shared<ASTIdentifier>(column)",
          "new_api": "push_back",
          "old_text": "std::make_shared<ASTIdentifier>(column)",
          "new_text": "all_asts->children.push_back(ast)",
          "old_line_content": "            all_asts->children.push_back(std::make_shared<ASTIdentifier>(column));",
          "new_line_content": "            all_asts->children.push_back(ast);",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": "addStep",
          "new_api": "std::make_unique<ExpressionAnalyzer>(all_asts, syntax_result, context)",
          "old_text": "actions_chain.addStep()",
          "new_text": "std::make_unique<ExpressionAnalyzer>(all_asts, syntax_result, context)",
          "old_line_content": "                actions_chain.addStep();",
          "new_line_content": "        stage.analyzer = std::make_unique<ExpressionAnalyzer>(all_asts, syntax_result, context);",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": "empty",
          "new_api": "addStep",
          "old_text": "actions_chain.steps.empty()",
          "new_text": "actions_chain.addStep()",
          "old_line_content": "            if (!actions_chain.steps.empty())",
          "new_line_content": "                actions_chain.addStep();",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": "addStep",
          "new_api": "appendExpression",
          "old_text": "actions_chain.addStep()",
          "new_text": "stage.analyzer->appendExpression(actions_chain, ast, dry_run)",
          "old_line_content": "                actions_chain.addStep();",
          "new_line_content": "            stage.analyzer->appendExpression(actions_chain, ast, dry_run);",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "findInOutputs",
          "new_api": "appendExpression",
          "old_text": "actions->findInOutputs(column_name)",
          "new_text": "stage.analyzer->appendExpression(actions_chain, kv.second, dry_run)",
          "old_line_content": "                const auto & dag_node = actions->findInOutputs(column_name);",
          "new_line_content": "                stage.analyzer->appendExpression(actions_chain, kv.second, dry_run);",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "addOrReplaceInOutputs",
          "new_api": "getLastStep",
          "old_text": "actions->addOrReplaceInOutputs(alias)",
          "new_text": "actions_chain.getLastStep().actions()",
          "old_line_content": "                actions->addOrReplaceInOutputs(alias);",
          "new_line_content": "            auto & actions = actions_chain.getLastStep().actions();",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": "addStep",
          "new_api": "findInOutputs",
          "old_text": "actions_chain.addStep()",
          "new_text": "actions->findInOutputs(column_name)",
          "old_line_content": "        actions_chain.addStep();",
          "new_line_content": "                const auto & dag_node = actions->findInOutputs(column_name);",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "getLastStep",
          "new_api": "addAlias",
          "old_text": "actions_chain.getLastStep().required_output.clear()",
          "new_text": "actions->addAlias(dag_node, kv.first)",
          "old_line_content": "        actions_chain.getLastStep().required_output.clear();",
          "new_line_content": "                const auto & alias = actions->addAlias(dag_node, kv.first);",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": "finalize",
          "new_api": "getLastStep",
          "old_text": "actions_chain.finalize()",
          "new_text": "actions_chain.getLastStep().required_output.clear()",
          "old_line_content": "        actions_chain.finalize();",
          "new_line_content": "        actions_chain.getLastStep().required_output.clear();",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": "front",
          "new_api": "getLastStep",
          "old_text": "actions_chain.steps.front()->getRequiredColumns()",
          "new_text": "actions_chain.getLastStep().addRequiredOutput(name)",
          "old_line_content": "        for (const auto & column : actions_chain.steps.front()->getRequiredColumns())",
          "new_line_content": "            actions_chain.getLastStep().addRequiredOutput(name);",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": "std::make_shared<ASTExpressionList>()",
          "new_api": "insert",
          "old_text": "std::make_shared<ASTExpressionList>()",
          "new_text": "prepared_stages[i - 1].output_columns.insert(column.name)",
          "old_line_content": "    select->setExpression(ASTSelectQuery::Expression::SELECT, std::make_shared<ASTExpressionList>());",
          "new_line_content": "            prepared_stages[i - 1].output_columns.insert(column.name);",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "empty",
          "new_api": "std::make_shared<ASTSelectQuery>()",
          "old_text": "select->select()->children.empty()",
          "new_text": "std::make_shared<ASTSelectQuery>()",
          "old_line_content": "    if (select->select()->children.empty())",
          "new_line_content": "    auto select = std::make_shared<ASTSelectQuery>();",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": "std::make_shared<ASTFunction>()",
          "new_api": "empty",
          "old_text": "std::make_shared<ASTFunction>()",
          "new_text": "prepared_stages[0].filters.empty()",
          "old_line_content": "            auto coalesced_predicates = std::make_shared<ASTFunction>();",
          "new_line_content": "    if (!prepared_stages[0].filters.empty())",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": "push_back",
          "new_api": "size",
          "old_text": "coalesced_predicates->children.push_back(coalesced_predicates->arguments)",
          "new_text": "prepared_stages[0].filters.size()",
          "old_line_content": "            coalesced_predicates->children.push_back(coalesced_predicates->arguments);",
          "new_line_content": "        if (prepared_stages[0].filters.size() == 1)",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "std::move(where_expression)",
          "new_api": "std::make_shared<ASTFunction>()",
          "old_text": "std::move(where_expression)",
          "new_text": "std::make_shared<ASTFunction>()",
          "old_line_content": "        select->setExpression(ASTSelectQuery::Expression::WHERE, std::move(where_expression));",
          "new_line_content": "            auto coalesced_predicates = std::make_shared<ASTFunction>();",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": "buildQueryPlan",
          "new_api": "Exception",
          "old_text": "select_interpreter->buildQueryPlan(plan)",
          "new_text": "Exception(ErrorCodes::BAD_ARGUMENTS,\n                    \"ALTER UPDATE/ALTER DELETE statements must use only deterministic functions. \"\n                    \"Function '{}' is non-deterministic\", *nondeterministic_func_data.nondeterministic_function_name)",
          "old_line_content": "    select_interpreter->buildQueryPlan(plan);",
          "new_line_content": "                throw Exception(ErrorCodes::BAD_ARGUMENTS,",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": "Exception",
          "new_api": "buildQueryPlan",
          "old_text": "Exception(\"Cannot execute mutations interpreter because can_execute flag set to false\", ErrorCodes::LOGICAL_ERROR)",
          "new_text": "select_interpreter->buildQueryPlan(plan)",
          "old_line_content": "        throw Exception(\"Cannot execute mutations interpreter because can_execute flag set to false\", ErrorCodes::LOGICAL_ERROR);",
          "new_line_content": "    select_interpreter->buildQueryPlan(plan);",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": "Context::createCopy(context)",
          "new_api": "Exception",
          "old_text": "Context::createCopy(context)",
          "new_text": "Exception(\"Cannot execute mutations interpreter because can_execute flag set to false\", ErrorCodes::LOGICAL_ERROR)",
          "old_line_content": "            auto context_for_reading = Context::createCopy(context);",
          "new_line_content": "        throw Exception(\"Cannot execute mutations interpreter because can_execute flag set to false\", ErrorCodes::LOGICAL_ERROR);",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": "addStreamsForLaterStages",
          "new_api": "std::make_unique<InterpreterSelectQuery>(mutation_ast, context, storage, metadata_snapshot, select_limits)",
          "old_text": "addStreamsForLaterStages(stages, plan)",
          "new_text": "std::make_unique<InterpreterSelectQuery>(mutation_ast, context, storage, metadata_snapshot, select_limits)",
          "old_line_content": "    auto builder = addStreamsForLaterStages(stages, plan);",
          "new_line_content": "            select_interpreter = std::make_unique<InterpreterSelectQuery>(mutation_ast, context, storage, metadata_snapshot, select_limits);",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": "getHeader",
          "new_api": "addSimpleTransform",
          "old_text": "builder.getHeader()",
          "new_text": "builder.addSimpleTransform([&](const Block & header)\n        {\n            return std::make_shared<CheckSortedTransform>(header, *sort_desc);\n        })",
          "old_line_content": "        updated_header = std::make_unique<Block>(builder.getHeader());",
          "new_line_content": "        builder.addSimpleTransform([&](const Block & header)",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": "getSortingKeyColumns",
          "new_api": "size",
          "old_text": "metadata_snapshot->getSortingKeyColumns()",
          "new_text": "mutation_ast->size()",
          "old_line_content": "    Names sort_columns = metadata_snapshot->getSortingKeyColumns();",
          "new_line_content": "            return mutation_ast->size();",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": "has",
          "new_api": "getSortingKeyColumns",
          "old_text": "header.has(sort_columns[i])",
          "new_text": "metadata_snapshot->getSortingKeyColumns()",
          "old_line_content": "        if (header.has(sort_columns[i]))",
          "new_line_content": "    Names sort_columns = metadata_snapshot->getSortingKeyColumns();",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": "contains",
          "new_api": "DB::getPartitionAndPredicateExpressionForMutationCommand(command, storage, context)",
          "old_text": "output_columns.contains(storage_column)",
          "new_text": "DB::getPartitionAndPredicateExpressionForMutationCommand(command, storage, context)",
          "old_line_content": "        if (!output_columns.contains(storage_column))",
          "new_line_content": "    return DB::getPartitionAndPredicateExpressionForMutationCommand(command, storage, context);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1024,
          "old_api": null,
          "new_api": "buildQueryPlan",
          "old_text": null,
          "new_text": "select_interpreter->buildQueryPlan(plan)",
          "old_line_content": "    {",
          "new_line_content": "    select_interpreter->buildQueryPlan(plan);",
          "content_same": false
        },
        {
          "line": 514,
          "old_api": null,
          "new_api": "emplace",
          "old_text": null,
          "new_text": "affected_materialized.emplace(mat_column)",
          "old_line_content": "                }",
          "new_line_content": "                        affected_materialized.emplace(mat_column);",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": null,
          "new_api": "addStreamsForLaterStages",
          "old_text": null,
          "new_text": "addStreamsForLaterStages(stages, plan)",
          "old_line_content": "        {",
          "new_line_content": "    auto builder = addStreamsForLaterStages(stages, plan);",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": null,
          "new_api": "getHeader",
          "old_text": null,
          "new_text": "builder.getHeader()",
          "old_line_content": "",
          "new_line_content": "    if (auto sort_desc = getStorageSortDescriptionIfPossible(builder.getHeader()))",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": null,
          "new_api": "std::make_shared<CheckSortedTransform>(header, *sort_desc)",
          "old_text": null,
          "new_text": "std::make_shared<CheckSortedTransform>(header, *sort_desc)",
          "old_line_content": "    return builder;",
          "new_line_content": "            return std::make_shared<CheckSortedTransform>(header, *sort_desc);",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": null,
          "new_api": "getHeader",
          "old_text": null,
          "new_text": "builder.getHeader()",
          "old_line_content": "    // If it's an index/projection materialization, we don't write any data columns, thus empty header is used",
          "new_line_content": "        updated_header = std::make_unique<Block>(builder.getHeader());",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": null,
          "new_api": "tryGetPhysical",
          "old_text": null,
          "new_text": "columns_desc.tryGetPhysical(column)",
          "old_line_content": "                    type = physical_column->type;",
          "new_line_content": "                if (auto physical_column = columns_desc.tryGetPhysical(column))",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::LOGICAL_ERROR, \"Unknown column {}\", column)",
          "old_line_content": "",
          "new_line_content": "                    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unknown column {}\", column);",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "type->getName()",
          "old_line_content": "",
          "new_line_content": "                auto type_literal = std::make_shared<ASTLiteral>(type->getName());",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": null,
          "new_api": "getPartitionAndPredicateExpressionForMutationCommand",
          "old_text": null,
          "new_text": "getPartitionAndPredicateExpressionForMutationCommand(command)",
          "old_line_content": "",
          "new_line_content": "                ASTPtr condition = getPartitionAndPredicateExpressionForMutationCommand(command);",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "Nested::splitName(column).second.empty()",
          "old_line_content": "                {",
          "new_line_content": "                if (isArray(type) && !Nested::splitName(column).second.empty())",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": null,
          "new_api": "getExpressionsOfUpdatedNestedSubcolumns",
          "old_text": null,
          "new_text": "getExpressionsOfUpdatedNestedSubcolumns(column, all_columns, command.column_to_update_expression)",
          "old_line_content": "                    if (!nested_update_exprs)",
          "new_line_content": "                    auto nested_update_exprs = getExpressionsOfUpdatedNestedSubcolumns(column, all_columns, command.column_to_update_expression);",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": null,
          "new_api": "unlikely",
          "old_text": null,
          "new_text": "unlikely(!command.predicate && !command.partition)",
          "old_line_content": "{",
          "new_line_content": "        if (unlikely(!command.predicate && !command.partition)) /// The command touches all rows.",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": null,
          "new_api": "clone",
          "old_text": null,
          "new_text": "makeASTFunction(\"validateNestedArraySizes\",\n                            condition,\n                            update_expr->clone(),\n                            std::make_shared<ASTIdentifier>(column))",
          "old_line_content": "                            condition,",
          "new_line_content": "                        function = makeASTFunction(\"validateNestedArraySizes\",",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": null,
          "new_api": "makeASTFunction",
          "old_text": null,
          "new_text": "makeASTFunction(\"and\", condition, function)",
          "old_line_content": "                    }",
          "new_line_content": "                        condition = makeASTFunction(\"and\", condition, function);",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "nested_update_exprs->size()",
          "old_line_content": "                    {",
          "new_line_content": "                    else if (nested_update_exprs->size() > 1)",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "sort_columns.size()",
          "old_line_content": "        else",
          "new_line_content": "    size_t sort_columns_size = sort_columns.size();",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": null,
          "new_api": "std::make_shared<ASTFunction>()",
          "old_text": null,
          "new_text": "std::make_shared<ASTFunction>()",
          "old_line_content": "                        function->name = \"validateNestedArraySizes\";",
          "new_line_content": "                        function = std::make_shared<ASTFunction>();",
          "content_same": false
        },
        {
          "line": 1069,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "sort_description.reserve(sort_columns_size)",
          "old_line_content": "            return {};",
          "new_line_content": "    sort_description.reserve(sort_columns_size);",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "function->arguments->children.push_back(condition)",
          "old_line_content": "                        for (const auto & it : *nested_update_exprs)",
          "new_line_content": "                        function->arguments->children.push_back(condition);",
          "content_same": false
        },
        {
          "line": 1073,
          "old_api": null,
          "new_api": "has",
          "old_text": null,
          "new_text": "header.has(sort_columns[i])",
          "old_line_content": "}",
          "new_line_content": "        if (header.has(sort_columns[i]))",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "sort_description.emplace_back(sort_columns[i], 1, 1)",
          "old_line_content": "",
          "new_line_content": "            sort_description.emplace_back(sort_columns[i], 1, 1);",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": null,
          "new_api": "makeASTFunction",
          "old_text": null,
          "new_text": "makeASTFunction(\"and\", condition, function)",
          "old_line_content": "                    }",
          "new_line_content": "                        condition = makeASTFunction(\"and\", condition, function);",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": null,
          "new_api": "clone",
          "old_text": null,
          "new_text": "makeASTFunction(\"if\",\n                        condition,\n                        makeASTFunction(\"_CAST\",\n                            update_expr->clone(),\n                            type_literal),\n                        std::make_shared<ASTIdentifier>(column))",
          "old_line_content": "                        condition,",
          "new_line_content": "                    makeASTFunction(\"if\",",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "clone",
          "old_text": null,
          "new_text": "update_expr->clone()",
          "old_line_content": "                            type_literal),",
          "new_line_content": "                            update_expr->clone(),",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": null,
          "new_api": "std::make_shared<ASTIdentifier>(column)",
          "old_text": null,
          "new_text": "std::make_shared<ASTIdentifier>(column)",
          "old_line_content": "                    type_literal);",
          "new_line_content": "                        std::make_shared<ASTIdentifier>(column)),",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "stages.back().column_to_updated.emplace(column, updated_column)",
          "old_line_content": "            }",
          "new_line_content": "                stages.back().column_to_updated.emplace(column, updated_column);",
          "content_same": false
        },
        {
          "line": 1091,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "output_columns.contains(storage_column)",
          "old_line_content": "{",
          "new_line_content": "        if (!output_columns.contains(storage_column))",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "affected_materialized.empty()",
          "old_line_content": "            {",
          "new_line_content": "            if (!affected_materialized.empty())",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "stages.emplace_back(context)",
          "old_line_content": "                for (const auto & column : columns_desc)",
          "new_line_content": "                stages.emplace_back(context);",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "stages.back().column_to_updated.emplace(\n                            column.name,\n                            column.default_desc.expression->clone())",
          "old_line_content": "                            column.name,",
          "new_line_content": "                        stages.back().column_to_updated.emplace(",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": null,
          "new_api": "getNamesOfPhysical",
          "old_text": null,
          "new_text": "metadata_snapshot->getColumns().getNamesOfPhysical()",
          "old_line_content": "void MutationsInterpreter::MutationKind::set(const MutationKindEnum & kind)",
          "new_line_content": "    auto storage_columns = metadata_snapshot->getColumns().getNamesOfPhysical();",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": null,
          "new_api": "clone",
          "old_text": null,
          "new_text": "column.default_desc.expression->clone()",
          "old_line_content": "                    }",
          "new_line_content": "                            column.default_desc.expression->clone());",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "stages.empty()",
          "old_line_content": "{",
          "new_line_content": "    if (stages.empty())",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::LOGICAL_ERROR, \"Mutation interpreter has no stages\")",
          "old_line_content": "    if (mutation_kind < kind)",
          "new_line_content": "        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Mutation interpreter has no stages\");",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "stages.back().isAffectingAllColumns(storage_columns)",
          "old_line_content": "}",
          "new_line_content": "    return stages.back().isAffectingAllColumns(storage_columns);",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "stages.emplace_back(context)",
          "old_line_content": "",
          "new_line_content": "                stages.emplace_back(context);",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "columns_desc.get(command.column_name)",
          "old_line_content": "",
          "new_line_content": "            const auto & column = columns_desc.get(command.column_name);",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\n                    ErrorCodes::BAD_ARGUMENTS,\n                    \"Cannot materialize column `{}` because it doesn't have default expression\", column.name)",
          "old_line_content": "                    ErrorCodes::BAD_ARGUMENTS,",
          "new_line_content": "                throw Exception(",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "column.type->getName()",
          "old_line_content": "",
          "new_line_content": "                \"_CAST\", column.default_desc.expression->clone(), std::make_shared<ASTLiteral>(column.type->getName()));",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "stages.back().column_to_updated.emplace(column.name, materialized_column)",
          "old_line_content": "        }",
          "new_line_content": "            stages.back().column_to_updated.emplace(column.name, materialized_column);",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": null,
          "new_api": "std::end(indices_desc)",
          "old_text": null,
          "new_text": "std::end(indices_desc)",
          "old_line_content": "                    [&](const IndexDescription & index)",
          "new_line_content": "                    std::cbegin(indices_desc), std::end(indices_desc),",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Unknown index: \" + command.index_name, ErrorCodes::BAD_ARGUMENTS)",
          "old_line_content": "",
          "new_line_content": "                throw Exception(\"Unknown index: \" + command.index_name, ErrorCodes::BAD_ARGUMENTS);",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": null,
          "new_api": "requiredSourceColumns",
          "old_text": null,
          "new_text": "syntax_result->requiredSourceColumns()",
          "old_line_content": "            for (const auto & column : required_columns)",
          "new_line_content": "            const auto required_columns = syntax_result->requiredSourceColumns();",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": null,
          "new_api": "emplace",
          "old_text": null,
          "new_text": "materialized_indices.emplace(command.index_name)",
          "old_line_content": "        }",
          "new_line_content": "            materialized_indices.emplace(command.index_name);",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "projections_desc.get(command.projection_name)",
          "old_line_content": "            for (const auto & column : projection.required_columns)",
          "new_line_content": "            const auto & projection = projections_desc.get(command.projection_name);",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": null,
          "new_api": "emplace",
          "old_text": null,
          "new_text": "materialized_projections.emplace(command.projection_name)",
          "old_line_content": "        }",
          "new_line_content": "            materialized_projections.emplace(command.projection_name);",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "materialized_indices.erase(command.index_name)",
          "old_line_content": "        }",
          "new_line_content": "            materialized_indices.erase(command.index_name);",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "materialized_projections.erase(command.projection_name)",
          "old_line_content": "        }",
          "new_line_content": "            materialized_projections.erase(command.projection_name);",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "mutation_kind.set(MutationKind::MUTATE_OTHER)",
          "old_line_content": "            if (materialize_ttl_recalculate_only)",
          "new_line_content": "            mutation_kind.set(MutationKind::MUTATE_OTHER);",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "all_columns_vec.end()",
          "old_line_content": "                for (const auto & dependency : new_dependencies)",
          "new_line_content": "                auto new_dependencies = metadata_snapshot->getColumnDependencies(NameSet(all_columns_vec.begin(), all_columns_vec.end()), false);",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "dependencies.insert(dependency)",
          "old_line_content": "                }",
          "new_line_content": "                        dependencies.insert(dependency);",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": null,
          "new_api": "hasAnyGroupByTTL",
          "old_text": null,
          "new_text": "metadata_snapshot->hasAnyGroupByTTL()",
          "old_line_content": "            {",
          "new_line_content": "                || metadata_snapshot->hasAnyGroupByTTL())",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": null,
          "new_api": "emplace",
          "old_text": null,
          "new_text": "dependencies.emplace(column.name, ColumnDependency::TTL_TARGET)",
          "old_line_content": "            }",
          "new_line_content": "                    dependencies.emplace(column.name, ColumnDependency::TTL_TARGET);",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": null,
          "new_api": "getColumnTTLs",
          "old_text": null,
          "new_text": "metadata_snapshot->getColumns().getColumnTTLs()",
          "old_line_content": "                for (const auto & elem : column_ttls)",
          "new_line_content": "                auto column_ttls = metadata_snapshot->getColumns().getColumnTTLs();",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "new_updated_columns.insert(elem.first)",
          "old_line_content": "                }",
          "new_line_content": "                    new_updated_columns.insert(elem.first);",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "all_columns_vec.end()",
          "old_line_content": "",
          "new_line_content": "                auto all_dependencies = getAllColumnDependencies(metadata_snapshot, NameSet(all_columns_vec.begin(), all_columns_vec.end()));",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "dependencies.insert(dependency)",
          "old_line_content": "                }",
          "new_line_content": "                        dependencies.insert(dependency);",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": null,
          "new_api": "getColumnDependencies",
          "old_text": null,
          "new_text": "metadata_snapshot->getColumnDependencies(new_updated_columns, true)",
          "old_line_content": "                for (const auto & dependency : new_dependencies)",
          "new_line_content": "                auto new_dependencies = metadata_snapshot->getColumnDependencies(new_updated_columns, true);",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "dependencies.insert(dependency)",
          "old_line_content": "                }",
          "new_line_content": "                        dependencies.insert(dependency);",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "dependencies.empty()",
          "old_line_content": "            {",
          "new_line_content": "            if (dependencies.empty())",
          "content_same": false
        },
        {
          "line": 704,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "all_columns.front()",
          "old_line_content": "            }",
          "new_line_content": "                dependencies.emplace(all_columns.front().name, ColumnDependency::TTL_EXPRESSION);",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": null,
          "new_api": "DB::toString<int>(command.type)",
          "old_text": null,
          "new_text": "DB::toString<int>(command.type)",
          "old_line_content": "",
          "new_line_content": "            throw Exception(\"Unknown mutation command type: \" + DB::toString<int>(command.type), ErrorCodes::UNKNOWN_MUTATION_COMMAND);",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "read_columns.empty()",
          "old_line_content": "        else",
          "new_line_content": "    if (!read_columns.empty())",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "stages.back().column_to_updated.empty()",
          "old_line_content": "    }",
          "new_line_content": "        if (stages.empty() || !stages.back().column_to_updated.empty())",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "stages.emplace_back(context)",
          "old_line_content": "",
          "new_line_content": "            stages.emplace_back(context);",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "stages.size()",
          "old_line_content": "    /// We care about affected indices and projections because we also need to rewrite them",
          "new_line_content": "        if (stages.size() == 1) /// First stage only supports filtering and can't update columns.",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "stages.emplace_back(context)",
          "old_line_content": "    /// when one of index columns updated or filtered with delete.",
          "new_line_content": "            stages.emplace_back(context);",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": null,
          "new_api": "std::make_shared<ASTIdentifier>(column_name)",
          "old_text": null,
          "new_text": "std::make_shared<ASTIdentifier>(column_name)",
          "old_line_content": "    {",
          "new_line_content": "            stages.back().column_to_updated.emplace(column_name, std::make_shared<ASTIdentifier>(column_name));",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": null,
          "new_api": "isReadOnly",
          "old_text": null,
          "new_text": "dependency.isReadOnly()",
          "old_line_content": "        {",
          "new_line_content": "            if (dependency.isReadOnly())",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "changed_columns.empty()",
          "old_line_content": "            for (const auto & column : changed_columns)",
          "new_line_content": "        if (!changed_columns.empty())",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "stages.emplace_back(context)",
          "old_line_content": "        }",
          "new_line_content": "                stages.emplace_back(context);",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "stages.size()",
          "old_line_content": "",
          "new_line_content": "            if (stages.size() == 1) /// First stage only supports filtering and can't update columns.",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "stages.back().column_to_updated.emplace(\n                    column, std::make_shared<ASTIdentifier>(column))",
          "old_line_content": "            {",
          "new_line_content": "                stages.back().column_to_updated.emplace(",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": null,
          "new_api": "std::make_shared<ASTIdentifier>(column)",
          "old_text": null,
          "new_text": "std::make_shared<ASTIdentifier>(column)",
          "old_line_content": "                std::vector<Stage> stages_copy;",
          "new_line_content": "                    column, std::make_shared<ASTIdentifier>(column));",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "unchanged_columns.empty()",
          "old_line_content": "                {",
          "new_line_content": "        if (!unchanged_columns.empty())",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "stages_copy.emplace_back(context)",
          "old_line_content": "                InterpreterSelectQuery interpreter{",
          "new_line_content": "                    stages_copy.emplace_back(context);",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "stages_copy.back()",
          "old_line_content": "                    select_query, context, storage, metadata_snapshot,",
          "new_line_content": "                    stages_copy.back().column_to_updated = stage.column_to_updated;",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "stages_copy.back()",
          "old_line_content": "",
          "new_line_content": "                    stages_copy.back().filters = stage.filters;",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": null,
          "new_api": "getSampleBlock",
          "old_text": null,
          "new_text": "interpreter.getSampleBlock()",
          "old_line_content": "",
          "new_line_content": "                auto first_stage_header = interpreter.getSampleBlock();",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": null,
          "new_api": "std::move(source)",
          "old_text": null,
          "new_text": "std::move(source)",
          "old_line_content": "            for (const auto & column : unchanged_columns)",
          "new_line_content": "                plan.addStep(std::make_unique<ReadFromPreparedSource>(Pipe(std::move(source))));",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "stages.emplace_back(context)",
          "old_line_content": "    is_prepared = true;",
          "new_line_content": "            stages.emplace_back(context);",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": null,
          "new_api": "std::make_shared<ASTIdentifier>(column)",
          "old_text": null,
          "new_text": "std::make_shared<ASTIdentifier>(column)",
          "old_line_content": "}",
          "new_line_content": "                    column, std::make_shared<ASTIdentifier>(column));",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": null,
          "new_api": "getColumns",
          "old_text": null,
          "new_text": "storage_snapshot->getColumns(options)",
          "old_line_content": "    }",
          "new_line_content": "    auto all_columns = storage_snapshot->getColumns(options);",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "all_columns.push_back({LightweightDeleteDescription::FILTER_COLUMN})",
          "old_line_content": "        {",
          "new_line_content": "            all_columns.push_back({LightweightDeleteDescription::FILTER_COLUMN});",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "prepared_stages.size()",
          "old_line_content": "        }",
          "new_line_content": "    for (size_t i = 0; i < prepared_stages.size(); ++i)",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "prepared_stages[i].filters.empty()",
          "old_line_content": "        if (i > 0)",
          "new_line_content": "        if (return_all_columns || !prepared_stages[i].filters.empty())",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "prepared_stages[i].output_columns.insert(column.name)",
          "old_line_content": "        /// Make sure that all updated columns are included into output_columns set.",
          "new_line_content": "                prepared_stages[i].output_columns.insert(column.name);",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "prepared_stages[i].output_columns.insert(kv.first)",
          "old_line_content": "        auto & stage = prepared_stages[i];",
          "new_line_content": "            prepared_stages[i].output_columns.insert(kv.first);",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": null,
          "new_api": "std::make_shared<ASTExpressionList>()",
          "old_text": null,
          "new_text": "std::make_shared<ASTExpressionList>()",
          "old_line_content": "",
          "new_line_content": "        ASTPtr all_asts = std::make_shared<ASTExpressionList>();",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "all_asts->children.push_back(kv.second)",
          "old_line_content": "        /// e.g. ALTER referencing the same table in scalar subquery",
          "new_line_content": "            all_asts->children.push_back(kv.second);",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": null,
          "new_api": "std::make_shared<ASTIdentifier>(column)",
          "old_text": null,
          "new_text": "std::make_shared<ASTIdentifier>(column)",
          "old_line_content": "            false, true, execute_scalar_subqueries);",
          "new_line_content": "            all_asts->children.push_back(std::make_shared<ASTIdentifier>(column));",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": null,
          "new_api": "analyze",
          "old_text": null,
          "new_text": "TreeRewriter(context).analyze(\n            all_asts, all_columns, storage, storage_snapshot,\n            false, true, execute_scalar_subqueries)",
          "old_line_content": "",
          "new_line_content": "        auto syntax_result = TreeRewriter(context).analyze(",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": null,
          "new_api": "hasQueryContext",
          "old_text": null,
          "new_text": "context->hasQueryContext()",
          "old_line_content": "",
          "new_line_content": "        if (execute_scalar_subqueries && context->hasQueryContext())",
          "content_same": false
        },
        {
          "line": 853,
          "old_api": null,
          "new_api": "getScalars",
          "old_text": null,
          "new_text": "syntax_result->getScalars()",
          "old_line_content": "        for (const auto & ast : stage.filters)",
          "new_line_content": "            for (const auto & it : syntax_result->getScalars())",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": null,
          "new_api": "getQueryContext",
          "old_text": null,
          "new_text": "context->getQueryContext()->addScalar(it.first, it.second)",
          "old_line_content": "        {",
          "new_line_content": "                context->getQueryContext()->addScalar(it.first, it.second);",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "actions_chain.steps.empty()",
          "old_line_content": "        {",
          "new_line_content": "            if (!actions_chain.steps.empty())",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": null,
          "new_api": "getColumnName",
          "old_text": null,
          "new_text": "ast->getColumnName()",
          "old_line_content": "",
          "new_line_content": "            stage.filter_column_names.push_back(ast->getColumnName());",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "stage.column_to_updated.empty()",
          "old_line_content": "",
          "new_line_content": "        if (!stage.column_to_updated.empty())",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "actions_chain.steps.empty()",
          "old_line_content": "",
          "new_line_content": "            if (!actions_chain.steps.empty())",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": null,
          "new_api": "addStep",
          "old_text": null,
          "new_text": "actions_chain.addStep()",
          "old_line_content": "            for (const auto & kv : stage.column_to_updated)",
          "new_line_content": "                actions_chain.addStep();",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": null,
          "new_api": "getColumnName",
          "old_text": null,
          "new_text": "kv.second->getColumnName()",
          "old_line_content": "        /// Remove all intermediate columns.",
          "new_line_content": "                auto column_name = kv.second->getColumnName();",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": null,
          "new_api": "addOrReplaceInOutputs",
          "old_text": null,
          "new_text": "actions->addOrReplaceInOutputs(alias)",
          "old_line_content": "        ActionsDAG::NodeRawConstPtrs new_index;",
          "new_line_content": "                actions->addOrReplaceInOutputs(alias);",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": null,
          "new_api": "addStep",
          "old_text": null,
          "new_text": "actions_chain.addStep()",
          "old_line_content": "",
          "new_line_content": "        actions_chain.addStep();",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": null,
          "new_api": "getLastActions",
          "old_text": null,
          "new_text": "actions_chain.getLastActions()",
          "old_line_content": "    }",
          "new_line_content": "        actions_chain.getLastActions();",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": null,
          "new_api": "finalize",
          "old_text": null,
          "new_text": "actions_chain.finalize()",
          "old_line_content": "    /// Execute first stage as a SELECT statement.",
          "new_line_content": "        actions_chain.finalize();",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "actions_chain.steps.front()->getRequiredColumns()",
          "old_line_content": "",
          "new_line_content": "        for (const auto & column : actions_chain.steps.front()->getRequiredColumns())",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": null,
          "new_api": "std::make_shared<ASTExpressionList>()",
          "old_text": null,
          "new_text": "std::make_shared<ASTExpressionList>()",
          "old_line_content": "",
          "new_line_content": "    select->setExpression(ASTSelectQuery::Expression::SELECT, std::make_shared<ASTExpressionList>());",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": null,
          "new_api": "std::make_shared<ASTIdentifier>(column_name)",
          "old_text": null,
          "new_text": "std::make_shared<ASTIdentifier>(column_name)",
          "old_line_content": "    {",
          "new_line_content": "        select->select()->children.push_back(std::make_shared<ASTIdentifier>(column_name));",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "select->select()->children.empty()",
          "old_line_content": "            where_expression = prepared_stages[0].filters[0];",
          "new_line_content": "    if (select->select()->children.empty())",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": null,
          "new_api": "Field",
          "old_text": null,
          "new_text": "Field(0)",
          "old_line_content": "        else",
          "new_line_content": "        select->select()->children.push_back(std::make_shared<ASTLiteral>(Field(0)));",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": null,
          "new_api": "std::make_shared<ASTExpressionList>()",
          "old_text": null,
          "new_text": "std::make_shared<ASTExpressionList>()",
          "old_line_content": "",
          "new_line_content": "            coalesced_predicates->arguments = std::make_shared<ASTExpressionList>();",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "coalesced_predicates->children.push_back(coalesced_predicates->arguments)",
          "old_line_content": "    return select;",
          "new_line_content": "            coalesced_predicates->children.push_back(coalesced_predicates->arguments);",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": null,
          "new_api": "std::move(coalesced_predicates)",
          "old_text": null,
          "new_text": "std::move(coalesced_predicates)",
          "old_line_content": "",
          "new_line_content": "            where_expression = std::move(coalesced_predicates);",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": null,
          "new_api": "std::move(where_expression)",
          "old_text": null,
          "new_text": "std::move(where_expression)",
          "old_line_content": "{",
          "new_line_content": "        select->setExpression(ASTSelectQuery::Expression::WHERE, std::move(where_expression));",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "stage.expressions_chain.steps.size()",
          "old_line_content": "            }",
          "new_line_content": "        for (size_t i = 0; i < stage.expressions_chain.steps.size(); ++i)",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "stage.filter_column_names.size()",
          "old_line_content": "                /// Execute UPDATE or final projection.",
          "new_line_content": "            if (i < stage.filter_column_names.size())",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": null,
          "new_api": "actions",
          "old_text": null,
          "new_text": "step->actions()",
          "old_line_content": "        }",
          "new_line_content": "                plan.addStep(std::make_unique<FilterStep>(plan.getCurrentDataStream(), step->actions(), stage.filter_column_names[i], false));",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": null,
          "new_api": "actions",
          "old_text": null,
          "new_text": "step->actions()",
          "old_line_content": "    QueryPlanOptimizationSettings do_not_optimize_plan;",
          "new_line_content": "                plan.addStep(std::make_unique<ExpressionStep>(plan.getCurrentDataStream(), step->actions()));",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": null,
          "new_api": "getPreparedSets",
          "old_text": null,
          "new_text": "stage.analyzer->getPreparedSets()",
          "old_line_content": "        do_not_optimize_plan,",
          "new_line_content": "        addCreatingSetsStep(plan, stage.analyzer->getPreparedSets(), context);",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": null,
          "new_api": "buildQueryPipeline",
          "old_text": null,
          "new_text": "plan.buildQueryPipeline(\n        do_not_optimize_plan,\n        BuildQueryPipelineSettings::fromContext(context))",
          "old_line_content": "    });",
          "new_line_content": "    auto pipeline = std::move(*plan.buildQueryPipeline(",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": null,
          "new_api": "BuildQueryPipelineSettings::fromContext(context)",
          "old_text": null,
          "new_text": "BuildQueryPipelineSettings::fromContext(context)",
          "old_line_content": "    return pipeline;",
          "new_line_content": "        BuildQueryPipelineSettings::fromContext(context)));",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": null,
          "new_api": "addSimpleTransform",
          "old_text": null,
          "new_text": "pipeline.addSimpleTransform([&](const Block & header)\n    {\n        return std::make_shared<MaterializingTransform>(header);\n    })",
          "old_line_content": "",
          "new_line_content": "    pipeline.addSimpleTransform([&](const Block & header)",
          "content_same": false
        },
        {
          "line": 968,
          "old_api": null,
          "new_api": "std::make_shared<MaterializingTransform>(header)",
          "old_text": null,
          "new_text": "std::make_shared<MaterializingTransform>(header)",
          "old_line_content": "{",
          "new_line_content": "        return std::make_shared<MaterializingTransform>(header);",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": null,
          "new_api": "std::make_unique<InterpreterSelectQuery>(mutation_ast, context, storage, metadata_snapshot, select_limits)",
          "old_text": null,
          "new_text": "std::make_unique<InterpreterSelectQuery>(mutation_ast, context, storage, metadata_snapshot, select_limits)",
          "old_line_content": "    {",
          "new_line_content": "        select_interpreter = std::make_unique<InterpreterSelectQuery>(mutation_ast, context, storage, metadata_snapshot, select_limits);",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context->getSettingsRef()",
          "old_line_content": "        {",
          "new_line_content": "    const Settings & settings = context->getSettingsRef();",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "storage->getName()",
          "old_line_content": "                                                           \"see allow_nondeterministic_mutations setting\");",
          "new_line_content": "    if (startsWith(storage->getName(), \"Replicated\") && !settings.allow_nondeterministic_mutations)",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": null,
          "new_api": "findFirstNonDeterministicFunctionName",
          "old_text": null,
          "new_text": "findFirstNonDeterministicFunctionName(command, context)",
          "old_line_content": "                    \"ALTER UPDATE/ALTER DELETE statements must use only deterministic functions. \"",
          "new_line_content": "            const auto nondeterministic_func_data = findFirstNonDeterministicFunctionName(command, context);",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::BAD_ARGUMENTS, \"ALTER UPDATE/ALTER DELETE statement with subquery may be nondeterministic, \"\n                                                           \"see allow_nondeterministic_mutations setting\")",
          "old_line_content": "        }",
          "new_line_content": "                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"ALTER UPDATE/ALTER DELETE statement with subquery may be nondeterministic, \"",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(command.type == MutationCommand::DELETE || !return_deleted_rows)",
          "old_line_content": "",
          "new_line_content": "        assert(command.type == MutationCommand::DELETE || !return_deleted_rows);",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "stages.emplace_back(context)",
          "old_line_content": "",
          "new_line_content": "                stages.emplace_back(context);",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": null,
          "new_api": "getPartitionAndPredicateExpressionForMutationCommand",
          "old_text": null,
          "new_text": "getPartitionAndPredicateExpressionForMutationCommand(command)",
          "old_line_content": "",
          "new_line_content": "            auto predicate  = getPartitionAndPredicateExpressionForMutationCommand(command);",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": null,
          "new_api": "addStreamsForLaterStages",
          "old_text": null,
          "new_text": "addStreamsForLaterStages(stages, plan)",
          "old_line_content": "",
          "new_line_content": "    auto pipeline = addStreamsForLaterStages(stages, plan);",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": null,
          "new_api": "makeASTFunction",
          "old_text": null,
          "new_text": "makeASTFunction(\"isZeroOrNull\", predicate)",
          "old_line_content": "",
          "new_line_content": "                predicate = makeASTFunction(\"isZeroOrNull\", predicate);",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "stages.back().filters.push_back(predicate)",
          "old_line_content": "        }",
          "new_line_content": "            stages.back().filters.push_back(predicate);",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": null,
          "new_api": "setApplyDeletedMask",
          "old_text": null,
          "new_text": "context_for_reading->setApplyDeletedMask(apply_deleted_mask)",
          "old_line_content": "",
          "new_line_content": "            context_for_reading->setApplyDeletedMask(apply_deleted_mask);",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "stages.emplace_back(context)",
          "old_line_content": "",
          "new_line_content": "                stages.emplace_back(context);",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": null,
          "new_api": "Context::createCopy(context)",
          "old_text": null,
          "new_text": "Context::createCopy(context)",
          "old_line_content": "",
          "new_line_content": "            auto context_for_reading = Context::createCopy(context);",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": null,
          "new_api": "std::make_unique<InterpreterSelectQuery>(mutation_ast, context_for_reading, storage, metadata_snapshot, select_limits)",
          "old_text": null,
          "new_text": "std::make_unique<InterpreterSelectQuery>(mutation_ast, context_for_reading, storage, metadata_snapshot, select_limits)",
          "old_line_content": "    QueryPlan plan;",
          "new_line_content": "            select_interpreter = std::make_unique<InterpreterSelectQuery>(mutation_ast, context_for_reading, storage, metadata_snapshot, select_limits);",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "column_to_affected_materialized.end()",
          "old_line_content": "                {",
          "new_line_content": "                if (materialized_it != column_to_affected_materialized.end())",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 513,
          "old_api": "emplace",
          "new_api": null,
          "old_text": "affected_materialized.emplace(mat_column)",
          "new_text": null,
          "old_line_content": "                        affected_materialized.emplace(mat_column);",
          "new_line_content": "                    for (const String & mat_column : materialized_it->second)",
          "content_same": false
        },
        {
          "line": 1025,
          "old_api": "addSimpleTransform",
          "new_api": null,
          "old_text": "builder.addSimpleTransform([&](const Block & header)\n        {\n            return std::make_shared<CheckSortedTransform>(header, *sort_desc);\n        })",
          "new_text": null,
          "old_line_content": "        builder.addSimpleTransform([&](const Block & header)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": "std::make_shared<CheckSortedTransform>(header, *sort_desc)",
          "new_api": null,
          "old_text": "std::make_shared<CheckSortedTransform>(header, *sort_desc)",
          "new_text": null,
          "old_line_content": "            return std::make_shared<CheckSortedTransform>(header, *sort_desc);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": "tryGetPhysical",
          "new_api": null,
          "old_text": "columns_desc.tryGetPhysical(column)",
          "new_text": null,
          "old_line_content": "                if (auto physical_column = columns_desc.tryGetPhysical(column))",
          "new_line_content": "                DataTypePtr type;",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::LOGICAL_ERROR, \"Unknown column {}\", column)",
          "new_text": null,
          "old_line_content": "                    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unknown column {}\", column);",
          "new_line_content": "                else",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "getName",
          "new_api": null,
          "old_text": "type->getName()",
          "new_text": null,
          "old_line_content": "                auto type_literal = std::make_shared<ASTLiteral>(type->getName());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "getPartitionAndPredicateExpressionForMutationCommand",
          "new_api": null,
          "old_text": "getPartitionAndPredicateExpressionForMutationCommand(command)",
          "new_text": null,
          "old_line_content": "                ASTPtr condition = getPartitionAndPredicateExpressionForMutationCommand(command);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "unlikely",
          "new_api": null,
          "old_text": "unlikely(!command.predicate && !command.partition)",
          "new_text": null,
          "old_line_content": "        if (unlikely(!command.predicate && !command.partition)) /// The command touches all rows.",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": "size",
          "new_api": null,
          "old_text": "mutation_ast->size()",
          "new_text": null,
          "old_line_content": "            return mutation_ast->size();",
          "new_line_content": "    return dependencies;",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": "empty",
          "new_api": null,
          "old_text": "Nested::splitName(column).second.empty()",
          "new_text": null,
          "old_line_content": "                if (isArray(type) && !Nested::splitName(column).second.empty())",
          "new_line_content": "                /// And new check validateNestedArraySizes for Nested subcolumns",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": "size",
          "new_api": null,
          "old_text": "mutation_ast->size()",
          "new_text": null,
          "old_line_content": "    return std::max(prepareQueryAffectedAST(commands, storage, context)->size(), mutation_ast->size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "getExpressionsOfUpdatedNestedSubcolumns",
          "new_api": null,
          "old_text": "getExpressionsOfUpdatedNestedSubcolumns(column, all_columns, command.column_to_update_expression)",
          "new_text": null,
          "old_line_content": "                    auto nested_update_exprs = getExpressionsOfUpdatedNestedSubcolumns(column, all_columns, command.column_to_update_expression);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": "clone",
          "new_api": null,
          "old_text": "makeASTFunction(\"validateNestedArraySizes\",\n                            condition,\n                            update_expr->clone(),\n                            std::make_shared<ASTIdentifier>(column))",
          "new_text": null,
          "old_line_content": "                        function = makeASTFunction(\"validateNestedArraySizes\",",
          "new_line_content": "                    {",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": "clone",
          "new_api": null,
          "old_text": "update_expr->clone()",
          "new_text": null,
          "old_line_content": "                            update_expr->clone(),",
          "new_line_content": "                            condition,",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "sort_description.reserve(sort_columns_size)",
          "new_text": null,
          "old_line_content": "    sort_description.reserve(sort_columns_size);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": "size",
          "new_api": null,
          "old_text": "nested_update_exprs->size()",
          "new_text": null,
          "old_line_content": "                    else if (nested_update_exprs->size() > 1)",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "sort_description.emplace_back(sort_columns[i], 1, 1)",
          "new_text": null,
          "old_line_content": "            sort_description.emplace_back(sort_columns[i], 1, 1);",
          "new_line_content": "    SortDescription sort_description;",
          "content_same": false
        },
        {
          "line": 556,
          "old_api": "std::make_shared<ASTFunction>()",
          "new_api": null,
          "old_text": "std::make_shared<ASTFunction>()",
          "new_text": null,
          "old_line_content": "                        function = std::make_shared<ASTFunction>();",
          "new_line_content": "                    {",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": "std::make_shared<ASTExpressionList>()",
          "new_api": null,
          "old_text": "std::make_shared<ASTExpressionList>()",
          "new_text": null,
          "old_line_content": "                        function->arguments = std::make_shared<ASTExpressionList>();",
          "new_line_content": "                        function->name = \"validateNestedArraySizes\";",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": "clone",
          "new_api": null,
          "old_text": "it->clone()",
          "new_text": null,
          "old_line_content": "                            function->arguments->children.push_back(it->clone());",
          "new_line_content": "                        for (const auto & it : *nested_update_exprs)",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": "DB::getPartitionAndPredicateExpressionForMutationCommand(command, storage, context)",
          "new_api": null,
          "old_text": "DB::getPartitionAndPredicateExpressionForMutationCommand(command, storage, context)",
          "new_text": null,
          "old_line_content": "    return DB::getPartitionAndPredicateExpressionForMutationCommand(command, storage, context);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "clone",
          "new_api": null,
          "old_text": "makeASTFunction(\"_CAST\",\n                    makeASTFunction(\"if\",\n                        condition,\n                        makeASTFunction(\"_CAST\",\n                            update_expr->clone(),\n                            type_literal),\n                        std::make_shared<ASTIdentifier>(column)),\n                    type_literal)",
          "new_text": null,
          "old_line_content": "                auto updated_column = makeASTFunction(\"_CAST\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": "clone",
          "new_api": null,
          "old_text": "makeASTFunction(\"_CAST\",\n                            update_expr->clone(),\n                            type_literal)",
          "new_text": null,
          "old_line_content": "                        makeASTFunction(\"_CAST\",",
          "new_line_content": "                        condition,",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "std::make_shared<ASTIdentifier>(column)",
          "new_api": null,
          "old_text": "std::make_shared<ASTIdentifier>(column)",
          "new_text": null,
          "old_line_content": "                        std::make_shared<ASTIdentifier>(column)),",
          "new_line_content": "                            type_literal),",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "back",
          "new_api": null,
          "old_text": "stages.back().column_to_updated.emplace(column, updated_column)",
          "new_text": null,
          "old_line_content": "                stages.back().column_to_updated.emplace(column, updated_column);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": "empty",
          "new_api": null,
          "old_text": "affected_materialized.empty()",
          "new_text": null,
          "old_line_content": "            if (!affected_materialized.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": "getNamesOfPhysical",
          "new_api": null,
          "old_text": "metadata_snapshot->getColumns().getNamesOfPhysical()",
          "new_text": null,
          "old_line_content": "    auto storage_columns = metadata_snapshot->getColumns().getNamesOfPhysical();",
          "new_line_content": "            return false;",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "stages.emplace_back(context)",
          "new_text": null,
          "old_line_content": "                stages.emplace_back(context);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": "empty",
          "new_api": null,
          "old_text": "stages.empty()",
          "new_text": null,
          "old_line_content": "    if (stages.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::LOGICAL_ERROR, \"Mutation interpreter has no stages\")",
          "new_text": null,
          "old_line_content": "        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Mutation interpreter has no stages\");",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": "back",
          "new_api": null,
          "old_text": "stages.back().isAffectingAllColumns(storage_columns)",
          "new_text": null,
          "old_line_content": "    return stages.back().isAffectingAllColumns(storage_columns);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": "back",
          "new_api": null,
          "old_text": "stages.back().column_to_updated.emplace(\n                            column.name,\n                            column.default_desc.expression->clone())",
          "new_text": null,
          "old_line_content": "                        stages.back().column_to_updated.emplace(",
          "new_line_content": "                    {",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": "clone",
          "new_api": null,
          "old_text": "column.default_desc.expression->clone()",
          "new_text": null,
          "old_line_content": "                            column.default_desc.expression->clone());",
          "new_line_content": "                            column.name,",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "set",
          "new_api": null,
          "old_text": "mutation_kind.set(MutationKind::MUTATE_OTHER)",
          "new_text": null,
          "old_line_content": "            mutation_kind.set(MutationKind::MUTATE_OTHER);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": "get",
          "new_api": null,
          "old_text": "columns_desc.get(command.column_name)",
          "new_text": null,
          "old_line_content": "            const auto & column = columns_desc.get(command.column_name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\n                    ErrorCodes::BAD_ARGUMENTS,\n                    \"Cannot materialize column `{}` because it doesn't have default expression\", column.name)",
          "new_text": null,
          "old_line_content": "                throw Exception(",
          "new_line_content": "            if (!column.default_desc.expression)",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": "clone",
          "new_api": null,
          "old_text": "makeASTFunction(\n                \"_CAST\", column.default_desc.expression->clone(), std::make_shared<ASTLiteral>(column.type->getName()))",
          "new_text": null,
          "old_line_content": "            auto materialized_column = makeASTFunction(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "back",
          "new_api": null,
          "old_text": "stages.back().column_to_updated.emplace(column.name, materialized_column)",
          "new_text": null,
          "old_line_content": "            stages.back().column_to_updated.emplace(column.name, materialized_column);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": "set",
          "new_api": null,
          "old_text": "mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION)",
          "new_text": null,
          "old_line_content": "            mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "std::cend(indices_desc)",
          "new_api": null,
          "old_text": "std::cend(indices_desc)",
          "new_text": null,
          "old_line_content": "            if (it == std::cend(indices_desc))",
          "new_line_content": "                    });",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": "clone",
          "new_api": null,
          "old_text": "*it).expression_list_ast->clone()",
          "new_text": null,
          "old_line_content": "            auto query = (*it).expression_list_ast->clone();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "emplace",
          "new_api": null,
          "old_text": "dependencies.emplace(column, ColumnDependency::SKIP_INDEX)",
          "new_text": null,
          "old_line_content": "                dependencies.emplace(column, ColumnDependency::SKIP_INDEX);",
          "new_line_content": "            for (const auto & column : required_columns)",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": "set",
          "new_api": null,
          "old_text": "mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION)",
          "new_text": null,
          "old_line_content": "            mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": "emplace",
          "new_api": null,
          "old_text": "dependencies.emplace(column, ColumnDependency::PROJECTION)",
          "new_text": null,
          "old_line_content": "                dependencies.emplace(column, ColumnDependency::PROJECTION);",
          "new_line_content": "            for (const auto & column : projection.required_columns)",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "set",
          "new_api": null,
          "old_text": "mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION)",
          "new_text": null,
          "old_line_content": "            mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "set",
          "new_api": null,
          "old_text": "mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION)",
          "new_text": null,
          "old_line_content": "            mutation_kind.set(MutationKind::MUTATE_INDEX_PROJECTION);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": "set",
          "new_api": null,
          "old_text": "mutation_kind.set(MutationKind::MUTATE_OTHER)",
          "new_text": null,
          "old_line_content": "            mutation_kind.set(MutationKind::MUTATE_OTHER);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": "getNames",
          "new_api": null,
          "old_text": "all_columns.getNames()",
          "new_text": null,
          "old_line_content": "                auto all_columns_vec = all_columns.getNames();",
          "new_line_content": "                // just recalculate ttl_infos without remove expired data",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": "insert",
          "new_api": null,
          "old_text": "dependencies.insert(dependency)",
          "new_text": null,
          "old_line_content": "                        dependencies.insert(dependency);",
          "new_line_content": "                    if (dependency.kind == ColumnDependency::TTL_EXPRESSION)",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": "hasRowsTTL",
          "new_api": null,
          "old_text": "metadata_snapshot->hasRowsTTL()",
          "new_text": null,
          "old_line_content": "            else if (metadata_snapshot->hasRowsTTL()",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "emplace",
          "new_api": null,
          "old_text": "dependencies.emplace(column.name, ColumnDependency::TTL_TARGET)",
          "new_text": null,
          "old_line_content": "                    dependencies.emplace(column.name, ColumnDependency::TTL_TARGET);",
          "new_line_content": "                for (const auto & column : all_columns)",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": "getColumnTTLs",
          "new_api": null,
          "old_text": "metadata_snapshot->getColumns().getColumnTTLs()",
          "new_text": null,
          "old_line_content": "                auto column_ttls = metadata_snapshot->getColumns().getColumnTTLs();",
          "new_line_content": "                NameSet new_updated_columns;",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": "emplace",
          "new_api": null,
          "old_text": "dependencies.emplace(elem.first, ColumnDependency::TTL_TARGET)",
          "new_text": null,
          "old_line_content": "                    dependencies.emplace(elem.first, ColumnDependency::TTL_TARGET);",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": "getNames",
          "new_api": null,
          "old_text": "all_columns.getNames()",
          "new_text": null,
          "old_line_content": "                auto all_columns_vec = all_columns.getNames();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "insert",
          "new_api": null,
          "old_text": "dependencies.insert(dependency)",
          "new_text": null,
          "old_line_content": "                        dependencies.insert(dependency);",
          "new_line_content": "                    if (dependency.kind == ColumnDependency::TTL_EXPRESSION)",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": "getColumnDependencies",
          "new_api": null,
          "old_text": "metadata_snapshot->getColumnDependencies(new_updated_columns, true)",
          "new_text": null,
          "old_line_content": "                auto new_dependencies = metadata_snapshot->getColumnDependencies(new_updated_columns, true);",
          "new_line_content": "                /// Recalc only skip indices and projections of columns which could be updated by TTL.",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": "insert",
          "new_api": null,
          "old_text": "dependencies.insert(dependency)",
          "new_text": null,
          "old_line_content": "                        dependencies.insert(dependency);",
          "new_line_content": "                    if (dependency.kind == ColumnDependency::SKIP_INDEX || dependency.kind == ColumnDependency::PROJECTION)",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": "empty",
          "new_api": null,
          "old_text": "dependencies.empty()",
          "new_text": null,
          "old_line_content": "            if (dependencies.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": "front",
          "new_api": null,
          "old_text": "all_columns.front()",
          "new_text": null,
          "old_line_content": "                dependencies.emplace(all_columns.front().name, ColumnDependency::TTL_EXPRESSION);",
          "new_line_content": "                /// But we still have to read at least one column.",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": "set",
          "new_api": null,
          "old_text": "mutation_kind.set(MutationKind::MUTATE_OTHER)",
          "new_text": null,
          "old_line_content": "            mutation_kind.set(MutationKind::MUTATE_OTHER);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "size",
          "new_api": null,
          "old_text": "stages.size()",
          "new_text": null,
          "old_line_content": "            if (stages.size() == 1) /// First stage only supports filtering and can't update columns.",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "stages.emplace_back(context)",
          "new_text": null,
          "old_line_content": "                stages.emplace_back(context);",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": "std::make_shared<ASTIdentifier>(command.column_name)",
          "new_api": null,
          "old_text": "std::make_shared<ASTIdentifier>(command.column_name)",
          "new_text": null,
          "old_line_content": "            stages.back().column_to_updated.emplace(command.column_name, std::make_shared<ASTIdentifier>(command.column_name));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "DB::toString<int>(command.type)",
          "new_api": null,
          "old_text": "DB::toString<int>(command.type)",
          "new_text": null,
          "old_line_content": "            throw Exception(\"Unknown mutation command type: \" + DB::toString<int>(command.type), ErrorCodes::UNKNOWN_MUTATION_COMMAND);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": "empty",
          "new_api": null,
          "old_text": "dependencies.empty()",
          "new_text": null,
          "old_line_content": "    if (!dependencies.empty())",
          "new_line_content": "        for (auto & column_name : read_columns)",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "isReadOnly",
          "new_api": null,
          "old_text": "dependency.isReadOnly()",
          "new_text": null,
          "old_line_content": "            if (dependency.isReadOnly())",
          "new_line_content": "    /// The same about columns, that are needed for calculation of TTL expressions.",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": "insert",
          "new_api": null,
          "old_text": "changed_columns.insert(dependency.column_name)",
          "new_text": null,
          "old_line_content": "                changed_columns.insert(dependency.column_name);",
          "new_line_content": "        NameSet changed_columns;",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": "empty",
          "new_api": null,
          "old_text": "changed_columns.empty()",
          "new_text": null,
          "old_line_content": "        if (!changed_columns.empty())",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "stages.emplace_back(context)",
          "new_text": null,
          "old_line_content": "                stages.emplace_back(context);",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "stages.emplace_back(context)",
          "new_text": null,
          "old_line_content": "                stages.emplace_back(context);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "back",
          "new_api": null,
          "old_text": "stages.back().column_to_updated.emplace(\n                    column, std::make_shared<ASTIdentifier>(column))",
          "new_text": null,
          "old_line_content": "                stages.back().column_to_updated.emplace(",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": "empty",
          "new_api": null,
          "old_text": "stages.empty()",
          "new_text": null,
          "old_line_content": "            if (!stages.empty())",
          "new_line_content": "            for (const auto & column : changed_columns)",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "stages_copy.emplace_back(context)",
          "new_text": null,
          "old_line_content": "                    stages_copy.emplace_back(context);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "back",
          "new_api": null,
          "old_text": "stages_copy.back()",
          "new_text": null,
          "old_line_content": "                    stages_copy.back().output_columns = stage.output_columns;",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": "back",
          "new_api": null,
          "old_text": "stages_copy.back()",
          "new_text": null,
          "old_line_content": "                    stages_copy.back().filters = stage.filters;",
          "new_line_content": "                std::vector<Stage> stages_copy;",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "prepareInterpreterSelectQuery",
          "new_api": null,
          "old_text": "prepareInterpreterSelectQuery(stages_copy, /* dry_run = */ true)",
          "new_text": null,
          "old_line_content": "                const ASTPtr select_query = prepareInterpreterSelectQuery(stages_copy, /* dry_run = */ true);",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": "getSampleBlock",
          "new_api": null,
          "old_text": "interpreter.getSampleBlock()",
          "new_text": null,
          "old_line_content": "                auto first_stage_header = interpreter.getSampleBlock();",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": "std::move(source)",
          "new_api": null,
          "old_text": "std::move(source)",
          "new_text": null,
          "old_line_content": "                plan.addStep(std::make_unique<ReadFromPreparedSource>(Pipe(std::move(source))));",
          "new_line_content": "                InterpreterSelectQuery interpreter{",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "addStreamsForLaterStages",
          "new_api": null,
          "old_text": "addStreamsForLaterStages(stages_copy, plan)",
          "new_text": null,
          "old_line_content": "                auto pipeline = addStreamsForLaterStages(stages_copy, plan);",
          "new_line_content": "                    select_query, context, storage, metadata_snapshot,",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": "getStorageSnapshot",
          "new_api": null,
          "old_text": "storage->getStorageSnapshot(metadata_snapshot, context)",
          "new_text": null,
          "old_line_content": "    auto storage_snapshot = storage->getStorageSnapshot(metadata_snapshot, context);",
          "new_line_content": "    is_prepared = true;",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "withExtendedObjects",
          "new_api": null,
          "old_text": "GetColumnsOptions(GetColumnsOptions::AllPhysical).withExtendedObjects()",
          "new_text": null,
          "old_line_content": "    auto options = GetColumnsOptions(GetColumnsOptions::AllPhysical).withExtendedObjects();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": "dynamic_pointer_cast<DB::StorageFromMergeTreeDataPart>(storage)",
          "new_api": null,
          "old_text": "dynamic_pointer_cast<DB::StorageFromMergeTreeDataPart>(storage)",
          "new_text": null,
          "old_line_content": "    if (auto part_storage = dynamic_pointer_cast<DB::StorageFromMergeTreeDataPart>(storage))",
          "new_line_content": "ASTPtr MutationsInterpreter::prepareInterpreterSelectQuery(std::vector<Stage> & prepared_stages, bool dry_run)",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "insert",
          "new_api": null,
          "old_text": "prepared_stages[i].output_columns.insert(column.name)",
          "new_text": null,
          "old_line_content": "                prepared_stages[i].output_columns.insert(column.name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "insert",
          "new_api": null,
          "old_text": "prepared_stages[i].output_columns.insert(kv.first)",
          "new_text": null,
          "old_line_content": "            prepared_stages[i].output_columns.insert(kv.first);",
          "new_line_content": "        if (i > 0)",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": "size",
          "new_api": null,
          "old_text": "prepared_stages.size()",
          "new_text": null,
          "old_line_content": "    for (size_t i = prepared_stages.size() - 1; i > 0; --i)",
          "new_line_content": "        /// and so it is not in the list of AllPhysical columns.",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "std::make_shared<ASTExpressionList>()",
          "new_api": null,
          "old_text": "std::make_shared<ASTExpressionList>()",
          "new_text": null,
          "old_line_content": "        ASTPtr all_asts = std::make_shared<ASTExpressionList>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "all_asts->children.push_back(kv.second)",
          "new_text": null,
          "old_line_content": "            all_asts->children.push_back(kv.second);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": "analyze",
          "new_api": null,
          "old_text": "TreeRewriter(context).analyze(\n            all_asts, all_columns, storage, storage_snapshot,\n            false, true, execute_scalar_subqueries)",
          "new_text": null,
          "old_line_content": "        auto syntax_result = TreeRewriter(context).analyze(",
          "new_line_content": "        /// Add all output columns to prevent ExpressionAnalyzer from deleting them from source columns.",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": "hasQueryContext",
          "new_api": null,
          "old_text": "context->hasQueryContext()",
          "new_text": null,
          "old_line_content": "        if (execute_scalar_subqueries && context->hasQueryContext())",
          "new_line_content": "        /// Executing scalar subquery on that stage can lead to deadlock",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": "getScalars",
          "new_api": null,
          "old_text": "syntax_result->getScalars()",
          "new_text": null,
          "old_line_content": "            for (const auto & it : syntax_result->getScalars())",
          "new_line_content": "        /// e.g. ALTER referencing the same table in scalar subquery",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "getQueryContext",
          "new_api": null,
          "old_text": "context->getQueryContext()->addScalar(it.first, it.second)",
          "new_text": null,
          "old_line_content": "                context->getQueryContext()->addScalar(it.first, it.second);",
          "new_line_content": "        bool execute_scalar_subqueries = !dry_run;",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": "std::make_unique<ExpressionAnalyzer>(all_asts, syntax_result, context)",
          "new_api": null,
          "old_text": "std::make_unique<ExpressionAnalyzer>(all_asts, syntax_result, context)",
          "new_text": null,
          "old_line_content": "        stage.analyzer = std::make_unique<ExpressionAnalyzer>(all_asts, syntax_result, context);",
          "new_line_content": "            all_asts, all_columns, storage, storage_snapshot,",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": "empty",
          "new_api": null,
          "old_text": "actions_chain.steps.empty()",
          "new_text": null,
          "old_line_content": "            if (!actions_chain.steps.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": "appendExpression",
          "new_api": null,
          "old_text": "stage.analyzer->appendExpression(actions_chain, ast, dry_run)",
          "new_text": null,
          "old_line_content": "            stage.analyzer->appendExpression(actions_chain, ast, dry_run);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "getColumnName",
          "new_api": null,
          "old_text": "ast->getColumnName()",
          "new_text": null,
          "old_line_content": "            stage.filter_column_names.push_back(ast->getColumnName());",
          "new_line_content": "        ExpressionActionsChain & actions_chain = stage.expressions_chain;",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": "empty",
          "new_api": null,
          "old_text": "stage.column_to_updated.empty()",
          "new_text": null,
          "old_line_content": "        if (!stage.column_to_updated.empty())",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "appendExpression",
          "new_api": null,
          "old_text": "stage.analyzer->appendExpression(actions_chain, kv.second, dry_run)",
          "new_text": null,
          "old_line_content": "                stage.analyzer->appendExpression(actions_chain, kv.second, dry_run);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": "getLastStep",
          "new_api": null,
          "old_text": "actions_chain.getLastStep().actions()",
          "new_text": null,
          "old_line_content": "            auto & actions = actions_chain.getLastStep().actions();",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": "getColumnName",
          "new_api": null,
          "old_text": "kv.second->getColumnName()",
          "new_text": null,
          "old_line_content": "                auto column_name = kv.second->getColumnName();",
          "new_line_content": "            for (const auto & kv : stage.column_to_updated)",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": "addAlias",
          "new_api": null,
          "old_text": "actions->addAlias(dag_node, kv.first)",
          "new_text": null,
          "old_line_content": "                const auto & alias = actions->addAlias(dag_node, kv.first);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": "getLastStep",
          "new_api": null,
          "old_text": "actions_chain.getLastStep().addRequiredOutput(name)",
          "new_text": null,
          "old_line_content": "            actions_chain.getLastStep().addRequiredOutput(name);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "getLastActions",
          "new_api": null,
          "old_text": "actions_chain.getLastActions()",
          "new_text": null,
          "old_line_content": "        actions_chain.getLastActions();",
          "new_line_content": "        /// Remove all intermediate columns.",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": "insert",
          "new_api": null,
          "old_text": "prepared_stages[i - 1].output_columns.insert(column.name)",
          "new_text": null,
          "old_line_content": "            prepared_stages[i - 1].output_columns.insert(column.name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": "std::make_shared<ASTSelectQuery>()",
          "new_api": null,
          "old_text": "std::make_shared<ASTSelectQuery>()",
          "new_text": null,
          "old_line_content": "    auto select = std::make_shared<ASTSelectQuery>();",
          "new_line_content": "        /// Propagate information about columns needed as input.",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": "std::make_shared<ASTIdentifier>(column_name)",
          "new_api": null,
          "old_text": "std::make_shared<ASTIdentifier>(column_name)",
          "new_text": null,
          "old_line_content": "        select->select()->children.push_back(std::make_shared<ASTIdentifier>(column_name));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": "Field",
          "new_api": null,
          "old_text": "Field(0)",
          "new_text": null,
          "old_line_content": "        select->select()->children.push_back(std::make_shared<ASTLiteral>(Field(0)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": "empty",
          "new_api": null,
          "old_text": "prepared_stages[0].filters.empty()",
          "new_text": null,
          "old_line_content": "    if (!prepared_stages[0].filters.empty())",
          "new_line_content": "    for (const auto & column_name : prepared_stages[0].output_columns)",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": "size",
          "new_api": null,
          "old_text": "prepared_stages[0].filters.size()",
          "new_text": null,
          "old_line_content": "        if (prepared_stages[0].filters.size() == 1)",
          "new_line_content": "    /// Don't let select list be empty.",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": "std::make_shared<ASTExpressionList>()",
          "new_api": null,
          "old_text": "std::make_shared<ASTExpressionList>()",
          "new_text": null,
          "old_line_content": "            coalesced_predicates->arguments = std::make_shared<ASTExpressionList>();",
          "new_line_content": "        ASTPtr where_expression;",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "std::move(coalesced_predicates)",
          "new_api": null,
          "old_text": "std::move(coalesced_predicates)",
          "new_text": null,
          "old_line_content": "            where_expression = std::move(coalesced_predicates);",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "size",
          "new_api": null,
          "old_text": "prepared_stages.size()",
          "new_text": null,
          "old_line_content": "    for (size_t i_stage = 1; i_stage < prepared_stages.size(); ++i_stage)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "size",
          "new_api": null,
          "old_text": "stage.expressions_chain.steps.size()",
          "new_text": null,
          "old_line_content": "        for (size_t i = 0; i < stage.expressions_chain.steps.size(); ++i)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "actions",
          "new_api": null,
          "old_text": "step->actions()",
          "new_text": null,
          "old_line_content": "                plan.addStep(std::make_unique<FilterStep>(plan.getCurrentDataStream(), step->actions(), stage.filter_column_names[i], false));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": "actions",
          "new_api": null,
          "old_text": "step->actions()",
          "new_text": null,
          "old_line_content": "                plan.addStep(std::make_unique<ExpressionStep>(plan.getCurrentDataStream(), step->actions()));",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": "getPreparedSets",
          "new_api": null,
          "old_text": "stage.analyzer->getPreparedSets()",
          "new_text": null,
          "old_line_content": "        addCreatingSetsStep(plan, stage.analyzer->getPreparedSets(), context);",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": "buildQueryPipeline",
          "new_api": null,
          "old_text": "plan.buildQueryPipeline(\n        do_not_optimize_plan,\n        BuildQueryPipelineSettings::fromContext(context))",
          "new_text": null,
          "old_line_content": "    auto pipeline = std::move(*plan.buildQueryPipeline(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": "BuildQueryPipelineSettings::fromContext(context)",
          "new_api": null,
          "old_text": "BuildQueryPipelineSettings::fromContext(context)",
          "new_text": null,
          "old_line_content": "        BuildQueryPipelineSettings::fromContext(context)));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": "addSimpleTransform",
          "new_api": null,
          "old_text": "pipeline.addSimpleTransform([&](const Block & header)\n    {\n        return std::make_shared<MaterializingTransform>(header);\n    })",
          "new_text": null,
          "old_line_content": "    pipeline.addSimpleTransform([&](const Block & header)",
          "new_line_content": "    QueryPlanOptimizationSettings do_not_optimize_plan;",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": "std::make_shared<MaterializingTransform>(header)",
          "new_api": null,
          "old_text": "std::make_shared<MaterializingTransform>(header)",
          "new_text": null,
          "old_line_content": "        return std::make_shared<MaterializingTransform>(header);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": "std::make_unique<InterpreterSelectQuery>(mutation_ast, context, storage, metadata_snapshot, select_limits)",
          "new_api": null,
          "old_text": "std::make_unique<InterpreterSelectQuery>(mutation_ast, context, storage, metadata_snapshot, select_limits)",
          "new_text": null,
          "old_line_content": "        select_interpreter = std::make_unique<InterpreterSelectQuery>(mutation_ast, context, storage, metadata_snapshot, select_limits);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context->getSettingsRef()",
          "new_text": null,
          "old_line_content": "    const Settings & settings = context->getSettingsRef();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": "getName",
          "new_api": null,
          "old_text": "storage->getName()",
          "new_text": null,
          "old_line_content": "    if (startsWith(storage->getName(), \"Replicated\") && !settings.allow_nondeterministic_mutations)",
          "new_line_content": "    if (!select_interpreter)",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": "findFirstNonDeterministicFunctionName",
          "new_api": null,
          "old_text": "findFirstNonDeterministicFunctionName(command, context)",
          "new_text": null,
          "old_line_content": "            const auto nondeterministic_func_data = findFirstNonDeterministicFunctionName(command, context);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::BAD_ARGUMENTS, \"ALTER UPDATE/ALTER DELETE statement with subquery may be nondeterministic, \"\n                                                           \"see allow_nondeterministic_mutations setting\")",
          "new_text": null,
          "old_line_content": "                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"ALTER UPDATE/ALTER DELETE statement with subquery may be nondeterministic, \"",
          "new_line_content": "    /// because that produces inconsistencies between replicas",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::BAD_ARGUMENTS,\n                    \"ALTER UPDATE/ALTER DELETE statements must use only deterministic functions. \"\n                    \"Function '{}' is non-deterministic\", *nondeterministic_func_data.nondeterministic_function_name)",
          "new_text": null,
          "old_line_content": "                throw Exception(ErrorCodes::BAD_ARGUMENTS,",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(command.type == MutationCommand::DELETE || !return_deleted_rows)",
          "new_text": null,
          "old_line_content": "        assert(command.type == MutationCommand::DELETE || !return_deleted_rows);",
          "new_line_content": "        // we can return deleted rows only if it's the only present command",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": "addStreamsForLaterStages",
          "new_api": null,
          "old_text": "addStreamsForLaterStages(stages, plan)",
          "new_text": null,
          "old_line_content": "    auto pipeline = addStreamsForLaterStages(stages, plan);",
          "new_line_content": "                    \"ALTER UPDATE/ALTER DELETE statements must use only deterministic functions. \"",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "set",
          "new_api": null,
          "old_text": "mutation_kind.set(MutationKind::MUTATE_OTHER)",
          "new_text": null,
          "old_line_content": "            mutation_kind.set(MutationKind::MUTATE_OTHER);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": "getPartitionAndPredicateExpressionForMutationCommand",
          "new_api": null,
          "old_text": "getPartitionAndPredicateExpressionForMutationCommand(command)",
          "new_text": null,
          "old_line_content": "            auto predicate  = getPartitionAndPredicateExpressionForMutationCommand(command);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": "makeASTFunction",
          "new_api": null,
          "old_text": "makeASTFunction(\"isZeroOrNull\", predicate)",
          "new_text": null,
          "old_line_content": "                predicate = makeASTFunction(\"isZeroOrNull\", predicate);",
          "new_line_content": "            if (!return_deleted_rows)",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": "back",
          "new_api": null,
          "old_text": "stages.back().filters.push_back(predicate)",
          "new_text": null,
          "old_line_content": "            stages.back().filters.push_back(predicate);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": "setApplyDeletedMask",
          "new_api": null,
          "old_text": "context_for_reading->setApplyDeletedMask(apply_deleted_mask)",
          "new_text": null,
          "old_line_content": "            context_for_reading->setApplyDeletedMask(apply_deleted_mask);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": "set",
          "new_api": null,
          "old_text": "mutation_kind.set(MutationKind::MUTATE_OTHER)",
          "new_text": null,
          "old_line_content": "            mutation_kind.set(MutationKind::MUTATE_OTHER);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": "std::make_unique<InterpreterSelectQuery>(mutation_ast, context_for_reading, storage, metadata_snapshot, select_limits)",
          "new_api": null,
          "old_text": "std::make_unique<InterpreterSelectQuery>(mutation_ast, context_for_reading, storage, metadata_snapshot, select_limits)",
          "new_text": null,
          "old_line_content": "            select_interpreter = std::make_unique<InterpreterSelectQuery>(mutation_ast, context_for_reading, storage, metadata_snapshot, select_limits);",
          "new_line_content": "    if (!select_interpreter)",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "std::make_unique<InterpreterSelectQuery>(mutation_ast, context, storage, metadata_snapshot, select_limits)",
          "new_api": null,
          "old_text": "std::make_unique<InterpreterSelectQuery>(mutation_ast, context, storage, metadata_snapshot, select_limits)",
          "new_text": null,
          "old_line_content": "            select_interpreter = std::make_unique<InterpreterSelectQuery>(mutation_ast, context, storage, metadata_snapshot, select_limits);",
          "new_line_content": "        if (!apply_deleted_mask)",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": "buildQueryPlan",
          "new_api": null,
          "old_text": "select_interpreter->buildQueryPlan(plan)",
          "new_text": null,
          "old_line_content": "    select_interpreter->buildQueryPlan(plan);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": "find",
          "new_api": null,
          "old_text": "column_to_affected_materialized.find(column)",
          "new_text": null,
          "old_line_content": "                auto materialized_it = column_to_affected_materialized.find(column);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": "getHeader",
          "new_api": null,
          "old_text": "builder.getHeader()",
          "new_text": null,
          "old_line_content": "    if (auto sort_desc = getStorageSortDescriptionIfPossible(builder.getHeader()))",
          "new_line_content": "    QueryPlan plan;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 72,
      "total_additions": 140,
      "total_deletions": 138,
      "total_api_changes": 350
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 18,
        "api_related_lines": 350,
        "non_api_lines": 5,
        "non_api_line_numbers": [
          710,
          722,
          725,
          726,
          476
        ]
      }
    },
    "api_calls_before": 431,
    "api_calls_after": 433,
    "diff_info": {
      "added_lines": 13,
      "removed_lines": 6,
      "total_diff_lines": 43
    }
  }
}