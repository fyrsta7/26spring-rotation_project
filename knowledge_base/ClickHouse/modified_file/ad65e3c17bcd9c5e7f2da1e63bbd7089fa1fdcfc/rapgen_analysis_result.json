{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/ad65e3c17bcd9c5e7f2da1e63bbd7089fa1fdcfc",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/ad65e3c17bcd9c5e7f2da1e63bbd7089fa1fdcfc/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/ad65e3c17bcd9c5e7f2da1e63bbd7089fa1fdcfc/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/ad65e3c17bcd9c5e7f2da1e63bbd7089fa1fdcfc/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 444,
          "old_api": "front",
          "new_api": "empty",
          "old_text": "part.ranges.front()",
          "new_text": "part.ranges.empty()",
          "old_line_content": "                    MarkRange & range = part.ranges.front();",
          "new_line_content": "                    if (part.ranges.empty())",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": "std::move(ranges_to_get_from_part)",
          "new_api": "emplace_back",
          "old_text": "std::move(ranges_to_get_from_part)",
          "new_text": "parts_with_ranges.emplace_back(part)",
          "old_line_content": "            new_parts.emplace_back(part.data_part, part.part_index_in_query, std::move(ranges_to_get_from_part));",
          "new_line_content": "                parts_with_ranges.emplace_back(part);",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": "std::make_shared<ExpressionActions>(sorting_key_prefix_expr)",
          "new_api": "size",
          "old_text": "std::make_shared<ExpressionActions>(sorting_key_prefix_expr)",
          "new_text": "input_order_info->order_key_prefix_descr.size()",
          "old_line_content": "        auto sorting_key_expr = std::make_shared<ExpressionActions>(sorting_key_prefix_expr);",
          "new_line_content": "        for (size_t j = 0; j < input_order_info->order_key_prefix_descr.size(); ++j)",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "std::make_shared<ExpressionTransform>(header, sorting_key_expr)",
          "new_api": "getHeader",
          "old_text": "std::make_shared<ExpressionTransform>(header, sorting_key_expr)",
          "new_text": "pipe.getHeader()",
          "old_line_content": "                return std::make_shared<ExpressionTransform>(header, sorting_key_expr);",
          "new_line_content": "            out_projection = createProjection(pipe.getHeader());",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": "std::make_shared<SummingSortedTransform>(header, num_outputs,\n                           sort_description, merging_params.columns_to_sum, partition_key_columns, max_block_size)",
          "new_api": "std::make_shared<CollapsingSortedTransform>(header, num_outputs,\n                           sort_description, merging_params.sign_column, true, max_block_size)",
          "old_text": "std::make_shared<SummingSortedTransform>(header, num_outputs,\n                           sort_description, merging_params.columns_to_sum, partition_key_columns, max_block_size)",
          "new_text": "std::make_shared<CollapsingSortedTransform>(header, num_outputs,\n                           sort_description, merging_params.sign_column, true, max_block_size)",
          "old_line_content": "                return std::make_shared<SummingSortedTransform>(header, num_outputs,",
          "new_line_content": "                return std::make_shared<CollapsingSortedTransform>(header, num_outputs,",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "std::make_shared<AggregatingSortedTransform>(header, num_outputs,\n                           sort_description, max_block_size)",
          "new_api": "std::make_shared<SummingSortedTransform>(header, num_outputs,\n                           sort_description, merging_params.columns_to_sum, partition_key_columns, max_block_size)",
          "old_text": "std::make_shared<AggregatingSortedTransform>(header, num_outputs,\n                           sort_description, max_block_size)",
          "new_text": "std::make_shared<SummingSortedTransform>(header, num_outputs,\n                           sort_description, merging_params.columns_to_sum, partition_key_columns, max_block_size)",
          "old_line_content": "                return std::make_shared<AggregatingSortedTransform>(header, num_outputs,",
          "new_line_content": "                return std::make_shared<SummingSortedTransform>(header, num_outputs,",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": "std::make_shared<ReplacingSortedTransform>(header, num_outputs,\n                           sort_description, merging_params.version_column, max_block_size)",
          "new_api": "std::make_shared<AggregatingSortedTransform>(header, num_outputs,\n                           sort_description, max_block_size)",
          "old_text": "std::make_shared<ReplacingSortedTransform>(header, num_outputs,\n                           sort_description, merging_params.version_column, max_block_size)",
          "new_text": "std::make_shared<AggregatingSortedTransform>(header, num_outputs,\n                           sort_description, max_block_size)",
          "old_line_content": "                return std::make_shared<ReplacingSortedTransform>(header, num_outputs,",
          "new_line_content": "                return std::make_shared<AggregatingSortedTransform>(header, num_outputs,",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "std::make_shared<VersionedCollapsingTransform>(header, num_outputs,\n                           sort_description, merging_params.sign_column, max_block_size)",
          "new_api": "std::make_shared<ReplacingSortedTransform>(header, num_outputs,\n                           sort_description, merging_params.version_column, max_block_size)",
          "old_text": "std::make_shared<VersionedCollapsingTransform>(header, num_outputs,\n                           sort_description, merging_params.sign_column, max_block_size)",
          "new_text": "std::make_shared<ReplacingSortedTransform>(header, num_outputs,\n                           sort_description, merging_params.version_column, max_block_size)",
          "old_line_content": "                return std::make_shared<VersionedCollapsingTransform>(header, num_outputs,",
          "new_line_content": "                return std::make_shared<ReplacingSortedTransform>(header, num_outputs,",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": "Exception",
          "new_api": "std::make_shared<VersionedCollapsingTransform>(header, num_outputs,\n                           sort_description, merging_params.sign_column, max_block_size)",
          "old_text": "Exception(\"GraphiteMergeTree doesn't support FINAL\", ErrorCodes::LOGICAL_ERROR)",
          "new_text": "std::make_shared<VersionedCollapsingTransform>(header, num_outputs,\n                           sort_description, merging_params.sign_column, max_block_size)",
          "old_line_content": "                throw Exception(\"GraphiteMergeTree doesn't support FINAL\", ErrorCodes::LOGICAL_ERROR);",
          "new_line_content": "                return std::make_shared<VersionedCollapsingTransform>(header, num_outputs,",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": "empty",
          "new_api": "size",
          "old_text": "desc.column_name.empty()",
          "new_text": "sort_description.size()",
          "old_line_content": "        if (!desc.column_name.empty())",
          "new_line_content": "    key_columns.reserve(sort_description.size());",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": "size",
          "new_api": "transform",
          "old_text": "ports.size()",
          "new_text": "pipe.transform([&](OutputPortRawPtrs ports)\n    {\n        Processors transforms;\n        std::vector<OutputPorts::iterator> output_ports;\n        transforms.reserve(ports.size() + num_output_streams);\n        output_ports.reserve(ports.size());\n\n        for (auto & port : ports)\n        {\n            auto copier = std::make_shared<CopyTransform>(header, num_output_streams);\n            connect(*port, copier->getInputPort());\n            output_ports.emplace_back(copier->getOutputs().begin());\n            transforms.emplace_back(std::move(copier));\n        }\n\n        for (size_t i = 0; i < num_output_streams; ++i)\n        {\n            auto merge = get_merging_processor();\n            merge->setSelectorPosition(i);\n            auto input = merge->getInputs().begin();\n\n            /// Connect i-th merge with i-th input port of every copier.\n            for (size_t j = 0; j < ports.size(); ++j)\n            {\n                connect(*output_ports[j], *input);\n                ++output_ports[j];\n                ++input;\n            }\n\n            transforms.emplace_back(std::move(merge));\n        }\n\n        return transforms;\n    })",
          "old_line_content": "        transforms.reserve(ports.size() + num_output_streams);",
          "new_line_content": "    pipe.transform([&](OutputPortRawPtrs ports)",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": "std::make_shared<CopyTransform>(header, num_output_streams)",
          "new_api": "size",
          "old_text": "std::make_shared<CopyTransform>(header, num_output_streams)",
          "new_text": "ports.size()",
          "old_line_content": "            auto copier = std::make_shared<CopyTransform>(header, num_output_streams);",
          "new_line_content": "        output_ports.reserve(ports.size());",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": "size",
          "new_api": "setSelectorPosition",
          "old_text": "ports.size()",
          "new_text": "merge->setSelectorPosition(i)",
          "old_line_content": "            for (size_t j = 0; j < ports.size(); ++j)",
          "new_line_content": "            merge->setSelectorPosition(i);",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": "end",
          "new_api": "push_back",
          "old_text": "parts_with_ranges.end()",
          "new_text": "parts_to_merge_ranges.push_back(it)",
          "old_line_content": "        while (it != parts_with_ranges.end())",
          "new_line_content": "    parts_to_merge_ranges.push_back(it);",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "push_back",
          "new_api": "end",
          "old_text": "parts_to_merge_ranges.push_back(it)",
          "new_text": "parts_with_ranges.end()",
          "old_line_content": "            parts_to_merge_ranges.push_back(it);",
          "new_line_content": "        while (it != parts_with_ranges.end())",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "size",
          "new_api": "push_back",
          "old_text": "parts_to_merge_ranges.size()",
          "new_text": "parts_to_merge_ranges.push_back(it)",
          "old_line_content": "        num_streams /= (parts_to_merge_ranges.size() - 1);",
          "new_line_content": "            parts_to_merge_ranges.push_back(it);",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "getMarksCount",
          "new_api": "std::distance(parts_to_merge_ranges[range_index], parts_to_merge_ranges[range_index + 1])",
          "old_text": "parts_to_merge_ranges[range_index]->getMarksCount()",
          "new_text": "std::distance(parts_to_merge_ranges[range_index], parts_to_merge_ranges[range_index + 1])",
          "old_line_content": "                sum_marks_in_lonely_parts += parts_to_merge_ranges[range_index]->getMarksCount();",
          "new_line_content": "                std::distance(parts_to_merge_ranges[range_index], parts_to_merge_ranges[range_index + 1]) == 1 &&",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": "empty",
          "new_api": "emplace_back",
          "old_text": "new_parts.empty()",
          "new_text": "new_parts.emplace_back(part_it->data_part, part_it->part_index_in_query, part_it->ranges)",
          "old_line_content": "            if (new_parts.empty())",
          "new_line_content": "                    new_parts.emplace_back(part_it->data_part, part_it->part_index_in_query, part_it->ranges);",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": "clone",
          "new_api": "getHeader",
          "old_text": "metadata_snapshot->getSortingKey().expression->getActionsDAG().clone()",
          "new_text": "pipe.getHeader()",
          "old_line_content": "            metadata_snapshot->getSortingKey().expression->getActionsDAG().clone());",
          "new_line_content": "                out_projection = createProjection(pipe.getHeader());",
          "content_same": false
        },
        {
          "line": 707,
          "old_api": "std::make_shared<ExpressionTransform>(header, sorting_expr)",
          "new_api": "clone",
          "old_text": "std::make_shared<ExpressionTransform>(header, sorting_expr)",
          "new_text": "metadata_snapshot->getSortingKey().expression->getActionsDAG().clone()",
          "old_line_content": "            return std::make_shared<ExpressionTransform>(header, sorting_expr);",
          "new_line_content": "            metadata_snapshot->getSortingKey().expression->getActionsDAG().clone());",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": "getSortingKeyColumns",
          "new_api": "std::move(pipe)",
          "old_text": "metadata_snapshot->getSortingKeyColumns()",
          "new_text": "std::move(pipe)",
          "old_line_content": "        Names sort_columns = metadata_snapshot->getSortingKeyColumns();",
          "new_line_content": "            partition_pipes.emplace_back(std::move(pipe));",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": "getHeader",
          "new_api": "reserve",
          "old_text": "pipe.getHeader()",
          "new_text": "sort_description.reserve(sort_columns_size)",
          "old_line_content": "        const auto & header = pipe.getHeader();",
          "new_line_content": "        sort_description.reserve(sort_columns_size);",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "getPositionByName",
          "new_api": "getPartitionKey",
          "old_text": "header.getPositionByName(sort_columns[i])",
          "new_text": "metadata_snapshot->getPartitionKey()",
          "old_line_content": "            sort_description.emplace_back(header.getPositionByName(sort_columns[i]), 1, 1);",
          "new_line_content": "        Names partition_key_columns = metadata_snapshot->getPartitionKey().column_names;",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": "addMergingFinal",
          "new_api": "getHeader",
          "old_text": "addMergingFinal(\n            pipe,\n            std::min<size_t>(num_streams, settings.max_final_threads),\n            sort_description, data.merging_params, partition_key_columns, max_block_size)",
          "new_text": "pipe.getHeader()",
          "old_line_content": "        addMergingFinal(",
          "new_line_content": "        const auto & header = pipe.getHeader();",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "std::min<size_t>(num_streams, settings.max_final_threads)",
          "new_api": "getPositionByName",
          "old_text": "std::min<size_t>(num_streams, settings.max_final_threads)",
          "new_text": "header.getPositionByName(sort_columns[i])",
          "old_line_content": "            std::min<size_t>(num_streams, settings.max_final_threads),",
          "new_line_content": "            sort_description.emplace_back(header.getPositionByName(sort_columns[i]), 1, 1);",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "size",
          "new_api": "empty",
          "old_text": "lonely_parts.size()",
          "new_text": "lonely_parts.empty()",
          "old_line_content": "        size_t num_streams_for_lonely_parts = num_streams * lonely_parts.size();",
          "new_line_content": "    if (!lonely_parts.empty())",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": "std::make_shared<ExpressionTransform>(header, sorting_expr)",
          "new_api": "clone",
          "old_text": "std::make_shared<ExpressionTransform>(header, sorting_expr)",
          "new_text": "metadata_snapshot->getSortingKey().expression->getActionsDAG().clone()",
          "old_line_content": "            return std::make_shared<ExpressionTransform>(header, sorting_expr);",
          "new_line_content": "            metadata_snapshot->getSortingKey().expression->getActionsDAG().clone());",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "MergeTreeDataSelectExecutor::filterPartsByVirtualColumns(data, parts, query_info.query, context)",
          "new_api": "getSettingsRef",
          "old_text": "MergeTreeDataSelectExecutor::filterPartsByVirtualColumns(data, parts, query_info.query, context)",
          "new_text": "context->getSettingsRef()",
          "old_line_content": "    auto part_values = MergeTreeDataSelectExecutor::filterPartsByVirtualColumns(data, parts, query_info.query, context);",
          "new_line_content": "    const auto & settings = context->getSettingsRef();",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": "getStorageID",
          "new_api": "getAllPhysical",
          "old_text": "data.getStorageID()",
          "new_text": "metadata_snapshot->getColumns().getAllPhysical()",
          "old_line_content": "    metadata_snapshot->check(result.column_names_to_read, data.getVirtuals(), data.getStorageID());",
          "new_line_content": "        NamesAndTypesList available_real_columns = metadata_snapshot->getColumns().getAllPhysical();",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": "alwaysUnknownOrTrue",
          "new_api": "getPrimaryKey",
          "old_text": "key_condition.alwaysUnknownOrTrue()",
          "new_text": "metadata_snapshot->getPrimaryKey()",
          "old_line_content": "    if (settings.force_primary_key && key_condition.alwaysUnknownOrTrue())",
          "new_line_content": "    const auto & primary_key = metadata_snapshot->getPrimaryKey();",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": "query_info.query->as<ASTSelectQuery &>()",
          "new_api": "fmt::join(primary_key_columns, \", \")",
          "old_text": "query_info.query->as<ASTSelectQuery &>()",
          "new_text": "fmt::join(primary_key_columns, \", \")",
          "old_line_content": "    const auto & select = query_info.query->as<ASTSelectQuery &>();",
          "new_line_content": "            fmt::join(primary_key_columns, \", \"));",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": "get",
          "new_api": "toString",
          "old_text": "MergeTreeDataSelectExecutor::filterPartsByPartition(\n        parts, part_values, metadata_snapshot_base, data, query_info, context,\n        max_block_numbers_to_read.get(), log, result.index_stats)",
          "new_text": "key_condition.toString()",
          "old_line_content": "    MergeTreeDataSelectExecutor::filterPartsByPartition(",
          "new_line_content": "    LOG_DEBUG(log, \"Key condition: {}\", key_condition.toString());",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": "get",
          "new_api": "query_info.query->as<ASTSelectQuery &>()",
          "old_text": "max_block_numbers_to_read.get()",
          "new_text": "query_info.query->as<ASTSelectQuery &>()",
          "old_line_content": "        max_block_numbers_to_read.get(), log, result.index_stats);",
          "new_line_content": "    const auto & select = query_info.query->as<ASTSelectQuery &>();",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": "getAllPhysical",
          "new_api": "get",
          "old_text": "MergeTreeDataSelectExecutor::getSampling(\n        select, metadata_snapshot->getColumns().getAllPhysical(), parts, key_condition,\n        data, metadata_snapshot, context, sample_factor_column_queried, log)",
          "new_text": "MergeTreeDataSelectExecutor::filterPartsByPartition(\n        parts, part_values, metadata_snapshot_base, data, query_info, context,\n        max_block_numbers_to_read.get(), log, result.index_stats)",
          "old_line_content": "    result.sampling = MergeTreeDataSelectExecutor::getSampling(",
          "new_line_content": "    MergeTreeDataSelectExecutor::filterPartsByPartition(",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": "MergeTreeDataSelectExecutor::filterPartsByPrimaryKeyAndSkipIndexes(\n        std::move(parts),\n        metadata_snapshot,\n        query_info,\n        context,\n        key_condition,\n        reader_settings,\n        log,\n        requested_num_streams,\n        result.index_stats,\n        true /* use_skip_indexes */,\n        true /* check_limits */)",
          "new_api": "getMarksCountWithoutFinal",
          "old_text": "MergeTreeDataSelectExecutor::filterPartsByPrimaryKeyAndSkipIndexes(\n        std::move(parts),\n        metadata_snapshot,\n        query_info,\n        context,\n        key_condition,\n        reader_settings,\n        log,\n        requested_num_streams,\n        result.index_stats,\n        true /* use_skip_indexes */,\n        true /* check_limits */)",
          "new_text": "part->index_granularity.getMarksCountWithoutFinal()",
          "old_line_content": "    result.parts_with_ranges = MergeTreeDataSelectExecutor::filterPartsByPrimaryKeyAndSkipIndexes(",
          "new_line_content": "        total_marks_pk += part->index_granularity.getMarksCountWithoutFinal();",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": "getOutputStream",
          "new_api": "MergeTreeDataSelectExecutor::checkLimits(data, result.parts_with_ranges, context)",
          "old_text": "getOutputStream()",
          "new_text": "MergeTreeDataSelectExecutor::checkLimits(data, result.parts_with_ranges, context)",
          "old_line_content": "        pipeline.init(Pipe(std::make_shared<NullSource>(getOutputStream().header)));",
          "new_line_content": "    auto query_id_holder = MergeTreeDataSelectExecutor::checkLimits(data, result.parts_with_ranges, context);",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": "getNames",
          "new_api": "final",
          "old_text": "result.sampling.filter_expression->getRequiredColumns().getNames()",
          "new_text": "select.final()",
          "old_line_content": "        std::vector<String> add_columns = result.sampling.filter_expression->getRequiredColumns().getNames();",
          "new_line_content": "    if (!select.final() && result.sampling.use_sampling)",
          "content_same": false
        },
        {
          "line": 919,
          "old_api": "end",
          "new_api": "getNames",
          "old_text": "column_names_to_read.end()",
          "new_text": "result.sampling.filter_expression->getRequiredColumns().getNames()",
          "old_line_content": "                                   column_names_to_read.end());",
          "new_line_content": "        std::vector<String> add_columns = result.sampling.filter_expression->getRequiredColumns().getNames();",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "end",
          "new_api": "final",
          "old_text": "add_columns.end()",
          "new_text": "select.final()",
          "old_line_content": "        column_names_to_read.insert(column_names_to_read.end(), add_columns.begin(), add_columns.end());",
          "new_line_content": "    if (select.final())",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": "push_back",
          "new_api": "getColumnsRequiredForSortingKey",
          "old_text": "column_names_to_read.push_back(data.merging_params.sign_column)",
          "new_text": "metadata_snapshot->getColumnsRequiredForSortingKey()",
          "old_line_content": "            column_names_to_read.push_back(data.merging_params.sign_column);",
          "new_line_content": "        std::vector<String> add_columns = metadata_snapshot->getColumnsRequiredForSortingKey();",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": "empty",
          "new_api": "end",
          "old_text": "data.merging_params.version_column.empty()",
          "new_text": "add_columns.end()",
          "old_line_content": "        if (!data.merging_params.version_column.empty())",
          "new_line_content": "        column_names_to_read.insert(column_names_to_read.end(), add_columns.begin(), add_columns.end());",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "end",
          "new_api": "push_back",
          "old_text": "column_names_to_read.end()",
          "new_text": "column_names_to_read.push_back(data.merging_params.sign_column)",
          "old_line_content": "        std::sort(column_names_to_read.begin(), column_names_to_read.end());",
          "new_line_content": "            column_names_to_read.push_back(data.merging_params.sign_column);",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "end",
          "new_api": "empty",
          "old_text": "column_names_to_read.end()",
          "new_text": "data.merging_params.version_column.empty()",
          "old_line_content": "        column_names_to_read.erase(std::unique(column_names_to_read.begin(), column_names_to_read.end()), column_names_to_read.end());",
          "new_line_content": "        if (!data.merging_params.version_column.empty())",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": "std::move(result.parts_with_ranges)",
          "new_api": "end",
          "old_text": "std::move(result.parts_with_ranges)",
          "new_text": "column_names_to_read.end()",
          "old_line_content": "            std::move(result.parts_with_ranges),",
          "new_line_content": "        std::sort(column_names_to_read.begin(), column_names_to_read.end());",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": "getAllPhysical",
          "new_api": "size",
          "old_text": "metadata_snapshot->getColumns().getAllPhysical()",
          "new_text": "input_order_info->order_key_prefix_descr.size()",
          "old_line_content": "        auto syntax_result = TreeRewriter(context).analyze(order_key_prefix_ast, metadata_snapshot->getColumns().getAllPhysical());",
          "new_line_content": "        size_t prefix_size = input_order_info->order_key_prefix_descr.size();",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "getActionsDAG",
          "new_api": "getSortingKey",
          "old_text": "ExpressionAnalyzer(order_key_prefix_ast, syntax_result, context).getActionsDAG(false)",
          "new_text": "metadata_snapshot->getSortingKey().expression_list_ast->clone()",
          "old_line_content": "        auto sorting_key_prefix_expr = ExpressionAnalyzer(order_key_prefix_ast, syntax_result, context).getActionsDAG(false);",
          "new_line_content": "        auto order_key_prefix_ast = metadata_snapshot->getSortingKey().expression_list_ast->clone();",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": "std::move(result.parts_with_ranges)",
          "new_api": "getAllPhysical",
          "old_text": "std::move(result.parts_with_ranges)",
          "new_text": "metadata_snapshot->getColumns().getAllPhysical()",
          "old_line_content": "            std::move(result.parts_with_ranges),",
          "new_line_content": "        auto syntax_result = TreeRewriter(context).analyze(order_key_prefix_ast, metadata_snapshot->getColumns().getAllPhysical());",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": "empty",
          "new_api": "std::move(result.parts_with_ranges)",
          "old_text": "pipe.empty()",
          "new_text": "std::move(result.parts_with_ranges)",
          "old_line_content": "    if (pipe.empty())",
          "new_line_content": "            std::move(result.parts_with_ranges),",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "getResultColumns",
          "new_api": "std::move(actions)",
          "old_text": "result_projection->getResultColumns()",
          "new_text": "std::move(actions)",
          "old_line_content": "        cur_header = result_projection->getResultColumns();",
          "new_line_content": "            result_projection = std::move(actions);",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "std::move(adding_column)",
          "new_api": "std::make_shared<DataTypeFloat64>()",
          "old_text": "std::move(adding_column)",
          "new_text": "std::make_shared<DataTypeFloat64>()",
          "old_line_content": "        append_actions(std::move(adding_column));",
          "new_line_content": "        column.type = std::make_shared<DataTypeFloat64>();",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": "getColumnsWithTypeAndName",
          "new_api": "getOutputStream",
          "old_text": "getOutputStream().header.getColumnsWithTypeAndName()",
          "new_text": "getOutputStream()",
          "old_line_content": "            getOutputStream().header.getColumnsWithTypeAndName(),",
          "new_line_content": "    if (!isCompatibleHeader(cur_header, getOutputStream().header))",
          "content_same": false
        },
        {
          "line": 1025,
          "old_api": "std::move(converting)",
          "new_api": "getColumnsWithTypeAndName",
          "old_text": "std::move(converting)",
          "new_text": "cur_header.getColumnsWithTypeAndName()",
          "old_line_content": "        append_actions(std::move(converting));",
          "new_line_content": "            cur_header.getColumnsWithTypeAndName(),",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": "getProcessors",
          "new_api": "std::make_shared<ExpressionTransform>(header, projection_actions)",
          "old_text": "pipe.getProcessors()",
          "new_text": "std::make_shared<ExpressionTransform>(header, projection_actions)",
          "old_line_content": "    for (const auto & processor : pipe.getProcessors())",
          "new_line_content": "            return std::make_shared<ExpressionTransform>(header, projection_actions);",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": "std::move(query_id_holder)",
          "new_api": "emplace_back",
          "old_text": "std::move(query_id_holder)",
          "new_text": "processors.emplace_back(processor)",
          "old_line_content": "        pipe.addQueryIdHolder(std::move(query_id_holder));",
          "new_line_content": "        processors.emplace_back(processor);",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": "empty",
          "new_api": "selectRangesToRead",
          "old_text": "result.index_stats.empty()",
          "new_text": "selectRangesToRead(prepared_parts)",
          "old_line_content": "    if (!result.index_stats.empty())",
          "new_line_content": "    auto result = selectRangesToRead(prepared_parts);",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": "back",
          "new_api": "readTypeToString",
          "old_text": "result.index_stats.back()",
          "new_text": "readTypeToString(result.read_type)",
          "old_line_content": "        format_settings.out << prefix << \"Parts: \" << result.index_stats.back().num_parts_after << '\\n';",
          "new_line_content": "    format_settings.out << prefix << \"ReadType: \" << readTypeToString(result.read_type) << '\\n';",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": "back",
          "new_api": "selectRangesToRead",
          "old_text": "result.index_stats.back()",
          "new_text": "selectRangesToRead(prepared_parts)",
          "old_line_content": "        map.add(\"Parts\", result.index_stats.back().num_parts_after);",
          "new_line_content": "    auto result = selectRangesToRead(prepared_parts);",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "back",
          "new_api": "readTypeToString",
          "old_text": "result.index_stats.back()",
          "new_text": "readTypeToString(result.read_type)",
          "old_line_content": "        map.add(\"Granules\", result.index_stats.back().num_granules_after);",
          "new_line_content": "    map.add(\"Read Type\", readTypeToString(result.read_type));",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": "empty",
          "new_api": "selectRangesToRead",
          "old_text": "index_stats.empty()",
          "new_text": "selectRangesToRead(prepared_parts)",
          "old_line_content": "    if (!index_stats.empty())",
          "new_line_content": "    auto result = selectRangesToRead(prepared_parts);",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": "empty",
          "new_api": "std::make_unique<JSONBuilder::JSONMap>()",
          "old_text": "stat.name.empty()",
          "new_text": "std::make_unique<JSONBuilder::JSONMap>()",
          "old_line_content": "            if (!stat.name.empty())",
          "new_line_content": "            auto index_map = std::make_unique<JSONBuilder::JSONMap>();",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": "add",
          "new_api": "empty",
          "old_text": "index_map->add(\"Description\", stat.description)",
          "new_text": "stat.name.empty()",
          "old_line_content": "                index_map->add(\"Description\", stat.description);",
          "new_line_content": "            if (!stat.name.empty())",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": "std::make_unique<JSONBuilder::JSONArray>()",
          "new_api": "add",
          "old_text": "std::make_unique<JSONBuilder::JSONArray>()",
          "new_text": "index_map->add(\"Description\", stat.description)",
          "old_line_content": "                auto keys_array = std::make_unique<JSONBuilder::JSONArray>();",
          "new_line_content": "                index_map->add(\"Description\", stat.description);",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": "add",
          "new_api": "std::move(keys_array)",
          "old_text": "index_map->add(\"Condition\", stat.condition)",
          "new_text": "std::move(keys_array)",
          "old_line_content": "                index_map->add(\"Condition\", stat.condition);",
          "new_line_content": "                index_map->add(\"Keys\", std::move(keys_array));",
          "content_same": false
        },
        {
          "line": 1200,
          "old_api": "add",
          "new_api": "empty",
          "old_text": "index_map->add(\"Initial Parts\", index_stats[i - 1].num_parts_after)",
          "new_text": "stat.condition.empty()",
          "old_line_content": "                index_map->add(\"Initial Parts\", index_stats[i - 1].num_parts_after);",
          "new_line_content": "            if (!stat.condition.empty())",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1024,
          "old_api": null,
          "new_api": "getColumnsWithTypeAndName",
          "old_text": null,
          "new_text": "ActionsDAG::makeConvertingActions(\n            cur_header.getColumnsWithTypeAndName(),\n            getOutputStream().header.getColumnsWithTypeAndName(),\n            ActionsDAG::MatchColumnsMode::Name)",
          "old_line_content": "",
          "new_line_content": "        auto converting = ActionsDAG::makeConvertingActions(",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": null,
          "new_api": "getColumnsWithTypeAndName",
          "old_text": null,
          "new_text": "getOutputStream().header.getColumnsWithTypeAndName()",
          "old_line_content": "    }",
          "new_line_content": "            getOutputStream().header.getColumnsWithTypeAndName(),",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": null,
          "new_api": "std::move(converting)",
          "old_text": null,
          "new_text": "std::move(converting)",
          "old_line_content": "    {",
          "new_line_content": "        append_actions(std::move(converting));",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": null,
          "new_api": "getHeader",
          "old_text": null,
          "new_text": "pipe.getHeader()",
          "old_line_content": "    {",
          "new_line_content": "    const auto & header = pipe.getHeader();",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": null,
          "new_api": "numOutputPorts",
          "old_text": null,
          "new_text": "pipe.numOutputPorts()",
          "old_line_content": "        switch (merging_params.mode)",
          "new_line_content": "    size_t num_outputs = pipe.numOutputPorts();",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": null,
          "new_api": "std::make_shared<ExpressionActions>(result_projection)",
          "old_text": null,
          "new_text": "std::make_shared<ExpressionActions>(result_projection)",
          "old_line_content": "        });",
          "new_line_content": "        auto projection_actions = std::make_shared<ExpressionActions>(result_projection);",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "addSimpleTransform",
          "old_text": null,
          "new_text": "pipe.addSimpleTransform([&](const Block & header)\n        {\n            return std::make_shared<ExpressionTransform>(header, projection_actions);\n        })",
          "old_line_content": "    }",
          "new_line_content": "        pipe.addSimpleTransform([&](const Block & header)",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": null,
          "new_api": "std::make_shared<MergingSortedTransform>(header, num_outputs,\n                           sort_description, max_block_size)",
          "old_text": null,
          "new_text": "std::make_shared<MergingSortedTransform>(header, num_outputs,\n                           sort_description, max_block_size)",
          "old_line_content": "            case MergeTreeData::MergingParams::Collapsing:",
          "new_line_content": "                return std::make_shared<MergingSortedTransform>(header, num_outputs,",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": null,
          "new_api": "getProcessors",
          "old_text": null,
          "new_text": "pipe.getProcessors()",
          "old_line_content": "    if (query_id_holder)",
          "new_line_content": "    for (const auto & processor : pipe.getProcessors())",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": null,
          "new_api": "std::move(query_id_holder)",
          "old_text": null,
          "new_text": "std::move(query_id_holder)",
          "old_line_content": "",
          "new_line_content": "        pipe.addQueryIdHolder(std::move(query_id_holder));",
          "content_same": false
        },
        {
          "line": 1048,
          "old_api": null,
          "new_api": "std::move(pipe)",
          "old_text": null,
          "new_text": "std::move(pipe)",
          "old_line_content": "{",
          "new_line_content": "    pipeline.init(std::move(pipe));",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"GraphiteMergeTree doesn't support FINAL\", ErrorCodes::LOGICAL_ERROR)",
          "old_line_content": "    };",
          "new_line_content": "                throw Exception(\"GraphiteMergeTree doesn't support FINAL\", ErrorCodes::LOGICAL_ERROR);",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": null,
          "new_api": "__builtin_unreachable",
          "old_text": null,
          "new_text": "__builtin_unreachable()",
          "old_line_content": "{",
          "new_line_content": "    __builtin_unreachable();",
          "content_same": false
        },
        {
          "line": 556,
          "old_api": null,
          "new_api": "__builtin_unreachable",
          "old_text": null,
          "new_text": "__builtin_unreachable()",
          "old_line_content": "    {",
          "new_line_content": "        __builtin_unreachable();",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "sort_description.empty()",
          "old_line_content": "    }",
          "new_line_content": "    if (num_output_streams <= 1 || sort_description.empty())",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "get_merging_processor",
          "old_text": null,
          "new_text": "get_merging_processor()",
          "old_line_content": "    ColumnNumbers key_columns;",
          "new_line_content": "        pipe.addTransform(get_merging_processor());",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "desc.column_name.empty()",
          "old_line_content": "    }",
          "new_line_content": "        if (!desc.column_name.empty())",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": null,
          "new_api": "getPositionByName",
          "old_text": null,
          "new_text": "header.getPositionByName(desc.column_name)",
          "old_line_content": "",
          "new_line_content": "            key_columns.push_back(header.getPositionByName(desc.column_name));",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": null,
          "new_api": "__builtin_unreachable",
          "old_text": null,
          "new_text": "__builtin_unreachable()",
          "old_line_content": "{",
          "new_line_content": "    __builtin_unreachable();",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "key_columns.emplace_back(desc.column_number)",
          "old_line_content": "    {",
          "new_line_content": "            key_columns.emplace_back(desc.column_number);",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": null,
          "new_api": "addSimpleTransform",
          "old_text": null,
          "new_text": "pipe.addSimpleTransform([&](const Block & stream_header)\n    {\n        return std::make_shared<AddingSelectorTransform>(stream_header, num_output_streams, key_columns);\n    })",
          "old_line_content": "",
          "new_line_content": "    pipe.addSimpleTransform([&](const Block & stream_header)",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": null,
          "new_api": "std::make_shared<AddingSelectorTransform>(stream_header, num_output_streams, key_columns)",
          "old_text": null,
          "new_text": "std::make_shared<AddingSelectorTransform>(stream_header, num_output_streams, key_columns)",
          "old_line_content": "    {",
          "new_line_content": "        return std::make_shared<AddingSelectorTransform>(stream_header, num_output_streams, key_columns);",
          "content_same": false
        },
        {
          "line": 1091,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "result.index_stats.empty()",
          "old_line_content": "    }",
          "new_line_content": "    if (!result.index_stats.empty())",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "result.index_stats.back()",
          "old_line_content": "",
          "new_line_content": "        format_settings.out << prefix << \"Parts: \" << result.index_stats.back().num_parts_after << '\\n';",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "result.index_stats.back()",
          "old_line_content": "void ReadFromMergeTree::describeActions(JSONBuilder::JSONMap & map) const",
          "new_line_content": "        format_settings.out << prefix << \"Granules: \" << result.index_stats.back().num_granules_after << '\\n';",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ports.size()",
          "old_line_content": "        {",
          "new_line_content": "        transforms.reserve(ports.size() + num_output_streams);",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": null,
          "new_api": "std::make_shared<CopyTransform>(header, num_output_streams)",
          "old_text": null,
          "new_text": "std::make_shared<CopyTransform>(header, num_output_streams)",
          "old_line_content": "        }",
          "new_line_content": "            auto copier = std::make_shared<CopyTransform>(header, num_output_streams);",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": null,
          "new_api": "getInputPort",
          "old_text": null,
          "new_text": "copier->getInputPort()",
          "old_line_content": "",
          "new_line_content": "            connect(*port, copier->getInputPort());",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "copier->getOutputs().begin()",
          "old_line_content": "        for (size_t i = 0; i < num_output_streams; ++i)",
          "new_line_content": "            output_ports.emplace_back(copier->getOutputs().begin());",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": null,
          "new_api": "std::move(copier)",
          "old_text": null,
          "new_text": "std::move(copier)",
          "old_line_content": "        {",
          "new_line_content": "            transforms.emplace_back(std::move(copier));",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "result.index_stats.empty()",
          "old_line_content": "    }",
          "new_line_content": "    if (!result.index_stats.empty())",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "result.index_stats.back()",
          "old_line_content": "",
          "new_line_content": "        map.add(\"Parts\", result.index_stats.back().num_parts_after);",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "result.index_stats.back()",
          "old_line_content": "void ReadFromMergeTree::describeIndexes(FormatSettings & format_settings) const",
          "new_line_content": "        map.add(\"Granules\", result.index_stats.back().num_granules_after);",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": null,
          "new_api": "get_merging_processor",
          "old_text": null,
          "new_text": "get_merging_processor()",
          "old_line_content": "            /// Connect i-th merge with i-th input port of every copier.",
          "new_line_content": "            auto merge = get_merging_processor();",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "merge->getInputs().begin()",
          "old_line_content": "            {",
          "new_line_content": "            auto input = merge->getInputs().begin();",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": null,
          "new_api": "std::move(result.index_stats)",
          "old_text": null,
          "new_text": "std::move(result.index_stats)",
          "old_line_content": "    {",
          "new_line_content": "    auto index_stats = std::move(result.index_stats);",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ports.size()",
          "old_line_content": "                ++input;",
          "new_line_content": "            for (size_t j = 0; j < ports.size(); ++j)",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "index_stats.empty()",
          "old_line_content": "            return;",
          "new_line_content": "    if (!index_stats.empty())",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": null,
          "new_api": "connect",
          "old_text": null,
          "new_text": "connect(*output_ports[j], *input)",
          "old_line_content": "",
          "new_line_content": "                connect(*output_ports[j], *input);",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "index_stats.front()",
          "old_line_content": "        format_settings.out << prefix << \"Indexes:\\n\";",
          "new_line_content": "        if (index_stats.size() == 1 && index_stats.front().type == IndexType::None)",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": null,
          "new_api": "std::move(merge)",
          "old_text": null,
          "new_text": "std::move(merge)",
          "old_line_content": "    });",
          "new_line_content": "            transforms.emplace_back(std::move(merge));",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "index_stats.size()",
          "old_line_content": "                continue;",
          "new_line_content": "        for (size_t i = 0; i < index_stats.size(); ++i)",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": null,
          "new_api": "indexTypeToString",
          "old_text": null,
          "new_text": "indexTypeToString(stat.type)",
          "old_line_content": "",
          "new_line_content": "            format_settings.out << prefix << indent << indexTypeToString(stat.type) << '\\n';",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "stat.name.empty()",
          "old_line_content": "                format_settings.out << prefix << indent << indent << \"Description: \" << stat.description << '\\n';",
          "new_line_content": "            if (!stat.name.empty())",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context->getSettingsRef()",
          "old_line_content": "",
          "new_line_content": "    const auto & settings = context->getSettingsRef();",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": null,
          "new_api": "getSettings",
          "old_text": null,
          "new_text": "data.getSettings()",
          "old_line_content": "    size_t num_streams = requested_num_streams;",
          "new_line_content": "    const auto data_settings = data.getSettings();",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "stat.description.empty()",
          "old_line_content": "            {",
          "new_line_content": "            if (!stat.description.empty())",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "stat.used_keys.empty()",
          "old_line_content": "                    format_settings.out << prefix << indent << indent << indent << used_key << '\\n';",
          "new_line_content": "            if (!stat.used_keys.empty())",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "stat.condition.empty()",
          "old_line_content": "            if (i)",
          "new_line_content": "            if (!stat.condition.empty())",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "parts_with_ranges.begin()",
          "old_line_content": "    {",
          "new_line_content": "    auto it = parts_with_ranges.begin();",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "std::find_if(\n                it, parts_with_ranges.end(), [&it](auto & part) { return it->data_part->info.partition_id != part.data_part->info.partition_id; })",
          "old_line_content": "        /// We divide threads for each partition equally. But we will create at least the number of partitions threads.",
          "new_line_content": "            it = std::find_if(",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "parts_with_ranges.end()",
          "old_line_content": "        /// (So, the total number of threads could be more than initial num_streams.",
          "new_line_content": "                it, parts_with_ranges.end(), [&it](auto & part) { return it->data_part->info.partition_id != part.data_part->info.partition_id; });",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "parts_to_merge_ranges.size()",
          "old_line_content": "        /// If do_not_merge_across_partitions_select_final is false we just merge all the parts.",
          "new_line_content": "        num_streams /= (parts_to_merge_ranges.size() - 1);",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": null,
          "new_api": "selectRangesToRead",
          "old_text": null,
          "new_text": "selectRangesToRead(prepared_parts)",
          "old_line_content": "    {",
          "new_line_content": "    auto result = selectRangesToRead(prepared_parts);",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": null,
          "new_api": "std::move(result.index_stats)",
          "old_text": null,
          "new_text": "std::move(result.index_stats)",
          "old_line_content": "        /// Do not print anything if no indexes is applied.",
          "new_line_content": "    auto index_stats = std::move(result.index_stats);",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "index_stats.empty()",
          "old_line_content": "            return;",
          "new_line_content": "    if (!index_stats.empty())",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "parts_with_ranges.end()",
          "old_line_content": "",
          "new_line_content": "        parts_to_merge_ranges.push_back(parts_with_ranges.end());",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "index_stats.front()",
          "old_line_content": "",
          "new_line_content": "        if (index_stats.size() == 1 && index_stats.front().type == IndexType::None)",
          "content_same": false
        },
        {
          "line": 1172,
          "old_api": null,
          "new_api": "std::make_unique<JSONBuilder::JSONArray>()",
          "old_text": null,
          "new_text": "std::make_unique<JSONBuilder::JSONArray>()",
          "old_line_content": "            const auto & stat = index_stats[i];",
          "new_line_content": "        auto indexes_array = std::make_unique<JSONBuilder::JSONArray>();",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "index_stats.size()",
          "old_line_content": "                continue;",
          "new_line_content": "        for (size_t i = 0; i < index_stats.size(); ++i)",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "parts_to_merge_ranges.size()",
          "old_line_content": "        {",
          "new_line_content": "    for (size_t range_index = 0; range_index < parts_to_merge_ranges.size() - 1; ++range_index)",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": null,
          "new_api": "indexTypeToString",
          "old_text": null,
          "new_text": "indexTypeToString(stat.type)",
          "old_line_content": "",
          "new_line_content": "            index_map->add(\"Type\", indexTypeToString(stat.type));",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "index_map->add(\"Name\", stat.name)",
          "old_line_content": "",
          "new_line_content": "                index_map->add(\"Name\", stat.name);",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "stat.description.empty()",
          "old_line_content": "            {",
          "new_line_content": "            if (!stat.description.empty())",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "stat.used_keys.empty()",
          "old_line_content": "                for (const auto & used_key : stat.used_keys)",
          "new_line_content": "            if (!stat.used_keys.empty())",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": null,
          "new_api": "std::make_unique<JSONBuilder::JSONArray>()",
          "old_text": null,
          "new_text": "std::make_unique<JSONBuilder::JSONArray>()",
          "old_line_content": "",
          "new_line_content": "                auto keys_array = std::make_unique<JSONBuilder::JSONArray>();",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": null,
          "new_api": "getRowsCount",
          "old_text": null,
          "new_text": "parts_to_merge_ranges[range_index]->getRowsCount()",
          "old_line_content": "            }",
          "new_line_content": "                total_rows_in_lonely_parts += parts_to_merge_ranges[range_index]->getRowsCount();",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": null,
          "new_api": "getMarksCount",
          "old_text": null,
          "new_text": "parts_to_merge_ranges[range_index]->getMarksCount()",
          "old_line_content": "            else",
          "new_line_content": "                sum_marks_in_lonely_parts += parts_to_merge_ranges[range_index]->getMarksCount();",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "std::move(*parts_to_merge_ranges[range_index])",
          "old_text": null,
          "new_text": "std::move(*parts_to_merge_ranges[range_index])",
          "old_line_content": "            {",
          "new_line_content": "                lonely_parts.push_back(std::move(*parts_to_merge_ranges[range_index]));",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "keys_array->add(used_key)",
          "old_line_content": "",
          "new_line_content": "                    keys_array->add(used_key);",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "new_parts.empty()",
          "old_line_content": "                num_streams, 0, info.use_uncompressed_cache);",
          "new_line_content": "            if (new_parts.empty())",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "index_map->add(\"Initial Granules\", index_stats[i - 1].num_granules_after)",
          "old_line_content": "        }",
          "new_line_content": "                index_map->add(\"Initial Granules\", index_stats[i - 1].num_granules_after);",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "index_map->add(\"Selected Granules\", stat.num_granules_after)",
          "old_line_content": "",
          "new_line_content": "            index_map->add(\"Selected Granules\", stat.num_granules_after);",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": null,
          "new_api": "std::move(new_parts)",
          "old_text": null,
          "new_text": "std::move(new_parts)",
          "old_line_content": "            if (!out_projection)",
          "new_line_content": "            pipe = read(std::move(new_parts), column_names, ReadFromMergeTree::ReadType::InOrder,",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": null,
          "new_api": "std::move(index_map)",
          "old_text": null,
          "new_text": "std::move(index_map)",
          "old_line_content": "    }",
          "new_line_content": "            indexes_array->add(std::move(index_map));",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": null,
          "new_api": "std::move(indexes_array)",
          "old_text": null,
          "new_text": "std::move(indexes_array)",
          "old_line_content": "}",
          "new_line_content": "        map.add(\"Indexes\", std::move(indexes_array));",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": null,
          "new_api": "clone",
          "old_text": null,
          "new_text": "std::make_shared<ExpressionActions>(\n            metadata_snapshot->getSortingKey().expression->getActionsDAG().clone())",
          "old_line_content": "        {",
          "new_line_content": "        auto sorting_expr = std::make_shared<ExpressionActions>(",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": null,
          "new_api": "addSimpleTransform",
          "old_text": null,
          "new_text": "pipe.addSimpleTransform([sorting_expr](const Block & header)\n        {\n            return std::make_shared<ExpressionTransform>(header, sorting_expr);\n        })",
          "old_line_content": "",
          "new_line_content": "        pipe.addSimpleTransform([sorting_expr](const Block & header)",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": null,
          "new_api": "std::make_shared<ExpressionTransform>(header, sorting_expr)",
          "old_text": null,
          "new_text": "std::make_shared<ExpressionTransform>(header, sorting_expr)",
          "old_line_content": "        /// with level > 0 then we won't postprocess this part",
          "new_line_content": "            return std::make_shared<ExpressionTransform>(header, sorting_expr);",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": null,
          "new_api": "std::distance(parts_to_merge_ranges[range_index], parts_to_merge_ranges[range_index + 1])",
          "old_text": null,
          "new_text": "std::distance(parts_to_merge_ranges[range_index], parts_to_merge_ranges[range_index + 1])",
          "old_line_content": "            continue;",
          "new_line_content": "            std::distance(parts_to_merge_ranges[range_index], parts_to_merge_ranges[range_index + 1]) == 1 &&",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": null,
          "new_api": "getSortingKeyColumns",
          "old_text": null,
          "new_text": "metadata_snapshot->getSortingKeyColumns()",
          "old_line_content": "",
          "new_line_content": "        Names sort_columns = metadata_snapshot->getSortingKeyColumns();",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "sort_columns.size()",
          "old_line_content": "",
          "new_line_content": "        size_t sort_columns_size = sort_columns.size();",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": null,
          "new_api": "addMergingFinal",
          "old_text": null,
          "new_text": "addMergingFinal(\n            pipe,\n            std::min<size_t>(num_streams, settings.max_final_threads),\n            sort_description, data.merging_params, partition_key_columns, max_block_size)",
          "old_line_content": "",
          "new_line_content": "        addMergingFinal(",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": null,
          "new_api": "std::min<size_t>(num_streams, settings.max_final_threads)",
          "old_text": null,
          "new_text": "std::min<size_t>(num_streams, settings.max_final_threads)",
          "old_line_content": "    }",
          "new_line_content": "            std::min<size_t>(num_streams, settings.max_final_threads),",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": null,
          "new_api": "std::move(pipe)",
          "old_text": null,
          "new_text": "std::move(pipe)",
          "old_line_content": "    {",
          "new_line_content": "        partition_pipes.emplace_back(std::move(pipe));",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "lonely_parts.size()",
          "old_line_content": "            settings.merge_tree_min_rows_for_concurrent_read,",
          "new_line_content": "        size_t num_streams_for_lonely_parts = num_streams * lonely_parts.size();",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": null,
          "new_api": "MergeTreeDataSelectExecutor::minMarksForConcurrentRead(\n            settings.merge_tree_min_rows_for_concurrent_read,\n            settings.merge_tree_min_bytes_for_concurrent_read,\n            data_settings->index_granularity,\n            info.index_granularity_bytes,\n            sum_marks_in_lonely_parts)",
          "old_text": null,
          "new_text": "MergeTreeDataSelectExecutor::minMarksForConcurrentRead(\n            settings.merge_tree_min_rows_for_concurrent_read,\n            settings.merge_tree_min_bytes_for_concurrent_read,\n            data_settings->index_granularity,\n            info.index_granularity_bytes,\n            sum_marks_in_lonely_parts)",
          "old_line_content": "            info.index_granularity_bytes,",
          "new_line_content": "        const size_t min_marks_for_concurrent_read = MergeTreeDataSelectExecutor::minMarksForConcurrentRead(",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "lonely_parts.size()",
          "old_line_content": "                num_streams_for_lonely_parts, min_marks_for_concurrent_read, info.use_uncompressed_cache);",
          "new_line_content": "        if (sum_marks_in_lonely_parts < num_streams_for_lonely_parts * min_marks_for_concurrent_read && lonely_parts.size() < num_streams_for_lonely_parts)",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "lonely_parts.size()",
          "old_line_content": "",
          "new_line_content": "            num_streams_for_lonely_parts = std::max((sum_marks_in_lonely_parts + min_marks_for_concurrent_read - 1) / min_marks_for_concurrent_read, lonely_parts.size());",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": null,
          "new_api": "std::move(lonely_parts)",
          "old_text": null,
          "new_text": "std::move(lonely_parts)",
          "old_line_content": "        if (!out_projection)",
          "new_line_content": "        auto pipe = read(std::move(lonely_parts), column_names, ReadFromMergeTree::ReadType::Default,",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": null,
          "new_api": "getHeader",
          "old_text": null,
          "new_text": "pipe.getHeader()",
          "old_line_content": "",
          "new_line_content": "            out_projection = createProjection(pipe.getHeader());",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": null,
          "new_api": "clone",
          "old_text": null,
          "new_text": "std::make_shared<ExpressionActions>(\n            metadata_snapshot->getSortingKey().expression->getActionsDAG().clone())",
          "old_line_content": "        {",
          "new_line_content": "        auto sorting_expr = std::make_shared<ExpressionActions>(",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": null,
          "new_api": "addSimpleTransform",
          "old_text": null,
          "new_text": "pipe.addSimpleTransform([sorting_expr](const Block & header)\n        {\n            return std::make_shared<ExpressionTransform>(header, sorting_expr);\n        })",
          "old_line_content": "",
          "new_line_content": "        pipe.addSimpleTransform([sorting_expr](const Block & header)",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": null,
          "new_api": "std::make_shared<ExpressionTransform>(header, sorting_expr)",
          "old_text": null,
          "new_text": "std::make_shared<ExpressionTransform>(header, sorting_expr)",
          "old_line_content": "    }",
          "new_line_content": "            return std::make_shared<ExpressionTransform>(header, sorting_expr);",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": null,
          "new_api": "std::move(pipe)",
          "old_text": null,
          "new_text": "std::move(pipe)",
          "old_line_content": "}",
          "new_line_content": "        partition_pipes.emplace_back(std::move(pipe));",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": null,
          "new_api": "std::move(partition_pipes)",
          "old_text": null,
          "new_text": "std::move(partition_pipes)",
          "old_line_content": "{",
          "new_line_content": "    return Pipe::unitePipes(std::move(partition_pipes));",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "parts.size()",
          "old_line_content": "        return result;",
          "new_line_content": "    size_t total_parts = parts.size();",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": null,
          "new_api": "MergeTreeDataSelectExecutor::filterPartsByVirtualColumns(data, parts, query_info.query, context)",
          "old_text": null,
          "new_text": "MergeTreeDataSelectExecutor::filterPartsByVirtualColumns(data, parts, query_info.query, context)",
          "old_line_content": "    result.column_names_to_read = real_column_names;",
          "new_line_content": "    auto part_values = MergeTreeDataSelectExecutor::filterPartsByVirtualColumns(data, parts, query_info.query, context);",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "part_values->empty()",
          "old_line_content": "",
          "new_line_content": "    if (part_values && part_values->empty())",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "result.column_names_to_read.empty()",
          "old_line_content": "    }",
          "new_line_content": "    if (result.column_names_to_read.empty())",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": null,
          "new_api": "ExpressionActions::getSmallestColumn(available_real_columns)",
          "old_text": null,
          "new_text": "ExpressionActions::getSmallestColumn(available_real_columns)",
          "old_line_content": "",
          "new_line_content": "        result.column_names_to_read.push_back(ExpressionActions::getSmallestColumn(available_real_columns));",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": null,
          "new_api": "getStorageID",
          "old_text": null,
          "new_text": "data.getStorageID()",
          "old_line_content": "    Names primary_key_columns = primary_key.column_names;",
          "new_line_content": "    metadata_snapshot->check(result.column_names_to_read, data.getVirtuals(), data.getStorageID());",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": null,
          "new_api": "alwaysUnknownOrTrue",
          "old_text": null,
          "new_text": "key_condition.alwaysUnknownOrTrue()",
          "old_line_content": "            \"Primary key ({}) is not used and setting 'force_primary_key' is set.\",",
          "new_line_content": "    if (settings.force_primary_key && key_condition.alwaysUnknownOrTrue())",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\n            ErrorCodes::INDEX_NOT_USED,\n            \"Primary key ({}) is not used and setting 'force_primary_key' is set.\",\n            fmt::join(primary_key_columns, \", \"))",
          "old_line_content": "    }",
          "new_line_content": "        throw Exception(",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "max_block_numbers_to_read.get()",
          "old_line_content": "        data, metadata_snapshot, context, sample_factor_column_queried, log);",
          "new_line_content": "        max_block_numbers_to_read.get(), log, result.index_stats);",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": null,
          "new_api": "getAllPhysical",
          "old_text": null,
          "new_text": "MergeTreeDataSelectExecutor::getSampling(\n        select, metadata_snapshot->getColumns().getAllPhysical(), parts, key_condition,\n        data, metadata_snapshot, context, sample_factor_column_queried, log)",
          "old_line_content": "    if (result.sampling.read_nothing)",
          "new_line_content": "    result.sampling = MergeTreeDataSelectExecutor::getSampling(",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": null,
          "new_api": "getAllPhysical",
          "old_text": null,
          "new_text": "metadata_snapshot->getColumns().getAllPhysical()",
          "old_line_content": "        return result;",
          "new_line_content": "        select, metadata_snapshot->getColumns().getAllPhysical(), parts, key_condition,",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "parts.size()",
          "old_line_content": "        metadata_snapshot,",
          "new_line_content": "    size_t parts_before_pk = parts.size();",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": null,
          "new_api": "MergeTreeDataSelectExecutor::filterPartsByPrimaryKeyAndSkipIndexes(\n        std::move(parts),\n        metadata_snapshot,\n        query_info,\n        context,\n        key_condition,\n        reader_settings,\n        log,\n        requested_num_streams,\n        result.index_stats,\n        true /* use_skip_indexes */,\n        true /* check_limits */)",
          "old_text": null,
          "new_text": "MergeTreeDataSelectExecutor::filterPartsByPrimaryKeyAndSkipIndexes(\n        std::move(parts),\n        metadata_snapshot,\n        query_info,\n        context,\n        key_condition,\n        reader_settings,\n        log,\n        requested_num_streams,\n        result.index_stats,\n        true /* use_skip_indexes */,\n        true /* check_limits */)",
          "old_line_content": "        context,",
          "new_line_content": "    result.parts_with_ranges = MergeTreeDataSelectExecutor::filterPartsByPrimaryKeyAndSkipIndexes(",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": null,
          "new_api": "std::move(parts)",
          "old_text": null,
          "new_text": "std::move(parts)",
          "old_line_content": "        key_condition,",
          "new_line_content": "        std::move(parts),",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": null,
          "new_api": "getMarksCount",
          "old_text": null,
          "new_text": "part.getMarksCount()",
          "old_line_content": "    result.selected_marks = sum_marks;",
          "new_line_content": "        sum_marks += part.getMarksCount();",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": null,
          "new_api": "getRowsCount",
          "old_text": null,
          "new_text": "part.getRowsCount()",
          "old_line_content": "    result.selected_rows  = sum_rows;",
          "new_line_content": "        sum_rows += part.getRowsCount();",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "result.parts_with_ranges.size()",
          "old_line_content": "        log,",
          "new_line_content": "    result.selected_parts = result.parts_with_ranges.size();",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "LOG_DEBUG(\n        log,\n        \"Selected {}/{} parts by partition key, {} parts by primary key, {}/{} marks by primary key, {} marks to read from {} ranges\",\n        parts_before_pk,\n        total_parts,\n        result.parts_with_ranges.size(),\n        sum_marks_pk,\n        total_marks_pk,\n        sum_marks,\n        sum_ranges)",
          "old_line_content": "        total_parts,",
          "new_line_content": "    LOG_DEBUG(",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "result.parts_with_ranges.size()",
          "old_line_content": "        sum_ranges);",
          "new_line_content": "        result.parts_with_ranges.size(),",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "result.parts_with_ranges.size()",
          "old_line_content": "    const auto & input_order_info = query_info.input_order_info",
          "new_line_content": "    ProfileEvents::increment(ProfileEvents::SelectedParts, result.parts_with_ranges.size());",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": null,
          "new_api": "ProfileEvents::increment(ProfileEvents::SelectedRanges, sum_ranges)",
          "old_text": null,
          "new_text": "ProfileEvents::increment(ProfileEvents::SelectedRanges, sum_ranges)",
          "old_line_content": "        ? query_info.input_order_info",
          "new_line_content": "    ProfileEvents::increment(ProfileEvents::SelectedRanges, sum_ranges);",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": null,
          "new_api": "ProfileEvents::increment(ProfileEvents::SelectedMarks, sum_marks)",
          "old_text": null,
          "new_text": "ProfileEvents::increment(ProfileEvents::SelectedMarks, sum_marks)",
          "old_line_content": "        : (query_info.projection ? query_info.projection->input_order_info : nullptr);",
          "new_line_content": "    ProfileEvents::increment(ProfileEvents::SelectedMarks, sum_marks);",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": null,
          "new_api": "selectRangesToRead",
          "old_text": null,
          "new_text": "selectRangesToRead(prepared_parts)",
          "old_line_content": "    {",
          "new_line_content": "    auto result = selectRangesToRead(prepared_parts);",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "result.parts_with_ranges.empty()",
          "old_line_content": "    }",
          "new_line_content": "    if (result.parts_with_ranges.empty())",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": null,
          "new_api": "getOutputStream",
          "old_text": null,
          "new_text": "getOutputStream()",
          "old_line_content": "    selected_marks = result.selected_marks;",
          "new_line_content": "        pipeline.init(Pipe(std::make_shared<NullSource>(getOutputStream().header)));",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": null,
          "new_api": "std::move(result.column_names_to_read)",
          "old_text": null,
          "new_text": "std::move(result.column_names_to_read)",
          "old_line_content": "        /// Add columns needed for `sample_by_ast` to `column_names_to_read`.",
          "new_line_content": "    Names column_names_to_read = std::move(result.column_names_to_read);",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": null,
          "new_api": "query_info.query->as<ASTSelectQuery &>()",
          "old_text": null,
          "new_text": "query_info.query->as<ASTSelectQuery &>()",
          "old_line_content": "        /// Skip this if final was used, because such columns were already added from PK.",
          "new_line_content": "    const auto & select = query_info.query->as<ASTSelectQuery &>();",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "add_columns.end()",
          "old_line_content": "    }",
          "new_line_content": "        column_names_to_read.insert(column_names_to_read.end(), add_columns.begin(), add_columns.end());",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "column_names_to_read.end()",
          "old_line_content": "",
          "new_line_content": "        std::sort(column_names_to_read.begin(), column_names_to_read.end());",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "column_names_to_read.end()",
          "old_line_content": "    const auto & input_order_info = query_info.input_order_info",
          "new_line_content": "        column_names_to_read.erase(std::unique(column_names_to_read.begin(), column_names_to_read.end()),",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "column_names_to_read.end()",
          "old_line_content": "        ? query_info.input_order_info",
          "new_line_content": "                                   column_names_to_read.end());",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "info.sum_marks_in_parts.back()",
          "old_line_content": "",
          "new_line_content": "            size_t & marks_in_part = info.sum_marks_in_parts.back();",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context->getSettingsRef()",
          "old_line_content": "        /// Add columns needed to calculate the sorting expression and the sign.",
          "new_line_content": "    const auto & settings = context->getSettingsRef();",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "data.merging_params.sign_column.empty()",
          "old_line_content": "",
          "new_line_content": "        if (!data.merging_params.sign_column.empty())",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": null,
          "new_api": "getRowsCount",
          "old_text": null,
          "new_text": "part.getRowsCount()",
          "old_line_content": "            {",
          "new_line_content": "                || (input_order_info->limit && input_order_info->limit < part.getRowsCount());",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "column_names_to_read.push_back(data.merging_params.version_column)",
          "old_line_content": "",
          "new_line_content": "            column_names_to_read.push_back(data.merging_params.version_column);",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "column_names_to_read.end()",
          "old_line_content": "            column_names_to_read,",
          "new_line_content": "        column_names_to_read.erase(std::unique(column_names_to_read.begin(), column_names_to_read.end()), column_names_to_read.end());",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": null,
          "new_api": "spreadMarkRangesAmongStreamsFinal",
          "old_text": null,
          "new_text": "spreadMarkRangesAmongStreamsFinal(\n            std::move(result.parts_with_ranges),\n            column_names_to_read,\n            result_projection)",
          "old_line_content": "    }",
          "new_line_content": "        pipe = spreadMarkRangesAmongStreamsFinal(",
          "content_same": false
        },
        {
          "line": 437,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "info.sum_marks_in_parts.pop_back()",
          "old_line_content": "                /// Loop through ranges in part. Take enough ranges to cover \"need_marks\".",
          "new_line_content": "                info.sum_marks_in_parts.pop_back();",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": null,
          "new_api": "std::move(result.parts_with_ranges)",
          "old_text": null,
          "new_text": "std::move(result.parts_with_ranges)",
          "old_line_content": "    else if ((settings.optimize_read_in_order || settings.optimize_aggregation_in_order) && input_order_info)",
          "new_line_content": "            std::move(result.parts_with_ranges),",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Unexpected end of ranges while spreading marks among streams\",\n                                        ErrorCodes::LOGICAL_ERROR)",
          "old_line_content": "",
          "new_line_content": "                        throw Exception(\"Unexpected end of ranges while spreading marks among streams\",",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "order_key_prefix_ast->children.resize(prefix_size)",
          "old_line_content": "",
          "new_line_content": "        order_key_prefix_ast->children.resize(prefix_size);",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "part.ranges.front()",
          "old_line_content": "",
          "new_line_content": "                    MarkRange & range = part.ranges.front();",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": null,
          "new_api": "getActionsDAG",
          "old_text": null,
          "new_text": "ExpressionAnalyzer(order_key_prefix_ast, syntax_result, context).getActionsDAG(false)",
          "old_line_content": "            column_names_to_read,",
          "new_line_content": "        auto sorting_key_prefix_expr = ExpressionAnalyzer(order_key_prefix_ast, syntax_result, context).getActionsDAG(false);",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": null,
          "new_api": "spreadMarkRangesAmongStreamsWithOrder",
          "old_text": null,
          "new_text": "spreadMarkRangesAmongStreamsWithOrder(\n            std::move(result.parts_with_ranges),\n            column_names_to_read,\n            sorting_key_prefix_expr,\n            result_projection,\n            input_order_info)",
          "old_line_content": "            result_projection,",
          "new_line_content": "        pipe = spreadMarkRangesAmongStreamsWithOrder(",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": null,
          "new_api": "std::min(marks_in_range, need_marks)",
          "old_text": null,
          "new_text": "std::min(marks_in_range, need_marks)",
          "old_line_content": "                    marks_in_part -= marks_to_get_from_range;",
          "new_line_content": "                    const size_t marks_to_get_from_range = std::min(marks_in_range, need_marks);",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "std::move(result.parts_with_ranges)",
          "old_text": null,
          "new_text": "std::move(result.parts_with_ranges)",
          "old_line_content": "            input_order_info);",
          "new_line_content": "            std::move(result.parts_with_ranges),",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "ranges_to_get_from_part.emplace_back(range.begin, range.begin + marks_to_get_from_range)",
          "old_line_content": "                    if (range.begin == range.end)",
          "new_line_content": "                    ranges_to_get_from_part.emplace_back(range.begin, range.begin + marks_to_get_from_range);",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": null,
          "new_api": "pop_front",
          "old_text": null,
          "new_text": "part.ranges.pop_front()",
          "old_line_content": "",
          "new_line_content": "                        part.ranges.pop_front();",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": null,
          "new_api": "spreadMarkRangesAmongStreams",
          "old_text": null,
          "new_text": "spreadMarkRangesAmongStreams(\n            std::move(result.parts_with_ranges),\n            column_names_to_read)",
          "old_line_content": "",
          "new_line_content": "        pipe = spreadMarkRangesAmongStreams(",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": null,
          "new_api": "split_ranges",
          "old_text": null,
          "new_text": "split_ranges(ranges_to_get_from_part, input_order_info->direction)",
          "old_line_content": "        auto read_type = input_order_info->direction == 1",
          "new_line_content": "            ranges_to_get_from_part = split_ranges(ranges_to_get_from_part, input_order_info->direction);",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": null,
          "new_api": "std::move(ranges_to_get_from_part)",
          "old_text": null,
          "new_text": "std::move(ranges_to_get_from_part)",
          "old_line_content": "                       ? ReadFromMergeTree::ReadType::InOrder",
          "new_line_content": "            new_parts.emplace_back(part.data_part, part.part_index_in_query, std::move(ranges_to_get_from_part));",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "pipe.empty()",
          "old_line_content": "    }",
          "new_line_content": "    if (pipe.empty())",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": null,
          "new_api": "getOutputStream",
          "old_text": null,
          "new_text": "getOutputStream()",
          "old_line_content": "    if (result.sampling.use_sampling)",
          "new_line_content": "        pipeline.init(Pipe(std::make_shared<NullSource>(getOutputStream().header)));",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": null,
          "new_api": "std::move(new_parts)",
          "old_text": null,
          "new_text": "std::move(new_parts)",
          "old_line_content": "    if (need_preliminary_merge)",
          "new_line_content": "        pipes.emplace_back(readInOrder(std::move(new_parts), column_names, read_type,",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": null,
          "new_api": "std::make_shared<ExpressionActions>(result.sampling.filter_expression)",
          "old_text": null,
          "new_text": "std::make_shared<ExpressionActions>(result.sampling.filter_expression)",
          "old_line_content": "                header,",
          "new_line_content": "        auto sampling_actions = std::make_shared<ExpressionActions>(result.sampling.filter_expression);",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": null,
          "new_api": "addSimpleTransform",
          "old_text": null,
          "new_text": "pipe.addSimpleTransform([&](const Block & header)\n        {\n            return std::make_shared<FilterTransform>(\n                header,\n                sampling_actions,\n                result.sampling.filter_function->getColumnName(),\n                false);\n        })",
          "old_line_content": "                sampling_actions,",
          "new_line_content": "        pipe.addSimpleTransform([&](const Block & header)",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": null,
          "new_api": "getColumnName",
          "old_text": null,
          "new_text": "std::make_shared<FilterTransform>(\n                header,\n                sampling_actions,\n                result.sampling.filter_function->getColumnName(),\n                false)",
          "old_line_content": "                false);",
          "new_line_content": "            return std::make_shared<FilterTransform>(",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": null,
          "new_api": "getColumnName",
          "old_text": null,
          "new_text": "result.sampling.filter_function->getColumnName()",
          "old_line_content": "",
          "new_line_content": "                result.sampling.filter_function->getColumnName(),",
          "content_same": false
        },
        {
          "line": 479,
          "old_api": null,
          "new_api": "getSortingKey",
          "old_text": null,
          "new_text": "metadata_snapshot->getSortingKey()",
          "old_line_content": "",
          "new_line_content": "            sort_description.emplace_back(metadata_snapshot->getSortingKey().column_names[j],",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": null,
          "new_api": "std::make_shared<ExpressionActions>(sorting_key_prefix_expr)",
          "old_text": null,
          "new_text": "std::make_shared<ExpressionActions>(sorting_key_prefix_expr)",
          "old_line_content": "            /// Drop temporary columns, added by 'sorting_key_prefix_expr'",
          "new_line_content": "        auto sorting_key_expr = std::make_shared<ExpressionActions>(sorting_key_prefix_expr);",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": null,
          "new_api": "getResultColumns",
          "old_text": null,
          "new_text": "result_projection->getResultColumns()",
          "old_line_content": "    {",
          "new_line_content": "    Block cur_header = result_projection ? result_projection->getResultColumns()",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": null,
          "new_api": "getHeader",
          "old_text": null,
          "new_text": "pipe.getHeader()",
          "old_line_content": "        if (!result_projection)",
          "new_line_content": "                                         : pipe.getHeader();",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": null,
          "new_api": "addSimpleTransform",
          "old_text": null,
          "new_text": "pipe.addSimpleTransform([sorting_key_expr](const Block & header)\n            {\n                return std::make_shared<ExpressionTransform>(header, sorting_key_expr);\n            })",
          "old_line_content": "",
          "new_line_content": "            pipe.addSimpleTransform([sorting_key_expr](const Block & header)",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": null,
          "new_api": "std::make_shared<ExpressionTransform>(header, sorting_key_expr)",
          "old_text": null,
          "new_text": "std::make_shared<ExpressionTransform>(header, sorting_key_expr)",
          "old_line_content": "            {",
          "new_line_content": "                return std::make_shared<ExpressionTransform>(header, sorting_key_expr);",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": null,
          "new_api": "std::move(*actions)",
          "old_text": null,
          "new_text": "std::move(*actions)",
          "old_line_content": "",
          "new_line_content": "            result_projection = ActionsDAG::merge(std::move(*result_projection), std::move(*actions));",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": null,
          "new_api": "getResultColumns",
          "old_text": null,
          "new_text": "result_projection->getResultColumns()",
          "old_line_content": "    if (sample_factor_column_queried)",
          "new_line_content": "        cur_header = result_projection->getResultColumns();",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": null,
          "new_api": "getHeader",
          "old_text": null,
          "new_text": "std::make_shared<MergingSortedTransform>(\n                        pipe.getHeader(),\n                        pipe.numOutputPorts(),\n                        sort_description,\n                        max_block_size,\n                        0, true)",
          "old_line_content": "                        max_block_size,",
          "new_line_content": "                auto transform = std::make_shared<MergingSortedTransform>(",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": null,
          "new_api": "getHeader",
          "old_text": null,
          "new_text": "pipe.getHeader()",
          "old_line_content": "                        0, true);",
          "new_line_content": "                        pipe.getHeader(),",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": null,
          "new_api": "numOutputPorts",
          "old_text": null,
          "new_text": "pipe.numOutputPorts()",
          "old_line_content": "",
          "new_line_content": "                        pipe.numOutputPorts(),",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": null,
          "new_api": "Field",
          "old_text": null,
          "new_text": "Field(result.sampling.used_sample_factor)",
          "old_line_content": "    }",
          "new_line_content": "        column.column = column.type->createColumnConst(0, Field(result.sampling.used_sample_factor));",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": null,
          "new_api": "std::move(transform)",
          "old_text": null,
          "new_text": "std::move(transform)",
          "old_line_content": "",
          "new_line_content": "                pipe.addTransform(std::move(transform));",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": null,
          "new_api": "std::move(column)",
          "old_text": null,
          "new_text": "std::move(column)",
          "old_line_content": "    /// Extra columns may be returned (for example, if sampling is used).",
          "new_line_content": "        auto adding_column = ActionsDAG::makeAddingColumnActions(std::move(column));",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": null,
          "new_api": "std::move(adding_column)",
          "old_text": null,
          "new_text": "std::move(adding_column)",
          "old_line_content": "    /// Convert pipe to step header structure.",
          "new_line_content": "        append_actions(std::move(adding_column));",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": null,
          "new_api": "std::move(pipes)",
          "old_text": null,
          "new_text": "std::move(pipes)",
          "old_line_content": "    Pipe & pipe,",
          "new_line_content": "    return Pipe::unitePipes(std::move(pipes));",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 515,
          "old_api": "getHeader",
          "new_api": null,
          "old_text": "pipe.getHeader()",
          "new_text": null,
          "old_line_content": "    const auto & header = pipe.getHeader();",
          "new_line_content": "    MergeTreeData::MergingParams merging_params,",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": "numOutputPorts",
          "new_api": null,
          "old_text": "pipe.numOutputPorts()",
          "new_text": null,
          "old_line_content": "    size_t num_outputs = pipe.numOutputPorts();",
          "new_line_content": "    Names partition_key_columns,",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": "std::make_shared<ExpressionActions>(result_projection)",
          "new_api": null,
          "old_text": "std::make_shared<ExpressionActions>(result_projection)",
          "new_text": null,
          "old_line_content": "        auto projection_actions = std::make_shared<ExpressionActions>(result_projection);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": "addSimpleTransform",
          "new_api": null,
          "old_text": "pipe.addSimpleTransform([&](const Block & header)\n        {\n            return std::make_shared<ExpressionTransform>(header, projection_actions);\n        })",
          "new_text": null,
          "old_line_content": "        pipe.addSimpleTransform([&](const Block & header)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": "std::make_shared<ExpressionTransform>(header, projection_actions)",
          "new_api": null,
          "old_text": "std::make_shared<ExpressionTransform>(header, projection_actions)",
          "new_text": null,
          "old_line_content": "            return std::make_shared<ExpressionTransform>(header, projection_actions);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": "std::make_shared<MergingSortedTransform>(header, num_outputs,\n                           sort_description, max_block_size)",
          "new_api": null,
          "old_text": "std::make_shared<MergingSortedTransform>(header, num_outputs,\n                           sort_description, max_block_size)",
          "new_text": null,
          "old_line_content": "                return std::make_shared<MergingSortedTransform>(header, num_outputs,",
          "new_line_content": "        switch (merging_params.mode)",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "processors.emplace_back(processor)",
          "new_text": null,
          "old_line_content": "        processors.emplace_back(processor);",
          "new_line_content": "        });",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": "std::make_shared<CollapsingSortedTransform>(header, num_outputs,\n                           sort_description, merging_params.sign_column, true, max_block_size)",
          "new_api": null,
          "old_text": "std::make_shared<CollapsingSortedTransform>(header, num_outputs,\n                           sort_description, merging_params.sign_column, true, max_block_size)",
          "new_text": null,
          "old_line_content": "                return std::make_shared<CollapsingSortedTransform>(header, num_outputs,",
          "new_line_content": "                           sort_description, max_block_size);",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": "std::move(pipe)",
          "new_api": null,
          "old_text": "std::move(pipe)",
          "new_text": null,
          "old_line_content": "    pipeline.init(std::move(pipe));",
          "new_line_content": "    // Attach QueryIdHolder if needed",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "__builtin_unreachable",
          "new_api": null,
          "old_text": "__builtin_unreachable()",
          "new_text": null,
          "old_line_content": "    __builtin_unreachable();",
          "new_line_content": "        case ReadFromMergeTree::IndexType::Skip:",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": "__builtin_unreachable",
          "new_api": null,
          "old_text": "__builtin_unreachable()",
          "new_text": null,
          "old_line_content": "        __builtin_unreachable();",
          "new_line_content": "            case MergeTreeData::MergingParams::Graphite:",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": "empty",
          "new_api": null,
          "old_text": "sort_description.empty()",
          "new_text": null,
          "old_line_content": "    if (num_output_streams <= 1 || sort_description.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": "get_merging_processor",
          "new_api": null,
          "old_text": "get_merging_processor()",
          "new_text": null,
          "old_line_content": "        pipe.addTransform(get_merging_processor());",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": "size",
          "new_api": null,
          "old_text": "sort_description.size()",
          "new_text": null,
          "old_line_content": "    key_columns.reserve(sort_description.size());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1078,
          "old_api": "__builtin_unreachable",
          "new_api": null,
          "old_text": "__builtin_unreachable()",
          "new_text": null,
          "old_line_content": "    __builtin_unreachable();",
          "new_line_content": "        case ReadFromMergeTree::ReadType::InReverseOrder:",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "getPositionByName",
          "new_api": null,
          "old_text": "header.getPositionByName(desc.column_name)",
          "new_text": null,
          "old_line_content": "            key_columns.push_back(header.getPositionByName(desc.column_name));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "key_columns.emplace_back(desc.column_number)",
          "new_text": null,
          "old_line_content": "            key_columns.emplace_back(desc.column_number);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": "selectRangesToRead",
          "new_api": null,
          "old_text": "selectRangesToRead(prepared_parts)",
          "new_text": null,
          "old_line_content": "    auto result = selectRangesToRead(prepared_parts);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": "addSimpleTransform",
          "new_api": null,
          "old_text": "pipe.addSimpleTransform([&](const Block & stream_header)\n    {\n        return std::make_shared<AddingSelectorTransform>(stream_header, num_output_streams, key_columns);\n    })",
          "new_text": null,
          "old_line_content": "    pipe.addSimpleTransform([&](const Block & stream_header)",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": "readTypeToString",
          "new_api": null,
          "old_text": "readTypeToString(result.read_type)",
          "new_text": null,
          "old_line_content": "    format_settings.out << prefix << \"ReadType: \" << readTypeToString(result.read_type) << '\\n';",
          "new_line_content": "void ReadFromMergeTree::describeActions(FormatSettings & format_settings) const",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": "std::make_shared<AddingSelectorTransform>(stream_header, num_output_streams, key_columns)",
          "new_api": null,
          "old_text": "std::make_shared<AddingSelectorTransform>(stream_header, num_output_streams, key_columns)",
          "new_text": null,
          "old_line_content": "        return std::make_shared<AddingSelectorTransform>(stream_header, num_output_streams, key_columns);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": "transform",
          "new_api": null,
          "old_text": "pipe.transform([&](OutputPortRawPtrs ports)\n    {\n        Processors transforms;\n        std::vector<OutputPorts::iterator> output_ports;\n        transforms.reserve(ports.size() + num_output_streams);\n        output_ports.reserve(ports.size());\n\n        for (auto & port : ports)\n        {\n            auto copier = std::make_shared<CopyTransform>(header, num_output_streams);\n            connect(*port, copier->getInputPort());\n            output_ports.emplace_back(copier->getOutputs().begin());\n            transforms.emplace_back(std::move(copier));\n        }\n\n        for (size_t i = 0; i < num_output_streams; ++i)\n        {\n            auto merge = get_merging_processor();\n            merge->setSelectorPosition(i);\n            auto input = merge->getInputs().begin();\n\n            /// Connect i-th merge with i-th input port of every copier.\n            for (size_t j = 0; j < ports.size(); ++j)\n            {\n                connect(*output_ports[j], *input);\n                ++output_ports[j];\n                ++input;\n            }\n\n            transforms.emplace_back(std::move(merge));\n        }\n\n        return transforms;\n    })",
          "new_text": null,
          "old_line_content": "    pipe.transform([&](OutputPortRawPtrs ports)",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1090,
          "old_api": "back",
          "new_api": null,
          "old_text": "result.index_stats.back()",
          "new_text": null,
          "old_line_content": "        format_settings.out << prefix << \"Granules: \" << result.index_stats.back().num_granules_after << '\\n';",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": "size",
          "new_api": null,
          "old_text": "ports.size()",
          "new_text": null,
          "old_line_content": "        output_ports.reserve(ports.size());",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": "selectRangesToRead",
          "new_api": null,
          "old_text": "selectRangesToRead(prepared_parts)",
          "new_text": null,
          "old_line_content": "    auto result = selectRangesToRead(prepared_parts);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": "readTypeToString",
          "new_api": null,
          "old_text": "readTypeToString(result.read_type)",
          "new_text": null,
          "old_line_content": "    map.add(\"Read Type\", readTypeToString(result.read_type));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": "empty",
          "new_api": null,
          "old_text": "result.index_stats.empty()",
          "new_text": null,
          "old_line_content": "    if (!result.index_stats.empty())",
          "new_line_content": "void ReadFromMergeTree::describeActions(JSONBuilder::JSONMap & map) const",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "getInputPort",
          "new_api": null,
          "old_text": "copier->getInputPort()",
          "new_text": null,
          "old_line_content": "            connect(*port, copier->getInputPort());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": "begin",
          "new_api": null,
          "old_text": "copier->getOutputs().begin()",
          "new_text": null,
          "old_line_content": "            output_ports.emplace_back(copier->getOutputs().begin());",
          "new_line_content": "        for (auto & port : ports)",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": "std::move(copier)",
          "new_api": null,
          "old_text": "std::move(copier)",
          "new_text": null,
          "old_line_content": "            transforms.emplace_back(std::move(copier));",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": "get_merging_processor",
          "new_api": null,
          "old_text": "get_merging_processor()",
          "new_text": null,
          "old_line_content": "            auto merge = get_merging_processor();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "setSelectorPosition",
          "new_api": null,
          "old_text": "merge->setSelectorPosition(i)",
          "new_text": null,
          "old_line_content": "            merge->setSelectorPosition(i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": "begin",
          "new_api": null,
          "old_text": "merge->getInputs().begin()",
          "new_text": null,
          "old_line_content": "            auto input = merge->getInputs().begin();",
          "new_line_content": "        for (size_t i = 0; i < num_output_streams; ++i)",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": "selectRangesToRead",
          "new_api": null,
          "old_text": "selectRangesToRead(prepared_parts)",
          "new_text": null,
          "old_line_content": "    auto result = selectRangesToRead(prepared_parts);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": "std::move(result.index_stats)",
          "new_api": null,
          "old_text": "std::move(result.index_stats)",
          "new_text": null,
          "old_line_content": "    auto index_stats = std::move(result.index_stats);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": "connect",
          "new_api": null,
          "old_text": "connect(*output_ports[j], *input)",
          "new_text": null,
          "old_line_content": "                connect(*output_ports[j], *input);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": "front",
          "new_api": null,
          "old_text": "index_stats.front()",
          "new_text": null,
          "old_line_content": "        if (index_stats.size() == 1 && index_stats.front().type == IndexType::None)",
          "new_line_content": "    std::string prefix(format_settings.offset, format_settings.indent_char);",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": "std::move(merge)",
          "new_api": null,
          "old_text": "std::move(merge)",
          "new_text": null,
          "old_line_content": "            transforms.emplace_back(std::move(merge));",
          "new_line_content": "                ++output_ports[j];",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": "size",
          "new_api": null,
          "old_text": "index_stats.size()",
          "new_text": null,
          "old_line_content": "        for (size_t i = 0; i < index_stats.size(); ++i)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": "indexTypeToString",
          "new_api": null,
          "old_text": "indexTypeToString(stat.type)",
          "new_text": null,
          "old_line_content": "            format_settings.out << prefix << indent << indexTypeToString(stat.type) << '\\n';",
          "new_line_content": "            const auto & stat = index_stats[i];",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": "empty",
          "new_api": null,
          "old_text": "stat.name.empty()",
          "new_text": null,
          "old_line_content": "            if (!stat.name.empty())",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context->getSettingsRef()",
          "new_text": null,
          "old_line_content": "    const auto & settings = context->getSettingsRef();",
          "new_line_content": "    RangesInDataParts && parts_with_ranges,",
          "content_same": false
        },
        {
          "line": 620,
          "old_api": "getSettings",
          "new_api": null,
          "old_text": "data.getSettings()",
          "new_text": null,
          "old_line_content": "    const auto data_settings = data.getSettings();",
          "new_line_content": "    const Names & column_names,",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": "empty",
          "new_api": null,
          "old_text": "stat.description.empty()",
          "new_text": null,
          "old_line_content": "            if (!stat.description.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": "empty",
          "new_api": null,
          "old_text": "stat.used_keys.empty()",
          "new_text": null,
          "old_line_content": "            if (!stat.used_keys.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "empty",
          "new_api": null,
          "old_text": "stat.condition.empty()",
          "new_text": null,
          "old_line_content": "            if (!stat.condition.empty())",
          "new_line_content": "                for (const auto & used_key : stat.used_keys)",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": "begin",
          "new_api": null,
          "old_text": "parts_with_ranges.begin()",
          "new_text": null,
          "old_line_content": "    auto it = parts_with_ranges.begin();",
          "new_line_content": "    /// So we will store iterators pointed to the beginning of each partition range (and parts.end()),",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "parts_to_merge_ranges.push_back(it)",
          "new_text": null,
          "old_line_content": "    parts_to_merge_ranges.push_back(it);",
          "new_line_content": "    /// then we will create a pipe for each partition that will run selecting processor and merging processor",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": "end",
          "new_api": null,
          "old_text": "std::find_if(\n                it, parts_with_ranges.end(), [&it](auto & part) { return it->data_part->info.partition_id != part.data_part->info.partition_id; })",
          "new_text": null,
          "old_line_content": "            it = std::find_if(",
          "new_line_content": "    if (settings.do_not_merge_across_partitions_select_final)",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "end",
          "new_api": null,
          "old_text": "parts_with_ranges.end()",
          "new_text": null,
          "old_line_content": "                it, parts_with_ranges.end(), [&it](auto & part) { return it->data_part->info.partition_id != part.data_part->info.partition_id; });",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "selectRangesToRead",
          "new_api": null,
          "old_text": "selectRangesToRead(prepared_parts)",
          "new_text": null,
          "old_line_content": "    auto result = selectRangesToRead(prepared_parts);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": "std::move(result.index_stats)",
          "new_api": null,
          "old_text": "std::move(result.index_stats)",
          "new_text": null,
          "old_line_content": "    auto index_stats = std::move(result.index_stats);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": "empty",
          "new_api": null,
          "old_text": "index_stats.empty()",
          "new_text": null,
          "old_line_content": "    if (!index_stats.empty())",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": "end",
          "new_api": null,
          "old_text": "parts_with_ranges.end()",
          "new_text": null,
          "old_line_content": "        parts_to_merge_ranges.push_back(parts_with_ranges.end());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": "front",
          "new_api": null,
          "old_text": "index_stats.front()",
          "new_text": null,
          "old_line_content": "        if (index_stats.size() == 1 && index_stats.front().type == IndexType::None)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": "std::make_unique<JSONBuilder::JSONArray>()",
          "new_api": null,
          "old_text": "std::make_unique<JSONBuilder::JSONArray>()",
          "new_text": null,
          "old_line_content": "        auto indexes_array = std::make_unique<JSONBuilder::JSONArray>();",
          "new_line_content": "        /// Do not print anything if no indexes is applied.",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": "size",
          "new_api": null,
          "old_text": "index_stats.size()",
          "new_text": null,
          "old_line_content": "        for (size_t i = 0; i < index_stats.size(); ++i)",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": "size",
          "new_api": null,
          "old_text": "parts_to_merge_ranges.size()",
          "new_text": null,
          "old_line_content": "    for (size_t range_index = 0; range_index < parts_to_merge_ranges.size() - 1; ++range_index)",
          "new_line_content": "    std::vector<RangesInDataPart> lonely_parts;",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": "std::make_unique<JSONBuilder::JSONMap>()",
          "new_api": null,
          "old_text": "std::make_unique<JSONBuilder::JSONMap>()",
          "new_text": null,
          "old_line_content": "            auto index_map = std::make_unique<JSONBuilder::JSONMap>();",
          "new_line_content": "            const auto & stat = index_stats[i];",
          "content_same": false
        },
        {
          "line": 1178,
          "old_api": "indexTypeToString",
          "new_api": null,
          "old_text": "indexTypeToString(stat.type)",
          "new_text": null,
          "old_line_content": "            index_map->add(\"Type\", indexTypeToString(stat.type));",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 1181,
          "old_api": "add",
          "new_api": null,
          "old_text": "index_map->add(\"Name\", stat.name)",
          "new_text": null,
          "old_line_content": "                index_map->add(\"Name\", stat.name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": "empty",
          "new_api": null,
          "old_text": "stat.description.empty()",
          "new_text": null,
          "old_line_content": "            if (!stat.description.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": "empty",
          "new_api": null,
          "old_text": "stat.used_keys.empty()",
          "new_text": null,
          "old_line_content": "            if (!stat.used_keys.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": "std::distance(parts_to_merge_ranges[range_index], parts_to_merge_ranges[range_index + 1])",
          "new_api": null,
          "old_text": "std::distance(parts_to_merge_ranges[range_index], parts_to_merge_ranges[range_index + 1])",
          "new_text": null,
          "old_line_content": "                std::distance(parts_to_merge_ranges[range_index], parts_to_merge_ranges[range_index + 1]) == 1 &&",
          "new_line_content": "            /// with level > 0 then we won't postprocess this part and if num_streams > 1 we",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": "getRowsCount",
          "new_api": null,
          "old_text": "parts_to_merge_ranges[range_index]->getRowsCount()",
          "new_text": null,
          "old_line_content": "                total_rows_in_lonely_parts += parts_to_merge_ranges[range_index]->getRowsCount();",
          "new_line_content": "            if (num_streams > 1 && settings.do_not_merge_across_partitions_select_final &&",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "add",
          "new_api": null,
          "old_text": "keys_array->add(used_key)",
          "new_text": null,
          "old_line_content": "                    keys_array->add(used_key);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": "std::move(*parts_to_merge_ranges[range_index])",
          "new_api": null,
          "old_text": "std::move(*parts_to_merge_ranges[range_index])",
          "new_text": null,
          "old_line_content": "                lonely_parts.push_back(std::move(*parts_to_merge_ranges[range_index]));",
          "new_line_content": "                parts_to_merge_ranges[range_index]->data_part->info.level > 0)",
          "content_same": false
        },
        {
          "line": 1193,
          "old_api": "std::move(keys_array)",
          "new_api": null,
          "old_text": "std::move(keys_array)",
          "new_text": null,
          "old_line_content": "                index_map->add(\"Keys\", std::move(keys_array));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": "empty",
          "new_api": null,
          "old_text": "stat.condition.empty()",
          "new_text": null,
          "old_line_content": "            if (!stat.condition.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "new_parts.emplace_back(part_it->data_part, part_it->part_index_in_query, part_it->ranges)",
          "new_text": null,
          "old_line_content": "                    new_parts.emplace_back(part_it->data_part, part_it->part_index_in_query, part_it->ranges);",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": "std::move(new_parts)",
          "new_api": null,
          "old_text": "std::move(new_parts)",
          "new_text": null,
          "old_line_content": "            pipe = read(std::move(new_parts), column_names, ReadFromMergeTree::ReadType::InOrder,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1207,
          "old_api": "std::move(index_map)",
          "new_api": null,
          "old_text": "std::move(index_map)",
          "new_text": null,
          "old_line_content": "            indexes_array->add(std::move(index_map));",
          "new_line_content": "            if (i)",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "std::move(indexes_array)",
          "new_api": null,
          "old_text": "std::move(indexes_array)",
          "new_text": null,
          "old_line_content": "        map.add(\"Indexes\", std::move(indexes_array));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": "getHeader",
          "new_api": null,
          "old_text": "pipe.getHeader()",
          "new_text": null,
          "old_line_content": "                out_projection = createProjection(pipe.getHeader());",
          "new_line_content": "                num_streams, 0, info.use_uncompressed_cache);",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": "clone",
          "new_api": null,
          "old_text": "std::make_shared<ExpressionActions>(\n            metadata_snapshot->getSortingKey().expression->getActionsDAG().clone())",
          "new_text": null,
          "old_line_content": "        auto sorting_expr = std::make_shared<ExpressionActions>(",
          "new_line_content": "            if (!out_projection)",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": "addSimpleTransform",
          "new_api": null,
          "old_text": "pipe.addSimpleTransform([sorting_expr](const Block & header)\n        {\n            return std::make_shared<ExpressionTransform>(header, sorting_expr);\n        })",
          "new_text": null,
          "old_line_content": "        pipe.addSimpleTransform([sorting_expr](const Block & header)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": "std::distance(parts_to_merge_ranges[range_index], parts_to_merge_ranges[range_index + 1])",
          "new_api": null,
          "old_text": "std::distance(parts_to_merge_ranges[range_index], parts_to_merge_ranges[range_index + 1])",
          "new_text": null,
          "old_line_content": "            std::distance(parts_to_merge_ranges[range_index], parts_to_merge_ranges[range_index + 1]) == 1 &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": "std::move(pipe)",
          "new_api": null,
          "old_text": "std::move(pipe)",
          "new_text": null,
          "old_line_content": "            partition_pipes.emplace_back(std::move(pipe));",
          "new_line_content": "        if (settings.do_not_merge_across_partitions_select_final &&",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": "size",
          "new_api": null,
          "old_text": "sort_columns.size()",
          "new_text": null,
          "old_line_content": "        size_t sort_columns_size = sort_columns.size();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "sort_description.reserve(sort_columns_size)",
          "new_text": null,
          "old_line_content": "        sort_description.reserve(sort_columns_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "getPartitionKey",
          "new_api": null,
          "old_text": "metadata_snapshot->getPartitionKey()",
          "new_text": null,
          "old_line_content": "        Names partition_key_columns = metadata_snapshot->getPartitionKey().column_names;",
          "new_line_content": "        SortDescription sort_description;",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": "std::move(pipe)",
          "new_api": null,
          "old_text": "std::move(pipe)",
          "new_text": null,
          "old_line_content": "        partition_pipes.emplace_back(std::move(pipe));",
          "new_line_content": "            pipe,",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "empty",
          "new_api": null,
          "old_text": "lonely_parts.empty()",
          "new_text": null,
          "old_line_content": "    if (!lonely_parts.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": "MergeTreeDataSelectExecutor::minMarksForConcurrentRead(\n            settings.merge_tree_min_rows_for_concurrent_read,\n            settings.merge_tree_min_bytes_for_concurrent_read,\n            data_settings->index_granularity,\n            info.index_granularity_bytes,\n            sum_marks_in_lonely_parts)",
          "new_api": null,
          "old_text": "MergeTreeDataSelectExecutor::minMarksForConcurrentRead(\n            settings.merge_tree_min_rows_for_concurrent_read,\n            settings.merge_tree_min_bytes_for_concurrent_read,\n            data_settings->index_granularity,\n            info.index_granularity_bytes,\n            sum_marks_in_lonely_parts)",
          "new_text": null,
          "old_line_content": "        const size_t min_marks_for_concurrent_read = MergeTreeDataSelectExecutor::minMarksForConcurrentRead(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": "size",
          "new_api": null,
          "old_text": "lonely_parts.size()",
          "new_text": null,
          "old_line_content": "        if (sum_marks_in_lonely_parts < num_streams_for_lonely_parts * min_marks_for_concurrent_read && lonely_parts.size() < num_streams_for_lonely_parts)",
          "new_line_content": "            info.index_granularity_bytes,",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": "size",
          "new_api": null,
          "old_text": "lonely_parts.size()",
          "new_text": null,
          "old_line_content": "            num_streams_for_lonely_parts = std::max((sum_marks_in_lonely_parts + min_marks_for_concurrent_read - 1) / min_marks_for_concurrent_read, lonely_parts.size());",
          "new_line_content": "            sum_marks_in_lonely_parts);",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "std::move(lonely_parts)",
          "new_api": null,
          "old_text": "std::move(lonely_parts)",
          "new_text": null,
          "old_line_content": "        auto pipe = read(std::move(lonely_parts), column_names, ReadFromMergeTree::ReadType::Default,",
          "new_line_content": "        /// Reduce the number of num_streams_for_lonely_parts if the data is small.",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "getHeader",
          "new_api": null,
          "old_text": "pipe.getHeader()",
          "new_text": null,
          "old_line_content": "            out_projection = createProjection(pipe.getHeader());",
          "new_line_content": "                num_streams_for_lonely_parts, min_marks_for_concurrent_read, info.use_uncompressed_cache);",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": "clone",
          "new_api": null,
          "old_text": "std::make_shared<ExpressionActions>(\n            metadata_snapshot->getSortingKey().expression->getActionsDAG().clone())",
          "new_text": null,
          "old_line_content": "        auto sorting_expr = std::make_shared<ExpressionActions>(",
          "new_line_content": "        /// Drop temporary columns, added by 'sorting_key_expr'",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": "clone",
          "new_api": null,
          "old_text": "metadata_snapshot->getSortingKey().expression->getActionsDAG().clone()",
          "new_text": null,
          "old_line_content": "            metadata_snapshot->getSortingKey().expression->getActionsDAG().clone());",
          "new_line_content": "        if (!out_projection)",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": "addSimpleTransform",
          "new_api": null,
          "old_text": "pipe.addSimpleTransform([sorting_expr](const Block & header)\n        {\n            return std::make_shared<ExpressionTransform>(header, sorting_expr);\n        })",
          "new_text": null,
          "old_line_content": "        pipe.addSimpleTransform([sorting_expr](const Block & header)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": "std::move(pipe)",
          "new_api": null,
          "old_text": "std::move(pipe)",
          "new_text": null,
          "old_line_content": "        partition_pipes.emplace_back(std::move(pipe));",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "std::move(partition_pipes)",
          "new_api": null,
          "old_text": "std::move(partition_pipes)",
          "new_text": null,
          "old_line_content": "    return Pipe::unitePipes(std::move(partition_pipes));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context->getSettingsRef()",
          "new_text": null,
          "old_line_content": "    const auto & settings = context->getSettingsRef();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": "size",
          "new_api": null,
          "old_text": "parts.size()",
          "new_text": null,
          "old_line_content": "    size_t total_parts = parts.size();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": "empty",
          "new_api": null,
          "old_text": "part_values->empty()",
          "new_text": null,
          "old_line_content": "    if (part_values && part_values->empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": "empty",
          "new_api": null,
          "old_text": "result.column_names_to_read.empty()",
          "new_text": null,
          "old_line_content": "    if (result.column_names_to_read.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": "getAllPhysical",
          "new_api": null,
          "old_text": "metadata_snapshot->getColumns().getAllPhysical()",
          "new_text": null,
          "old_line_content": "        NamesAndTypesList available_real_columns = metadata_snapshot->getColumns().getAllPhysical();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": "ExpressionActions::getSmallestColumn(available_real_columns)",
          "new_api": null,
          "old_text": "ExpressionActions::getSmallestColumn(available_real_columns)",
          "new_text": null,
          "old_line_content": "        result.column_names_to_read.push_back(ExpressionActions::getSmallestColumn(available_real_columns));",
          "new_line_content": "    /// If there are only virtual columns in the query, you must request at least one non-virtual one.",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "getPrimaryKey",
          "new_api": null,
          "old_text": "metadata_snapshot->getPrimaryKey()",
          "new_text": null,
          "old_line_content": "    const auto & primary_key = metadata_snapshot->getPrimaryKey();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\n            ErrorCodes::INDEX_NOT_USED,\n            \"Primary key ({}) is not used and setting 'force_primary_key' is set.\",\n            fmt::join(primary_key_columns, \", \"))",
          "new_text": null,
          "old_line_content": "        throw Exception(",
          "new_line_content": "    KeyCondition key_condition(query_info, context, primary_key_columns, primary_key.expression);",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": "fmt::join(primary_key_columns, \", \")",
          "new_api": null,
          "old_text": "fmt::join(primary_key_columns, \", \")",
          "new_text": null,
          "old_line_content": "            fmt::join(primary_key_columns, \", \"));",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": "toString",
          "new_api": null,
          "old_text": "key_condition.toString()",
          "new_text": null,
          "old_line_content": "    LOG_DEBUG(log, \"Key condition: {}\", key_condition.toString());",
          "new_line_content": "            ErrorCodes::INDEX_NOT_USED,",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": "getAllPhysical",
          "new_api": null,
          "old_text": "metadata_snapshot->getColumns().getAllPhysical()",
          "new_text": null,
          "old_line_content": "        select, metadata_snapshot->getColumns().getAllPhysical(), parts, key_condition,",
          "new_line_content": "        parts, part_values, metadata_snapshot_base, data, query_info, context,",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "getMarksCountWithoutFinal",
          "new_api": null,
          "old_text": "part->index_granularity.getMarksCountWithoutFinal()",
          "new_text": null,
          "old_line_content": "        total_marks_pk += part->index_granularity.getMarksCountWithoutFinal();",
          "new_line_content": "        return result;",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": "size",
          "new_api": null,
          "old_text": "parts.size()",
          "new_text": null,
          "old_line_content": "    size_t parts_before_pk = parts.size();",
          "new_line_content": "    size_t total_marks_pk = 0;",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": "std::move(parts)",
          "new_api": null,
          "old_text": "std::move(parts)",
          "new_text": null,
          "old_line_content": "        std::move(parts),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": "size",
          "new_api": null,
          "old_text": "part.ranges.size()",
          "new_text": null,
          "old_line_content": "        sum_ranges += part.ranges.size();",
          "new_line_content": "    size_t sum_rows = 0;",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "getMarksCount",
          "new_api": null,
          "old_text": "part.getMarksCount()",
          "new_text": null,
          "old_line_content": "        sum_marks += part.getMarksCount();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": "getRowsCount",
          "new_api": null,
          "old_text": "part.getRowsCount()",
          "new_text": null,
          "old_line_content": "        sum_rows += part.getRowsCount();",
          "new_line_content": "    for (const auto & part : result.parts_with_ranges)",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": "size",
          "new_api": null,
          "old_text": "LOG_DEBUG(\n        log,\n        \"Selected {}/{} parts by partition key, {} parts by primary key, {}/{} marks by primary key, {} marks to read from {} ranges\",\n        parts_before_pk,\n        total_parts,\n        result.parts_with_ranges.size(),\n        sum_marks_pk,\n        total_marks_pk,\n        sum_marks,\n        sum_ranges)",
          "new_text": null,
          "old_line_content": "    LOG_DEBUG(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": "size",
          "new_api": null,
          "old_text": "result.parts_with_ranges.size()",
          "new_text": null,
          "old_line_content": "        result.parts_with_ranges.size(),",
          "new_line_content": "        log,",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": "size",
          "new_api": null,
          "old_text": "result.parts_with_ranges.size()",
          "new_text": null,
          "old_line_content": "    ProfileEvents::increment(ProfileEvents::SelectedParts, result.parts_with_ranges.size());",
          "new_line_content": "        total_marks_pk,",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "ProfileEvents::increment(ProfileEvents::SelectedRanges, sum_ranges)",
          "new_api": null,
          "old_text": "ProfileEvents::increment(ProfileEvents::SelectedRanges, sum_ranges)",
          "new_text": null,
          "old_line_content": "    ProfileEvents::increment(ProfileEvents::SelectedRanges, sum_ranges);",
          "new_line_content": "        sum_marks,",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": "ProfileEvents::increment(ProfileEvents::SelectedMarks, sum_marks)",
          "new_api": null,
          "old_text": "ProfileEvents::increment(ProfileEvents::SelectedMarks, sum_marks)",
          "new_text": null,
          "old_line_content": "    ProfileEvents::increment(ProfileEvents::SelectedMarks, sum_marks);",
          "new_line_content": "        sum_ranges);",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": "selectRangesToRead",
          "new_api": null,
          "old_text": "selectRangesToRead(prepared_parts)",
          "new_text": null,
          "old_line_content": "    auto result = selectRangesToRead(prepared_parts);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": "MergeTreeDataSelectExecutor::checkLimits(data, result.parts_with_ranges, context)",
          "new_api": null,
          "old_text": "MergeTreeDataSelectExecutor::checkLimits(data, result.parts_with_ranges, context)",
          "new_text": null,
          "old_line_content": "    auto query_id_holder = MergeTreeDataSelectExecutor::checkLimits(data, result.parts_with_ranges, context);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": "empty",
          "new_api": null,
          "old_text": "result.parts_with_ranges.empty()",
          "new_text": null,
          "old_line_content": "    if (result.parts_with_ranges.empty())",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": "std::move(result.column_names_to_read)",
          "new_api": null,
          "old_text": "std::move(result.column_names_to_read)",
          "new_text": null,
          "old_line_content": "    Names column_names_to_read = std::move(result.column_names_to_read);",
          "new_line_content": "    /// of some extra expressions, and to allow execute the same expressions later.",
          "content_same": false
        },
        {
          "line": 910,
          "old_api": "query_info.query->as<ASTSelectQuery &>()",
          "new_api": null,
          "old_text": "query_info.query->as<ASTSelectQuery &>()",
          "new_text": null,
          "old_line_content": "    const auto & select = query_info.query->as<ASTSelectQuery &>();",
          "new_line_content": "    /// NOTE: It may lead to double computation of expressions.",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": "final",
          "new_api": null,
          "old_text": "select.final()",
          "new_text": null,
          "old_line_content": "    if (!select.final() && result.sampling.use_sampling)",
          "new_line_content": "    ActionsDAGPtr result_projection;",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": "end",
          "new_api": null,
          "old_text": "add_columns.end()",
          "new_text": null,
          "old_line_content": "        column_names_to_read.insert(column_names_to_read.end(), add_columns.begin(), add_columns.end());",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": "end",
          "new_api": null,
          "old_text": "column_names_to_read.end()",
          "new_text": null,
          "old_line_content": "        std::sort(column_names_to_read.begin(), column_names_to_read.end());",
          "new_line_content": "        /// Add columns needed for `sample_by_ast` to `column_names_to_read`.",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": "end",
          "new_api": null,
          "old_text": "column_names_to_read.end()",
          "new_text": null,
          "old_line_content": "        column_names_to_read.erase(std::unique(column_names_to_read.begin(), column_names_to_read.end()),",
          "new_line_content": "        /// Skip this if final was used, because such columns were already added from PK.",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "back",
          "new_api": null,
          "old_text": "info.sum_marks_in_parts.back()",
          "new_text": null,
          "old_line_content": "            size_t & marks_in_part = info.sum_marks_in_parts.back();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context->getSettingsRef()",
          "new_text": null,
          "old_line_content": "    const auto & settings = context->getSettingsRef();",
          "new_line_content": "        : (query_info.projection ? query_info.projection->input_order_info : nullptr);",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "final",
          "new_api": null,
          "old_text": "select.final()",
          "new_text": null,
          "old_line_content": "    if (select.final())",
          "new_line_content": "    Pipe pipe;",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "getColumnsRequiredForSortingKey",
          "new_api": null,
          "old_text": "metadata_snapshot->getColumnsRequiredForSortingKey()",
          "new_text": null,
          "old_line_content": "        std::vector<String> add_columns = metadata_snapshot->getColumnsRequiredForSortingKey();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": "empty",
          "new_api": null,
          "old_text": "data.merging_params.sign_column.empty()",
          "new_text": null,
          "old_line_content": "        if (!data.merging_params.sign_column.empty())",
          "new_line_content": "        /// Add columns needed to calculate the sorting expression and the sign.",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "column_names_to_read.push_back(data.merging_params.version_column)",
          "new_text": null,
          "old_line_content": "            column_names_to_read.push_back(data.merging_params.version_column);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "spreadMarkRangesAmongStreamsFinal",
          "new_api": null,
          "old_text": "spreadMarkRangesAmongStreamsFinal(\n            std::move(result.parts_with_ranges),\n            column_names_to_read,\n            result_projection)",
          "new_text": null,
          "old_line_content": "        pipe = spreadMarkRangesAmongStreamsFinal(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": "pop_back",
          "new_api": null,
          "old_text": "info.sum_marks_in_parts.pop_back()",
          "new_text": null,
          "old_line_content": "                info.sum_marks_in_parts.pop_back();",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": "size",
          "new_api": null,
          "old_text": "input_order_info->order_key_prefix_descr.size()",
          "new_text": null,
          "old_line_content": "        size_t prefix_size = input_order_info->order_key_prefix_descr.size();",
          "new_line_content": "            result_projection);",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": "empty",
          "new_api": null,
          "old_text": "part.ranges.empty()",
          "new_text": null,
          "old_line_content": "                    if (part.ranges.empty())",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Unexpected end of ranges while spreading marks among streams\",\n                                        ErrorCodes::LOGICAL_ERROR)",
          "new_text": null,
          "old_line_content": "                        throw Exception(\"Unexpected end of ranges while spreading marks among streams\",",
          "new_line_content": "                /// Loop through ranges in part. Take enough ranges to cover \"need_marks\".",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": "getSortingKey",
          "new_api": null,
          "old_text": "metadata_snapshot->getSortingKey().expression_list_ast->clone()",
          "new_text": null,
          "old_line_content": "        auto order_key_prefix_ast = metadata_snapshot->getSortingKey().expression_list_ast->clone();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "resize",
          "new_api": null,
          "old_text": "order_key_prefix_ast->children.resize(prefix_size)",
          "new_text": null,
          "old_line_content": "        order_key_prefix_ast->children.resize(prefix_size);",
          "new_line_content": "    else if ((settings.optimize_read_in_order || settings.optimize_aggregation_in_order) && input_order_info)",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": "spreadMarkRangesAmongStreamsWithOrder",
          "new_api": null,
          "old_text": "spreadMarkRangesAmongStreamsWithOrder(\n            std::move(result.parts_with_ranges),\n            column_names_to_read,\n            sorting_key_prefix_expr,\n            result_projection,\n            input_order_info)",
          "new_text": null,
          "old_line_content": "        pipe = spreadMarkRangesAmongStreamsWithOrder(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": "std::min(marks_in_range, need_marks)",
          "new_api": null,
          "old_text": "std::min(marks_in_range, need_marks)",
          "new_text": null,
          "old_line_content": "                    const size_t marks_to_get_from_range = std::min(marks_in_range, need_marks);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "ranges_to_get_from_part.emplace_back(range.begin, range.begin + marks_to_get_from_range)",
          "new_text": null,
          "old_line_content": "                    ranges_to_get_from_part.emplace_back(range.begin, range.begin + marks_to_get_from_range);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": "pop_front",
          "new_api": null,
          "old_text": "part.ranges.pop_front()",
          "new_text": null,
          "old_line_content": "                        part.ranges.pop_front();",
          "new_line_content": "                    range.begin += marks_to_get_from_range;",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": "spreadMarkRangesAmongStreams",
          "new_api": null,
          "old_text": "spreadMarkRangesAmongStreams(\n            std::move(result.parts_with_ranges),\n            column_names_to_read)",
          "new_text": null,
          "old_line_content": "        pipe = spreadMarkRangesAmongStreams(",
          "new_line_content": "            input_order_info);",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "parts_with_ranges.emplace_back(part)",
          "new_text": null,
          "old_line_content": "                parts_with_ranges.emplace_back(part);",
          "new_line_content": "                    need_marks -= marks_to_get_from_range;",
          "content_same": false
        },
        {
          "line": 968,
          "old_api": "std::move(result.parts_with_ranges)",
          "new_api": null,
          "old_text": "std::move(result.parts_with_ranges)",
          "new_text": null,
          "old_line_content": "            std::move(result.parts_with_ranges),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "split_ranges",
          "new_api": null,
          "old_text": "split_ranges(ranges_to_get_from_part, input_order_info->direction)",
          "new_text": null,
          "old_line_content": "            ranges_to_get_from_part = split_ranges(ranges_to_get_from_part, input_order_info->direction);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": "getOutputStream",
          "new_api": null,
          "old_text": "getOutputStream()",
          "new_text": null,
          "old_line_content": "        pipeline.init(Pipe(std::make_shared<NullSource>(getOutputStream().header)));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "std::move(new_parts)",
          "new_api": null,
          "old_text": "std::move(new_parts)",
          "new_text": null,
          "old_line_content": "        pipes.emplace_back(readInOrder(std::move(new_parts), column_names, read_type,",
          "new_line_content": "        auto read_type = input_order_info->direction == 1",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": "std::make_shared<ExpressionActions>(result.sampling.filter_expression)",
          "new_api": null,
          "old_text": "std::make_shared<ExpressionActions>(result.sampling.filter_expression)",
          "new_text": null,
          "old_line_content": "        auto sampling_actions = std::make_shared<ExpressionActions>(result.sampling.filter_expression);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": "addSimpleTransform",
          "new_api": null,
          "old_text": "pipe.addSimpleTransform([&](const Block & header)\n        {\n            return std::make_shared<FilterTransform>(\n                header,\n                sampling_actions,\n                result.sampling.filter_function->getColumnName(),\n                false);\n        })",
          "new_text": null,
          "old_line_content": "        pipe.addSimpleTransform([&](const Block & header)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "getColumnName",
          "new_api": null,
          "old_text": "std::make_shared<FilterTransform>(\n                header,\n                sampling_actions,\n                result.sampling.filter_function->getColumnName(),\n                false)",
          "new_text": null,
          "old_line_content": "            return std::make_shared<FilterTransform>(",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": "size",
          "new_api": null,
          "old_text": "input_order_info->order_key_prefix_descr.size()",
          "new_text": null,
          "old_line_content": "        for (size_t j = 0; j < input_order_info->order_key_prefix_descr.size(); ++j)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": "getSortingKey",
          "new_api": null,
          "old_text": "metadata_snapshot->getSortingKey()",
          "new_text": null,
          "old_line_content": "            sort_description.emplace_back(metadata_snapshot->getSortingKey().column_names[j],",
          "new_line_content": "    if (need_preliminary_merge)",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": "getColumnName",
          "new_api": null,
          "old_text": "result.sampling.filter_function->getColumnName()",
          "new_text": null,
          "old_line_content": "                result.sampling.filter_function->getColumnName(),",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": "getResultColumns",
          "new_api": null,
          "old_text": "result_projection->getResultColumns()",
          "new_text": null,
          "old_line_content": "    Block cur_header = result_projection ? result_projection->getResultColumns()",
          "new_line_content": "                false);",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": "getHeader",
          "new_api": null,
          "old_text": "pipe.getHeader()",
          "new_text": null,
          "old_line_content": "                                         : pipe.getHeader();",
          "new_line_content": "        });",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": "getHeader",
          "new_api": null,
          "old_text": "pipe.getHeader()",
          "new_text": null,
          "old_line_content": "            out_projection = createProjection(pipe.getHeader());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": "addSimpleTransform",
          "new_api": null,
          "old_text": "pipe.addSimpleTransform([sorting_key_expr](const Block & header)\n            {\n                return std::make_shared<ExpressionTransform>(header, sorting_key_expr);\n            })",
          "new_text": null,
          "old_line_content": "            pipe.addSimpleTransform([sorting_key_expr](const Block & header)",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": "std::move(actions)",
          "new_api": null,
          "old_text": "std::move(actions)",
          "new_text": null,
          "old_line_content": "            result_projection = std::move(actions);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "std::move(*actions)",
          "new_api": null,
          "old_text": "std::move(*actions)",
          "new_text": null,
          "old_line_content": "            result_projection = ActionsDAG::merge(std::move(*result_projection), std::move(*actions));",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": "numOutputPorts",
          "new_api": null,
          "old_text": "pipe.numOutputPorts()",
          "new_text": null,
          "old_line_content": "            if (pipe.numOutputPorts() > 1)",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": "getHeader",
          "new_api": null,
          "old_text": "std::make_shared<MergingSortedTransform>(\n                        pipe.getHeader(),\n                        pipe.numOutputPorts(),\n                        sort_description,\n                        max_block_size,\n                        0, true)",
          "new_text": null,
          "old_line_content": "                auto transform = std::make_shared<MergingSortedTransform>(",
          "new_line_content": "            });",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": "getHeader",
          "new_api": null,
          "old_text": "pipe.getHeader()",
          "new_text": null,
          "old_line_content": "                        pipe.getHeader(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": "std::make_shared<DataTypeFloat64>()",
          "new_api": null,
          "old_text": "std::make_shared<DataTypeFloat64>()",
          "new_text": null,
          "old_line_content": "        column.type = std::make_shared<DataTypeFloat64>();",
          "new_line_content": "    if (sample_factor_column_queried)",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": "Field",
          "new_api": null,
          "old_text": "Field(result.sampling.used_sample_factor)",
          "new_text": null,
          "old_line_content": "        column.column = column.type->createColumnConst(0, Field(result.sampling.used_sample_factor));",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": "std::move(transform)",
          "new_api": null,
          "old_text": "std::move(transform)",
          "new_text": null,
          "old_line_content": "                pipe.addTransform(std::move(transform));",
          "new_line_content": "                        sort_description,",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "std::move(column)",
          "new_api": null,
          "old_text": "std::move(column)",
          "new_text": null,
          "old_line_content": "        auto adding_column = ActionsDAG::makeAddingColumnActions(std::move(column));",
          "new_line_content": "        column.name = \"_sample_factor\";",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": "std::move(pipes)",
          "new_api": null,
          "old_text": "std::move(pipes)",
          "new_text": null,
          "old_line_content": "    return Pipe::unitePipes(std::move(pipes));",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": "getOutputStream",
          "new_api": null,
          "old_text": "getOutputStream()",
          "new_text": null,
          "old_line_content": "    if (!isCompatibleHeader(cur_header, getOutputStream().header))",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "getColumnsWithTypeAndName",
          "new_api": null,
          "old_text": "ActionsDAG::makeConvertingActions(\n            cur_header.getColumnsWithTypeAndName(),\n            getOutputStream().header.getColumnsWithTypeAndName(),\n            ActionsDAG::MatchColumnsMode::Name)",
          "new_text": null,
          "old_line_content": "        auto converting = ActionsDAG::makeConvertingActions(",
          "new_line_content": "    /// Extra columns may be returned (for example, if sampling is used).",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": "getColumnsWithTypeAndName",
          "new_api": null,
          "old_text": "cur_header.getColumnsWithTypeAndName()",
          "new_text": null,
          "old_line_content": "            cur_header.getColumnsWithTypeAndName(),",
          "new_line_content": "    /// Convert pipe to step header structure.",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 64,
      "total_additions": 171,
      "total_deletions": 170,
      "total_api_changes": 405
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 7,
        "api_related_lines": 405,
        "non_api_lines": 5,
        "non_api_line_numbers": [
          426,
          427,
          428,
          430,
          432
        ]
      }
    },
    "api_calls_before": 415,
    "api_calls_after": 416,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 2,
      "total_diff_lines": 28
    }
  }
}