{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/eaccddc51b92d3bcccdb9b760f57e75a6e87a688",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/eaccddc51b92d3bcccdb9b760f57e75a6e87a688/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/eaccddc51b92d3bcccdb9b760f57e75a6e87a688/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/eaccddc51b92d3bcccdb9b760f57e75a6e87a688/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 528,
          "old_api": "data",
          "new_api": "alloc",
          "old_text": "inst->batch_that->addBatchLookupTable8(\n                rows,\n                reinterpret_cast<AggregateDataPtr *>(method.data.data()),\n                inst->state_offset,\n                [&](AggregateDataPtr & aggregate_data)\n                {\n                    aggregate_data = aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);\n                    createAggregateStates(aggregate_data);\n                },\n                state.getKeyData(),\n                inst->batch_arguments,\n                aggregates_pool)",
          "new_text": "aggregates_pool->alloc(0)",
          "old_line_content": "            inst->batch_that->addBatchLookupTable8(",
          "new_line_content": "        AggregateDataPtr place = aggregates_pool->alloc(0);",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": "data",
          "new_api": "emplaceKey",
          "old_text": "method.data.data()",
          "new_text": "state.emplaceKey(method.data, i, *aggregates_pool).setMapped(place)",
          "old_line_content": "                reinterpret_cast<AggregateDataPtr *>(method.data.data()),",
          "new_line_content": "            state.emplaceKey(method.data, i, *aggregates_pool).setMapped(place);",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "data",
          "new_api": "setMapped",
          "old_text": "places.data()",
          "new_text": "emplace_result.setMapped(aggregate_data)",
          "old_line_content": "            inst->batch_that->addBatchArray(rows, places.data(), inst->state_offset, inst->batch_arguments, inst->offsets, aggregates_pool);",
          "new_line_content": "            emplace_result.setMapped(aggregate_data);",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": "resize",
          "new_api": "addBatchSinglePlaceFromInterval",
          "old_text": "aggregate_functions_instructions.resize(params.aggregates_size + 1)",
          "new_text": "inst->batch_that->addBatchSinglePlaceFromInterval(inst->offsets[row_begin], inst->offsets[row_end - 1], res + inst->state_offset, inst->batch_arguments, arena)",
          "old_line_content": "    aggregate_functions_instructions.resize(params.aggregates_size + 1);",
          "new_line_content": "            inst->batch_that->addBatchSinglePlaceFromInterval(inst->offsets[row_begin], inst->offsets[row_end - 1], res + inst->state_offset, inst->batch_arguments, arena);",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": "get",
          "new_api": "size",
          "old_text": "column_no_lc.get()",
          "new_text": "params.aggregates[i].arguments.size()",
          "old_line_content": "            if (column_no_lc.get() != aggregate_columns[i][j])",
          "new_line_content": "        aggregate_columns[i].resize(params.aggregates[i].arguments.size());",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": "std::move(column_no_lc)",
          "new_api": "resize",
          "old_text": "std::move(column_no_lc)",
          "new_text": "aggregate_functions_instructions.resize(params.aggregates_size + 1)",
          "old_line_content": "                materialized_columns.emplace_back(std::move(column_no_lc));",
          "new_line_content": "    aggregate_functions_instructions.resize(params.aggregates_size + 1);",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "data",
          "new_api": "size",
          "old_text": "aggregate_columns[i].data()",
          "new_text": "aggregate_columns[i].size()",
          "old_line_content": "        aggregate_functions_instructions[i].arguments = aggregate_columns[i].data();",
          "new_line_content": "        for (size_t j = 0; j < aggregate_columns[i].size(); ++j)",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "get",
          "new_api": "getPtr",
          "old_text": "func->getNestedFunction().get()",
          "new_text": "aggregate_columns[i][j]->getPtr()",
          "old_line_content": "            that = func->getNestedFunction().get();",
          "new_line_content": "            auto column_no_lc = recursiveRemoveLowCardinality(aggregate_columns[i][j]->getPtr());",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": "typeid_cast<const AggregateFunctionArray *>(that)",
          "new_api": "back",
          "old_text": "typeid_cast<const AggregateFunctionArray *>(that)",
          "new_text": "materialized_columns.back().get()",
          "old_line_content": "        if (const auto * func = typeid_cast<const AggregateFunctionArray *>(that))",
          "new_line_content": "                aggregate_columns[i][j] = materialized_columns.back().get();",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": "typeid_cast<const AggregateFunctionState *>(that)",
          "new_api": "data",
          "old_text": "typeid_cast<const AggregateFunctionState *>(that)",
          "new_text": "aggregate_columns[i].data()",
          "old_line_content": "            while (const auto * nested_func = typeid_cast<const AggregateFunctionState *>(that))",
          "new_line_content": "        aggregate_functions_instructions[i].arguments = aggregate_columns[i].data();",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": "back",
          "new_api": "typeid_cast<const AggregateFunctionState *>(that)",
          "old_text": "nested_columns_holder.back().data()",
          "new_text": "typeid_cast<const AggregateFunctionState *>(that)",
          "old_line_content": "            aggregate_functions_instructions[i].batch_arguments = nested_columns_holder.back().data();",
          "new_line_content": "        while (const auto * func = typeid_cast<const AggregateFunctionState *>(that))",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "alignedAlloc",
          "new_api": "back",
          "old_text": "result.aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states)",
          "new_text": "materialized_columns.back().get()",
          "old_line_content": "        AggregateDataPtr place = result.aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);",
          "new_line_content": "                key_columns[i] = materialized_columns.back().get();",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": "APPLY_FOR_AGGREGATED_VARIANTS",
          "new_api": "data",
          "old_text": "APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "new_text": "aggregate_functions_instructions.data()",
          "old_line_content": "        APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "new_line_content": "        executeWithoutKeyImpl(result.without_key, num_rows, aggregate_functions_instructions.data(), result.aggregates_pool);",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": "isConvertibleToTwoLevel",
          "new_api": "getParent",
          "old_text": "result.isConvertibleToTwoLevel()",
          "new_text": "memory_tracker_child->getParent()",
          "old_line_content": "    if (result.isConvertibleToTwoLevel() && worth_convert_to_two_level)",
          "new_line_content": "        if (auto * memory_tracker = memory_tracker_child->getParent())",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "convertToTwoLevel",
          "new_api": "get",
          "old_text": "result.convertToTwoLevel()",
          "new_text": "memory_tracker->get()",
          "old_line_content": "        result.convertToTwoLevel();",
          "new_line_content": "            current_memory_usage = memory_tracker->get();",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": "getDisk",
          "new_api": "checkLimits",
          "old_text": "params.tmp_volume->getDisk()->getPath()",
          "new_text": "checkLimits(result_size, no_more_keys)",
          "old_line_content": "        std::string tmp_path = params.tmp_volume->getDisk()->getPath();",
          "new_line_content": "    if (!checkLimits(result_size, no_more_keys))",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "size",
          "new_api": "enoughSpaceInDirectory",
          "old_text": "data_variants.size()",
          "new_text": "enoughSpaceInDirectory(tmp_path, size)",
          "old_line_content": "    size_t rows = data_variants.size();",
          "new_line_content": "        if (!enoughSpaceInDirectory(tmp_path, size))",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": "path",
          "new_api": "writeToTemporaryFile",
          "old_text": "file->path()",
          "new_text": "writeToTemporaryFile(result, tmp_path)",
          "old_line_content": "    const std::string & path = file->path();",
          "new_line_content": "        writeToTemporaryFile(result, tmp_path);",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": "next",
          "new_api": "APPLY_FOR_VARIANTS_TWO_LEVEL",
          "old_text": "file_buf.next()",
          "new_text": "APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "old_line_content": "    file_buf.next();",
          "new_line_content": "    APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": "std::move(file)",
          "new_api": "back",
          "old_text": "std::move(file)",
          "new_text": "data_variants.aggregates_pools.back().get()",
          "old_line_content": "        temporary_files.files.emplace_back(std::move(file));",
          "new_line_content": "    data_variants.aggregates_pool = data_variants.aggregates_pools.back().get();",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": "ProfileEvents::increment(ProfileEvents::ExternalAggregationCompressedBytes, compressed_bytes)",
          "new_api": "next",
          "old_text": "ProfileEvents::increment(ProfileEvents::ExternalAggregationCompressedBytes, compressed_bytes)",
          "new_text": "file_buf.next()",
          "old_line_content": "    ProfileEvents::increment(ProfileEvents::ExternalAggregationCompressedBytes, compressed_bytes);",
          "new_line_content": "    file_buf.next();",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": "LOG_TRACE",
          "new_api": "count",
          "old_text": "LOG_TRACE(log,\n        \"Written part in {} sec., {} rows, {} uncompressed, {} compressed,\"\n        \" {} uncompressed bytes per row, {} compressed bytes per row, compression rate: {}\"\n        \" ({} rows/sec., {}/sec. uncompressed, {}/sec. compressed)\",\n        elapsed_seconds,\n        rows,\n        ReadableSize(uncompressed_bytes),\n        ReadableSize(compressed_bytes),\n        uncompressed_bytes / rows,\n        compressed_bytes / rows,\n        uncompressed_bytes / compressed_bytes,\n        rows / elapsed_seconds,\n        ReadableSize(uncompressed_bytes / elapsed_seconds),\n        ReadableSize(compressed_bytes / elapsed_seconds))",
          "new_text": "file_buf.count()",
          "old_line_content": "    LOG_TRACE(log,",
          "new_line_content": "    double compressed_bytes = file_buf.count();",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": "ReadableSize",
          "new_api": "LOG_TRACE",
          "old_text": "ReadableSize(compressed_bytes / elapsed_seconds)",
          "new_text": "LOG_TRACE(log,\n        \"Written part in {} sec., {} rows, {} uncompressed, {} compressed,\"\n        \" {} uncompressed bytes per row, {} compressed bytes per row, compression rate: {}\"\n        \" ({} rows/sec., {}/sec. uncompressed, {}/sec. compressed)\",\n        elapsed_seconds,\n        rows,\n        ReadableSize(uncompressed_bytes),\n        ReadableSize(compressed_bytes),\n        uncompressed_bytes / rows,\n        compressed_bytes / rows,\n        uncompressed_bytes / compressed_bytes,\n        rows / elapsed_seconds,\n        ReadableSize(uncompressed_bytes / elapsed_seconds),\n        ReadableSize(compressed_bytes / elapsed_seconds))",
          "old_line_content": "        ReadableSize(compressed_bytes / elapsed_seconds));",
          "new_line_content": "    LOG_TRACE(log,",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": "getDisk",
          "new_api": "ReadableSize",
          "old_text": "params.tmp_volume->getDisk()->getPath()",
          "new_text": "ReadableSize(uncompressed_bytes)",
          "old_line_content": "    String tmp_path = params.tmp_volume->getDisk()->getPath();",
          "new_line_content": "        ReadableSize(uncompressed_bytes),",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": "writeToTemporaryFile",
          "new_api": "ReadableSize",
          "old_text": "writeToTemporaryFile(data_variants, tmp_path)",
          "new_text": "ReadableSize(compressed_bytes)",
          "old_line_content": "    return writeToTemporaryFile(data_variants, tmp_path);",
          "new_line_content": "        ReadableSize(compressed_bytes),",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": "update_max_sizes",
          "new_api": "rows",
          "old_text": "update_max_sizes(block)",
          "new_text": "block.rows()",
          "old_line_content": "        update_max_sizes(block);",
          "new_line_content": "        size_t block_size_rows = block.rows();",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": "LOG_TRACE",
          "new_api": "isCancelled",
          "old_text": "LOG_TRACE(log, \"Aggregating\")",
          "new_text": "isCancelled()",
          "old_line_content": "    LOG_TRACE(log, \"Aggregating\");",
          "new_line_content": "    if (isCancelled())",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": "rows",
          "new_api": "LOG_TRACE",
          "old_text": "block.rows()",
          "new_text": "LOG_TRACE(log, \"Aggregating\")",
          "old_line_content": "        src_rows += block.rows();",
          "new_line_content": "    LOG_TRACE(log, \"Aggregating\");",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": "getHeader",
          "new_api": "isCancelled",
          "old_text": "stream->getHeader()",
          "new_text": "isCancelled()",
          "old_line_content": "        executeOnBlock(stream->getHeader(), result, key_columns, aggregate_columns, no_more_keys);",
          "new_line_content": "        if (isCancelled())",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": "sizeWithoutOverflowRow",
          "new_api": "rows",
          "old_text": "result.sizeWithoutOverflowRow()",
          "new_text": "block.rows()",
          "old_line_content": "    size_t rows = result.sizeWithoutOverflowRow();",
          "new_line_content": "        src_rows += block.rows();",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": "ReadableSize",
          "new_api": "executeOnBlock",
          "old_text": "ReadableSize(src_bytes)",
          "new_text": "executeOnBlock(block, result, key_columns, aggregate_columns, no_more_keys)",
          "old_line_content": "        src_rows, rows, ReadableSize(src_bytes),",
          "new_line_content": "        if (!executeOnBlock(block, result, key_columns, aggregate_columns, no_more_keys))",
          "content_same": false
        },
        {
          "line": 1177,
          "old_api": "hasNullKeyData",
          "new_api": "insertAggregatesIntoColumns",
          "old_text": "data.hasNullKeyData()",
          "new_text": "insertAggregatesIntoColumns(mapped, final_aggregate_columns, arena)",
          "old_line_content": "        if (data.hasNullKeyData())",
          "new_line_content": "        insertAggregatesIntoColumns(mapped, final_aggregate_columns, arena);",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": "insertKeyIntoColumns",
          "new_api": "hasNullKeyData",
          "old_text": "method.insertKeyIntoColumns(key, key_columns, key_sizes)",
          "new_text": "data.hasNullKeyData()",
          "old_line_content": "        method.insertKeyIntoColumns(key, key_columns, key_sizes);",
          "new_line_content": "        if (data.hasNullKeyData())",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": "getByName",
          "new_api": "getHeader",
          "old_text": "header.getByName(aggregate_column_name).type->createColumn()",
          "new_text": "getHeader(final)",
          "old_line_content": "            aggregate_columns[i] = header.getByName(aggregate_column_name).type->createColumn();",
          "new_line_content": "    Block header = getHeader(final);",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": "getReturnType",
          "new_api": "getByName",
          "old_text": "aggregate_functions[i]->getReturnType()->createColumn()",
          "new_text": "header.getByName(aggregate_column_name).type->createColumn()",
          "old_line_content": "            final_aggregate_columns[i] = aggregate_functions[i]->getReturnType()->createColumn();",
          "new_line_content": "            aggregate_columns[i] = header.getByName(aggregate_column_name).type->createColumn();",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": "isState",
          "new_api": "assert_cast<ColumnAggregateFunction &>(*aggregate_columns[i])",
          "old_text": "aggregate_functions[i]->isState()",
          "new_text": "assert_cast<ColumnAggregateFunction &>(*aggregate_columns[i])",
          "old_line_content": "            if (aggregate_functions[i]->isState())",
          "new_line_content": "            ColumnAggregateFunction & column_aggregate_func = assert_cast<ColumnAggregateFunction &>(*aggregate_columns[i]);",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "get",
          "new_api": "addArena",
          "old_text": "final_aggregate_columns[i].get()",
          "new_text": "column_aggregate_func.addArena(pool)",
          "old_line_content": "                if (auto * column_aggregate_func = typeid_cast<ColumnAggregateFunction *>(final_aggregate_columns[i].get()))",
          "new_line_content": "                column_aggregate_func.addArena(pool);",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": "addArena",
          "new_api": "getData",
          "old_text": "column_aggregate_func->addArena(pool)",
          "new_text": "column_aggregate_func.getData()",
          "old_line_content": "                        column_aggregate_func->addArena(pool);",
          "new_line_content": "            aggregate_columns_data[i] = &column_aggregate_func.getData();",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": "get",
          "new_api": "getReturnType",
          "old_text": "subcolumn.get()",
          "new_text": "aggregate_functions[i]->getReturnType()->createColumn()",
          "old_line_content": "                    if (auto * column_aggregate_func = typeid_cast<ColumnAggregateFunction *>(subcolumn.get()))",
          "new_line_content": "            final_aggregate_columns[i] = aggregate_functions[i]->getReturnType()->createColumn();",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": "filler",
          "new_api": "addArena",
          "old_text": "filler(key_columns, aggregate_columns_data, final_aggregate_columns, data_variants.aggregates_pool, final)",
          "new_text": "column_aggregate_func->addArena(pool)",
          "old_line_content": "    filler(key_columns, aggregate_columns_data, final_aggregate_columns, data_variants.aggregates_pool, final);",
          "new_line_content": "                        column_aggregate_func->addArena(pool);",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": "std::move(key_columns[i])",
          "new_api": "get",
          "old_text": "std::move(key_columns[i])",
          "new_text": "subcolumn.get()",
          "old_line_content": "        res.getByPosition(i).column = std::move(key_columns[i]);",
          "new_line_content": "                    if (auto * column_aggregate_func = typeid_cast<ColumnAggregateFunction *>(subcolumn.get()))",
          "content_same": false
        },
        {
          "line": 1273,
          "old_api": "std::move(aggregate_columns[i])",
          "new_api": "filler",
          "old_text": "std::move(aggregate_columns[i])",
          "new_text": "filler(key_columns, aggregate_columns_data, final_aggregate_columns, data_variants.aggregates_pool, final)",
          "old_line_content": "            res.getByName(aggregate_column_name).column = std::move(aggregate_columns[i]);",
          "new_line_content": "    filler(key_columns, aggregate_columns_data, final_aggregate_columns, data_variants.aggregates_pool, final);",
          "content_same": false
        },
        {
          "line": 1293,
          "old_api": "assert_cast<ColumnAggregateFunction &>(*final_aggregate_columns[i])",
          "new_api": "getByPosition",
          "old_text": "assert_cast<ColumnAggregateFunction &>(*final_aggregate_columns[i])",
          "new_text": "res.getByPosition(i).column->cut(0, rows)",
          "old_line_content": "        ColumnAggregateFunction & column_aggregate_func = assert_cast<ColumnAggregateFunction &>(*final_aggregate_columns[i]);",
          "new_line_content": "            res.getByPosition(i).column = res.getByPosition(i).column->cut(0, rows);",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": "alignedAlloc",
          "new_api": "addArena",
          "old_text": "data_variants.aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states)",
          "new_text": "column_aggregate_func.addArena(pool)",
          "old_line_content": "    AggregateDataPtr place = data_variants.aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);",
          "new_line_content": "            column_aggregate_func.addArena(pool);",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": "sizeWithoutOverflowRow",
          "new_api": "prepareBlockAndFill",
          "old_text": "data_variants.sizeWithoutOverflowRow()",
          "new_text": "prepareBlockAndFill(data_variants, final, rows, filler)",
          "old_line_content": "    size_t rows = data_variants.sizeWithoutOverflowRow();",
          "new_line_content": "    Block block = prepareBlockAndFill(data_variants, final, rows, filler);",
          "content_same": false
        },
        {
          "line": 1446,
          "old_api": "wait",
          "new_api": "tasks[bucket]()",
          "old_text": "thread_pool->wait()",
          "new_text": "tasks[bucket]()",
          "old_line_content": "        thread_pool->wait();",
          "new_line_content": "                tasks[bucket]();",
          "content_same": false
        },
        {
          "line": 1465,
          "old_api": "BlocksList",
          "new_api": "valid",
          "old_text": "BlocksList()",
          "new_text": "task.valid()",
          "old_line_content": "        return BlocksList();",
          "new_line_content": "        if (!task.valid())",
          "content_same": false
        },
        {
          "line": 1478,
          "old_api": "sizeWithoutOverflowRow",
          "new_api": "BlocksList",
          "old_text": "data_variants.sizeWithoutOverflowRow()",
          "new_text": "BlocksList()",
          "old_line_content": "    if (max_threads > 1 && data_variants.sizeWithoutOverflowRow() > 100000  /// TODO Make a custom threshold.",
          "new_line_content": "        return BlocksList();",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": "std::make_unique<ThreadPool>(max_threads)",
          "new_api": "LOG_TRACE",
          "old_text": "std::make_unique<ThreadPool>(max_threads)",
          "new_text": "LOG_TRACE(log, \"Converting aggregated data to blocks\")",
          "old_line_content": "        thread_pool = std::make_unique<ThreadPool>(max_threads);",
          "new_line_content": "    LOG_TRACE(log, \"Converting aggregated data to blocks\");",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": "prepareBlockAndFillSingleLevel",
          "new_api": "isCancelled",
          "old_text": "prepareBlockAndFillSingleLevel(data_variants, final)",
          "new_text": "isCancelled()",
          "old_line_content": "            blocks.emplace_back(prepareBlockAndFillSingleLevel(data_variants, final));",
          "new_line_content": "    if (isCancelled())",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": "isCancelled",
          "new_api": "isTwoLevel",
          "old_text": "isCancelled()",
          "new_text": "data_variants.isTwoLevel()",
          "old_line_content": "    if (isCancelled())",
          "new_line_content": "        if (!data_variants.isTwoLevel())",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": "BlocksList",
          "new_api": "prepareBlockAndFillSingleLevel",
          "old_text": "BlocksList()",
          "new_text": "prepareBlockAndFillSingleLevel(data_variants, final)",
          "old_line_content": "        return BlocksList();",
          "new_line_content": "            blocks.emplace_back(prepareBlockAndFillSingleLevel(data_variants, final));",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": "LOG_TRACE",
          "new_api": "isCancelled",
          "old_text": "LOG_TRACE(log,\n        \"Converted aggregated data to blocks. {} rows, {} in {} sec. ({} rows/sec., {}/sec.)\",\n        rows, ReadableSize(bytes),\n        elapsed_seconds, rows / elapsed_seconds,\n        ReadableSize(bytes / elapsed_seconds))",
          "new_text": "isCancelled()",
          "old_line_content": "    LOG_TRACE(log,",
          "new_line_content": "    if (isCancelled())",
          "content_same": false
        },
        {
          "line": 1555,
          "old_api": "getNullKeyData",
          "new_api": "hasNullKeyData",
          "old_text": "table_src.getNullKeyData()",
          "new_text": "table_dst.hasNullKeyData()",
          "old_line_content": "                            table_src.getNullKeyData() + offsets_of_aggregate_states[i]);",
          "new_line_content": "                table_dst.hasNullKeyData() = true;",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": "mergeDataNullKey<Method, Table>(table_dst, table_src, arena)",
          "new_api": "getNullKeyData",
          "old_text": "mergeDataNullKey<Method, Table>(table_dst, table_src, arena)",
          "new_text": "table_src.getNullKeyData()",
          "old_line_content": "        mergeDataNullKey<Method, Table>(table_dst, table_src, arena);",
          "new_line_content": "            table_src.getNullKeyData() = nullptr;",
          "content_same": false
        },
        {
          "line": 1608,
          "old_api": "mergeDataNullKey<Method, Table>(table_dst, table_src, arena)",
          "new_api": "clearAndShrink",
          "old_text": "mergeDataNullKey<Method, Table>(table_dst, table_src, arena)",
          "new_text": "table_src.clearAndShrink()",
          "old_line_content": "        mergeDataNullKey<Method, Table>(table_dst, table_src, arena);",
          "new_line_content": "    table_src.clearAndShrink();",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": "destroy",
          "new_api": "mergeDataNullKey<Method, Table>(table_dst, table_src, arena)",
          "old_text": "aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i])",
          "new_text": "mergeDataNullKey<Method, Table>(table_dst, table_src, arena)",
          "old_line_content": "            aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i]);",
          "new_line_content": "        mergeDataNullKey<Method, Table>(table_dst, table_src, arena);",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": "mergeToViaFind",
          "new_api": "clearAndShrink",
          "old_text": "table_src.mergeToViaFind(table_dst,\n        [&](AggregateDataPtr dst, AggregateDataPtr & src, bool found)\n    {\n        if (!found)\n            return;\n\n        for (size_t i = 0; i < params.aggregates_size; ++i)\n            aggregate_functions[i]->merge(\n                dst + offsets_of_aggregate_states[i],\n                src + offsets_of_aggregate_states[i],\n                arena);\n\n        for (size_t i = 0; i < params.aggregates_size; ++i)\n            aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i]);\n\n        src = nullptr;\n    })",
          "new_text": "table_src.clearAndShrink()",
          "old_line_content": "    table_src.mergeToViaFind(table_dst,",
          "new_line_content": "    table_src.clearAndShrink();",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": "destroy",
          "new_api": "mergeToViaFind",
          "old_text": "aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i])",
          "new_text": "table_src.mergeToViaFind(table_dst,\n        [&](AggregateDataPtr dst, AggregateDataPtr & src, bool found)\n    {\n        if (!found)\n            return;\n\n        for (size_t i = 0; i < params.aggregates_size; ++i)\n            aggregate_functions[i]->merge(\n                dst + offsets_of_aggregate_states[i],\n                src + offsets_of_aggregate_states[i],\n                arena);\n\n        for (size_t i = 0; i < params.aggregates_size; ++i)\n            aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i]);\n\n        src = nullptr;\n    })",
          "old_line_content": "            aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i]);",
          "new_line_content": "    table_src.mergeToViaFind(table_dst,",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": "mergeDataNoMoreKeysImpl<Method>(\n                getDataVariant<Method>(*res).data,\n                res->without_key,\n                getDataVariant<Method>(current).data,\n                res->aggregates_pool)",
          "new_api": "size",
          "old_text": "mergeDataNoMoreKeysImpl<Method>(\n                getDataVariant<Method>(*res).data,\n                res->without_key,\n                getDataVariant<Method>(current).data,\n                res->aggregates_pool)",
          "new_text": "non_empty_data.size()",
          "old_line_content": "            mergeDataNoMoreKeysImpl<Method>(",
          "new_line_content": "    for (size_t result_num = 1, size = non_empty_data.size(); result_num < size; ++result_num)",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": "getDataVariant<Method>(current)",
          "new_api": "mergeDataImpl<Method>(\n                getDataVariant<Method>(*res).data,\n                getDataVariant<Method>(current).data,\n                res->aggregates_pool)",
          "old_text": "getDataVariant<Method>(current)",
          "new_text": "mergeDataImpl<Method>(\n                getDataVariant<Method>(*res).data,\n                getDataVariant<Method>(current).data,\n                res->aggregates_pool)",
          "old_line_content": "                getDataVariant<Method>(current).data,",
          "new_line_content": "            mergeDataImpl<Method>(",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": "APPLY_FOR_VARIANTS_SINGLE_LEVEL",
          "new_api": "mergeDataOnlyExistingKeysImpl<Method>(\n                getDataVariant<Method>(*res).data,\n                getDataVariant<Method>(current).data,\n                res->aggregates_pool)",
          "old_text": "APPLY_FOR_VARIANTS_SINGLE_LEVEL(M)",
          "new_text": "mergeDataOnlyExistingKeysImpl<Method>(\n                getDataVariant<Method>(*res).data,\n                getDataVariant<Method>(current).data,\n                res->aggregates_pool)",
          "old_line_content": "    APPLY_FOR_VARIANTS_SINGLE_LEVEL(M)",
          "new_line_content": "            mergeDataOnlyExistingKeysImpl<Method>(",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": "scheduleThreadForNextBucket",
          "new_api": "APPLY_FOR_VARIANTS_SINGLE_LEVEL",
          "old_text": "scheduleThreadForNextBucket()",
          "new_text": "APPLY_FOR_VARIANTS_SINGLE_LEVEL(M)",
          "old_line_content": "                    scheduleThreadForNextBucket();",
          "new_line_content": "            APPLY_FOR_VARIANTS_SINGLE_LEVEL(M)",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": "end",
          "new_api": "scheduleThreadForNextBucket",
          "old_text": "parallel_merge_data->ready_blocks.end()",
          "new_text": "scheduleThreadForNextBucket()",
          "old_line_content": "                if (it != parallel_merge_data->ready_blocks.end())",
          "new_line_content": "                    scheduleThreadForNextBucket();",
          "content_same": false
        },
        {
          "line": 1917,
          "old_api": "at",
          "new_api": "setThreadName",
          "old_text": "merged_data.aggregates_pools.at(thread_number).get()",
          "new_text": "setThreadName(\"MergingAggregtd\")",
          "old_line_content": "            Arena * arena = merged_data.aggregates_pools.at(thread_number).get();",
          "new_line_content": "            setThreadName(\"MergingAggregtd\");",
          "content_same": false
        },
        {
          "line": 1940,
          "old_api": "notify_all",
          "new_api": "APPLY_FOR_VARIANTS_TWO_LEVEL",
          "old_text": "parallel_merge_data->condvar.notify_all()",
          "new_text": "APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "old_line_content": "        parallel_merge_data->condvar.notify_all();",
          "new_line_content": "            APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "content_same": false
        },
        {
          "line": 1960,
          "old_api": "size",
          "new_api": "Exception",
          "old_text": "non_empty_data.size()",
          "new_text": "Exception(\"Empty data passed to Aggregator::mergeAndConvertToBlocks.\", ErrorCodes::EMPTY_DATA_PASSED)",
          "old_line_content": "    if (non_empty_data.size() > 1)",
          "new_line_content": "        throw Exception(\"Empty data passed to Aggregator::mergeAndConvertToBlocks.\", ErrorCodes::EMPTY_DATA_PASSED);",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": "isTwoLevel",
          "new_api": "end",
          "old_text": "variant->isTwoLevel()",
          "new_text": "non_empty_data.end()",
          "old_line_content": "        if (variant->isTwoLevel())",
          "new_line_content": "        std::sort(non_empty_data.begin(), non_empty_data.end(),",
          "content_same": false
        },
        {
          "line": 1998,
          "old_api": "end",
          "new_api": "isTwoLevel",
          "old_text": "first->aggregates_pools.end()",
          "new_text": "variant->isTwoLevel()",
          "old_line_content": "        first->aggregates_pools.insert(first->aggregates_pools.end(),",
          "new_line_content": "            if (!variant->isTwoLevel())",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": "end",
          "new_api": "convertToTwoLevel",
          "old_text": "non_empty_data[i]->aggregates_pools.end()",
          "new_text": "variant->convertToTwoLevel()",
          "old_line_content": "            non_empty_data[i]->aggregates_pools.begin(), non_empty_data[i]->aggregates_pools.end());",
          "new_line_content": "                variant->convertToTwoLevel();",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": "getHeader",
          "new_api": "end",
          "old_text": "getHeader(final)",
          "new_text": "first->aggregates_pools.end()",
          "old_line_content": "        return std::make_unique<NullBlockInputStream>(getHeader(final));",
          "new_line_content": "        first->aggregates_pools.insert(first->aggregates_pools.end(),",
          "content_same": false
        },
        {
          "line": 2048,
          "old_api": "emplaceKey",
          "new_api": "getByName",
          "old_text": "state.emplaceKey(data, i, *aggregates_pool)",
          "new_text": "block.getByName(aggregate_column_name)",
          "old_line_content": "            auto emplace_result = state.emplaceKey(data, i, *aggregates_pool);",
          "new_line_content": "        aggregate_columns[i] = &typeid_cast<const ColumnAggregateFunction &>(*block.getByName(aggregate_column_name).column).getData();",
          "content_same": false
        },
        {
          "line": 2054,
          "old_api": "createAggregateStates",
          "new_api": "rows",
          "old_text": "createAggregateStates(aggregate_data)",
          "new_text": "block.rows()",
          "old_line_content": "                createAggregateStates(aggregate_data);",
          "new_line_content": "    size_t rows = block.rows();",
          "content_same": false
        },
        {
          "line": 2064,
          "old_api": "isFound",
          "new_api": "setMapped",
          "old_text": "find_result.isFound()",
          "new_text": "emplace_result.setMapped(nullptr)",
          "old_line_content": "            if (find_result.isFound())",
          "new_line_content": "                emplace_result.setMapped(nullptr);",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": "merge",
          "new_api": "getMapped",
          "old_text": "aggregate_functions[j]->merge(\n                value + offsets_of_aggregate_states[j],\n                (*aggregate_columns[j])[i],\n                aggregates_pool)",
          "new_text": "find_result.getMapped()",
          "old_line_content": "            aggregate_functions[j]->merge(",
          "new_line_content": "                aggregate_data = find_result.getMapped();",
          "content_same": false
        },
        {
          "line": 2098,
          "old_api": "mergeStreamsImplCase<false>(block, aggregates_pool, method, data, overflow_row)",
          "new_api": "clear",
          "old_text": "mergeStreamsImplCase<false>(block, aggregates_pool, method, data, overflow_row)",
          "new_text": "block.clear()",
          "old_line_content": "        mergeStreamsImplCase<false>(block, aggregates_pool, method, data, overflow_row);",
          "new_line_content": "    block.clear();",
          "content_same": false
        },
        {
          "line": 2127,
          "old_api": "merge",
          "new_api": "getByName",
          "old_text": "aggregate_functions[i]->merge(res + offsets_of_aggregate_states[i], (*aggregate_columns[i])[0], result.aggregates_pool)",
          "new_text": "block.getByName(aggregate_column_name)",
          "old_line_content": "        aggregate_functions[i]->merge(res + offsets_of_aggregate_states[i], (*aggregate_columns[i])[0], result.aggregates_pool);",
          "new_line_content": "        aggregate_columns[i] = &typeid_cast<const ColumnAggregateFunction &>(*block.getByName(aggregate_column_name).column).getData();",
          "content_same": false
        },
        {
          "line": 2174,
          "old_api": "rows",
          "new_api": "LOG_TRACE",
          "old_text": "block.rows()",
          "new_text": "LOG_TRACE(log, \"Read {} blocks of partially aggregated data, total {} rows.\", total_input_blocks, total_input_rows)",
          "old_line_content": "            total_input_rows += block.rows();",
          "new_line_content": "    LOG_TRACE(log, \"Read {} blocks of partially aggregated data, total {} rows.\", total_input_blocks, total_input_rows);",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": "LOG_TRACE",
          "new_api": "back",
          "old_text": "LOG_TRACE(log, \"Merged partially aggregated two-level data.\")",
          "new_text": "result.aggregates_pools.back().get()",
          "old_line_content": "        LOG_TRACE(log, \"Merged partially aggregated two-level data.\");",
          "new_line_content": "            Arena * aggregates_pool = result.aggregates_pools.back().get();",
          "content_same": false
        },
        {
          "line": 2268,
          "old_api": "invalidate",
          "new_api": "scheduleOrThrowOnError",
          "old_text": "result.invalidate()",
          "new_text": "thread_pool->scheduleOrThrowOnError(task)",
          "old_line_content": "        result.invalidate();",
          "new_line_content": "                thread_pool->scheduleOrThrowOnError(task);",
          "content_same": false
        },
        {
          "line": 2274,
          "old_api": "LOG_TRACE",
          "new_api": "wait",
          "old_text": "LOG_TRACE(log, \"Merging partially aggregated single-level data.\")",
          "new_text": "thread_pool->wait()",
          "old_line_content": "        LOG_TRACE(log, \"Merging partially aggregated single-level data.\");",
          "new_line_content": "            thread_pool->wait();",
          "content_same": false
        },
        {
          "line": 2281,
          "old_api": "isCancelled",
          "new_api": "invalidate",
          "old_text": "isCancelled()",
          "new_text": "result.invalidate()",
          "old_line_content": "            if (isCancelled())",
          "new_line_content": "        result.invalidate();",
          "content_same": false
        },
        {
          "line": 2287,
          "old_api": "sizeWithoutOverflowRow",
          "new_api": "LOG_TRACE",
          "old_text": "result.sizeWithoutOverflowRow()",
          "new_text": "LOG_TRACE(log, \"Merging partially aggregated single-level data.\")",
          "old_line_content": "            if (!checkLimits(result.sizeWithoutOverflowRow(), no_more_keys))",
          "new_line_content": "        LOG_TRACE(log, \"Merging partially aggregated single-level data.\");",
          "content_same": false
        },
        {
          "line": 2300,
          "old_api": "Exception",
          "new_api": "sizeWithoutOverflowRow",
          "old_text": "Exception(\"Unknown aggregated data variant.\", ErrorCodes::UNKNOWN_AGGREGATED_DATA_VARIANT)",
          "new_text": "result.sizeWithoutOverflowRow()",
          "old_line_content": "                throw Exception(\"Unknown aggregated data variant.\", ErrorCodes::UNKNOWN_AGGREGATED_DATA_VARIANT);",
          "new_line_content": "            if (!checkLimits(result.sizeWithoutOverflowRow(), no_more_keys))",
          "content_same": false
        },
        {
          "line": 2310,
          "old_api": "empty",
          "new_api": "APPLY_FOR_AGGREGATED_VARIANTS",
          "old_text": "blocks.empty()",
          "new_text": "APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "old_line_content": "    if (blocks.empty())",
          "new_line_content": "            APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "content_same": false
        },
        {
          "line": 2313,
          "old_api": "front",
          "new_api": "Exception",
          "old_text": "blocks.front()",
          "new_text": "Exception(\"Unknown aggregated data variant.\", ErrorCodes::UNKNOWN_AGGREGATED_DATA_VARIANT)",
          "old_line_content": "    auto bucket_num = blocks.front().info.bucket_num;",
          "new_line_content": "                throw Exception(\"Unknown aggregated data variant.\", ErrorCodes::UNKNOWN_AGGREGATED_DATA_VARIANT);",
          "content_same": false
        },
        {
          "line": 2361,
          "old_api": "mergeWithoutKeyStreamsImpl",
          "new_api": "init",
          "old_text": "mergeWithoutKeyStreamsImpl(block, result)",
          "new_text": "result.init(merge_method)",
          "old_line_content": "            mergeWithoutKeyStreamsImpl(block, result);",
          "new_line_content": "    result.init(merge_method);",
          "content_same": false
        },
        {
          "line": 2367,
          "old_api": "APPLY_FOR_AGGREGATED_VARIANTS",
          "new_api": "isCancelled",
          "old_text": "APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "new_text": "isCancelled()",
          "old_line_content": "        APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "new_line_content": "        if (isCancelled())",
          "content_same": false
        },
        {
          "line": 2380,
          "old_api": "prepareBlockAndFillSingleLevel",
          "new_api": "APPLY_FOR_AGGREGATED_VARIANTS",
          "old_text": "prepareBlockAndFillSingleLevel(result, final)",
          "new_text": "APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "old_line_content": "        block = prepareBlockAndFillSingleLevel(result, final);",
          "new_line_content": "        APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "content_same": false
        },
        {
          "line": 2391,
          "old_api": "elapsedSeconds",
          "new_api": "prepareBlockAndFillWithoutKey",
          "old_text": "watch.elapsedSeconds()",
          "new_text": "prepareBlockAndFillWithoutKey(result, final, is_overflows)",
          "old_line_content": "    double elapsed_seconds = watch.elapsedSeconds();",
          "new_line_content": "        block = prepareBlockAndFillWithoutKey(result, final, is_overflows);",
          "content_same": false
        },
        {
          "line": 2393,
          "old_api": "ReadableSize",
          "new_api": "prepareBlockAndFillSingleLevel",
          "old_text": "ReadableSize(bytes)",
          "new_text": "prepareBlockAndFillSingleLevel(result, final)",
          "old_line_content": "        rows, ReadableSize(bytes),",
          "new_line_content": "        block = prepareBlockAndFillSingleLevel(result, final);",
          "content_same": false
        },
        {
          "line": 2453,
          "old_api": "std::move(scattered_columns[bucket])",
          "new_api": "size",
          "old_text": "std::move(scattered_columns[bucket])",
          "new_text": "destinations.size()",
          "old_line_content": "                dst.insert({std::move(scattered_columns[bucket]), src_col.type, src_col.name});",
          "new_line_content": "    size_t num_buckets = destinations.size();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2061,
          "old_api": null,
          "new_api": "emplaceKey",
          "old_text": null,
          "new_text": "state.emplaceKey(data, i, *aggregates_pool)",
          "old_line_content": "        else",
          "new_line_content": "            auto emplace_result = state.emplaceKey(data, i, *aggregates_pool);",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": null,
          "new_api": "isInserted",
          "old_text": null,
          "new_text": "emplace_result.isInserted()",
          "old_line_content": "        {",
          "new_line_content": "            if (emplace_result.isInserted())",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": null,
          "new_api": "alignedAlloc",
          "old_text": null,
          "new_text": "aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states)",
          "old_line_content": "        }",
          "new_line_content": "                aggregate_data = aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);",
          "content_same": false
        },
        {
          "line": 2067,
          "old_api": null,
          "new_api": "createAggregateStates",
          "old_text": null,
          "new_text": "createAggregateStates(aggregate_data)",
          "old_line_content": "",
          "new_line_content": "                createAggregateStates(aggregate_data);",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": null,
          "new_api": "setMapped",
          "old_text": null,
          "new_text": "emplace_result.setMapped(aggregate_data)",
          "old_line_content": "",
          "new_line_content": "                emplace_result.setMapped(aggregate_data);",
          "content_same": false
        },
        {
          "line": 2072,
          "old_api": null,
          "new_api": "getMapped",
          "old_text": null,
          "new_text": "emplace_result.getMapped()",
          "old_line_content": "            continue;",
          "new_line_content": "                aggregate_data = emplace_result.getMapped();",
          "content_same": false
        },
        {
          "line": 2076,
          "old_api": null,
          "new_api": "findKey",
          "old_text": null,
          "new_text": "state.findKey(data, i, *aggregates_pool)",
          "old_line_content": "        /// Merge state of aggregate functions.",
          "new_line_content": "            auto find_result = state.findKey(data, i, *aggregates_pool);",
          "content_same": false
        },
        {
          "line": 2077,
          "old_api": null,
          "new_api": "isFound",
          "old_text": null,
          "new_text": "find_result.isFound()",
          "old_line_content": "        for (size_t j = 0; j < params.aggregates_size; ++j)",
          "new_line_content": "            if (find_result.isFound())",
          "content_same": false
        },
        {
          "line": 2091,
          "old_api": null,
          "new_api": "merge",
          "old_text": null,
          "new_text": "aggregate_functions[j]->merge(\n                value + offsets_of_aggregate_states[j],\n                (*aggregate_columns[j])[i],\n                aggregates_pool)",
          "old_line_content": "    Arena * aggregates_pool,",
          "new_line_content": "            aggregate_functions[j]->merge(",
          "content_same": false
        },
        {
          "line": 2111,
          "old_api": null,
          "new_api": "mergeStreamsImplCase<false>(block, aggregates_pool, method, data, overflow_row)",
          "old_text": null,
          "new_text": "mergeStreamsImplCase<false>(block, aggregates_pool, method, data, overflow_row)",
          "old_line_content": "    for (size_t i = 0; i < params.aggregates_size; ++i)",
          "new_line_content": "        mergeStreamsImplCase<false>(block, aggregates_pool, method, data, overflow_row);",
          "content_same": false
        },
        {
          "line": 2113,
          "old_api": null,
          "new_api": "mergeStreamsImplCase<true>(block, aggregates_pool, method, data, overflow_row)",
          "old_text": null,
          "new_text": "mergeStreamsImplCase<true>(block, aggregates_pool, method, data, overflow_row)",
          "old_line_content": "        const auto & aggregate_column_name = params.aggregates[i].column_name;",
          "new_line_content": "        mergeStreamsImplCase<true>(block, aggregates_pool, method, data, overflow_row);",
          "content_same": false
        },
        {
          "line": 2133,
          "old_api": null,
          "new_api": "alignedAlloc",
          "old_text": null,
          "new_text": "result.aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states)",
          "old_line_content": "",
          "new_line_content": "        AggregateDataPtr place = result.aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);",
          "content_same": false
        },
        {
          "line": 2134,
          "old_api": null,
          "new_api": "createAggregateStates",
          "old_text": null,
          "new_text": "createAggregateStates(place)",
          "old_line_content": "void Aggregator::mergeStream(const BlockInputStreamPtr & stream, AggregatedDataVariants & result, size_t max_threads)",
          "new_line_content": "        createAggregateStates(place);",
          "content_same": false
        },
        {
          "line": 2140,
          "old_api": null,
          "new_api": "merge",
          "old_text": null,
          "new_text": "aggregate_functions[i]->merge(res + offsets_of_aggregate_states[i], (*aggregate_columns[i])[0], result.aggregates_pool)",
          "old_line_content": "      *  then blocks will contain information about the number of the bucket.",
          "new_line_content": "        aggregate_functions[i]->merge(res + offsets_of_aggregate_states[i], (*aggregate_columns[i])[0], result.aggregates_pool);",
          "content_same": false
        },
        {
          "line": 2143,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "block.clear()",
          "old_line_content": "      */",
          "new_line_content": "    block.clear();",
          "content_same": false
        },
        {
          "line": 2149,
          "old_api": null,
          "new_api": "isCancelled",
          "old_text": null,
          "new_text": "isCancelled()",
          "old_line_content": "    size_t total_input_rows = 0;",
          "new_line_content": "    if (isCancelled())",
          "content_same": false
        },
        {
          "line": 2160,
          "old_api": null,
          "new_api": "LOG_TRACE",
          "old_text": null,
          "new_text": "LOG_TRACE(log, \"Reading blocks of partially aggregated data.\")",
          "old_line_content": "",
          "new_line_content": "    LOG_TRACE(log, \"Reading blocks of partially aggregated data.\");",
          "content_same": false
        },
        {
          "line": 2164,
          "old_api": null,
          "new_api": "read",
          "old_text": null,
          "new_text": "stream->read()",
          "old_line_content": "}",
          "new_line_content": "    while (Block block = stream->read())",
          "content_same": false
        },
        {
          "line": 2166,
          "old_api": null,
          "new_api": "isCancelled",
          "old_text": null,
          "new_text": "isCancelled()",
          "old_line_content": "void Aggregator::mergeBlocks(BucketToBlocks bucket_to_blocks, AggregatedDataVariants & result, size_t max_threads)",
          "new_line_content": "        if (isCancelled())",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": null,
          "new_api": "rows",
          "old_text": null,
          "new_text": "block.rows()",
          "old_line_content": "        return;",
          "new_line_content": "        total_input_rows += block.rows();",
          "content_same": false
        },
        {
          "line": 2171,
          "old_api": null,
          "new_api": "std::move(block)",
          "old_text": null,
          "new_text": "std::move(block)",
          "old_line_content": "    UInt64 total_input_rows = 0;",
          "new_line_content": "        bucket_to_blocks[block.info.bucket_num].emplace_back(std::move(block));",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": null,
          "new_api": "mergeBlocks",
          "old_text": null,
          "new_text": "mergeBlocks(bucket_to_blocks, result, max_threads)",
          "old_line_content": "    /** `minus one` means the absence of information about the bucket",
          "new_line_content": "    mergeBlocks(bucket_to_blocks, result, max_threads);",
          "content_same": false
        },
        {
          "line": 2181,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "bucket_to_blocks.empty()",
          "old_line_content": "    bool has_two_level = max_bucket >= 0;",
          "new_line_content": "    if (bucket_to_blocks.empty())",
          "content_same": false
        },
        {
          "line": 2187,
          "old_api": null,
          "new_api": "rows",
          "old_text": null,
          "new_text": "block.rows()",
          "old_line_content": "            method_chosen = AggregatedDataVariants::Type::NAME ## _two_level;",
          "new_line_content": "            total_input_rows += block.rows();",
          "content_same": false
        },
        {
          "line": 2193,
          "old_api": null,
          "new_api": "rbegin",
          "old_text": null,
          "new_text": "bucket_to_blocks.rbegin()",
          "old_line_content": "",
          "new_line_content": "    auto max_bucket = bucket_to_blocks.rbegin()->first;",
          "content_same": false
        },
        {
          "line": 2202,
          "old_api": null,
          "new_api": "APPLY_FOR_VARIANTS_CONVERTIBLE_TO_TWO_LEVEL",
          "old_text": null,
          "new_text": "APPLY_FOR_VARIANTS_CONVERTIBLE_TO_TWO_LEVEL(M)",
          "old_line_content": "    result.key_sizes = key_sizes;",
          "new_line_content": "        APPLY_FOR_VARIANTS_CONVERTIBLE_TO_TWO_LEVEL(M)",
          "content_same": false
        },
        {
          "line": 2207,
          "old_api": null,
          "new_api": "isCancelled",
          "old_text": null,
          "new_text": "isCancelled()",
          "old_line_content": "    if (has_two_level)",
          "new_line_content": "    if (isCancelled())",
          "content_same": false
        },
        {
          "line": 2213,
          "old_api": null,
          "new_api": "init",
          "old_text": null,
          "new_text": "result.init(method_chosen)",
          "old_line_content": "",
          "new_line_content": "    result.init(method_chosen);",
          "content_same": false
        },
        {
          "line": 2217,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "bucket_to_blocks.count(-1)",
          "old_line_content": "        {",
          "new_line_content": "    bool has_blocks_with_unknown_bucket = bucket_to_blocks.count(-1);",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": null,
          "new_api": "LOG_TRACE",
          "old_text": null,
          "new_text": "LOG_TRACE(log, \"Merging partially aggregated two-level data.\")",
          "old_line_content": "                else if (result.type == AggregatedDataVariants::Type::NAME) \\",
          "new_line_content": "        LOG_TRACE(log, \"Merging partially aggregated two-level data.\");",
          "content_same": false
        },
        {
          "line": 2232,
          "old_api": null,
          "new_api": "CurrentThread::attachToIfDetached(thread_group)",
          "old_text": null,
          "new_text": "CurrentThread::attachToIfDetached(thread_group)",
          "old_line_content": "            #undef M",
          "new_line_content": "                CurrentThread::attachToIfDetached(thread_group);",
          "content_same": false
        },
        {
          "line": 2236,
          "old_api": null,
          "new_api": "isCancelled",
          "old_text": null,
          "new_text": "isCancelled()",
          "old_line_content": "        };",
          "new_line_content": "                if (isCancelled())",
          "content_same": false
        },
        {
          "line": 2244,
          "old_api": null,
          "new_api": "APPLY_FOR_VARIANTS_TWO_LEVEL",
          "old_text": null,
          "new_text": "APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "old_line_content": "            const auto bucket = bucket_blocks.first;",
          "new_line_content": "                    APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "content_same": false
        },
        {
          "line": 2253,
          "old_api": null,
          "new_api": "std::make_unique<ThreadPool>(max_threads)",
          "old_text": null,
          "new_text": "std::make_unique<ThreadPool>(max_threads)",
          "old_line_content": "",
          "new_line_content": "            thread_pool = std::make_unique<ThreadPool>(max_threads);",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": null,
          "new_api": "std::make_shared<Arena>()",
          "old_text": null,
          "new_text": "std::make_shared<Arena>()",
          "old_line_content": "",
          "new_line_content": "            result.aggregates_pools.push_back(std::make_shared<Arena>());",
          "content_same": false
        },
        {
          "line": 2265,
          "old_api": null,
          "new_api": "merge_bucket",
          "old_text": null,
          "new_text": "merge_bucket(bucket, aggregates_pool, group)",
          "old_line_content": "",
          "new_line_content": "            auto task = [group = CurrentThread::getGroup(), bucket, &merge_bucket, aggregates_pool]{ return merge_bucket(bucket, aggregates_pool, group); };",
          "content_same": false
        },
        {
          "line": 2270,
          "old_api": null,
          "new_api": "task",
          "old_text": null,
          "new_text": "task()",
          "old_line_content": "    }",
          "new_line_content": "                task();",
          "content_same": false
        },
        {
          "line": 2276,
          "old_api": null,
          "new_api": "LOG_TRACE",
          "old_text": null,
          "new_text": "LOG_TRACE(log, \"Merged partially aggregated two-level data.\")",
          "old_line_content": "        bool no_more_keys = false;",
          "new_line_content": "        LOG_TRACE(log, \"Merged partially aggregated two-level data.\");",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": null,
          "new_api": "isCancelled",
          "old_text": null,
          "new_text": "isCancelled()",
          "old_line_content": "        for (Block & block : blocks)",
          "new_line_content": "    if (isCancelled())",
          "content_same": false
        },
        {
          "line": 2294,
          "old_api": null,
          "new_api": "isCancelled",
          "old_text": null,
          "new_text": "isCancelled()",
          "old_line_content": "            else if (result.type == AggregatedDataVariants::Type::NAME) \\",
          "new_line_content": "            if (isCancelled())",
          "content_same": false
        },
        {
          "line": 2296,
          "old_api": null,
          "new_api": "invalidate",
          "old_text": null,
          "new_text": "result.invalidate()",
          "old_line_content": "",
          "new_line_content": "                result.invalidate();",
          "content_same": false
        },
        {
          "line": 2304,
          "old_api": null,
          "new_api": "mergeWithoutKeyStreamsImpl",
          "old_text": null,
          "new_text": "mergeWithoutKeyStreamsImpl(block, result)",
          "old_line_content": "    }",
          "new_line_content": "                mergeWithoutKeyStreamsImpl(block, result);",
          "content_same": false
        },
        {
          "line": 2323,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "blocks.empty()",
          "old_line_content": "    auto merge_method = method_chosen;",
          "new_line_content": "    if (blocks.empty())",
          "content_same": false
        },
        {
          "line": 2326,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "blocks.front()",
          "old_line_content": "        M(key64)            \\",
          "new_line_content": "    auto bucket_num = blocks.front().info.bucket_num;",
          "content_same": false
        },
        {
          "line": 2327,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "blocks.front()",
          "old_line_content": "        M(key_string)       \\",
          "new_line_content": "    bool is_overflows = blocks.front().info.is_overflows;",
          "content_same": false
        },
        {
          "line": 2329,
          "old_api": null,
          "new_api": "LOG_TRACE",
          "old_text": null,
          "new_text": "LOG_TRACE(log, \"Merging partially aggregated blocks (bucket = {}).\", bucket_num)",
          "old_line_content": "        M(keys128)          \\",
          "new_line_content": "    LOG_TRACE(log, \"Merging partially aggregated blocks (bucket = {}).\", bucket_num);",
          "content_same": false
        },
        {
          "line": 2350,
          "old_api": null,
          "new_api": "APPLY_FOR_VARIANTS_THAT_MAY_USE_BETTER_HASH_FUNCTION",
          "old_text": null,
          "new_text": "APPLY_FOR_VARIANTS_THAT_MAY_USE_BETTER_HASH_FUNCTION(M)",
          "old_line_content": "    result.key_sizes = key_sizes;",
          "new_line_content": "    APPLY_FOR_VARIANTS_THAT_MAY_USE_BETTER_HASH_FUNCTION(M)",
          "content_same": false
        },
        {
          "line": 2374,
          "old_api": null,
          "new_api": "mergeWithoutKeyStreamsImpl",
          "old_text": null,
          "new_text": "mergeWithoutKeyStreamsImpl(block, result)",
          "old_line_content": "        return {};",
          "new_line_content": "            mergeWithoutKeyStreamsImpl(block, result);",
          "content_same": false
        },
        {
          "line": 2383,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Unknown aggregated data variant.\", ErrorCodes::UNKNOWN_AGGREGATED_DATA_VARIANT)",
          "old_line_content": "    if (!final)",
          "new_line_content": "            throw Exception(\"Unknown aggregated data variant.\", ErrorCodes::UNKNOWN_AGGREGATED_DATA_VARIANT);",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": null,
          "new_api": "isCancelled",
          "old_text": null,
          "new_text": "isCancelled()",
          "old_line_content": "        result.aggregator = nullptr;",
          "new_line_content": "    if (isCancelled())",
          "content_same": false
        },
        {
          "line": 2402,
          "old_api": null,
          "new_api": "rows",
          "old_text": null,
          "new_text": "block.rows()",
          "old_line_content": "}",
          "new_line_content": "    size_t rows = block.rows();",
          "content_same": false
        },
        {
          "line": 2403,
          "old_api": null,
          "new_api": "bytes",
          "old_text": null,
          "new_text": "block.bytes()",
          "old_line_content": "",
          "new_line_content": "    size_t bytes = block.bytes();",
          "content_same": false
        },
        {
          "line": 2404,
          "old_api": null,
          "new_api": "elapsedSeconds",
          "old_text": null,
          "new_text": "watch.elapsedSeconds()",
          "old_line_content": "",
          "new_line_content": "    double elapsed_seconds = watch.elapsedSeconds();",
          "content_same": false
        },
        {
          "line": 2405,
          "old_api": null,
          "new_api": "LOG_TRACE",
          "old_text": null,
          "new_text": "LOG_TRACE(log, \"Merged partially aggregated blocks. {} rows, {}. in {} sec. ({} rows/sec., {}/sec.)\",\n        rows, ReadableSize(bytes),\n        elapsed_seconds, rows / elapsed_seconds,\n        ReadableSize(bytes / elapsed_seconds))",
          "old_line_content": "template <typename Method>",
          "new_line_content": "    LOG_TRACE(log, \"Merged partially aggregated blocks. {} rows, {}. in {} sec. ({} rows/sec., {}/sec.)\",",
          "content_same": false
        },
        {
          "line": 2406,
          "old_api": null,
          "new_api": "ReadableSize",
          "old_text": null,
          "new_text": "ReadableSize(bytes)",
          "old_line_content": "void NO_INLINE Aggregator::convertBlockToTwoLevelImpl(",
          "new_line_content": "        rows, ReadableSize(bytes),",
          "content_same": false
        },
        {
          "line": 2408,
          "old_api": null,
          "new_api": "ReadableSize",
          "old_text": null,
          "new_text": "ReadableSize(bytes / elapsed_seconds)",
          "old_line_content": "    Arena * pool,",
          "new_line_content": "        ReadableSize(bytes / elapsed_seconds));",
          "content_same": false
        },
        {
          "line": 2410,
          "old_api": null,
          "new_api": "isCancelled",
          "old_text": null,
          "new_text": "isCancelled()",
          "old_line_content": "    const Block & source,",
          "new_line_content": "    if (isCancelled())",
          "content_same": false
        },
        {
          "line": 2428,
          "old_api": null,
          "new_api": "rows",
          "old_text": null,
          "new_text": "source.rows()",
          "old_line_content": "                selector[i] = 0;",
          "new_line_content": "    size_t rows = source.rows();",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": null,
          "new_api": "columns",
          "old_text": null,
          "new_text": "source.columns()",
          "old_line_content": "                continue;",
          "new_line_content": "    size_t columns = source.columns();",
          "content_same": false
        },
        {
          "line": 2439,
          "old_api": null,
          "new_api": "isNullAt",
          "old_text": null,
          "new_text": "state.isNullAt(i)",
          "old_line_content": "",
          "new_line_content": "            if (state.isNullAt(i))",
          "content_same": false
        },
        {
          "line": 2447,
          "old_api": null,
          "new_api": "getHash",
          "old_text": null,
          "new_text": "state.getHash(method.data, i, *pool)",
          "old_line_content": "        for (size_t bucket = 0, size = num_buckets; bucket < size; ++bucket)",
          "new_line_content": "        auto hash = state.getHash(method.data, i, *pool);",
          "content_same": false
        },
        {
          "line": 2448,
          "old_api": null,
          "new_api": "getBucketFromHash",
          "old_text": null,
          "new_text": "method.data.getBucketFromHash(hash)",
          "old_line_content": "        {",
          "new_line_content": "        auto bucket = method.data.getBucketFromHash(hash);",
          "content_same": false
        },
        {
          "line": 2457,
          "old_api": null,
          "new_api": "getByPosition",
          "old_text": null,
          "new_text": "source.getByPosition(column_idx)",
          "old_line_content": "              *  by holding shared_ptr to source column. See ColumnAggregateFunction.h",
          "new_line_content": "        const ColumnWithTypeAndName & src_col = source.getByPosition(column_idx);",
          "content_same": false
        },
        {
          "line": 2458,
          "old_api": null,
          "new_api": "scatter",
          "old_text": null,
          "new_text": "src_col.column->scatter(num_buckets, selector)",
          "old_line_content": "              */",
          "new_line_content": "        MutableColumns scattered_columns = src_col.column->scatter(num_buckets, selector);",
          "content_same": false
        },
        {
          "line": 2462,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "scattered_columns[bucket]->empty()",
          "old_line_content": "",
          "new_line_content": "            if (!scattered_columns[bucket]->empty())",
          "content_same": false
        },
        {
          "line": 2466,
          "old_api": null,
          "new_api": "std::move(scattered_columns[bucket])",
          "old_text": null,
          "new_text": "std::move(scattered_columns[bucket])",
          "old_line_content": "    if (!block)",
          "new_line_content": "                dst.insert({std::move(scattered_columns[bucket]), src_col.type, src_col.name});",
          "content_same": false
        },
        {
          "line": 2488,
          "old_api": null,
          "new_api": "safeGetByPosition",
          "old_text": null,
          "new_text": "block.safeGetByPosition(i).column.get()",
          "old_line_content": "    else",
          "new_line_content": "        key_columns[i] = block.safeGetByPosition(i).column.get();",
          "content_same": false
        },
        {
          "line": 2499,
          "old_api": null,
          "new_api": "APPLY_FOR_VARIANTS_CONVERTIBLE_TO_TWO_LEVEL",
          "old_text": null,
          "new_text": "APPLY_FOR_VARIANTS_CONVERTIBLE_TO_TWO_LEVEL(M)",
          "old_line_content": "    if (false) {} // NOLINT",
          "new_line_content": "    APPLY_FOR_VARIANTS_CONVERTIBLE_TO_TWO_LEVEL(M)",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": null,
          "new_api": "init",
          "old_text": null,
          "new_text": "data.init(type)",
          "old_line_content": "",
          "new_line_content": "    data.init(type);",
          "content_same": false
        },
        {
          "line": 2526,
          "old_api": null,
          "new_api": "APPLY_FOR_VARIANTS_TWO_LEVEL",
          "old_text": null,
          "new_text": "APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "old_line_content": "    {",
          "new_line_content": "    APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "content_same": false
        },
        {
          "line": 2538,
          "old_api": null,
          "new_api": "forEachMapped",
          "old_text": null,
          "new_text": "table.forEachMapped([&](AggregateDataPtr & data)\n    {\n        /** If an exception (usually a lack of memory, the MemoryTracker throws) arose\n          *  after inserting the key into a hash table, but before creating all states of aggregate functions,\n          *  then data will be equal nullptr.\n          */\n        if (nullptr == data)\n            return;\n\n        for (size_t i = 0; i < params.aggregates_size; ++i)\n            aggregate_functions[i]->destroy(data + offsets_of_aggregate_states[i]);\n\n        data = nullptr;\n    })",
          "old_line_content": "    });",
          "new_line_content": "    table.forEachMapped([&](AggregateDataPtr & data)",
          "content_same": false
        },
        {
          "line": 2548,
          "old_api": null,
          "new_api": "destroy",
          "old_text": null,
          "new_text": "aggregate_functions[i]->destroy(data + offsets_of_aggregate_states[i])",
          "old_line_content": "        for (size_t i = 0; i < params.aggregates_size; ++i)",
          "new_line_content": "            aggregate_functions[i]->destroy(data + offsets_of_aggregate_states[i]);",
          "content_same": false
        },
        {
          "line": 2562,
          "old_api": null,
          "new_api": "destroy",
          "old_text": null,
          "new_text": "aggregate_functions[i]->destroy(res_data + offsets_of_aggregate_states[i])",
          "old_line_content": "",
          "new_line_content": "            aggregate_functions[i]->destroy(res_data + offsets_of_aggregate_states[i]);",
          "content_same": false
        },
        {
          "line": 2571,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "result.empty()",
          "old_line_content": "    if (false) {} // NOLINT",
          "new_line_content": "    if (result.empty())",
          "content_same": false
        },
        {
          "line": 2574,
          "old_api": null,
          "new_api": "LOG_TRACE",
          "old_text": null,
          "new_text": "LOG_TRACE(log, \"Destroying aggregate states\")",
          "old_line_content": "    else if (result.type != AggregatedDataVariants::Type::without_key)",
          "new_line_content": "    LOG_TRACE(log, \"Destroying aggregate states\");",
          "content_same": false
        },
        {
          "line": 2578,
          "old_api": null,
          "new_api": "destroyWithoutKey",
          "old_text": null,
          "new_text": "destroyWithoutKey(result)",
          "old_line_content": "",
          "new_line_content": "        destroyWithoutKey(result);",
          "content_same": false
        },
        {
          "line": 2585,
          "old_api": null,
          "new_api": "APPLY_FOR_AGGREGATED_VARIANTS",
          "old_text": null,
          "new_text": "APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "old_line_content": "}",
          "new_line_content": "    APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "inst->batch_that->addBatchLookupTable8(\n                rows,\n                reinterpret_cast<AggregateDataPtr *>(method.data.data()),\n                inst->state_offset,\n                [&](AggregateDataPtr & aggregate_data)\n                {\n                    aggregate_data = aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);\n                    createAggregateStates(aggregate_data);\n                },\n                state.getKeyData(),\n                inst->batch_arguments,\n                aggregates_pool)",
          "old_line_content": "                aggregates_pool);",
          "new_line_content": "            inst->batch_that->addBatchLookupTable8(",
          "content_same": false
        },
        {
          "line": 2588,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Unknown aggregated data variant.\", ErrorCodes::UNKNOWN_AGGREGATED_DATA_VARIANT)",
          "old_line_content": "",
          "new_line_content": "        throw Exception(\"Unknown aggregated data variant.\", ErrorCodes::UNKNOWN_AGGREGATED_DATA_VARIANT);",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "method.data.data()",
          "old_line_content": "        return;",
          "new_line_content": "                reinterpret_cast<AggregateDataPtr *>(method.data.data()),",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": null,
          "new_api": "alignedAlloc",
          "old_text": null,
          "new_text": "aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states)",
          "old_line_content": "",
          "new_line_content": "                    aggregate_data = aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": null,
          "new_api": "createAggregateStates",
          "old_text": null,
          "new_text": "createAggregateStates(aggregate_data)",
          "old_line_content": "    /// For all rows.",
          "new_line_content": "                    createAggregateStates(aggregate_data);",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": null,
          "new_api": "getKeyData",
          "old_text": null,
          "new_text": "state.getKeyData()",
          "old_line_content": "    {",
          "new_line_content": "                state.getKeyData(),",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": null,
          "new_api": "emplaceKey",
          "old_text": null,
          "new_text": "state.emplaceKey(method.data, i, *aggregates_pool)",
          "old_line_content": "        else",
          "new_line_content": "        auto emplace_result = state.emplaceKey(method.data, i, *aggregates_pool);",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": null,
          "new_api": "isInserted",
          "old_text": null,
          "new_text": "emplace_result.isInserted()",
          "old_line_content": "        places[i] = aggregate_data;",
          "new_line_content": "        if (emplace_result.isInserted())",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": null,
          "new_api": "setMapped",
          "old_text": null,
          "new_text": "emplace_result.setMapped(nullptr)",
          "old_line_content": "",
          "new_line_content": "            emplace_result.setMapped(nullptr);",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "alignedAlloc",
          "old_text": null,
          "new_text": "aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states)",
          "old_line_content": "    for (AggregateFunctionInstruction * inst = aggregate_instructions; inst->that; ++inst)",
          "new_line_content": "            aggregate_data = aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": null,
          "new_api": "createAggregateStates",
          "old_text": null,
          "new_text": "createAggregateStates(aggregate_data)",
          "old_line_content": "    {",
          "new_line_content": "            createAggregateStates(aggregate_data);",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": null,
          "new_api": "getMapped",
          "old_text": null,
          "new_text": "emplace_result.getMapped()",
          "old_line_content": "    }",
          "new_line_content": "            aggregate_data = emplace_result.getMapped();",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(places[i] != nullptr)",
          "old_line_content": "",
          "new_line_content": "        assert(places[i] != nullptr);",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "places.data()",
          "old_line_content": "    /// Adding values",
          "new_line_content": "            inst->batch_that->addBatchArray(rows, places.data(), inst->state_offset, inst->batch_arguments, inst->offsets, aggregates_pool);",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "places.data()",
          "old_line_content": "    {",
          "new_line_content": "            inst->batch_that->addBatch(rows, places.data(), inst->state_offset, inst->batch_arguments, aggregates_pool);",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": null,
          "new_api": "addBatchSinglePlace",
          "old_text": null,
          "new_text": "inst->batch_that->addBatchSinglePlace(\n                inst->offsets[static_cast<ssize_t>(rows - 1)], res + inst->state_offset, inst->batch_arguments, arena)",
          "old_line_content": "        Arena * arena)",
          "new_line_content": "            inst->batch_that->addBatchSinglePlace(",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": null,
          "new_api": "static_cast<ssize_t>(rows - 1)",
          "old_text": null,
          "new_text": "static_cast<ssize_t>(rows - 1)",
          "old_line_content": "{",
          "new_line_content": "                inst->offsets[static_cast<ssize_t>(rows - 1)], res + inst->state_offset, inst->batch_arguments, arena);",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": null,
          "new_api": "addBatchSinglePlace",
          "old_text": null,
          "new_text": "inst->batch_that->addBatchSinglePlace(rows, res + inst->state_offset, inst->batch_arguments, arena)",
          "old_line_content": "    for (AggregateFunctionInstruction * inst = aggregate_instructions; inst->that; ++inst)",
          "new_line_content": "            inst->batch_that->addBatchSinglePlace(rows, res + inst->state_offset, inst->batch_arguments, arena);",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": null,
          "new_api": "addBatchSinglePlaceFromInterval",
          "old_text": null,
          "new_text": "inst->batch_that->addBatchSinglePlaceFromInterval(row_begin, row_end, res + inst->state_offset, inst->batch_arguments, arena)",
          "old_line_content": "",
          "new_line_content": "            inst->batch_that->addBatchSinglePlaceFromInterval(row_begin, row_end, res + inst->state_offset, inst->batch_arguments, arena);",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "columns.at(params.aggregates[i].arguments[j])->convertToFullColumnIfConst()",
          "old_line_content": "        auto * that = aggregate_functions[i];",
          "new_line_content": "            materialized_columns.push_back(columns.at(params.aggregates[i].arguments[j])->convertToFullColumnIfConst());",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "materialized_columns.back().get()",
          "old_line_content": "        /// Unnest consecutive trailing -State combinators",
          "new_line_content": "            aggregate_columns[i][j] = materialized_columns.back().get();",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "column_no_lc.get()",
          "old_line_content": "        aggregate_functions_instructions[i].that = that;",
          "new_line_content": "            if (column_no_lc.get() != aggregate_columns[i][j])",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": null,
          "new_api": "std::move(column_no_lc)",
          "old_text": null,
          "new_text": "std::move(column_no_lc)",
          "old_line_content": "",
          "new_line_content": "                materialized_columns.emplace_back(std::move(column_no_lc));",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "func->getNestedFunction().get()",
          "old_line_content": "            aggregate_functions_instructions[i].offsets = offsets;",
          "new_line_content": "            that = func->getNestedFunction().get();",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": null,
          "new_api": "getAddressOfAddFunction",
          "old_text": null,
          "new_text": "that->getAddressOfAddFunction()",
          "old_line_content": "        else",
          "new_line_content": "        aggregate_functions_instructions[i].func = that->getAddressOfAddFunction();",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "typeid_cast<const AggregateFunctionArray *>(that)",
          "old_text": null,
          "new_text": "typeid_cast<const AggregateFunctionArray *>(that)",
          "old_line_content": "",
          "new_line_content": "        if (const auto * func = typeid_cast<const AggregateFunctionArray *>(that))",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "func->getNestedFunction().get()",
          "old_line_content": "}",
          "new_line_content": "            that = func->getNestedFunction().get();",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": null,
          "new_api": "typeid_cast<const AggregateFunctionState *>(that)",
          "old_text": null,
          "new_text": "typeid_cast<const AggregateFunctionState *>(that)",
          "old_line_content": "",
          "new_line_content": "            while (const auto * nested_func = typeid_cast<const AggregateFunctionState *>(that))",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "nested_func->getNestedFunction().get()",
          "old_line_content": "",
          "new_line_content": "                that = nested_func->getNestedFunction().get();",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "that->getArgumentTypes().size()",
          "old_line_content": "bool Aggregator::executeOnBlock(const Block & block, AggregatedDataVariants & result,",
          "new_line_content": "            auto [nested_columns, offsets] = checkAndGetNestedArrayOffset(aggregate_columns[i].data(), that->getArgumentTypes().size());",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": null,
          "new_api": "std::move(nested_columns)",
          "old_text": null,
          "new_text": "std::move(nested_columns)",
          "old_line_content": "                                ColumnRawPtrs & key_columns, AggregateColumns & aggregate_columns, bool & no_more_keys)",
          "new_line_content": "            nested_columns_holder.push_back(std::move(nested_columns));",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "nested_columns_holder.back().data()",
          "old_line_content": "{",
          "new_line_content": "            aggregate_functions_instructions[i].batch_arguments = nested_columns_holder.back().data();",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "aggregate_columns[i].data()",
          "old_line_content": "",
          "new_line_content": "            aggregate_functions_instructions[i].batch_arguments = aggregate_columns[i].data();",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": null,
          "new_api": "rows",
          "old_text": null,
          "new_text": "block.rows()",
          "old_line_content": "",
          "new_line_content": "    UInt64 num_rows = block.rows();",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": null,
          "new_api": "getColumns",
          "old_text": null,
          "new_text": "block.getColumns()",
          "old_line_content": "    /// How to perform the aggregation?",
          "new_line_content": "    return executeOnBlock(block.getColumns(), num_rows, result, key_columns, aggregate_columns, no_more_keys);",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": null,
          "new_api": "isCancelled",
          "old_text": null,
          "new_text": "isCancelled()",
          "old_line_content": "    }",
          "new_line_content": "    if (isCancelled())",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "result.empty()",
          "old_line_content": "      */",
          "new_line_content": "    if (result.empty())",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": null,
          "new_api": "init",
          "old_text": null,
          "new_text": "result.init(method_chosen)",
          "old_line_content": "",
          "new_line_content": "        result.init(method_chosen);",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": null,
          "new_api": "getMethodName",
          "old_text": null,
          "new_text": "result.getMethodName()",
          "old_line_content": "    {",
          "new_line_content": "        LOG_TRACE(log, \"Aggregation method: {}\", result.getMethodName());",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": null,
          "new_api": "isCancelled",
          "old_text": null,
          "new_text": "isCancelled()",
          "old_line_content": "",
          "new_line_content": "    if (isCancelled())",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "columns.at(params.keys[i])->convertToFullColumnIfConst()",
          "old_line_content": "    NestedColumnsHolder nested_columns_holder;",
          "new_line_content": "        materialized_columns.push_back(columns.at(params.keys[i])->convertToFullColumnIfConst());",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "materialized_columns.back().get()",
          "old_line_content": "    AggregateFunctionInstructions aggregate_functions_instructions;",
          "new_line_content": "        key_columns[i] = materialized_columns.back().get();",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": null,
          "new_api": "isLowCardinality",
          "old_text": null,
          "new_text": "result.isLowCardinality()",
          "old_line_content": "",
          "new_line_content": "        if (!result.isLowCardinality())",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": null,
          "new_api": "getPtr",
          "old_text": null,
          "new_text": "key_columns[i]->getPtr()",
          "old_line_content": "        return true;",
          "new_line_content": "            auto column_no_lc = recursiveRemoveLowCardinality(key_columns[i]->getPtr());",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "column_no_lc.get()",
          "old_line_content": "",
          "new_line_content": "            if (column_no_lc.get() != key_columns[i])",
          "content_same": false
        },
        {
          "line": 728,
          "old_api": null,
          "new_api": "std::move(column_no_lc)",
          "old_text": null,
          "new_text": "std::move(column_no_lc)",
          "old_line_content": "    {",
          "new_line_content": "                materialized_columns.emplace_back(std::move(column_no_lc));",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": null,
          "new_api": "prepareAggregateInstructions",
          "old_text": null,
          "new_text": "prepareAggregateInstructions(columns, aggregate_columns, materialized_columns, aggregate_functions_instructions, nested_columns_holder)",
          "old_line_content": "",
          "new_line_content": "    prepareAggregateInstructions(columns, aggregate_columns, materialized_columns, aggregate_functions_instructions, nested_columns_holder);",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": null,
          "new_api": "isCancelled",
          "old_text": null,
          "new_text": "isCancelled()",
          "old_line_content": "    if (result.type == AggregatedDataVariants::Type::without_key)",
          "new_line_content": "    if (isCancelled())",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": null,
          "new_api": "alignedAlloc",
          "old_text": null,
          "new_text": "result.aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states)",
          "old_line_content": "    {",
          "new_line_content": "        AggregateDataPtr place = result.aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": null,
          "new_api": "createAggregateStates",
          "old_text": null,
          "new_text": "createAggregateStates(place)",
          "old_line_content": "        /// This is where data is written that does not fit in `max_rows_to_group_by` with `group_by_overflow_mode = any`.",
          "new_line_content": "        createAggregateStates(place);",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": null,
          "new_api": "APPLY_FOR_AGGREGATED_VARIANTS",
          "old_text": null,
          "new_text": "APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "old_line_content": "    bool worth_convert_to_two_level",
          "new_line_content": "        APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": null,
          "new_api": "sizeWithoutOverflowRow",
          "old_text": null,
          "new_text": "result.sizeWithoutOverflowRow()",
          "old_line_content": "    /** Converting to a two-level data structure.",
          "new_line_content": "    size_t result_size = result.sizeWithoutOverflowRow();",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": null,
          "new_api": "CurrentThread::getMemoryTracker()",
          "old_text": null,
          "new_text": "CurrentThread::getMemoryTracker()",
          "old_line_content": "      */",
          "new_line_content": "    if (auto * memory_tracker_child = CurrentThread::getMemoryTracker())",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": null,
          "new_api": "static_cast<Int64>(params.group_by_two_level_threshold_bytes)",
          "old_text": null,
          "new_text": "static_cast<Int64>(params.group_by_two_level_threshold_bytes)",
          "old_line_content": "      * Data can only be flushed to disk if a two-level aggregation structure is used.",
          "new_line_content": "        || (params.group_by_two_level_threshold_bytes && result_size_bytes >= static_cast<Int64>(params.group_by_two_level_threshold_bytes));",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": null,
          "new_api": "isConvertibleToTwoLevel",
          "old_text": null,
          "new_text": "result.isConvertibleToTwoLevel()",
          "old_line_content": "        && worth_convert_to_two_level)",
          "new_line_content": "    if (result.isConvertibleToTwoLevel() && worth_convert_to_two_level)",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": null,
          "new_api": "convertToTwoLevel",
          "old_text": null,
          "new_text": "result.convertToTwoLevel()",
          "old_line_content": "    {",
          "new_line_content": "        result.convertToTwoLevel();",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": null,
          "new_api": "isTwoLevel",
          "old_text": null,
          "new_text": "result.isTwoLevel()",
          "old_line_content": "        // current_memory_usage does not takes compression into account and",
          "new_line_content": "        && result.isTwoLevel()",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": null,
          "new_api": "static_cast<Int64>(params.max_bytes_before_external_group_by)",
          "old_text": null,
          "new_text": "static_cast<Int64>(params.max_bytes_before_external_group_by)",
          "old_line_content": "        // will reserve way more that actually will be used.",
          "new_line_content": "        && current_memory_usage > static_cast<Int64>(params.max_bytes_before_external_group_by)",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": null,
          "new_api": "getDisk",
          "old_text": null,
          "new_text": "params.tmp_volume->getDisk()->getPath()",
          "old_line_content": "",
          "new_line_content": "        std::string tmp_path = params.tmp_volume->getDisk()->getPath();",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Not enough space for external aggregation in \" + tmp_path, ErrorCodes::NOT_ENOUGH_SPACE)",
          "old_line_content": "",
          "new_line_content": "            throw Exception(\"Not enough space for external aggregation in \" + tmp_path, ErrorCodes::NOT_ENOUGH_SPACE);",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data_variants.size()",
          "old_line_content": "#define M(NAME) \\",
          "new_line_content": "    size_t rows = data_variants.size();",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": null,
          "new_api": "createTemporaryFile",
          "old_text": null,
          "new_text": "createTemporaryFile(tmp_path)",
          "old_line_content": "        writeToTemporaryFileImpl(data_variants, *data_variants.NAME, block_out);",
          "new_line_content": "    auto file = createTemporaryFile(tmp_path);",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": null,
          "new_api": "path",
          "old_text": null,
          "new_text": "file->path()",
          "old_line_content": "",
          "new_line_content": "    const std::string & path = file->path();",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": null,
          "new_api": "LOG_DEBUG",
          "old_text": null,
          "new_text": "LOG_DEBUG(log, \"Writing part of aggregation data into temporary file {}.\", path)",
          "old_line_content": "        throw Exception(\"Unknown aggregated data variant.\", ErrorCodes::UNKNOWN_AGGREGATED_DATA_VARIANT);",
          "new_line_content": "    LOG_DEBUG(log, \"Writing part of aggregation data into temporary file {}.\", path);",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": null,
          "new_api": "ProfileEvents::increment(ProfileEvents::ExternalAggregationWritePart)",
          "old_text": null,
          "new_text": "ProfileEvents::increment(ProfileEvents::ExternalAggregationWritePart)",
          "old_line_content": "",
          "new_line_content": "    ProfileEvents::increment(ProfileEvents::ExternalAggregationWritePart);",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": null,
          "new_api": "init",
          "old_text": null,
          "new_text": "data_variants.init(data_variants.type)",
          "old_line_content": "    {",
          "new_line_content": "    data_variants.init(data_variants.type);",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": null,
          "new_api": "std::make_shared<Arena>()",
          "old_text": null,
          "new_text": "std::make_shared<Arena>()",
          "old_line_content": "        std::lock_guard lock(temporary_files.mutex);",
          "new_line_content": "    data_variants.aggregates_pools = Arenas(1, std::make_shared<Arena>());",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": null,
          "new_api": "flush",
          "old_text": null,
          "new_text": "block_out.flush()",
          "old_line_content": "    }",
          "new_line_content": "    block_out.flush();",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "compressed_buf.next()",
          "old_line_content": "",
          "new_line_content": "    compressed_buf.next();",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": null,
          "new_api": "elapsedSeconds",
          "old_text": null,
          "new_text": "watch.elapsedSeconds()",
          "old_line_content": "",
          "new_line_content": "    double elapsed_seconds = watch.elapsedSeconds();",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "compressed_buf.count()",
          "old_line_content": "        \"Written part in {} sec., {} rows, {} uncompressed, {} compressed,\"",
          "new_line_content": "    double uncompressed_bytes = compressed_buf.count();",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": null,
          "new_api": "std::move(file)",
          "old_text": null,
          "new_text": "std::move(file)",
          "old_line_content": "        rows,",
          "new_line_content": "        temporary_files.files.emplace_back(std::move(file));",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": null,
          "new_api": "ProfileEvents::increment(ProfileEvents::ExternalAggregationCompressedBytes, compressed_bytes)",
          "old_text": null,
          "new_text": "ProfileEvents::increment(ProfileEvents::ExternalAggregationCompressedBytes, compressed_bytes)",
          "old_line_content": "        uncompressed_bytes / compressed_bytes,",
          "new_line_content": "    ProfileEvents::increment(ProfileEvents::ExternalAggregationCompressedBytes, compressed_bytes);",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": null,
          "new_api": "ProfileEvents::increment(ProfileEvents::ExternalAggregationUncompressedBytes, uncompressed_bytes)",
          "old_text": null,
          "new_text": "ProfileEvents::increment(ProfileEvents::ExternalAggregationUncompressedBytes, uncompressed_bytes)",
          "old_line_content": "        rows / elapsed_seconds,",
          "new_line_content": "    ProfileEvents::increment(ProfileEvents::ExternalAggregationUncompressedBytes, uncompressed_bytes);",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": null,
          "new_api": "ReadableSize",
          "old_text": null,
          "new_text": "ReadableSize(uncompressed_bytes / elapsed_seconds)",
          "old_line_content": "Block Aggregator::convertOneBucketToBlock(",
          "new_line_content": "        ReadableSize(uncompressed_bytes / elapsed_seconds),",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": null,
          "new_api": "ReadableSize",
          "old_text": null,
          "new_text": "ReadableSize(compressed_bytes / elapsed_seconds)",
          "old_line_content": "    AggregatedDataVariants & data_variants,",
          "new_line_content": "        ReadableSize(compressed_bytes / elapsed_seconds));",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": null,
          "new_api": "getDisk",
          "old_text": null,
          "new_text": "params.tmp_volume->getDisk()->getPath()",
          "old_line_content": "        [bucket, &method, this] (",
          "new_line_content": "    String tmp_path = params.tmp_volume->getDisk()->getPath();",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": null,
          "new_api": "writeToTemporaryFile",
          "old_text": null,
          "new_text": "writeToTemporaryFile(data_variants, tmp_path)",
          "old_line_content": "            MutableColumns & key_columns,",
          "new_line_content": "    return writeToTemporaryFile(data_variants, tmp_path);",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "method.data.impls[bucket].size()",
          "old_line_content": "    return block;",
          "new_line_content": "    Block block = prepareBlockAndFill(data_variants, final, method.data.impls[bucket].size(),",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": null,
          "new_api": "convertToBlockImpl",
          "old_text": null,
          "new_text": "convertToBlockImpl(method, method.data.impls[bucket],\n                key_columns, aggregate_columns, final_aggregate_columns, arena, final_)",
          "old_line_content": "    std::atomic<bool> * is_cancelled) const",
          "new_line_content": "            convertToBlockImpl(method, method.data.impls[bucket],",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": null,
          "new_api": "APPLY_FOR_VARIANTS_TWO_LEVEL",
          "old_text": null,
          "new_text": "APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "old_line_content": "    size_t max_temporary_block_size_rows = 0;",
          "new_line_content": "    APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": null,
          "new_api": "bytes",
          "old_text": null,
          "new_text": "block.bytes()",
          "old_line_content": "    }",
          "new_line_content": "        size_t block_size_bytes = block.bytes();",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": null,
          "new_api": "convertOneBucketToBlock",
          "old_text": null,
          "new_text": "convertOneBucketToBlock(data_variants, method, false, bucket)",
          "old_line_content": "    /// `data_variants` will not destroy them in the destructor, they are now owned by ColumnAggregateFunction objects.",
          "new_line_content": "        Block block = convertOneBucketToBlock(data_variants, method, false, bucket);",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": null,
          "new_api": "write",
          "old_text": null,
          "new_text": "out.write(block)",
          "old_line_content": "    data_variants.aggregator = nullptr;",
          "new_line_content": "        out.write(block);",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": null,
          "new_api": "update_max_sizes",
          "old_text": null,
          "new_text": "update_max_sizes(block)",
          "old_line_content": "",
          "new_line_content": "        update_max_sizes(block);",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": null,
          "new_api": "prepareBlockAndFillWithoutKey",
          "old_text": null,
          "new_text": "prepareBlockAndFillWithoutKey(data_variants, false, true)",
          "old_line_content": "bool Aggregator::checkLimits(size_t result_size, bool & no_more_keys) const",
          "new_line_content": "        Block block = prepareBlockAndFillWithoutKey(data_variants, false, true);",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": null,
          "new_api": "write",
          "old_text": null,
          "new_text": "out.write(block)",
          "old_line_content": "{",
          "new_line_content": "        out.write(block);",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": null,
          "new_api": "update_max_sizes",
          "old_text": null,
          "new_text": "update_max_sizes(block)",
          "old_line_content": "    if (!no_more_keys && params.max_rows_to_group_by && result_size > params.max_rows_to_group_by)",
          "new_line_content": "        update_max_sizes(block);",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": null,
          "new_api": "ReadableSize",
          "old_text": null,
          "new_text": "ReadableSize(max_temporary_block_size_bytes)",
          "old_line_content": "                    ErrorCodes::TOO_MANY_ROWS);",
          "new_line_content": "    LOG_TRACE(log, \"Max size of temporary block: {} rows, {}.\", max_temporary_block_size_rows, ReadableSize(max_temporary_block_size_bytes));",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "toString(result_size)",
          "old_line_content": "    return true;",
          "new_line_content": "                throw Exception(\"Limit for rows to GROUP BY exceeded: has \" + toString(result_size)",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "toString(params.max_rows_to_group_by)",
          "old_line_content": "}",
          "new_line_content": "                    + \" rows, maximum: \" + toString(params.max_rows_to_group_by),",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": null,
          "new_api": "read",
          "old_text": null,
          "new_text": "stream->read()",
          "old_line_content": "    /// To do this, we pass a block with zero rows to aggregate.",
          "new_line_content": "    while (Block block = stream->read())",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": null,
          "new_api": "bytes",
          "old_text": null,
          "new_text": "block.bytes()",
          "old_line_content": "",
          "new_line_content": "        src_bytes += block.bytes();",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "result.empty()",
          "old_line_content": "template <typename Method, typename Table>",
          "new_line_content": "    if (result.empty() && params.keys_size == 0 && !params.empty_result_for_aggregation_by_empty_set)",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": null,
          "new_api": "getHeader",
          "old_text": null,
          "new_text": "stream->getHeader()",
          "old_line_content": "void Aggregator::convertToBlockImpl(",
          "new_line_content": "        executeOnBlock(stream->getHeader(), result, key_columns, aggregate_columns, no_more_keys);",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": null,
          "new_api": "elapsedSeconds",
          "old_text": null,
          "new_text": "watch.elapsedSeconds()",
          "old_line_content": "    Table & data,",
          "new_line_content": "    double elapsed_seconds = watch.elapsedSeconds();",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": null,
          "new_api": "sizeWithoutOverflowRow",
          "old_text": null,
          "new_text": "result.sizeWithoutOverflowRow()",
          "old_line_content": "    MutableColumns & key_columns,",
          "new_line_content": "    size_t rows = result.sizeWithoutOverflowRow();",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": null,
          "new_api": "LOG_TRACE",
          "old_text": null,
          "new_text": "LOG_TRACE(log, \"Aggregated. {} to {} rows (from {}) in {} sec. ({} rows/sec., {}/sec.)\",\n        src_rows, rows, ReadableSize(src_bytes),\n        elapsed_seconds, src_rows / elapsed_seconds,\n        ReadableSize(src_bytes / elapsed_seconds))",
          "old_line_content": "    MutableColumns & final_aggregate_columns,",
          "new_line_content": "    LOG_TRACE(log, \"Aggregated. {} to {} rows (from {}) in {} sec. ({} rows/sec., {}/sec.)\",",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": null,
          "new_api": "ReadableSize",
          "old_text": null,
          "new_text": "ReadableSize(src_bytes)",
          "old_line_content": "    Arena * arena,",
          "new_line_content": "        src_rows, rows, ReadableSize(src_bytes),",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": null,
          "new_api": "ReadableSize",
          "old_text": null,
          "new_text": "ReadableSize(src_bytes / elapsed_seconds)",
          "old_line_content": "{",
          "new_line_content": "        ReadableSize(src_bytes / elapsed_seconds));",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "data.empty()",
          "old_line_content": "",
          "new_line_content": "    if (data.empty())",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "key_columns.size()",
          "old_line_content": "inline void Aggregator::insertAggregatesIntoColumns(",
          "new_line_content": "    if (key_columns.size() != params.keys_size)",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": null,
          "new_api": "convertToBlockImplFinal",
          "old_text": null,
          "new_text": "convertToBlockImplFinal(method, data, key_columns, final_aggregate_columns, arena)",
          "old_line_content": "{",
          "new_line_content": "        convertToBlockImplFinal(method, data, key_columns, final_aggregate_columns, arena);",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": null,
          "new_api": "convertToBlockImplNotFinal",
          "old_text": null,
          "new_text": "convertToBlockImplNotFinal(method, data, key_columns, aggregate_columns)",
          "old_line_content": "      * Then states of aggregate functions, that are not longer needed, are destroyed.",
          "new_line_content": "        convertToBlockImplNotFinal(method, data, key_columns, aggregate_columns);",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": null,
          "new_api": "clearAndShrink",
          "old_text": null,
          "new_text": "data.clearAndShrink()",
          "old_line_content": "      * We mark already destroyed states with \"nullptr\" in data,",
          "new_line_content": "    data.clearAndShrink();",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": null,
          "new_api": "insertResultInto",
          "old_text": null,
          "new_text": "aggregate_functions[insert_i]->insertResultInto(\n                mapped + offsets_of_aggregate_states[insert_i],\n                *final_aggregate_columns[insert_i],\n                arena)",
          "old_line_content": "        *  because the ownership of this state is transferred to ColumnAggregateFunction",
          "new_line_content": "            aggregate_functions[insert_i]->insertResultInto(",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": null,
          "new_api": "std::current_exception()",
          "old_text": null,
          "new_text": "std::current_exception()",
          "old_line_content": "    {",
          "new_line_content": "        exception = std::current_exception();",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": null,
          "new_api": "isState",
          "old_text": null,
          "new_text": "aggregate_functions[destroy_i]->isState()",
          "old_line_content": "template <typename Method, typename Table>",
          "new_line_content": "        if (!(destroy_i < insert_i && aggregate_functions[destroy_i]->isState()))",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": null,
          "new_api": "destroy",
          "old_text": null,
          "new_text": "aggregate_functions[destroy_i]->destroy(\n                mapped + offsets_of_aggregate_states[destroy_i])",
          "old_line_content": "void NO_INLINE Aggregator::convertToBlockImplFinal(",
          "new_line_content": "            aggregate_functions[destroy_i]->destroy(",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": null,
          "new_api": "std::rethrow_exception(exception)",
          "old_text": null,
          "new_text": "std::rethrow_exception(exception)",
          "old_line_content": "    {",
          "new_line_content": "        std::rethrow_exception(exception);",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": null,
          "new_api": "hasNullKeyData",
          "old_text": null,
          "new_text": "data.hasNullKeyData()",
          "old_line_content": "",
          "new_line_content": "        if (data.hasNullKeyData())",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": null,
          "new_api": "insertDefault",
          "old_text": null,
          "new_text": "key_columns[0]->insertDefault()",
          "old_line_content": "void NO_INLINE Aggregator::convertToBlockImplNotFinal(",
          "new_line_content": "            key_columns[0]->insertDefault();",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": null,
          "new_api": "getNullKeyData",
          "old_text": null,
          "new_text": "data.getNullKeyData()",
          "old_line_content": "    Method & method,",
          "new_line_content": "            insertAggregatesIntoColumns(data.getNullKeyData(), final_aggregate_columns, arena);",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": null,
          "new_api": "forEachValue",
          "old_text": null,
          "new_text": "data.forEachValue([&](const auto & key, auto & mapped)\n    {\n        method.insertKeyIntoColumns(key, key_columns, key_sizes);\n        insertAggregatesIntoColumns(mapped, final_aggregate_columns, arena);\n    })",
          "old_line_content": "{",
          "new_line_content": "    data.forEachValue([&](const auto & key, auto & mapped)",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "insertKeyIntoColumns",
          "old_text": null,
          "new_text": "method.insertKeyIntoColumns(key, key_columns, key_sizes)",
          "old_line_content": "    {",
          "new_line_content": "        method.insertKeyIntoColumns(key, key_columns, key_sizes);",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": null,
          "new_api": "insertDefault",
          "old_text": null,
          "new_text": "key_columns[0]->insertDefault()",
          "old_line_content": "        /// reserved, so push_back does not throw exceptions",
          "new_line_content": "            key_columns[0]->insertDefault();",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": null,
          "new_api": "getNullKeyData",
          "old_text": null,
          "new_text": "data.getNullKeyData()",
          "old_line_content": "",
          "new_line_content": "                aggregate_columns[i]->push_back(data.getNullKeyData() + offsets_of_aggregate_states[i]);",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": null,
          "new_api": "getNullKeyData",
          "old_text": null,
          "new_text": "data.getNullKeyData()",
          "old_line_content": "    });",
          "new_line_content": "            data.getNullKeyData() = nullptr;",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": null,
          "new_api": "forEachValue",
          "old_text": null,
          "new_text": "data.forEachValue([&](const auto & key, auto & mapped)\n    {\n        method.insertKeyIntoColumns(key, key_columns, key_sizes);\n\n        /// reserved, so push_back does not throw exceptions\n        for (size_t i = 0; i < params.aggregates_size; ++i)\n            aggregate_columns[i]->push_back(mapped + offsets_of_aggregate_states[i]);\n\n        mapped = nullptr;\n    })",
          "old_line_content": "template <typename Filler>",
          "new_line_content": "    data.forEachValue([&](const auto & key, auto & mapped)",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": null,
          "new_api": "insertKeyIntoColumns",
          "old_text": null,
          "new_text": "method.insertKeyIntoColumns(key, key_columns, key_sizes)",
          "old_line_content": "    AggregatedDataVariants & data_variants,",
          "new_line_content": "        method.insertKeyIntoColumns(key, key_columns, key_sizes);",
          "content_same": false
        },
        {
          "line": 1207,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "aggregate_columns[i]->push_back(mapped + offsets_of_aggregate_states[i])",
          "old_line_content": "{",
          "new_line_content": "            aggregate_columns[i]->push_back(mapped + offsets_of_aggregate_states[i]);",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": null,
          "new_api": "safeGetByPosition",
          "old_text": null,
          "new_text": "header.safeGetByPosition(i).type->createColumn()",
          "old_line_content": "",
          "new_line_content": "        key_columns[i] = header.safeGetByPosition(i).type->createColumn();",
          "content_same": false
        },
        {
          "line": 1231,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "key_columns[i]->reserve(rows)",
          "old_line_content": "            for (auto & pool : data_variants.aggregates_pools)",
          "new_line_content": "        key_columns[i]->reserve(rows);",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "aggregate_columns_data[i]->reserve(rows)",
          "old_line_content": "",
          "new_line_content": "            aggregate_columns_data[i]->reserve(rows);",
          "content_same": false
        },
        {
          "line": 1253,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "final_aggregate_columns[i]->reserve(rows)",
          "old_line_content": "                        for (auto & pool : data_variants.aggregates_pools)",
          "new_line_content": "            final_aggregate_columns[i]->reserve(rows);",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": null,
          "new_api": "isState",
          "old_text": null,
          "new_text": "aggregate_functions[i]->isState()",
          "old_line_content": "                });",
          "new_line_content": "            if (aggregate_functions[i]->isState())",
          "content_same": false
        },
        {
          "line": 1258,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "final_aggregate_columns[i].get()",
          "old_line_content": "    }",
          "new_line_content": "                if (auto * column_aggregate_func = typeid_cast<ColumnAggregateFunction *>(final_aggregate_columns[i].get()))",
          "content_same": false
        },
        {
          "line": 1263,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "final_aggregate_columns[i]->forEachSubcolumn([&data_variants](auto & subcolumn)\n                {\n                    if (auto * column_aggregate_func = typeid_cast<ColumnAggregateFunction *>(subcolumn.get()))\n                        for (auto & pool : data_variants.aggregates_pools)\n                            column_aggregate_func->addArena(pool);\n                })",
          "old_line_content": "",
          "new_line_content": "                final_aggregate_columns[i]->forEachSubcolumn([&data_variants](auto & subcolumn)",
          "content_same": false
        },
        {
          "line": 1267,
          "old_api": null,
          "new_api": "addArena",
          "old_text": null,
          "new_text": "column_aggregate_func->addArena(pool)",
          "old_line_content": "    for (size_t i = 0; i < params.aggregates_size; ++i)",
          "new_line_content": "                            column_aggregate_func->addArena(pool);",
          "content_same": false
        },
        {
          "line": 1275,
          "old_api": null,
          "new_api": "cloneEmpty",
          "old_text": null,
          "new_text": "header.cloneEmpty()",
          "old_line_content": "",
          "new_line_content": "    Block res = header.cloneEmpty();",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": null,
          "new_api": "std::move(key_columns[i])",
          "old_text": null,
          "new_text": "std::move(key_columns[i])",
          "old_line_content": "    for (size_t i = 0; i < columns; ++i)",
          "new_line_content": "        res.getByPosition(i).column = std::move(key_columns[i]);",
          "content_same": false
        },
        {
          "line": 1284,
          "old_api": null,
          "new_api": "std::move(final_aggregate_columns[i])",
          "old_text": null,
          "new_text": "std::move(final_aggregate_columns[i])",
          "old_line_content": "",
          "new_line_content": "            res.getByName(aggregate_column_name).column = std::move(final_aggregate_columns[i]);",
          "content_same": false
        },
        {
          "line": 1286,
          "old_api": null,
          "new_api": "std::move(aggregate_columns[i])",
          "old_text": null,
          "new_text": "std::move(aggregate_columns[i])",
          "old_line_content": "    AggregatedDataVariants & data_variants,",
          "new_line_content": "            res.getByName(aggregate_column_name).column = std::move(aggregate_columns[i]);",
          "content_same": false
        },
        {
          "line": 1290,
          "old_api": null,
          "new_api": "columns",
          "old_text": null,
          "new_text": "header.columns()",
          "old_line_content": "",
          "new_line_content": "    size_t columns = header.columns();",
          "content_same": false
        },
        {
          "line": 1292,
          "old_api": null,
          "new_api": "getByPosition",
          "old_text": null,
          "new_text": "res.getByPosition(i)",
          "old_line_content": "    {",
          "new_line_content": "        if (isColumnConst(*res.getByPosition(i).column))",
          "content_same": false
        },
        {
          "line": 1306,
          "old_api": null,
          "new_api": "assert_cast<ColumnAggregateFunction &>(*final_aggregate_columns[i])",
          "old_text": null,
          "new_text": "assert_cast<ColumnAggregateFunction &>(*final_aggregate_columns[i])",
          "old_line_content": "    size_t key_row,",
          "new_line_content": "        ColumnAggregateFunction & column_aggregate_func = assert_cast<ColumnAggregateFunction &>(*final_aggregate_columns[i]);",
          "content_same": false
        },
        {
          "line": 1311,
          "old_api": null,
          "new_api": "getData",
          "old_text": null,
          "new_text": "column_aggregate_func.getData().push_back(data + offsets_of_aggregate_states[i])",
          "old_line_content": "    data_variants.without_key = place;",
          "new_line_content": "        column_aggregate_func.getData().push_back(data + offsets_of_aggregate_states[i]);",
          "content_same": false
        },
        {
          "line": 1322,
          "old_api": null,
          "new_api": "alignedAlloc",
          "old_text": null,
          "new_text": "data_variants.aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states)",
          "old_line_content": "",
          "new_line_content": "    AggregateDataPtr place = data_variants.aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": null,
          "new_api": "createAggregateStates",
          "old_text": null,
          "new_text": "createAggregateStates(place)",
          "old_line_content": "    auto filler = [&data_variants, this](",
          "new_line_content": "    createAggregateStates(place);",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "key_columns[i].get()",
          "old_line_content": "        bool final_)",
          "new_line_content": "        final_key_columns[i]->insertFrom(*key_columns[i].get(), key_row);",
          "content_same": false
        },
        {
          "line": 1350,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "aggregate_columns[i]->push_back(data + offsets_of_aggregate_states[i])",
          "old_line_content": "",
          "new_line_content": "                    aggregate_columns[i]->push_back(data + offsets_of_aggregate_states[i]);",
          "content_same": false
        },
        {
          "line": 1355,
          "old_api": null,
          "new_api": "insertAggregatesIntoColumns",
          "old_text": null,
          "new_text": "insertAggregatesIntoColumns(data, final_aggregate_columns, arena)",
          "old_line_content": "",
          "new_line_content": "                insertAggregatesIntoColumns(data, final_aggregate_columns, arena);",
          "content_same": false
        },
        {
          "line": 1360,
          "old_api": null,
          "new_api": "insertDefault",
          "old_text": null,
          "new_text": "key_columns[i]->insertDefault()",
          "old_line_content": "}",
          "new_line_content": "                    key_columns[i]->insertDefault();",
          "content_same": false
        },
        {
          "line": 1370,
          "old_api": null,
          "new_api": "destroyWithoutKey",
          "old_text": null,
          "new_text": "destroyWithoutKey(data_variants)",
          "old_line_content": "        Arena * arena,",
          "new_line_content": "        destroyWithoutKey(data_variants);",
          "content_same": false
        },
        {
          "line": 1377,
          "old_api": null,
          "new_api": "sizeWithoutOverflowRow",
          "old_text": null,
          "new_text": "data_variants.sizeWithoutOverflowRow()",
          "old_line_content": "",
          "new_line_content": "    size_t rows = data_variants.sizeWithoutOverflowRow();",
          "content_same": false
        },
        {
          "line": 1392,
          "old_api": null,
          "new_api": "APPLY_FOR_VARIANTS_SINGLE_LEVEL",
          "old_text": null,
          "new_text": "APPLY_FOR_VARIANTS_SINGLE_LEVEL(M)",
          "old_line_content": "    else if (data_variants.type == AggregatedDataVariants::Type::NAME) \\",
          "new_line_content": "        APPLY_FOR_VARIANTS_SINGLE_LEVEL(M)",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": null,
          "new_api": "prepareBlockAndFill",
          "old_text": null,
          "new_text": "prepareBlockAndFill(data_variants, final, rows, filler)",
          "old_line_content": "    else",
          "new_line_content": "    return prepareBlockAndFill(data_variants, final, rows, filler);",
          "content_same": false
        },
        {
          "line": 1409,
          "old_api": null,
          "new_api": "APPLY_FOR_VARIANTS_TWO_LEVEL",
          "old_text": null,
          "new_text": "APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "old_line_content": "{",
          "new_line_content": "    APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "content_same": false
        },
        {
          "line": 1426,
          "old_api": null,
          "new_api": "CurrentThread::attachToIfDetached(thread_group)",
          "old_text": null,
          "new_text": "CurrentThread::attachToIfDetached(thread_group)",
          "old_line_content": "                continue;",
          "new_line_content": "            CurrentThread::attachToIfDetached(thread_group);",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": null,
          "new_api": "convertOneBucketToBlock",
          "old_text": null,
          "new_text": "convertOneBucketToBlock(data_variants, method, final, bucket)",
          "old_line_content": "",
          "new_line_content": "        return convertOneBucketToBlock(data_variants, method, final, bucket);",
          "content_same": false
        },
        {
          "line": 1438,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "method.data.impls[bucket].empty()",
          "old_line_content": "        /// If this is not done, then in case of an exception, tasks will be destroyed before the threads are completed, and it will be bad.",
          "new_line_content": "            if (method.data.impls[bucket].empty())",
          "content_same": false
        },
        {
          "line": 1441,
          "old_api": null,
          "new_api": "converter",
          "old_text": null,
          "new_text": "converter(bucket, group)",
          "old_line_content": "",
          "new_line_content": "            tasks[bucket] = std::packaged_task<Block()>([group = CurrentThread::getGroup(), bucket, &converter]{ return converter(bucket, group); });",
          "content_same": false
        },
        {
          "line": 1444,
          "old_api": null,
          "new_api": "scheduleOrThrowOnError",
          "old_text": null,
          "new_text": "thread_pool->scheduleOrThrowOnError([bucket, &tasks] { tasks[bucket](); })",
          "old_line_content": "",
          "new_line_content": "                thread_pool->scheduleOrThrowOnError([bucket, &tasks] { tasks[bucket](); });",
          "content_same": false
        },
        {
          "line": 1453,
          "old_api": null,
          "new_api": "wait",
          "old_text": null,
          "new_text": "thread_pool->wait()",
          "old_line_content": "            continue;",
          "new_line_content": "            thread_pool->wait();",
          "content_same": false
        },
        {
          "line": 1459,
          "old_api": null,
          "new_api": "wait",
          "old_text": null,
          "new_text": "thread_pool->wait()",
          "old_line_content": "}",
          "new_line_content": "        thread_pool->wait();",
          "content_same": false
        },
        {
          "line": 1468,
          "old_api": null,
          "new_api": "get_future",
          "old_text": null,
          "new_text": "task.get_future().get()",
          "old_line_content": "",
          "new_line_content": "        blocks.emplace_back(task.get_future().get());",
          "content_same": false
        },
        {
          "line": 1477,
          "old_api": null,
          "new_api": "isCancelled",
          "old_text": null,
          "new_text": "isCancelled()",
          "old_line_content": "    std::unique_ptr<ThreadPool> thread_pool;",
          "new_line_content": "    if (isCancelled())",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "data_variants.empty()",
          "old_line_content": "            data_variants, final, data_variants.type != AggregatedDataVariants::Type::without_key));",
          "new_line_content": "    if (data_variants.empty())",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": null,
          "new_api": "sizeWithoutOverflowRow",
          "old_text": null,
          "new_text": "data_variants.sizeWithoutOverflowRow()",
          "old_line_content": "",
          "new_line_content": "    if (max_threads > 1 && data_variants.sizeWithoutOverflowRow() > 100000  /// TODO Make a custom threshold.",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": null,
          "new_api": "isTwoLevel",
          "old_text": null,
          "new_text": "data_variants.isTwoLevel()",
          "old_line_content": "    if (data_variants.type != AggregatedDataVariants::Type::without_key)",
          "new_line_content": "        && data_variants.isTwoLevel())                      /// TODO Use the shared thread pool with the `merge` function.",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": null,
          "new_api": "std::make_unique<ThreadPool>(max_threads)",
          "old_text": null,
          "new_text": "std::make_unique<ThreadPool>(max_threads)",
          "old_line_content": "    {",
          "new_line_content": "        thread_pool = std::make_unique<ThreadPool>(max_threads);",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": null,
          "new_api": "BlocksList",
          "old_text": null,
          "new_text": "BlocksList()",
          "old_line_content": "        else",
          "new_line_content": "        return BlocksList();",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": null,
          "new_api": "prepareBlockAndFillWithoutKey",
          "old_text": null,
          "new_text": "prepareBlockAndFillWithoutKey(\n            data_variants, final, data_variants.type != AggregatedDataVariants::Type::without_key)",
          "old_line_content": "",
          "new_line_content": "        blocks.emplace_back(prepareBlockAndFillWithoutKey(",
          "content_same": false
        },
        {
          "line": 1502,
          "old_api": null,
          "new_api": "isCancelled",
          "old_text": null,
          "new_text": "isCancelled()",
          "old_line_content": "        /// data_variants will not destroy the states of aggregate functions in the destructor.",
          "new_line_content": "    if (isCancelled())",
          "content_same": false
        },
        {
          "line": 1503,
          "old_api": null,
          "new_api": "BlocksList",
          "old_text": null,
          "new_text": "BlocksList()",
          "old_line_content": "        /// Now ColumnAggregateFunction owns the states.",
          "new_line_content": "        return BlocksList();",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "thread_pool.get()",
          "old_line_content": "    size_t rows = 0;",
          "new_line_content": "            blocks.splice(blocks.end(), prepareBlocksAndFillTwoLevel(data_variants, final, thread_pool.get()));",
          "content_same": false
        },
        {
          "line": 1521,
          "old_api": null,
          "new_api": "BlocksList",
          "old_text": null,
          "new_text": "BlocksList()",
          "old_line_content": "        \"Converted aggregated data to blocks. {} rows, {} in {} sec. ({} rows/sec., {}/sec.)\",",
          "new_line_content": "        return BlocksList();",
          "content_same": false
        },
        {
          "line": 1528,
          "old_api": null,
          "new_api": "rows",
          "old_text": null,
          "new_text": "block.rows()",
          "old_line_content": "",
          "new_line_content": "        rows += block.rows();",
          "content_same": false
        },
        {
          "line": 1529,
          "old_api": null,
          "new_api": "bytes",
          "old_text": null,
          "new_text": "block.bytes()",
          "old_line_content": "",
          "new_line_content": "        bytes += block.bytes();",
          "content_same": false
        },
        {
          "line": 1532,
          "old_api": null,
          "new_api": "elapsedSeconds",
          "old_text": null,
          "new_text": "watch.elapsedSeconds()",
          "old_line_content": "    Table & table_dst,",
          "new_line_content": "    double elapsed_seconds = watch.elapsedSeconds();",
          "content_same": false
        },
        {
          "line": 1533,
          "old_api": null,
          "new_api": "LOG_TRACE",
          "old_text": null,
          "new_text": "LOG_TRACE(log,\n        \"Converted aggregated data to blocks. {} rows, {} in {} sec. ({} rows/sec., {}/sec.)\",\n        rows, ReadableSize(bytes),\n        elapsed_seconds, rows / elapsed_seconds,\n        ReadableSize(bytes / elapsed_seconds))",
          "old_line_content": "    Table & table_src,",
          "new_line_content": "    LOG_TRACE(log,",
          "content_same": false
        },
        {
          "line": 1535,
          "old_api": null,
          "new_api": "ReadableSize",
          "old_text": null,
          "new_text": "ReadableSize(bytes)",
          "old_line_content": "{",
          "new_line_content": "        rows, ReadableSize(bytes),",
          "content_same": false
        },
        {
          "line": 1537,
          "old_api": null,
          "new_api": "ReadableSize",
          "old_text": null,
          "new_text": "ReadableSize(bytes / elapsed_seconds)",
          "old_line_content": "    {",
          "new_line_content": "        ReadableSize(bytes / elapsed_seconds));",
          "content_same": false
        },
        {
          "line": 1551,
          "old_api": null,
          "new_api": "hasNullKeyData",
          "old_text": null,
          "new_text": "table_src.hasNullKeyData()",
          "old_line_content": "                            arena);",
          "new_line_content": "        if (table_src.hasNullKeyData())",
          "content_same": false
        },
        {
          "line": 1553,
          "old_api": null,
          "new_api": "hasNullKeyData",
          "old_text": null,
          "new_text": "table_dst.hasNullKeyData()",
          "old_line_content": "                for (size_t i = 0; i < params.aggregates_size; ++i)",
          "new_line_content": "            if (!table_dst.hasNullKeyData())",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": null,
          "new_api": "getNullKeyData",
          "old_text": null,
          "new_text": "table_src.getNullKeyData()",
          "old_line_content": "            }",
          "new_line_content": "                table_dst.getNullKeyData() = table_src.getNullKeyData();",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": null,
          "new_api": "getNullKeyData",
          "old_text": null,
          "new_text": "aggregate_functions[i]->merge(\n                            table_dst.getNullKeyData() + offsets_of_aggregate_states[i],\n                            table_src.getNullKeyData() + offsets_of_aggregate_states[i],\n                            arena)",
          "old_line_content": "    }",
          "new_line_content": "                    aggregate_functions[i]->merge(",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": null,
          "new_api": "getNullKeyData",
          "old_text": null,
          "new_text": "table_dst.getNullKeyData()",
          "old_line_content": "}",
          "new_line_content": "                            table_dst.getNullKeyData() + offsets_of_aggregate_states[i],",
          "content_same": false
        },
        {
          "line": 1563,
          "old_api": null,
          "new_api": "getNullKeyData",
          "old_text": null,
          "new_text": "table_src.getNullKeyData()",
          "old_line_content": "",
          "new_line_content": "                            table_src.getNullKeyData() + offsets_of_aggregate_states[i],",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": null,
          "new_api": "getNullKeyData",
          "old_text": null,
          "new_text": "aggregate_functions[i]->destroy(\n                            table_src.getNullKeyData() + offsets_of_aggregate_states[i])",
          "old_line_content": "    Table & table_dst,",
          "new_line_content": "                    aggregate_functions[i]->destroy(",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": null,
          "new_api": "getNullKeyData",
          "old_text": null,
          "new_text": "table_src.getNullKeyData()",
          "old_line_content": "    Table & table_src,",
          "new_line_content": "                            table_src.getNullKeyData() + offsets_of_aggregate_states[i]);",
          "content_same": false
        },
        {
          "line": 1571,
          "old_api": null,
          "new_api": "hasNullKeyData",
          "old_text": null,
          "new_text": "table_src.hasNullKeyData()",
          "old_line_content": "    if constexpr (Method::low_cardinality_optimization)",
          "new_line_content": "            table_src.hasNullKeyData() = false;",
          "content_same": false
        },
        {
          "line": 1585,
          "old_api": null,
          "new_api": "mergeDataNullKey<Method, Table>(table_dst, table_src, arena)",
          "old_text": null,
          "new_text": "mergeDataNullKey<Method, Table>(table_dst, table_src, arena)",
          "old_line_content": "            for (size_t i = 0; i < params.aggregates_size; ++i)",
          "new_line_content": "        mergeDataNullKey<Method, Table>(table_dst, table_src, arena);",
          "content_same": false
        },
        {
          "line": 1587,
          "old_api": null,
          "new_api": "mergeToViaEmplace",
          "old_text": null,
          "new_text": "table_src.mergeToViaEmplace(table_dst,\n        [&](AggregateDataPtr & dst, AggregateDataPtr & src, bool inserted)\n    {\n        if (!inserted)\n        {\n            for (size_t i = 0; i < params.aggregates_size; ++i)\n                aggregate_functions[i]->merge(\n                    dst + offsets_of_aggregate_states[i],\n                    src + offsets_of_aggregate_states[i],\n                    arena);\n\n            for (size_t i = 0; i < params.aggregates_size; ++i)\n                aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i]);\n        }\n        else\n        {\n            dst = src;\n        }\n\n        src = nullptr;\n    })",
          "old_line_content": "        }",
          "new_line_content": "    table_src.mergeToViaEmplace(table_dst,",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": null,
          "new_api": "merge",
          "old_text": null,
          "new_text": "aggregate_functions[i]->merge(\n                    dst + offsets_of_aggregate_states[i],\n                    src + offsets_of_aggregate_states[i],\n                    arena)",
          "old_line_content": "        src = nullptr;",
          "new_line_content": "                aggregate_functions[i]->merge(",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": null,
          "new_api": "destroy",
          "old_text": null,
          "new_text": "aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i])",
          "old_line_content": "template <typename Method, typename Table>",
          "new_line_content": "                aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i]);",
          "content_same": false
        },
        {
          "line": 1623,
          "old_api": null,
          "new_api": "mergeToViaFind",
          "old_text": null,
          "new_text": "table_src.mergeToViaFind(table_dst, [&](AggregateDataPtr dst, AggregateDataPtr & src, bool found)\n    {\n        AggregateDataPtr res_data = found ? dst : overflows;\n\n        for (size_t i = 0; i < params.aggregates_size; ++i)\n            aggregate_functions[i]->merge(\n                res_data + offsets_of_aggregate_states[i],\n                src + offsets_of_aggregate_states[i],\n                arena);\n\n        for (size_t i = 0; i < params.aggregates_size; ++i)\n            aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i]);\n\n        src = nullptr;\n    })",
          "old_line_content": "        src = nullptr;",
          "new_line_content": "    table_src.mergeToViaFind(table_dst, [&](AggregateDataPtr dst, AggregateDataPtr & src, bool found)",
          "content_same": false
        },
        {
          "line": 1628,
          "old_api": null,
          "new_api": "merge",
          "old_text": null,
          "new_text": "aggregate_functions[i]->merge(\n                res_data + offsets_of_aggregate_states[i],\n                src + offsets_of_aggregate_states[i],\n                arena)",
          "old_line_content": "template <typename Method, typename Table>",
          "new_line_content": "            aggregate_functions[i]->merge(",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": null,
          "new_api": "destroy",
          "old_text": null,
          "new_text": "aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i])",
          "old_line_content": "    /// Note : will create data for NULL key if not exist",
          "new_line_content": "            aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i]);",
          "content_same": false
        },
        {
          "line": 1649,
          "old_api": null,
          "new_api": "mergeDataNullKey<Method, Table>(table_dst, table_src, arena)",
          "old_text": null,
          "new_text": "mergeDataNullKey<Method, Table>(table_dst, table_src, arena)",
          "old_line_content": "",
          "new_line_content": "        mergeDataNullKey<Method, Table>(table_dst, table_src, arena);",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": null,
          "new_api": "merge",
          "old_text": null,
          "new_text": "aggregate_functions[i]->merge(\n                dst + offsets_of_aggregate_states[i],\n                src + offsets_of_aggregate_states[i],\n                arena)",
          "old_line_content": "",
          "new_line_content": "            aggregate_functions[i]->merge(",
          "content_same": false
        },
        {
          "line": 1664,
          "old_api": null,
          "new_api": "destroy",
          "old_text": null,
          "new_text": "aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i])",
          "old_line_content": "    /// We merge all aggregation results to the first.",
          "new_line_content": "            aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i]);",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": null,
          "new_api": "clearAndShrink",
          "old_text": null,
          "new_text": "table_src.clearAndShrink()",
          "old_line_content": "        AggregatedDataWithoutKey & current_data = non_empty_data[result_num]->without_key;",
          "new_line_content": "    table_src.clearAndShrink();",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "non_empty_data.size()",
          "old_line_content": "}",
          "new_line_content": "    for (size_t result_num = 1, size = non_empty_data.size(); result_num < size; ++result_num)",
          "content_same": false
        },
        {
          "line": 1684,
          "old_api": null,
          "new_api": "merge",
          "old_text": null,
          "new_text": "aggregate_functions[i]->merge(res_data + offsets_of_aggregate_states[i], current_data + offsets_of_aggregate_states[i], res->aggregates_pool)",
          "old_line_content": "{",
          "new_line_content": "            aggregate_functions[i]->merge(res_data + offsets_of_aggregate_states[i], current_data + offsets_of_aggregate_states[i], res->aggregates_pool);",
          "content_same": false
        },
        {
          "line": 1687,
          "old_api": null,
          "new_api": "destroy",
          "old_text": null,
          "new_text": "aggregate_functions[i]->destroy(current_data + offsets_of_aggregate_states[i])",
          "old_line_content": "",
          "new_line_content": "            aggregate_functions[i]->destroy(current_data + offsets_of_aggregate_states[i]);",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": null,
          "new_api": "sizeWithoutOverflowRow",
          "old_text": null,
          "new_text": "res->sizeWithoutOverflowRow()",
          "old_line_content": "                res->without_key,",
          "new_line_content": "        if (!checkLimits(res->sizeWithoutOverflowRow(), no_more_keys))",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": null,
          "new_api": "getDataVariant<Method>(*res)",
          "old_text": null,
          "new_text": "getDataVariant<Method>(*res)",
          "old_line_content": "                res->aggregates_pool);",
          "new_line_content": "                getDataVariant<Method>(*res).data,",
          "content_same": false
        },
        {
          "line": 1712,
          "old_api": null,
          "new_api": "getDataVariant<Method>(current)",
          "old_text": null,
          "new_text": "getDataVariant<Method>(current)",
          "old_line_content": "",
          "new_line_content": "                getDataVariant<Method>(current).data,",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": null,
          "new_api": "mergeDataNoMoreKeysImpl<Method>(\n                getDataVariant<Method>(*res).data,\n                res->without_key,\n                getDataVariant<Method>(current).data,\n                res->aggregates_pool)",
          "old_text": null,
          "new_text": "mergeDataNoMoreKeysImpl<Method>(\n                getDataVariant<Method>(*res).data,\n                res->without_key,\n                getDataVariant<Method>(current).data,\n                res->aggregates_pool)",
          "old_line_content": "    }",
          "new_line_content": "            mergeDataNoMoreKeysImpl<Method>(",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": null,
          "new_api": "getDataVariant<Method>(*res)",
          "old_text": null,
          "new_text": "getDataVariant<Method>(*res)",
          "old_line_content": "}",
          "new_line_content": "                getDataVariant<Method>(*res).data,",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": null,
          "new_api": "getDataVariant<Method>(current)",
          "old_text": null,
          "new_text": "getDataVariant<Method>(current)",
          "old_line_content": "#define M(NAME) \\",
          "new_line_content": "                getDataVariant<Method>(current).data,",
          "content_same": false
        },
        {
          "line": 1722,
          "old_api": null,
          "new_api": "getDataVariant<Method>(*res)",
          "old_text": null,
          "new_text": "getDataVariant<Method>(*res)",
          "old_line_content": "#undef M",
          "new_line_content": "                getDataVariant<Method>(*res).data,",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": null,
          "new_api": "getDataVariant<Method>(current)",
          "old_text": null,
          "new_text": "getDataVariant<Method>(current)",
          "old_line_content": "",
          "new_line_content": "                getDataVariant<Method>(current).data,",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": null,
          "new_api": "APPLY_FOR_VARIANTS_SINGLE_LEVEL",
          "old_text": null,
          "new_text": "APPLY_FOR_VARIANTS_SINGLE_LEVEL(M)",
          "old_line_content": "",
          "new_line_content": "    APPLY_FOR_VARIANTS_SINGLE_LEVEL(M)",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data.size()",
          "old_line_content": "",
          "new_line_content": "    for (size_t result_num = 1, size = data.size(); result_num < size; ++result_num)",
          "content_same": false
        },
        {
          "line": 1745,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "is_cancelled->load(std::memory_order_seq_cst)",
          "old_line_content": "/** Combines aggregation states together, turns them into blocks, and outputs streams.",
          "new_line_content": "        if (is_cancelled && is_cancelled->load(std::memory_order_seq_cst))",
          "content_same": false
        },
        {
          "line": 1750,
          "old_api": null,
          "new_api": "mergeDataImpl<Method>(\n            getDataVariant<Method>(*res).data.impls[bucket],\n            getDataVariant<Method>(current).data.impls[bucket],\n            arena)",
          "old_text": null,
          "new_text": "mergeDataImpl<Method>(\n            getDataVariant<Method>(*res).data.impls[bucket],\n            getDataVariant<Method>(current).data.impls[bucket],\n            arena)",
          "old_line_content": "class MergingAndConvertingBlockInputStream : public IBlockInputStream",
          "new_line_content": "        mergeDataImpl<Method>(",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": null,
          "new_api": "getDataVariant<Method>(*res)",
          "old_text": null,
          "new_text": "getDataVariant<Method>(*res)",
          "old_line_content": "{",
          "new_line_content": "            getDataVariant<Method>(*res).data.impls[bucket],",
          "content_same": false
        },
        {
          "line": 1752,
          "old_api": null,
          "new_api": "getDataVariant<Method>(current)",
          "old_text": null,
          "new_text": "getDataVariant<Method>(current)",
          "old_line_content": "public:",
          "new_line_content": "            getDataVariant<Method>(current).data.impls[bucket],",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data[0]->aggregates_pools.size()",
          "old_line_content": "    {",
          "new_line_content": "        if (!data.empty() && threads > data[0]->aggregates_pools.size())",
          "content_same": false
        },
        {
          "line": 1776,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "first_pool.size()",
          "old_line_content": "        /// We need to wait for threads to finish before destructor of 'parallel_merge_data',",
          "new_line_content": "            for (size_t j = first_pool.size(); j < threads; j++)",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": null,
          "new_api": "std::make_shared<Arena>()",
          "old_text": null,
          "new_text": "std::make_shared<Arena>()",
          "old_line_content": "        ///  because the threads access 'parallel_merge_data'.",
          "new_line_content": "                first_pool.emplace_back(std::make_shared<Arena>());",
          "content_same": false
        },
        {
          "line": 1783,
          "old_api": null,
          "new_api": "getHeader",
          "old_text": null,
          "new_text": "aggregator.getHeader(final)",
          "old_line_content": "    Block readImpl() override",
          "new_line_content": "    Block getHeader() const override { return aggregator.getHeader(final); }",
          "content_same": false
        },
        {
          "line": 1787,
          "old_api": null,
          "new_api": "Poco::Logger::get(__PRETTY_FUNCTION__)",
          "old_text": null,
          "new_text": "Poco::Logger::get(__PRETTY_FUNCTION__)",
          "old_line_content": "",
          "new_line_content": "        LOG_TRACE(&Poco::Logger::get(__PRETTY_FUNCTION__), \"Waiting for threads to finish\");",
          "content_same": false
        },
        {
          "line": 1792,
          "old_api": null,
          "new_api": "wait",
          "old_text": null,
          "new_text": "parallel_merge_data->pool.wait()",
          "old_line_content": "",
          "new_line_content": "            parallel_merge_data->pool.wait();",
          "content_same": false
        },
        {
          "line": 1798,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "data.empty()",
          "old_line_content": "            {",
          "new_line_content": "        if (data.empty())",
          "content_same": false
        },
        {
          "line": 1812,
          "old_api": null,
          "new_api": "mergeWithoutKeyDataImpl",
          "old_text": null,
          "new_text": "aggregator.mergeWithoutKeyDataImpl(data)",
          "old_line_content": "",
          "new_line_content": "                aggregator.mergeWithoutKeyDataImpl(data);",
          "content_same": false
        },
        {
          "line": 1813,
          "old_api": null,
          "new_api": "prepareBlockAndFillWithoutKey",
          "old_text": null,
          "new_text": "aggregator.prepareBlockAndFillWithoutKey(\n                    *first, final, first->type != AggregatedDataVariants::Type::without_key)",
          "old_line_content": "            ++current_bucket_num;",
          "new_line_content": "                return aggregator.prepareBlockAndFillWithoutKey(",
          "content_same": false
        },
        {
          "line": 1818,
          "old_api": null,
          "new_api": "isTwoLevel",
          "old_text": null,
          "new_text": "first->isTwoLevel()",
          "old_line_content": "            if (false) {} // NOLINT",
          "new_line_content": "        if (!first->isTwoLevel())",
          "content_same": false
        },
        {
          "line": 1837,
          "old_api": null,
          "new_api": "prepareBlockAndFillSingleLevel",
          "old_text": null,
          "new_text": "aggregator.prepareBlockAndFillSingleLevel(*first, final)",
          "old_line_content": "            while (true)",
          "new_line_content": "            return aggregator.prepareBlockAndFillSingleLevel(*first, final);",
          "content_same": false
        },
        {
          "line": 1843,
          "old_api": null,
          "new_api": "std::make_unique<ParallelMergeData>(threads)",
          "old_text": null,
          "new_text": "std::make_unique<ParallelMergeData>(threads)",
          "old_line_content": "",
          "new_line_content": "                parallel_merge_data = std::make_unique<ParallelMergeData>(threads);",
          "content_same": false
        },
        {
          "line": 1855,
          "old_api": null,
          "new_api": "std::rethrow_exception(parallel_merge_data->exception)",
          "old_text": null,
          "new_text": "std::rethrow_exception(parallel_merge_data->exception)",
          "old_line_content": "                    else if (current_bucket_num >= NUM_BUCKETS)",
          "new_line_content": "                    std::rethrow_exception(parallel_merge_data->exception);",
          "content_same": false
        },
        {
          "line": 1857,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "parallel_merge_data->ready_blocks.find(current_bucket_num)",
          "old_line_content": "                }",
          "new_line_content": "                auto it = parallel_merge_data->ready_blocks.find(current_bucket_num);",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "parallel_merge_data->ready_blocks.end()",
          "old_line_content": "",
          "new_line_content": "                if (it != parallel_merge_data->ready_blocks.end())",
          "content_same": false
        },
        {
          "line": 1861,
          "old_api": null,
          "new_api": "scheduleThreadForNextBucket",
          "old_text": null,
          "new_text": "scheduleThreadForNextBucket()",
          "old_line_content": "",
          "new_line_content": "                    scheduleThreadForNextBucket();",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": null,
          "new_api": "swap",
          "old_text": null,
          "new_text": "res.swap(it->second)",
          "old_line_content": "",
          "new_line_content": "                        res.swap(it->second);",
          "content_same": false
        },
        {
          "line": 1872,
          "old_api": null,
          "new_api": "wait",
          "old_text": null,
          "new_text": "parallel_merge_data->condvar.wait(lock)",
          "old_line_content": "    Int32 current_bucket_num = -1;",
          "new_line_content": "                parallel_merge_data->condvar.wait(lock);",
          "content_same": false
        },
        {
          "line": 1887,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "    std::unique_ptr<ParallelMergeData> parallel_merge_data;",
          "new_line_content": "    static constexpr Int32 NUM_BUCKETS = 256;",
          "content_same": false
        },
        {
          "line": 1908,
          "old_api": null,
          "new_api": "scheduleOrThrowOnError",
          "old_text": null,
          "new_text": "parallel_merge_data->pool.scheduleOrThrowOnError(\n            [this, max_scheduled_bucket_num = max_scheduled_bucket_num, group = CurrentThread::getGroup()]\n            { return thread(max_scheduled_bucket_num, group); })",
          "old_line_content": "",
          "new_line_content": "        parallel_merge_data->pool.scheduleOrThrowOnError(",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": null,
          "new_api": "thread",
          "old_text": null,
          "new_text": "thread(max_scheduled_bucket_num, group)",
          "old_line_content": "",
          "new_line_content": "            { return thread(max_scheduled_bucket_num, group); });",
          "content_same": false
        },
        {
          "line": 1919,
          "old_api": null,
          "new_api": "CurrentThread::attachToIfDetached(thread_group)",
          "old_text": null,
          "new_text": "CurrentThread::attachToIfDetached(thread_group)",
          "old_line_content": "            if (false) {} // NOLINT",
          "new_line_content": "                CurrentThread::attachToIfDetached(thread_group);",
          "content_same": false
        },
        {
          "line": 1929,
          "old_api": null,
          "new_api": "static_cast<size_t>(bucket_num)",
          "old_text": null,
          "new_text": "static_cast<size_t>(bucket_num)",
          "old_line_content": "",
          "new_line_content": "            size_t thread_number = static_cast<size_t>(bucket_num) % threads;",
          "content_same": false
        },
        {
          "line": 1930,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "merged_data.aggregates_pools.at(thread_number).get()",
          "old_line_content": "            std::lock_guard lock(parallel_merge_data->mutex);",
          "new_line_content": "            Arena * arena = merged_data.aggregates_pools.at(thread_number).get();",
          "content_same": false
        },
        {
          "line": 1944,
          "old_api": null,
          "new_api": "std::move(block)",
          "old_text": null,
          "new_text": "std::move(block)",
          "old_line_content": "ManyAggregatedDataVariants Aggregator::prepareVariantsToMerge(ManyAggregatedDataVariants & data_variants) const",
          "new_line_content": "            parallel_merge_data->ready_blocks[bucket_num] = std::move(block);",
          "content_same": false
        },
        {
          "line": 1950,
          "old_api": null,
          "new_api": "std::current_exception()",
          "old_text": null,
          "new_text": "std::current_exception()",
          "old_line_content": "",
          "new_line_content": "                parallel_merge_data->exception = std::current_exception();",
          "content_same": false
        },
        {
          "line": 1953,
          "old_api": null,
          "new_api": "notify_all",
          "old_text": null,
          "new_text": "parallel_merge_data->condvar.notify_all()",
          "old_line_content": "    for (auto & data : data_variants)",
          "new_line_content": "        parallel_merge_data->condvar.notify_all();",
          "content_same": false
        },
        {
          "line": 1959,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "data_variants.empty()",
          "old_line_content": "",
          "new_line_content": "    if (data_variants.empty())",
          "content_same": false
        },
        {
          "line": 1962,
          "old_api": null,
          "new_api": "LOG_TRACE",
          "old_text": null,
          "new_text": "LOG_TRACE(log, \"Merging aggregated data\")",
          "old_line_content": "        /// Sort the states in descending order so that the merge is more efficient (since all states are merged into the first).",
          "new_line_content": "    LOG_TRACE(log, \"Merging aggregated data\");",
          "content_same": false
        },
        {
          "line": 1965,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data_variants.size()",
          "old_line_content": "            {",
          "new_line_content": "    non_empty_data.reserve(data_variants.size());",
          "content_same": false
        },
        {
          "line": 1967,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "data->empty()",
          "old_line_content": "            });",
          "new_line_content": "        if (!data->empty())",
          "content_same": false
        },
        {
          "line": 1968,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "non_empty_data.push_back(data)",
          "old_line_content": "    }",
          "new_line_content": "            non_empty_data.push_back(data);",
          "content_same": false
        },
        {
          "line": 1970,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "non_empty_data.empty()",
          "old_line_content": "    /// If at least one of the options is two-level, then convert all the options into two-level ones, if there are not such.",
          "new_line_content": "    if (non_empty_data.empty())",
          "content_same": false
        },
        {
          "line": 1973,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "non_empty_data.size()",
          "old_line_content": "    bool has_at_least_one_two_level = false;",
          "new_line_content": "    if (non_empty_data.size() > 1)",
          "content_same": false
        },
        {
          "line": 1979,
          "old_api": null,
          "new_api": "sizeWithoutOverflowRow",
          "old_text": null,
          "new_text": "rhs->sizeWithoutOverflowRow()",
          "old_line_content": "            break;",
          "new_line_content": "                return lhs->sizeWithoutOverflowRow() > rhs->sizeWithoutOverflowRow();",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": null,
          "new_api": "isTwoLevel",
          "old_text": null,
          "new_text": "variant->isTwoLevel()",
          "old_line_content": "",
          "new_line_content": "        if (variant->isTwoLevel())",
          "content_same": false
        },
        {
          "line": 2003,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "non_empty_data.size()",
          "old_line_content": "}",
          "new_line_content": "    for (size_t i = 1, size = non_empty_data.size(); i < size; ++i)",
          "content_same": false
        },
        {
          "line": 2006,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\"Cannot merge different aggregated data variants.\", ErrorCodes::CANNOT_MERGE_DIFFERENT_AGGREGATED_DATA_VARIANTS)",
          "old_line_content": "    ManyAggregatedDataVariants & data_variants, bool final, size_t max_threads) const",
          "new_line_content": "            throw Exception(\"Cannot merge different aggregated data variants.\", ErrorCodes::CANNOT_MERGE_DIFFERENT_AGGREGATED_DATA_VARIANTS);",
          "content_same": false
        },
        {
          "line": 2012,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "non_empty_data[i]->aggregates_pools.end()",
          "old_line_content": "",
          "new_line_content": "            non_empty_data[i]->aggregates_pools.begin(), non_empty_data[i]->aggregates_pools.end());",
          "content_same": false
        },
        {
          "line": 2021,
          "old_api": null,
          "new_api": "prepareVariantsToMerge",
          "old_text": null,
          "new_text": "prepareVariantsToMerge(data_variants)",
          "old_line_content": "    Method & method [[maybe_unused]],",
          "new_line_content": "    ManyAggregatedDataVariants non_empty_data = prepareVariantsToMerge(data_variants);",
          "content_same": false
        },
        {
          "line": 2023,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "non_empty_data.empty()",
          "old_line_content": "    AggregateDataPtr overflow_row) const",
          "new_line_content": "    if (non_empty_data.empty())",
          "content_same": false
        },
        {
          "line": 2024,
          "old_api": null,
          "new_api": "getHeader",
          "old_text": null,
          "new_text": "getHeader(final)",
          "old_line_content": "{",
          "new_line_content": "        return std::make_unique<NullBlockInputStream>(getHeader(final));",
          "content_same": false
        },
        {
          "line": 2026,
          "old_api": null,
          "new_api": "std::make_unique<MergingAndConvertingBlockInputStream>(*this, non_empty_data, final, max_threads)",
          "old_text": null,
          "new_text": "std::make_unique<MergingAndConvertingBlockInputStream>(*this, non_empty_data, final, max_threads)",
          "old_line_content": "    AggregateColumnsConstData aggregate_columns(params.aggregates_size);",
          "new_line_content": "    return std::make_unique<MergingAndConvertingBlockInputStream>(*this, non_empty_data, final, max_threads);",
          "content_same": false
        },
        {
          "line": 2043,
          "old_api": null,
          "new_api": "safeGetByPosition",
          "old_text": null,
          "new_text": "block.safeGetByPosition(i).column.get()",
          "old_line_content": "    {",
          "new_line_content": "        key_columns[i] = block.safeGetByPosition(i).column.get();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2049,
          "old_api": "isInserted",
          "new_api": null,
          "old_text": "emplace_result.isInserted()",
          "new_text": null,
          "old_line_content": "            if (emplace_result.isInserted())",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2051,
          "old_api": "setMapped",
          "new_api": null,
          "old_text": "emplace_result.setMapped(nullptr)",
          "new_text": null,
          "old_line_content": "                emplace_result.setMapped(nullptr);",
          "new_line_content": "    typename Method::State state(key_columns, key_sizes, aggregation_state_cache);",
          "content_same": false
        },
        {
          "line": 2053,
          "old_api": "alignedAlloc",
          "new_api": null,
          "old_text": "aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states)",
          "new_text": null,
          "old_line_content": "                aggregate_data = aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);",
          "new_line_content": "    /// For all rows.",
          "content_same": false
        },
        {
          "line": 2056,
          "old_api": "setMapped",
          "new_api": null,
          "old_text": "emplace_result.setMapped(aggregate_data)",
          "new_text": null,
          "old_line_content": "                emplace_result.setMapped(aggregate_data);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2059,
          "old_api": "getMapped",
          "new_api": null,
          "old_text": "emplace_result.getMapped()",
          "new_text": null,
          "old_line_content": "                aggregate_data = emplace_result.getMapped();",
          "new_line_content": "        if (!no_more_keys)",
          "content_same": false
        },
        {
          "line": 2063,
          "old_api": "findKey",
          "new_api": null,
          "old_text": "state.findKey(data, i, *aggregates_pool)",
          "new_text": null,
          "old_line_content": "            auto find_result = state.findKey(data, i, *aggregates_pool);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 2065,
          "old_api": "getMapped",
          "new_api": null,
          "old_text": "find_result.getMapped()",
          "new_text": null,
          "old_line_content": "                aggregate_data = find_result.getMapped();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2085,
          "old_api": "clear",
          "new_api": null,
          "old_text": "block.clear()",
          "new_text": null,
          "old_line_content": "    block.clear();",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 2100,
          "old_api": "mergeStreamsImplCase<true>(block, aggregates_pool, method, data, overflow_row)",
          "new_api": null,
          "old_text": "mergeStreamsImplCase<true>(block, aggregates_pool, method, data, overflow_row)",
          "new_text": null,
          "old_line_content": "        mergeStreamsImplCase<true>(block, aggregates_pool, method, data, overflow_row);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2114,
          "old_api": "getByName",
          "new_api": null,
          "old_text": "block.getByName(aggregate_column_name)",
          "new_text": null,
          "old_line_content": "        aggregate_columns[i] = &typeid_cast<const ColumnAggregateFunction &>(*block.getByName(aggregate_column_name).column).getData();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2120,
          "old_api": "alignedAlloc",
          "new_api": null,
          "old_text": "result.aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states)",
          "new_text": null,
          "old_line_content": "        AggregateDataPtr place = result.aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2121,
          "old_api": "createAggregateStates",
          "new_api": null,
          "old_text": "createAggregateStates(place)",
          "new_text": null,
          "old_line_content": "        createAggregateStates(place);",
          "new_line_content": "    AggregateColumnsConstData aggregate_columns(params.aggregates_size);",
          "content_same": false
        },
        {
          "line": 2130,
          "old_api": "clear",
          "new_api": null,
          "old_text": "block.clear()",
          "new_text": null,
          "old_line_content": "    block.clear();",
          "new_line_content": "    AggregatedDataWithoutKey & res = result.without_key;",
          "content_same": false
        },
        {
          "line": 2136,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "    if (isCancelled())",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2147,
          "old_api": "LOG_TRACE",
          "new_api": null,
          "old_text": "LOG_TRACE(log, \"Reading blocks of partially aggregated data.\")",
          "new_text": null,
          "old_line_content": "    LOG_TRACE(log, \"Reading blocks of partially aggregated data.\");",
          "new_line_content": "void Aggregator::mergeStream(const BlockInputStreamPtr & stream, AggregatedDataVariants & result, size_t max_threads)",
          "content_same": false
        },
        {
          "line": 2151,
          "old_api": "read",
          "new_api": null,
          "old_text": "stream->read()",
          "new_text": null,
          "old_line_content": "    while (Block block = stream->read())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2153,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "        if (isCancelled())",
          "new_line_content": "      *  then blocks will contain information about the number of the bucket.",
          "content_same": false
        },
        {
          "line": 2156,
          "old_api": "rows",
          "new_api": null,
          "old_text": "block.rows()",
          "new_text": null,
          "old_line_content": "        total_input_rows += block.rows();",
          "new_line_content": "      */",
          "content_same": false
        },
        {
          "line": 2158,
          "old_api": "std::move(block)",
          "new_api": null,
          "old_text": "std::move(block)",
          "new_text": null,
          "old_line_content": "        bucket_to_blocks[block.info.bucket_num].emplace_back(std::move(block));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2161,
          "old_api": "LOG_TRACE",
          "new_api": null,
          "old_text": "LOG_TRACE(log, \"Read {} blocks of partially aggregated data, total {} rows.\", total_input_blocks, total_input_rows)",
          "new_text": null,
          "old_line_content": "    LOG_TRACE(log, \"Read {} blocks of partially aggregated data, total {} rows.\", total_input_blocks, total_input_rows);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2163,
          "old_api": "mergeBlocks",
          "new_api": null,
          "old_text": "mergeBlocks(bucket_to_blocks, result, max_threads)",
          "new_text": null,
          "old_line_content": "    mergeBlocks(bucket_to_blocks, result, max_threads);",
          "new_line_content": "    size_t total_input_blocks = 0;",
          "content_same": false
        },
        {
          "line": 2168,
          "old_api": "empty",
          "new_api": null,
          "old_text": "bucket_to_blocks.empty()",
          "new_text": null,
          "old_line_content": "    if (bucket_to_blocks.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2180,
          "old_api": "rbegin",
          "new_api": null,
          "old_text": "bucket_to_blocks.rbegin()",
          "new_text": null,
          "old_line_content": "    auto max_bucket = bucket_to_blocks.rbegin()->first;",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2189,
          "old_api": "APPLY_FOR_VARIANTS_CONVERTIBLE_TO_TWO_LEVEL",
          "new_api": null,
          "old_text": "APPLY_FOR_VARIANTS_CONVERTIBLE_TO_TWO_LEVEL(M)",
          "new_text": null,
          "old_line_content": "        APPLY_FOR_VARIANTS_CONVERTIBLE_TO_TWO_LEVEL(M)",
          "new_line_content": "    /** `minus one` means the absence of information about the bucket",
          "content_same": false
        },
        {
          "line": 2194,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "    if (isCancelled())",
          "new_line_content": "    bool has_two_level = max_bucket >= 0;",
          "content_same": false
        },
        {
          "line": 2200,
          "old_api": "init",
          "new_api": null,
          "old_text": "result.init(method_chosen)",
          "new_text": null,
          "old_line_content": "    result.init(method_chosen);",
          "new_line_content": "            method_chosen = AggregatedDataVariants::Type::NAME ## _two_level;",
          "content_same": false
        },
        {
          "line": 2204,
          "old_api": "count",
          "new_api": null,
          "old_text": "bucket_to_blocks.count(-1)",
          "new_text": null,
          "old_line_content": "    bool has_blocks_with_unknown_bucket = bucket_to_blocks.count(-1);",
          "new_line_content": "    #undef M",
          "content_same": false
        },
        {
          "line": 2214,
          "old_api": "LOG_TRACE",
          "new_api": null,
          "old_text": "LOG_TRACE(log, \"Merging partially aggregated two-level data.\")",
          "new_text": null,
          "old_line_content": "        LOG_TRACE(log, \"Merging partially aggregated two-level data.\");",
          "new_line_content": "    result.keys_size = params.keys_size;",
          "content_same": false
        },
        {
          "line": 2219,
          "old_api": "CurrentThread::attachToIfDetached(thread_group)",
          "new_api": null,
          "old_text": "CurrentThread::attachToIfDetached(thread_group)",
          "new_text": null,
          "old_line_content": "                CurrentThread::attachToIfDetached(thread_group);",
          "new_line_content": "    /// First, parallel the merge for the individual buckets. Then we continue merge the data not allocated to the buckets.",
          "content_same": false
        },
        {
          "line": 2223,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "                if (isCancelled())",
          "new_line_content": "          *  from different threads it is difficult to update the general state for \"other\" keys (overflows).",
          "content_same": false
        },
        {
          "line": 2231,
          "old_api": "APPLY_FOR_VARIANTS_TWO_LEVEL",
          "new_api": null,
          "old_text": "APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "new_text": null,
          "old_line_content": "                    APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "new_line_content": "            if (thread_group)",
          "content_same": false
        },
        {
          "line": 2240,
          "old_api": "std::make_unique<ThreadPool>(max_threads)",
          "new_api": null,
          "old_text": "std::make_unique<ThreadPool>(max_threads)",
          "new_text": null,
          "old_line_content": "            thread_pool = std::make_unique<ThreadPool>(max_threads);",
          "new_line_content": "                else if (result.type == AggregatedDataVariants::Type::NAME) \\",
          "content_same": false
        },
        {
          "line": 2249,
          "old_api": "std::make_shared<Arena>()",
          "new_api": null,
          "old_text": "std::make_shared<Arena>()",
          "new_text": null,
          "old_line_content": "            result.aggregates_pools.push_back(std::make_shared<Arena>());",
          "new_line_content": "        };",
          "content_same": false
        },
        {
          "line": 2250,
          "old_api": "back",
          "new_api": null,
          "old_text": "result.aggregates_pools.back().get()",
          "new_text": null,
          "old_line_content": "            Arena * aggregates_pool = result.aggregates_pools.back().get();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2252,
          "old_api": "merge_bucket",
          "new_api": null,
          "old_text": "merge_bucket(bucket, aggregates_pool, group)",
          "new_text": null,
          "old_line_content": "            auto task = [group = CurrentThread::getGroup(), bucket, &merge_bucket, aggregates_pool]{ return merge_bucket(bucket, aggregates_pool, group); };",
          "new_line_content": "        if (max_threads > 1 && total_input_rows > 100000)    /// TODO Make a custom threshold.",
          "content_same": false
        },
        {
          "line": 2255,
          "old_api": "scheduleOrThrowOnError",
          "new_api": null,
          "old_text": "thread_pool->scheduleOrThrowOnError(task)",
          "new_text": null,
          "old_line_content": "                thread_pool->scheduleOrThrowOnError(task);",
          "new_line_content": "        for (const auto & bucket_blocks : bucket_to_blocks)",
          "content_same": false
        },
        {
          "line": 2257,
          "old_api": "task",
          "new_api": null,
          "old_text": "task()",
          "new_text": null,
          "old_line_content": "                task();",
          "new_line_content": "            const auto bucket = bucket_blocks.first;",
          "content_same": false
        },
        {
          "line": 2261,
          "old_api": "wait",
          "new_api": null,
          "old_text": "thread_pool->wait()",
          "new_text": null,
          "old_line_content": "            thread_pool->wait();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2266,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "    if (isCancelled())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2283,
          "old_api": "invalidate",
          "new_api": null,
          "old_text": "result.invalidate()",
          "new_text": null,
          "old_line_content": "                result.invalidate();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": "mergeWithoutKeyStreamsImpl",
          "new_api": null,
          "old_text": "mergeWithoutKeyStreamsImpl(block, result)",
          "new_text": null,
          "old_line_content": "                mergeWithoutKeyStreamsImpl(block, result);",
          "new_line_content": "        BlocksList & blocks = bucket_to_blocks[-1];",
          "content_same": false
        },
        {
          "line": 2297,
          "old_api": "APPLY_FOR_AGGREGATED_VARIANTS",
          "new_api": null,
          "old_text": "APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "new_text": null,
          "old_line_content": "            APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "new_line_content": "                return;",
          "content_same": false
        },
        {
          "line": 2303,
          "old_api": "LOG_TRACE",
          "new_api": null,
          "old_text": "LOG_TRACE(log, \"Merged partially aggregated single-level data.\")",
          "new_text": null,
          "old_line_content": "        LOG_TRACE(log, \"Merged partially aggregated single-level data.\");",
          "new_line_content": "            if (result.type == AggregatedDataVariants::Type::without_key || block.info.is_overflows)",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": "front",
          "new_api": null,
          "old_text": "blocks.front()",
          "new_text": null,
          "old_line_content": "    bool is_overflows = blocks.front().info.is_overflows;",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2337,
          "old_api": "APPLY_FOR_VARIANTS_THAT_MAY_USE_BETTER_HASH_FUNCTION",
          "new_api": null,
          "old_text": "APPLY_FOR_VARIANTS_THAT_MAY_USE_BETTER_HASH_FUNCTION(M)",
          "new_text": null,
          "old_line_content": "    APPLY_FOR_VARIANTS_THAT_MAY_USE_BETTER_HASH_FUNCTION(M)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": "init",
          "new_api": null,
          "old_text": "result.init(merge_method)",
          "new_text": null,
          "old_line_content": "    result.init(merge_method);",
          "new_line_content": "        merge_method = AggregatedDataVariants::Type::NAME ## _hash64; \\",
          "content_same": false
        },
        {
          "line": 2354,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "        if (isCancelled())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2370,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Unknown aggregated data variant.\", ErrorCodes::UNKNOWN_AGGREGATED_DATA_VARIANT)",
          "new_text": null,
          "old_line_content": "            throw Exception(\"Unknown aggregated data variant.\", ErrorCodes::UNKNOWN_AGGREGATED_DATA_VARIANT);",
          "new_line_content": "        if (bucket_num >= 0 && block.info.bucket_num != bucket_num)",
          "content_same": false
        },
        {
          "line": 2373,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "    if (isCancelled())",
          "new_line_content": "        if (result.type == AggregatedDataVariants::Type::without_key || is_overflows)",
          "content_same": false
        },
        {
          "line": 2378,
          "old_api": "prepareBlockAndFillWithoutKey",
          "new_api": null,
          "old_text": "prepareBlockAndFillWithoutKey(result, final, is_overflows)",
          "new_text": null,
          "old_line_content": "        block = prepareBlockAndFillWithoutKey(result, final, is_overflows);",
          "new_line_content": "            mergeStreamsImpl(block, result.aggregates_pool, *result.NAME, result.NAME->data, nullptr, false);",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": "rows",
          "new_api": null,
          "old_text": "block.rows()",
          "new_text": null,
          "old_line_content": "    size_t rows = block.rows();",
          "new_line_content": "    Block block;",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": "bytes",
          "new_api": null,
          "old_text": "block.bytes()",
          "new_text": null,
          "old_line_content": "    size_t bytes = block.bytes();",
          "new_line_content": "    if (result.type == AggregatedDataVariants::Type::without_key || is_overflows)",
          "content_same": false
        },
        {
          "line": 2392,
          "old_api": "LOG_TRACE",
          "new_api": null,
          "old_text": "LOG_TRACE(log, \"Merged partially aggregated blocks. {} rows, {}. in {} sec. ({} rows/sec., {}/sec.)\",\n        rows, ReadableSize(bytes),\n        elapsed_seconds, rows / elapsed_seconds,\n        ReadableSize(bytes / elapsed_seconds))",
          "new_text": null,
          "old_line_content": "    LOG_TRACE(log, \"Merged partially aggregated blocks. {} rows, {}. in {} sec. ({} rows/sec., {}/sec.)\",",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 2395,
          "old_api": "ReadableSize",
          "new_api": null,
          "old_text": "ReadableSize(bytes / elapsed_seconds)",
          "new_text": null,
          "old_line_content": "        ReadableSize(bytes / elapsed_seconds));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2397,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "    if (isCancelled())",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2415,
          "old_api": "rows",
          "new_api": null,
          "old_text": "source.rows()",
          "new_text": null,
          "old_line_content": "    size_t rows = source.rows();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2416,
          "old_api": "columns",
          "new_api": null,
          "old_text": "source.columns()",
          "new_text": null,
          "old_line_content": "    size_t columns = source.columns();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2426,
          "old_api": "isNullAt",
          "new_api": null,
          "old_text": "state.isNullAt(i)",
          "new_text": null,
          "old_line_content": "            if (state.isNullAt(i))",
          "new_line_content": "    typename Method::State state(key_columns, key_sizes, aggregation_state_cache);",
          "content_same": false
        },
        {
          "line": 2434,
          "old_api": "getHash",
          "new_api": null,
          "old_text": "state.getHash(method.data, i, *pool)",
          "new_text": null,
          "old_line_content": "        auto hash = state.getHash(method.data, i, *pool);",
          "new_line_content": "    /// For every row.",
          "content_same": false
        },
        {
          "line": 2435,
          "old_api": "getBucketFromHash",
          "new_api": null,
          "old_text": "method.data.getBucketFromHash(hash)",
          "new_text": null,
          "old_line_content": "        auto bucket = method.data.getBucketFromHash(hash);",
          "new_line_content": "    for (size_t i = 0; i < rows; ++i)",
          "content_same": false
        },
        {
          "line": 2440,
          "old_api": "size",
          "new_api": null,
          "old_text": "destinations.size()",
          "new_text": null,
          "old_line_content": "    size_t num_buckets = destinations.size();",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 2444,
          "old_api": "getByPosition",
          "new_api": null,
          "old_text": "source.getByPosition(column_idx)",
          "new_text": null,
          "old_line_content": "        const ColumnWithTypeAndName & src_col = source.getByPosition(column_idx);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": "scatter",
          "new_api": null,
          "old_text": "src_col.column->scatter(num_buckets, selector)",
          "new_text": null,
          "old_line_content": "        MutableColumns scattered_columns = src_col.column->scatter(num_buckets, selector);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2449,
          "old_api": "empty",
          "new_api": null,
          "old_text": "scattered_columns[bucket]->empty()",
          "new_text": null,
          "old_line_content": "            if (!scattered_columns[bucket]->empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2475,
          "old_api": "safeGetByPosition",
          "new_api": null,
          "old_text": "block.safeGetByPosition(i).column.get()",
          "new_text": null,
          "old_line_content": "        key_columns[i] = block.safeGetByPosition(i).column.get();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2486,
          "old_api": "APPLY_FOR_VARIANTS_CONVERTIBLE_TO_TWO_LEVEL",
          "new_api": null,
          "old_text": "APPLY_FOR_VARIANTS_CONVERTIBLE_TO_TWO_LEVEL(M)",
          "new_text": null,
          "old_line_content": "    APPLY_FOR_VARIANTS_CONVERTIBLE_TO_TWO_LEVEL(M)",
          "new_line_content": "    /// Remember the columns we will work with",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": "init",
          "new_api": null,
          "old_text": "data.init(type)",
          "new_text": null,
          "old_line_content": "    data.init(type);",
          "new_line_content": "    data.keys_size = params.keys_size;",
          "content_same": false
        },
        {
          "line": 2500,
          "old_api": "APPLY_FOR_VARIANTS_TWO_LEVEL",
          "new_api": null,
          "old_text": "APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "new_text": null,
          "old_line_content": "    APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "new_line_content": "#undef M",
          "content_same": false
        },
        {
          "line": 2525,
          "old_api": "forEachMapped",
          "new_api": null,
          "old_text": "table.forEachMapped([&](AggregateDataPtr & data)\n    {\n        /** If an exception (usually a lack of memory, the MemoryTracker throws) arose\n          *  after inserting the key into a hash table, but before creating all states of aggregate functions,\n          *  then data will be equal nullptr.\n          */\n        if (nullptr == data)\n            return;\n\n        for (size_t i = 0; i < params.aggregates_size; ++i)\n            aggregate_functions[i]->destroy(data + offsets_of_aggregate_states[i]);\n\n        data = nullptr;\n    })",
          "new_text": null,
          "old_line_content": "    table.forEachMapped([&](AggregateDataPtr & data)",
          "new_line_content": "    if (false) {} // NOLINT",
          "content_same": false
        },
        {
          "line": 2535,
          "old_api": "destroy",
          "new_api": null,
          "old_text": "aggregate_functions[i]->destroy(data + offsets_of_aggregate_states[i])",
          "new_text": null,
          "old_line_content": "            aggregate_functions[i]->destroy(data + offsets_of_aggregate_states[i]);",
          "new_line_content": "template <typename Method, typename Table>",
          "content_same": false
        },
        {
          "line": 2549,
          "old_api": "destroy",
          "new_api": null,
          "old_text": "aggregate_functions[i]->destroy(res_data + offsets_of_aggregate_states[i])",
          "new_text": null,
          "old_line_content": "            aggregate_functions[i]->destroy(res_data + offsets_of_aggregate_states[i]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2558,
          "old_api": "empty",
          "new_api": null,
          "old_text": "result.empty()",
          "new_text": null,
          "old_line_content": "    if (result.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2561,
          "old_api": "LOG_TRACE",
          "new_api": null,
          "old_text": "LOG_TRACE(log, \"Destroying aggregate states\")",
          "new_text": null,
          "old_line_content": "    LOG_TRACE(log, \"Destroying aggregate states\");",
          "new_line_content": "        for (size_t i = 0; i < params.aggregates_size; ++i)",
          "content_same": false
        },
        {
          "line": 2565,
          "old_api": "destroyWithoutKey",
          "new_api": null,
          "old_text": "destroyWithoutKey(result)",
          "new_text": null,
          "old_line_content": "        destroyWithoutKey(result);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2572,
          "old_api": "APPLY_FOR_AGGREGATED_VARIANTS",
          "new_api": null,
          "old_text": "APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "new_text": null,
          "old_line_content": "    APPLY_FOR_AGGREGATED_VARIANTS(M)",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 2575,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Unknown aggregated data variant.\", ErrorCodes::UNKNOWN_AGGREGATED_DATA_VARIANT)",
          "new_text": null,
          "old_line_content": "        throw Exception(\"Unknown aggregated data variant.\", ErrorCodes::UNKNOWN_AGGREGATED_DATA_VARIANT);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "alignedAlloc",
          "new_api": null,
          "old_text": "aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states)",
          "new_text": null,
          "old_line_content": "                    aggregate_data = aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);",
          "new_line_content": "    /// Optimization for special case when aggregating by 8bit key.",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": "createAggregateStates",
          "new_api": null,
          "old_text": "createAggregateStates(aggregate_data)",
          "new_text": null,
          "old_line_content": "                    createAggregateStates(aggregate_data);",
          "new_line_content": "    if constexpr (std::is_same_v<Method, typename decltype(AggregatedDataVariants::key8)::element_type>)",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "getKeyData",
          "new_api": null,
          "old_text": "state.getKeyData()",
          "new_text": null,
          "old_line_content": "                state.getKeyData(),",
          "new_line_content": "        for (AggregateFunctionInstruction * inst = aggregate_instructions; inst->that; ++inst)",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "emplaceKey",
          "new_api": null,
          "old_text": "state.emplaceKey(method.data, i, *aggregates_pool)",
          "new_text": null,
          "old_line_content": "        auto emplace_result = state.emplaceKey(method.data, i, *aggregates_pool);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": "isInserted",
          "new_api": null,
          "old_text": "emplace_result.isInserted()",
          "new_text": null,
          "old_line_content": "        if (emplace_result.isInserted())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": "setMapped",
          "new_api": null,
          "old_text": "emplace_result.setMapped(nullptr)",
          "new_text": null,
          "old_line_content": "            emplace_result.setMapped(nullptr);",
          "new_line_content": "    PODArray<AggregateDataPtr> places(rows);",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": "alignedAlloc",
          "new_api": null,
          "old_text": "aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states)",
          "new_text": null,
          "old_line_content": "            aggregate_data = aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);",
          "new_line_content": "    /// For all rows.",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": "createAggregateStates",
          "new_api": null,
          "old_text": "createAggregateStates(aggregate_data)",
          "new_text": null,
          "old_line_content": "            createAggregateStates(aggregate_data);",
          "new_line_content": "    for (size_t i = 0; i < rows; ++i)",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": "setMapped",
          "new_api": null,
          "old_text": "emplace_result.setMapped(aggregate_data)",
          "new_text": null,
          "old_line_content": "            emplace_result.setMapped(aggregate_data);",
          "new_line_content": "        AggregateDataPtr aggregate_data = nullptr;",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": "getMapped",
          "new_api": null,
          "old_text": "emplace_result.getMapped()",
          "new_text": null,
          "old_line_content": "            aggregate_data = emplace_result.getMapped();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(places[i] != nullptr)",
          "new_text": null,
          "old_line_content": "        assert(places[i] != nullptr);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": "data",
          "new_api": null,
          "old_text": "places.data()",
          "new_text": null,
          "old_line_content": "            inst->batch_that->addBatch(rows, places.data(), inst->state_offset, inst->batch_arguments, aggregates_pool);",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": "addBatchSinglePlace",
          "new_api": null,
          "old_text": "inst->batch_that->addBatchSinglePlace(\n                inst->offsets[static_cast<ssize_t>(rows - 1)], res + inst->state_offset, inst->batch_arguments, arena)",
          "new_text": null,
          "old_line_content": "            inst->batch_that->addBatchSinglePlace(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": "static_cast<ssize_t>(rows - 1)",
          "new_api": null,
          "old_text": "static_cast<ssize_t>(rows - 1)",
          "new_text": null,
          "old_line_content": "                inst->offsets[static_cast<ssize_t>(rows - 1)], res + inst->state_offset, inst->batch_arguments, arena);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "addBatchSinglePlace",
          "new_api": null,
          "old_text": "inst->batch_that->addBatchSinglePlace(rows, res + inst->state_offset, inst->batch_arguments, arena)",
          "new_text": null,
          "old_line_content": "            inst->batch_that->addBatchSinglePlace(rows, res + inst->state_offset, inst->batch_arguments, arena);",
          "new_line_content": "void NO_INLINE Aggregator::executeWithoutKeyImpl(",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "addBatchSinglePlaceFromInterval",
          "new_api": null,
          "old_text": "inst->batch_that->addBatchSinglePlaceFromInterval(inst->offsets[row_begin], inst->offsets[row_end - 1], res + inst->state_offset, inst->batch_arguments, arena)",
          "new_text": null,
          "old_line_content": "            inst->batch_that->addBatchSinglePlaceFromInterval(inst->offsets[row_begin], inst->offsets[row_end - 1], res + inst->state_offset, inst->batch_arguments, arena);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": "addBatchSinglePlaceFromInterval",
          "new_api": null,
          "old_text": "inst->batch_that->addBatchSinglePlaceFromInterval(row_begin, row_end, res + inst->state_offset, inst->batch_arguments, arena)",
          "new_text": null,
          "old_line_content": "            inst->batch_that->addBatchSinglePlaceFromInterval(row_begin, row_end, res + inst->state_offset, inst->batch_arguments, arena);",
          "new_line_content": "void NO_INLINE Aggregator::executeOnIntervalWithoutKeyImpl(",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "size",
          "new_api": null,
          "old_text": "params.aggregates[i].arguments.size()",
          "new_text": null,
          "old_line_content": "        aggregate_columns[i].resize(params.aggregates[i].arguments.size());",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "size",
          "new_api": null,
          "old_text": "aggregate_columns[i].size()",
          "new_text": null,
          "old_line_content": "        for (size_t j = 0; j < aggregate_columns[i].size(); ++j)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": "at",
          "new_api": null,
          "old_text": "columns.at(params.aggregates[i].arguments[j])->convertToFullColumnIfConst()",
          "new_text": null,
          "old_line_content": "            materialized_columns.push_back(columns.at(params.aggregates[i].arguments[j])->convertToFullColumnIfConst());",
          "new_line_content": "void Aggregator::prepareAggregateInstructions(Columns columns, AggregateColumns & aggregate_columns, Columns & materialized_columns,",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": "back",
          "new_api": null,
          "old_text": "materialized_columns.back().get()",
          "new_text": null,
          "old_line_content": "            aggregate_columns[i][j] = materialized_columns.back().get();",
          "new_line_content": "                                              AggregateFunctionInstructions & aggregate_functions_instructions, NestedColumnsHolder & nested_columns_holder)",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": "getPtr",
          "new_api": null,
          "old_text": "aggregate_columns[i][j]->getPtr()",
          "new_text": null,
          "old_line_content": "            auto column_no_lc = recursiveRemoveLowCardinality(aggregate_columns[i][j]->getPtr());",
          "new_line_content": "    for (size_t i = 0; i < params.aggregates_size; ++i)",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": "back",
          "new_api": null,
          "old_text": "materialized_columns.back().get()",
          "new_text": null,
          "old_line_content": "                aggregate_columns[i][j] = materialized_columns.back().get();",
          "new_line_content": "    aggregate_functions_instructions[params.aggregates_size].that = nullptr;",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": "typeid_cast<const AggregateFunctionState *>(that)",
          "new_api": null,
          "old_text": "typeid_cast<const AggregateFunctionState *>(that)",
          "new_text": null,
          "old_line_content": "        while (const auto * func = typeid_cast<const AggregateFunctionState *>(that))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": "getAddressOfAddFunction",
          "new_api": null,
          "old_text": "that->getAddressOfAddFunction()",
          "new_text": null,
          "old_line_content": "        aggregate_functions_instructions[i].func = that->getAddressOfAddFunction();",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": "get",
          "new_api": null,
          "old_text": "func->getNestedFunction().get()",
          "new_text": null,
          "old_line_content": "            that = func->getNestedFunction().get();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": "get",
          "new_api": null,
          "old_text": "nested_func->getNestedFunction().get()",
          "new_text": null,
          "old_line_content": "                that = nested_func->getNestedFunction().get();",
          "new_line_content": "        aggregate_functions_instructions[i].state_offset = offsets_of_aggregate_states[i];",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": "size",
          "new_api": null,
          "old_text": "that->getArgumentTypes().size()",
          "new_text": null,
          "old_line_content": "            auto [nested_columns, offsets] = checkAndGetNestedArrayOffset(aggregate_columns[i].data(), that->getArgumentTypes().size());",
          "new_line_content": "        auto * that = aggregate_functions[i];",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "std::move(nested_columns)",
          "new_api": null,
          "old_text": "std::move(nested_columns)",
          "new_text": null,
          "old_line_content": "            nested_columns_holder.push_back(std::move(nested_columns));",
          "new_line_content": "        /// Unnest consecutive trailing -State combinators",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": "data",
          "new_api": null,
          "old_text": "aggregate_columns[i].data()",
          "new_text": null,
          "old_line_content": "            aggregate_functions_instructions[i].batch_arguments = aggregate_columns[i].data();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": "rows",
          "new_api": null,
          "old_text": "block.rows()",
          "new_text": null,
          "old_line_content": "    UInt64 num_rows = block.rows();",
          "new_line_content": "            aggregate_functions_instructions[i].offsets = offsets;",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": "getColumns",
          "new_api": null,
          "old_text": "block.getColumns()",
          "new_text": null,
          "old_line_content": "    return executeOnBlock(block.getColumns(), num_rows, result, key_columns, aggregate_columns, no_more_keys);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "    if (isCancelled())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": "empty",
          "new_api": null,
          "old_text": "result.empty()",
          "new_text": null,
          "old_line_content": "    if (result.empty())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": "init",
          "new_api": null,
          "old_text": "result.init(method_chosen)",
          "new_text": null,
          "old_line_content": "        result.init(method_chosen);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": "getMethodName",
          "new_api": null,
          "old_text": "result.getMethodName()",
          "new_text": null,
          "old_line_content": "        LOG_TRACE(log, \"Aggregation method: {}\", result.getMethodName());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "    if (isCancelled())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 707,
          "old_api": "at",
          "new_api": null,
          "old_text": "columns.at(params.keys[i])->convertToFullColumnIfConst()",
          "new_text": null,
          "old_line_content": "        materialized_columns.push_back(columns.at(params.keys[i])->convertToFullColumnIfConst());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": "back",
          "new_api": null,
          "old_text": "materialized_columns.back().get()",
          "new_text": null,
          "old_line_content": "        key_columns[i] = materialized_columns.back().get();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": "isLowCardinality",
          "new_api": null,
          "old_text": "result.isLowCardinality()",
          "new_text": null,
          "old_line_content": "        if (!result.isLowCardinality())",
          "new_line_content": "        return true;",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": "getPtr",
          "new_api": null,
          "old_text": "key_columns[i]->getPtr()",
          "new_text": null,
          "old_line_content": "            auto column_no_lc = recursiveRemoveLowCardinality(key_columns[i]->getPtr());",
          "new_line_content": "    /** Constant columns are not supported directly during aggregation.",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": "get",
          "new_api": null,
          "old_text": "column_no_lc.get()",
          "new_text": null,
          "old_line_content": "            if (column_no_lc.get() != key_columns[i])",
          "new_line_content": "      * To make them work anyway, we materialize them.",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": "std::move(column_no_lc)",
          "new_api": null,
          "old_text": "std::move(column_no_lc)",
          "new_text": null,
          "old_line_content": "                materialized_columns.emplace_back(std::move(column_no_lc));",
          "new_line_content": "    Columns materialized_columns;",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": "back",
          "new_api": null,
          "old_text": "materialized_columns.back().get()",
          "new_text": null,
          "old_line_content": "                key_columns[i] = materialized_columns.back().get();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": "prepareAggregateInstructions",
          "new_api": null,
          "old_text": "prepareAggregateInstructions(columns, aggregate_columns, materialized_columns, aggregate_functions_instructions, nested_columns_holder)",
          "new_text": null,
          "old_line_content": "    prepareAggregateInstructions(columns, aggregate_columns, materialized_columns, aggregate_functions_instructions, nested_columns_holder);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "    if (isCancelled())",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": "createAggregateStates",
          "new_api": null,
          "old_text": "createAggregateStates(place)",
          "new_text": null,
          "old_line_content": "        createAggregateStates(place);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "data",
          "new_api": null,
          "old_text": "aggregate_functions_instructions.data()",
          "new_text": null,
          "old_line_content": "        executeWithoutKeyImpl(result.without_key, num_rows, aggregate_functions_instructions.data(), result.aggregates_pool);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": "sizeWithoutOverflowRow",
          "new_api": null,
          "old_text": "result.sizeWithoutOverflowRow()",
          "new_text": null,
          "old_line_content": "    size_t result_size = result.sizeWithoutOverflowRow();",
          "new_line_content": "        /// This is where data is written that does not fit in `max_rows_to_group_by` with `group_by_overflow_mode = any`.",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": "CurrentThread::getMemoryTracker()",
          "new_api": null,
          "old_text": "CurrentThread::getMemoryTracker()",
          "new_text": null,
          "old_line_content": "    if (auto * memory_tracker_child = CurrentThread::getMemoryTracker())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": "getParent",
          "new_api": null,
          "old_text": "memory_tracker_child->getParent()",
          "new_text": null,
          "old_line_content": "        if (auto * memory_tracker = memory_tracker_child->getParent())",
          "new_line_content": "        #define M(NAME, IS_TWO_LEVEL) \\",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": "get",
          "new_api": null,
          "old_text": "memory_tracker->get()",
          "new_text": null,
          "old_line_content": "            current_memory_usage = memory_tracker->get();",
          "new_line_content": "            else if (result.type == AggregatedDataVariants::Type::NAME) \\",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": "static_cast<Int64>(params.group_by_two_level_threshold_bytes)",
          "new_api": null,
          "old_text": "static_cast<Int64>(params.group_by_two_level_threshold_bytes)",
          "new_text": null,
          "old_line_content": "        || (params.group_by_two_level_threshold_bytes && result_size_bytes >= static_cast<Int64>(params.group_by_two_level_threshold_bytes));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "checkLimits",
          "new_api": null,
          "old_text": "checkLimits(result_size, no_more_keys)",
          "new_text": null,
          "old_line_content": "    if (!checkLimits(result_size, no_more_keys))",
          "new_line_content": "    auto result_size_bytes = current_memory_usage - memory_usage_before_aggregation;",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": "isTwoLevel",
          "new_api": null,
          "old_text": "result.isTwoLevel()",
          "new_text": null,
          "old_line_content": "        && result.isTwoLevel()",
          "new_line_content": "      * It allows you to make, in the subsequent, an effective merge - either economical from memory or parallel.",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "static_cast<Int64>(params.max_bytes_before_external_group_by)",
          "new_api": null,
          "old_text": "static_cast<Int64>(params.max_bytes_before_external_group_by)",
          "new_text": null,
          "old_line_content": "        && current_memory_usage > static_cast<Int64>(params.max_bytes_before_external_group_by)",
          "new_line_content": "      */",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": "enoughSpaceInDirectory",
          "new_api": null,
          "old_text": "enoughSpaceInDirectory(tmp_path, size)",
          "new_text": null,
          "old_line_content": "        if (!enoughSpaceInDirectory(tmp_path, size))",
          "new_line_content": "        size_t size = current_memory_usage + params.min_free_disk_space;",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Not enough space for external aggregation in \" + tmp_path, ErrorCodes::NOT_ENOUGH_SPACE)",
          "new_text": null,
          "old_line_content": "            throw Exception(\"Not enough space for external aggregation in \" + tmp_path, ErrorCodes::NOT_ENOUGH_SPACE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": "writeToTemporaryFile",
          "new_api": null,
          "old_text": "writeToTemporaryFile(result, tmp_path)",
          "new_text": null,
          "old_line_content": "        writeToTemporaryFile(result, tmp_path);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "createTemporaryFile",
          "new_api": null,
          "old_text": "createTemporaryFile(tmp_path)",
          "new_text": null,
          "old_line_content": "    auto file = createTemporaryFile(tmp_path);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": "LOG_DEBUG",
          "new_api": null,
          "old_text": "LOG_DEBUG(log, \"Writing part of aggregation data into temporary file {}.\", path)",
          "new_text": null,
          "old_line_content": "    LOG_DEBUG(log, \"Writing part of aggregation data into temporary file {}.\", path);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": "ProfileEvents::increment(ProfileEvents::ExternalAggregationWritePart)",
          "new_api": null,
          "old_text": "ProfileEvents::increment(ProfileEvents::ExternalAggregationWritePart)",
          "new_text": null,
          "old_line_content": "    ProfileEvents::increment(ProfileEvents::ExternalAggregationWritePart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": "APPLY_FOR_VARIANTS_TWO_LEVEL",
          "new_api": null,
          "old_text": "APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "new_text": null,
          "old_line_content": "    APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "new_line_content": "    CompressedWriteBuffer compressed_buf(file_buf);",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": "init",
          "new_api": null,
          "old_text": "data_variants.init(data_variants.type)",
          "new_text": null,
          "old_line_content": "    data_variants.init(data_variants.type);",
          "new_line_content": "    /// Flush only two-level data and possibly overflow data.",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": "std::make_shared<Arena>()",
          "new_api": null,
          "old_text": "std::make_shared<Arena>()",
          "new_text": null,
          "old_line_content": "    data_variants.aggregates_pools = Arenas(1, std::make_shared<Arena>());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": "back",
          "new_api": null,
          "old_text": "data_variants.aggregates_pools.back().get()",
          "new_text": null,
          "old_line_content": "    data_variants.aggregates_pool = data_variants.aggregates_pools.back().get();",
          "new_line_content": "#define M(NAME) \\",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "flush",
          "new_api": null,
          "old_text": "block_out.flush()",
          "new_text": null,
          "old_line_content": "    block_out.flush();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": "next",
          "new_api": null,
          "old_text": "compressed_buf.next()",
          "new_text": null,
          "old_line_content": "    compressed_buf.next();",
          "new_line_content": "    if (false) {} // NOLINT",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": "elapsedSeconds",
          "new_api": null,
          "old_text": "watch.elapsedSeconds()",
          "new_text": null,
          "old_line_content": "    double elapsed_seconds = watch.elapsedSeconds();",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "count",
          "new_api": null,
          "old_text": "file_buf.count()",
          "new_text": null,
          "old_line_content": "    double compressed_bytes = file_buf.count();",
          "new_line_content": "        throw Exception(\"Unknown aggregated data variant.\", ErrorCodes::UNKNOWN_AGGREGATED_DATA_VARIANT);",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": "count",
          "new_api": null,
          "old_text": "compressed_buf.count()",
          "new_text": null,
          "old_line_content": "    double uncompressed_bytes = compressed_buf.count();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "ProfileEvents::increment(ProfileEvents::ExternalAggregationUncompressedBytes, uncompressed_bytes)",
          "new_api": null,
          "old_text": "ProfileEvents::increment(ProfileEvents::ExternalAggregationUncompressedBytes, uncompressed_bytes)",
          "new_text": null,
          "old_line_content": "    ProfileEvents::increment(ProfileEvents::ExternalAggregationUncompressedBytes, uncompressed_bytes);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": "ReadableSize",
          "new_api": null,
          "old_text": "ReadableSize(uncompressed_bytes)",
          "new_text": null,
          "old_line_content": "        ReadableSize(uncompressed_bytes),",
          "new_line_content": "        temporary_files.sum_size_uncompressed += uncompressed_bytes;",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "ReadableSize",
          "new_api": null,
          "old_text": "ReadableSize(compressed_bytes)",
          "new_text": null,
          "old_line_content": "        ReadableSize(compressed_bytes),",
          "new_line_content": "        temporary_files.sum_size_compressed += compressed_bytes;",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "ReadableSize",
          "new_api": null,
          "old_text": "ReadableSize(uncompressed_bytes / elapsed_seconds)",
          "new_text": null,
          "old_line_content": "        ReadableSize(uncompressed_bytes / elapsed_seconds),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "size",
          "new_api": null,
          "old_text": "method.data.impls[bucket].size()",
          "new_text": null,
          "old_line_content": "    Block block = prepareBlockAndFill(data_variants, final, method.data.impls[bucket].size(),",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": "convertToBlockImpl",
          "new_api": null,
          "old_text": "convertToBlockImpl(method, method.data.impls[bucket],\n                key_columns, aggregate_columns, final_aggregate_columns, arena, final_)",
          "new_text": null,
          "old_line_content": "            convertToBlockImpl(method, method.data.impls[bucket],",
          "new_line_content": "    AggregatedDataVariants & data_variants,",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": "APPLY_FOR_VARIANTS_TWO_LEVEL",
          "new_api": null,
          "old_text": "APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "new_text": null,
          "old_line_content": "    APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "new_line_content": "    auto method = merged_data.type;",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": "rows",
          "new_api": null,
          "old_text": "block.rows()",
          "new_text": null,
          "old_line_content": "        size_t block_size_rows = block.rows();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": "bytes",
          "new_api": null,
          "old_text": "block.bytes()",
          "new_text": null,
          "old_line_content": "        size_t block_size_bytes = block.bytes();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": "convertOneBucketToBlock",
          "new_api": null,
          "old_text": "convertOneBucketToBlock(data_variants, method, false, bucket)",
          "new_text": null,
          "old_line_content": "        Block block = convertOneBucketToBlock(data_variants, method, false, bucket);",
          "new_line_content": "    auto update_max_sizes = [&](const Block & block)",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": "write",
          "new_api": null,
          "old_text": "out.write(block)",
          "new_text": null,
          "old_line_content": "        out.write(block);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": "prepareBlockAndFillWithoutKey",
          "new_api": null,
          "old_text": "prepareBlockAndFillWithoutKey(data_variants, false, true)",
          "new_text": null,
          "old_line_content": "        Block block = prepareBlockAndFillWithoutKey(data_variants, false, true);",
          "new_line_content": "        if (block_size_bytes > max_temporary_block_size_bytes)",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": "write",
          "new_api": null,
          "old_text": "out.write(block)",
          "new_text": null,
          "old_line_content": "        out.write(block);",
          "new_line_content": "            max_temporary_block_size_bytes = block_size_bytes;",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": "update_max_sizes",
          "new_api": null,
          "old_text": "update_max_sizes(block)",
          "new_text": null,
          "old_line_content": "        update_max_sizes(block);",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 973,
          "old_api": "ReadableSize",
          "new_api": null,
          "old_text": "ReadableSize(max_temporary_block_size_bytes)",
          "new_text": null,
          "old_line_content": "    LOG_TRACE(log, \"Max size of temporary block: {} rows, {}.\", max_temporary_block_size_rows, ReadableSize(max_temporary_block_size_bytes));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": "toString",
          "new_api": null,
          "old_text": "toString(result_size)",
          "new_text": null,
          "old_line_content": "                throw Exception(\"Limit for rows to GROUP BY exceeded: has \" + toString(result_size)",
          "new_line_content": "    data_variants.aggregator = nullptr;",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": "toString",
          "new_api": null,
          "old_text": "toString(params.max_rows_to_group_by)",
          "new_text": null,
          "old_line_content": "                    + \" rows, maximum: \" + toString(params.max_rows_to_group_by),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "    if (isCancelled())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": "read",
          "new_api": null,
          "old_text": "stream->read()",
          "new_text": null,
          "old_line_content": "    while (Block block = stream->read())",
          "new_line_content": "      * In this case, new keys are not added to the set, but aggregation is performed only by",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "        if (isCancelled())",
          "new_line_content": "      */",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": "bytes",
          "new_api": null,
          "old_text": "block.bytes()",
          "new_text": null,
          "old_line_content": "        src_bytes += block.bytes();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": "executeOnBlock",
          "new_api": null,
          "old_text": "executeOnBlock(block, result, key_columns, aggregate_columns, no_more_keys)",
          "new_text": null,
          "old_line_content": "        if (!executeOnBlock(block, result, key_columns, aggregate_columns, no_more_keys))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "empty",
          "new_api": null,
          "old_text": "result.empty()",
          "new_text": null,
          "old_line_content": "    if (result.empty() && params.keys_size == 0 && !params.empty_result_for_aggregation_by_empty_set)",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "elapsedSeconds",
          "new_api": null,
          "old_text": "watch.elapsedSeconds()",
          "new_text": null,
          "old_line_content": "    double elapsed_seconds = watch.elapsedSeconds();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": "LOG_TRACE",
          "new_api": null,
          "old_text": "LOG_TRACE(log, \"Aggregated. {} to {} rows (from {}) in {} sec. ({} rows/sec., {}/sec.)\",\n        src_rows, rows, ReadableSize(src_bytes),\n        elapsed_seconds, src_rows / elapsed_seconds,\n        ReadableSize(src_bytes / elapsed_seconds))",
          "new_text": null,
          "old_line_content": "    LOG_TRACE(log, \"Aggregated. {} to {} rows (from {}) in {} sec. ({} rows/sec., {}/sec.)\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": "ReadableSize",
          "new_api": null,
          "old_text": "ReadableSize(src_bytes / elapsed_seconds)",
          "new_text": null,
          "old_line_content": "        ReadableSize(src_bytes / elapsed_seconds));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1061,
          "old_api": "empty",
          "new_api": null,
          "old_text": "data.empty()",
          "new_text": null,
          "old_line_content": "    if (data.empty())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": "size",
          "new_api": null,
          "old_text": "key_columns.size()",
          "new_text": null,
          "old_line_content": "    if (key_columns.size() != params.keys_size)",
          "new_line_content": "template <typename Method, typename Table>",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": "convertToBlockImplFinal",
          "new_api": null,
          "old_text": "convertToBlockImplFinal(method, data, key_columns, final_aggregate_columns, arena)",
          "new_text": null,
          "old_line_content": "        convertToBlockImplFinal(method, data, key_columns, final_aggregate_columns, arena);",
          "new_line_content": "    MutableColumns & key_columns,",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": "convertToBlockImplNotFinal",
          "new_api": null,
          "old_text": "convertToBlockImplNotFinal(method, data, key_columns, aggregate_columns)",
          "new_text": null,
          "old_line_content": "        convertToBlockImplNotFinal(method, data, key_columns, aggregate_columns);",
          "new_line_content": "    MutableColumns & final_aggregate_columns,",
          "content_same": false
        },
        {
          "line": 1072,
          "old_api": "clearAndShrink",
          "new_api": null,
          "old_text": "data.clearAndShrink()",
          "new_text": null,
          "old_line_content": "    data.clearAndShrink();",
          "new_line_content": "    bool final) const",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": "insertResultInto",
          "new_api": null,
          "old_text": "aggregate_functions[insert_i]->insertResultInto(\n                mapped + offsets_of_aggregate_states[insert_i],\n                *final_aggregate_columns[insert_i],\n                arena)",
          "new_text": null,
          "old_line_content": "            aggregate_functions[insert_i]->insertResultInto(",
          "new_line_content": "      *  and ColumnAggregateFunction will take ownership of this state.",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": "std::current_exception()",
          "new_api": null,
          "old_text": "std::current_exception()",
          "new_text": null,
          "old_line_content": "        exception = std::current_exception();",
          "new_line_content": "    std::exception_ptr exception;",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": "isState",
          "new_api": null,
          "old_text": "aggregate_functions[destroy_i]->isState()",
          "new_text": null,
          "old_line_content": "        if (!(destroy_i < insert_i && aggregate_functions[destroy_i]->isState()))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": "destroy",
          "new_api": null,
          "old_text": "aggregate_functions[destroy_i]->destroy(\n                mapped + offsets_of_aggregate_states[destroy_i])",
          "new_text": null,
          "old_line_content": "            aggregate_functions[destroy_i]->destroy(",
          "new_line_content": "    /** Destroy states that are no longer needed. This loop does not throw.",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": "std::rethrow_exception(exception)",
          "new_api": null,
          "old_text": "std::rethrow_exception(exception)",
          "new_text": null,
          "old_line_content": "        std::rethrow_exception(exception);",
          "new_line_content": "        */",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": "hasNullKeyData",
          "new_api": null,
          "old_text": "data.hasNullKeyData()",
          "new_text": null,
          "old_line_content": "        if (data.hasNullKeyData())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": "insertDefault",
          "new_api": null,
          "old_text": "key_columns[0]->insertDefault()",
          "new_text": null,
          "old_line_content": "            key_columns[0]->insertDefault();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": "getNullKeyData",
          "new_api": null,
          "old_text": "data.getNullKeyData()",
          "new_text": null,
          "old_line_content": "            insertAggregatesIntoColumns(data.getNullKeyData(), final_aggregate_columns, arena);",
          "new_line_content": "template <typename Method, typename Table>",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": "forEachValue",
          "new_api": null,
          "old_text": "data.forEachValue([&](const auto & key, auto & mapped)\n    {\n        method.insertKeyIntoColumns(key, key_columns, key_sizes);\n        insertAggregatesIntoColumns(mapped, final_aggregate_columns, arena);\n    })",
          "new_text": null,
          "old_line_content": "    data.forEachValue([&](const auto & key, auto & mapped)",
          "new_line_content": "    MutableColumns & key_columns,",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": "insertKeyIntoColumns",
          "new_api": null,
          "old_text": "method.insertKeyIntoColumns(key, key_columns, key_sizes)",
          "new_text": null,
          "old_line_content": "        method.insertKeyIntoColumns(key, key_columns, key_sizes);",
          "new_line_content": "    Arena * arena) const",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "insertAggregatesIntoColumns",
          "new_api": null,
          "old_text": "insertAggregatesIntoColumns(mapped, final_aggregate_columns, arena)",
          "new_text": null,
          "old_line_content": "        insertAggregatesIntoColumns(mapped, final_aggregate_columns, arena);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1179,
          "old_api": "insertDefault",
          "new_api": null,
          "old_text": "key_columns[0]->insertDefault()",
          "new_text": null,
          "old_line_content": "            key_columns[0]->insertDefault();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": "getNullKeyData",
          "new_api": null,
          "old_text": "data.getNullKeyData()",
          "new_text": null,
          "old_line_content": "                aggregate_columns[i]->push_back(data.getNullKeyData() + offsets_of_aggregate_states[i]);",
          "new_line_content": "void NO_INLINE Aggregator::convertToBlockImplNotFinal(",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": "getNullKeyData",
          "new_api": null,
          "old_text": "data.getNullKeyData()",
          "new_text": null,
          "old_line_content": "            data.getNullKeyData() = nullptr;",
          "new_line_content": "    Table & data,",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": "forEachValue",
          "new_api": null,
          "old_text": "data.forEachValue([&](const auto & key, auto & mapped)\n    {\n        method.insertKeyIntoColumns(key, key_columns, key_sizes);\n\n        /// reserved, so push_back does not throw exceptions\n        for (size_t i = 0; i < params.aggregates_size; ++i)\n            aggregate_columns[i]->push_back(mapped + offsets_of_aggregate_states[i]);\n\n        mapped = nullptr;\n    })",
          "new_text": null,
          "old_line_content": "    data.forEachValue([&](const auto & key, auto & mapped)",
          "new_line_content": "    if constexpr (Method::low_cardinality_optimization)",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "aggregate_columns[i]->push_back(mapped + offsets_of_aggregate_states[i])",
          "new_text": null,
          "old_line_content": "            aggregate_columns[i]->push_back(mapped + offsets_of_aggregate_states[i]);",
          "new_line_content": "            for (size_t i = 0; i < params.aggregates_size; ++i)",
          "content_same": false
        },
        {
          "line": 1213,
          "old_api": "getHeader",
          "new_api": null,
          "old_text": "getHeader(final)",
          "new_text": null,
          "old_line_content": "    Block header = getHeader(final);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": "safeGetByPosition",
          "new_api": null,
          "old_text": "header.safeGetByPosition(i).type->createColumn()",
          "new_text": null,
          "old_line_content": "        key_columns[i] = header.safeGetByPosition(i).type->createColumn();",
          "new_line_content": "    bool final,",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "key_columns[i]->reserve(rows)",
          "new_text": null,
          "old_line_content": "        key_columns[i]->reserve(rows);",
          "new_line_content": "    size_t rows,",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": "assert_cast<ColumnAggregateFunction &>(*aggregate_columns[i])",
          "new_api": null,
          "old_text": "assert_cast<ColumnAggregateFunction &>(*aggregate_columns[i])",
          "new_text": null,
          "old_line_content": "            ColumnAggregateFunction & column_aggregate_func = assert_cast<ColumnAggregateFunction &>(*aggregate_columns[i]);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": "addArena",
          "new_api": null,
          "old_text": "column_aggregate_func.addArena(pool)",
          "new_text": null,
          "old_line_content": "                column_aggregate_func.addArena(pool);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": "getData",
          "new_api": null,
          "old_text": "column_aggregate_func.getData()",
          "new_text": null,
          "old_line_content": "            aggregate_columns_data[i] = &column_aggregate_func.getData();",
          "new_line_content": "    for (size_t i = 0; i < params.aggregates_size; ++i)",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "aggregate_columns_data[i]->reserve(rows)",
          "new_text": null,
          "old_line_content": "            aggregate_columns_data[i]->reserve(rows);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "final_aggregate_columns[i]->reserve(rows)",
          "new_text": null,
          "old_line_content": "            final_aggregate_columns[i]->reserve(rows);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": "get",
          "new_api": null,
          "old_text": "final_aggregate_columns[i]->forEachSubcolumn([&data_variants](auto & subcolumn)\n                {\n                    if (auto * column_aggregate_func = typeid_cast<ColumnAggregateFunction *>(subcolumn.get()))\n                        for (auto & pool : data_variants.aggregates_pools)\n                            column_aggregate_func->addArena(pool);\n                })",
          "new_text": null,
          "old_line_content": "                final_aggregate_columns[i]->forEachSubcolumn([&data_variants](auto & subcolumn)",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": "addArena",
          "new_api": null,
          "old_text": "column_aggregate_func->addArena(pool)",
          "new_text": null,
          "old_line_content": "                            column_aggregate_func->addArena(pool);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1262,
          "old_api": "cloneEmpty",
          "new_api": null,
          "old_text": "header.cloneEmpty()",
          "new_text": null,
          "old_line_content": "    Block res = header.cloneEmpty();",
          "new_line_content": "                /// Aggregate state can be wrapped into array if aggregate function ends with -Resample combinator.",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": "std::move(final_aggregate_columns[i])",
          "new_api": null,
          "old_text": "std::move(final_aggregate_columns[i])",
          "new_text": null,
          "old_line_content": "            res.getByName(aggregate_column_name).column = std::move(final_aggregate_columns[i]);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": "columns",
          "new_api": null,
          "old_text": "header.columns()",
          "new_text": null,
          "old_line_content": "    size_t columns = header.columns();",
          "new_line_content": "    for (size_t i = 0; i < params.keys_size; ++i)",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": "getByPosition",
          "new_api": null,
          "old_text": "res.getByPosition(i)",
          "new_text": null,
          "old_line_content": "        if (isColumnConst(*res.getByPosition(i).column))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1280,
          "old_api": "getByPosition",
          "new_api": null,
          "old_text": "res.getByPosition(i).column->cut(0, rows)",
          "new_text": null,
          "old_line_content": "            res.getByPosition(i).column = res.getByPosition(i).column->cut(0, rows);",
          "new_line_content": "    for (size_t i = 0; i < params.aggregates_size; ++i)",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": "addArena",
          "new_api": null,
          "old_text": "column_aggregate_func.addArena(pool)",
          "new_text": null,
          "old_line_content": "            column_aggregate_func.addArena(pool);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": "getData",
          "new_api": null,
          "old_text": "column_aggregate_func.getData().push_back(data + offsets_of_aggregate_states[i])",
          "new_text": null,
          "old_line_content": "        column_aggregate_func.getData().push_back(data + offsets_of_aggregate_states[i]);",
          "new_line_content": "void Aggregator::fillAggregateColumnsWithSingleKey(",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": "createAggregateStates",
          "new_api": null,
          "old_text": "createAggregateStates(place)",
          "new_text": null,
          "old_line_content": "    createAggregateStates(place);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": "get",
          "new_api": null,
          "old_text": "key_columns[i].get()",
          "new_text": null,
          "old_line_content": "        final_key_columns[i]->insertFrom(*key_columns[i].get(), key_row);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1337,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "aggregate_columns[i]->push_back(data + offsets_of_aggregate_states[i])",
          "new_text": null,
          "old_line_content": "                    aggregate_columns[i]->push_back(data + offsets_of_aggregate_states[i]);",
          "new_line_content": "        MutableColumns & key_columns,",
          "content_same": false
        },
        {
          "line": 1342,
          "old_api": "insertAggregatesIntoColumns",
          "new_api": null,
          "old_text": "insertAggregatesIntoColumns(data, final_aggregate_columns, arena)",
          "new_text": null,
          "old_line_content": "                insertAggregatesIntoColumns(data, final_aggregate_columns, arena);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1347,
          "old_api": "insertDefault",
          "new_api": null,
          "old_text": "key_columns[i]->insertDefault()",
          "new_text": null,
          "old_line_content": "                    key_columns[i]->insertDefault();",
          "new_line_content": "            if (!final_)",
          "content_same": false
        },
        {
          "line": 1351,
          "old_api": "prepareBlockAndFill",
          "new_api": null,
          "old_text": "prepareBlockAndFill(data_variants, final, rows, filler)",
          "new_text": null,
          "old_line_content": "    Block block = prepareBlockAndFill(data_variants, final, rows, filler);",
          "new_line_content": "                data = nullptr;",
          "content_same": false
        },
        {
          "line": 1357,
          "old_api": "destroyWithoutKey",
          "new_api": null,
          "old_text": "destroyWithoutKey(data_variants)",
          "new_text": null,
          "old_line_content": "        destroyWithoutKey(data_variants);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": "APPLY_FOR_VARIANTS_SINGLE_LEVEL",
          "new_api": null,
          "old_text": "APPLY_FOR_VARIANTS_SINGLE_LEVEL(M)",
          "new_text": null,
          "old_line_content": "        APPLY_FOR_VARIANTS_SINGLE_LEVEL(M)",
          "new_line_content": "    auto filler = [&data_variants, this](",
          "content_same": false
        },
        {
          "line": 1385,
          "old_api": "prepareBlockAndFill",
          "new_api": null,
          "old_text": "prepareBlockAndFill(data_variants, final, rows, filler)",
          "new_text": null,
          "old_line_content": "    return prepareBlockAndFill(data_variants, final, rows, filler);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1396,
          "old_api": "APPLY_FOR_VARIANTS_TWO_LEVEL",
          "new_api": null,
          "old_text": "APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "new_text": null,
          "old_line_content": "    APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": "CurrentThread::attachToIfDetached(thread_group)",
          "new_api": null,
          "old_text": "CurrentThread::attachToIfDetached(thread_group)",
          "new_text": null,
          "old_line_content": "            CurrentThread::attachToIfDetached(thread_group);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1414,
          "old_api": "convertOneBucketToBlock",
          "new_api": null,
          "old_text": "convertOneBucketToBlock(data_variants, method, final, bucket)",
          "new_text": null,
          "old_line_content": "        return convertOneBucketToBlock(data_variants, method, final, bucket);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1425,
          "old_api": "empty",
          "new_api": null,
          "old_text": "method.data.impls[bucket].empty()",
          "new_text": null,
          "old_line_content": "            if (method.data.impls[bucket].empty())",
          "new_line_content": "        if (thread_group)",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": "converter",
          "new_api": null,
          "old_text": "converter(bucket, group)",
          "new_text": null,
          "old_line_content": "            tasks[bucket] = std::packaged_task<Block()>([group = CurrentThread::getGroup(), bucket, &converter]{ return converter(bucket, group); });",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 1431,
          "old_api": "scheduleOrThrowOnError",
          "new_api": null,
          "old_text": "thread_pool->scheduleOrThrowOnError([bucket, &tasks] { tasks[bucket](); })",
          "new_text": null,
          "old_line_content": "                thread_pool->scheduleOrThrowOnError([bucket, &tasks] { tasks[bucket](); });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1433,
          "old_api": "tasks[bucket]()",
          "new_api": null,
          "old_text": "tasks[bucket]()",
          "new_text": null,
          "old_line_content": "                tasks[bucket]();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1440,
          "old_api": "wait",
          "new_api": null,
          "old_text": "thread_pool->wait()",
          "new_text": null,
          "old_line_content": "            thread_pool->wait();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": "valid",
          "new_api": null,
          "old_text": "task.valid()",
          "new_text": null,
          "old_line_content": "        if (!task.valid())",
          "new_line_content": "        if (thread_pool)",
          "content_same": false
        },
        {
          "line": 1455,
          "old_api": "get_future",
          "new_api": null,
          "old_text": "task.get_future().get()",
          "new_text": null,
          "old_line_content": "        blocks.emplace_back(task.get_future().get());",
          "new_line_content": "        throw;",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "    if (isCancelled())",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1467,
          "old_api": "LOG_TRACE",
          "new_api": null,
          "old_text": "LOG_TRACE(log, \"Converting aggregated data to blocks\")",
          "new_text": null,
          "old_line_content": "    LOG_TRACE(log, \"Converting aggregated data to blocks\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1474,
          "old_api": "empty",
          "new_api": null,
          "old_text": "data_variants.empty()",
          "new_text": null,
          "old_line_content": "    if (data_variants.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1479,
          "old_api": "isTwoLevel",
          "new_api": null,
          "old_text": "data_variants.isTwoLevel()",
          "new_text": null,
          "old_line_content": "        && data_variants.isTwoLevel())                      /// TODO Use the shared thread pool with the `merge` function.",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "    if (isCancelled())",
          "new_line_content": "    Stopwatch watch;",
          "content_same": false
        },
        {
          "line": 1483,
          "old_api": "BlocksList",
          "new_api": null,
          "old_text": "BlocksList()",
          "new_text": null,
          "old_line_content": "        return BlocksList();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1486,
          "old_api": "prepareBlockAndFillWithoutKey",
          "new_api": null,
          "old_text": "prepareBlockAndFillWithoutKey(\n            data_variants, final, data_variants.type != AggregatedDataVariants::Type::without_key)",
          "new_text": null,
          "old_line_content": "        blocks.emplace_back(prepareBlockAndFillWithoutKey(",
          "new_line_content": "    /// In what data structure is the data aggregated?",
          "content_same": false
        },
        {
          "line": 1489,
          "old_api": "isCancelled",
          "new_api": null,
          "old_text": "isCancelled()",
          "new_text": null,
          "old_line_content": "    if (isCancelled())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1490,
          "old_api": "BlocksList",
          "new_api": null,
          "old_text": "BlocksList()",
          "new_text": null,
          "old_line_content": "        return BlocksList();",
          "new_line_content": "    std::unique_ptr<ThreadPool> thread_pool;",
          "content_same": false
        },
        {
          "line": 1494,
          "old_api": "isTwoLevel",
          "new_api": null,
          "old_text": "data_variants.isTwoLevel()",
          "new_text": null,
          "old_line_content": "        if (!data_variants.isTwoLevel())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": "get",
          "new_api": null,
          "old_text": "thread_pool.get()",
          "new_text": null,
          "old_line_content": "            blocks.splice(blocks.end(), prepareBlocksAndFillTwoLevel(data_variants, final, thread_pool.get()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": "rows",
          "new_api": null,
          "old_text": "block.rows()",
          "new_text": null,
          "old_line_content": "        rows += block.rows();",
          "new_line_content": "        /// data_variants will not destroy the states of aggregate functions in the destructor.",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": "bytes",
          "new_api": null,
          "old_text": "block.bytes()",
          "new_text": null,
          "old_line_content": "        bytes += block.bytes();",
          "new_line_content": "        /// Now ColumnAggregateFunction owns the states.",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": "elapsedSeconds",
          "new_api": null,
          "old_text": "watch.elapsedSeconds()",
          "new_text": null,
          "old_line_content": "    double elapsed_seconds = watch.elapsedSeconds();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1522,
          "old_api": "ReadableSize",
          "new_api": null,
          "old_text": "ReadableSize(bytes)",
          "new_text": null,
          "old_line_content": "        rows, ReadableSize(bytes),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1524,
          "old_api": "ReadableSize",
          "new_api": null,
          "old_text": "ReadableSize(bytes / elapsed_seconds)",
          "new_text": null,
          "old_line_content": "        ReadableSize(bytes / elapsed_seconds));",
          "new_line_content": "    size_t bytes = 0;",
          "content_same": false
        },
        {
          "line": 1538,
          "old_api": "hasNullKeyData",
          "new_api": null,
          "old_text": "table_src.hasNullKeyData()",
          "new_text": null,
          "old_line_content": "        if (table_src.hasNullKeyData())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1540,
          "old_api": "hasNullKeyData",
          "new_api": null,
          "old_text": "table_dst.hasNullKeyData()",
          "new_text": null,
          "old_line_content": "            if (!table_dst.hasNullKeyData())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1542,
          "old_api": "hasNullKeyData",
          "new_api": null,
          "old_text": "table_dst.hasNullKeyData()",
          "new_text": null,
          "old_line_content": "                table_dst.hasNullKeyData() = true;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1543,
          "old_api": "getNullKeyData",
          "new_api": null,
          "old_text": "table_src.getNullKeyData()",
          "new_text": null,
          "old_line_content": "                table_dst.getNullKeyData() = table_src.getNullKeyData();",
          "new_line_content": "template <typename Method, typename Table>",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": "getNullKeyData",
          "new_api": null,
          "old_text": "aggregate_functions[i]->merge(\n                            table_dst.getNullKeyData() + offsets_of_aggregate_states[i],\n                            table_src.getNullKeyData() + offsets_of_aggregate_states[i],\n                            arena)",
          "new_text": null,
          "old_line_content": "                    aggregate_functions[i]->merge(",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": "getNullKeyData",
          "new_api": null,
          "old_text": "table_dst.getNullKeyData()",
          "new_text": null,
          "old_line_content": "                            table_dst.getNullKeyData() + offsets_of_aggregate_states[i],",
          "new_line_content": "    if constexpr (Method::low_cardinality_optimization)",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": "getNullKeyData",
          "new_api": null,
          "old_text": "table_src.getNullKeyData()",
          "new_text": null,
          "old_line_content": "                            table_src.getNullKeyData() + offsets_of_aggregate_states[i],",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1554,
          "old_api": "getNullKeyData",
          "new_api": null,
          "old_text": "aggregate_functions[i]->destroy(\n                            table_src.getNullKeyData() + offsets_of_aggregate_states[i])",
          "new_text": null,
          "old_line_content": "                    aggregate_functions[i]->destroy(",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1558,
          "old_api": "hasNullKeyData",
          "new_api": null,
          "old_text": "table_src.hasNullKeyData()",
          "new_text": null,
          "old_line_content": "            table_src.hasNullKeyData() = false;",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": "getNullKeyData",
          "new_api": null,
          "old_text": "table_src.getNullKeyData()",
          "new_text": null,
          "old_line_content": "            table_src.getNullKeyData() = nullptr;",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": "mergeToViaEmplace",
          "new_api": null,
          "old_text": "table_src.mergeToViaEmplace(table_dst,\n        [&](AggregateDataPtr & dst, AggregateDataPtr & src, bool inserted)\n    {\n        if (!inserted)\n        {\n            for (size_t i = 0; i < params.aggregates_size; ++i)\n                aggregate_functions[i]->merge(\n                    dst + offsets_of_aggregate_states[i],\n                    src + offsets_of_aggregate_states[i],\n                    arena);\n\n            for (size_t i = 0; i < params.aggregates_size; ++i)\n                aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i]);\n        }\n        else\n        {\n            dst = src;\n        }\n\n        src = nullptr;\n    })",
          "new_text": null,
          "old_line_content": "    table_src.mergeToViaEmplace(table_dst,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": "merge",
          "new_api": null,
          "old_text": "aggregate_functions[i]->merge(\n                    dst + offsets_of_aggregate_states[i],\n                    src + offsets_of_aggregate_states[i],\n                    arena)",
          "new_text": null,
          "old_line_content": "                aggregate_functions[i]->merge(",
          "new_line_content": "    Table & table_dst,",
          "content_same": false
        },
        {
          "line": 1586,
          "old_api": "destroy",
          "new_api": null,
          "old_text": "aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i])",
          "new_text": null,
          "old_line_content": "                aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1595,
          "old_api": "clearAndShrink",
          "new_api": null,
          "old_text": "table_src.clearAndShrink()",
          "new_text": null,
          "old_line_content": "    table_src.clearAndShrink();",
          "new_line_content": "                    src + offsets_of_aggregate_states[i],",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": "mergeToViaFind",
          "new_api": null,
          "old_text": "table_src.mergeToViaFind(table_dst, [&](AggregateDataPtr dst, AggregateDataPtr & src, bool found)\n    {\n        AggregateDataPtr res_data = found ? dst : overflows;\n\n        for (size_t i = 0; i < params.aggregates_size; ++i)\n            aggregate_functions[i]->merge(\n                res_data + offsets_of_aggregate_states[i],\n                src + offsets_of_aggregate_states[i],\n                arena);\n\n        for (size_t i = 0; i < params.aggregates_size; ++i)\n            aggregate_functions[i]->destroy(src + offsets_of_aggregate_states[i]);\n\n        src = nullptr;\n    })",
          "new_text": null,
          "old_line_content": "    table_src.mergeToViaFind(table_dst, [&](AggregateDataPtr dst, AggregateDataPtr & src, bool found)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": "merge",
          "new_api": null,
          "old_text": "aggregate_functions[i]->merge(\n                res_data + offsets_of_aggregate_states[i],\n                src + offsets_of_aggregate_states[i],\n                arena)",
          "new_text": null,
          "old_line_content": "            aggregate_functions[i]->merge(",
          "new_line_content": "    AggregatedDataWithoutKey & overflows,",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": "clearAndShrink",
          "new_api": null,
          "old_text": "table_src.clearAndShrink()",
          "new_text": null,
          "old_line_content": "    table_src.clearAndShrink();",
          "new_line_content": "        AggregateDataPtr res_data = found ? dst : overflows;",
          "content_same": false
        },
        {
          "line": 1636,
          "old_api": "mergeDataNullKey<Method, Table>(table_dst, table_src, arena)",
          "new_api": null,
          "old_text": "mergeDataNullKey<Method, Table>(table_dst, table_src, arena)",
          "new_text": null,
          "old_line_content": "        mergeDataNullKey<Method, Table>(table_dst, table_src, arena);",
          "new_line_content": "        src = nullptr;",
          "content_same": false
        },
        {
          "line": 1645,
          "old_api": "merge",
          "new_api": null,
          "old_text": "aggregate_functions[i]->merge(\n                dst + offsets_of_aggregate_states[i],\n                src + offsets_of_aggregate_states[i],\n                arena)",
          "new_text": null,
          "old_line_content": "            aggregate_functions[i]->merge(",
          "new_line_content": "    Arena * arena) const",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": "clearAndShrink",
          "new_api": null,
          "old_text": "table_src.clearAndShrink()",
          "new_text": null,
          "old_line_content": "    table_src.clearAndShrink();",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": "size",
          "new_api": null,
          "old_text": "non_empty_data.size()",
          "new_text": null,
          "old_line_content": "    for (size_t result_num = 1, size = non_empty_data.size(); result_num < size; ++result_num)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": "merge",
          "new_api": null,
          "old_text": "aggregate_functions[i]->merge(res_data + offsets_of_aggregate_states[i], current_data + offsets_of_aggregate_states[i], res->aggregates_pool)",
          "new_text": null,
          "old_line_content": "            aggregate_functions[i]->merge(res_data + offsets_of_aggregate_states[i], current_data + offsets_of_aggregate_states[i], res->aggregates_pool);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": "destroy",
          "new_api": null,
          "old_text": "aggregate_functions[i]->destroy(current_data + offsets_of_aggregate_states[i])",
          "new_text": null,
          "old_line_content": "            aggregate_functions[i]->destroy(current_data + offsets_of_aggregate_states[i]);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1689,
          "old_api": "size",
          "new_api": null,
          "old_text": "non_empty_data.size()",
          "new_text": null,
          "old_line_content": "    for (size_t result_num = 1, size = non_empty_data.size(); result_num < size; ++result_num)",
          "new_line_content": "        current_data = nullptr;",
          "content_same": false
        },
        {
          "line": 1691,
          "old_api": "sizeWithoutOverflowRow",
          "new_api": null,
          "old_text": "res->sizeWithoutOverflowRow()",
          "new_text": null,
          "old_line_content": "        if (!checkLimits(res->sizeWithoutOverflowRow(), no_more_keys))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1697,
          "old_api": "mergeDataImpl<Method>(\n                getDataVariant<Method>(*res).data,\n                getDataVariant<Method>(current).data,\n                res->aggregates_pool)",
          "new_api": null,
          "old_text": "mergeDataImpl<Method>(\n                getDataVariant<Method>(*res).data,\n                getDataVariant<Method>(current).data,\n                res->aggregates_pool)",
          "new_text": null,
          "old_line_content": "            mergeDataImpl<Method>(",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": "getDataVariant<Method>(*res)",
          "new_api": null,
          "old_text": "getDataVariant<Method>(*res)",
          "new_text": null,
          "old_line_content": "                getDataVariant<Method>(*res).data,",
          "new_line_content": "    AggregatedDataVariantsPtr & res = non_empty_data[0];",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": "getDataVariant<Method>(current)",
          "new_api": null,
          "old_text": "getDataVariant<Method>(current)",
          "new_text": null,
          "old_line_content": "                getDataVariant<Method>(current).data,",
          "new_line_content": "    bool no_more_keys = false;",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": "getDataVariant<Method>(*res)",
          "new_api": null,
          "old_text": "getDataVariant<Method>(*res)",
          "new_text": null,
          "old_line_content": "                getDataVariant<Method>(*res).data,",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1705,
          "old_api": "getDataVariant<Method>(current)",
          "new_api": null,
          "old_text": "getDataVariant<Method>(current)",
          "new_text": null,
          "old_line_content": "                getDataVariant<Method>(current).data,",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": "mergeDataOnlyExistingKeysImpl<Method>(\n                getDataVariant<Method>(*res).data,\n                getDataVariant<Method>(current).data,\n                res->aggregates_pool)",
          "new_api": null,
          "old_text": "mergeDataOnlyExistingKeysImpl<Method>(\n                getDataVariant<Method>(*res).data,\n                getDataVariant<Method>(current).data,\n                res->aggregates_pool)",
          "new_text": null,
          "old_line_content": "            mergeDataOnlyExistingKeysImpl<Method>(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": "getDataVariant<Method>(*res)",
          "new_api": null,
          "old_text": "getDataVariant<Method>(*res)",
          "new_text": null,
          "old_line_content": "                getDataVariant<Method>(*res).data,",
          "new_line_content": "        if (!no_more_keys)",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": "size",
          "new_api": null,
          "old_text": "data.size()",
          "new_text": null,
          "old_line_content": "    for (size_t result_num = 1, size = data.size(); result_num < size; ++result_num)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": "load",
          "new_api": null,
          "old_text": "is_cancelled->load(std::memory_order_seq_cst)",
          "new_text": null,
          "old_line_content": "        if (is_cancelled && is_cancelled->load(std::memory_order_seq_cst))",
          "new_line_content": "    template void NO_INLINE Aggregator::mergeSingleLevelDataImpl<decltype(AggregatedDataVariants::NAME)::element_type>( \\",
          "content_same": false
        },
        {
          "line": 1737,
          "old_api": "mergeDataImpl<Method>(\n            getDataVariant<Method>(*res).data.impls[bucket],\n            getDataVariant<Method>(current).data.impls[bucket],\n            arena)",
          "new_api": null,
          "old_text": "mergeDataImpl<Method>(\n            getDataVariant<Method>(*res).data.impls[bucket],\n            getDataVariant<Method>(current).data.impls[bucket],\n            arena)",
          "new_text": null,
          "old_line_content": "        mergeDataImpl<Method>(",
          "new_line_content": "template <typename Method>",
          "content_same": false
        },
        {
          "line": 1738,
          "old_api": "getDataVariant<Method>(*res)",
          "new_api": null,
          "old_text": "getDataVariant<Method>(*res)",
          "new_text": null,
          "old_line_content": "            getDataVariant<Method>(*res).data.impls[bucket],",
          "new_line_content": "void NO_INLINE Aggregator::mergeBucketImpl(",
          "content_same": false
        },
        {
          "line": 1739,
          "old_api": "getDataVariant<Method>(current)",
          "new_api": null,
          "old_text": "getDataVariant<Method>(current)",
          "new_text": null,
          "old_line_content": "            getDataVariant<Method>(current).data.impls[bucket],",
          "new_line_content": "    ManyAggregatedDataVariants & data, Int32 bucket, Arena * arena, std::atomic<bool> * is_cancelled) const",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": "size",
          "new_api": null,
          "old_text": "data[0]->aggregates_pools.size()",
          "new_text": null,
          "old_line_content": "        if (!data.empty() && threads > data[0]->aggregates_pools.size())",
          "new_line_content": "  * (This is important for distributed processing.)",
          "content_same": false
        },
        {
          "line": 1763,
          "old_api": "size",
          "new_api": null,
          "old_text": "first_pool.size()",
          "new_text": null,
          "old_line_content": "            for (size_t j = first_pool.size(); j < threads; j++)",
          "new_line_content": "class MergingAndConvertingBlockInputStream : public IBlockInputStream",
          "content_same": false
        },
        {
          "line": 1764,
          "old_api": "std::make_shared<Arena>()",
          "new_api": null,
          "old_text": "std::make_shared<Arena>()",
          "new_text": null,
          "old_line_content": "                first_pool.emplace_back(std::make_shared<Arena>());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": "getHeader",
          "new_api": null,
          "old_text": "aggregator.getHeader(final)",
          "new_text": null,
          "old_line_content": "    Block getHeader() const override { return aggregator.getHeader(final); }",
          "new_line_content": "        : aggregator(aggregator_), data(data_), final(final_), threads(threads_)",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": "Poco::Logger::get(__PRETTY_FUNCTION__)",
          "new_api": null,
          "old_text": "Poco::Logger::get(__PRETTY_FUNCTION__)",
          "new_text": null,
          "old_line_content": "        LOG_TRACE(&Poco::Logger::get(__PRETTY_FUNCTION__), \"Waiting for threads to finish\");",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1779,
          "old_api": "wait",
          "new_api": null,
          "old_text": "parallel_merge_data->pool.wait()",
          "new_text": null,
          "old_line_content": "            parallel_merge_data->pool.wait();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1785,
          "old_api": "empty",
          "new_api": null,
          "old_text": "data.empty()",
          "new_text": null,
          "old_line_content": "        if (data.empty())",
          "new_line_content": "    ~MergingAndConvertingBlockInputStream() override",
          "content_same": false
        },
        {
          "line": 1799,
          "old_api": "mergeWithoutKeyDataImpl",
          "new_api": null,
          "old_text": "aggregator.mergeWithoutKeyDataImpl(data)",
          "new_text": null,
          "old_line_content": "                aggregator.mergeWithoutKeyDataImpl(data);",
          "new_line_content": "            return {};",
          "content_same": false
        },
        {
          "line": 1800,
          "old_api": "prepareBlockAndFillWithoutKey",
          "new_api": null,
          "old_text": "aggregator.prepareBlockAndFillWithoutKey(\n                    *first, final, first->type != AggregatedDataVariants::Type::without_key)",
          "new_text": null,
          "old_line_content": "                return aggregator.prepareBlockAndFillWithoutKey(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1805,
          "old_api": "isTwoLevel",
          "new_api": null,
          "old_text": "first->isTwoLevel()",
          "new_text": null,
          "old_line_content": "        if (!first->isTwoLevel())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1819,
          "old_api": "APPLY_FOR_VARIANTS_SINGLE_LEVEL",
          "new_api": null,
          "old_text": "APPLY_FOR_VARIANTS_SINGLE_LEVEL(M)",
          "new_text": null,
          "old_line_content": "            APPLY_FOR_VARIANTS_SINGLE_LEVEL(M)",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1824,
          "old_api": "prepareBlockAndFillSingleLevel",
          "new_api": null,
          "old_text": "aggregator.prepareBlockAndFillSingleLevel(*first, final)",
          "new_text": null,
          "old_line_content": "            return aggregator.prepareBlockAndFillSingleLevel(*first, final);",
          "new_line_content": "                return {};",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": "std::make_unique<ParallelMergeData>(threads)",
          "new_api": null,
          "old_text": "std::make_unique<ParallelMergeData>(threads)",
          "new_text": null,
          "old_line_content": "                parallel_merge_data = std::make_unique<ParallelMergeData>(threads);",
          "new_line_content": "                aggregator.mergeSingleLevelDataImpl<decltype(first->NAME)::element_type>(data);",
          "content_same": false
        },
        {
          "line": 1842,
          "old_api": "std::rethrow_exception(parallel_merge_data->exception)",
          "new_api": null,
          "old_text": "std::rethrow_exception(parallel_merge_data->exception)",
          "new_text": null,
          "old_line_content": "                    std::rethrow_exception(parallel_merge_data->exception);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1844,
          "old_api": "find",
          "new_api": null,
          "old_text": "parallel_merge_data->ready_blocks.find(current_bucket_num)",
          "new_text": null,
          "old_line_content": "                auto it = parallel_merge_data->ready_blocks.find(current_bucket_num);",
          "new_line_content": "                for (size_t i = 0; i < threads; ++i)",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": "scheduleThreadForNextBucket",
          "new_api": null,
          "old_text": "scheduleThreadForNextBucket()",
          "new_text": null,
          "old_line_content": "                    scheduleThreadForNextBucket();",
          "new_line_content": "            Block res;",
          "content_same": false
        },
        {
          "line": 1852,
          "old_api": "swap",
          "new_api": null,
          "old_text": "res.swap(it->second)",
          "new_text": null,
          "old_line_content": "                        res.swap(it->second);",
          "new_line_content": "                std::unique_lock lock(parallel_merge_data->mutex);",
          "content_same": false
        },
        {
          "line": 1859,
          "old_api": "wait",
          "new_api": null,
          "old_text": "parallel_merge_data->condvar.wait(lock)",
          "new_text": null,
          "old_line_content": "                parallel_merge_data->condvar.wait(lock);",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "    static constexpr Int32 NUM_BUCKETS = 256;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1895,
          "old_api": "scheduleOrThrowOnError",
          "new_api": null,
          "old_text": "parallel_merge_data->pool.scheduleOrThrowOnError(\n            [this, max_scheduled_bucket_num = max_scheduled_bucket_num, group = CurrentThread::getGroup()]\n            { return thread(max_scheduled_bucket_num, group); })",
          "new_text": null,
          "old_line_content": "        parallel_merge_data->pool.scheduleOrThrowOnError(",
          "new_line_content": "        ThreadPool pool;",
          "content_same": false
        },
        {
          "line": 1897,
          "old_api": "thread",
          "new_api": null,
          "old_text": "thread(max_scheduled_bucket_num, group)",
          "new_text": null,
          "old_line_content": "            { return thread(max_scheduled_bucket_num, group); });",
          "new_line_content": "        explicit ParallelMergeData(size_t threads_) : pool(threads_) {}",
          "content_same": false
        },
        {
          "line": 1904,
          "old_api": "setThreadName",
          "new_api": null,
          "old_text": "setThreadName(\"MergingAggregtd\")",
          "new_text": null,
          "old_line_content": "            setThreadName(\"MergingAggregtd\");",
          "new_line_content": "        ++max_scheduled_bucket_num;",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": "CurrentThread::attachToIfDetached(thread_group)",
          "new_api": null,
          "old_text": "CurrentThread::attachToIfDetached(thread_group)",
          "new_text": null,
          "old_line_content": "                CurrentThread::attachToIfDetached(thread_group);",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": "static_cast<size_t>(bucket_num)",
          "new_api": null,
          "old_text": "static_cast<size_t>(bucket_num)",
          "new_text": null,
          "old_line_content": "            size_t thread_number = static_cast<size_t>(bucket_num) % threads;",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1927,
          "old_api": "APPLY_FOR_VARIANTS_TWO_LEVEL",
          "new_api": null,
          "old_text": "APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "new_text": null,
          "old_line_content": "            APPLY_FOR_VARIANTS_TWO_LEVEL(M)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1931,
          "old_api": "std::move(block)",
          "new_api": null,
          "old_text": "std::move(block)",
          "new_text": null,
          "old_line_content": "            parallel_merge_data->ready_blocks[bucket_num] = std::move(block);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1937,
          "old_api": "std::current_exception()",
          "new_api": null,
          "old_text": "std::current_exception()",
          "new_text": null,
          "old_line_content": "                parallel_merge_data->exception = std::current_exception();",
          "new_line_content": "                block = aggregator.convertOneBucketToBlock(merged_data, *merged_data.NAME, final, bucket_num); \\",
          "content_same": false
        },
        {
          "line": 1946,
          "old_api": "empty",
          "new_api": null,
          "old_text": "data_variants.empty()",
          "new_text": null,
          "old_line_content": "    if (data_variants.empty())",
          "new_line_content": "        catch (...)",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Empty data passed to Aggregator::mergeAndConvertToBlocks.\", ErrorCodes::EMPTY_DATA_PASSED)",
          "new_text": null,
          "old_line_content": "        throw Exception(\"Empty data passed to Aggregator::mergeAndConvertToBlocks.\", ErrorCodes::EMPTY_DATA_PASSED);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1949,
          "old_api": "LOG_TRACE",
          "new_api": null,
          "old_text": "LOG_TRACE(log, \"Merging aggregated data\")",
          "new_text": null,
          "old_line_content": "    LOG_TRACE(log, \"Merging aggregated data\");",
          "new_line_content": "            if (!parallel_merge_data->exception)",
          "content_same": false
        },
        {
          "line": 1952,
          "old_api": "size",
          "new_api": null,
          "old_text": "data_variants.size()",
          "new_text": null,
          "old_line_content": "    non_empty_data.reserve(data_variants.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1954,
          "old_api": "empty",
          "new_api": null,
          "old_text": "data->empty()",
          "new_text": null,
          "old_line_content": "        if (!data->empty())",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1955,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "non_empty_data.push_back(data)",
          "new_text": null,
          "old_line_content": "            non_empty_data.push_back(data);",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 1957,
          "old_api": "empty",
          "new_api": null,
          "old_text": "non_empty_data.empty()",
          "new_text": null,
          "old_line_content": "    if (non_empty_data.empty())",
          "new_line_content": "ManyAggregatedDataVariants Aggregator::prepareVariantsToMerge(ManyAggregatedDataVariants & data_variants) const",
          "content_same": false
        },
        {
          "line": 1963,
          "old_api": "end",
          "new_api": null,
          "old_text": "non_empty_data.end()",
          "new_text": null,
          "old_line_content": "        std::sort(non_empty_data.begin(), non_empty_data.end(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1966,
          "old_api": "sizeWithoutOverflowRow",
          "new_api": null,
          "old_text": "rhs->sizeWithoutOverflowRow()",
          "new_text": null,
          "old_line_content": "                return lhs->sizeWithoutOverflowRow() > rhs->sizeWithoutOverflowRow();",
          "new_line_content": "    for (auto & data : data_variants)",
          "content_same": false
        },
        {
          "line": 1985,
          "old_api": "isTwoLevel",
          "new_api": null,
          "old_text": "variant->isTwoLevel()",
          "new_text": null,
          "old_line_content": "            if (!variant->isTwoLevel())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1986,
          "old_api": "convertToTwoLevel",
          "new_api": null,
          "old_text": "variant->convertToTwoLevel()",
          "new_text": null,
          "old_line_content": "                variant->convertToTwoLevel();",
          "new_line_content": "    bool has_at_least_one_two_level = false;",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": "size",
          "new_api": null,
          "old_text": "non_empty_data.size()",
          "new_text": null,
          "old_line_content": "    for (size_t i = 1, size = non_empty_data.size(); i < size; ++i)",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1993,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Cannot merge different aggregated data variants.\", ErrorCodes::CANNOT_MERGE_DIFFERENT_AGGREGATED_DATA_VARIANTS)",
          "new_text": null,
          "old_line_content": "            throw Exception(\"Cannot merge different aggregated data variants.\", ErrorCodes::CANNOT_MERGE_DIFFERENT_AGGREGATED_DATA_VARIANTS);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2008,
          "old_api": "prepareVariantsToMerge",
          "new_api": null,
          "old_text": "prepareVariantsToMerge(data_variants)",
          "new_text": null,
          "old_line_content": "    ManyAggregatedDataVariants non_empty_data = prepareVariantsToMerge(data_variants);",
          "new_line_content": "        /** Elements from the remaining sets can be moved to the first data set.",
          "content_same": false
        },
        {
          "line": 2010,
          "old_api": "empty",
          "new_api": null,
          "old_text": "non_empty_data.empty()",
          "new_text": null,
          "old_line_content": "    if (non_empty_data.empty())",
          "new_line_content": "          */",
          "content_same": false
        },
        {
          "line": 2013,
          "old_api": "std::make_unique<MergingAndConvertingBlockInputStream>(*this, non_empty_data, final, max_threads)",
          "new_api": null,
          "old_text": "std::make_unique<MergingAndConvertingBlockInputStream>(*this, non_empty_data, final, max_threads)",
          "new_text": null,
          "old_line_content": "    return std::make_unique<MergingAndConvertingBlockInputStream>(*this, non_empty_data, final, max_threads);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2030,
          "old_api": "safeGetByPosition",
          "new_api": null,
          "old_text": "block.safeGetByPosition(i).column.get()",
          "new_text": null,
          "old_line_content": "        key_columns[i] = block.safeGetByPosition(i).column.get();",
          "new_line_content": "template <bool no_more_keys, typename Method, typename Table>",
          "content_same": false
        },
        {
          "line": 2035,
          "old_api": "getByName",
          "new_api": null,
          "old_text": "block.getByName(aggregate_column_name)",
          "new_text": null,
          "old_line_content": "        aggregate_columns[i] = &typeid_cast<const ColumnAggregateFunction &>(*block.getByName(aggregate_column_name).column).getData();",
          "new_line_content": "    Table & data,",
          "content_same": false
        },
        {
          "line": 2041,
          "old_api": "rows",
          "new_api": null,
          "old_text": "block.rows()",
          "new_text": null,
          "old_line_content": "    size_t rows = block.rows();",
          "new_line_content": "    /// Remember the columns we will work with",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 92,
      "total_additions": 331,
      "total_deletions": 329,
      "total_api_changes": 752
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 13,
        "api_related_lines": 752,
        "non_api_lines": 10,
        "non_api_line_numbers": [
          555,
          524,
          525,
          526,
          527,
          556,
          529,
          531,
          532,
          533
        ]
      }
    },
    "api_calls_before": 579,
    "api_calls_after": 582,
    "diff_info": {
      "added_lines": 13,
      "removed_lines": 0,
      "total_diff_lines": 32
    }
  }
}