{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/a7387d9ce431a1f288d1a4898fa0c0c36c765abc",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/a7387d9ce431a1f288d1a4898fa0c0c36c765abc/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/a7387d9ce431a1f288d1a4898fa0c0c36c765abc/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/a7387d9ce431a1f288d1a4898fa0c0c36c765abc/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 151,
          "old_api": "umn_no).column = co",
          "new_api": "}\n}\n\n\nclass Buffer",
          "old_text": "umn_no).column = co",
          "new_text": "\t}\n}\n\n\nclass Buffer",
          "old_line_content": null,
          "new_line_content": "\t\t\tthrow Exception(\"Cannot append block to another: different type of columns at index \" + toString(column_no)",
          "content_same": true
        },
        {
          "line": 152,
          "old_api": "s; ++row_no)\n\t\t\t\tc",
          "new_api": "rBlockOutputStream",
          "old_text": "s; ++row_no)\n\t\t\t\tc",
          "new_text": "rBlockOutputStream",
          "old_line_content": null,
          "new_line_content": "\t\t\t\t+ \". Block 1: \" + from.dumpStructure() + \". Block 2: \" + to.dumpStructure(), ErrorCodes::BLOCKS_HAS_DIFFERENT_STRUCTURE);",
          "content_same": true
        },
        {
          "line": 154,
          "old_api": "rBlockOutputSt",
          "new_api": "void write(const Block & block)\n\t{\n\t\tif",
          "old_text": "rBlockOutputSt",
          "new_text": "\n\tvoid write(const Block & block)\n\t{\n\t\tif",
          "old_line_content": "\t\tif (col_to.empty())",
          "new_line_content": "\t\tcol_to.insertRangeFrom(col_from, 0, rows);",
          "content_same": false
        },
        {
          "line": 180,
          "old_api": "s myself. Write will cause infinite loop.\", ErrorCodes::INFINITE_LOOP);\n\n\t\t\t\t/// Про",
          "new_api": "{\n\t\t\t\t\tdestinat",
          "old_text": "s myself. Write will cause infinite loop.\", ErrorCodes::INFINITE_LOOP);\n\n\t\t\t\t/// Про",
          "new_text": "\t\t{\n\t\t\t\t\tdestinat",
          "old_line_content": "\t\t\tdestination = storage.context.tryGetTable(storage.destination_database, storage.destination_table);",
          "new_line_content": "\t\t\t\tif (destination.get() == &storage)",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": "}\n\t\t}\n\n\t\tsize_t bytes = blo",
          "new_api": "ксимальные ограничения, то пишем минуя буфер.\n\t\tif (rows > storage.max_thresholds.rows || bytes > storage.max_thresholds.b",
          "old_text": "\n\t\t\t}\n\t\t}\n\n\t\tsize_t bytes = blo",
          "new_text": "ксимальные ограничения, то пишем минуя буфер.\n\t\tif (rows > storage.max_thresholds.rows || bytes > storage.max_thresholds.b",
          "old_line_content": "\t\t\t\t\tdestination->check(block, true);",
          "new_line_content": "\t\t\t\t\te.addMessage(\"(when looking at destination table \" + storage.destination_database + \".\" + storage.destination_table + \")\");",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": ", sorted_block.byte",
          "new_api": "r, fals",
          "old_text": ", sorted_block.byte",
          "new_text": "r, fals",
          "old_line_content": "\t\tBlock sorted_block = block.sortColumns();",
          "new_line_content": "\t\t\tbuffer.first_write_time = time(0);",
          "content_same": false
        },
        {
          "line": 255,
          "old_api": "ional_bytes)\n{\n\ttime",
          "new_api": "urrent_time",
          "old_text": "ional_bytes)\n{\n\ttime",
          "new_text": "urrent_time",
          "old_line_content": "\t\tif (storage.checkThresholds(buffer, time(0), sorted_block.rowsInFirstColumn(), sorted_block.bytes()))",
          "new_line_content": "\t\t\tlock.lock();",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": "fer.first_write_time)\n\t\ttime_passe",
          "new_api": ".first_write_time;\n\n\tsize_t rows = buf",
          "old_text": "fer.first_write_time)\n\t\ttime_passe",
          "new_text": ".first_write_time;\n\n\tsize_t rows = buf",
          "old_line_content": "\t\t\tstorage.flushBuffer(buffer, false);",
          "new_line_content": "\t\tappendBlock(sorted_block, buffer.data);",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": "e_passed > max_thre",
          "new_api": "max_thresholds.rows |",
          "old_text": "e_passed > max_thre",
          "new_text": "max_thresholds.rows |",
          "old_line_content": "\t\tflush_thread.join();",
          "new_line_content": "\t\toptimize(context.getSettings());",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": "max_thresholds.rows |",
          "new_api": ".bytes);\n\n\tif (res)\n\t\tLOG_TRACE(log, \"Flush",
          "old_text": "max_thresholds.rows |",
          "new_text": ".bytes);\n\n\tif (res)\n\t\tLOG_TRACE(log, \"Flush",
          "old_line_content": "\t\toptimize(context.getSettings());",
          "new_line_content": "\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": "rn;\n\n\tif (!table)\n\t{\n\t\tLOG_ERRO",
          "new_api": "\" << destination_database << \".\"",
          "old_text": "rn;\n\n\tif (!table)\n\t{\n\t\tLOG_ERRO",
          "new_text": "\" << destination_database << \".\"",
          "old_line_content": "\t\t\tif (buffer.data.rowsInFirstColumn() == 0)",
          "new_line_content": "\t\tbuffer.data.swap(block_to_write);",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "execute",
          "new_api": "do\n\t{\n\t\ttry\n\t\t{\n\t\t\tfl",
          "old_text": "r.execute();\n\tb",
          "new_text": "\n\tdo\n\t{\n\t\ttry\n\t\t{\n\t\t\tfl",
          "old_line_content": "\tcolumns_intersection.reserve(block.columns());",
          "new_line_content": "\t\tif (block.has(dst_col.name))",
          "content_same": false
        },
        {
          "line": 414,
          "old_api": "do\n\t{\n\t\ttry\n\t\t{\n\t\t\tfl",
          "new_api": "tryWait",
          "old_text": "\n\tdo\n\t{\n\t\ttry\n\t\t{\n\t\t\tfl",
          "new_text": "} while (!shutdown_event.tryWait(1000));\n}\n\n\nvoid StorageBuffer::alter(const AlterCommands & params, const String & database_name, const String & table_name, Context & context)\n{\n\ta",
          "old_line_content": "\t\tif (block.has(dst_col.name))",
          "new_line_content": "\t\t\t\tLOG_ERROR(log, \"Destination table \" << destination_database << \".\" << destination_table",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": "eForAlter",
          "new_api": "ы.\n\toptimize(context.getSett",
          "old_text": "eForAlter();\n\n\t/// Чтобы не осталось блоков ",
          "new_text": "ы.\n\toptimize(context.getSett",
          "old_line_content": "\t\t\tcolumns_intersection.push_back(dst_col.name);",
          "new_line_content": "\tif (columns_intersection.empty())",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": "apply",
          "new_api": "xt);\n}\n\n}",
          "old_text": ";\n\n\tparams.apply(*columns, materialized_columns, alias_columns, column_defaults);\n\tInterpreterAlterQuery::updateMetadata(database_name, table_name,\n\t\t*columns, materia",
          "new_text": "xt);\n}\n\n}\n",
          "old_line_content": "\t\tLOG_ERROR(log, \"Destination table \" << destination_database << \".\" << destination_table << \" have no common columns with block in buffer. Block of data is discarded.\");",
          "new_line_content": "\tif (columns_intersection.size() != block.columns())",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 391,
          "old_api": null,
          "new_api": ", \"Destination table \" << destination_database << \".\" << destination_table << \" have no common columns with block in buffer. Block of dat",
          "old_text": null,
          "new_text": ", \"Destination table \" << destination_database << \".\" << destination_table << \" have no common columns with block in buffer. Block of dat",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\t\tLOG_ERROR(log, \"Destination table \" << destination_database << \".\" << destination_table << \" doesn't exist. Block of data is discarded.\");",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": null,
          "new_api": "esholds.rows && byte",
          "old_text": null,
          "new_text": "esholds.rows && byte",
          "old_line_content": "",
          "new_line_content": "\tshutdown_event.set();",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": null,
          "new_api": "thresholds.bytes)\n\t\t||",
          "old_text": null,
          "new_text": "thresholds.bytes)\n\t\t|| ",
          "old_line_content": "void StorageBuffer::shutdown()",
          "new_line_content": "\tif (flush_thread.joinable())",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": null,
          "new_api": "e_passed > max_thre",
          "old_text": null,
          "new_text": "e_passed > max_thre",
          "old_line_content": "{",
          "new_line_content": "\t\tflush_thread.join();",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": null,
          "new_api": "InterpreterInsertQuer",
          "old_text": null,
          "new_text": "\n\tInterpreterInsertQuer",
          "old_line_content": "",
          "new_line_content": "\tBlock structure_of_destination_table = table->getSampleBlock();",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": null,
          "new_api": "execute",
          "old_text": null,
          "new_text": "r.execute();\n\tb",
          "old_line_content": "\t  * Это позволит поддержать часть случаев (но не все), когда структура таблицы не совпадает.",
          "new_line_content": "\tcolumns_intersection.reserve(block.columns());",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": null,
          "new_api": "write",
          "old_text": null,
          "new_text": "_io.out->write(block);\n\tblock_io.out->wr",
          "old_line_content": "\t  */",
          "new_line_content": "\tfor (size_t i : ext::range(0, structure_of_destination_table.columns()))",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": null,
          "new_api": "torageBuffer::flushThread()\n{\n\tsetThreadName(\"BufferF",
          "old_text": null,
          "new_text": "torageBuffer::flushThread()\n{\n\tsetThreadName(\"BufferF",
          "old_line_content": "\tNames columns_intersection;",
          "new_line_content": "\t\tauto dst_col = structure_of_destination_table.unsafeGetByPosition(i);",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": null,
          "new_api": "eption",
          "old_text": null,
          "new_text": "eption(__PRETTY_FUNCTIO",
          "old_line_content": "\t{",
          "new_line_content": "\t\t\tif (block.getByName(dst_col.name).type->getName() != dst_col.type->getName())",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": null,
          "new_api": "time_passed << \" seco",
          "old_text": null,
          "new_text": " time_passed << \" seco",
          "old_line_content": "",
          "new_line_content": "\tflushAllBuffers(false);",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": null,
          "new_api": "eForAlter",
          "old_text": null,
          "new_text": "eForAlter();\n\n\t/// Чтобы не осталось блоков ",
          "old_line_content": "\t\t\t\t\t<< \" have different type of column \" << dst_col.name << \". Block of data is discarded.\");",
          "new_line_content": "\t\t\tcolumns_intersection.push_back(dst_col.name);",
          "content_same": false
        },
        {
          "line": 169,
          "old_api": null,
          "new_api": "age.destination_table);",
          "old_text": null,
          "new_text": "age.destination_table);\n\n",
          "old_line_content": "\t{",
          "new_line_content": "\t\tsize_t rows = block.rowsInFirstColumn();",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": null,
          "new_api": "apply",
          "old_text": null,
          "new_text": ";\n\n\tparams.apply(*columns, materialized_columns, alias_columns, column_defaults);\n\tInterpreterAlterQuery::updateMetadata(database_name, table_name,\n\t\t*columns, materia",
          "old_line_content": "\t}",
          "new_line_content": "\t\tLOG_ERROR(log, \"Destination table \" << destination_database << \".\" << destination_table << \" have no common columns with block in buffer. Block of data is discarded.\");",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": null,
          "new_api": "nt_time = check_thresholds ? ti",
          "old_text": null,
          "new_text": "nt_time = check_thresholds ? ti",
          "old_line_content": "\ttime_t time_passed = 0;",
          "new_line_content": "\tsize_t rows = buffer.data.rowsInFirstColumn() + additional_rows;",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": null,
          "new_api": "лем из-за того, что",
          "old_text": null,
          "new_text": "лем из-за того, что",
          "old_line_content": "\tif (buffer.first_write_time)",
          "new_line_content": "\tsize_t bytes = buffer.data.bytes() + additional_bytes;",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\t\tLOG_WARNING(log, \"Not all columns from block in buffer exist in destination table \"",
          "content_same": false
        },
        {
          "line": 176,
          "old_api": null,
          "new_api": "s myself. Write will cause infinite loop.\", ErrorCodes::INFINITE_LOOP);\n\n\t\t\t\t/// Про",
          "old_text": null,
          "new_text": "s myself. Write will cause infinite loop.\", ErrorCodes::INFINITE_LOOP);\n\n\t\t\t\t/// Про",
          "old_line_content": "",
          "new_line_content": "\t\t\tdestination = storage.context.tryGetTable(storage.destination_database, storage.destination_table);",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\t<< destination_database << \".\" << destination_table << \". Some columns are discarded.\");",
          "new_line_content": "\tlist_of_columns->children.reserve(columns_intersection.size());",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": null,
          "new_api": "addMessage",
          "old_text": null,
          "new_text": "\t\t\t\t}\n\t\t\t\tcatch (Exception & e)\n\t\t\t\t{\n\t\t\t\t\te.addMessage(\"(when looking at destination table \" + stor",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tthrow Exception(\"Destination table is myself. Write will cause infinite loop.\", ErrorCodes::INFINITE_LOOP);",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": null,
          "new_api": "в буфер.\n\t  * Замечание: может быть, стоит избавиться от такой сложности.\n\t  */\n\t{\n\t\tstd::lock_guard<std::mutex> lock",
          "old_text": null,
          "new_text": "в буфер.\n\t  * Замечание: может быть, стоит избавиться от такой сложности.\n\t  */\n\t{\n\t\tstd::lock_guard<std::mutex> lock",
          "old_line_content": "\t       (time_passed > min_thresholds.time && rows > min_thresholds.rows && bytes > min_thresholds.bytes)",
          "new_line_content": "\t\tLOG_TRACE(log, \"Flushing buffer with \" << rows << \" rows, \" << bytes << \" bytes, age \" << time_passed << \" seconds.\");",
          "content_same": false
        },
        {
          "line": 437,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\tASTExpressionList * list_of_columns = new ASTExpressionList;",
          "new_line_content": "\t\tlist_of_columns->children.push_back(new ASTIdentifier(StringRange(), column, ASTIdentifier::Column));",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": null,
          "new_api": "}\n\t\t}\n\n\t\tsize_t bytes = blo",
          "old_text": null,
          "new_text": "\n\t\t\t}\n\t\t}\n\n\t\tsize_t bytes = blo",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tdestination->check(block, true);",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tblock_io.out->writePrefix();",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\tInterpreterInsertQuery interpreter{ast_ptr, context};",
          "new_line_content": "\tblock_io.out->write(block);",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tblock_io.out->writeSuffix();",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": null,
          "new_api": "{\n\t\t\tif (buffer.data.rowsInFirstCo",
          "old_text": null,
          "new_text": "{\n\t\t\tif (buffer.data.rowsInFirstCo",
          "old_line_content": "",
          "new_line_content": "\t\tflushBuffer(buf, check_thresholds);",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tsetThreadName(\"BufferFlush\");",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": null,
          "new_api": "LOG_TRACE",
          "old_text": null,
          "new_text": "\t\t\t\tLOG_TRACE",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\tsize_t bytes = block.bytes();",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": null,
          "new_api": "iteBloc",
          "old_text": null,
          "new_text": "iteBloc",
          "old_line_content": "",
          "new_line_content": "\ttime_t current_time = check_thresholds ? time(0) : 0;",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\tdo",
          "new_line_content": "\t\t\tflushAllBuffers(true);",
          "content_same": false
        },
        {
          "line": 203,
          "old_api": null,
          "new_api": "Number::get() % storage.num_shards;\n\n\t\t/// Перебираем буферы по кругу, пытаясь заблокировать mute",
          "old_text": null,
          "new_text": "Number::get() % storage.num_shards;\n\n\t\t/// Перебираем буферы по кругу, пытаясь заблокировать mute",
          "old_line_content": "\t\tif (rows > storage.max_thresholds.rows || bytes > storage.max_thresholds.bytes)",
          "new_line_content": "\t\t\t\tLOG_TRACE(storage.log, \"Writing block with \" << rows << \" rows, \" << bytes << \" bytes directly.\");",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": null,
          "new_api": "более одного круга.\n\t\tauto shard_num = start_shard_",
          "old_text": null,
          "new_text": "более одного круга.\n\t\tauto shard_num = start_shard_",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\t\tstorage.writeBlockToDestination(block, destination);",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tcatch (...)",
          "new_line_content": "\t} while (!shutdown_event.tryWait(1000));",
          "content_same": false
        },
        {
          "line": 210,
          "old_api": null,
          "new_api": "::try_to_lock_t());\n\t\t\tif",
          "old_text": null,
          "new_text": "::try_to_lock_t());\n\t\t\tif",
          "old_line_content": "\t\t\treturn;",
          "new_line_content": "\t\tconst auto start_shard_num = Poco::ThreadNumber::get() % storage.num_shards;",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": null,
          "new_api": "Block & block, StoragePtr table)\n{",
          "old_text": null,
          "new_text": " Block & block, StoragePtr table)\n{\n\t",
          "old_line_content": "\t\tstd::lock_guard<std::mutex> lock(buffer.mutex);",
          "new_line_content": "\t\t\tif (!checkThresholds(buffer, current_time))",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tauto lock = lockStructureForAlter();",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": null,
          "new_api": "rn;\n\n\tif (!table)\n\t{\n\t\tLOG_ERRO",
          "old_text": null,
          "new_text": "rn;\n\n\tif (!table)\n\t{\n\t\tLOG_ERRO",
          "old_line_content": "\t\t\t\treturn;",
          "new_line_content": "\t\t\tif (buffer.data.rowsInFirstColumn() == 0)",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "{",
          "new_line_content": "\toptimize(context.getSettings());",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": null,
          "new_api": "ffers[start_shard_nu",
          "old_text": null,
          "new_text": "ffers[start_shard_nu",
          "old_line_content": "\t\tauto shard_num = start_shard_num;",
          "new_line_content": "\t\t\tstd::unique_lock<std::mutex> lock(storage.buffers[shard_num].mutex, std::try_to_lock_t());",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": null,
          "new_api": "nique_lock<std::",
          "old_text": null,
          "new_text": "nique_lock<std::",
          "old_line_content": "\t\tsize_t try_no = 0;",
          "new_line_content": "\t\t\tif (lock.owns_lock())",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tparams.apply(*columns, materialized_columns, alias_columns, column_defaults);",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": null,
          "new_api": "torageBuffer &",
          "old_text": null,
          "new_text": "torageBuffer & ",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\t\tinsertIntoBuffer(block, storage.buffers[shard_num], std::move(lock));",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t/// Чтобы не осталось блоков старой структуры.",
          "new_line_content": "\tInterpreterAlterQuery::updateMetadata(database_name, table_name,",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": null,
          "new_api": "STInsertQuery;\n\tASTPtr ast_ptr = insert;\n\n\tinsert->database",
          "old_text": null,
          "new_text": "STInsertQuery;\n\tASTPtr ast_ptr = insert;\n\n\tinsert->database ",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\t\twriteBlockToDestination(block_to_write, context.tryGetTable(destination_database, destination_table));",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": null,
          "new_api": "cloneEmpty",
          "old_text": null,
          "new_text": "ta = sorted_block.cloneEmpty();\n\t\t}\n\n\t\t/** Если после вставки в буфе",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tinsertIntoBuffer(block, storage.buffers[start_shard_num], std::unique_lock<std::mutex>(storage.buffers[start_shard_num].mutex));",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": null,
          "new_api": ", sorted_block.byte",
          "old_text": null,
          "new_text": ", sorted_block.byte",
          "old_line_content": "",
          "new_line_content": "\t\tBlock sorted_block = block.sortColumns();",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": null,
          "new_api": "has",
          "old_text": null,
          "new_text": "(block.has(dst_col.name))\n\t\t{\n\t\t\tif (blo",
          "old_line_content": "\t\t\t/** Так как структура таблицы не изменилась, можно склеить два блока.",
          "new_line_content": "\t\t\tappendBlock(buffer.data, block_to_write);",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": null,
          "new_api": "}\n\n\t\tappendBlock(sorte",
          "old_text": null,
          "new_text": "\n\t\t}\n\n\t\tappendBlock(sorte",
          "old_line_content": "",
          "new_line_content": "\t\t\tbuffer.data = sorted_block.cloneEmpty();",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "ame(dst_col.name).type->getName(",
          "old_line_content": "\t\t\t  */",
          "new_line_content": "\t\tbuffer.data.swap(block_to_write);",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": null,
          "new_api": "ional_bytes)\n{\n\ttime",
          "old_text": null,
          "new_text": "ional_bytes)\n{\n\ttime",
          "old_line_content": "\t\t/** Если после вставки в буфер, ограничения будут превышены, то будем сбрасывать буфер.",
          "new_line_content": "\t\tif (storage.checkThresholds(buffer, time(0), sorted_block.rowsInFirstColumn(), sorted_block.bytes()))",
          "content_same": false
        },
        {
          "line": 253,
          "old_api": null,
          "new_api": "ssed = 0;\n\tif",
          "old_text": null,
          "new_text": "ssed = 0;\n\tif",
          "old_line_content": "\t\t  *  будет выкинуто исключение, а новые данные не будут добавлены в буфер.",
          "new_line_content": "\t\t\tlock.unlock();",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": null,
          "new_api": "fer.first_write_time)\n\t\ttime_passe",
          "old_text": null,
          "new_text": "fer.first_write_time)\n\t\ttime_passe",
          "old_line_content": "\t\t  */",
          "new_line_content": "\t\t\tstorage.flushBuffer(buffer, false);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 257,
          "old_api": "ssed = 0;\n\tif",
          "new_api": null,
          "old_text": "ssed = 0;\n\tif",
          "new_text": null,
          "old_line_content": "\t\t\tlock.unlock();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": "urrent_time",
          "new_api": null,
          "old_text": "urrent_time",
          "new_text": null,
          "old_line_content": "\t\t\tlock.lock();",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": ".first_write_time;\n\n\tsize_t rows = buf",
          "new_api": null,
          "old_text": ".first_write_time;\n\n\tsize_t rows = buf",
          "new_text": null,
          "old_line_content": "\t\tappendBlock(sorted_block, buffer.data);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": ", \"Destination table \" << destination_database << \".\" << destination_table << \" have no common columns with block in buffer. Block of dat",
          "new_api": null,
          "old_text": ", \"Destination table \" << destination_database << \".\" << destination_table << \" have no common columns with block in buffer. Block of dat",
          "new_text": null,
          "old_line_content": "\t\tLOG_ERROR(log, \"Destination table \" << destination_database << \".\" << destination_table << \" doesn't exist. Block of data is discarded.\");",
          "new_line_content": "\tASTInsertQuery * insert = new ASTInsertQuery;",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": "esholds.rows && byte",
          "new_api": null,
          "old_text": "esholds.rows && byte",
          "new_text": null,
          "old_line_content": "\tshutdown_event.set();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": "thresholds.bytes)\n\t\t||",
          "new_api": null,
          "old_text": "thresholds.bytes)\n\t\t|| ",
          "new_text": null,
          "old_line_content": "\tif (flush_thread.joinable())",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": "InterpreterInsertQuer",
          "new_api": null,
          "old_text": "\n\tInterpreterInsertQuer",
          "new_text": null,
          "old_line_content": "\tBlock structure_of_destination_table = table->getSampleBlock();",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 155,
          "old_api": "BufferBlockOut",
          "new_api": null,
          "old_text": "\n\tBufferBlockOut",
          "new_text": null,
          "old_line_content": "\t\t\tto.getByPosition(column_no).column = col_from.clone();",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": "write",
          "new_api": null,
          "old_text": "_io.out->write(block);\n\tblock_io.out->wr",
          "new_text": null,
          "old_line_content": "\tfor (size_t i : ext::range(0, structure_of_destination_table.columns()))",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "torageBuffer::flushThread()\n{\n\tsetThreadName(\"BufferF",
          "new_api": null,
          "old_text": "torageBuffer::flushThread()\n{\n\tsetThreadName(\"BufferF",
          "new_text": null,
          "old_line_content": "\t\tauto dst_col = structure_of_destination_table.unsafeGetByPosition(i);",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": "write(const Block & block)\n\t{\n\t\tif",
          "new_api": null,
          "old_text": " write(const Block & block)\n\t{\n\t\tif",
          "new_text": null,
          "old_line_content": "\t\t\t\tcol_to.insertFrom(col_from, row_no);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": ".bytes);\n\n\tif (res)\n\t\tLOG_TRACE(log, \"Flush",
          "new_api": null,
          "old_text": ".bytes);\n\n\tif (res)\n\t\tLOG_TRACE(log, \"Flush",
          "new_text": null,
          "old_line_content": "\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": "eption",
          "new_api": null,
          "old_text": "eption(__PRETTY_FUNCTIO",
          "new_text": null,
          "old_line_content": "\t\t\tif (block.getByName(dst_col.name).type->getName() != dst_col.type->getName())",
          "new_line_content": "\t\t\t\treturn;",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": "tryWait",
          "new_api": null,
          "old_text": "} while (!shutdown_event.tryWait(1000));\n}\n\n\nvoid StorageBuffer::alter(const AlterCommands & params, const String & database_name, const String & table_name, Context & context)\n{\n\ta",
          "new_text": null,
          "old_line_content": "\t\t\t\tLOG_ERROR(log, \"Destination table \" << destination_database << \".\" << destination_table",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 293,
          "old_api": "time_passed << \" seco",
          "new_api": null,
          "old_text": " time_passed << \" seco",
          "new_text": null,
          "old_line_content": "\tflushAllBuffers(false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": "ы.\n\toptimize(context.getSett",
          "new_api": null,
          "old_text": "ы.\n\toptimize(context.getSett",
          "new_text": null,
          "old_line_content": "\tif (columns_intersection.empty())",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 173,
          "old_api": "age.destination_table);",
          "new_api": null,
          "old_text": "age.destination_table);\n\n",
          "new_text": null,
          "old_line_content": "\t\tsize_t rows = block.rowsInFirstColumn();",
          "new_line_content": "\t\tStoragePtr destination;",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": "nt_time = check_thresholds ? ti",
          "new_api": null,
          "old_text": "nt_time = check_thresholds ? ti",
          "new_text": null,
          "old_line_content": "\tsize_t rows = buffer.data.rowsInFirstColumn() + additional_rows;",
          "new_line_content": "\t       (time_passed > min_thresholds.time && rows > min_thresholds.rows && bytes > min_thresholds.bytes)",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": "лем из-за того, что",
          "new_api": null,
          "old_text": "лем из-за того, что",
          "new_text": null,
          "old_line_content": "\tsize_t bytes = buffer.data.bytes() + additional_bytes;",
          "new_line_content": "\t\t|| (time_passed > max_thresholds.time || rows > max_thresholds.rows || bytes > max_thresholds.bytes);",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": "xt);\n}\n\n}",
          "new_api": null,
          "old_text": "xt);\n}\n\n}\n",
          "new_text": null,
          "old_line_content": "\tif (columns_intersection.size() != block.columns())",
          "new_line_content": "\tASTExpressionList * list_of_columns = new ASTExpressionList;",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tLOG_WARNING(log, \"Not all columns from block in buffer exist in destination table \"",
          "new_line_content": "\tinsert->columns = list_of_columns;",
          "content_same": false
        },
        {
          "line": 439,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tlist_of_columns->children.reserve(columns_intersection.size());",
          "new_line_content": "\tInterpreterInsertQuery interpreter{ast_ptr, context};",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": "{\n\t\t\t\t\tdestinat",
          "new_api": null,
          "old_text": "\t\t{\n\t\t\t\t\tdestinat",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (destination.get() == &storage)",
          "new_line_content": "\t\t\t\ttry",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": "addMessage",
          "new_api": null,
          "old_text": "\t\t\t\t}\n\t\t\t\tcatch (Exception & e)\n\t\t\t\t{\n\t\t\t\t\te.addMessage(\"(when looking at destination table \" + stor",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tthrow Exception(\"Destination table is myself. Write will cause infinite loop.\", ErrorCodes::INFINITE_LOOP);",
          "new_line_content": "\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": "в буфер.\n\t  * Замечание: может быть, стоит избавиться от такой сложности.\n\t  */\n\t{\n\t\tstd::lock_guard<std::mutex> lock",
          "new_api": null,
          "old_text": "в буфер.\n\t  * Замечание: может быть, стоит избавиться от такой сложности.\n\t  */\n\t{\n\t\tstd::lock_guard<std::mutex> lock",
          "new_text": null,
          "old_line_content": "\t\tLOG_TRACE(log, \"Flushing buffer with \" << rows << \" rows, \" << bytes << \" bytes, age \" << time_passed << \" seconds.\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tauto block_io = interpreter.execute();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tblock_io.out->writePrefix();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tblock_io.out->write(block);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tblock_io.out->writeSuffix();",
          "new_line_content": "void StorageBuffer::flushThread()",
          "content_same": false
        },
        {
          "line": 194,
          "old_api": "ксимальные ограничения, то пишем минуя буфер.\n\t\tif (rows > storage.max_thresholds.rows || bytes > storage.max_thresholds.b",
          "new_api": null,
          "old_text": "ксимальные ограничения, то пишем минуя буфер.\n\t\tif (rows > storage.max_thresholds.rows || bytes > storage.max_thresholds.b",
          "new_text": null,
          "old_line_content": "\t\t\t\t\te.addMessage(\"(when looking at destination table \" + storage.destination_database + \".\" + storage.destination_table + \")\");",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "{\n\t\t\tif (buffer.data.rowsInFirstCo",
          "new_api": null,
          "old_text": "{\n\t\t\tif (buffer.data.rowsInFirstCo",
          "new_text": null,
          "old_line_content": "\t\tflushBuffer(buf, check_thresholds);",
          "new_line_content": "void StorageBuffer::flushBuffer(Buffer & buffer, bool check_thresholds)",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tsetThreadName(\"BufferFlush\");",
          "new_line_content": "\t\ttry",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": "LOG_TRACE",
          "new_api": null,
          "old_text": "\t\t\t\tLOG_TRACE",
          "new_text": null,
          "old_line_content": "\t\tsize_t bytes = block.bytes();",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": "iteBloc",
          "new_api": null,
          "old_text": "iteBloc",
          "new_text": null,
          "old_line_content": "\ttime_t current_time = check_thresholds ? time(0) : 0;",
          "new_line_content": "\t  * Затем пытаемся записать полученный блок в подчинённую таблицу.",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": "Number::get() % storage.num_shards;\n\n\t\t/// Перебираем буферы по кругу, пытаясь заблокировать mute",
          "new_api": null,
          "old_text": "Number::get() % storage.num_shards;\n\n\t\t/// Перебираем буферы по кругу, пытаясь заблокировать mute",
          "new_text": null,
          "old_line_content": "\t\t\t\tLOG_TRACE(storage.log, \"Writing block with \" << rows << \" rows, \" << bytes << \" bytes directly.\");",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": "более одного круга.\n\t\tauto shard_num = start_shard_",
          "new_api": null,
          "old_text": "более одного круга.\n\t\tauto shard_num = start_shard_",
          "new_text": null,
          "old_line_content": "\t\t\t\tstorage.writeBlockToDestination(block, destination);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t} while (!shutdown_event.tryWait(1000));",
          "new_line_content": "void StorageBuffer::alter(const AlterCommands & params, const String & database_name, const String & table_name, Context & context)",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": "::try_to_lock_t());\n\t\t\tif",
          "new_api": null,
          "old_text": "::try_to_lock_t());\n\t\t\tif",
          "new_text": null,
          "old_line_content": "\t\tconst auto start_shard_num = Poco::ThreadNumber::get() % storage.num_shards;",
          "new_line_content": "\t\tsize_t try_no = 0;",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": "Block & block, StoragePtr table)\n{",
          "new_api": null,
          "old_text": " Block & block, StoragePtr table)\n{\n\t",
          "new_text": null,
          "old_line_content": "\t\t\tif (!checkThresholds(buffer, current_time))",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tauto lock = lockStructureForAlter();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\toptimize(context.getSettings());",
          "new_line_content": "\t\t*columns, materialized_columns, alias_columns, column_defaults, context);",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": "ffers[start_shard_nu",
          "new_api": null,
          "old_text": "ffers[start_shard_nu",
          "new_text": null,
          "old_line_content": "\t\t\tstd::unique_lock<std::mutex> lock(storage.buffers[shard_num].mutex, std::try_to_lock_t());",
          "new_line_content": "\t\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 222,
          "old_api": "nique_lock<std::",
          "new_api": null,
          "old_text": "nique_lock<std::",
          "new_text": null,
          "old_line_content": "\t\t\tif (lock.owns_lock())",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": "\" << destination_database << \".\"",
          "new_api": null,
          "old_text": "\" << destination_database << \".\"",
          "new_text": null,
          "old_line_content": "\t\tbuffer.data.swap(block_to_write);",
          "new_line_content": "\tif (no_destination)",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": "torageBuffer &",
          "new_api": null,
          "old_text": "torageBuffer & ",
          "new_text": null,
          "old_line_content": "\t\t\t\tinsertIntoBuffer(block, storage.buffers[shard_num], std::move(lock));",
          "new_line_content": "\t\t\t++shard_num;",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tparams.apply(*columns, materialized_columns, alias_columns, column_defaults);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tInterpreterAlterQuery::updateMetadata(database_name, table_name,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 360,
          "old_api": "STInsertQuery;\n\tASTPtr ast_ptr = insert;\n\n\tinsert->database",
          "new_api": null,
          "old_text": "STInsertQuery;\n\tASTPtr ast_ptr = insert;\n\n\tinsert->database ",
          "new_text": null,
          "old_line_content": "\t\twriteBlockToDestination(block_to_write, context.tryGetTable(destination_database, destination_table));",
          "new_line_content": "\t\t/// Возвращаем блок на место в буфер.",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": "cloneEmpty",
          "new_api": null,
          "old_text": "ta = sorted_block.cloneEmpty();\n\t\t}\n\n\t\t/** Если после вставки в буфе",
          "new_text": null,
          "old_line_content": "\t\t\tinsertIntoBuffer(block, storage.buffers[start_shard_num], std::unique_lock<std::mutex>(storage.buffers[start_shard_num].mutex));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": "has",
          "new_api": null,
          "old_text": "(block.has(dst_col.name))\n\t\t{\n\t\t\tif (blo",
          "new_text": null,
          "old_line_content": "\t\t\tappendBlock(buffer.data, block_to_write);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": "r, fals",
          "new_api": null,
          "old_text": "r, fals",
          "new_text": null,
          "old_line_content": "\t\t\tbuffer.first_write_time = time(0);",
          "new_line_content": "\t\t/** Если после вставки в буфер, ограничения будут превышены, то будем сбрасывать буфер.",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": "}\n\n\t\tappendBlock(sorte",
          "new_api": null,
          "old_text": "\n\t\t}\n\n\t\tappendBlock(sorte",
          "new_text": null,
          "old_line_content": "\t\t\tbuffer.data = sorted_block.cloneEmpty();",
          "new_line_content": "\t\t  * Это также защищает от неограниченного потребления оперативки, так как в случае невозможности записать в таблицу,",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": "getName",
          "new_api": null,
          "old_text": "ame(dst_col.name).type->getName(",
          "new_text": null,
          "old_line_content": "\t\tbuffer.data.swap(block_to_write);",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 15,
      "total_additions": 52,
      "total_deletions": 54,
      "total_api_changes": 121
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 5,
        "api_related_lines": 121,
        "non_api_lines": 2,
        "non_api_line_numbers": [
          156,
          157
        ]
      }
    },
    "api_calls_before": 120,
    "api_calls_after": 117,
    "diff_info": {
      "added_lines": 1,
      "removed_lines": 5,
      "total_diff_lines": 18
    }
  }
}