{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/b76731a578d8c7eec1b5ab52cc8151dd1cde9df8",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/b76731a578d8c7eec1b5ab52cc8151dd1cde9df8/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/b76731a578d8c7eec1b5ab52cc8151dd1cde9df8/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/b76731a578d8c7eec1b5ab52cc8151dd1cde9df8/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 644,
          "old_api": "for (const String & child : children",
          "new_api": "std::vector<std::pair<String, zkuti",
          "old_text": "\tfor (const String & child : children",
          "new_text": "\n\tstd::vector<std::pair<String, zkuti",
          "old_line_content": null,
          "new_line_content": "\t\tcheckPartAndAddToZooKeeper(part, ops);",
          "content_same": true
        },
        {
          "line": 645,
          "old_api": "zkutil::Stat stat;",
          "new_api": "ooKeeper::GetFuture>>",
          "old_text": "\n\t\tzkutil::Stat stat;",
          "new_text": "ooKeeper::GetFuture>>",
          "old_line_content": null,
          "new_line_content": "\t\tzookeeper->multi(ops);",
          "content_same": true
        },
        {
          "line": 651,
          "old_api": "push_back",
          "new_api": "get",
          "old_text": "this);\n\t\tqueue.push_back(entry);\n\t}\n}\n\n\nvoid StorageReplicatedMergeTree::pullLogsT",
          "new_text": " & future : futures)\n\t{\n\t\tzkutil::ZooKeeper::ValueAndStat res = future.second.get(",
          "old_line_content": null,
          "new_line_content": "\t\tLOG_ERROR(log, \"Removing unexpectedly merged local part from ZooKeeper: \" << name);",
          "content_same": true
        },
        {
          "line": 654,
          "old_api": "next_update_event)\n{\n\tauto zookeep",
          "new_api": "LogEntry::parse(res.value, res.st",
          "old_text": "next_update_event)\n{\n\tauto zookeep",
          "new_text": " LogEntry::parse(res.value, res.st",
          "old_line_content": null,
          "new_line_content": "\t\tremovePartFromZooKeeper(name, ops);",
          "content_same": true
        },
        {
          "line": 655,
          "old_api": "getZooKeeper();\n\n\tst",
          "new_api": "entry->znode_name",
          "old_text": " getZooKeeper();\n\n\tst",
          "new_text": "\n\n\t\tentry->znode_name",
          "old_line_content": null,
          "new_line_content": "\t\tzookeeper->multi(ops);",
          "content_same": true
        },
        {
          "line": 661,
          "old_api": "empty",
          "new_api": "get",
          "old_text": "eeper->getChildren(zookeeper_path + \"/log\");\n\t\tindex = entries.empty() ? 0 : parse<UI",
          "new_text": "ing index_str = zookeeper->get(replica_path + \"/log_pointer\");\n\tUInt64 index;\n\n\tif (i",
          "old_line_content": null,
          "new_line_content": "\t\tLOG_ERROR(log, \"Removing missing part from ZooKeeper and queueing a fetch: \" << name);",
          "content_same": true
        },
        {
          "line": 667,
          "old_api": "{\n\t\tindex = parse<UInt64>(index_str);\n\t}\n\n\tUInt64",
          "new_api": "empty",
          "old_text": "\t{\n\t\tindex = parse<UInt64>(index_str);\n\t}\n\n\tUInt64 ",
          "new_text": "er_path + \"/log\");\n\t\tindex = entries.empty() ? 0 : ",
          "old_line_content": null,
          "new_line_content": "\t\tlog_entry.create_time = tryGetPartCreateTime(zookeeper, replica_path, name);",
          "content_same": true
        },
        {
          "line": 671,
          "old_api": "padIndex",
          "new_api": "toString(index));\n\t}\n\telse\n\t{\n\t\ti",
          "old_text": "padIndex(index), entry_str, &stat)",
          "new_text": " toString(index));\n\t}\n\telse\n\t{\n\t\ti",
          "old_line_content": null,
          "new_line_content": "\t\tremovePartFromZooKeeper(name, ops);",
          "content_same": true
        },
        {
          "line": 672,
          "old_api": "++count;\n\t\t++index;\n\n\t\tLogEntryPtr entry = LogEntry::parse(entry_str, stat);\n\n\t\t/// Одновременно добавим запись в очередь и продвинем указатель на лог.\n\t\tzkutil::",
          "new_api": "tryGet",
          "old_text": "\n\t\t++count;\n\t\t++index;\n\n\t\tLogEntryPtr entry = LogEntry::parse(entry_str, stat);\n\n\t\t/// Одновременно добавим запись в очередь и продвинем указатель на лог.\n\t\tzkutil::",
          "new_text": " = parse<UInt64>(index_str);\n\t}\n\n\tUInt64 first_index = index;\n\n\tsize_t count = 0;\n\tString entry_str;\n\tzkutil::Stat stat;\n\twhile (zookeeper->tryGet(zookeeper_path + \"",
          "old_line_content": null,
          "new_line_content": "\t\tops.push_back(new zkutil::Op::Create(",
          "content_same": true
        },
        {
          "line": 673,
          "old_api": "енно добавим запись в очер",
          "new_api": "_str;\n\tzkutil::Stat stat;",
          "old_text": "енно добавим запись в очер",
          "new_text": "_str;\n\tzkutil::Stat stat;\n",
          "old_line_content": null,
          "new_line_content": "\t\t\treplica_path + \"/queue/queue-\", log_entry.toString(), zookeeper->getDefaultACL(), zkutil::CreateMode::PersistentSequential));",
          "content_same": true
        },
        {
          "line": 674,
          "old_api": "push_back",
          "new_api": "/log-\" + padIndex(ind",
          "old_text": "ops;\n\t\tops.push_back(",
          "new_text": "/log-\" + padIndex(ind",
          "old_line_content": null,
          "new_line_content": "\t\tzookeeper->multi(ops);",
          "content_same": true
        },
        {
          "line": 681,
          "old_api": "multi",
          "new_api": ":Create(\n\t\t\treplica_path + \"/queue/queue-\", entr",
          "old_text": "), -1));\n\t\tauto results = zookeeper->multi(ops);",
          "new_text": ":Create(\n\t\t\treplica_path + \"/queue/queue-\", entr",
          "old_line_content": null,
          "new_line_content": "\t\tdata.renameAndDetachPart(part, \"ignored_\", true);",
          "content_same": true
        },
        {
          "line": 688,
          "old_api": "reated",
          "new_api": "push_back",
          "old_text": "reated();\n\t\tentry->",
          "new_text": ";\n\t\tops.push_back(n",
          "old_line_content": null,
          "new_line_content": "\tauto parts = data.getDataParts();",
          "content_same": true
        },
        {
          "line": 690,
          "old_api": "find_last_of",
          "new_api": "th + \"/log_pointer\", toString",
          "old_text": "_created.find_last_of('/') + ",
          "new_text": "th + \"/log_pointer\", toString",
          "old_line_content": null,
          "new_line_content": "\t\tvirtual_parts.add(part->name);",
          "content_same": true
        },
        {
          "line": 696,
          "old_api": "er_path + \"/lo",
          "new_api": "ath_created.su",
          "old_text": "er_path + \"/lo",
          "new_text": "ath_created.su",
          "old_line_content": null,
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": true
        },
        {
          "line": 698,
          "old_api": "+ padIndex(index)",
          "new_api": "h_created.find_la",
          "old_text": "+ padIndex(index)",
          "new_text": "h_created.find_la",
          "old_line_content": null,
          "new_line_content": "\tif (part_name.empty())",
          "content_same": true
        },
        {
          "line": 701,
          "old_api": "next_update_even",
          "new_api": "esultToVirtualParts",
          "old_text": "\n\t\t\tnext_update_even",
          "new_text": "esultToVirtualParts(",
          "old_line_content": null,
          "new_line_content": "\tcheck(part->columns);",
          "content_same": true
        },
        {
          "line": 704,
          "old_api": "wake",
          "new_api": "exists",
          "old_text": "sk_handle->wake();\n\n\tLOG_DEBUG(log, \"Pulled \" << cou",
          "new_text": " (next_update_event)\n\t{\n\t\tif (zookeeper->exists(zook",
          "old_line_content": null,
          "new_line_content": "\tStrings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "content_same": true
        },
        {
          "line": 705,
          "old_api": "ex",
          "new_api": "), nullptr, ne",
          "old_text": "ex(first_index",
          "new_text": "), nullptr, ne",
          "old_line_content": null,
          "new_line_content": "\tstd::random_shuffle(replicas.begin(), replicas.end());",
          "content_same": true
        },
        {
          "line": 706,
          "old_api": "1));\n}\n\n\nbool StorageRe",
          "new_api": "set",
          "old_text": " 1));\n}\n\n\nbool StorageRe",
          "new_text": "vent->set();\n\t}\n\n\tif (!c",
          "old_line_content": null,
          "new_line_content": "\tString expected_columns_str = part->columns.toString();",
          "content_same": true
        },
        {
          "line": 712,
          "old_api": "е захвачен. Функция вызывается только из queueTask.\n\n\tif (entry.type == LogEntry::MERGE_PARTS || entry.type == LogEntry::G",
          "new_api": "es to queue: log-\" << padIndex(first_index) << \" - log-\" << padIndex(index - 1));\n}\n\n\nbool StorageReplicatedMergeTree::sho",
          "old_text": "е захвачен. Функция вызывается только из queueTask.\n\n\tif (entry.type == LogEntry::MERGE_PARTS || entry.type == LogEntry::G",
          "new_text": "es to queue: log-\" << padIndex(first_index) << \" - log-\" << padIndex(index - 1));\n}\n\n\nbool StorageReplicatedMergeTree::sho",
          "old_line_content": null,
          "new_line_content": "\t\tif (!zookeeper->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/parts/\" + part_name + \"/columns\", columns_str, &stat_before))",
          "content_same": true
        },
        {
          "line": 716,
          "old_api": "count",
          "new_api": "reason)\n{\n\t/// queue_mutex уже захвачен. Функция вызывается только из queueTask.\n\n\tif (entry.type == LogEntry::MERGE_PARTS || entry.",
          "old_text": ", не создаётся ли сейчас этот же кусок другим действием.\n\t\tif (future_parts.count(entry.new_part_name))\n\t\t{\n\t\t\tString reason = \"Not ",
          "new_text": "reason)\n{\n\t/// queue_mutex уже захвачен. Функция вызывается только из queueTask.\n\n\tif (entry.type == LogEntry::MERGE_PARTS || entry.",
          "old_line_content": null,
          "new_line_content": "\t\t\tLOG_INFO(log, \"Not checking checksums of part \" << part_name << \" with replica \" << replica",
          "content_same": true
        },
        {
          "line": 723,
          "old_api": "т успешно,\n\t\t\t  *  и элемент очереди будет обработан. Сразу же в функции executeLogEntry будет выяснено, что кус",
          "new_api": "cessed. This shouldn't happen often.\";\n\t\t\tLOG_DEBUG(log, reason);\n\t\t\tout_postpone_reason = reason;\n\t\t\treturn fal",
          "old_text": "т успешно,\n\t\t\t  *  и элемент очереди будет обработан. Сразу же в функции executeLogEntry будет выяснено, что кус",
          "new_text": "cessed. This shouldn't happen often.\";\n\t\t\tLOG_DEBUG(log, reason);\n\t\t\tout_postpone_reason = reason;\n\t\t\treturn fal",
          "old_line_content": null,
          "new_line_content": "\t\tif (!zookeeper->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/parts/\" + part_name + \"/checksums\", checksums_str) ||",
          "content_same": true
        },
        {
          "line": 724,
          "old_api": "уже есть,\n\t\t\t  *  и элемент очереди будет сразу считаться обработанным.\n\t\t\t  */\n\t\t}\n\n\t\t/// Более сложная пр",
          "new_api": "/** Когда соответствующее действие завершится, то shouldExecuteLogEntry, в следующий раз, пройдёт успешно,",
          "old_text": " уже есть,\n\t\t\t  *  и элемент очереди будет сразу считаться обработанным.\n\t\t\t  */\n\t\t}\n\n\t\t/// Более сложная пр",
          "new_text": "/** Когда соответствующее действие завершится, то shouldExecuteLogEntry, в следующий раз, пройдёт успешно,\n\t",
          "old_line_content": null,
          "new_line_content": "\t\t\t!zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/parts/\" + part_name + \"/columns\", &stat_after) ||",
          "content_same": true
        },
        {
          "line": 727,
          "old_api": "оторый покроет этот кусок.\n\t\t/// NOTE То, что выше - избыточно, но оставлено ради более удобного сообщения в логе.\n\t\tActiveDataPartSet::Part result_part;\n\t\tAct",
          "new_api": "ции executeLogEntry будет выяснено, что кусок у нас уже есть,\n\t\t\t  *  и элемент очереди будет сразу считаться обработанным.\n\t\t\t  */\n\t\t}\n\n\t\t/// Более сложная пр",
          "old_text": "оторый покроет этот кусок.\n\t\t/// NOTE То, что выше - избыточно, но оставлено ради более удобного сообщения в логе.\n\t\tActiveDataPartSet::Part result_part;\n\t\tAct",
          "new_text": "ции executeLogEntry будет выяснено, что кусок у нас уже есть,\n\t\t\t  *  и элемент очереди будет сразу считаться обработанным.\n\t\t\t  */\n\t\t}\n\n\t\t/// Более сложная пр",
          "old_line_content": null,
          "new_line_content": "\t\t\tLOG_INFO(log, \"Not checking checksums of part \" << part_name << \" with replica \" << replica",
          "content_same": true
        },
        {
          "line": 732,
          "old_api": "_part_name, result_part);\n\n\t\t/// Оно может тормозить при",
          "new_api": "действием кусок, который покроет этот кусок.\n\t\t/// NOTE",
          "old_text": "_part_name, result_part);\n\n\t\t/// Оно может тормозить при",
          "new_text": "действием кусок, который покроет этот кусок.\n\t\t/// NOTE ",
          "old_line_content": null,
          "new_line_content": "\t\tauto checksums = MergeTreeData::DataPart::Checksums::parse(checksums_str);",
          "content_same": true
        },
        {
          "line": 733,
          "old_api": "ьшом размере future_parts. Но он не может б",
          "new_api": "что выше - избыточно, но оставлено ради бол",
          "old_text": "ьшом размере future_parts. Но он не может б",
          "new_text": "что выше - избыточно, но оставлено ради бол",
          "old_line_content": null,
          "new_line_content": "\t\tchecksums.checkEqual(part->checksums, true);",
          "content_same": true
        },
        {
          "line": 736,
          "old_api": ", так как ограничен BackgroundProcessingPool.\n\t\tfor (co",
          "new_api": "сообщения в логе.\n\t\tActiveDataPartSet::Part result_par",
          "old_text": ", так как ограничен BackgroundProcessingPool.\n\t\tfor (co",
          "new_text": " сообщения в логе.\n\t\tActiveDataPartSet::Part result_par",
          "old_line_content": null,
          "new_line_content": "\tif (zookeeper->exists(replica_path + \"/parts/\" + part_name))",
          "content_same": true
        },
        {
          "line": 738,
          "old_api": "o & future_part_name : future_parts)\n\t\t{\n\t\t\tActiveDataPartSet::Part future_part;\n\t\t\tActiveDataPartSet::parsePart",
          "new_api": "tiveDataPartSet::parsePartName(entry.new_part_name, result_part);\n\n\t\t/// Оно может тормозить при большом размере",
          "old_text": "o & future_part_name : future_parts)\n\t\t{\n\t\t\tActiveDataPartSet::Part future_part;\n\t\t\tActiveDataPartSet::parsePart",
          "new_text": "tiveDataPartSet::parsePartName(entry.new_part_name, result_part);\n\n\t\t/// Оно может тормозить при большом размере",
          "old_line_content": null,
          "new_line_content": "\t\tLOG_ERROR(log, \"checkPartAndAddToZooKeeper: node \" << replica_path + \"/parts/\" + part_name << \" already exists\");",
          "content_same": true
        },
        {
          "line": 742,
          "old_api": "e_part);\n\n\t\t\tif (future_pa",
          "new_api": "т быть большим, так как ог",
          "old_text": "e_part);\n\n\t\t\tif (future_pa",
          "new_text": "т быть большим, так как ог",
          "old_line_content": null,
          "new_line_content": "\tauto acl = zookeeper->getDefaultACL();",
          "content_same": true
        },
        {
          "line": 744,
          "old_api": "ontains",
          "new_api": "чен BackgroundProcessingPool.\n\t\tfor (const auto & future_part_name : future_parts)\n\t\t{\n\t\t\tActive",
          "old_text": "ontains(result_part))\n\t\t\t{\n\t\t\t\tString reason = \"Not executing log entry for part \" + entry.new_p",
          "new_text": "чен BackgroundProcessingPool.\n\t\tfor (const auto & future_part_name : future_parts)\n\t\t{\n\t\t\tActive",
          "old_line_content": null,
          "new_line_content": "\tops.push_back(new zkutil::Op::Check(",
          "content_same": true
        },
        {
          "line": 747,
          "old_api": "_name\n\t\t\t\t\t+ \" because another log entry for covering part \" + future_part_name + \" is being processed.\";\n\t\t\t\tLOG_DEBUG(log,",
          "new_api": "contains",
          "old_text": "_name\n\t\t\t\t\t+ \" because another log entry for covering part \" + future_part_name + \" is being processed.\";\n\t\t\t\tLOG_DEBUG(log, ",
          "new_text": "aPartSet::Part future_part;\n\t\t\tActiveDataPartSet::parsePartName(future_part_name, future_part);\n\n\t\t\tif (future_part.contains(",
          "old_line_content": null,
          "new_line_content": "\tops.push_back(new zkutil::Op::Create(",
          "content_same": true
        },
        {
          "line": 752,
          "old_api": "son);\n\t\t\t\tout_postpone_reason = reason;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entry.type == LogEntry::MERGE_PARTS)\n\t{\n\t\t/** Если какая-то из нужных частей сейчас",
          "new_api": "ult_part))\n\t\t\t{\n\t\t\t\tString reason = \"Not executing log entry for part \" + entry.new_part_name\n\t\t\t\t\t+ \" because another log entry for covering part \" + future_pa",
          "old_text": "son);\n\t\t\t\tout_postpone_reason = reason;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entry.type == LogEntry::MERGE_PARTS)\n\t{\n\t\t/** Если какая-то из нужных частей сейчас ",
          "new_text": "ult_part))\n\t\t\t{\n\t\t\t\tString reason = \"Not executing log entry for part \" + entry.new_part_name\n\t\t\t\t\t+ \" because another log entry for covering part \" + future_pa",
          "old_line_content": null,
          "new_line_content": "\tops.push_back(new zkutil::Op::Create(",
          "content_same": true
        },
        {
          "line": 754,
          "old_api": "Entry::MERGE_PARTS)\n\t{",
          "new_api": "+ \" because anothe",
          "old_text": "Entry::MERGE_PARTS)\n\t{\n\t",
          "new_text": "\n\t\t\t\t\t+ \" because anothe",
          "old_line_content": null,
          "new_line_content": "\t\tpart->columns.toString(),",
          "content_same": true
        },
        {
          "line": 757,
          "old_api": "едается или мерджится, подождем окончания этой операции.\n\t\t  * Иначе, даже если всех нужных частей для мерджа нет, нужно попытаться сделать мердж.\n\t\t  * Если каких-",
          "new_api": "name + \" is being processed.\";\n\t\t\t\tLOG_DEBUG(log, reason);\n\t\t\t\tout_postpone_reason = reason;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entry.type == LogEntry::MERGE_PARTS",
          "old_text": "едается или мерджится, подождем окончания этой операции.\n\t\t  * Иначе, даже если всех нужных частей для мерджа нет, нужно попытаться сделать мердж.\n\t\t  * Если каких-",
          "new_text": "name + \" is being processed.\";\n\t\t\t\tLOG_DEBUG(log, reason);\n\t\t\t\tout_postpone_reason = reason;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entry.type == LogEntry::MERGE_PARTS",
          "old_line_content": null,
          "new_line_content": "\tops.push_back(new zkutil::Op::Create(",
          "content_same": true
        },
        {
          "line": 759,
          "old_api": "тей для мерджа нет, нужно",
          "new_api": "return false;\n\t\t\t}\n\t\t}",
          "old_text": "тей для мерджа нет, нужно ",
          "new_text": "\t\treturn false;\n\t\t\t}\n\t\t}\n\t",
          "old_line_content": null,
          "new_line_content": "\t\tpart->checksums.toString(),",
          "content_same": true
        },
        {
          "line": 767,
          "old_api": "Такая ситуация",
          "new_api": "ся, подождем о",
          "old_text": "Такая ситуация",
          "new_text": "ся, подождем о",
          "old_line_content": null,
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": true
        },
        {
          "line": 771,
          "old_api": "в конец очереди.\n\t\t  */\n\t\tfor (const auto & na",
          "new_api": "рджа нет, нужно попытаться сделать мердж.\n\t\t  *",
          "old_text": " в конец очереди.\n\t\t  */\n\t\tfor (const auto & na",
          "new_text": "рджа нет, нужно попытаться сделать мердж.\n\t\t  *",
          "old_line_content": null,
          "new_line_content": "\tStrings children = zookeeper->getChildren(replica_path + \"/queue\");",
          "content_same": true
        },
        {
          "line": 772,
          "old_api": "if (future_",
          "new_api": "т, вместо мерд",
          "old_text": "\t\t\tif (future_",
          "new_text": "т, вместо мерд",
          "old_line_content": null,
          "new_line_content": "\tstd::sort(children.begin(), children.end());",
          "content_same": true
        },
        {
          "line": 787,
          "old_api": "\" because merg",
          "new_api": "return false;\n\t\t\t}",
          "old_text": "\" because merg",
          "new_text": "\treturn false;\n\t\t\t}\n\t\t",
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "\t\tqueue.push_back(entry);",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": "eplicatedMergeTre",
          "new_api": "\" because merg",
          "old_text": "eplicatedMergeTre",
          "new_text": "\" because merg",
          "old_line_content": "\tif (index_str.empty())",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": "::ATTACH_PART)",
          "new_api": "n = reason;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn",
          "old_text": "::ATTACH_PART)",
          "new_text": "n = reason;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn ",
          "old_line_content": "\t\tindex = entries.empty() ? 0 : parse<UInt64>(std::min_element(entries.begin(), entries.end())->substr(strlen(\"log-\")));",
          "new_line_content": "\tString index_str = zookeeper->get(replica_path + \"/log_pointer\");",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": "MergeTreeData::DataPart",
          "new_api": "executeDropRange(entry);\n\t\treturn true;\n\t}",
          "old_text": "\tMergeTreeData::DataPart",
          "new_text": "\t\texecuteDropRange(entry);\n\t\treturn true;\n\t}\n\n\t",
          "old_line_content": "\t\tindex = parse<UInt64>(index_str);",
          "new_line_content": "\t\tStrings entries = zookeeper->getChildren(zookeeper_path + \"/log\");",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": "sn't exist.\");",
          "new_api": "sts",
          "old_text": "sn't exist.\");\n",
          "new_text": "sts(replica_path + \"/parts/\" + c",
          "old_line_content": "\t\t\treplica_path + \"/log_pointer\", toString(index), -1));",
          "new_line_content": "\t\tLogEntryPtr entry = LogEntry::parse(entry_str, stat);",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": "path + \"/quorum/failed_parts/\"",
          "new_api": "\" << entry.new_part_name << \" - part already exists.\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (entry.type == LogEntry::GET_PART && entry.source_replica == replica_",
          "old_text": "path + \"/quorum/failed_parts/\"",
          "new_text": " \" << entry.new_part_name << \" - part already exists.\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (entry.type == LogEntry::GET_PART && entry.source_replica == replica_",
          "old_line_content": "\t\tentry->znode_name = path_created.substr(path_created.find_last_of('/') + 1);",
          "new_line_content": "\t\tops.push_back(new zkutil::Op::Create(",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "new_part_name))\n\t{\n\t\tLOG_DEBUG(log, \"",
          "new_api": "(entry.type == LogEntry::",
          "old_text": "new_part_name))\n\t{\n\t\tLOG_DEBUG(log, \"",
          "new_text": " (entry.type == LogEntry::",
          "old_line_content": "\t\tentry->addResultToVirtualParts(*this);",
          "new_line_content": "\t\t\treplica_path + \"/queue/queue-\", entry_str, zookeeper->getDefaultACL(), zkutil::CreateMode::PersistentSequential));",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": "ping action for part \"",
          "new_api": ")\n\t\tLOG_WARNING(log, \"Part \" << entry.new_part_name << \" from own log doesn't exist.\");\n\n\t///",
          "old_text": "ping action for part \"",
          "new_text": ")\n\t\tLOG_WARNING(log, \"Part \" << entry.new_part_name << \" from own log doesn't exist.\");\n\n\t/// ",
          "old_line_content": "\t\tqueue.push_back(entry);",
          "new_line_content": "\t\tops.push_back(new zkutil::Op::SetData(",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": "rts не делается",
          "new_api": "ping action for part \"",
          "old_text": "rts не делается",
          "new_text": "ping action for part \"",
          "old_line_content": "\t\tif (zookeeper->exists(zookeeper_path + \"/log/log-\" + padIndex(index), nullptr, next_update_event))",
          "new_line_content": "\t\tqueue.push_back(entry);",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": "ch = true;\n\t}\n\telse if (e",
          "new_api": "}\n\n\tbool do_fetch = fa",
          "old_text": "ch = true;\n\t}\n\telse if (e",
          "new_text": "\n\t}\n\n\tbool do_fetch = fa",
          "old_line_content": "\t\tqueue_task_handle->wake();",
          "new_line_content": "\t\t\tnext_update_event->set();",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": "keeper_path + \"/nonincrement_block_numbers/\" + partition_str + \"/block-\" + padIndex(part_info.left),",
          "new_api": "Exception",
          "old_text": "keeper_path + \"/nonincrement_block_numbers/\" + partition_str + \"/block-\" + padIndex(part_info.left),\n\t\t\t\t\t\t\t",
          "new_text": "Exception(\"Logical er",
          "old_line_content": "\t\t\tLOG_DEBUG(log, \"Don't have all parts for merge \" << entry.new_part_name << \"; will try to fetch it instead\");",
          "new_line_content": "\t\t\tparts.push_back(part);",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": "(log, \"Marked quorum for part \" << entry.new_part_name << \" as failed.\");",
          "new_api": "push_back",
          "old_text": "(log, \"Marked quorum for part \" << entry.new_part_name << \" as failed.\");\n\t\t\t",
          "new_text": "push_back(new zkutil::Op::Remove(zookeeper_path + \"/b",
          "old_line_content": "\t\t\tconst auto & merge_entry = context.getMergeList().insert(database_name, table_name, entry.new_part_name);",
          "new_line_content": "\t\t\tsize_t sum_parts_size_in_bytes = MergeTreeDataMerger::estimateDiskSpaceForMerge(parts);",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": "илось скачать кусок, нужный",
          "new_api": "uorum);\n\n\t\t\tif (entry.type",
          "old_text": "илось скачать кусок, нужный ",
          "new_text": "uorum);\n\n\t\t\tif (entry.type ",
          "old_line_content": "\t\tthrow Exception(\"Unexpected log entry type: \" + toString(static_cast<int>(entry.type)));",
          "new_line_content": "\t\t\tmerge_selecting_event.set();",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": ">type == LogEntry::MERGE_PAR",
          "new_api": "й кусок. Чтобы",
          "old_text": ">type == LogEntry::MERGE_PAR",
          "new_text": "й кусок. Чтобы ",
          "old_line_content": "\t\t\t\tif (entry.source_replica.empty() || entry.source_replica == replica_name)",
          "new_line_content": "\t\t\tif (replica.empty() && entry.type == LogEntry::ATTACH_PART)",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": "auto zookeeper = getZooKeeper();\n\n\tString source_path = (entry.attach_unreplicated ? \"unreplicated/\" : \"detached/\") + entry.source",
          "new_api": "replaceParts",
          "old_text": "auto zookeeper = getZooKeeper();\n\n\tString source_path = (entry.attach_unreplicated ? \"unreplicated/\" : \"detached/\") + entry.source",
          "new_text": "ний в ZooKeeper.\n\t\tif (!entry.detach)\n\t\t\tdata.replaceParts({part}, {}, ",
          "old_line_content": "\t\t\t\t\t\t\t\tthrow Exception(\"Logical error: log entry with quorum for part covering more than one block number\",",
          "new_line_content": "\t\t\t\t\t\t\tops.push_back(new zkutil::Op::Remove(quorum_path, quorum_stat.version));",
          "content_same": false
        },
        {
          "line": 1171,
          "old_api": "unreplicated && unreplicated_data)\n\t{\n\t\tMergeTreeData::DataPart",
          "new_api": "loadPartAndFixMetadata",
          "old_text": "unreplicated && unreplicated_data)\n\t{\n\t\tMergeTreeData::DataPart",
          "new_text": "n false;\n\t}\n\n\tLOG_DEBUG(log, \"Checking data\");\n\tMergeTreeData::MutableDataPartPtr part = data.loadPartAndFixMetadata(source_path);\n\n\tzkutil::Ops ops;\n\tcheckPartAndAddToZooKeep",
          "old_line_content": "\t\t\t\t\t\t\tif (zookeeper->exists(zookeeper_path + \"/blocks/\" + entry.block_id))",
          "new_line_content": "\t\t\t\t\t\t\tops.push_back(new zkutil::Op::Create(",
          "content_same": false
        },
        {
          "line": 1178,
          "old_api": "тому что кусок не времен",
          "new_api": "unreplicated && unreplicated_data)\n\t{\n\t\tMergeTreeData::DataPart",
          "old_text": "тому что кусок не времен",
          "new_text": "unreplicated && unreplicated_data)\n\t{\n\t\tMergeTreeData::DataPart",
          "old_line_content": "\t\t\t\t\t\t\tauto code = zookeeper->tryMulti(ops);",
          "new_line_content": "\t\t\t\t\t\t\tif (zookeeper->exists(zookeeper_path + \"/blocks/\" + entry.block_id))",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": "renameTo",
          "new_api": "multi",
          "old_text": "о удалять.\n\tpart->renameTo(entry.new_part_name);\n\tpart->name = entry.new_part_nam",
          "new_text": "ame << \" is already detached\");\n\t}\n\n\tzookeeper->multi(ops);\n\n\t/// NOTE: Не можем исполь",
          "old_line_content": "\t\t\t\t\t\t\t\tLOG_DEBUG(log, \"Marked quorum for part \" << entry.new_part_name << \" as failed.\");",
          "new_line_content": "\t\t\t\t\t\t\t\tops.push_back(new zkutil::Op::Remove(zookeeper_path + \"/blocks/\" + entry.block_id, -1));",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "begin",
          "new_api": "torageReplicate",
          "old_text": " (LogEntries::iterator it = queue.begin(); it != queue.end(); ++it)\n\t\t\t{\n\t\t\t\tif ((*it)->curr",
          "new_text": "torageReplicate",
          "old_line_content": "\t\t\tfetchPart(entry.new_part_name, zookeeper_path + \"/replicas/\" + replica, false, entry.quorum);",
          "new_line_content": "\t\t\t\tif (replica.empty())",
          "content_same": false
        },
        {
          "line": 1213,
          "old_api": "uteLogEntry",
          "new_api": "empty",
          "old_text": "uteLogEntry(**it, (*it)->postpone_reason))\n\t\t\t\t{\n\t\t\t\t\tentry = *it;\n\t\t\t",
          "new_text": "\n\ttry\n\t{\n\t\tstd::lock_guard<std::mutex> lock(queue_mutex);\n\t\tbool empty = queue.empty();\n\t\tif (!",
          "old_line_content": "\t\t\t\tProfileEvents::increment(ProfileEvents::ReplicatedPartFetchesOfMerged);",
          "new_line_content": "\t\t\t\t\tthrow Exception(\"No active replica has part \" + entry.new_part_name, ErrorCodes::NO_REPLICA_HAS_PART);",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": "ботают; не будем писать в",
          "new_api": "success = t",
          "old_text": "ботают; не будем писать в ",
          "new_text": "success = t",
          "old_line_content": "\t\t\t\t\t\t\tparts_for_merge = StringSet((*it)->parts_to_merge.begin(), (*it)->parts_to_merge.end());",
          "new_line_content": "\t\t\t\tfor (LogEntries::iterator it = queue.begin(); it != queue.end(); ++it)",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": "code",
          "new_api": "ботают; не будем писать в",
          "old_text": "code() == ErrorCodes::A",
          "new_text": "ботают; не будем писать в ",
          "old_line_content": "\t\t\t\tif (!parts_for_merge.empty())",
          "new_line_content": "\t\t\t\t\t\t\tparts_for_merge = StringSet((*it)->parts_to_merge.begin(), (*it)->parts_to_merge.end());",
          "content_same": false
        },
        {
          "line": 1263,
          "old_api": "eed_pull = true",
          "new_api": "ание из оче",
          "old_text": "eed_pull = true",
          "new_text": "ание из оче",
          "old_line_content": "\t\t\t\t\tif (replica.empty())",
          "new_line_content": "\t\t\t\t\t\t\tqueue.splice(queue.end(), queue, it0, it);",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": "auto zookeeper = getZooKeeper();\n\n\t\t/// Нельзя сливать куски, ср",
          "new_api": "ft->name ||",
          "old_text": "\t\tauto zookeeper = getZooKeeper();\n\n\t\t/// Нельзя сливать куски, ср",
          "new_text": "ft->name ||",
          "old_line_content": "\t\t\t\tauto code = zookeeper->tryRemove(replica_path + \"/queue/\" + (*it)->znode_name);",
          "new_line_content": "\t\tfor (LogEntries::iterator it = queue.begin(); it != queue.end();)",
          "content_same": false
        },
        {
          "line": 1311,
          "old_api": "о это сделает логику более сложной.",
          "new_api": "td::make_pair(left->name, right->name);\n\t\tif (memoized_parts_that_coul",
          "old_text": "о это сделает логику более сложной.\n\t",
          "new_text": "td::make_pair(left->name, right->name);\n\t\tif (memoized_parts_that_coul",
          "old_line_content": "\t\t\t\t\t\t<< zkutil::ZooKeeper::error2string(code));",
          "new_line_content": "\t\t\t\tActiveDataPartSet::contains(entry.new_part_name, (*it)->new_part_name))",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": "fromString",
          "new_api": "quorum_node_valu",
          "old_text": "atus\", quorum_node_value))\n\t\t{\n\t\t\tReplicatedMergeTreeQuorumEntry quorum_entry;\n\t\t\tquorum_entry.fromString(quorum_node_value);\n\n\t\t\tActiveDataPartSet::Par",
          "new_text": " quorum_node_valu",
          "old_line_content": "\t\tLOG_DEBUG(log, \"Removed \" << removed_entries << \" entries from queue. \"",
          "new_line_content": "\t\t\t\tqueue.erase(it++);",
          "content_same": false
        },
        {
          "line": 1327,
          "old_api": ".left && right->left >= part_info.right)\n\t\t\t\treturn false;\n\t\t}\n\n\t\t///",
          "new_api": "fromString",
          "old_text": ".left && right->left >= part_info.right)\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/// ",
          "new_text": "y.fromString(q",
          "old_line_content": "\tLOG_DEBUG(log, (entry.detach ? \"Detaching\" : \"Removing\") << \" parts.\");",
          "new_line_content": "\t\t\t\"Waiting for \" << to_wait.size() << \" entries that are currently executing.\");",
          "content_same": false
        },
        {
          "line": 1331,
          "old_api": "оответствуют никаки",
          "new_api": "rs more than one block numbers\", ErrorCodes::LOGICAL_ERROR);\n\n\t\t\tif (left->right <= pa",
          "old_text": "оответствуют никаки",
          "new_text": "rs more than one block numbers\", ErrorCodes::LOGICAL_ERROR);\n\n\t\t\tif (left->right <= pa",
          "old_line_content": "\tauto parts = data.getDataParts();",
          "new_line_content": "\t\t\tentry->execution_complete.wait(lock, [&entry] { return !entry->currently_executing; });",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": "RVED_BLOCK_NUMBERS, left->right + 1); number <= right->left",
          "new_api": ".left && right->left >= part_info.right)\n\t\t\t\treturn false;\n\t\t}\n\n\t\t///",
          "old_text": "RVED_BLOCK_NUMBERS, left->right + 1); number <= right->left ",
          "new_text": ".left && right->left >= part_info.right)\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/// ",
          "old_line_content": "\t\tif (!ActiveDataPartSet::contains(entry.new_part_name, part->name))",
          "new_line_content": "\tLOG_DEBUG(log, (entry.detach ? \"Detaching\" : \"Removing\") << \" parts.\");",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": "nZooKeeper::check(path1, *zook",
          "new_api": "RVED_BLOCK_NUMBERS, left->right + 1); number <= right->left",
          "old_text": "nZooKeeper::check(path1, *zook",
          "new_text": "RVED_BLOCK_NUMBERS, left->right + 1); number <= right->left ",
          "old_line_content": "\t\t\tdata.renameAndDetachPart(part);",
          "new_line_content": "\t\tif (!ActiveDataPartSet::contains(entry.new_part_name, part->name))",
          "content_same": false
        },
        {
          "line": 1352,
          "old_api": "false;\n\n\t\ttry\n\t\t{\n\t\t\tstd::lock_guard<std::mutex> merge_selecting_lock(merge_selecting_mutex);\n\n\t\t\tif (need_pull)\n\t\t\t{\n\t\t\t\t/",
          "new_api": "ckInZooKeeper::check(",
          "old_text": "false;\n\n\t\ttry\n\t\t{\n\t\t\tstd::lock_guard<std::mutex> merge_selecting_lock(merge_selecting_mutex);\n\n\t\t\tif (need_pull)\n\t\t\t{\n\t\t\t\t/",
          "new_text": "ckInZooKeeper::check(",
          "old_line_content": "\tLOG_INFO(log, (entry.detach ? \"Detached \" : \"Removed \") << removed_parts << \" parts inside \" << entry.new_part_name << \".\");",
          "new_line_content": "\t\tzookeeper->multi(ops);",
          "content_same": false
        },
        {
          "line": 1371,
          "old_api": "ed = 0;\n\t\t\tsize_t big_merges_queued = 0;",
          "new_api": "ol = context.getBa",
          "old_text": "ed = 0;\n\t\t\tsize_t big_merges_queued = 0;",
          "new_text": "ol = context.getBa",
          "old_line_content": "\tMergeTreeData::MutableDataPartPtr part = data.loadPartAndFixMetadata(source_path);",
          "new_line_content": "\tif (!Poco::File(data.getFullPath() + source_path).exists())",
          "content_same": false
        },
        {
          "line": 1378,
          "old_api": "::MERGE_PARTS)\n\t\t\t\t\t{\n\t\t\t\t\t\t++merges_queued;\n\n\t\t\t\t\t\tif (bi",
          "new_api": "ed = 0;\n\t\t\tsize_t big_merges_queued = 0;",
          "old_text": "::MERGE_PARTS)\n\t\t\t\t\t{\n\t\t\t\t\t\t++merges_queued;\n\n\t\t\t\t\t\tif (bi",
          "new_text": "ed = 0;\n\t\t\tsize_t big_merges_queued = 0;",
          "old_line_content": "\t\tMergeTreeData::DataPartPtr unreplicated_part = unreplicated_data->getPartIfExists(entry.source_part_name);",
          "new_line_content": "\tMergeTreeData::MutableDataPartPtr part = data.loadPartAndFixMetadata(source_path);",
          "content_same": false
        },
        {
          "line": 1385,
          "old_api": "eContainingPart",
          "new_api": "::MERGE_PARTS)\n\t\t\t\t\t{\n\t\t\t\t\t\t++merges_queued;\n\n\t\t\t\t\t\tif (bi",
          "old_text": "eContainingPart(name)",
          "new_text": "::MERGE_PARTS)\n\t\t\t\t\t{\n\t\t\t\t\t\t++merges_queued;\n\n\t\t\t\t\t\tif (bi",
          "old_line_content": "\tzookeeper->multi(ops);",
          "new_line_content": "\t\tMergeTreeData::DataPartPtr unreplicated_part = unreplicated_data->getPartIfExists(entry.source_part_name);",
          "content_same": false
        },
        {
          "line": 1392,
          "old_api": "ges_current || merges",
          "new_api": "eContainingPart",
          "old_text": "ges_current || merges",
          "new_text": "eContainingPart(name)",
          "old_line_content": "\tdata.attachPart(part);",
          "new_line_content": "\tzookeeper->multi(ops);",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": "ax number of big merg",
          "new_api": "ges_queued >= max_number_of_big_merges;\n\n\t\t\tif (big",
          "old_text": "ax number of big merg",
          "new_text": "ges_queued >= max_number_of_big_merges;\n\n\t\t\tif (big",
          "old_line_content": "\tcontext.resetCaches();",
          "new_line_content": "\tActiveDataPartSet::parsePartName(part->name, *part);",
          "content_same": false
        },
        {
          "line": 1412,
          "old_api": "ngs.max_replicated_merges_in",
          "new_api": "small parts to merge.\" : \".\"))",
          "old_text": "ngs.max_replicated_merges_in",
          "new_text": " small parts to merge.\" : \".\"))",
          "old_line_content": "\t\t\tqueue_updating_event->wait();",
          "new_line_content": "\tsetThreadName(\"ReplMTQueueUpd\");",
          "content_same": false
        },
        {
          "line": 1419,
          "old_api": "erges_in_queue (\"\n\t\t\t\t\t\t<< data.settings.ma",
          "new_api": "ngs.max_replicated_merges_in",
          "old_text": "erges_in_queue (\"\n\t\t\t\t\t\t<< data.settings.ma",
          "new_text": "ngs.max_replicated_merges_in",
          "old_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "\t\t\tqueue_updating_event->wait();",
          "content_same": false
        },
        {
          "line": 1457,
          "old_api": "\"Part",
          "new_api": "exists",
          "old_text": " \"Part ",
          "new_text": "ZK, не будем сливать.\n\t\t\t\t\tif (!zookeeper->exists(r",
          "old_line_content": "\t\t\t\t\tentry->last_attempt_time = time(0);",
          "new_line_content": "\t\t\t\tif (shouldExecuteLogEntry(**it, (*it)->postpone_reason))",
          "content_same": false
        },
        {
          "line": 1470,
          "old_api": "locally but not in ZooKeeper.\"\n\t\t\t\t\t\t\t\t<<",
          "new_api": "odifica",
          "old_text": " locally but not in ZooKeeper.\"\n\t\t\t\t\t\t\t\t<< ",
          "new_text": "odifica",
          "old_line_content": "\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "\t\t\t\t\t(*it)->last_postpone_time = time(0);",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": "create",
          "new_api": "LogEntry entry;\n\t\t\t\tentry.type = Lo",
          "old_text": "per->create(zookeeper_path + \"/log/lo",
          "new_text": "\t\tLogEntry entry;\n\t\t\t\tentry.type = Lo",
          "old_line_content": "\t\t\t\t\t\t<< zkutil::ZooKeeper::error2string(code) + \". This shouldn't happen often.\");",
          "new_line_content": "\t\t\tif (executeLogEntry(*entry, pool_context))",
          "content_same": false
        },
        {
          "line": 1498,
          "old_api": "ubstr",
          "new_api": "create",
          "old_text": "ubstr(0, 6);\n\t\t\t\tfor (si",
          "new_text": "per->create(zookeeper_path + \"/log/lo",
          "old_line_content": "\t\t\tsaved_exception = std::current_exception();",
          "new_line_content": "\t\t\t\t\t\t<< zkutil::ZooKeeper::error2string(code) + \". This shouldn't happen often.\");",
          "content_same": false
        },
        {
          "line": 1521,
          "old_api": "CTION__);\n\t\t}\n\n\t\tif (shutdown_called || !is",
          "new_api": "}\n\t\t\t\t}\n\n\t\t\t\tsuccess = true;",
          "old_text": "CTION__);\n\t\t}\n\n\t\tif (shutdown_called || !is",
          "new_text": "\t\t}\n\t\t\t\t}\n\n\t\t\t\tsuccess = true;\n\t",
          "old_line_content": "\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "\t\t\tLOG_INFO(log, \"Merge cancelled\");",
          "content_same": false
        },
        {
          "line": 1584,
          "old_api": "const auto materi",
          "new_api": "FO",
          "old_text": "\n\t\t\t\t\tconst auto materi",
          "new_text": "FO(log, \"Changed version of 'columns' node i",
          "old_line_content": "\t\tString month_name = left->name.substr(0, 6);",
          "new_line_content": "\t\t\tvirtual_parts.getContainingPart(right->name) != right->name)",
          "content_same": false
        },
        {
          "line": 1617,
          "old_api": "int changed_parts = 0;\n\n\t\t\t\t\tif (!changed_",
          "new_api": "ataParts",
          "old_text": "\t\t\t\t\tint changed_parts = 0;\n\n\t\t\t\t\tif (!changed_",
          "new_text": "ataParts();\n\n\t\t\t",
          "old_line_content": "\t\tmemoized_parts_that_could_be_merged.insert(key);",
          "new_line_content": "\t\t\tString path2 = zookeeper_path + \"/nonincrement_block_numbers/\" + month_name + \"/block-\" + padIndex(number);",
          "content_same": false
        },
        {
          "line": 1640,
          "old_api": "+ part->name + \"/checksums\"",
          "new_api": "olumns_plus_mater",
          "old_text": "+ part->name + \"/checksums\"",
          "new_text": "olumns_plus_mater",
          "old_line_content": "\t\t\tauto & background_pool = context.getBackgroundPool();",
          "new_line_content": "\t\t\t\tpullLogsToQueue();",
          "content_same": false
        },
        {
          "line": 1720,
          "old_api": "guard<s",
          "new_api": "getPathCreated",
          "old_text": "guard<s",
          "new_text": "ic_cast<zkutil::Op::Create &>(ops[0]).getPathCreated();\n",
          "old_line_content": "\t\t\t\t\t\t\t\t<< \" with age \" << (time(0) - part->modification_time)",
          "new_line_content": "\t\t\t\t\tif (!zookeeper->exists(replica_path + \"/parts/\" + part->name))",
          "content_same": false
        },
        {
          "line": 1741,
          "old_api": "locally. \"\n\t\t\t\"R",
          "new_api": "го отту",
          "old_text": "locally. \"\n\t\t\t\"R",
          "new_text": "го отту",
          "old_line_content": "\t\t\t\tzookeeper->create(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential);",
          "new_line_content": "\t\t\t\tentry.create_time = time(0);",
          "content_same": false
        },
        {
          "line": 1744,
          "old_api": "rtAndEnqueue",
          "new_api": "exists",
          "old_text": "rtAndEnqueue",
          "new_text": "\tif (zookeeper->exists(part_path))\n\t{\n\t\tLO",
          "old_line_content": "\t\t\t\tfor (size_t i = 0; i + 1 < parts.size(); ++i)",
          "new_line_content": "\t\t\t\t\tentry.parts_to_merge.push_back(part->name);",
          "content_same": false
        },
        {
          "line": 1750,
          "old_api": "или создаст нов",
          "new_api": "ment",
          "old_text": " или создаст нов",
          "new_text": "ment(ProfileEvents::Replica",
          "old_line_content": "\t\t\t\t\t\tzookeeper->tryRemove(zookeeper_path + \"/nonincrement_block_numbers/\" + month_name + \"/block-\" + padIndex(number));",
          "new_line_content": "\t\t\t\tString month_name = parts[0]->name.substr(0, 6);",
          "content_same": false
        },
        {
          "line": 1767,
          "old_api": ", что другие реплики ещё недоделали мердж\n\t\t*   - если",
          "new_api": "крывающего его куска, то\n\t\t*   - если у ког",
          "old_text": ", что другие реплики ещё недоделали мердж\n\t\t*   - если ",
          "new_text": "крывающего его куска, то\n\t\t*   - если у ког",
          "old_line_content": "\t\t\tmerge_selecting_event.tryWait(MERGE_SELECTING_SLEEP_MS);",
          "new_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 1856,
          "old_api": "rement_block_numbers/\" + par",
          "new_api": "substr",
          "old_text": "rement_block_numbers/\" + par",
          "new_text": "ion\");\n\t\treturn;\n\t}\n\n\tconst auto partition_str = part_name.substr(0, 6);\n\tfor",
          "old_line_content": "\t\t\t\t\t\t\tdata.setColumnsList(columns);",
          "new_line_content": "\t\t\t\t\t\tLOG_INFO(log, \"Columns list changed in ZooKeeper. Applying changes locally.\");",
          "content_same": false
        },
        {
          "line": 1884,
          "old_api": "(part->name == part_name)\n\t{\n\t\tauto zookeeper = getZooKeeper();\n\t\tauto table_lock = lockStructure(false)",
          "new_api": "нас есть этот кусок, и он",
          "old_text": "(part->name == part_name)\n\t{\n\t\tauto zookeeper = getZooKeeper();\n\t\tauto table_lock = lockStructure(false)",
          "new_text": " нас есть этот кусок, и он",
          "old_line_content": "\t\t\t\t\t\tLOG_INFO(log, \"Columns version changed in ZooKeeper, but data wasn't changed. It's like cyclic ALTERs.\");",
          "new_line_content": "\t\t\t\t\t\t\tdata.column_defaults = std::move(column_defaults);",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": "s)\n\t\t\t\t\tthrow Excepti",
          "new_api": "cksums, true);\n\n\t\t\t\tauto zk_colu",
          "old_text": "s)\n\t\t\t\t\tthrow Excepti",
          "new_text": "cksums, true);\n\n\t\t\t\tauto zk_colu",
          "old_line_content": "\t\t\t\t\tconst auto columns_plus_materialized = data.getColumnsList();",
          "new_line_content": "\t\t\t\t\t\tLOG_INFO(log, \"ALTER-ing parts\");",
          "content_same": false
        },
        {
          "line": 1913,
          "old_api": "\" << part_name << \" looks good.\");\n\t\t\t}\n\t\t\tcatch (",
          "new_api": "s)\n\t\t\t\t\tthrow Excepti",
          "old_text": " \" << part_name << \" looks good.\");\n\t\t\t}\n\t\t\tcatch (",
          "new_text": "s)\n\t\t\t\t\tthrow Excepti",
          "old_line_content": "\t\t\t\t\t\tauto transaction = data.alterDataPart(part, columns_plus_materialized);",
          "new_line_content": "\t\t\t\t\tconst auto columns_plus_materialized = data.getColumnsList();",
          "content_same": false
        },
        {
          "line": 1929,
          "old_api": "что записал, и еще н",
          "new_api": "ProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);\n\n\t\t\t\tremovePartAndEnqueueFetch(part_name);\n\n\t\t\t\t/// Удалим кусок локально.",
          "old_text": " что записал, и еще н",
          "new_text": "ProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);\n\n\t\t\t\tremovePartAndEnqueueFetch(part_name);\n\n\t\t\t\t/// Удалим кусок локально.",
          "old_line_content": "\t\t\t\t\t\ttransaction->commit();",
          "new_line_content": "\t\t\t\t\t\tops.push_back(new zkutil::Op::SetData(",
          "content_same": false
        },
        {
          "line": 1946,
          "old_api": "modification_time)",
          "new_api": "ndDetachPart",
          "old_text": "modification_time)\n\t\t",
          "new_text": "ndDetachPart(part, \"unexpected_\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLOG_TRACE(lo",
          "old_line_content": "\t\t\t\t\t\t\ttransaction->commit();",
          "new_line_content": "\t\t\t\t\t\t\tauto transaction = unreplicated_data->alterDataPart(part, columns_plus_materialized);",
          "content_same": false
        },
        {
          "line": 1958,
          "old_api": "ave part \" << part->name << \" cove",
          "new_api": "вающий кусок, игнорируем все проблемы с этим куском.",
          "old_text": "ave part \" << part->name << \" cove",
          "new_text": "вающий кусок, игнорируем все проблемы с этим куском.\n\t",
          "old_line_content": "\t\t\t\t\t\t\tLOG_INFO(log, \"No parts ALTER-ed\");",
          "new_line_content": "\t\t\t\t\tzookeeper->set(replica_path + \"/columns\", columns_str);",
          "content_same": false
        },
        {
          "line": 2017,
          "old_api": "ngPart",
          "new_api": "= true;\n\tmerge_selecting_thread = std:",
          "old_text": "ngPart(const String & part_name, bool active)\n{\n\tauto zooke",
          "new_text": " = true;\n\tmerge_selecting_thread = std:",
          "old_line_content": "\t\tString path_created = dynamic_cast<zkutil::Op::Create &>(ops[0]).getPathCreated();",
          "new_line_content": "\tremovePartFromZooKeeper(part_name, ops);",
          "content_same": false
        },
        {
          "line": 2019,
          "old_api": "plicas\");\n\n\t/// Из реплик, у которых есть",
          "new_api": "licatedMergeTree::mer",
          "old_text": "plicas\");\n\n\t/// Из реплик, у которых есть",
          "new_text": "licatedMergeTree::mer",
          "old_line_content": "\t\tlog_entry->addResultToVirtualParts(*this);",
          "new_line_content": "\tauto results = zookeeper->multi(ops);",
          "content_same": false
        },
        {
          "line": 2039,
          "old_api": "осле возврата",
          "new_api": "s",
          "old_text": "осле возврата ",
          "new_text": "s(zookeeper_path + \"/replicas/\"",
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "\tparts_to_check_set.insert(name);",
          "content_same": false
        },
        {
          "line": 2074,
          "old_api": "nue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow zkutil::KeeperException(",
          "new_api": ");\n\n\t\t\tif (code == ZOK)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (code == ZNONODE)\n\t\t\t{\n\t\t\t\t///",
          "old_text": "nue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow zkutil::KeeperException(",
          "new_text": ");\n\n\t\t\tif (code == ZOK)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (code == ZNONODE)\n\t\t\t{\n\t\t\t\t///",
          "old_line_content": "\tStrings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "new_line_content": "\tLOG_WARNING(log, \"Checker: Checking if anyone has part covering \" << part_name << \".\");",
          "content_same": false
        },
        {
          "line": 2087,
          "old_api": "get",
          "new_api": "g part \" << part_name << \" from \" << replica_path);\n\n\tT",
          "old_text": "per->get(replica_path + \"/host\"));\n\n\tMergeTreeData::Mut",
          "new_text": "g part \" << part_name << \" from \" << replica_path);\n\n\tT",
          "old_line_content": "\t\t\tif (ActiveDataPartSet::contains(part_name, part_on_replica))",
          "new_line_content": "\t\t\tif (part_on_replica == part_name || ActiveDataPartSet::contains(part_on_replica, part_name))",
          "content_same": false
        },
        {
          "line": 2090,
          "old_api": "ath, address.host, address.replication_port, to_detached);\n\n\tif (!to_de",
          "new_api": "e_lock;\n\tif (!to_detached)\n\t\ttable_lock = lockStructure(true);\n\n\tReplicatedMerge",
          "old_text": "ath, address.host, address.replication_port, to_detached);\n\n\tif (!to_de",
          "new_text": "e_lock;\n\tif (!to_detached)\n\t\ttable_lock = lockStructure(true);\n\n\tReplicatedMerge",
          "old_line_content": "\t\t\t\tActiveDataPartSet::parsePartName(part_on_replica, part_on_replica_info);",
          "new_line_content": "\t\t\t\tLOG_WARNING(log, \"Checker: Found part \" << part_on_replica << \" on \" << replica);",
          "content_same": false
        },
        {
          "line": 2131,
          "old_api": "gs,\n\tQueryP",
          "new_api": "reset",
          "old_text": "gs,\n\tQueryP",
          "new_text": "stop();\n\t\trestarting_thread.reset();\n\t}\n\n\tendpoint_holder = nullptr",
          "old_line_content": "\t\tfor (LogEntries::iterator it = queue.begin(); it != queue.end();)",
          "new_line_content": "\tProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);",
          "content_same": false
        },
        {
          "line": 2154,
          "old_api": "uery &>(*query);\n\n\t/// Try transferring some condition from WHERE to",
          "new_api": "ность использовать \"виртуальные столбцы\".\n\t  * Один из них - _replicated позволя",
          "old_text": "uery &>(*query);\n\n\t/// Try transferring some condition from WHERE to",
          "new_text": "ность использовать \"виртуальные столбцы\".\n\t  * Один из них - _replicated позволя",
          "old_line_content": "\tLOG_ERROR(log, \"Checker: Part \" << part_name << \" is lost forever.\");",
          "new_line_content": "\t\tLOG_ERROR(log, \"Checker: Missing part \" << part_name << \" is not in our queue.\");",
          "content_same": false
        },
        {
          "line": 2186,
          "old_api": "nt8>(stream, new DataTypeUInt8, 0, \"_replicated\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (values.coun",
          "new_api": "max_block_size, threads, &part_index, 0);\n\n\t\tfor (auto & virtual_column : virt_column_names)",
          "old_text": "nt8>(stream, new DataTypeUInt8, 0, \"_replicated\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (values.coun",
          "new_text": "\tmax_block_size, threads, &part_index, 0);\n\n\t\tfor (auto & virtual_column : virt_column_names)\n\t\t",
          "old_line_content": "\t\tzookeeper->createIfNotExists(zookeeper_path + \"/nonincrement_block_numbers\", \"\");",
          "new_line_content": "\t\tLOG_ERROR(log, \"Won't add nonincrement_block_numbers because part is one of first in partition\");",
          "content_same": false
        },
        {
          "line": 2205,
          "old_api": "е реплики при распределённых за",
          "new_api": "{\n\t\t\tauto zookeeper = getZooKeeper();\n\t\t\tString last_part;",
          "old_text": "е реплики при распределённых за",
          "new_text": "\t{\n\t\t\tauto zookeeper = getZooKeeper();\n\t\t\tString last_part;\n\t",
          "old_line_content": "\t\tsearchForMissingPart(part_name);",
          "new_line_content": "\tProfileEvents::increment(ProfileEvents::ReplicatedPartChecks);",
          "content_same": false
        },
        {
          "line": 2221,
          "old_api": "_read = part_info.left - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tActiveDataP",
          "new_api": "licatedMergeTreeQuorumEntry quorum_entry;\n\t\t\t\t\tquorum_e",
          "old_text": "_read = part_info.left - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tActiveDataP",
          "new_text": "licatedMergeTreeQuorumEntry quorum_entry;\n\t\t\t\t\tquorum_e",
          "old_line_content": "\t\t\t\t\tzookeeper->get(replica_path + \"/parts/\" + part_name + \"/checksums\"));",
          "new_line_content": "\t\tif (zookeeper->exists(replica_path + \"/parts/\" + part_name))",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": "d_stage, max_block_size, threads, &part_index, max_block_number_to_read);\n\n\t\tfor",
          "new_api": ".part_name, part_info);\n\t\t\t\t\tmax_block_number_to_read = part_info.left - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tActiveDataPa",
          "old_text": "d_stage, max_block_size, threads, &part_index, max_block_number_to_read);\n\n\t\tfor ",
          "new_text": ".part_name, part_info);\n\t\t\t\t\tmax_block_number_to_read = part_info.left - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tActiveDataPa",
          "old_line_content": "\t\t\t\t\tthrow Exception(\"Columns of local part \" + part_name + \" are different from ZooKeeper\");",
          "new_line_content": "\t\t\t\tauto zk_checksums = MergeTreeData::DataPart::Checksums::parse(",
          "content_same": false
        },
        {
          "line": 2231,
          "old_api": "tream : res2)\n\t\t\t\t\tstream = new Ad",
          "new_api": "read",
          "old_text": "tream : res2)\n\t\t\t\t\tstream = new Ad",
          "new_text": "nfo);\n\t\t\t\tmax_block_number_to_read = part_info.right;\n\t\t\t}\n\t\t}\n\n\t\tauto res2 = reader.read(\n\t\t\trea",
          "old_line_content": "\t\t\t\tsettings.setRequireChecksums(true);",
          "new_line_content": "\t\t\t\tauto zk_columns = NamesAndTypesList::parse(",
          "content_same": false
        },
        {
          "line": 2232,
          "old_api": "nstColumnBlockInputStream<UInt8>(str",
          "new_api": "read",
          "old_text": "nstColumnBlockInputStream<UInt8>(str",
          "new_text": "ead = part_info.right;\n\t\t\t}\n\t\t}\n\n\t\tauto res2 = reader.read(\n\t\t\tre",
          "old_line_content": "\t\t\t\tsettings.setRequireColumnFiles(true);",
          "new_line_content": "\t\t\t\t\tzookeeper->get(replica_path + \"/parts/\" + part_name + \"/columns\"));",
          "content_same": false
        },
        {
          "line": 2234,
          "old_api": "insert",
          "new_api": "d_stage, max_block_size, threads, &part_index, max_block_number_to_read);\n\n\t\tfor",
          "old_text": "\t\t}\n\n\t\tres.insert(",
          "new_text": "d_stage, max_block_size, threads, &part_index, max_block_number_to_read);\n\n\t\tfor ",
          "old_line_content": "\t\t\t\t\tdata.getFullPath() + part_name, settings, data.primary_key_data_types);",
          "new_line_content": "\t\t\t\t\tthrow Exception(\"Columns of local part \" + part_name + \" are different from ZooKeeper\");",
          "content_same": false
        },
        {
          "line": 2240,
          "old_api": "s)\n{\n\tif (is_readonly)\n\t\tthrow Exception(\"T",
          "new_api": "insert",
          "old_text": "s)\n{\n\tif (is_readonly)\n\t\tthrow Exception(\"T",
          "new_text": "ew DataTypeUInt8, 1, \"_replicated\");\n\t\t\t}\n\t\t}\n\n\t\tres.insert(res.end(), res2.begin(), res2.end());\n\t}\n\n\treturn re",
          "old_line_content": "\t\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "\t\t\t\tMergeTreePartChecker::checkDataPart(",
          "content_same": false
        },
        {
          "line": 2243,
          "old_api": "* insert = typeid_cast<ASTInsertQuery *>(&*query))\n\t\t\tinsert_id =",
          "new_api": "BlockOutputStreamPtr StorageReplicatedMergeTree::write(ASTPtr",
          "old_text": " * insert = typeid_cast<ASTInsertQuery *>(&*query))\n\t\t\tinsert_id = ",
          "new_text": "BlockOutputStreamPtr StorageReplicatedMergeTree::write(ASTPtr ",
          "old_line_content": "\t\t\t\tProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);",
          "new_line_content": "\t\t\t\tLOG_INFO(log, \"Checker: Part \" << part_name << \" looks good.\");",
          "content_same": false
        },
        {
          "line": 2258,
          "old_api": "rged_name, 0, true, true, false, always_can_merge))\n\t\treturn false;\n\n\tconst auto & merg",
          "new_api": "ated.",
          "old_text": "rged_name, 0, true, true, false, always_can_merge))\n\t\treturn false;\n\n\tconst auto & merg",
          "new_text": "ated.\n\t",
          "old_line_content": "\t\t\tLOG_ERROR(log, \"Checker: Unexpected part \" << part_name << \" in filesystem. Removing.\");",
          "new_line_content": "\t\telse if (part->modification_time + MAX_AGE_OF_LOCAL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < time(0))",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": "mergeParts",
          "new_api": "selectPartsToMerge",
          "old_text": "ged_name);\n\tunreplicated_merger->mergeParts(parts, merged_name, *merge_entry, settings.min_bytes_to_use_direct_io);\n\n\treturn true;\n}\n\n\nvoid StorageReplicatedMergeTree::alter",
          "new_text": "{ return true; };\n\tif (!unreplicated_merger->selectPartsToMerge(par",
          "old_line_content": "\t\t\tLOG_TRACE(log, \"Checker: Young part \" << part_name",
          "new_line_content": "\t\t\tProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": "_column_defaults;\n\tString new_co",
          "new_api": ", \"Doing ALTER\");\n\n\tNamesAndTypesList new_columns;\n\tNamesAndTypesList new_materialized_col",
          "old_text": "_column_defaults;\n\tString new_co",
          "new_text": ", \"Doing ALTER\");\n\n\tNamesAndTypesList new_columns;\n\tNamesAndTypesList new_materialized_col",
          "old_line_content": "\tsetThreadName(\"ReplMTPartCheck\");",
          "new_line_content": "\t\tLOG_WARNING(log, \"Checker: We have part \" << part->name << \" covering part \" << part_name);",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": "ting for replicas to apply changes.\");\n\n\t/// Ждем, пока все реплики обновят данные.\n\n\t/",
          "new_api": "ns,\n\t\t\tnew_alias_col",
          "old_text": "ting for replicas to apply changes.\");\n\n\t/// Ждем, пока все реплики обновят данные.\n\n\t/",
          "new_text": "ns,\n\t\t\tnew_alias_col",
          "old_line_content": "\t\t\t\t\tLOG_ERROR(log, \"Checker: Someone changed parts_to_check_queue.front(). This is a bug.\");",
          "new_line_content": "\t\t\tcheckPart(part_name);",
          "content_same": false
        },
        {
          "line": 2321,
          "old_api": "о-то еще сделает ALTER.\n\tif (!zooke",
          "new_api": "}\n\n\tLOG_DEBUG(log, \"Updated",
          "old_text": "о-то еще сделает ALTER.\n\tif (!zooke",
          "new_text": "\t}\n\n\tLOG_DEBUG(log, \"Updated",
          "old_line_content": "\t\t\t\t\tparts_to_check_set.erase(part_name);",
          "new_line_content": "\t\t\t\tif (parts_to_check_queue.empty() || parts_to_check_queue.front() != part_name)",
          "content_same": false
        },
        {
          "line": 2327,
          "old_api": "s\", &stat, alter_query_event))\n\t\tthrow Exce",
          "new_api": "толбцов, чтобы перестать ждать,",
          "old_text": "s\", &stat, alter_query_event))\n\t\tthrow Exce",
          "new_text": "толбцов, чтобы перестать ждать, ",
          "old_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "\t\t\t\t\tparts_to_check_queue.pop_front();",
          "content_same": false
        },
        {
          "line": 2328,
          "old_api": "(zookeeper_path + \"/columns doesn't exist\",",
          "new_api": "о-то еще сделает ALTER.\n\tif (!zooke",
          "old_text": "(zookeeper_path + \"/columns doesn't exist\", ",
          "new_text": "о-то еще сделает ALTER.\n\tif (!zooke",
          "old_line_content": "\t\t\tparts_to_check_event.tryWait(ERROR_SLEEP_MS);",
          "new_line_content": "\t\t\t\t\tparts_to_check_set.erase(part_name);",
          "content_same": false
        },
        {
          "line": 2345,
          "old_api": "LOG_DEBUG",
          "new_api": "finished; \"\n\t\t\t\"overlapping ALTER-s are fine but use caution with n",
          "old_text": "LOG_DEBUG(log, \"Waiting for \" << replica << \" to app",
          "new_text": " finished; \"\n\t\t\t\"overlapping ALTER-s are fine but use caution with n",
          "old_line_content": "\tStrings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "new_line_content": "\tmerge_selecting_thread = std::thread(&StorageReplicatedMergeTree::mergeSelectingThread, this);",
          "content_same": false
        },
        {
          "line": 2352,
          "old_api": "{\n\t\t\t\tLOG_WARNING(log, replica << \" was removed\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint repli",
          "new_api": "LOG_DEBUG",
          "old_text": "\t\t{\n\t\t\t\tLOG_WARNING(log, replica << \" was removed\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint repli",
          "new_text": "LOG_DEBUG(log, \"Waiting for \" << replica << \" to app",
          "old_line_content": "\t\tif (zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/parts/\" + part_name) &&",
          "new_line_content": "\tStrings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": "k = lockStructure(true);\n\n\tconst DayNum_t month = MergeTreeData::getMon",
          "new_api": "catedMergeTree::dropUnreplicatedPartition(",
          "old_text": "k = lockStructure(true);\n\n\tconst DayNum_t month = MergeTreeData::getMon",
          "new_text": "catedMergeTree::dropUnreplicatedPartition(",
          "old_line_content": "\t\t\tops.push_back(new zkutil::Op::Remove(quorum_status_path, stat.version));",
          "new_line_content": "\t\tquorum_entry.replicas.insert(replica_name);",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": "getDataParts",
          "new_api": "ld & partition, const bool d",
          "old_text": "ta->getDataParts();\n\n\tfo",
          "new_text": "ld & partition, const bool d",
          "old_line_content": "\t\t\tauto code = zookeeper->tryMulti(ops);",
          "new_line_content": "\t\tif (quorum_entry.replicas.size() >= quorum_entry.required_number_of_replicas)",
          "content_same": false
        },
        {
          "line": 2460,
          "old_api": "вателя default без пароля. Можно исправить с пом",
          "new_api": "clone",
          "old_text": "вателя default без пароля. Можно исправить с пом",
          "new_text": " new_query = query->clone();\n\t\tauto & ",
          "old_line_content": "\t\tcheckPartAndAddToZooKeeper(part, ops, part_name);",
          "new_line_content": "\tReplicatedMergeTreeAddress address(zookeeper->get(replica_path + \"/host\"));",
          "content_same": false
        },
        {
          "line": 2472,
          "old_api": "* Инвариант: в логе не",
          "new_api": "ader_address.database",
          "old_text": " * Инвариант: в логе не",
          "new_text": "ader_address.database",
          "old_line_content": "\t\t\tupdateQuorum(part_name);",
          "new_line_content": "\t\tzookeeper->multi(ops);",
          "content_same": false
        },
        {
          "line": 2479,
          "old_api": "антировать этот инвариант.\n\t  */\n\tInt64 right;\n\n\t{\n\t\tAbandonable",
          "new_api": "* Инвариант: в логе не",
          "old_text": "антировать этот инвариант.\n\t  */\n\tInt64 right;\n\n\t{\n\t\tAbandonable",
          "new_text": " * Инвариант: в логе не",
          "old_line_content": "\t\t\tProfileEvents::increment(ProfileEvents::ObsoleteReplicatedParts);",
          "new_line_content": "\t\t\tupdateQuorum(part_name);",
          "content_same": false
        },
        {
          "line": 2561,
          "old_api": "вуют и не испорчены хотя бы на этой реплике. Запишем checksums.txt, если его нет.\n\tLOG_DEBUG",
          "new_api": "name",
          "old_text": "вуют и не испорчены хотя бы на этой реплике. Запишем checksums.txt, если его нет.\n\tLOG_DEBUG",
          "new_text": " it.name();\n\t\t\tif",
          "old_line_content": "\tstd::multiset<UInt8> values = VirtualColumnUtils::extractSingleValueFromBlock<UInt8>(virtual_columns_block, \"_replicated\");",
          "new_line_content": "\tcolumn->getData()[1] = 1;",
          "content_same": false
        },
        {
          "line": 2610,
          "old_api": "_INFO",
          "new_api": "getPathCreated",
          "old_text": "_INFO(log, \"Removing replica \" << replica_path);\n\treplica_is_act",
          "new_text": "s[i]).getPathCreated();\n\t\t\tentr",
          "old_line_content": "\t\t\t\tif (zookeeper->tryGet(zookeeper_path + \"/quorum/status\", quorum_str))",
          "new_line_content": "\t\t\tif (!last_part.empty() && !data.getPartIfExists(last_part))\t/// TODO Отключение реплики при распределённых запросах.",
          "content_same": false
        },
        {
          "line": 2622,
          "old_api": "le \" << zookeeper_path << \" (this might take several m",
          "new_api": "а после выполнения предыдущей строки.\n\tStrings replicas;\n\tif (zooke",
          "old_text": "le \" << zookeeper_path << \" (this might take several m",
          "new_text": "а после выполнения предыдущей строки.\n\tStrings replicas;\n\tif (zooke",
          "old_line_content": "\t\t\t\tActiveDataPartSet::parsePartName(last_part, part_info);",
          "new_line_content": "\t\t\t\t\tActiveDataPartSet::parsePartName(quorum_entry.part_name, part_info);",
          "content_same": false
        },
        {
          "line": 2711,
          "old_api": "номера у одного и того же элемента",
          "new_api": "* 2. Из директории queu",
          "old_text": " номера у одного и того же элемента ",
          "new_text": "* 2. Из директории queu",
          "old_line_content": "\t\tnew_columns = data.getColumnsListNonMaterialized();",
          "new_line_content": "\t\tauto table_lock = lockStructureForAlter();",
          "content_same": false
        },
        {
          "line": 2753,
          "old_api": "ound = false;\n\n\t\tfor (const String & log_entry_name : log_entries)\n\t\t{\n\t\t\tlog_index = parse<UInt64>",
          "new_api": "get",
          "old_text": "ound = false;\n\n\t\tfor (const String & log_entry_name : log_entries)\n\t\t{\n\t\t\tlog_index = parse<UInt64>",
          "new_text": "tring log_pointer = zookeeper->get(zookeeper_path + \"/replicas/\"",
          "old_line_content": "\t\t\tif (!zookeeper->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/columns\", replica_columns_str, &stat))",
          "new_line_content": "\t\tLOG_DEBUG(log, \"Waiting for \" << replica << \" to apply changes\");",
          "content_same": false
        },
        {
          "line": 2776,
          "old_api": "licas/\" + replica + \"/log_pointer\", nullptr",
          "new_api": "(found)\n\t\t{\n\t\t\tLOG_DEBUG(log, \"Waiting for \" << replica << \" to pull \" << log_node_name << \" to queue\");\n\n\t\t\t/// Дождемся, пока запись попадет в очередь реп",
          "old_text": "licas/\" + replica + \"/log_pointer\", nullptr",
          "new_text": "(found)\n\t\t{\n\t\t\tLOG_DEBUG(log, \"Waiting for \" << replica << \" to pull \" << log_node_name << \" to queue\");\n\n\t\t\t/// Дождемся, пока запись попадет в очередь реп",
          "old_line_content": "\t\t\t\tLOG_WARNING(log, replica << \" was removed\");",
          "new_line_content": "\t\t\t\tLOG_WARNING(log, zookeeper_path + \"/columns changed before ALTER finished; \"",
          "content_same": false
        },
        {
          "line": 2783,
          "old_api": "break;\n\n\t\t\t\tevent->wait",
          "new_api": "licas/\" + replica + \"/log_pointer\", nullptr",
          "old_text": "\t\tbreak;\n\n\t\t\t\tevent->wait",
          "new_text": "licas/\" + replica + \"/log_pointer\", nullptr",
          "old_line_content": "\t\t\talter_query_event->wait();",
          "new_line_content": "\t\t\t\tLOG_WARNING(log, replica << \" was removed\");",
          "content_same": false
        },
        {
          "line": 2790,
          "old_api": "cal error: unexpected name of lo",
          "new_api": "break;\n\n\t\t\t\tevent->wait",
          "old_text": "cal error: unexpected name of lo",
          "new_text": "\t\tbreak;\n\n\t\t\t\tevent->wait",
          "old_line_content": "\tLOG_DEBUG(log, \"ALTER finished\");",
          "new_line_content": "\t\t\talter_query_event->wait();",
          "content_same": false
        },
        {
          "line": 2828,
          "old_api": "ock_guard<std::mutex> lock(queue_mutex);\n\t\tres.future_parts",
          "new_api": "der_node;\n\tres.is_readonly = is_r",
          "old_text": "ock_guard<std::mutex> lock(queue_mutex);\n\t\tres.future_parts",
          "new_text": "der_node;\n\tres.is_readonly = is_r",
          "old_line_content": "\t\tLOG_DEBUG(log, \"Removing unreplicated part \" << part->name);",
          "new_line_content": "\tMergeTreeData::DataParts parts = unreplicated_data->getDataParts();",
          "content_same": false
        },
        {
          "line": 2856,
          "old_api": "f (entry->type == LogEntry::MERGE_PARTS)\n\t\t\t{\n\t\t\t\t++res.mer",
          "new_api": "time || entry-",
          "old_text": "f (entry->type == LogEntry::MERGE_PARTS)\n\t\t\t{\n\t\t\t\t++res.mer",
          "new_text": "time || entry-",
          "old_line_content": "\t\tauto live_replicas = zookeeper->getChildren(zookeeper_path + \"/leader_election\");",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2857,
          "old_api": "ueue;\n\n\t\t\t\tif (entry-",
          "new_api": "rts_oldest_time))\n\t\t\t\t{\n\t\t\t\t\tres.i",
          "old_text": "ueue;\n\n\t\t\t\tif (entry-",
          "new_text": "rts_oldest_time))\n\t\t\t\t{\n\t\t\t\t\tres.i",
          "old_line_content": "\t\tif (live_replicas.empty())",
          "new_line_content": "\tString month_name = MergeTreeData::getMonthName(field);",
          "content_same": false
        },
        {
          "line": 2864,
          "old_api": "size",
          "new_api": "ueue;\n\n\t\t\t\tif (entry-",
          "old_text": "_mutex);\n\t\tres.parts_to_check = parts_to_check_set.size();\n\t}\n\n\tres.zookeeper_path = zooke",
          "new_text": "ueue;\n\n\t\t\t\tif (entry-",
          "old_line_content": "\t\t\tthrow Exception(\"Leader was suddenly changed or logical error.\", ErrorCodes::LEADERSHIP_CHANGED);",
          "new_line_content": "\t\tif (live_replicas.empty())",
          "content_same": false
        },
        {
          "line": 2868,
          "old_api": "ssion_expired",
          "new_api": "}\n\t\t}\n\t}\n\n\t{\n\t\tstd:",
          "old_text": "ssion_expired ",
          "new_text": "\t\t}\n\t\t}\n\t}\n\n\t{\n\t\tstd:",
          "old_line_content": "\t\tauto new_query = query->clone();",
          "new_line_content": "\t\tconst auto leader = zookeeper->get(zookeeper_path + \"/leader_election/\" + live_replicas.front());",
          "content_same": false
        },
        {
          "line": 2905,
          "old_api": "back",
          "new_api": "}\n\n\nvoid StorageReplicatedMerg",
          "old_text": "nthName(partition);\n\n\tString from = from_;\n\tif (from.back() == '/')\n\t\tfrom.resize(from.siz",
          "new_text": "\n}\n\n\nvoid StorageReplicatedMerg",
          "old_line_content": "\t\tthrow Exception(\"Logical error: just allocated block number is zero\", ErrorCodes::LOGICAL_ERROR);",
          "new_line_content": "\t\tAbandonableLockInZooKeeper block_number_lock = allocateBlockNumber(month_name);",
          "content_same": false
        },
        {
          "line": 2933,
          "old_api": "было бы неплохо уметь выбирать реплику, ближайшую по",
          "new_api": "Exception",
          "old_text": "было бы неплохо уметь выбирать реплику, ближайшую по",
          "new_text": "Exception(\"No active replicas fo",
          "old_line_content": "\t\t\twaitForReplicaToProcessLogEntry(replica_name, entry);",
          "new_line_content": "\tentry.znode_name = log_znode_path.substr(log_znode_path.find_last_of('/') + 1);",
          "content_same": false
        },
        {
          "line": 2942,
          "old_api": "e_replicas)\n\t{",
          "new_api": "NOTE Разумеется, здесь есть data race-ы. М",
          "old_text": "e_replicas)\n\t{",
          "new_text": "NOTE Разумеется, здесь есть data race-ы. М",
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "\t\t\twaitForAllReplicasToProcessLogEntry(entry);",
          "content_same": false
        },
        {
          "line": 2967,
          "old_api": "ve_replicas.size",
          "new_api": "pointer\n\t\t\t|| (log_pointer == max_log_pointer && queue_size < min_queue_size))\n\t\t{\n\t\t\tm",
          "old_text": "ve_replicas.size",
          "new_text": "pointer\n\t\t\t|| (log_pointer == max_log_pointer && queue_size < min_queue_size))\n\t\t{\n\t\t\tm",
          "old_line_content": "\t\t\tif (0 != name.compare(0, partition.size(), partition))",
          "new_line_content": "\t\tLOG_DEBUG(log, \"Looking for parts for partition \" << partition << \" in \" << source_dir);",
          "content_same": false
        },
        {
          "line": 2969,
          "old_api": "<< \" Selected \" << best_replica << \"",
          "new_api": "hrow Exception(\"Logical e",
          "old_text": "<< \" Selected \" << best_replica << \" ",
          "new_text": "hrow Exception(\"Logical e",
          "old_line_content": "\t\t\tLOG_DEBUG(log, \"Found part \" << name);",
          "new_line_content": "\t\tfor (Poco::DirectoryIterator it = Poco::DirectoryIterator(full_path + source_dir); it != Poco::DirectoryIterator(); ++it)",
          "content_same": false
        },
        {
          "line": 2972,
          "old_api": "m + \"/replicas/\" +",
          "new_api": "LOGICAL_ERROR);\n\n\tLOG_INFO(log, \"Found \"",
          "old_text": "m + \"/replicas/\" + ",
          "new_text": "LOGICAL_ERROR);\n\n\tLOG_INFO(log, \"Found \"",
          "old_line_content": "\t\tLOG_DEBUG(log, active_parts.size() << \" of them are active\");",
          "new_line_content": "\t\t\tif (!ActiveDataPartSet::isPartDirectory(name))",
          "content_same": false
        },
        {
          "line": 2977,
          "old_api": "LOG_INFO(log, \"Some of parts",
          "new_api": "tch from.\");\n\n\tString",
          "old_text": "\n\t\t\tLOG_INFO(log, \"Some of parts",
          "new_text": "tch from.\");\n\n\tString ",
          "old_line_content": "\tLOG_DEBUG(log, \"Checking parts\");",
          "new_line_content": "\t\t\tactive_parts.add(name);",
          "content_same": false
        },
        {
          "line": 2980,
          "old_api": "ing. Will try to fetch covering parts.\")",
          "new_api": "ки есть на лучшей репли",
          "old_text": "ing. Will try to fetch covering parts.\")",
          "new_text": "ки есть на лучшей репли",
          "old_line_content": "\t\tLOG_DEBUG(log, \"Checking part \" << part);",
          "new_line_content": "\t\tparts = active_parts.getParts();",
          "content_same": false
        },
        {
          "line": 2987,
          "old_api": "etch_partition.push_ba",
          "new_api": "ing. Will try to fetch covering parts.\")",
          "old_text": "etch_partition.push_ba",
          "new_text": "ing. Will try to fetch covering parts.\")",
          "old_line_content": "\tDayNum_t month = DateLUT::instance().makeDayNum(parse<UInt16>(partition.substr(0, 4)), parse<UInt8>(partition.substr(4, 2)), 0);",
          "new_line_content": "\t\tLOG_DEBUG(log, \"Checking part \" << part);",
          "content_same": false
        },
        {
          "line": 2997,
          "old_api": "ring & miss",
          "new_api": ":move(parts_to_fetc",
          "old_text": "ring & miss",
          "new_text": ":move(parts_to_fetc",
          "old_line_content": "\tstd::reverse(parts.begin(), parts.end());",
          "new_line_content": "\t\tauto existing_parts = data.getDataParts();",
          "content_same": false
        },
        {
          "line": 3010,
          "old_api": "fetchPart(",
          "new_api": "empty",
          "old_text": "\t\t\t\tfetchPart(",
          "new_text": "g_part.empty())\n\t\t\t\t\tparts_to_fetch.push_back(con",
          "old_line_content": "\t\tLogEntry & entry = entries.back();",
          "new_line_content": "\t\tActiveDataPartSet::parsePartName(part_name, part);",
          "content_same": false
        },
        {
          "line": 3016,
          "old_api": "back",
          "new_api": "ing & part : parts_to_",
          "old_text": "back(pa",
          "new_text": "ing & part : parts_to_",
          "old_line_content": "\t\tentry.create_time = time(0);",
          "new_line_content": "\t\tentries.emplace_back();",
          "content_same": false
        },
        {
          "line": 3023,
          "old_api": "ательно месяц - можно",
          "new_api": "back",
          "old_text": "ательно месяц - можно",
          "new_text": "back(pa",
          "old_line_content": "\tzookeeper->multi(ops);",
          "new_line_content": "\t\tentry.create_time = time(0);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2050,
          "old_api": null,
          "new_api": "r",
          "old_text": null,
          "new_text": "r();\n\n\t/// Информация, на ка",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\tif (zookeeper->exists(part_path))",
          "content_same": false
        },
        {
          "line": 2052,
          "old_api": null,
          "new_api": "лики был добавлен кусок, если кворум ещё не достигнут.\n\tconst String quorum_status_path = zookeeper_path + \"/quorum/status\";\n\t/// Имя предыдущ",
          "old_text": null,
          "new_text": "лики был добавлен кусок, если кворум ещё не достигнут.\n\tconst String quorum_status_path = zookeeper_path + \"/quorum/status\";\n\t/// Имя предыдущ",
          "old_line_content": "",
          "new_line_content": "\t\tLOG_WARNING(log, \"Checker: Part \" << part_name << \" exists in ZooKeeper but not locally. \"",
          "content_same": false
        },
        {
          "line": 2054,
          "old_api": null,
          "new_api": "куска, для которого был достигнут кворум.\n\tconst String quorum_last",
          "old_text": null,
          "new_text": "куска, для которого был достигнут кворум.\n\tconst String quorum_last",
          "old_line_content": "\tActiveDataPartSet::Part part_info;",
          "new_line_content": "\t\tProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);",
          "content_same": false
        },
        {
          "line": 2056,
          "old_api": null,
          "new_api": "_path = zookeeper_path + \"/quorum/la",
          "old_text": null,
          "new_text": "_path = zookeeper_path + \"/quorum/la",
          "old_line_content": "",
          "new_line_content": "\t\tremovePartAndEnqueueFetch(part_name);",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": null,
          "new_api": "tryGet",
          "old_text": null,
          "new_text": "zookeeper->tryGet(quorum_status_path, value, &stat))\n\t",
          "old_line_content": "\t\t*   - если у кого-то есть все составляющие куски, то ничего делать не будем - это просто значит, что другие реплики ещё недоделали мердж",
          "new_line_content": "\tActiveDataPartSet::parsePartName(part_name, part_info);",
          "content_same": false
        },
        {
          "line": 2081,
          "old_api": null,
          "new_api": "nue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow zkutil::KeeperException(",
          "old_text": null,
          "new_text": "nue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow zkutil::KeeperException(",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\tStrings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "content_same": false
        },
        {
          "line": 2084,
          "old_api": null,
          "new_api": "eTree::fetchPart(const String & part_name, const String & replica_path, bo",
          "old_text": null,
          "new_text": "eTree::fetchPart(const String & part_name, const String & replica_path, bo",
          "old_line_content": "\t\t\t\tbreak;",
          "new_line_content": "\t\tStrings parts = zookeeper->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/parts\");",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "per->get(replica_path + \"/host\"));\n\n\tMergeTreeData::Mut",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\tif (ActiveDataPartSet::contains(part_name, part_on_replica))",
          "content_same": false
        },
        {
          "line": 2097,
          "old_api": null,
          "new_api": "ath, address.host, address.replication_port, to_detached);\n\n\tif (!to_de",
          "old_text": null,
          "new_text": "ath, address.host, address.replication_port, to_detached);\n\n\tif (!to_de",
          "old_line_content": "\t\t\tbreak;",
          "new_line_content": "\t\t\t\tActiveDataPartSet::parsePartName(part_on_replica, part_on_replica_info);",
          "content_same": false
        },
        {
          "line": 2100,
          "old_api": null,
          "new_api": "nsaction;\n\t\tauto removed_parts = data.renam",
          "old_text": null,
          "new_text": "nsaction;\n\t\tauto removed_parts = data.renam",
          "old_line_content": "\tif (found)",
          "new_line_content": "\t\t\t\t\tfound_blocks.at(block_num - part_info.left) = 1;",
          "content_same": false
        },
        {
          "line": 2120,
          "old_api": null,
          "new_api": "getFullPath",
          "old_text": null,
          "new_text": "teReplicatedParts);\n\t\t}\n\t}\n\telse\n\t{\n\t\tPoco::File(data.getFullPath() + \"detached/tmp_\" + part_nam",
          "old_line_content": "\tif (num_found_blocks != 0)",
          "new_line_content": "\t\tLOG_WARNING(log, \"Checker: Found all blocks for missing part. Will wait for them to be merged.\");",
          "content_same": false
        },
        {
          "line": 2125,
          "old_api": null,
          "new_api": "Events::increment(ProfileEvents::ReplicatedPartFetches);\n\n\tLOG_DEBUG(",
          "old_text": null,
          "new_text": "Events::increment(ProfileEvents::ReplicatedPartFetches);\n\n\tLOG_DEBUG(",
          "old_line_content": "",
          "new_line_content": "\tLOG_ERROR(log, \"Checker: No replica has part covering \" << part_name);",
          "content_same": false
        },
        {
          "line": 2128,
          "old_api": null,
          "new_api": "<< \" from \" << replica_path << (to_detached ? \" (to 'detached' directory)\" : \"\"));\n}\n\n\nvoid StorageReplicatedMergeTree::shutdown()\n{\n\tif (restarting_thread)\n\t{\n\t\trestarting_thre",
          "old_text": null,
          "new_text": " << \" from \" << replica_path << (to_detached ? \" (to 'detached' directory)\" : \"\"));\n}\n\n\nvoid StorageReplicatedMergeTree::shutdown()\n{\n\tif (restarting_thread)\n\t{\n\t\trestarting_thre",
          "old_line_content": "\t{",
          "new_line_content": "\t\tLOG_WARNING(log, \"When looking for smaller parts, that is covered by \" << part_name",
          "content_same": false
        },
        {
          "line": 2138,
          "old_api": null,
          "new_api": "gs,\n\tQueryP",
          "old_text": null,
          "new_text": "gs,\n\tQueryP",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\tfor (LogEntries::iterator it = queue.begin(); it != queue.end();)",
          "content_same": false
        },
        {
          "line": 2142,
          "old_api": null,
          "new_api": "block_size,\n\tconst unsigned threads)\n{\n\t/** У таблицы может быть д",
          "old_text": null,
          "new_text": "block_size,\n\tconst unsigned threads)\n{\n\t/** У таблицы может быть д",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t\tzookeeper->tryRemove(replica_path + \"/queue/\" + (*it)->znode_name);",
          "content_same": false
        },
        {
          "line": 2143,
          "old_api": null,
          "new_api": "а данных:\n\t  * -",
          "old_text": null,
          "new_text": "а данных:\n\t  * - ",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tqueue.erase(it++);",
          "content_same": false
        },
        {
          "line": 2161,
          "old_api": null,
          "new_api": "uery &>(*query);\n\n\t/// Try transferring some condition from WHERE to",
          "old_text": null,
          "new_text": "uery &>(*query);\n\n\t/// Try transferring some condition from WHERE to",
          "old_line_content": "\t\t* Специально из-за этого приходится отдельно иметь nonincrement_block_numbers.",
          "new_line_content": "\tLOG_ERROR(log, \"Checker: Part \" << part_name << \" is lost forever.\");",
          "content_same": false
        },
        {
          "line": 2162,
          "old_api": null,
          "new_api": "EWHERE if enabled and viable\n\tif (settings.optimize_move_to",
          "old_text": null,
          "new_text": "EWHERE if enabled and viable\n\tif (settings.optimize_move_to",
          "old_line_content": "\t\t*",
          "new_line_content": "\tProfileEvents::increment(ProfileEvents::ReplicatedDataLoss);",
          "content_same": false
        },
        {
          "line": 2180,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "parallel_replica_offset == 0) && unreplicated_reader && values.count(0))\n\t{\n\t\tres = unreplicated_reader->read(real_column_n",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\t\tLOG_ERROR(log, \"Won't add nonincrement_block_numbers because part spans too much blocks (\" << part_length_in_blocks << \")\");",
          "content_same": false
        },
        {
          "line": 2190,
          "old_api": null,
          "new_api": "{\n\t\t\t\tfor (auto & str",
          "old_text": null,
          "new_text": "\t{\n\t\t\t\tfor (auto & str",
          "old_line_content": "\t\t\t*zookeeper);",
          "new_line_content": "\tconst auto partition_str = part_name.substr(0, 6);",
          "content_same": false
        },
        {
          "line": 2193,
          "old_api": null,
          "new_api": "nt8>(stream, new DataTypeUInt8, 0, \"_replicated\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (values.coun",
          "old_text": null,
          "new_text": "nt8>(stream, new DataTypeUInt8, 0, \"_replicated\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (values.coun",
          "old_line_content": "",
          "new_line_content": "\t\tzookeeper->createIfNotExists(zookeeper_path + \"/nonincrement_block_numbers\", \"\");",
          "content_same": false
        },
        {
          "line": 2194,
          "old_api": null,
          "new_api": ")\n\t{\n\t\t/** Настройка select_sequential_consistency имеет два смысла:\n\t\t  * 1. Кидать исключение,",
          "old_text": null,
          "new_text": ")\n\t{\n\t\t/** Настройка select_sequential_consistency имеет два смысла:\n\t\t  * 1. Кидать исключение, ",
          "old_line_content": "",
          "new_line_content": "\t\tzookeeper->createIfNotExists(zookeeper_path + \"/nonincrement_block_numbers/\" + partition_str, \"\");",
          "content_same": false
        },
        {
          "line": 2195,
          "old_api": null,
          "new_api": "на реплике есть не все куски, которые были записаны на кворум остальных реплик.\n\t\t  * 2. Не читать куски, которые ещё не были записаны на кворум реплик.\n\t\t  * Для",
          "old_text": null,
          "new_text": " на реплике есть не все куски, которые были записаны на кворум остальных реплик.\n\t\t  * 2. Не читать куски, которые ещё не были записаны на кворум реплик.\n\t\t  * Для ",
          "old_line_content": "void StorageReplicatedMergeTree::checkPart(const String & part_name)",
          "new_line_content": "\t\tAbandonableLockInZooKeeper::createAbandonedIfNotExists(",
          "content_same": false
        },
        {
          "line": 2196,
          "old_api": null,
          "new_api": "а кворум ре",
          "old_text": null,
          "new_text": "а кворум ре",
          "old_line_content": "{",
          "new_line_content": "\t\t\tzookeeper_path + \"/nonincrement_block_numbers/\" + partition_str + \"/block-\" + padIndex(i),",
          "content_same": false
        },
        {
          "line": 2204,
          "old_api": null,
          "new_api": "o_read = 0;\n\t\tif (settings.select_sequential_consistency",
          "old_text": null,
          "new_text": "o_read = 0;\n\t\tif (settings.select_sequential_consistency",
          "old_line_content": "\t{",
          "new_line_content": "\tLOG_WARNING(log, \"Checker: Checking part \" << part_name);",
          "content_same": false
        },
        {
          "line": 2207,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "Get(zookeeper_path + \"/quorum/last_part",
          "old_line_content": "\t/// У нас есть этот кусок, и он активен. Будем проверять, нужен ли нам этот кусок и правильные ли у него данные.",
          "new_line_content": "\tauto part = data.getActiveContainingPart(part_name);",
          "content_same": false
        },
        {
          "line": 2212,
          "old_api": null,
          "new_api": "е реплики при распределённых за",
          "old_text": null,
          "new_text": "е реплики при распределённых за",
          "old_line_content": "",
          "new_line_content": "\t\tsearchForMissingPart(part_name);",
          "content_same": false
        },
        {
          "line": 2217,
          "old_api": null,
          "new_api": "M);\n\n\t\t\tif (la",
          "old_text": null,
          "new_text": "M);\n\n\t\t\tif (la",
          "old_line_content": "",
          "new_line_content": "\t\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2218,
          "old_api": null,
          "new_api": "сли ещё ни один кусо",
          "old_text": null,
          "new_text": "сли ещё ни один кусо",
          "old_line_content": "\t\t\ttry",
          "new_line_content": "\t\tauto table_lock = lockStructure(false);",
          "content_same": false
        },
        {
          "line": 2223,
          "old_api": null,
          "new_api": "String",
          "old_text": null,
          "new_text": "String(quorum_str);\n\t\t\t\t\tActiveDataPartSet::Part part_info;\n\t\t\t\t\tActive",
          "old_line_content": "",
          "new_line_content": "\t\t\tLOG_WARNING(log, \"Checker: Checking data of part \" << part_name << \".\");",
          "content_same": false
        },
        {
          "line": 2228,
          "old_api": null,
          "new_api": "_read = part_info.left - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tActiveDataP",
          "old_text": null,
          "new_text": "_read = part_info.left - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tActiveDataP",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tzookeeper->get(replica_path + \"/parts/\" + part_name + \"/checksums\"));",
          "content_same": false
        },
        {
          "line": 2229,
          "old_api": null,
          "new_api": ":Part part_info;\n\t\t\t\tActiveDataPartSet::parseP",
          "old_text": null,
          "new_text": ":Part part_info;\n\t\t\t\tActiveDataPartSet::parseP",
          "old_line_content": "\t\t\t\tMergeTreePartChecker::Settings settings;",
          "new_line_content": "\t\t\t\tzk_checksums.checkEqual(part->checksums, true);",
          "content_same": false
        },
        {
          "line": 2237,
          "old_api": null,
          "new_api": "f (virtual_column == \"_replicated\")\n\t\t\t{\n\t\t\t\tfor (au",
          "old_text": null,
          "new_text": "f (virtual_column == \"_replicated\")\n\t\t\t{\n\t\t\t\tfor (au",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\tsettings.setIndexGranularity(data.index_granularity);",
          "content_same": false
        },
        {
          "line": 2238,
          "old_api": null,
          "new_api": "tream : res2)\n\t\t\t\t\tstream = new Ad",
          "old_text": null,
          "new_text": "tream : res2)\n\t\t\t\t\tstream = new Ad",
          "old_line_content": "\t\t\tcatch (...)",
          "new_line_content": "\t\t\t\tsettings.setRequireChecksums(true);",
          "content_same": false
        },
        {
          "line": 2239,
          "old_api": null,
          "new_api": "nstColumnBlockInputStream<UInt8>(str",
          "old_text": null,
          "new_text": "nstColumnBlockInputStream<UInt8>(str",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\t\tsettings.setRequireColumnFiles(true);",
          "content_same": false
        },
        {
          "line": 2241,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "\t\t}\n\n\t\tres.insert(",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tdata.getFullPath() + part_name, settings, data.primary_key_data_types);",
          "content_same": false
        },
        {
          "line": 2247,
          "old_api": null,
          "new_api": "s)\n{\n\tif (is_readonly)\n\t\tthrow Exception(\"T",
          "old_text": null,
          "new_text": "s)\n{\n\tif (is_readonly)\n\t\tthrow Exception(\"T",
          "old_line_content": "\t\t\t\t/// Удалим кусок локально.",
          "new_line_content": "\t\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 2249,
          "old_api": null,
          "new_api": "in readonly mode\", ErrorCodes::TABLE_IS_READ_ONLY);\n\n\tString insert_id;\n\tif (query)\n\t\tif (ASTInser",
          "old_text": null,
          "new_text": " in readonly mode\", ErrorCodes::TABLE_IS_READ_ONLY);\n\n\tString insert_id;\n\tif (query)\n\t\tif (ASTInser",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\tLOG_ERROR(log, \"Checker: Part \" << part_name << \" looks broken. Removing it and queueing a fetch.\");",
          "content_same": false
        },
        {
          "line": 2250,
          "old_api": null,
          "new_api": "* insert = typeid_cast<ASTInsertQuery *>(&*query))\n\t\t\tinsert_id =",
          "old_text": null,
          "new_text": " * insert = typeid_cast<ASTInsertQuery *>(&*query))\n\t\t\tinsert_id = ",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\t\tProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);",
          "content_same": false
        },
        {
          "line": 2252,
          "old_api": null,
          "new_api": ">insert_id;\n\n\treturn new ReplicatedM",
          "old_text": null,
          "new_text": ">insert_id;\n\n\treturn new ReplicatedM",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\t\tremovePartAndEnqueueFetch(part_name);",
          "content_same": false
        },
        {
          "line": 2255,
          "old_api": null,
          "new_api": "rt_quorum);\n}\n\n\nbool StorageReplicatedMer",
          "old_text": null,
          "new_text": "rt_quorum);\n}\n\n\nbool StorageReplicatedMer",
          "old_line_content": "\t\t\t/// Поэтому удаляем только если кусок старый (не очень надежно).",
          "new_line_content": "\t\t\t\tdata.renameAndDetachPart(part, \"broken_\");",
          "content_same": false
        },
        {
          "line": 2265,
          "old_api": null,
          "new_api": "rged_name, 0, true, true, false, always_can_merge))\n\t\treturn false;\n\n\tconst auto & merg",
          "old_text": null,
          "new_text": "rged_name, 0, true, true, false, always_can_merge))\n\t\treturn false;\n\n\tconst auto & merg",
          "old_line_content": "\t\t\t\t<< \" seconds hasn't been added to ZooKeeper yet. It's ok.\");",
          "new_line_content": "\t\t\tLOG_ERROR(log, \"Checker: Unexpected part \" << part_name << \" in filesystem. Removing.\");",
          "content_same": false
        },
        {
          "line": 2266,
          "old_api": null,
          "new_api": "getMergeList",
          "old_text": null,
          "new_text": "ry = context.getMergeList().insert(database_n",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tdata.renameAndDetachPart(part, \"unexpected_\");",
          "content_same": false
        },
        {
          "line": 2270,
          "old_api": null,
          "new_api": "mergeParts",
          "old_text": null,
          "new_text": "ged_name);\n\tunreplicated_merger->mergeParts(parts, merged_name, *merge_entry, settings.min_bytes_to_use_direct_io);\n\n\treturn true;\n}\n\n\nvoid StorageReplicatedMergeTree::alter",
          "old_line_content": "\t\t/// Если у нас есть покрывающий кусок, игнорируем все проблемы с этим куском.",
          "new_line_content": "\t\t\tLOG_TRACE(log, \"Checker: Young part \" << part_name",
          "content_same": false
        },
        {
          "line": 2271,
          "old_api": null,
          "new_api": "y, sett",
          "old_text": null,
          "new_text": "y, sett",
          "old_line_content": "\t\t/// В худшем случае в лог еще old_parts_lifetime секунд будут валиться ошибки, пока кусок не удалится как старый.",
          "new_line_content": "\t\t\t\t<< \" with age \" << (time(0) - part->modification_time)",
          "content_same": false
        },
        {
          "line": 2286,
          "old_api": null,
          "new_api": "_column_defaults;\n\tString new_co",
          "old_text": null,
          "new_text": "_column_defaults;\n\tString new_co",
          "old_line_content": "\t\t\tString part_name;",
          "new_line_content": "\tsetThreadName(\"ReplMTPartCheck\");",
          "content_same": false
        },
        {
          "line": 2296,
          "old_api": null,
          "new_api": "checkAlter",
          "old_text": null,
          "new_text": "checkAlter(params);\n\n\t\tnew_c",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\t\tif (parts_to_check_queue.empty())",
          "content_same": false
        },
        {
          "line": 2298,
          "old_api": null,
          "new_api": "olumnsListNonMaterialized",
          "old_text": null,
          "new_text": "olumnsListNonMaterialized(",
          "old_line_content": "\t\t\t\t{",
          "new_line_content": "\t\t\t\t\tif (!parts_to_check_set.empty())",
          "content_same": false
        },
        {
          "line": 2300,
          "old_api": null,
          "new_api": "alized_columns = data.materialized_columns;\n\t\tnew_alias_columns = data.alias_columns;\n\t\tnew_column_defa",
          "old_text": null,
          "new_text": "alized_columns = data.materialized_columns;\n\t\tnew_alias_columns = data.alias_columns;\n\t\tnew_column_defa",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\tLOG_ERROR(log, \"Checker: Non-empty parts_to_check_set with empty parts_to_check_queue. This is a bug.\");",
          "content_same": false
        },
        {
          "line": 2301,
          "old_api": null,
          "new_api": "ata.column_defaults;\n\t\tpar",
          "old_text": null,
          "new_text": "ata.column_defaults;\n\t\tpar",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\t\t\tparts_to_check_set.clear();",
          "content_same": false
        },
        {
          "line": 2306,
          "old_api": null,
          "new_api": ", new_alias_columns, new_col",
          "old_text": null,
          "new_text": ", new_alias_columns, new_col",
          "old_line_content": "\t\t\t\tcontinue;",
          "new_line_content": "\t\t\t\t\tpart_name = parts_to_check_queue.front();",
          "content_same": false
        },
        {
          "line": 2310,
          "old_api": null,
          "new_api": "_columns_str = Co",
          "old_text": null,
          "new_text": "_columns_str = Co",
          "old_line_content": "",
          "new_line_content": "\t\t\tif (part_name.empty())",
          "content_same": false
        },
        {
          "line": 2312,
          "old_api": null,
          "new_api": "ption<false>{\n\t\t\tnew_column",
          "old_text": null,
          "new_text": "ption<false>{\n\t\t\tnew_column",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\t\tparts_to_check_event.wait();",
          "content_same": false
        },
        {
          "line": 2323,
          "old_api": null,
          "new_api": "ting for replicas to apply changes.\");\n\n\t/// Ждем, пока все реплики обновят данные.\n\n\t/",
          "old_text": null,
          "new_text": "ting for replicas to apply changes.\");\n\n\t/// Ждем, пока все реплики обновят данные.\n\n\t/",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\t\tLOG_ERROR(log, \"Checker: Someone changed parts_to_check_queue.front(). This is a bug.\");",
          "content_same": false
        },
        {
          "line": 2334,
          "old_api": null,
          "new_api": "s\", &stat, alter_query_event))\n\t\tthrow Exce",
          "old_text": null,
          "new_text": "s\", &stat, alter_query_event))\n\t\tthrow Exce",
          "old_line_content": "void StorageReplicatedMergeTree::becomeLeader()",
          "new_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 2335,
          "old_api": null,
          "new_api": "(zookeeper_path + \"/columns doesn't exist\",",
          "old_text": null,
          "new_text": "(zookeeper_path + \"/columns doesn't exist\", ",
          "old_line_content": "{",
          "new_line_content": "\t\t\tparts_to_check_event.tryWait(ERROR_SLEEP_MS);",
          "content_same": false
        },
        {
          "line": 2343,
          "old_api": null,
          "new_api": "ersion)\n\t{\n\t\tLOG_WARNING(log,",
          "old_text": null,
          "new_text": "ersion)\n\t{\n\t\tLOG_WARNING(log, ",
          "old_line_content": "{",
          "new_line_content": "\tLOG_INFO(log, \"Became leader\");",
          "content_same": false
        },
        {
          "line": 2351,
          "old_api": null,
          "new_api": "t String & rep",
          "old_text": null,
          "new_text": "t String & rep",
          "old_line_content": "\t{",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2355,
          "old_api": null,
          "new_api": "\"/replicas/\"",
          "old_text": null,
          "new_text": " \"/replicas/\" ",
          "old_line_content": "",
          "new_line_content": "\tstd::random_shuffle(replicas.begin(), replicas.end());",
          "content_same": false
        },
        {
          "line": 2359,
          "old_api": null,
          "new_api": "{\n\t\t\t\tLOG_WARNING(log, replica << \" was removed\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint repli",
          "old_text": null,
          "new_text": "\t\t{\n\t\t\t\tLOG_WARNING(log, replica << \" was removed\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint repli",
          "old_line_content": "\treturn \"\";",
          "new_line_content": "\t\tif (zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/parts/\" + part_name) &&",
          "content_same": false
        },
        {
          "line": 2360,
          "old_api": null,
          "new_api": "= stat.version;\n\n\t\t\tif (replica_columns_str == new_columns_str)\n\t\t\t\tbreak",
          "old_text": null,
          "new_text": "= stat.version;\n\n\t\t\tif (replica_columns_str == new_columns_str)\n\t\t\t\tbreak",
          "old_line_content": "}",
          "new_line_content": "\t\t\t(!active || zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")))",
          "content_same": false
        },
        {
          "line": 2374,
          "old_api": null,
          "new_api": "ery_event))",
          "old_text": null,
          "new_text": "ery_event))\n\t\t",
          "old_line_content": "\tString value;",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2385,
          "old_api": null,
          "new_api": "Num",
          "old_text": null,
          "new_text": "Num(start_time);\n\tDayNum_t right_date = DayNum_t(st",
          "old_line_content": "\t\t\t/// Кворум уже был достигнут. Более того, уже начался другой INSERT с кворумом.",
          "new_line_content": "\twhile (zookeeper->tryGet(quorum_status_path, value, &stat))",
          "content_same": false
        },
        {
          "line": 2388,
          "old_api": null,
          "new_api": "ime) - 1);\n\n\t/// Уровень - rig",
          "old_text": null,
          "new_text": "ime) - 1);\n\n\t/// Уровень - rig",
          "old_line_content": "",
          "new_line_content": "\t\tquorum_entry.fromString(value);",
          "content_same": false
        },
        {
          "line": 2403,
          "old_api": null,
          "new_api": "k = lockStructure(true);\n\n\tconst DayNum_t month = MergeTreeData::getMon",
          "old_text": null,
          "new_text": "k = lockStructure(true);\n\n\tconst DayNum_t month = MergeTreeData::getMon",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\tops.push_back(new zkutil::Op::Remove(quorum_status_path, stat.version));",
          "content_same": false
        },
        {
          "line": 2404,
          "old_api": null,
          "new_api": "Num",
          "old_text": null,
          "new_text": "Num(partition);\n\n\tsize_t removed_parts = 0;\n\tMergeTreeData::DataParts parts ",
          "old_line_content": "\t\t\telse if (code == ZNONODE)",
          "new_line_content": "\t\t\tops.push_back(new zkutil::Op::SetData(quorum_last_part_path, part_name, -1));",
          "content_same": false
        },
        {
          "line": 2405,
          "old_api": null,
          "new_api": "getDataParts",
          "old_text": null,
          "new_text": "ta->getDataParts();\n\n\tfo",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\tauto code = zookeeper->tryMulti(ops);",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": null,
          "new_api": "eplicated parts inside \" << apply_visitor(FieldVi",
          "old_text": null,
          "new_text": "eplicated parts inside \" << apply_visitor(FieldVi",
          "old_line_content": "\t\t\tif (code == ZOK)",
          "new_line_content": "\t\t\t\tthrow zkutil::KeeperException(code, quorum_status_path);",
          "content_same": false
        },
        {
          "line": 2427,
          "old_api": null,
          "new_api": "s)\n{\n\tif (unreplicated)",
          "old_text": null,
          "new_text": "s)\n{\n\tif (unreplicated)",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\tauto code = zookeeper->trySet(quorum_status_path, quorum_entry.toString(), stat.version);",
          "content_same": false
        },
        {
          "line": 2444,
          "old_api": null,
          "new_api": "rCodes::NO_ACTIVE_REPLICAS);\n\n\t\tstd::sort(live_re",
          "old_text": null,
          "new_text": "rCodes::NO_ACTIVE_REPLICAS);\n\n\t\tstd::sort(live_re",
          "old_line_content": "{",
          "new_line_content": "\t\t\t\tthrow zkutil::KeeperException(code, quorum_status_path);",
          "content_same": false
        },
        {
          "line": 2452,
          "old_api": null,
          "new_api": "ame)\n\t\t\tthrow",
          "old_text": null,
          "new_text": "ame)\n\t\t\tthrow ",
          "old_line_content": "",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2454,
          "old_api": null,
          "new_api": "ption",
          "old_text": null,
          "new_text": "ption(\"Leader was suddenly changed or logical error.\", ErrorCodes::LEADER",
          "old_line_content": "",
          "new_line_content": "\tLOG_DEBUG(log, \"Fetching part \" << part_name << \" from \" << replica_path);",
          "content_same": false
        },
        {
          "line": 2458,
          "old_api": null,
          "new_api": "ookeeper_path + \"/r",
          "old_text": null,
          "new_text": "ookeeper_path + \"/r",
          "old_line_content": "\t{",
          "new_line_content": "\t\ttable_lock = lockStructure(true);",
          "content_same": false
        },
        {
          "line": 2462,
          "old_api": null,
          "new_api": "y);\n\n\t\talter.database = leader_address.database;\n\t\talter.table = leader_address.table;\n\n\t\t/// N",
          "old_text": null,
          "new_text": "y);\n\n\t\talter.database = leader_address.database;\n\t\talter.table = leader_address.table;\n\n\t\t/// N",
          "old_line_content": "\t\tMergeTreeData::Transaction transaction;",
          "new_line_content": "\tMergeTreeData::MutableDataPartPtr part = fetcher.fetchPart(part_name, replica_path, address.host, address.replication_port, to_detached);",
          "content_same": false
        },
        {
          "line": 2467,
          "old_api": null,
          "new_api": "вателя default без пароля. Можно исправить с пом",
          "old_text": null,
          "new_text": "вателя default без пароля. Можно исправить с пом",
          "old_line_content": "",
          "new_line_content": "\t\tcheckPartAndAddToZooKeeper(part, ops, part_name);",
          "content_same": false
        },
        {
          "line": 2470,
          "old_api": null,
          "new_api": "(\n\t\t\tleader_address.host,\n\t\t\tleader_address.queries_port,",
          "old_text": null,
          "new_text": "(\n\t\t\tleader_address.host,\n\t\t\tleader_address.queries_port,\n",
          "old_line_content": "\t\t  */",
          "new_line_content": "\t\tauto removed_parts = data.renameTempPartAndReplace(part, nullptr, &transaction);",
          "content_same": false
        },
        {
          "line": 2473,
          "old_api": null,
          "new_api": "\"\", \"\", \"ClickHouse",
          "old_text": null,
          "new_text": "\t\"\", \"\", \"ClickHouse",
          "old_line_content": "",
          "new_line_content": "\t\ttransaction.commit();",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": null,
          "new_api": "ятся слияния удаляемых куск",
          "old_text": null,
          "new_text": "ятся слияния удаляемых куск",
          "old_line_content": "\t}",
          "new_line_content": "\t\tmerge_selecting_event.set();",
          "content_same": false
        },
        {
          "line": 2485,
          "old_api": null,
          "new_api": "поддержать запрос DROP PART, для него придется придумать какой-нибудь новый механизм,\n\t  *        чтоб",
          "old_text": null,
          "new_text": " поддержать запрос DROP PART, для него придется придумать какой-нибудь новый механизм,\n\t  *        чтоб",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\tLOG_DEBUG(log, \"Part \" << removed_part->name << \" is rendered obsolete by fetching part \" << part_name);",
          "content_same": false
        },
        {
          "line": 2486,
          "old_api": null,
          "new_api": "антировать этот инвариант.\n\t  */\n\tInt64 right;\n\n\t{\n\t\tAbandonable",
          "old_text": null,
          "new_text": "антировать этот инвариант.\n\t  */\n\tInt64 right;\n\n\t{\n\t\tAbandonable",
          "old_line_content": "",
          "new_line_content": "\t\t\tProfileEvents::increment(ProfileEvents::ObsoleteReplicatedParts);",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": null,
          "new_api": "getNumber",
          "old_text": null,
          "new_text": "r_lock.getNumber()",
          "old_line_content": "",
          "new_line_content": "\t\tPoco::File(data.getFullPath() + \"detached/tmp_\" + part_name).renameTo(data.getFullPath() + \"detached/\" + part_name);",
          "content_same": false
        },
        {
          "line": 2494,
          "old_api": null,
          "new_api": "/// Такого никогда не должно происходить.\n\tif (right == 0)",
          "old_text": null,
          "new_text": "\n\n\t/// Такого никогда не должно происходить.\n\tif (right == 0)\n",
          "old_line_content": "{",
          "new_line_content": "\tProfileEvents::increment(ProfileEvents::ReplicatedPartFetches);",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": null,
          "new_api": "row Exception(\"Logical error: just allocated block number is zero\", ErrorCodes::LOGICAL_ERROR);\n\t--right;\n\n\tString fake_part_",
          "old_text": null,
          "new_text": "row Exception(\"Logical error: just allocated block number is zero\", ErrorCodes::LOGICAL_ERROR);\n\t--right;\n\n\tString fake_part_",
          "old_line_content": "\t{",
          "new_line_content": "\tLOG_DEBUG(log, \"Fetched part \" << part_name << \" from \" << replica_path << (to_detached ? \" (to 'detached' directory)\" : \"\"));",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": null,
          "new_api": "слияния удаляемые куски -",
          "old_text": null,
          "new_text": "слияния удаляемые куски -",
          "old_line_content": "",
          "new_line_content": "\t\trestarting_thread->stop();",
          "content_same": false
        },
        {
          "line": 2505,
          "old_api": null,
          "new_api": "лаем вид, что их всех уже",
          "old_text": null,
          "new_text": "лаем вид, что их всех уже",
          "old_line_content": "StorageReplicatedMergeTree::~StorageReplicatedMergeTree()",
          "new_line_content": "\t\trestarting_thread.reset();",
          "content_same": false
        },
        {
          "line": 2516,
          "old_api": null,
          "new_api": "ятся слиян",
          "old_text": null,
          "new_text": "ятся слиян",
          "old_line_content": "",
          "new_line_content": "\t\tshutdown();",
          "content_same": false
        },
        {
          "line": 2520,
          "old_api": null,
          "new_api": "*/\n\t{\n\t\tstd::lock_guard<std::mutex> merge",
          "old_text": null,
          "new_text": "  */\n\t{\n\t\tstd::lock_guard<std::mutex> merge",
          "old_line_content": "\tASTPtr query,",
          "new_line_content": "\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 2546,
          "old_api": null,
          "new_api": "g>();\n\telse\n\t\tpartition = Merge",
          "old_text": null,
          "new_text": "g>();\n\telse\n\t\tpartition = Merge",
          "old_line_content": "\tif (settings.optimize_move_to_prewhere)",
          "new_line_content": "\t\t\tvirt_column_names.push_back(it);",
          "content_same": false
        },
        {
          "line": 2548,
          "old_api": null,
          "new_api": "tMonthName",
          "old_text": null,
          "new_text": "tMonthName(field);\n\n\tString sou",
          "old_line_content": "\t\t\tMergeTreeWhereOptimizer{query, context, data, real_column_names, log};",
          "new_line_content": "\t\t\treal_column_names.push_back(it);",
          "content_same": false
        },
        {
          "line": 2550,
          "old_api": null,
          "new_api": "ted ? \"unreplicated/\" : \"detached/\");\n\n\t///",
          "old_text": null,
          "new_text": "ted ? \"unreplicated/\" : \"detached/\");\n\n\t///",
          "old_line_content": "\tBlock virtual_columns_block;",
          "new_line_content": "\tauto & select = typeid_cast<const ASTSelectQuery &>(*query);",
          "content_same": false
        },
        {
          "line": 2560,
          "old_api": null,
          "new_api": "++it)\n\t\t{\n\t\t\tStr",
          "old_text": null,
          "new_text": " ++it)\n\t\t{\n\t\t\tStr",
          "old_line_content": "",
          "new_line_content": "\tcolumn->getData()[0] = 0;",
          "content_same": false
        },
        {
          "line": 2562,
          "old_api": null,
          "new_api": "compare",
          "old_text": null,
          "new_text": "ame))\n\t\t\t\tcontinue;\n\t\t\tif (0 != name.compare(0, partition.size(), p",
          "old_line_content": "",
          "new_line_content": "\tvirtual_columns_block.insert(ColumnWithTypeAndName(column_ptr, new DataTypeUInt8, \"_replicated\"));",
          "content_same": false
        },
        {
          "line": 2565,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "g, active_parts.size() <<",
          "old_line_content": "\tsize_t part_index = 0;",
          "new_line_content": "\tif (!virt_column_names.empty())",
          "content_same": false
        },
        {
          "line": 2566,
          "old_api": null,
          "new_api": "getParts",
          "old_text": null,
          "new_text": "f them are active\");\n\t\tparts = active_parts.getParts();\n\t}\n\n\t/// Синхронно пров",
          "old_line_content": "",
          "new_line_content": "\t\tVirtualColumnUtils::filterBlockWithQuery(query, virtual_columns_block, context);",
          "content_same": false
        },
        {
          "line": 2568,
          "old_api": null,
          "new_api": "вуют и не испорчены хотя бы на этой реплике. Запишем checksums.txt, если его нет.\n\tLOG_DEBUG",
          "old_text": null,
          "new_text": "вуют и не испорчены хотя бы на этой реплике. Запишем checksums.txt, если его нет.\n\tLOG_DEBUG",
          "old_line_content": "\t  * Для реплицируемых, данные разбиваются таким же механизмом, как работает секция SAMPLE.",
          "new_line_content": "\tstd::multiset<UInt8> values = VirtualColumnUtils::extractSingleValueFromBlock<UInt8>(virtual_columns_block, \"_replicated\");",
          "content_same": false
        },
        {
          "line": 2580,
          "old_api": null,
          "new_api": ");\n\tstd::list<L",
          "old_text": null,
          "new_text": ");\n\tstd::list<L",
          "old_line_content": "\t\t{",
          "new_line_content": "\tif ((settings.parallel_replica_offset == 0) && unreplicated_reader && values.count(0))",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": null,
          "new_api": "ies;\n\tzkutil::Ops ops;\n\tfor (const String & part_name : parts)\n\t{\n\t\tActiveDataPartSet::Part part;\n\t\tActiveDataPartSet::parsePartName(part_name, part",
          "old_text": null,
          "new_text": "ies;\n\tzkutil::Ops ops;\n\tfor (const String & part_name : parts)\n\t{\n\t\tActiveDataPartSet::Part part;\n\t\tActiveDataPartSet::parsePartName(part_name, part",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\tres = unreplicated_reader->read(real_column_names, query,",
          "content_same": false
        },
        {
          "line": 2596,
          "old_api": null,
          "new_api": "ies.emplace_bac",
          "old_text": null,
          "new_text": "ies.emplace_bac",
          "old_line_content": "\t\tInt64 max_block_number_to_read = 0;",
          "new_line_content": "\tif (values.count(1))",
          "content_same": false
        },
        {
          "line": 2606,
          "old_api": null,
          "new_api": "tions_sync !=",
          "old_text": null,
          "new_text": "tions_sync != ",
          "old_line_content": "",
          "new_line_content": "\t\t\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2608,
          "old_api": null,
          "new_api": "r (LogEntry & entry : entries)\n\t\t{\n\t\t\tString log_znode_path = dyna",
          "old_text": null,
          "new_text": "r (LogEntry & entry : entries)\n\t\t{\n\t\t\tString log_znode_path = dyna",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\tzookeeper->tryGet(zookeeper_path + \"/quorum/last_part\", last_part);",
          "content_same": false
        },
        {
          "line": 2611,
          "old_api": null,
          "new_api": "partitions_sync == 1)\n\t\t\t\twaitForReplicaToProcessLogEntry(replica_name, entry);\n\t\t\telse\n\t\t\t\twaitForAllReplicasToProcessLogEntry(entry);\n\n\t\t\t++i;\n\t\t}\n\t}\n}\n\n\nvoid StorageReplicatedMergeTree::drop()\n{\n\tif (is_readonly)\n\t\tthrow Exception(\"Can't dro",
          "old_text": null,
          "new_text": "partitions_sync == 1)\n\t\t\t\twaitForReplicaToProcessLogEntry(replica_name, entry);\n\t\t\telse\n\t\t\t\twaitForAllReplicasToProcessLogEntry(entry);\n\n\t\t\t++i;\n\t\t}\n\t}\n}\n\n\nvoid StorageReplicatedMergeTree::drop()\n{\n\tif (is_readonly)\n\t\tthrow Exception(\"Can't dro",
          "old_line_content": "\t\t\t\t{",
          "new_line_content": "\t\t\t\tthrow Exception(\"Replica doesn't have part \" + last_part + \" which was successfully written to quorum of other replicas.\"",
          "content_same": false
        },
        {
          "line": 2614,
          "old_api": null,
          "new_api": "replicated table",
          "old_text": null,
          "new_text": " replicated table",
          "old_line_content": "\t\t\t\t\tActiveDataPartSet::Part part_info;",
          "new_line_content": "\t\t\tif (last_part.empty())\t/// Если ещё ни один кусок не был записан с кворумом.",
          "content_same": false
        },
        {
          "line": 2617,
          "old_api": null,
          "new_api": "_INFO",
          "old_text": null,
          "new_text": "_INFO(log, \"Removing replica \" << replica_path);\n\treplica_is_act",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\t\tif (zookeeper->tryGet(zookeeper_path + \"/quorum/status\", quorum_str))",
          "content_same": false
        },
        {
          "line": 2620,
          "old_api": null,
          "new_api": ");\n\n\t/// Проверяем, что zookeeper_p",
          "old_text": null,
          "new_text": ");\n\n\t/// Проверяем, что zookeeper_p",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\t\t\tquorum_entry.fromString(quorum_str);",
          "content_same": false
        },
        {
          "line": 2629,
          "old_api": null,
          "new_api": "le \" << zookeeper_path << \" (this might take several m",
          "old_text": null,
          "new_text": "le \" << zookeeper_path << \" (this might take several m",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tActiveDataPartSet::parsePartName(last_part, part_info);",
          "content_same": false
        },
        {
          "line": 2634,
          "old_api": null,
          "new_api": "AllData",
          "old_text": null,
          "new_text": "AllData();\n}\n\n\nvoid StorageReplicatedMergeTree::rename(const String & new_path_to_db, const String & new_database_name, const String & new_ta",
          "old_line_content": "\t\t\t\tfor (auto & stream : res2)",
          "new_line_content": "\t\tauto res2 = reader.read(",
          "content_same": false
        },
        {
          "line": 2646,
          "old_api": null,
          "new_api": "able_name;",
          "old_text": null,
          "new_text": "able_name;",
          "old_line_content": "BlockOutputStreamPtr StorageReplicatedMergeTree::write(ASTPtr query, const Settings & settings)",
          "new_line_content": "\t\tres.insert(res.end(), res2.begin(), res2.end());",
          "content_same": false
        },
        {
          "line": 2656,
          "old_api": null,
          "new_api": "umber",
          "old_text": null,
          "new_text": "umber(const String & month_name)\n{\n\tauto zookeeper = getZooKeeper();\n\n",
          "old_line_content": "\treturn new ReplicatedMergeTreeBlockOutputStream(*this, insert_id, settings.insert_quorum);",
          "new_line_content": "\t\tthrow Exception(\"Table is in readonly mode\", ErrorCodes::TABLE_IS_READ_ONLY);",
          "content_same": false
        },
        {
          "line": 2660,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "me;\n\tif (!zookeeper->exists(month_path",
          "old_line_content": "bool StorageReplicatedMergeTree::optimize(const Settings & settings)",
          "new_line_content": "\t\tif (ASTInsertQuery * insert = typeid_cast<ASTInsertQuery *>(&*query))",
          "content_same": false
        },
        {
          "line": 2677,
          "old_api": null,
          "new_api": "::CreateMode::Persistent));\n\t\t\tops",
          "old_text": null,
          "new_text": "::CreateMode::Persistent));\n\t\t\tops",
          "old_line_content": "",
          "new_line_content": "\tunreplicated_data->clearOldParts();",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": null,
          "new_api": "tryMulti",
          "old_text": null,
          "new_text": "tryMulti(ops);\n\t}\n\n\treturn AbandonableLockInZooKeeper(\n\t\tzookeeper_path + \"/block_numbers/\" + month",
          "old_line_content": "}",
          "new_line_content": "\tif (!unreplicated_merger->selectPartsToMerge(parts, merged_name, 0, true, true, false, always_can_merge))",
          "content_same": false
        },
        {
          "line": 2685,
          "old_api": null,
          "new_api": "*zookeeper);\n}\n\n\nvoid StorageReplicatedMergeTree::waitForAllReplicasT",
          "old_text": null,
          "new_text": "*zookeeper);\n}\n\n\nvoid StorageReplicatedMergeTree::waitForAllReplicasT",
          "old_line_content": "void StorageReplicatedMergeTree::alter(const AlterCommands & params,",
          "new_line_content": "\tconst auto & merge_entry = context.getMergeList().insert(database_name, table_name, merged_name);",
          "content_same": false
        },
        {
          "line": 2686,
          "old_api": null,
          "new_api": "ocessLogEntry",
          "old_text": null,
          "new_text": "ocessLogEntry(const LogEntry & entry)\n{\n\tauto zookeeper = getZooKeeper();\n\tLOG_DEBUG(log, \"Waiting for",
          "old_line_content": "\tconst String & database_name, const String & table_name, Context & context)",
          "new_line_content": "\tunreplicated_merger->mergeParts(parts, merged_name, *merge_entry, settings.min_bytes_to_use_direct_io);",
          "content_same": false
        },
        {
          "line": 2695,
          "old_api": null,
          "new_api": "essLogEntry",
          "old_text": null,
          "new_text": "essLogEntry(re",
          "old_line_content": "\tNamesAndTypesList new_columns;",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2698,
          "old_api": null,
          "new_api": "eplicatedMergeTree::waitForReplicaToProcessLogEntry(const Str",
          "old_text": null,
          "new_text": "eplicatedMergeTree::waitForReplicaToProcessLogEntry(const Str",
          "old_line_content": "\tColumnDefaults new_column_defaults;",
          "new_line_content": "\t\tstd::make_unique<MergeTreeMergeBlocker>(*unreplicated_merger) : nullptr;",
          "content_same": false
        },
        {
          "line": 2700,
          "old_api": null,
          "new_api": "const LogEntry & entry)\n{\n\ta",
          "old_text": null,
          "new_text": " const LogEntry & entry)\n{\n\ta",
          "old_line_content": "\tint new_columns_version;",
          "new_line_content": "\tLOG_DEBUG(log, \"Doing ALTER\");",
          "content_same": false
        },
        {
          "line": 2714,
          "old_api": null,
          "new_api": "облема в том, что номера (sequential нод) элементов очереди в log и в q",
          "old_text": null,
          "new_text": "облема в том, что номера (sequential нод) элементов очереди в log и в q",
          "old_line_content": "\t\tnew_column_defaults = data.column_defaults;",
          "new_line_content": "\t\t\tthrow Exception(\"Can't ALTER readonly table\", ErrorCodes::TABLE_IS_READ_ONLY);",
          "content_same": false
        },
        {
          "line": 2716,
          "old_api": null,
          "new_api": "не совпадают.\n\t  * (И в",
          "old_text": null,
          "new_text": "не совпадают.\n\t  * (И в",
          "old_line_content": "",
          "new_line_content": "\t\tdata.checkAlter(params);",
          "content_same": false
        },
        {
          "line": 2718,
          "old_api": null,
          "new_api": "номера у одного и того же элемента",
          "old_text": null,
          "new_text": " номера у одного и того же элемента ",
          "old_line_content": "\t\t\tnew_columns, new_materialized_columns,",
          "new_line_content": "\t\tnew_columns = data.getColumnsListNonMaterialized();",
          "content_same": false
        },
        {
          "line": 2722,
          "old_api": null,
          "new_api": "ёт к себе в queue элемент очереди из log,\n\t  *  если она ещё этого не сделала (см. функцию",
          "old_text": null,
          "new_text": "ёт к себе в queue элемент очереди из log,\n\t  *  если она ещё этого не сделала (см. функцию ",
          "old_line_content": "\t\t/// Делаем ALTER.",
          "new_line_content": "\t\tparams.apply(new_columns, new_materialized_columns, new_alias_columns, new_column_defaults);",
          "content_same": false
        },
        {
          "line": 2724,
          "old_api": null,
          "new_api": "* Для этого проверяем её узел log_pointer - максимальный номер взятого элемента из log плюс единица.\n\t  */\n\n\tif (0 == entr",
          "old_text": null,
          "new_text": "\t  * Для этого проверяем её узел log_pointer - максимальный номер взятого элемента из log плюс единица.\n\t  */\n\n\tif (0 == entr",
          "old_line_content": "",
          "new_line_content": "\t\tnew_columns_str = ColumnsDescription<false>{",
          "content_same": false
        },
        {
          "line": 2730,
          "old_api": null,
          "new_api": "\"log-\"), \"log-\"))\n\t{\n\t\t/** В этом случае просто берём номер из имени но",
          "old_text": null,
          "new_text": "\"log-\"), \"log-\"))\n\t{\n\t\t/** В этом случае просто берём номер из имени но",
          "old_line_content": "\t/// Ждем, пока все реплики обновят данные.",
          "new_line_content": "\t\tzookeeper->set(zookeeper_path + \"/columns\", new_columns_str, -1, &stat);",
          "content_same": false
        },
        {
          "line": 2735,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "= parse<UInt64>(entry.znode_name.substr(entry.znode_name.size() - 10));\n\t\tlog_node_nam",
          "old_line_content": "",
          "new_line_content": "\tLOG_DEBUG(log, \"Updated columns in ZooKeeper. Waiting for replicas to apply changes.\");",
          "content_same": false
        },
        {
          "line": 2740,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": " log_pointer = zookeeper->get(zookeeper_path + \"/replicas/\" + replica + ",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\tif (!zookeeper->exists(zookeeper_path + \"/columns\", &stat, alter_query_event))",
          "content_same": false
        },
        {
          "line": 2741,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "ter\", nullptr, event);\n\t\t\tif (!log_pointer.empty() && parse<UInt64>(log_pointer)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tthrow Exception(zookeeper_path + \"/columns doesn't exist\", ErrorCodes::NOT_FOUND_NODE);",
          "content_same": false
        },
        {
          "line": 2745,
          "old_api": null,
          "new_api": "compare",
          "old_text": null,
          "new_text": "\n\telse if (0 == entry.znode_name.compare(0, strlen(\"queue-\"), \"queue-\"))\n\t{\n\t\t/** В этом случае номер log-ноды неизвестен. Нужно просмотреть все от log_pointer",
          "old_line_content": "\t{",
          "new_line_content": "\t\tLOG_WARNING(log, zookeeper_path + \"/columns changed before this ALTER finished; \"",
          "content_same": false
        },
        {
          "line": 2750,
          "old_api": null,
          "new_api": "е содержимым. И если мы её не найдём - значит реплик",
          "old_text": null,
          "new_text": "е содержимым. И если мы её не найдём - значит реплик",
          "old_line_content": "\t\t\tString replica_columns_str;",
          "new_line_content": "\tStrings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "content_same": false
        },
        {
          "line": 2760,
          "old_api": null,
          "new_api": "ound = false;\n\n\t\tfor (const String & log_entry_name : log_entries)\n\t\t{\n\t\t\tlog_index = parse<UInt64>",
          "old_text": null,
          "new_text": "ound = false;\n\n\t\tfor (const String & log_entry_name : log_entries)\n\t\t{\n\t\t\tlog_index = parse<UInt64>",
          "old_line_content": "",
          "new_line_content": "\t\t\tif (!zookeeper->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/columns\", replica_columns_str, &stat))",
          "content_same": false
        },
        {
          "line": 2762,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "name.substr(log_entry_name.size() - 10));\n\n",
          "old_line_content": "\t\t\t\tbreak;",
          "new_line_content": "\t\t\t\tLOG_WARNING(log, replica << \" was removed\");",
          "content_same": false
        },
        {
          "line": 2771,
          "old_api": null,
          "new_api": "tryGet",
          "old_text": null,
          "new_text": "per->tryGet(zookeeper_path + \"/log/\" + log_entry_name",
          "old_line_content": "\t\t\t\treturn;",
          "new_line_content": "\t\t\tif (!zookeeper->exists(zookeeper_path + \"/columns\", &stat))",
          "content_same": false
        },
        {
          "line": 2772,
          "old_api": null,
          "new_api": "str);\n\t\t\tif (exists && entry_str == log_entry_str)\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tlo",
          "old_text": null,
          "new_text": "str);\n\t\t\tif (exists && entry_str == log_entry_str)\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tlo",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\tthrow Exception(zookeeper_path + \"/columns doesn't exist\", ErrorCodes::NOT_FOUND_NODE);",
          "content_same": false
        },
        {
          "line": 2781,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "\t\t\tzkutil::EventPtr event = new Poco::Event;\n\n\t\t\t\tString log_pointer = zookeeper->get(zookeeper_p",
          "old_line_content": "\t\t\t\tcontinue;",
          "new_line_content": "\t\t\tif (!zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/columns\", &stat, alter_query_event))",
          "content_same": false
        },
        {
          "line": 2797,
          "old_api": null,
          "new_api": "cal error: unexpected name of lo",
          "old_text": null,
          "new_text": "cal error: unexpected name of lo",
          "old_line_content": "\t/// Диапазон дат - весь месяц.",
          "new_line_content": "\tLOG_DEBUG(log, \"ALTER finished\");",
          "content_same": false
        },
        {
          "line": 2805,
          "old_api": null,
          "new_api": "адать ни с log-узло",
          "old_text": null,
          "new_text": "адать ни с log-узло",
          "old_line_content": "}",
          "new_line_content": "\tconst auto & lut = DateLUT::instance();",
          "content_same": false
        },
        {
          "line": 2806,
          "old_api": null,
          "new_api": "ас).\n\t  * Поэтому, ищем путём ср",
          "old_text": null,
          "new_text": "ас).\n\t  * Поэтому, ищем путём ср",
          "old_line_content": "",
          "new_line_content": "\ttime_t start_time = lut.YYYYMMDDToDate(parse<UInt32>(month_name + \"01\"));",
          "content_same": false
        },
        {
          "line": 2807,
          "old_api": null,
          "new_api": "/\n\n\tStrings queue_entrie",
          "old_text": null,
          "new_text": "/\n\n\tStrings queue_entrie",
          "old_line_content": "",
          "new_line_content": "\tDayNum_t left_date = lut.toDayNum(start_time);",
          "content_same": false
        },
        {
          "line": 2808,
          "old_api": null,
          "new_api": "+ \"/queue\");\n\tString queue_",
          "old_text": null,
          "new_text": "+ \"/queue\");\n\tString queue_",
          "old_line_content": "void StorageReplicatedMergeTree::dropUnreplicatedPartition(const Field & partition, const bool detach, const Settings & settings)",
          "new_line_content": "\tDayNum_t right_date = DayNum_t(static_cast<size_t>(left_date) + lut.daysInMonth(start_time) - 1);",
          "content_same": false
        },
        {
          "line": 2811,
          "old_api": null,
          "new_api": "queue_entry_str);\n\t\tif (exists && queue_entry_str == entry_str)\n\t\t{\n\t\t\tqueue_entry_t",
          "old_text": null,
          "new_text": "queue_entry_str);\n\t\tif (exists && queue_entry_str == entry_str)\n\t\t{\n\t\t\tqueue_entry_t",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\treturn ActiveDataPartSet::getPartName(left_date, right_date, left, right, right - left + 1);",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": null,
          "new_api": "а пофейлилось,",
          "old_text": null,
          "new_text": "а пофейлилось, ",
          "old_line_content": "\t\tzkutil::Stat stat;",
          "new_line_content": "\tfutures.reserve(children.size());",
          "content_same": false
        },
        {
          "line": 2823,
          "old_api": null,
          "new_api": "t_for);\n}\n\n\nvoid St",
          "old_text": null,
          "new_text": "t_for);\n}\n\n\nvoid St",
          "old_line_content": "\tfor (const auto & part : parts)",
          "new_line_content": "\tauto structure_lock = lockStructure(true);",
          "content_same": false
        },
        {
          "line": 2825,
          "old_api": null,
          "new_api": "etStatus",
          "old_text": null,
          "new_text": "etStatus(Status & res, bool with_zk_fiel",
          "old_line_content": "\t\tif (part->month != month)",
          "new_line_content": "\tconst DayNum_t month = MergeTreeData::getMonthDayNum(partition);",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "y.parts_to_merge)\n\t\t{\n\t\t\tif (future_parts.count(name)",
          "old_line_content": "\t\tentry->znode_name = child;",
          "new_line_content": "\t\tfutures.emplace_back(child, zookeeper->asyncGet(replica_path + \"/queue/\" + child));",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": null,
          "new_api": "+ \" because part \"",
          "old_text": null,
          "new_text": "\t+ \" because part \"",
          "old_line_content": "}",
          "new_line_content": "\t\tzkutil::ZooKeeper::ValueAndStat res = future.second.get();",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": null,
          "new_api": "yet (log entry for that part is bei",
          "old_text": null,
          "new_text": " yet (log entry for that part is bei",
          "old_line_content": "",
          "new_line_content": "\t\tLogEntryPtr entry = LogEntry::parse(res.value, res.stat);",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": null,
          "new_api": "n);\n\t\t\t\tout_postpone_reason = reason;",
          "old_text": null,
          "new_text": "n);\n\t\t\t\tout_postpone_reason = reason;",
          "old_line_content": "{",
          "new_line_content": "\t\tentry->addResultToVirtualParts(*this);",
          "content_same": false
        },
        {
          "line": 2835,
          "old_api": null,
          "new_api": "ock_guard<std::mutex> lock(queue_mutex);\n\t\tres.future_parts",
          "old_text": null,
          "new_text": "ock_guard<std::mutex> lock(queue_mutex);\n\t\tres.future_parts",
          "old_line_content": "\t}",
          "new_line_content": "\t\tLOG_DEBUG(log, \"Removing unreplicated part \" << part->name);",
          "content_same": false
        },
        {
          "line": 2839,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "e = queue.size();\n\t\tres.last_queue_update = last",
          "old_line_content": "",
          "new_line_content": "\t\t\tunreplicated_data->renameAndDetachPart(part, \"\");",
          "content_same": false
        },
        {
          "line": 2841,
          "old_api": null,
          "new_api": "e;\n\n\t\tres.inserts_in_queue = 0;\n\t\tres.merges_in_qu",
          "old_text": null,
          "new_text": "e;\n\n\t\tres.inserts_in_queue = 0;\n\t\tres.merges_in_qu",
          "old_line_content": "void StorageReplicatedMergeTree::dropPartition(ASTPtr query, const Field & field, bool detach, bool unreplicated, const Settings & settings)",
          "new_line_content": "\t\t\tunreplicated_data->replaceParts({part}, {}, false);",
          "content_same": false
        },
        {
          "line": 2844,
          "old_api": null,
          "new_api": "& entry : queue)\n\t\t{",
          "old_text": null,
          "new_text": " & entry : queue)\n\t\t{\n",
          "old_line_content": "\t{",
          "new_line_content": "\tLOG_INFO(log, (detach ? \"Detached \" : \"Removed \") << removed_parts << \" unreplicated parts inside \" << apply_visitor(FieldVisitorToString(), partition) << \".\");",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": null,
          "new_api": "eplicatedMergeTre",
          "old_text": null,
          "new_text": "eplicatedMergeTre",
          "old_line_content": "\t}",
          "new_line_content": "\tif (index_str.empty())",
          "content_same": false
        },
        {
          "line": 2852,
          "old_api": null,
          "new_api": "{\n\t\t\t\t++res.inserts_in_queue;\n\n\t\t\t\tif (entry->cr",
          "old_text": null,
          "new_text": "\t\t{\n\t\t\t\t++res.inserts_in_queue;\n\n\t\t\t\tif (entry->cr",
          "old_line_content": "\tif (!is_leader_node)",
          "new_line_content": "\t\tdropUnreplicatedPartition(field, detach, settings);",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": null,
          "new_api": "::ATTACH_PART)",
          "old_text": null,
          "new_text": "::ATTACH_PART)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tindex = entries.empty() ? 0 : parse<UInt64>(std::min_element(entries.begin(), entries.end())->substr(strlen(\"log-\")));",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": null,
          "new_api": "щий его кусок,",
          "old_text": null,
          "new_text": "щий его кусок, ",
          "old_line_content": "\tUInt64 first_index = index;",
          "new_line_content": "\t\tzookeeper->set(replica_path + \"/log_pointer\", toString(index));",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": null,
          "new_api": "MergeTreeData::DataPart",
          "old_text": null,
          "new_text": "\tMergeTreeData::DataPart",
          "old_line_content": "\tzkutil::Stat stat;",
          "new_line_content": "\t\tindex = parse<UInt64>(index_str);",
          "content_same": false
        },
        {
          "line": 2863,
          "old_api": null,
          "new_api": "f (entry->type == LogEntry::MERGE_PARTS)\n\t\t\t{\n\t\t\t\t++res.mer",
          "old_text": null,
          "new_text": "f (entry->type == LogEntry::MERGE_PARTS)\n\t\t\t{\n\t\t\t\t++res.mer",
          "old_line_content": "\t\tif (leader == replica_name)",
          "new_line_content": "\t\tauto live_replicas = zookeeper->getChildren(zookeeper_path + \"/leader_election\");",
          "content_same": false
        },
        {
          "line": 2865,
          "old_api": null,
          "new_api": "e && (!res.merges_oldest_time || entry->create_time < res.merge",
          "old_text": null,
          "new_text": "e && (!res.merges_oldest_time || entry->create_time < res.merge",
          "old_line_content": "",
          "new_line_content": "\t\t\tthrow Exception(\"No active replicas\", ErrorCodes::NO_ACTIVE_REPLICAS);",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": null,
          "new_api": "быть в zookeepe",
          "old_text": null,
          "new_text": "быть в zookeepe",
          "old_line_content": "\t\t/// Одновременно добавим запись в очередь и продвинем указатель на лог.",
          "new_line_content": "\twhile (zookeeper->tryGet(zookeeper_path + \"/log/log-\" + padIndex(index), entry_str, &stat))",
          "content_same": false
        },
        {
          "line": 2867,
          "old_api": null,
          "new_api": "oldest_time = entry",
          "old_text": null,
          "new_text": "oldest_time = entry",
          "old_line_content": "",
          "new_line_content": "\t\tstd::sort(live_replicas.begin(), live_replicas.end());",
          "content_same": false
        },
        {
          "line": 2871,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "_mutex);\n\t\tres.parts_to_check = parts_to_check_set.size();\n\t}\n\n\tres.zookeeper_path = zooke",
          "old_line_content": "\t\talter.database = leader_address.database;",
          "new_line_content": "\t\t\tthrow Exception(\"Leader was suddenly changed or logical error.\", ErrorCodes::LEADERSHIP_CHANGED);",
          "content_same": false
        },
        {
          "line": 2873,
          "old_api": null,
          "new_api": "es.replica_path = replica_path;\n\tres.columns_version = columns_v",
          "old_text": null,
          "new_text": "es.replica_path = replica_path;\n\tres.columns_version = columns_v",
          "old_line_content": "",
          "new_line_content": "\t\tReplicatedMergeTreeAddress leader_address(zookeeper->get(zookeeper_path + \"/replicas/\" + leader + \"/host\"));",
          "content_same": false
        },
        {
          "line": 2875,
          "old_api": null,
          "new_api": "ssion_expired",
          "old_text": null,
          "new_text": "ssion_expired ",
          "old_line_content": "",
          "new_line_content": "\t\tauto new_query = query->clone();",
          "content_same": false
        },
        {
          "line": 2876,
          "old_api": null,
          "new_api": "{\n\t\tres.log_max_index = 0;\n\t\tres.log_p",
          "old_text": null,
          "new_text": "\n\t{\n\t\tres.log_max_index = 0;\n\t\tres.log_p",
          "old_line_content": "\t\tConnection connection(",
          "new_line_content": "\t\tauto & alter = typeid_cast<ASTAlterQuery &>(*new_query);",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": null,
          "new_api": "sn't exist.\");",
          "old_text": null,
          "new_text": "sn't exist.\");\n",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\treplica_path + \"/log_pointer\", toString(index), -1));",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": null,
          "new_api": "к нам не нужен, так к",
          "old_text": null,
          "new_text": "к нам не нужен, так к",
          "old_line_content": "",
          "new_line_content": "\t\tauto results = zookeeper->multi(ops);",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": null,
          "new_api": "ворум пофейлился (см. ниже про /quorum/failed_parts).\n\tif (",
          "old_text": null,
          "new_text": "ворум пофейлился (см. ниже про /quorum/failed_parts).\n\tif (",
          "old_line_content": "",
          "new_line_content": "\t\tString path_created = dynamic_cast<zkutil::Op::Create &>(ops[0]).getPathCreated();",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": null,
          "new_api": "path + \"/quorum/failed_parts/\"",
          "old_text": null,
          "new_text": "path + \"/quorum/failed_parts/\"",
          "old_line_content": "\tif (next_update_event)",
          "new_line_content": "\t\tentry->znode_name = path_created.substr(path_created.find_last_of('/') + 1);",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": null,
          "new_api": "new_part_name))\n\t{\n\t\tLOG_DEBUG(log, \"",
          "old_text": null,
          "new_text": "new_part_name))\n\t{\n\t\tLOG_DEBUG(log, \"",
          "old_line_content": "\t{",
          "new_line_content": "\t\tentry->addResultToVirtualParts(*this);",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": null,
          "new_api": "\" becau",
          "old_text": null,
          "new_text": "\" becau",
          "old_line_content": "",
          "new_line_content": "\tlast_queue_update = time(0);",
          "content_same": false
        },
        {
          "line": 2889,
          "old_api": null,
          "new_api": "UInt64>(log_pointer_str",
          "old_text": null,
          "new_text": "UInt64>(log_pointer_str",
          "old_line_content": "\t/** Пропустим один номер в block_numbers для удаляемого месяца, и будем удалять только куски до этого номера.",
          "new_line_content": "\t\tRemoteBlockInputStream stream(connection, formattedAST(new_query), &settings);",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": null,
          "new_api": "rts не делается",
          "old_text": null,
          "new_text": "rts не делается",
          "old_line_content": "\tif (queue_task_handle)",
          "new_line_content": "\t\tif (zookeeper->exists(zookeeper_path + \"/log/log-\" + padIndex(index), nullptr, next_update_event))",
          "content_same": false
        },
        {
          "line": 2892,
          "old_api": null,
          "new_api": "zookeeper_path + \"/repli",
          "old_text": null,
          "new_text": "zookeeper_path + \"/repli",
          "old_line_content": "\t  * NOTE: Если понадобится аналогично поддержать запрос DROP PART, для него придется придумать какой-нибудь новый механизм,",
          "new_line_content": "\t\tcopyData(stream, output);",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": null,
          "new_api": "ch = true;\n\t}\n\telse if (e",
          "old_text": null,
          "new_text": "ch = true;\n\t}\n\telse if (e",
          "old_line_content": "{",
          "new_line_content": "\t\tqueue_task_handle->wake();",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": null,
          "new_api": "gEntry::MERGE_PARTS",
          "old_text": null,
          "new_text": "gEntry::MERGE_PARTS",
          "old_line_content": "",
          "new_line_content": "\tLOG_DEBUG(log, \"Pulled \" << count << \" entries to queue: log-\" << padIndex(first_index) << \" - log-\" << padIndex(index - 1));",
          "content_same": false
        },
        {
          "line": 2906,
          "old_api": null,
          "new_api": "Partition",
          "old_text": null,
          "new_text": "Partition(const Field & parti",
          "old_line_content": "\t--right;",
          "new_line_content": "\t\tright = block_number_lock.getNumber();",
          "content_same": false
        },
        {
          "line": 2907,
          "old_api": null,
          "new_api": ", const String & from_, co",
          "old_text": null,
          "new_text": ", const String & from_, co",
          "old_line_content": "",
          "new_line_content": "\t\tblock_number_lock.unlock();",
          "content_same": false
        },
        {
          "line": 2912,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "nthName(partition);\n\n\tString from = from_;\n\tif (from.back() == '/')\n\t\tfrom.resize(from.siz",
          "old_line_content": "\t  */",
          "new_line_content": "\t\tthrow Exception(\"Logical error: just allocated block number is zero\", ErrorCodes::LOGICAL_ERROR);",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": null,
          "new_api": "getActiveContainingPart",
          "old_text": null,
          "new_text": ".getActiveContainingPart(name);\n\t\t\tif (",
          "old_line_content": "",
          "new_line_content": "\t\tif (future_parts.count(entry.new_part_name))",
          "content_same": false
        },
        {
          "line": 2915,
          "old_api": null,
          "new_api": "partition \" << partition_str << \" from shard",
          "old_text": null,
          "new_text": "partition \" << partition_str << \" from shard",
          "old_line_content": "",
          "new_line_content": "\tString fake_part_name = getFakePartNameForDrop(month_name, 0, right);",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": null,
          "new_api": "d into \" << entry.new_",
          "old_text": null,
          "new_text": "d into \" << entry.new_",
          "old_line_content": "\t\t\t  */",
          "new_line_content": "\t\t\tLOG_DEBUG(log, reason);",
          "content_same": false
        },
        {
          "line": 2923,
          "old_api": null,
          "new_api": "\" + partition_str + \" is already",
          "old_text": null,
          "new_text": "\" + partition_str + \" is already ",
          "old_line_content": "\tentry.new_part_name = fake_part_name;",
          "new_line_content": "\t\tvirtual_parts.add(fake_part_name);",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": null,
          "new_api": "SpaceMonitor::reserve(full_path, sum_parts_size_in_bytes);\n\n\t\t\taut",
          "old_text": null,
          "new_text": "SpaceMonitor::reserve(full_path, sum_parts_size_in_bytes);\n\n\t\t\taut",
          "old_line_content": "",
          "new_line_content": "\t\tActiveDataPartSet::parsePartName(entry.new_part_name, result_part);",
          "content_same": false
        },
        {
          "line": 2932,
          "old_api": null,
          "new_api": "replica + \"/is_a",
          "old_text": null,
          "new_text": "replica + \"/is_a",
          "old_line_content": "\t\tif (settings.replication_alter_partitions_sync == 1)",
          "new_line_content": "\tString log_znode_path = zookeeper->create(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential);",
          "content_same": false
        },
        {
          "line": 2934,
          "old_api": null,
          "new_api": "::NO_AC",
          "old_text": null,
          "new_text": "::NO_AC",
          "old_line_content": "\t\telse",
          "new_line_content": "\tentry.create_time = time(0);",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": null,
          "new_api": "mergeParts",
          "old_text": null,
          "new_text": "ger.mergeParts(\n\t\t\t\tparts, entry.new_part_name, *merge_entry, a",
          "old_line_content": "\t\t\t\tout_postpone_reason = reason;",
          "new_line_content": "\t\t\tActiveDataPartSet::parsePartName(future_part_name, future_part);",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": null,
          "new_api": "ld, &transaction, reserved_space)",
          "old_text": null,
          "new_text": "ld, &transaction, reserved_space)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\tif (future_part.contains(result_part))",
          "content_same": false
        },
        {
          "line": 2940,
          "old_api": null,
          "new_api": "было бы неплохо уметь выбирать реплику, ближайшую по",
          "old_text": null,
          "new_text": "было бы неплохо уметь выбирать реплику, ближайшую по",
          "old_line_content": "void StorageReplicatedMergeTree::attachPartition(ASTPtr query, const Field & field, bool unreplicated, bool attach_part, const Settings & settings)",
          "new_line_content": "\t\t\twaitForReplicaToProcessLogEntry(replica_name, entry);",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": null,
          "new_api": "иже к zookeeper->multi",
          "old_text": null,
          "new_text": "иже к zookeeper->multi",
          "old_line_content": "\tif (entry.type == LogEntry::MERGE_PARTS)",
          "new_line_content": "\t\t\t\tLOG_DEBUG(log, reason);",
          "content_same": false
        },
        {
          "line": 2949,
          "old_api": null,
          "new_api": "e_replicas)\n\t{",
          "old_text": null,
          "new_text": "e_replicas)\n\t{",
          "old_line_content": "",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2953,
          "old_api": null,
          "new_api": "replica;\n\n\t\tString log",
          "old_text": null,
          "new_text": " replica;\n\n\t\tString log",
          "old_line_content": "\tStrings parts;",
          "new_line_content": "\t\tpartition = field.safeGet<String>();",
          "content_same": false
        },
        {
          "line": 2955,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "er->get(current_replica_path + \"/l",
          "old_line_content": "\t{",
          "new_line_content": "\t\tpartition = MergeTreeData::getMonthName(field);",
          "content_same": false
        },
        {
          "line": 910,
          "old_api": null,
          "new_api": "ок есть, ещё сама не усп",
          "old_text": null,
          "new_text": "ок есть, ещё сама не усп",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\tif (future_parts.count(name))",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": null,
          "new_api": "eplica == replica_name",
          "old_text": null,
          "new_text": "eplica == replica_name",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\t\tLOG_TRACE(log, reason);",
          "content_same": false
        },
        {
          "line": 2963,
          "old_api": null,
          "new_api": "numChildren;\n\n\t\tif (log_po",
          "old_text": null,
          "new_text": "numChildren;\n\n\t\tif (log_po",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\tparts.push_back(partition);",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "ATTACH_PART log ent",
          "old_text": null,
          "new_text": " ATTACH_PART log ent",
          "old_line_content": "\t}",
          "new_line_content": "\t\tif (merger.isCancelled())",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": null,
          "new_api": "подцепит кусок.\n\t\t\t\tw",
          "old_text": null,
          "new_text": " подцепит кусок.\n\t\t\t\tw",
          "old_line_content": "}",
          "new_line_content": "\t\t\tLOG_DEBUG(log, reason);",
          "content_same": false
        },
        {
          "line": 2971,
          "old_api": null,
          "new_api": "ica.\", Er",
          "old_text": null,
          "new_text": "ica.\", Er",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tString name = it.name();",
          "content_same": false
        },
        {
          "line": 2974,
          "old_api": null,
          "new_api": "ve_replicas.size",
          "old_text": null,
          "new_text": "ve_replicas.size",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\tif (0 != name.compare(0, partition.size(), partition))",
          "content_same": false
        },
        {
          "line": 2976,
          "old_api": null,
          "new_api": "<< \" Selected \" << best_replica << \"",
          "old_text": null,
          "new_text": "<< \" Selected \" << best_replica << \" ",
          "old_line_content": "\t/// Синхронно проверим, что добавляемые куски существуют и не испорчены хотя бы на этой реплике. Запишем checksums.txt, если его нет.",
          "new_line_content": "\t\t\tLOG_DEBUG(log, \"Found part \" << name);",
          "content_same": false
        },
        {
          "line": 2979,
          "old_api": null,
          "new_api": "m + \"/replicas/\" +",
          "old_text": null,
          "new_text": "m + \"/replicas/\" + ",
          "old_line_content": "\t{",
          "new_line_content": "\t\tLOG_DEBUG(log, active_parts.size() << \" of them are active\");",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": null,
          "new_api": "щё недостигнут",
          "old_text": null,
          "new_text": "щё недостигнут",
          "old_line_content": "",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2984,
          "old_api": null,
          "new_api": "LOG_INFO(log, \"Some of parts",
          "old_text": null,
          "new_text": "\n\t\t\tLOG_INFO(log, \"Some of parts",
          "old_line_content": "\t/// Выделим добавляемым кускам максимальные свободные номера, меньшие RESERVED_BLOCK_NUMBERS.",
          "new_line_content": "\tLOG_DEBUG(log, \"Checking parts\");",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": null,
          "new_api": "рямо сейчас скачать),",
          "old_text": null,
          "new_text": "рямо сейчас скачать),\n\t",
          "old_line_content": "\t{",
          "new_line_content": "\t\texecuteDropRange(entry);",
          "content_same": false
        },
        {
          "line": 2988,
          "old_api": null,
          "new_api": "if (try_no >= 5)\n\t\t\tthrow Exception(\"Too much",
          "old_text": null,
          "new_text": "\tif (try_no >= 5)\n\t\t\tthrow Exception(\"Too much",
          "old_line_content": "",
          "new_line_content": "\t\tdata.loadPartAndFixMetadata(source_dir + part);",
          "content_same": false
        },
        {
          "line": 2994,
          "old_api": null,
          "new_api": "etch_partition.push_ba",
          "old_text": null,
          "new_text": "etch_partition.push_ba",
          "old_line_content": "\t}",
          "new_line_content": "\tDayNum_t month = DateLUT::instance().makeDayNum(parse<UInt16>(partition.substr(0, 4)), parse<UInt8>(partition.substr(4, 2)), 0);",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": null,
          "new_api": "ion",
          "old_text": null,
          "new_text": "ion(\"Logical error: log entry with quorum have em",
          "old_line_content": "\t\t\treturn true;",
          "new_line_content": "\t\tMergeTreeData::DataPartPtr containing_part = data.getActiveContainingPart(entry.new_part_name);",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": null,
          "new_api": "* - если реплики не стали активными;\n\t\t\t\t\t  * - если сущест",
          "old_text": null,
          "new_text": "\n\t\t\t\t\t  * - если реплики не стали активными;\n\t\t\t\t\t  * - если сущест",
          "old_line_content": "",
          "new_line_content": "\t\tif (containing_part && zookeeper->exists(replica_path + \"/parts/\" + containing_part->name))",
          "content_same": false
        },
        {
          "line": 3000,
          "old_api": null,
          "new_api": "\" on \" + best_replica_path + \" doesn",
          "old_text": null,
          "new_text": " \" on \" + best_replica_path + \" doesn",
          "old_line_content": "\tfor (const String & part_name : parts)",
          "new_line_content": "\t\t\t\tmin_used_number = std::min(min_used_number, part->left);",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": null,
          "new_api": "nt_block_numbers, чтобы разрешить мерджи через номер потерянного куска;\n\t\t\t\t\t  * - добавим кусо",
          "old_text": null,
          "new_text": "nt_block_numbers, чтобы разрешить мерджи через номер потерянного куска;\n\t\t\t\t\t  * - добавим кусо",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tLOG_DEBUG(log, \"Skipping action for part \" << entry.new_part_name << \" - part already exists.\");",
          "content_same": false
        },
        {
          "line": 3004,
          "old_api": null,
          "new_api": "ring & miss",
          "old_text": null,
          "new_text": "ring & miss",
          "old_line_content": "\t\tpart.left = part.right = --min_used_number;",
          "new_line_content": "\tstd::reverse(parts.begin(), parts.end());",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": null,
          "new_api": "_num, то удалим его;\n\t\t\t\t\t  *\n\t\t\t\t\t  * Если что-то изменится, то ничего не сделаем",
          "old_text": null,
          "new_text": "_num, то удалим его;\n\t\t\t\t\t  *\n\t\t\t\t\t  * Если что-то изменится, то ничего не сделаем",
          "old_line_content": "\t}",
          "new_line_content": "\t\tLOG_WARNING(log, \"Part \" << entry.new_part_name << \" from own log doesn't exist.\");",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "волит проследить, что реплики не стали активными.\n\t\t\t\t\t  */\n\n\t\t\t\t\tStrings replica",
          "old_text": null,
          "new_text": "волит проследить, что реплики не стали активными.\n\t\t\t\t\t  */\n\n\t\t\t\t\tStrings replica",
          "old_line_content": "",
          "new_line_content": "\tif (entry.quorum && zookeeper->exists(zookeeper_path + \"/quorum/failed_parts/\" + entry.new_part_name))",
          "content_same": false
        },
        {
          "line": 3012,
          "old_api": null,
          "new_api": "\" on replica \" << best_replica_path << \" has been vanished.\");\n\t\t\t}\n\t\t}\n\n\t\tLOG_INFO(log, \"Parts to",
          "old_text": null,
          "new_text": "\" on replica \" << best_replica_path << \" has been vanished.\");\n\t\t\t}\n\t\t}\n\n\t\tLOG_INFO(log, \"Parts to",
          "old_line_content": "\t\tentry.source_replica = replica_name;",
          "new_line_content": "\t\tString new_part_name = ActiveDataPartSet::getPartName(part.left_date, part.right_date, part.left, part.right, part.level);",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": null,
          "new_api": "getChildren",
          "old_text": null,
          "new_text": "keeper->getChildren(zookeeper_path + \"/replicas\");\n\n\t\t\t\t\tzkutil::Ops ops;\n\n\t\t\t\t\tfor (size_t i = 0, size = replica",
          "old_line_content": "\t{",
          "new_line_content": "\t\tLOG_DEBUG(log, \"Skipping action for part \" << entry.new_part_name << \" because quorum for that part was failed.\");",
          "content_same": false
        },
        {
          "line": 3014,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "h: \" << parts_to_fetch.size());\n\n\t\tmissing_parts.clear();\n\t\tfor (cons",
          "old_line_content": "\t\tentry.new_part_name = new_part_name;",
          "new_line_content": "\t\tLOG_INFO(log, \"Will attach \" << part_name << \" as \" << new_part_name);",
          "content_same": false
        },
        {
          "line": 3017,
          "old_api": null,
          "new_api": "fetchPart(",
          "old_text": null,
          "new_text": "\t\t\t\tfetchPart(",
          "old_line_content": "",
          "new_line_content": "\t\tLogEntry & entry = entries.back();",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": null,
          "new_api": "жным куском.\n\t\t\t\t\treplic",
          "old_text": null,
          "new_text": "жным куском.\n\t\t\t\t\treplic",
          "old_line_content": "\t\t\tlog_message << (i != 0 ? \", \" : \"\") << entry.parts_to_merge[i];",
          "new_line_content": "\t\tdo_fetch = !executeAttachPart(entry);",
          "content_same": false
        },
        {
          "line": 3025,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "\t\t\t}\n\t\t}\n\n\t\t++try_no;\n\t} while (!missing_parts.empty());\n}\n\n\nvoid StorageReplicatedMergeTree::freezePartition(const Field & partition, const Settings & setting",
          "old_line_content": "\t/// Если надо - дожидаемся выполнения операции на себе или на всех репликах.",
          "new_line_content": "\t\tops.push_back(new zkutil::Op::Create(",
          "content_same": false
        },
        {
          "line": 3026,
          "old_api": null,
          "new_api": "ree::freezePartition(const",
          "old_text": null,
          "new_text": "ree::freezePartition(const",
          "old_line_content": "\tif (settings.replication_alter_partitions_sync != 0)",
          "new_line_content": "\t\t\tzookeeper_path + \"/log/log-\", entry.toString(), zookeeper->getDefaultACL(), zkutil::CreateMode::PersistentSequential));",
          "content_same": false
        },
        {
          "line": 3029,
          "old_api": null,
          "new_api": "// Префикс может быть произвольным. Не о",
          "old_text": null,
          "new_text": "// Префикс может быть произвольным. Не о",
          "old_line_content": "\t\tfor (LogEntry & entry : entries)",
          "new_line_content": "\tLOG_DEBUG(log, \"Adding attaches to log\");",
          "content_same": false
        },
        {
          "line": 3030,
          "old_api": null,
          "new_api": "ательно месяц - можно",
          "old_text": null,
          "new_text": "ательно месяц - можно",
          "old_line_content": "\t\t{",
          "new_line_content": "\tzookeeper->multi(ops);",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": null,
          "new_api": "го тоже не может быть.",
          "old_text": null,
          "new_text": "го тоже не может быть.\n\n\t\t\t",
          "old_line_content": "\t\tbool have_all_parts = true;",
          "new_line_content": "\t\tfor (auto i : ext::range(0, entry.parts_to_merge.size()))",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": null,
          "new_api": "str = zookeeper->ge",
          "old_text": null,
          "new_text": "str = zookeeper->ge",
          "old_line_content": "\t\t\tif (!part)",
          "new_line_content": "\t\tLOG_TRACE(log, log_message.rdbuf());",
          "content_same": false
        },
        {
          "line": 3038,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\t\tString log_znode_path = dynamic_cast<zkutil::Op::Create &>(ops[i]).getPathCreated();",
          "content_same": false
        },
        {
          "line": 3039,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\t++i;",
          "new_line_content": "\t\t\tentry.znode_name = log_znode_path.substr(log_znode_path.find_last_of('/') + 1);",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": null,
          "new_api": ".new_part_name)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tops",
          "old_text": null,
          "new_text": ".new_part_name)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tops",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\tMergeTreeData::DataPartPtr part = data.getActiveContainingPart(name);",
          "content_same": false
        },
        {
          "line": 3042,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "}",
          "new_line_content": "\t\t\t\twaitForReplicaToProcessLogEntry(replica_name, entry);",
          "content_same": false
        },
        {
          "line": 3044,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\t\t\twaitForAllReplicasToProcessLogEntry(entry);",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "r = entry.new_part_name.substr(0, 6);\n\t\t\t\t\t\t\tActiveDataPartSet::Part part_info;\n\t\t\t\t\t\t\tActiveDataPartSet::parsePartName(entry.new_part_name, part_info);\n\n\t\t\t\t\t\t\tif (",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tLOG_WARNING(log, \"Part \" << name << \" is covered by \" << part->name",
          "content_same": false
        },
        {
          "line": 3055,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\treplica_is_active_node = nullptr;",
          "new_line_content": "\t\tthrow Exception(\"Can't drop readonly replicated table (need to drop data in ZooKeeper as well)\", ErrorCodes::TABLE_IS_READ_ONLY);",
          "content_same": false
        },
        {
          "line": 3057,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 3059,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\tStrings replicas;",
          "new_line_content": "\tshutdown();",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": null,
          "new_api": "keeper_path + \"/nonincrement_block_numbers/\" + partition_str + \"/block-\" + padIndex(part_info.left),",
          "old_text": null,
          "new_text": "keeper_path + \"/nonincrement_block_numbers/\" + partition_str + \"/block-\" + padIndex(part_info.left),\n\t\t\t\t\t\t\t",
          "old_line_content": "\t\t\t\tif (part->size_in_bytes > data.settings.max_bytes_to_merge_parts_small)",
          "new_line_content": "\t\t\tLOG_DEBUG(log, \"Don't have all parts for merge \" << entry.new_part_name << \"; will try to fetch it instead\");",
          "content_same": false
        },
        {
          "line": 3061,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t{",
          "new_line_content": "\tLOG_INFO(log, \"Removing replica \" << replica_path);",
          "content_same": false
        },
        {
          "line": 3067,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "}",
          "new_line_content": "\tif (zookeeper->tryGetChildren(zookeeper_path + \"/replicas\", replicas) == ZOK && replicas.empty())",
          "content_same": false
        },
        {
          "line": 3069,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\tLOG_INFO(log, \"Removing table \" << zookeeper_path << \" (this might take several minutes)\");",
          "content_same": false
        },
        {
          "line": 3070,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "void StorageReplicatedMergeTree::rename(const String & new_path_to_db, const String & new_database_name, const String & new_table_name)",
          "new_line_content": "\t\tzookeeper->tryRemoveRecursive(zookeeper_path);",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": null,
          "new_api": "ath + \"/blocks/\" + entry.block_id))",
          "old_text": null,
          "new_text": "ath + \"/blocks/\" + entry.block_id))\n\t\t\t\t\t\t\t",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tpool_context.incrementCounter(\"big merges\");",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "\t\t\tops.push_back(new zkutil::Op::Remove(zookeeper_path",
          "old_line_content": "\t\t\t/// Может бросить исключение.",
          "new_line_content": "\t\t\t\t\tpool_context.incrementCounter(\"replicated big merges\");",
          "content_same": false
        },
        {
          "line": 3073,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tdata.dropAllData();",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": null,
          "new_api": "locks/\" + entry.block_id, -1));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tauto code =",
          "old_text": null,
          "new_text": "locks/\" + entry.block_id, -1));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tauto code = ",
          "old_line_content": "",
          "new_line_content": "\t\t\tDiskSpaceMonitor::ReservationPtr reserved_space = DiskSpaceMonitor::reserve(full_path, sum_parts_size_in_bytes);",
          "content_same": false
        },
        {
          "line": 3079,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\ttable_name = new_table_name;",
          "new_line_content": "\tstd::string new_full_path = new_path_to_db + escapeForFileName(new_table_name) + '/';",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": null,
          "new_api": ";\n\n\t\t\t\t\t\t\tif (code =",
          "old_text": null,
          "new_text": ";\n\n\t\t\t\t\t\t\tif (code =",
          "old_line_content": "\t\t\t\tparts, entry.new_part_name, *merge_entry, aio_threshold, &transaction, reserved_space);",
          "new_line_content": "\t\t\tauto table_lock = lockStructure(false);",
          "content_same": false
        },
        {
          "line": 3081,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tdata.setPath(new_full_path, true);",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "(log, \"Marked quorum for part \" << entry.new_part_name << \" as failed.\");",
          "old_text": null,
          "new_text": "(log, \"Marked quorum for part \" << entry.new_part_name << \" as failed.\");\n\t\t\t",
          "old_line_content": "\t\t\tzkutil::Ops ops;",
          "new_line_content": "\t\t\tconst auto & merge_entry = context.getMergeList().insert(database_name, table_name, entry.new_part_name);",
          "content_same": false
        },
        {
          "line": 3083,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "}",
          "new_line_content": "\t\tunreplicated_data->setPath(new_full_path + \"unreplicated/\", false);",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": null,
          "new_api": "о нужно только для ме",
          "old_text": null,
          "new_text": "о нужно только для ме",
          "old_line_content": "",
          "new_line_content": "\t\t\tsize_t aio_threshold = context.getSettings().min_bytes_to_use_direct_io;",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": null,
          "new_api": "ODE || code == ZNODEEXISTS)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tLOG_DEBUG(log, \"State was changed or isn't expected when trying",
          "old_text": null,
          "new_text": "ODE || code == ZNODEEXISTS)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tLOG_DEBUG(log, \"State was changed or isn't expected when trying ",
          "old_line_content": "\t\t\t  *  чтобы оно было как можно ближе к zookeeper->multi.",
          "new_line_content": "\t\t\tMergeTreeData::DataPartPtr part = merger.mergeParts(",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": null,
          "new_api": "<< entry.new_part_name << \"",
          "old_text": null,
          "new_text": "\t\t\t\t\t\t\t\t\t<< entry.new_part_name << \" ",
          "old_line_content": "",
          "new_line_content": "\t\t\tcheckPartAndAddToZooKeeper(part, ops);",
          "content_same": false
        },
        {
          "line": 3095,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tzkutil::Ops ops;",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": null,
          "new_api": "ns entry about anothe",
          "old_text": null,
          "new_text": "ns entry about anothe",
          "old_line_content": "\t\t\t  */",
          "new_line_content": "\t\t\tzookeeper->multi(ops);",
          "content_same": false
        },
        {
          "line": 3098,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tfor (size_t i = 0; i < RESERVED_BLOCK_NUMBERS; ++i)",
          "new_line_content": "\tif (!zookeeper->exists(month_path))",
          "content_same": false
        },
        {
          "line": 3103,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t/// Игнорируем ошибки - не получиться могло только если кто-то еще выполнил эту строчку раньше нас.",
          "new_line_content": "\t\tauto acl = zookeeper->getDefaultACL();",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": null,
          "new_api": "+ replica, false, en",
          "old_text": null,
          "new_text": "+ replica, false, en",
          "old_line_content": "\t{",
          "new_line_content": "\t\t\ttransaction.commit();",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": null,
          "new_api": "Entry::MERGE_PARTS)\n\t\t\t\tProfileEvents::increment(ProfileEvent",
          "old_text": null,
          "new_text": "Entry::MERGE_PARTS)\n\t\t\t\tProfileEvents::increment(ProfileEvent",
          "old_line_content": "",
          "new_line_content": "\t\t\tProfileEvents::increment(ProfileEvents::ReplicatedPartMerges);",
          "content_same": false
        },
        {
          "line": 3108,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tzookeeper_path + \"/block_numbers/\" + month_name + \"/block-\",",
          "new_line_content": "\t\t\tops.push_back(new zkutil::Op::Remove(month_path + \"/skip_increment\", -1));",
          "content_same": false
        },
        {
          "line": 3111,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\tzookeeper->tryMulti(ops);",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": null,
          "new_api": "илось скачать кусок, нужный",
          "old_text": null,
          "new_text": "илось скачать кусок, нужный ",
          "old_line_content": "\t\ttry",
          "new_line_content": "\t\tthrow Exception(\"Unexpected log entry type: \" + toString(static_cast<int>(entry.type)));",
          "content_same": false
        },
        {
          "line": 3114,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "{",
          "new_line_content": "\treturn AbandonableLockInZooKeeper(",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": null,
          "new_api": "ого мерджа,\n\t\t\t  * а попытаться сразу получить п",
          "old_text": null,
          "new_text": "ого мерджа,\n\t\t\t  * а попытаться сразу получить п",
          "old_line_content": "",
          "new_line_content": "\t\t\treplica = findReplicaHavingPart(entry.new_part_name, true);",
          "content_same": false
        },
        {
          "line": 3123,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "}",
          "new_line_content": "\tLOG_DEBUG(log, \"Waiting for all replicas to process \" << entry.znode_name);",
          "content_same": false
        },
        {
          "line": 3125,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tStrings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "content_same": false
        },
        {
          "line": 3127,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "{",
          "new_line_content": "\t\twaitForReplicaToProcessLogEntry(replica, entry);",
          "content_same": false
        },
        {
          "line": 3129,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tLOG_DEBUG(log, \"Finished waiting for all replicas to process \" << entry.znode_name);",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": null,
          "new_api": ">type == LogEntry::MERGE_PAR",
          "old_text": null,
          "new_text": ">type == LogEntry::MERGE_PAR",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\tif (entry.source_replica.empty() || entry.source_replica == replica_name)",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "begin(), (*it)->parts_to_merge.end(), entry.new_part_name)\n\t\t\t\t\t\t\t!= (*it)->parts_to_merge.end())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparts_for_merge = StringSet((*it)->parts_to_mer",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tthrow Exception(\"Logical error: no source replica specified for ATTACH_PART log entry;\"",
          "content_same": false
        },
        {
          "line": 3135,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t  * 2. Из директории queue одной из реплик.",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "\t\tif (!parts_for_merge.empty())\n\t\t\t\t{\n\t\t\t\t\t/// Переместим в ",
          "old_line_content": "\t\t\t\t  *  то (из-за того, что кусок невозможно прямо сейчас скачать),",
          "new_line_content": "\t\t\t\twaitForReplicaToProcessLogEntry(entry.source_replica, entry);",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": null,
          "new_api": "йствия, получающие parts_for_merge.\n\t\t\t\t\tfor (Lo",
          "old_text": null,
          "new_text": "йствия, получающие parts_for_merge.\n\t\t\t\t\tfor (Lo",
          "old_line_content": "\t\t\t\t  *  кворумную запись следует считать безуспешной.",
          "new_line_content": "\t\t\t\treplica = findReplicaHavingPart(entry.new_part_name, true);",
          "content_same": false
        },
        {
          "line": 3137,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t  * Проблема в том, что номера (sequential нод) элементов очереди в log и в queue не совпадают.",
          "new_line_content": "\tString entry_str = entry.toString();",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": null,
          "new_api": "tor it = queue.",
          "old_text": null,
          "new_text": "tor it = queue.",
          "old_line_content": "\t\t\t\tif (entry.quorum)",
          "new_line_content": "\t\t\tif (replica.empty())",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "росать исключение, чтобы queueTask лишний раз не спала.\n\t\t\t\t\t  */\n\t\t\t\t\tif (replica.empty())\n\t\t\t\t\t{\n\t\t",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\tthrow Exception(\"Logical error: log entry with quorum but type is not GET_PART\", ErrorCodes::LOGICAL_ERROR);",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": null,
          "new_api": "(log, \"No active repli",
          "old_text": null,
          "new_text": "(log, \"No active repli",
          "old_line_content": "\t\t\t\t\t  * - если реплики не стали активными;",
          "new_line_content": "\t\t\t\t\tif (entry.block_id.empty())",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": null,
          "new_api": "<< entry.new_part_name << \". Will fetch merged part instead.\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}",
          "old_text": null,
          "new_text": "<< entry.new_part_name << \". Will fetch merged part instead.\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}",
          "old_line_content": "\t\t\t\t\t  * - если существует узел quorum с этим куском;",
          "new_line_content": "\t\t\t\t\t\tthrow Exception(\"Logical error: log entry with quorum have empty block_id\", ErrorCodes::LOGICAL_ERROR);",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": null,
          "new_api": "* Если ни у какой активной реплики нет куска, и в очереди нет слияний с его участием,\n\t\t\t\t  * проверим, есть ли у любой (активной или неактивной) реплики такой ку",
          "old_text": null,
          "new_text": "* Если ни у какой активной реплики нет куска, и в очереди нет слияний с его участием,\n\t\t\t\t  * проверим, есть ли у любой (активной или неактивной) реплики такой ку",
          "old_line_content": "\t\t\t\t\t  * - установим nonincrement_block_numbers, чтобы разрешить мерджи через номер потерянного куска;",
          "new_line_content": "\t\t\t\t\tLOG_DEBUG(log, \"No active replica has part \" << entry.new_part_name << \" which needs to be written with quorum.\"",
          "content_same": false
        },
        {
          "line": 3156,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tif (0 == entry.znode_name.compare(0, strlen(\"log-\"), \"log-\"))",
          "content_same": false
        },
        {
          "line": 3161,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\tUInt64 log_index = parse<UInt64>(entry.znode_name.substr(entry.znode_name.size() - 10));",
          "content_same": false
        },
        {
          "line": 3172,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t{",
          "new_line_content": "\t\t\tif (!log_pointer.empty() && parse<UInt64>(log_pointer) > log_index)",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": ":error2string(code));\n\t\t\t\tqueue.erase(it++);\n\t\t\t\t++r",
          "old_line_content": "\t\t\t\t\t\tString path = zookeeper_path + \"/replicas/\" + replicas[i] + \"/host\";",
          "new_line_content": "\t\t\t\t\tStrings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "content_same": false
        },
        {
          "line": 3175,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t  */",
          "new_line_content": "\t\t\tevent->wait();",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": null,
          "new_api": "og, \"Removed \"",
          "old_text": null,
          "new_text": "og, \"Removed \" ",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tfor (size_t i = 0, size = replicas.size(); i < size; ++i)",
          "content_same": false
        },
        {
          "line": 3178,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\telse if (0 == entry.znode_name.compare(0, strlen(\"queue-\"), \"queue-\"))",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": null,
          "new_api": "g.\");\n\n\t\t/// Дождемся завер",
          "old_text": null,
          "new_text": "g.\");\n\n\t\t/// Дождемся завер",
          "old_line_content": "\t\t\t\t\t/// Также за это время могла быть создана совсем новая реплика. Но если на старых не появится куска, то на новой его тоже не может быть.",
          "new_line_content": "\t\t\t\t\t\tzookeeper->get(path, &stat);",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": null,
          "new_api": "ераций с кусками, содержащимися в удаляемом диапазоне.",
          "old_text": null,
          "new_text": "ераций с кусками, содержащимися в удаляемом диапазоне.\n\t",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\tops.push_back(new zkutil::Op::Check(path, stat.version));",
          "content_same": false
        },
        {
          "line": 3184,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\tString log_pointer = zookeeper->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\");",
          "content_same": false
        },
        {
          "line": 3186,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\tStrings log_entries = zookeeper->getChildren(zookeeper_path + \"/log\");",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": null,
          "new_api": "taching\" : \"Removing\") << \" parts.\");\n\tsize_t re",
          "old_text": null,
          "new_text": "taching\" : \"Removing\") << \" parts.\");\n\tsize_t re",
          "old_line_content": "\t\t\t\t\t\tString quorum_path = zookeeper_path + \"/quorum/status\";",
          "new_line_content": "\t\t\t\t\treplica = findReplicaHavingPart(entry.new_part_name, true);",
          "content_same": false
        },
        {
          "line": 1143,
          "old_api": null,
          "new_api": "<< part->name);",
          "old_text": null,
          "new_text": "<< part->name);",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tif (replica.empty())",
          "content_same": false
        },
        {
          "line": 3192,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\tif (exists && entry_str == log_entry_str)",
          "new_line_content": "\t\t\tlog_index = parse<UInt64>(log_entry_name.substr(log_entry_name.size() - 10));",
          "content_same": false
        },
        {
          "line": 3194,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\t\tfound = true;",
          "new_line_content": "\t\t\tif (!log_pointer.empty() && log_index < parse<UInt64>(log_pointer))",
          "content_same": false
        },
        {
          "line": 1147,
          "old_api": null,
          "new_api": "renameAndDetachPart",
          "old_text": null,
          "new_text": "ntry.detach)\n\t\t\tdata.renameAndDetachPart(",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\tString quorum_str = zookeeper->get(quorum_path, &quorum_stat);",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": null,
          "new_api": "multi",
          "old_text": null,
          "new_text": "name, ops);\n\t\tzookeeper->multi(ops)",
          "old_line_content": "\t\t\t\t\t\t\tActiveDataPartSet::Part part_info;",
          "new_line_content": "\t\t\t\t\t\tquorum_entry.fromString(quorum_str);",
          "content_same": false
        },
        {
          "line": 3198,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tbool exists = zookeeper->tryGet(zookeeper_path + \"/log/\" + log_entry_name, log_entry_str);",
          "content_same": false
        },
        {
          "line": 1155,
          "old_api": null,
          "new_api": "ch ? \"Detached \" : \"Removed \") <",
          "old_text": null,
          "new_text": "ch ? \"Detached \" : \"Removed \") <",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t\tconst auto partition_str = entry.new_part_name.substr(0, 6);",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": null,
          "new_api": "rt_name << \".\");\n}\n\n\nbool StorageReplicatedMergeTree::executeAtt",
          "old_text": null,
          "new_text": "rt_name << \".\");\n}\n\n\nbool StorageReplicatedMergeTree::executeAtt",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t\tActiveDataPartSet::parsePartName(entry.new_part_name, part_info);",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": null,
          "new_api": "auto zookeeper = getZooKeeper();\n\n\tString source_path = (entry.attach_unreplicated ? \"unreplicated/\" : \"detached/\") + entry.source",
          "old_text": null,
          "new_text": "auto zookeeper = getZooKeeper();\n\n\tString source_path = (entry.attach_unreplicated ? \"unreplicated/\" : \"detached/\") + entry.source",
          "old_line_content": "\t\t\t\t\t\t\t\t\"\",",
          "new_line_content": "\t\t\t\t\t\t\t\tthrow Exception(\"Logical error: log entry with quorum for part covering more than one block number\",",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": null,
          "new_api": "O",
          "old_text": null,
          "new_text": "O(log, \"Attaching part \" <",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t\tauto acl = zookeeper->getDefaultACL();",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": null,
          "new_api": "getFullPath",
          "old_text": null,
          "new_text": "urce_part_name << \" from \" << source_path << \" as \" << entry.new_part_name);\n\n\tif (!Poco::File(data.getFullPath() + source_path).exists())\n\t{\n\t\tLOG_INFO(log, \"No part at \" << source_path << \". Will fetch it instead\"",
          "old_line_content": "\t\t\t\t\t\t\t\tzookeeper_path + \"/quorum/failed_parts/\" + entry.new_part_name,",
          "new_line_content": "\t\t\t\t\t\t\tops.push_back(new zkutil::Op::Create(",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "ath).exists())\n\t{\n\t\tLOG_",
          "old_line_content": "\t\t\t\t\t\t\t\t\"\",",
          "new_line_content": "\t\t\t\t\t\t\t\tzookeeper_path + \"/nonincrement_block_numbers/\" + partition_str + \"/block-\" + padIndex(part_info.left),",
          "content_same": false
        },
        {
          "line": 3216,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t\tString log_pointer = zookeeper->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\", nullptr, event);",
          "content_same": false
        },
        {
          "line": 3217,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\telse",
          "new_line_content": "\t\t\t\tif (!log_pointer.empty() && parse<UInt64>(log_pointer) > log_index)",
          "content_same": false
        },
        {
          "line": 3225,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t/** Второе - найдем соответствующую запись в очереди указанной реплики (replica).",
          "new_line_content": "\t\tthrow Exception(\"Logical error: unexpected name of log node: \" + entry.znode_name, ErrorCodes::LOGICAL_ERROR);",
          "content_same": false
        },
        {
          "line": 3227,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t  * Поэтому, ищем путём сравнения содержимого.",
          "new_line_content": "\tif (!log_node_name.empty())",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": null,
          "new_api": "getPartIfExists",
          "old_text": null,
          "new_text": "rt = unreplicated_data->getPartIfExists(entry.source_part_name);\n\t\tif (unreplicated_part)\n\t\t\tunrepl",
          "old_line_content": "\t\t\t\t\t\t\tif (code == ZOK)",
          "new_line_content": "\t\t\t\t\t\t\t\tops.push_back(new zkutil::Op::Remove(zookeeper_path + \"/blocks/\" + entry.block_id + \"/number\", -1));",
          "content_same": false
        },
        {
          "line": 1181,
          "old_api": null,
          "new_api": "detachPartInPlace",
          "old_text": null,
          "new_text": "a->detachPartInPlace(unreplicated_part);\n\t\telse\n\t\t\tLOG_WARNING(log, \"Unreplicated part \" << entry.sou",
          "old_line_content": "\t\t\t\t\t\t\t{",
          "new_line_content": "\t\t\t\t\t\t\t\tops.push_back(new zkutil::Op::Remove(zookeeper_path + \"/blocks/\" + entry.block_id + \"/checksum\", -1));",
          "content_same": false
        },
        {
          "line": 3228,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t  */",
          "new_line_content": "\t\tLOG_DEBUG(log, \"Looking for node corresponding to \" << log_node_name << \" in \" << replica << \" queue\");",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": null,
          "new_api": "тому что кусок не времен",
          "old_text": null,
          "new_text": "тому что кусок не времен",
          "old_line_content": "\t\t\t\t\t\t\telse if (code == ZBADVERSION || code == ZNONODE || code == ZNODEEXISTS)",
          "new_line_content": "\t\t\t\t\t\t\tauto code = zookeeper->tryMulti(ops);",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": null,
          "new_api": "renameTo",
          "old_text": null,
          "new_text": "о удалять.\n\tpart->renameTo(entry.new_part_name);\n\tpart->name = entry.new_part_nam",
          "old_line_content": "\t\t\t\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\t\t\tLOG_DEBUG(log, \"Marked quorum for part \" << entry.new_part_name << \" as failed.\");",
          "content_same": false
        },
        {
          "line": 3237,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tif (exists && queue_entry_str == entry_str)",
          "new_line_content": "\tStrings queue_entries = zookeeper->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/queue\");",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": null,
          "new_api": "n true;\n}\n\n\nvoid StorageReplicatedMergeTree::queueUpdatingThread()\n{\n\tsetThreadName(\"ReplMTQueueUpd\");\n\n\twhile (!shutdown_called)\n\t{\n\t\ttry",
          "old_text": null,
          "new_text": "n true;\n}\n\n\nvoid StorageReplicatedMergeTree::queueUpdatingThread()\n{\n\tsetThreadName(\"ReplMTQueueUpd\");\n\n\twhile (!shutdown_called)\n\t{\n\t\ttry\n",
          "old_line_content": "\t\t\t\t\t\t{",
          "new_line_content": "\t\t\t\t\t\t\t\tLOG_DEBUG(log, \"State was changed or isn't expected when trying to mark quorum for part \"",
          "content_same": false
        },
        {
          "line": 3243,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\tbool exists = zookeeper->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/queue/\" + entry_name, queue_entry_str);",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": null,
          "new_api": "_event);\n\t\t\tqueue_updating_ev",
          "old_text": null,
          "new_text": "_event);\n\t\t\tqueue_updating_ev",
          "old_line_content": "\t\t\t\t\t\t\t\t<< \" Or it is a bug.\");",
          "new_line_content": "\t\t\t\t\t\t\t\tthrow zkutil::KeeperException(code);",
          "content_same": false
        },
        {
          "line": 1202,
          "old_api": null,
          "new_api": "wakeup",
          "old_text": null,
          "new_text": "il::KeeperException & e)\n\t\t{\n\t\t\tif (e.code == ZINVALIDSTATE)\n\t\t\t\trestarting_thread->wakeup();\n\n\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);\n\n\t\t\tqueue_updating_event->tryWait(ERROR_SLEEP_MS);\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);\n\n\t\t\tqueue_updating_event->tryWait(ERROR_SLEEP_MS);\n\t\t}\n\t}\n\n\tLOG_DEBUG(log, \"Queue updati",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t\tLOG_WARNING(log, \"No active replica has part \" << entry.new_part_name",
          "content_same": false
        },
        {
          "line": 3252,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tif (queue_entry_to_wait_for.empty())",
          "content_same": false
        },
        {
          "line": 3258,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "void StorageReplicatedMergeTree::getStatus(Status & res, bool with_zk_fields)",
          "new_line_content": "\tLOG_DEBUG(log, \"Waiting for \" << queue_entry_to_wait_for << \" to disappear from \" << replica << \" queue\");",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": null,
          "new_api": "ueueTask",
          "old_text": null,
          "new_text": "ueueTask(BackgroundProcessingPool::Context & pool_context)\n{\n\tLogEnt",
          "old_line_content": "\t\t\tif (entry.type == LogEntry::MERGE_PARTS)",
          "new_line_content": "\t\t\t\t\tProfileEvents::increment(ProfileEvents::ReplicatedPartFailedFetches);",
          "content_same": false
        },
        {
          "line": 3261,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tzookeeper->waitForDisappear(zookeeper_path + \"/replicas/\" + replica + \"/queue/\" + queue_entry_to_wait_for);",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": " (LogEntries::iterator it = queue.begin(); it != queue.end(); ++it)\n\t\t\t{\n\t\t\t\tif ((*it)->curr",
          "old_line_content": "\t\t\t/** Если не получилось скачать кусок, нужный для какого-то мерджа, лучше не пытаться получить другие куски для этого мерджа,",
          "new_line_content": "\t\t\tfetchPart(entry.new_part_name, zookeeper_path + \"/replicas/\" + replica, false, entry.quorum);",
          "content_same": false
        },
        {
          "line": 3267,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tstd::lock_guard<std::mutex> lock(queue_mutex);",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": null,
          "new_api": "uteLogEntry",
          "old_text": null,
          "new_text": "uteLogEntry(**it, (*it)->postpone_reason))\n\t\t\t\t{\n\t\t\t\t\tentry = *it;\n\t\t\t",
          "old_line_content": "\t\t\t  */",
          "new_line_content": "\t\t\t\tProfileEvents::increment(ProfileEvents::ReplicatedPartFetchesOfMerged);",
          "content_same": false
        },
        {
          "line": 3271,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tres.is_session_expired = !zookeeper || zookeeper->expired();",
          "content_same": false
        },
        {
          "line": 3275,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tres.inserts_oldest_time = 0;",
          "new_line_content": "\t\tres.future_parts = future_parts.size();",
          "content_same": false
        },
        {
          "line": 3276,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tres.merges_oldest_time = 0;",
          "new_line_content": "\t\tres.queue_size = queue.size();",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": null,
          "new_api": "}\n\tcatch (const Exception",
          "old_text": null,
          "new_text": "}\n\tcatch (const Exception ",
          "old_line_content": "\t\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\tif (std::find((*it)->parts_to_merge.begin(), (*it)->parts_to_merge.end(), entry.new_part_name)",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": null,
          "new_api": "es::NO_REPLICA_HAS_PART)",
          "old_text": null,
          "new_text": "es::NO_REPLICA_HAS_PART)\n\t",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\t\t!= (*it)->parts_to_merge.end())",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "code() == ErrorCodes::A",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tif (!parts_for_merge.empty())",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": null,
          "new_api": "xception",
          "old_text": null,
          "new_text": "xception(__",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tfor (LogEntries::iterator it = queue.begin(); it != queue.end();)",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": null,
          "new_api": "notify_all",
          "old_text": null,
          "new_text": "entry->execution_complete.notify_all();\n\n\tif",
          "old_line_content": "\t\t\t\t\t  *  что его все померджили и удалили. Не будем бросать исключение, чтобы queueTask лишний раз не спала.",
          "new_line_content": "\t\t\t\t\t\t\t&& parts_for_merge.count((*it0)->new_part_name))",
          "content_same": false
        },
        {
          "line": 3316,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\tres.parts_to_check = parts_to_check_set.size();",
          "content_same": false
        },
        {
          "line": 1270,
          "old_api": null,
          "new_api": "eed_pull = true",
          "old_text": null,
          "new_text": "eed_pull = true",
          "old_line_content": "\t\t\t\t/** Если ни у какой активной реплики нет куска, и в очереди нет слияний с его участием,",
          "new_line_content": "\t\t\t\t\tif (replica.empty())",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": null,
          "new_api": "ного времени тратиться на определение, можно ли мерджить два рядом стоящих куска.\n\t  * Два рядом стоящих к",
          "old_text": null,
          "new_text": "ного времени тратиться на определение, можно ли мерджить два рядом стоящих куска.\n\t  * Два рядом стоящих к",
          "old_line_content": "\t\t\t\t  */",
          "new_line_content": "\t\t\t\t\t\tLOG_INFO(log, \"No active replica has part \" << entry.new_part_name << \". Will fetch merged part instead.\");",
          "content_same": false
        },
        {
          "line": 1280,
          "old_api": null,
          "new_api": "рджить.\n\t  *",
          "old_text": null,
          "new_text": "рджить.\n\t  *\n\t ",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tif (replica.empty())",
          "content_same": false
        },
        {
          "line": 1281,
          "old_api": null,
          "new_api": "ользуемся утверждением, что если пару ку",
          "old_text": null,
          "new_text": "ользуемся утверждением, что если пару ку",
          "old_line_content": "\t\t\tthrow;",
          "new_line_content": "\t\t\t\t\tenqueuePartForCheck(entry.new_part_name);",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": null,
          "new_api": "мердж ещё не запланирован,\n\t  *  то и сейча",
          "old_text": null,
          "new_text": "мердж ещё не запланирован,\n\t  *  то и сейча",
          "old_line_content": "\treturn true;",
          "new_line_content": "\t\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 3333,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\tauto log_entries = zookeeper->getChildren(zookeeper_path + \"/log\");",
          "content_same": false
        },
        {
          "line": 3345,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tfor (const String & replica : all_replicas)",
          "new_line_content": "\t\tString log_pointer_str = zookeeper->get(replica_path + \"/log_pointer\");",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": null,
          "new_api": "ARTITION и зат",
          "old_text": null,
          "new_text": "ARTITION и зат",
          "old_line_content": "",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": null,
          "new_api": "TTACH PARTITION.\n\t  */\n\tstd::set<std::pair<std::string, std::string>> memoized_parts_that_could_be_merged;",
          "old_text": null,
          "new_text": "TTACH PARTITION.\n\t  */\n\tstd::set<std::pair<std::string, std::string>> memoized_parts_that_could_be_merged;",
          "old_line_content": "\t\tstd::unique_lock<std::mutex> lock(queue_mutex);",
          "new_line_content": "\tLOG_INFO(log, (entry.detach ? \"Detaching\" : \"Removing\") << \" parts inside \" << entry.new_part_name << \".\");",
          "content_same": false
        },
        {
          "line": 3348,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t}",
          "new_line_content": "\t\tauto all_replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "content_same": false
        },
        {
          "line": 3349,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "}",
          "new_line_content": "\t\tres.total_replicas = all_replicas.size();",
          "content_same": false
        },
        {
          "line": 3353,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "{",
          "new_line_content": "\t\t\tif (zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\"))",
          "content_same": false
        },
        {
          "line": 3361,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "}",
          "new_line_content": "\tres.clear();",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": null,
          "new_api": "g month_name = left->n",
          "old_text": null,
          "new_text": "g month_name = left->n",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\t\tto_wait.push_back(*it);",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": null,
          "new_api": "auto zookeeper = getZooKeeper();\n\n\t\t/// Нельзя сливать куски, ср",
          "old_text": null,
          "new_text": "\t\tauto zookeeper = getZooKeeper();\n\n\t\t/// Нельзя сливать куски, ср",
          "old_line_content": "\t\t\telse",
          "new_line_content": "\t\t\t\tauto code = zookeeper->tryRemove(replica_path + \"/queue/\" + (*it)->znode_name);",
          "content_same": false
        },
        {
          "line": 1317,
          "old_api": null,
          "new_api": "для которого неудовлетворён кворум.\n\t\t/// Замечание: теоретически, это можно было бы разрешить. Но это сделает логику более сложной.",
          "old_text": null,
          "new_text": " для которого неудовлетворён кворум.\n\t\t/// Замечание: теоретически, это можно было бы разрешить. Но это сделает логику более сложной.\n\t\t",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\t\t\tLOG_INFO(log, \"Couldn't remove \" << replica_path + \"/queue/\" + (*it)->znode_name << \": \"",
          "content_same": false
        },
        {
          "line": 1318,
          "old_api": null,
          "new_api": "о это сделает логику более сложной.",
          "old_text": null,
          "new_text": "о это сделает логику более сложной.\n\t",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t<< zkutil::ZooKeeper::error2string(code));",
          "content_same": false
        },
        {
          "line": 3365,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "{",
          "new_line_content": "\tres.reserve(queue.size());",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": null,
          "new_api": "fromString",
          "old_text": null,
          "new_text": "atus\", quorum_node_value))\n\t\t{\n\t\t\tReplicatedMergeTreeQuorumEntry quorum_entry;\n\t\t\tquorum_entry.fromString(quorum_node_value);\n\n\t\t\tActiveDataPartSet::Par",
          "old_line_content": "",
          "new_line_content": "\t\tLOG_DEBUG(log, \"Removed \" << removed_entries << \" entries from queue. \"",
          "content_same": false
        },
        {
          "line": 3374,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "{",
          "new_line_content": "\t\tthrow Exception(\"Table was shutted down or is in readonly mode.\", ErrorCodes::TABLE_IS_READ_ONLY);",
          "content_same": false
        },
        {
          "line": 3376,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\trestarting_thread->getReplicaDelays(out_absolute_delay, out_relative_delay);",
          "content_same": false
        },
        {
          "line": 3382,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 3384,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tString partition_str = MergeTreeData::getMonthName(partition);",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": null,
          "new_api": "оответствуют никаки",
          "old_text": null,
          "new_text": "оответствуют никаки",
          "old_line_content": "",
          "new_line_content": "\tauto parts = data.getDataParts();",
          "content_same": false
        },
        {
          "line": 3387,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t  */",
          "new_line_content": "\tif (from.back() == '/')",
          "content_same": false
        },
        {
          "line": 3388,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\tPoco::DirectoryIterator dir_end;",
          "new_line_content": "\t\tfrom.resize(from.size() - 1);",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": null,
          "new_api": "{\n\t\t\tString path1 = zookeeper_path +",
          "old_text": null,
          "new_text": "{\n\t\t\tString path1 = zookeeper_path +          ",
          "old_line_content": "\t\tzkutil::Ops ops;",
          "new_line_content": "\t\tLOG_DEBUG(log, \"Removing part \" << part->name);",
          "content_same": false
        },
        {
          "line": 1348,
          "old_api": null,
          "new_api": "nZooKeeper::check(path1, *zook",
          "old_text": null,
          "new_text": "nZooKeeper::check(path1, *zook",
          "old_line_content": "\t\tif (!entry.detach)",
          "new_line_content": "\t\t\tdata.renameAndDetachPart(part);",
          "content_same": false
        },
        {
          "line": 3396,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t/// Оставим только активные реплики.",
          "new_line_content": "\tfor (Poco::DirectoryIterator dir_it{data.getFullPath() + \"detached/\"}; dir_it != dir_end; ++dir_it)",
          "content_same": false
        },
        {
          "line": 3397,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\tzkutil::Strings active_replicas;",
          "new_line_content": "\t\tif (0 == dir_it.name().compare(0, partition_str.size(), partition_str))",
          "content_same": false
        },
        {
          "line": 1351,
          "old_api": null,
          "new_api": "kInZooKeeper::ABANDONED &&\n\t\t\t\tAbandonab",
          "old_text": null,
          "new_text": "kInZooKeeper::ABANDONED &&\n\t\t\t\tAbandonab",
          "old_line_content": "",
          "new_line_content": "\t\tremovePartFromZooKeeper(part->name, ops);",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": null,
          "new_api": "ed && is_leader_node)\n\t{\n\t\tbool suc",
          "old_text": null,
          "new_text": "ed && is_leader_node)\n\t{\n\t\tbool suc",
          "old_line_content": "bool StorageReplicatedMergeTree::executeAttachPart(const StorageReplicatedMergeTree::LogEntry & entry)",
          "new_line_content": "\t\t\tdata.replaceParts({part}, {}, true);",
          "content_same": false
        },
        {
          "line": 1359,
          "old_api": null,
          "new_api": "false;\n\n\t\ttry\n\t\t{\n\t\t\tstd::lock_guard<std::mutex> merge_selecting_lock(merge_selecting_mutex);\n\n\t\t\tif (need_pull)\n\t\t\t{\n\t\t\t\t/",
          "old_text": null,
          "new_text": "false;\n\n\t\ttry\n\t\t{\n\t\t\tstd::lock_guard<std::mutex> merge_selecting_lock(merge_selecting_mutex);\n\n\t\t\tif (need_pull)\n\t\t\t{\n\t\t\t\t/",
          "old_line_content": "",
          "new_line_content": "\tLOG_INFO(log, (entry.detach ? \"Detached \" : \"Removed \") << removed_parts << \" parts inside \" << entry.new_part_name << \".\");",
          "content_same": false
        },
        {
          "line": 3408,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t  * Это реплика с максимальным log_pointer, затем с минимальным размером queue.",
          "new_line_content": "\t\tif (zookeeper->exists(from + \"/replicas/\" + replica + \"/is_active\"))",
          "content_same": false
        },
        {
          "line": 3409,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t  * NOTE Это не совсем лучший критерий. Для скачивания старых партиций это не имеет смысла,",
          "new_line_content": "\t\t\tactive_replicas.push_back(replica);",
          "content_same": false
        },
        {
          "line": 3411,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t  * NOTE Разумеется, здесь есть data race-ы. Можно решить ретраями.",
          "new_line_content": "\tif (active_replicas.empty())",
          "content_same": false
        },
        {
          "line": 3412,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t  */",
          "new_line_content": "\t\tthrow Exception(\"No active replicas for shard \" + from, ErrorCodes::NO_ACTIVE_REPLICAS);",
          "content_same": false
        },
        {
          "line": 1365,
          "old_api": null,
          "new_api": "rts).\n\t\t\t\tpull",
          "old_text": null,
          "new_text": "rts).\n\t\t\t\tpull",
          "old_line_content": "\t{",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": null,
          "new_api": "* Если их больше половины от размера пула потоков для мерджа, то можно мерджить только мелкие куски.\n\t\t\t  */",
          "old_text": null,
          "new_text": "\n\t\t\t  * Если их больше половины от размера пула потоков для мерджа, то можно мерджить только мелкие куски.\n\t\t\t  */\n\t\t\t",
          "old_line_content": "",
          "new_line_content": "\tLOG_INFO(log, \"Attaching part \" << entry.source_part_name << \" from \" << source_path << \" as \" << entry.new_part_name);",
          "content_same": false
        },
        {
          "line": 1373,
          "old_api": null,
          "new_api": "getCounter",
          "old_text": null,
          "new_text": "merges_current = background_pool.getCounter(\"replicated big merges\");\n\t\t",
          "old_line_content": "\tzkutil::Ops ops;",
          "new_line_content": "\t\tLOG_INFO(log, \"No part at \" << source_path << \". Will fetch it instead\");",
          "content_same": false
        },
        {
          "line": 1377,
          "old_api": null,
          "new_api": "ig_merges = background_pool.get",
          "old_text": null,
          "new_text": "ig_merges = background_pool.get",
          "old_line_content": "\t{",
          "new_line_content": "\tLOG_DEBUG(log, \"Checking data\");",
          "content_same": false
        },
        {
          "line": 3428,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tif (log_pointer > max_log_pointer",
          "new_line_content": "\t\tString log_pointer_str = zookeeper->get(current_replica_path + \"/log_pointer\");",
          "content_same": false
        },
        {
          "line": 1381,
          "old_api": null,
          "new_api": "rrent < max_number_of_big_merges)\n\t\t\t{\n\t\t\t\tstd::lock_guard",
          "old_text": null,
          "new_text": "rrent < max_number_of_big_merges)\n\t\t\t{\n\t\t\t\tstd::lock_guard",
          "old_line_content": "\t\telse",
          "new_line_content": "\tcheckPartAndAddToZooKeeper(part, ops, entry.new_part_name);",
          "content_same": false
        },
        {
          "line": 3429,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\t|| (log_pointer == max_log_pointer && queue_size < min_queue_size))",
          "new_line_content": "\t\tInt64 log_pointer = log_pointer_str.empty() ? 0 : parse<UInt64>(log_pointer_str);",
          "content_same": false
        },
        {
          "line": 3432,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\tmin_queue_size = queue_size;",
          "new_line_content": "\t\tzookeeper->get(current_replica_path + \"/queue\", &stat);",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": null,
          "new_api": "queued < max_number_of_big_merges)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (",
          "old_text": null,
          "new_text": "queued < max_number_of_big_merges)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (",
          "old_line_content": "\t/// NOTE: Не можем использовать renameTempPartAndAdd, потому что кусок не временный - если что-то пойдет не так, его не нужно удалять.",
          "new_line_content": "\t\t\tunreplicated_data->detachPartInPlace(unreplicated_part);",
          "content_same": false
        },
        {
          "line": 1389,
          "old_api": null,
          "new_api": "& name : entry->parts_to_merge)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMergeTreeData::DataPartPtr part = data.g",
          "old_text": null,
          "new_text": " & name : entry->parts_to_merge)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMergeTreeData::DataPartPtr part = data.g",
          "old_line_content": "\tpart->name = entry.new_part_name;",
          "new_line_content": "\t\t\tLOG_WARNING(log, \"Unreplicated part \" << entry.source_part_name << \" is already detached\");",
          "content_same": false
        },
        {
          "line": 1395,
          "old_api": null,
          "new_api": "}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool onl",
          "old_text": null,
          "new_text": "\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool onl",
          "old_line_content": "",
          "new_line_content": "\tpart->renameTo(entry.new_part_name);",
          "content_same": false
        },
        {
          "line": 3444,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tif (best_replica.empty())",
          "content_same": false
        },
        {
          "line": 3445,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t/// Выясним, какие куски есть на лучшей реплике.",
          "new_line_content": "\t\tthrow Exception(\"Logical error: cannot choose best replica.\", ErrorCodes::LOGICAL_ERROR);",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": null,
          "new_api": "ges_current || merges",
          "old_text": null,
          "new_text": "ges_current || merges",
          "old_line_content": "\treturn true;",
          "new_line_content": "\tdata.attachPart(part);",
          "content_same": false
        },
        {
          "line": 3447,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t/** Пытаемся скачать эти куски.",
          "new_line_content": "\tLOG_INFO(log, \"Found \" << replicas.size() << \" replicas, \" << active_replicas.size() << \" of them are active.\"",
          "content_same": false
        },
        {
          "line": 1401,
          "old_api": null,
          "new_api": "ued)\n\t\t\t\tLOG_TRACE(log, \"Currently executing big merges: \" << bi",
          "old_text": null,
          "new_text": "ued)\n\t\t\t\tLOG_TRACE(log, \"Currently executing big merges: \" << bi",
          "old_line_content": "",
          "new_line_content": "\tLOG_INFO(log, \"Finished attaching part \" << entry.new_part_name);",
          "content_same": false
        },
        {
          "line": 1404,
          "old_api": null,
          "new_api": "ax number of big merg",
          "old_text": null,
          "new_text": "ax number of big merg",
          "old_line_content": "{",
          "new_line_content": "\tcontext.resetCaches();",
          "content_same": false
        },
        {
          "line": 3464,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tStrings parts_to_fetch;",
          "new_line_content": "\t\t\tLOG_INFO(log, \"Some of parts (\" << missing_parts.size() << \") are missing. Will try to fetch covering parts.\");",
          "content_same": false
        },
        {
          "line": 1418,
          "old_api": null,
          "new_api": "er",
          "old_text": null,
          "new_text": "er();\n\n\t\t\t\tif (merges_queued >= data.",
          "old_line_content": "",
          "new_line_content": "\t\t\tpullLogsToQueue(queue_updating_event);",
          "content_same": false
        },
        {
          "line": 3467,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\tthrow Exception(\"Too much retries to fetch parts from \" + best_replica_path, ErrorCodes::TOO_MUCH_RETRIES_TO_FETCH_PARTS);",
          "content_same": false
        },
        {
          "line": 3469,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\tStrings parts = zookeeper->getChildren(best_replica_path + \"/parts\");",
          "content_same": false
        },
        {
          "line": 1424,
          "old_api": null,
          "new_api": "is greater than max_replic",
          "old_text": null,
          "new_text": " is greater than max_replic",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\t\trestarting_thread->wakeup();",
          "content_same": false
        },
        {
          "line": 1426,
          "old_api": null,
          "new_api": "erges_in_queue (\"\n\t\t\t\t\t\t<< data.settings.ma",
          "old_text": null,
          "new_text": "erges_in_queue (\"\n\t\t\t\t\t\t<< data.settings.ma",
          "old_line_content": "",
          "new_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 3475,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\t\tparts_to_fetch = active_parts_set.getParts();",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": null,
          "new_api": "icated_merges_in_queue << \"), so won't select",
          "old_text": null,
          "new_text": "icated_merges_in_queue << \"), so won't select",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tqueue_updating_event->tryWait(ERROR_SLEEP_MS);",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": null,
          "new_api": "break;\n\t\t\t\t}\n\n\t\t\t\tMergeTreeData::DataPart",
          "old_text": null,
          "new_text": "\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tMergeTreeData::DataPart",
          "old_line_content": "}",
          "new_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 3480,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\t\tif (0 == part.compare(0, partition_str.size(), partition_str))",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": null,
          "new_api": "r parts;\n\n\t\t\t\tString merged_name;\n\n\t\t\t\tsize_t",
          "old_text": null,
          "new_text": "r parts;\n\n\t\t\t\tString merged_name;\n\n\t\t\t\tsize_t",
          "old_line_content": "",
          "new_line_content": "\t\t\tqueue_updating_event->tryWait(ERROR_SLEEP_MS);",
          "content_same": false
        },
        {
          "line": 3481,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\telse",
          "new_line_content": "\t\t\t\t\tparts_to_fetch_partition.push_back(part);",
          "content_same": false
        },
        {
          "line": 3483,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\tfor (const String & missing_part : missing_parts)",
          "new_line_content": "\t\t\tparts_to_fetch = std::move(parts_to_fetch_partition);",
          "content_same": false
        },
        {
          "line": 1438,
          "old_api": null,
          "new_api": "= DiskSpaceMonitor::getUnreservedFreeSpace(full",
          "old_text": null,
          "new_text": " = DiskSpaceMonitor::getUnreservedFreeSpace(full",
          "old_line_content": "",
          "new_line_content": "\tLOG_DEBUG(log, \"Queue updating thread finished\");",
          "content_same": false
        },
        {
          "line": 3492,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tString containing_part = active_parts_set.getContainingPart(missing_part);",
          "content_same": false
        },
        {
          "line": 3494,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tparts_to_fetch.push_back(containing_part);",
          "content_same": false
        },
        {
          "line": 3496,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tfor (const String & part : parts_to_fetch)",
          "new_line_content": "\t\t\t\t\tLOG_WARNING(log, \"Part \" << missing_part << \" on replica \" << best_replica_path << \" has been vanished.\");",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": null,
          "new_api": ", only_small,",
          "old_text": null,
          "new_text": ", only_small,",
          "old_line_content": "",
          "new_line_content": "\t\tbool empty = queue.empty();",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": null,
          "new_api": "onst auto &",
          "old_text": null,
          "new_text": "onst auto &",
          "old_line_content": "\t\t\t\t\tentry = *it;",
          "new_line_content": "\t\t\tfor (LogEntries::iterator it = queue.begin(); it != queue.end(); ++it)",
          "content_same": false
        },
        {
          "line": 3502,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\t\tcatch (const DB::Exception & e)",
          "new_line_content": "\t\tmissing_parts.clear();",
          "content_same": false
        },
        {
          "line": 1460,
          "old_api": null,
          "new_api": ">name))\n\t\t\t\t\t{\n\t\t\t\t\t\tall_in_z",
          "old_text": null,
          "new_text": ">name))\n\t\t\t\t\t{\n\t\t\t\t\t\tall_in_z",
          "old_line_content": "\t\t\t\telse",
          "new_line_content": "\t\t\t\t\tentry->tagPartAsFuture(*this);",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": null,
          "new_api": "(part->mod",
          "old_text": null,
          "new_text": " (part->mod",
          "old_line_content": "\t\t\t\t{",
          "new_line_content": "\t\t\t\t\tqueue.splice(queue.end(), queue, it);",
          "content_same": false
        },
        {
          "line": 3511,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tif (e.code() != ErrorCodes::RECEIVED_ERROR_FROM_REMOTE_IO_SERVER)",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": null,
          "new_api": "\"Part",
          "old_text": null,
          "new_text": " \"Part ",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\t\t\tentry->last_attempt_time = time(0);",
          "content_same": false
        },
        {
          "line": 3514,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "}",
          "new_line_content": "\t\t\t\tLOG_INFO(log, e.displayText());",
          "content_same": false
        },
        {
          "line": 3515,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tmissing_parts.push_back(part);",
          "content_same": false
        },
        {
          "line": 1477,
          "old_api": null,
          "new_api": "locally but not in ZooKeeper.\"\n\t\t\t\t\t\t\t\t<<",
          "old_text": null,
          "new_text": " locally but not in ZooKeeper.\"\n\t\t\t\t\t\t\t\t<< ",
          "old_line_content": "\tbool success = false;",
          "new_line_content": "\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 3527,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "}",
          "new_line_content": "\tString prefix = partition.getType() == Field::Types::UInt64",
          "content_same": false
        },
        {
          "line": 3528,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\t? toString(partition.get<UInt64>())",
          "content_same": false
        },
        {
          "line": 3529,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\t: partition.safeGet<String>();",
          "content_same": false
        },
        {
          "line": 3531,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tdata.freezePartition(prefix);",
          "content_same": false
        },
        {
          "line": 3533,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\tunreplicated_data->freezePartition(prefix);",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": null,
          "new_api": "ry.source_repl",
          "old_text": null,
          "new_text": "ry.source_repl",
          "old_line_content": "\t\t\t\tsuccess = true;",
          "new_line_content": "\t\t\t\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 1494,
          "old_api": null,
          "new_api": ";\n\t\t\t\tentry.new_part_name = merged_name;\n\t\t\t\tentry.create_time = t",
          "old_text": null,
          "new_text": ";\n\t\t\t\tentry.new_part_name = merged_name;\n\t\t\t\tentry.create_time = t",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\tauto code = zookeeper->tryRemove(replica_path + \"/queue/\" + entry->znode_name);",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "& part : parts)\n\t\t\t\t\tentry.parts_to_merge.push_back(part->name);\n\n\t\t\t\tneed_pull = true;\n\n\t\t\t\tzookeeper->create(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::Creat",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\t\t\tLOG_ERROR(log, \"Couldn't remove \" << replica_path + \"/queue/\" + entry->znode_name << \": \"",
          "content_same": false
        },
        {
          "line": 1505,
          "old_api": null,
          "new_api": "ubstr",
          "old_text": null,
          "new_text": "ubstr(0, 6);\n\t\t\t\tfor (si",
          "old_line_content": "\t{",
          "new_line_content": "\t\t\tsaved_exception = std::current_exception();",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": null,
          "new_api": "ки о нес",
          "old_text": null,
          "new_text": "ки о нес",
          "old_line_content": "\t\t\t/// Прерванный мердж - не ошибка.",
          "new_line_content": "\t\tif (e.code() == ErrorCodes::NO_REPLICA_HAS_PART)",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": null,
          "new_api": "umber));",
          "old_text": null,
          "new_text": "umber));\n\t\t\t\t\t\t",
          "old_line_content": "\t\telse",
          "new_line_content": "\t\t\tLOG_INFO(log, e.displayText());",
          "content_same": false
        },
        {
          "line": 1518,
          "old_api": null,
          "new_api": "ve",
          "old_text": null,
          "new_text": "ve(zooke",
          "old_line_content": "\t}",
          "new_line_content": "\t\telse if (e.code() == ErrorCodes::ABORTED)",
          "content_same": false
        },
        {
          "line": 1524,
          "old_api": null,
          "new_api": "lse);\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t\ttryLogCurren",
          "old_text": null,
          "new_text": "lse);\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t\ttryLogCurren",
          "old_line_content": "\tentry->future_part_tagger = nullptr;",
          "new_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 1528,
          "old_api": null,
          "new_api": "CTION__);\n\t\t}\n\n\t\tif (shutdown_called || !is",
          "old_text": null,
          "new_text": "CTION__);\n\t\t}\n\n\t\tif (shutdown_called || !is",
          "old_line_content": "\tentry->currently_executing = false;",
          "new_line_content": "\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 1537,
          "old_api": null,
          "new_api": "rageReplicatedMergeTree::alterThread()",
          "old_text": null,
          "new_text": "rageReplicatedMergeTree::alterThread()",
          "old_line_content": "\t\t{",
          "new_line_content": "\tentry->execution_complete.notify_all();",
          "content_same": false
        },
        {
          "line": 1543,
          "old_api": null,
          "new_api": "писания отлич",
          "old_text": null,
          "new_text": "писания отлич",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\tfor (LogEntries::iterator it = queue.end(); it != queue.begin();)",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": null,
          "new_api": "и запомненная в",
          "old_text": null,
          "new_text": "и запомненная в",
          "old_line_content": "\treturn !was_exception;",
          "new_line_content": "\t\t\t\tqueue.erase(it);",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": null,
          "new_api": "елом, ничего не меняет.\n\t\t\t  *",
          "old_text": null,
          "new_text": "елом, ничего не меняет.\n\t\t\t  * ",
          "old_line_content": "\t  *",
          "new_line_content": "\tsetThreadName(\"ReplMTMergeSel\");",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": null,
          "new_api": "уру таблицы локально.\n\t\t\t\tif (changed_versi",
          "old_text": null,
          "new_text": "уру таблицы локально.\n\t\t\t\tif (changed_versi",
          "old_line_content": "",
          "new_line_content": "\t\tif (virtual_parts.getContainingPart(left->name) != left->name ||",
          "content_same": false
        },
        {
          "line": 1587,
          "old_api": null,
          "new_api": ";\n\n\t\t\t\t\tauto table_lock = lockStructure",
          "old_text": null,
          "new_text": ";\n\n\t\t\t\t\tauto table_lock = lockStructure",
          "old_line_content": "\t\t/// Нельзя сливать куски, среди которых находится кусок, для которого неудовлетворён кворум.",
          "new_line_content": "\t\tauto key = std::make_pair(left->name, right->name);",
          "content_same": false
        },
        {
          "line": 1588,
          "old_api": null,
          "new_api": "();\n\n\t\t\t\t\tconst auto columns_changed = columns",
          "old_text": null,
          "new_text": "();\n\n\t\t\t\t\tconst auto columns_changed = columns",
          "old_line_content": "\t\t/// Замечание: теоретически, это можно было бы разрешить. Но это сделает логику более сложной.",
          "new_line_content": "\t\tif (memoized_parts_that_could_be_merged.count(key))",
          "content_same": false
        },
        {
          "line": 1591,
          "old_api": null,
          "new_api": "const auto materi",
          "old_text": null,
          "new_text": "\n\t\t\t\t\tconst auto materi",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\tString month_name = left->name.substr(0, 6);",
          "content_same": false
        },
        {
          "line": 1592,
          "old_api": null,
          "new_api": "d = materializ",
          "old_text": null,
          "new_text": "d = materializ",
          "old_line_content": "\t\t\tReplicatedMergeTreeQuorumEntry quorum_entry;",
          "new_line_content": "\t\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 1597,
          "old_api": null,
          "new_api": "r. Applying changes locally.\");\n\n\t\t\t\t\t\tInterpreterAlterQuery::updateMet",
          "old_text": null,
          "new_text": "r. Applying changes locally.\");\n\n\t\t\t\t\t\tInterpreterAlterQuery::updateMet",
          "old_line_content": "",
          "new_line_content": "\t\tif (zookeeper->tryGet(zookeeper_path + \"/quorum/status\", quorum_node_value))",
          "content_same": false
        },
        {
          "line": 1600,
          "old_api": null,
          "new_api": "ized_columns, alias_columns, column_defaul",
          "old_text": null,
          "new_text": "ized_columns, alias_columns, column_defaul",
          "old_line_content": "",
          "new_line_content": "\t\t\tquorum_entry.fromString(quorum_node_value);",
          "content_same": false
        },
        {
          "line": 1603,
          "old_api": null,
          "new_api": "setColumnsList",
          "old_text": null,
          "new_text": "\t\t\t\t{\n\t\t\t\t\t\t\tdata.setColumnsList(columns);\n\n\t\t\t\t\t\t\tif (unreplicated",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tActiveDataPartSet::parsePartName(quorum_entry.part_name, part_info);",
          "content_same": false
        },
        {
          "line": 1606,
          "old_api": null,
          "new_api": "s);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (materialized_columns_changed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis->materialized_columns = materialized_colu",
          "old_text": null,
          "new_text": "s);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (materialized_columns_changed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis->materialized_columns = materialized_colu",
          "old_line_content": "\t\t/// Номера до RESERVED_BLOCK_NUMBERS всегда не соответствуют никаким блокам.",
          "new_line_content": "\t\t\t\tthrow Exception(\"Logical error: part written with quorum covers more than one block numbers\", ErrorCodes::LOGICAL_ERROR);",
          "content_same": false
        },
        {
          "line": 1614,
          "old_api": null,
          "new_api": "lied changes to table.\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{",
          "old_text": null,
          "new_text": "lied changes to table.\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{",
          "old_line_content": "\t\t\t\treturn false;",
          "new_line_content": "\t\tfor (Int64 number = std::max(RESERVED_BLOCK_NUMBERS, left->right + 1); number <= right->left - 1; ++number)",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": null,
          "new_api": "получить список",
          "old_text": null,
          "new_text": "получить список ",
          "old_line_content": "",
          "new_line_content": "\t\t\tString path1 = zookeeper_path +              \"/block_numbers/\" + month_name + \"/block-\" + padIndex(number);",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": null,
          "new_api": "version = stat.version;\n\t\t\t\t}\n\n\t\t\t\t/// Обновим куски",
          "old_text": null,
          "new_text": "version = stat.version;\n\t\t\t\t}\n\n\t\t\t\t/// Обновим куски",
          "old_line_content": "\t};",
          "new_line_content": "\t\t\tif (AbandonableLockInZooKeeper::check(path1, *zookeeper) != AbandonableLockInZooKeeper::ABANDONED &&",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": null,
          "new_api": "{\n\t\t\t\t\tauto table_lock = lockStructure(false);",
          "old_text": null,
          "new_text": "\n\t\t\t\t{\n\t\t\t\t\tauto table_lock = lockStructure(false);\n",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tAbandonableLockInZooKeeper::check(path2, *zookeeper) != AbandonableLockInZooKeeper::ABANDONED)",
          "content_same": false
        },
        {
          "line": 1624,
          "old_api": null,
          "new_api": "int changed_parts = 0;\n\n\t\t\t\t\tif (!changed_",
          "old_text": null,
          "new_text": "\t\t\t\t\tint changed_parts = 0;\n\n\t\t\t\t\tif (!changed_",
          "old_line_content": "",
          "new_line_content": "\t\tmemoized_parts_that_could_be_merged.insert(key);",
          "content_same": false
        },
        {
          "line": 1647,
          "old_api": null,
          "new_api": "+ part->name + \"/checksums\"",
          "old_text": null,
          "new_text": "+ part->name + \"/checksums\"",
          "old_line_content": "\t\t\tif (big_merges_current < max_number_of_big_merges)",
          "new_line_content": "\t\t\tauto & background_pool = context.getBackgroundPool();",
          "content_same": false
        },
        {
          "line": 1649,
          "old_api": null,
          "new_api": "multi",
          "old_text": null,
          "new_text": "oString(), -1));\n\t\t\t\t\t\tzookeeper->multi(ops);\n\n\t\t\t\t",
          "old_line_content": "\t\t\t\tstd::lock_guard<std::mutex> lock(queue_mutex);",
          "new_line_content": "\t\t\tsize_t big_merges_current = background_pool.getCounter(\"replicated big merges\");",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": null,
          "new_api": "commit",
          "old_text": null,
          "new_text": "transaction->commit();\n\t\t\t\t\t}\n\n\t\t\t\t\t",
          "old_line_content": "",
          "new_line_content": "\t\t\tsize_t max_number_of_big_merges = background_pool.getNumberOfThreads() / 2;",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": null,
          "new_api": "lumns\", columns_str);\n\n\t\t\t\t\tif (ch",
          "old_text": null,
          "new_text": "lumns\", columns_str);\n\n\t\t\t\t\tif (ch",
          "old_line_content": "\t\t\t\t\t\t\t\t\tbreak;",
          "new_line_content": "\t\t\t\t\t\t\t\tMergeTreeData::DataPartPtr part = data.getActiveContainingPart(name);",
          "content_same": false
        },
        {
          "line": 1686,
          "old_api": null,
          "new_api": "tryWait",
          "old_text": null,
          "new_text": "UNCTION__);\n\n\t\t\tforce_recheck_parts = true;\n\n\t\t\talter_thread_event->tryWait(ERROR_SLEEP_MS);\n\t\t}\n\t}\n\n\tLOG_DEBUG(log, \"Alter thread finished\");\n}\n\n\nvoid StorageReplicatedMergeTree::removePartFromZooKeeper(const String & part_name, zkutil::Ops & ops)\n{\n\tString part_path = replica_path + \"/parts/\" + part_name;\n\n\tops.push",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\t\tLOG_TRACE(log, \"Currently executing big merges: \" << big_merges_current",
          "content_same": false
        },
        {
          "line": 1694,
          "old_api": null,
          "new_api": "ath + \"/checks",
          "old_text": null,
          "new_text": "ath + \"/checks",
          "old_line_content": "\t\t\t\t\tbreak;",
          "new_line_content": "\t\t\t\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "push_back(new zkutil::Op::Remove(part_path, -1));\n}\n\n\nvoid StorageReplicatedMergeTree::removePartAndEnqueueFetch(const String & part_name)\n{\n\tauto zookeeper = getZooKeeper();\n\n\tString part_path = replica_path + \"/parts/\"",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tLOG_TRACE(log, \"Number of queued merges (\" << merges_queued",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": null,
          "new_api": "ime = tryGetPartCreateTime(zookeeper, replica_path,",
          "old_text": null,
          "new_text": "ime = tryGetPartCreateTime(zookeeper, replica_path,",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tsize_t disk_space = DiskSpaceMonitor::getUnreservedFreeSpace(full_path);",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": null,
          "new_api": "og_entry->source_replica = \"\";\n\tlog_entry->new_part_name = part_name;\n\n\tzkutil::Ops ops;\n\tops.",
          "old_text": null,
          "new_text": "og_entry->source_replica = \"\";\n\tlog_entry->new_part_name = part_name;\n\n\tzkutil::Ops ops;\n\tops.",
          "old_line_content": "\t\t\t\tfor (const auto & part : parts)",
          "new_line_content": "\t\t\t\tif (   !merger.selectPartsToMerge(parts, merged_name, disk_space, false, false, only_small, can_merge)",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "new zkutil::Op::Create(\n\t\treplica_path + \"/queue/queue-\", log_entry->toString(), zookeeper->g",
          "old_line_content": "\t\t\t\t{",
          "new_line_content": "\t\t\t\t\t&& !merger.selectPartsToMerge(parts, merged_name, disk_space, true, false, only_small, can_merge))",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": null,
          "new_api": ");\n\t\tqu",
          "old_text": null,
          "new_text": ");\n\t\tqu",
          "old_line_content": "\t\t\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\tif (part->modification_time + MAX_AGE_OF_LOCAL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < time(0))",
          "content_same": false
        },
        {
          "line": 1726,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "_entry);\n\t}\n}\n\n\nvoid StorageReplicatedMergeTree::enqueuePartForCheck(const String & name)\n{\n\tstd::lock_guard<std::mutex> lock(parts_to_check_mutex);\n\n\tif (parts_to_check_set.count(name))\n\t\treturn;\n\tparts_to_check_queue.push_back(name);\n\tparts_to_check_set.inse",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\t\tLOG_WARNING(log, \"Part \" << part->name << \" (that was selected for merge)\"",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": null,
          "new_api": "guard<s",
          "old_text": null,
          "new_text": "guard<s",
          "old_line_content": "\t\t\t\tif (!all_in_zk)",
          "new_line_content": "\t\t\t\t\t\t\t\t<< \" with age \" << (time(0) - part->modification_time)",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "\n\tparts_to_check_event.set();\n}",
          "old_line_content": "\t\t\t\tLogEntry entry;",
          "new_line_content": "\t\t\t\t\t\t\tenqueuePartForCheck(part->name);",
          "content_same": false
        },
        {
          "line": 1748,
          "old_api": null,
          "new_api": "locally. \"\n\t\t\t\"R",
          "old_text": null,
          "new_text": "locally. \"\n\t\t\t\"R",
          "old_line_content": "\t\t\t\t\t{",
          "new_line_content": "\t\t\t\tzookeeper->create(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential);",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": null,
          "new_api": "rtAndEnqueue",
          "old_text": null,
          "new_text": "rtAndEnqueue",
          "old_line_content": "\t\t\t\t\t}",
          "new_line_content": "\t\t\t\tfor (size_t i = 0; i + 1 < parts.size(); ++i)",
          "content_same": false
        },
        {
          "line": 1754,
          "old_api": null,
          "new_api": "Set::parsePartName(part_name, part_info);\n\n\t/** Логик",
          "old_text": null,
          "new_text": "Set::parsePartName(part_name, part_info);\n\n\t/** Логик",
          "old_line_content": "\t\t\t\tsuccess = true;",
          "new_line_content": "\t\t\t\t\tfor (Int64 number = std::max(RESERVED_BLOCK_NUMBERS, parts[i]->right + 1); number <= parts[i + 1]->left - 1; ++number)",
          "content_same": false
        },
        {
          "line": 1756,
          "old_api": null,
          "new_api": "я затем при обра",
          "old_text": null,
          "new_text": "я затем при обра",
          "old_line_content": "\t\t\twhile (false);",
          "new_line_content": "\t\t\t\t\t\tzookeeper->tryRemove(zookeeper_path +              \"/block_numbers/\" + month_name + \"/block-\" + padIndex(number));",
          "content_same": false
        },
        {
          "line": 1757,
          "old_api": null,
          "new_api": "или создаст нов",
          "old_text": null,
          "new_text": " или создаст нов",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\t\t\t\tzookeeper->tryRemove(zookeeper_path + \"/nonincrement_block_numbers/\" + month_name + \"/block-\" + padIndex(number));",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": null,
          "new_api": ", что другие реплики ещё недоделали мердж\n\t\t*   - если",
          "old_text": null,
          "new_text": ", что другие реплики ещё недоделали мердж\n\t\t*   - если ",
          "old_line_content": "void StorageReplicatedMergeTree::alterThread()",
          "new_line_content": "\t\t\tmerge_selecting_event.tryWait(MERGE_SELECTING_SLEEP_MS);",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": null,
          "new_api": "го нет всех составляющих кусков, то признаем кусо",
          "old_text": null,
          "new_text": "го нет всех составляющих кусков, то признаем кусо",
          "old_line_content": "",
          "new_line_content": "\tLOG_DEBUG(log, \"Merge selecting thread finished\");",
          "content_same": false
        },
        {
          "line": 1783,
          "old_api": null,
          "new_api": "репликации.\n\t\t*/\n\n\tLOG_WARN",
          "old_text": null,
          "new_text": " репликации.\n\t\t*/\n\n\tLOG_WARN",
          "old_line_content": "\t\t{",
          "new_line_content": "\tsetThreadName(\"ReplMTAlter\");",
          "content_same": false
        },
        {
          "line": 1814,
          "old_api": null,
          "new_api": "x> lock(queue_",
          "old_text": null,
          "new_text": "x> lock(queue_",
          "old_line_content": "\t\t\tauto & materialized_columns = columns_desc.materialized;",
          "new_line_content": "\t\t\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 1817,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "; it != queue.end();)\n\t\t{\n\t\t\tif ((*it)->new_part_name == part_name)\n\t\t",
          "old_line_content": "",
          "new_line_content": "\t\t\tconst String columns_str = zookeeper->get(zookeeper_path + \"/columns\", &stat, alter_thread_event);",
          "content_same": false
        },
        {
          "line": 1818,
          "old_api": null,
          "new_api": "ve",
          "old_text": null,
          "new_text": "ve(replica_path + \"/queue/\" + (*it)->znode_n",
          "old_line_content": "\t\t\tbool changed_version = (stat.version != columns_version);",
          "new_line_content": "\t\t\tauto columns_desc = ColumnsDescription<true>::parse(columns_str);",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": null,
          "new_api": "отсутствующий кусок в block_numbers, чтобы он н",
          "old_text": null,
          "new_text": "отсутствующий кусок в block_numbers, чтобы он н",
          "old_line_content": "\t\t\t\t/// Если описание столбцов изменилось, обновим структуру таблицы локально.",
          "new_line_content": "\t\t\t\t\tmerge_blocker = std::make_unique<MergeTreeMergeBlocker>(merger);",
          "content_same": false
        },
        {
          "line": 1836,
          "old_api": null,
          "new_api": "ь не можем - если так сделать,\n\t\t*  ZooKeeper зачем-то пропус",
          "old_text": null,
          "new_text": "ь не можем - если так сделать,\n\t\t*  ZooKeeper зачем-то пропус",
          "old_line_content": "\t\t\t\t{",
          "new_line_content": "\t\t\t\t\t\tunreplicated_merge_blocker = std::make_unique<MergeTreeMergeBlocker>(*unreplicated_merger);",
          "content_same": false
        },
        {
          "line": 1844,
          "old_api": null,
          "new_api": "дут делаться сквозь эти отсутствующие куски.\n\t\t*\n\t\t* А ещё, не будем добавлять, если:\n\t\t* - потреб",
          "old_text": null,
          "new_text": "дут делаться сквозь эти отсутствующие куски.\n\t\t*\n\t\t* А ещё, не будем добавлять, если:\n\t\t* - потреб",
          "old_line_content": "\t\t\t\t\tconst auto column_defaults_changed = column_defaults != data.column_defaults;",
          "new_line_content": "\t\t\t\t\tLOG_INFO(log, \"Changed version of 'columns' node in ZooKeeper. Waiting for structure write lock.\");",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": null,
          "new_api": "много (больше 1000) уз",
          "old_text": null,
          "new_text": " много (больше 1000) уз",
          "old_line_content": "\t\t\t\t\tif (columns_changed || materialized_columns_changed || alias_columns_changed ||",
          "new_line_content": "\t\t\t\t\tauto table_lock = lockStructureForAlter();",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": null,
          "new_api": "был при-ATTACH-ен.\n\t\t* NOTE Возможно",
          "old_text": null,
          "new_text": "был при-ATTACH-ен.\n\t\t* NOTE Возможно",
          "old_line_content": "\t\t\t\t\t{",
          "new_line_content": "\t\t\t\t\tconst auto columns_changed = columns != data.getColumnsListNonMaterialized();",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": null,
          "new_api": "createIfNotExists",
          "old_text": null,
          "new_text": "= part_info.left; i <= part_info.right; ++i)\n\t{\n\t\tzookeeper->createIfNotExists(zookeeper_path + \"/nonincrement_block_numbers\", \"\");\n\t\tzookeeper",
          "old_line_content": "\t\t\t\t\t\t\tif (unreplicated_data)",
          "new_line_content": "\t\t\t\t\t\tInterpreterAlterQuery::updateMetadata(database_name, table_name, columns,",
          "content_same": false
        },
        {
          "line": 1863,
          "old_api": null,
          "new_api": "rement_block_numbers/\" + par",
          "old_text": null,
          "new_text": "rement_block_numbers/\" + par",
          "old_line_content": "\t\t\t\t\t\t{",
          "new_line_content": "\t\t\t\t\t\t\tdata.setColumnsList(columns);",
          "content_same": false
        },
        {
          "line": 1866,
          "old_api": null,
          "new_api": "eper::createAbandonedIfNotExists(\n\t\t\tzooke",
          "old_text": null,
          "new_text": "eper::createAbandonedIfNotExists(\n\t\t\tzooke",
          "old_line_content": "\t\t\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\t\t\tunreplicated_data->setColumnsList(columns);",
          "content_same": false
        },
        {
          "line": 1872,
          "old_api": null,
          "new_api": "const String & part_name)\n{\n\tLO",
          "old_text": null,
          "new_text": "const String & part_name)\n{\n\tLO",
          "old_line_content": "\t\t\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\t\tdata.materialized_columns = std::move(materialized_columns);",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": null,
          "new_api": "to part = data.getActive",
          "old_text": null,
          "new_text": "to part = data.getActive",
          "old_line_content": "\t\t\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\t\tdata.alias_columns = std::move(alias_columns);",
          "content_same": false
        },
        {
          "line": 1887,
          "old_api": null,
          "new_api": "роверять, нужен ли нам этот кусок и правил",
          "old_text": null,
          "new_text": "роверять, нужен ли нам этот кусок и правил",
          "old_line_content": "\t\t\t\t\t/// Нужно получить список кусков под блокировкой таблицы, чтобы избежать race condition с мерджем.",
          "new_line_content": "\t\t\t\t\t\tLOG_INFO(log, \"Applied changes to table.\");",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": null,
          "new_api": "(part->name == part_name)\n\t{\n\t\tauto zookeeper = getZooKeeper();\n\t\tauto table_lock = lockStructure(false)",
          "old_text": null,
          "new_text": "(part->name == part_name)\n\t{\n\t\tauto zookeeper = getZooKeeper();\n\t\tauto table_lock = lockStructure(false)",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\tLOG_INFO(log, \"Columns version changed in ZooKeeper, but data wasn't changed. It's like cyclic ALTERs.\");",
          "content_same": false
        },
        {
          "line": 1895,
          "old_api": null,
          "new_api": "ing data of part \"",
          "old_text": null,
          "new_text": "ing data of part \" ",
          "old_line_content": "\t\t\t\t{",
          "new_line_content": "\t\t\t\t\tparts = data.getDataParts();",
          "content_same": false
        },
        {
          "line": 1903,
          "old_api": null,
          "new_api": "+ \"/checksums\"));",
          "old_text": null,
          "new_text": "+ \"/checksums\"));\n\t\t",
          "old_line_content": "\t\t\t\t\tif (!changed_version)",
          "new_line_content": "\t\t\t\t\tauto table_lock = lockStructure(false);",
          "content_same": false
        },
        {
          "line": 1911,
          "old_api": null,
          "new_api": "s/\" + part_name + \"",
          "old_text": null,
          "new_text": "s/\" + part_name + \"",
          "old_line_content": "\t\t\t\t\t\t/// TODO: Можно пропускать проверку на слишком большие изменения, если в ZooKeeper есть, например,",
          "new_line_content": "\t\t\t\t\t\tparts = data.getDataParts();",
          "content_same": false
        },
        {
          "line": 1920,
          "old_api": null,
          "new_api": "\" << part_name << \" looks good.\");\n\t\t\t}\n\t\t\tcatch (",
          "old_text": null,
          "new_text": " \" << part_name << \" looks good.\");\n\t\t\t}\n\t\t\tcatch (",
          "old_line_content": "\t\t\t\t\t\t/// Обновим метаданные куска в ZooKeeper.",
          "new_line_content": "\t\t\t\t\t\tauto transaction = data.alterDataPart(part, columns_plus_materialized);",
          "content_same": false
        },
        {
          "line": 1930,
          "old_api": null,
          "new_api": "h",
          "old_text": null,
          "new_text": "h(part_name);\n\n\t\t\t\t/// Удалим кусок лок",
          "old_line_content": "\t\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\t\treplica_path + \"/parts/\" + part->name + \"/columns\", transaction->getNewColumns().toString(), -1));",
          "content_same": false
        },
        {
          "line": 1931,
          "old_api": null,
          "new_api": "renameAndDetachPart",
          "old_text": null,
          "new_text": "a.renameAndDetachPart(part, \"broken_\");\n\t\t\t}\n\t\t}\n\t\telse if (part->modification_time + MAX_AGE_OF_LOCAL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < time(0)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\tops.push_back(new zkutil::Op::SetData(",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": null,
          "new_api": "AL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < t",
          "old_text": null,
          "new_text": "AL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < t",
          "old_line_content": "\t\t\t\t\t/// То же самое для нереплицируемых данных.",
          "new_line_content": "\t\t\t\t\t\t\treplica_path + \"/parts/\" + part->name + \"/checksums\", transaction->getNewChecksums().toString(), -1));",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": null,
          "new_api": "/// Если куска нет в",
          "old_text": null,
          "new_text": "\t/// Если куска нет в",
          "old_line_content": "\t\t\t\t\tif (unreplicated_data)",
          "new_line_content": "\t\t\t\t\t\tzookeeper->multi(ops);",
          "content_same": false
        },
        {
          "line": 1936,
          "old_api": null,
          "new_api": "что записал, и еще н",
          "old_text": null,
          "new_text": " что записал, и еще н",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\ttransaction->commit();",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": null,
          "new_api": "tedPartChecksFailed);\n\n\t\t\tLOG_ERR",
          "old_text": null,
          "new_text": "tedPartChecksFailed);\n\n\t\t\tLOG_ERR",
          "old_line_content": "\t\t\t\t\t\t\t\tcontinue;",
          "new_line_content": "\t\t\t\t\t\tparts = unreplicated_data->getDataParts();",
          "content_same": false
        },
        {
          "line": 1953,
          "old_api": null,
          "new_api": "modification_time)",
          "old_text": null,
          "new_text": "modification_time)\n\t\t",
          "old_line_content": "\t\t\t\t\tif (changed_version)",
          "new_line_content": "\t\t\t\t\t\t\ttransaction->commit();",
          "content_same": false
        },
        {
          "line": 1963,
          "old_api": null,
          "new_api": "шибки, пока кусок не удалится как старый.\n\t\tLOG_WARNING",
          "old_text": null,
          "new_text": "шибки, пока кусок не удалится как старый.\n\t\tLOG_WARNING",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t\tLOG_INFO(log, \"ALTER-ed \" << changed_parts << \" parts\");",
          "content_same": false
        },
        {
          "line": 1965,
          "old_api": null,
          "new_api": "ave part \" << part->name << \" cove",
          "old_text": null,
          "new_text": "ave part \" << part->name << \" cove",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\t\t\t\tLOG_INFO(log, \"No parts ALTER-ed\");",
          "content_same": false
        },
        {
          "line": 1974,
          "old_api": null,
          "new_api": "{\n\t\t\t/// Достанем из оч",
          "old_text": null,
          "new_text": "\n\t\t{\n\t\t\t/// Достанем из оч",
          "old_line_content": "",
          "new_line_content": "\t\t\talter_thread_event->wait();",
          "content_same": false
        },
        {
          "line": 1978,
          "old_api": null,
          "new_api": "String part_name;\n\t\t\t{\n\t\t\t\tstd::lock_guar",
          "old_text": null,
          "new_text": "\t\tString part_name;\n\t\t\t{\n\t\t\t\tstd::lock_guar",
          "old_line_content": "",
          "new_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "content_same": false
        },
        {
          "line": 1982,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "x);\n\t\t\t\tif (parts_to_check_queue.empty())\n\t",
          "old_line_content": "",
          "new_line_content": "\t\t\talter_thread_event->tryWait(ERROR_SLEEP_MS);",
          "content_same": false
        },
        {
          "line": 1986,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "f (!parts_to_check_set.empty())\n\t\t\t\t\t{\n",
          "old_line_content": "",
          "new_line_content": "\tLOG_DEBUG(log, \"Alter thread finished\");",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "\t{\n\t\t\t\t\tpart_name = parts_to_check_queue.front();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif",
          "old_line_content": "{",
          "new_line_content": "\tops.push_back(new zkutil::Op::Remove(part_path + \"/checksums\", -1));",
          "content_same": false
        },
        {
          "line": 1996,
          "old_api": null,
          "new_api": ";\n\t\t\t}\n\n\t\t\tcheckPart(part_name);\n\n\t\t\t/// Удалим кусо",
          "old_text": null,
          "new_text": ";\n\t\t\t}\n\n\t\t\tcheckPart(part_name);\n\n\t\t\t/// Удалим кусо",
          "old_line_content": "",
          "new_line_content": "\tops.push_back(new zkutil::Op::Remove(part_path, -1));",
          "content_same": false
        },
        {
          "line": 2002,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "queue.empty() ",
          "old_line_content": "\tlog_entry->source_replica = \"\";",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        },
        {
          "line": 2008,
          "old_api": null,
          "new_api": "pop_front",
          "old_text": null,
          "new_text": "\n\t\t\t\t\tparts_to_check_queue.pop_front();\n\t\t\t\t\tparts_to_ch",
          "old_line_content": "\t\tzkutil::CreateMode::PersistentSequential));",
          "new_line_content": "\tlog_entry->create_time = tryGetPartCreateTime(zookeeper, replica_path, part_name);",
          "content_same": false
        },
        {
          "line": 2013,
          "old_api": null,
          "new_api": "tryWait",
          "old_text": null,
          "new_text": "FUNCTION__);\n\t\t\tparts_to_check_event.tryWait(ERROR_SLEEP_MS);\n\t\t}\n\t}\n}\n\n\nvoid StorageReplicatedMergeTree::becomeLeader()\n{\n\tLOG_INFO(log, \"Became leader\");\n\tis_leader_",
          "old_line_content": "",
          "new_line_content": "\tops.push_back(new zkutil::Op::Create(",
          "content_same": false
        },
        {
          "line": 2014,
          "old_api": null,
          "new_api": "MergeTree::becomeLeader()",
          "old_text": null,
          "new_text": "MergeTree::becomeLeader()\n",
          "old_line_content": "\t{",
          "new_line_content": "\t\treplica_path + \"/queue/queue-\", log_entry->toString(), zookeeper->getDefaultACL(),",
          "content_same": false
        },
        {
          "line": 2024,
          "old_api": null,
          "new_api": "ngPart",
          "old_text": null,
          "new_text": "ngPart(const String & part_name, bool active)\n{\n\tauto zooke",
          "old_line_content": "",
          "new_line_content": "\t\tString path_created = dynamic_cast<zkutil::Op::Create &>(ops[0]).getPathCreated();",
          "content_same": false
        },
        {
          "line": 2025,
          "old_api": null,
          "new_api": "getChildren",
          "old_text": null,
          "new_text": "eper->getChildren(zookeeper_pa",
          "old_line_content": "void StorageReplicatedMergeTree::enqueuePartForCheck(const String & name)",
          "new_line_content": "\t\tlog_entry->znode_name = path_created.substr(path_created.find_last_of('/') + 1);",
          "content_same": false
        },
        {
          "line": 2026,
          "old_api": null,
          "new_api": "plicas\");\n\n\t/// Из реплик, у которых есть",
          "old_text": null,
          "new_text": "plicas\");\n\n\t/// Из реплик, у которых есть",
          "old_line_content": "{",
          "new_line_content": "\t\tlog_entry->addResultToVirtualParts(*this);",
          "content_same": false
        },
        {
          "line": 2027,
          "old_api": null,
          "new_api": "ок, выберем одну равноверо",
          "old_text": null,
          "new_text": "ок, выберем одну равноверо",
          "old_line_content": "\tstd::lock_guard<std::mutex> lock(parts_to_check_mutex);",
          "new_line_content": "\t\tqueue.push_back(log_entry);",
          "content_same": false
        },
        {
          "line": 2036,
          "old_api": null,
          "new_api": "\"/replicas/\" + replica + \"/par",
          "old_text": null,
          "new_text": "\"/replicas/\" + replica + \"/par",
          "old_line_content": "",
          "new_line_content": "\tif (parts_to_check_set.count(name))",
          "content_same": false
        },
        {
          "line": 2038,
          "old_api": null,
          "new_api": "ame) &&\n\t\t\t(!active || zookeeper->ex",
          "old_text": null,
          "new_text": "ame) &&\n\t\t\t(!active || zookeeper->ex",
          "old_line_content": "{",
          "new_line_content": "\tparts_to_check_queue.push_back(name);",
          "content_same": false
        },
        {
          "line": 2040,
          "old_api": null,
          "new_api": "replica + \"/is_active\")))",
          "old_text": null,
          "new_text": "replica + \"/is_active\")))\n",
          "old_line_content": "\tString part_path = replica_path + \"/parts/\" + part_name;",
          "new_line_content": "\tparts_to_check_event.set();",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": null,
          "new_api": "осле возврата",
          "old_text": null,
          "new_text": "осле возврата ",
          "old_line_content": "\t\t\t\"Removing from ZooKeeper and queueing a fetch.\");",
          "new_line_content": "\tauto zookeeper = getZooKeeper();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2049,
          "old_api": "_path = zookeeper_path + \"/quorum/la",
          "new_api": null,
          "old_text": "_path = zookeeper_path + \"/quorum/la",
          "new_text": null,
          "old_line_content": "\t\tremovePartAndEnqueueFetch(part_name);",
          "new_line_content": "\t/// Если кусок есть в ZooKeeper, удалим его оттуда и добавим в очередь задание скачать его.",
          "content_same": false
        },
        {
          "line": 2055,
          "old_api": "tryGet",
          "new_api": null,
          "old_text": "zookeeper->tryGet(quorum_status_path, value, &stat))\n\t",
          "new_text": null,
          "old_line_content": "\tActiveDataPartSet::parsePartName(part_name, part_info);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2067,
          "old_api": ");\n\n\t\t\tif (code == ZOK)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (code == ZNONODE)\n\t\t\t{\n\t\t\t\t///",
          "new_api": null,
          "old_text": ");\n\n\t\t\tif (code == ZOK)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (code == ZNONODE)\n\t\t\t{\n\t\t\t\t///",
          "new_text": null,
          "old_line_content": "\tLOG_WARNING(log, \"Checker: Checking if anyone has part covering \" << part_name << \".\");",
          "new_line_content": "\t\t*   - или, если реплика никогда не оживёт, то администратор удалит или создаст новую реплику с тем же адресом и см. всё сначала;",
          "content_same": false
        },
        {
          "line": 2077,
          "old_api": "eTree::fetchPart(const String & part_name, const String & replica_path, bo",
          "new_api": null,
          "old_text": "eTree::fetchPart(const String & part_name, const String & replica_path, bo",
          "new_text": null,
          "old_line_content": "\t\tStrings parts = zookeeper->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/parts\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2080,
          "old_api": "g part \" << part_name << \" from \" << replica_path);\n\n\tT",
          "new_api": null,
          "old_text": "g part \" << part_name << \" from \" << replica_path);\n\n\tT",
          "new_text": null,
          "old_line_content": "\t\t\tif (part_on_replica == part_name || ActiveDataPartSet::contains(part_on_replica, part_name))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2083,
          "old_api": "e_lock;\n\tif (!to_detached)\n\t\ttable_lock = lockStructure(true);\n\n\tReplicatedMerge",
          "new_api": null,
          "old_text": "e_lock;\n\tif (!to_detached)\n\t\ttable_lock = lockStructure(true);\n\n\tReplicatedMerge",
          "new_text": null,
          "old_line_content": "\t\t\t\tLOG_WARNING(log, \"Checker: Found part \" << part_on_replica << \" on \" << replica);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2093,
          "old_api": "nsaction;\n\t\tauto removed_parts = data.renam",
          "new_api": null,
          "old_text": "nsaction;\n\t\tauto removed_parts = data.renam",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tfound_blocks.at(block_num - part_info.left) = 1;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2113,
          "old_api": "getFullPath",
          "new_api": null,
          "old_text": "teReplicatedParts);\n\t\t}\n\t}\n\telse\n\t{\n\t\tPoco::File(data.getFullPath() + \"detached/tmp_\" + part_nam",
          "new_text": null,
          "old_line_content": "\t\tLOG_WARNING(log, \"Checker: Found all blocks for missing part. Will wait for them to be merged.\");",
          "new_line_content": "\tsize_t num_found_blocks = 0;",
          "content_same": false
        },
        {
          "line": 2118,
          "old_api": "Events::increment(ProfileEvents::ReplicatedPartFetches);\n\n\tLOG_DEBUG(",
          "new_api": null,
          "old_text": "Events::increment(ProfileEvents::ReplicatedPartFetches);\n\n\tLOG_DEBUG(",
          "new_text": null,
          "old_line_content": "\tLOG_ERROR(log, \"Checker: No replica has part covering \" << part_name);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2121,
          "old_api": "<< \" from \" << replica_path << (to_detached ? \" (to 'detached' directory)\" : \"\"));\n}\n\n\nvoid StorageReplicatedMergeTree::shutdown()\n{\n\tif (restarting_thread)\n\t{\n\t\trestarting_thre",
          "new_api": null,
          "old_text": " << \" from \" << replica_path << (to_detached ? \" (to 'detached' directory)\" : \"\"));\n}\n\n\nvoid StorageReplicatedMergeTree::shutdown()\n{\n\tif (restarting_thread)\n\t{\n\t\trestarting_thre",
          "new_text": null,
          "old_line_content": "\t\tLOG_WARNING(log, \"When looking for smaller parts, that is covered by \" << part_name",
          "new_line_content": "\t\treturn;",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": "reset",
          "new_api": null,
          "old_text": "stop();\n\t\trestarting_thread.reset();\n\t}\n\n\tendpoint_holder = nullptr",
          "new_text": null,
          "old_line_content": "\tProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);",
          "new_line_content": "\t/// Ни у кого нет такого куска.",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": "block_size,\n\tconst unsigned threads)\n{\n\t/** У таблицы может быть д",
          "new_api": null,
          "old_text": "block_size,\n\tconst unsigned threads)\n{\n\t/** У таблицы может быть д",
          "new_text": null,
          "old_line_content": "\t\t\t\tzookeeper->tryRemove(replica_path + \"/queue/\" + (*it)->znode_name);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2136,
          "old_api": "а данных:\n\t  * -",
          "new_api": null,
          "old_text": "а данных:\n\t  * - ",
          "new_text": null,
          "old_line_content": "\t\t\t\tqueue.erase(it++);",
          "new_line_content": "\t\tstd::lock_guard<std::mutex> lock(queue_mutex);",
          "content_same": false
        },
        {
          "line": 2147,
          "old_api": "ность использовать \"виртуальные столбцы\".\n\t  * Один из них - _replicated позволя",
          "new_api": null,
          "old_text": "ность использовать \"виртуальные столбцы\".\n\t  * Один из них - _replicated позволя",
          "new_text": null,
          "old_line_content": "\t\tLOG_ERROR(log, \"Checker: Missing part \" << part_name << \" is not in our queue.\");",
          "new_line_content": "\t\t\t\t++it;",
          "content_same": false
        },
        {
          "line": 2155,
          "old_api": "EWHERE if enabled and viable\n\tif (settings.optimize_move_to",
          "new_api": null,
          "old_text": "EWHERE if enabled and viable\n\tif (settings.optimize_move_to",
          "new_text": null,
          "old_line_content": "\tProfileEvents::increment(ProfileEvents::ReplicatedDataLoss);",
          "new_line_content": "\t\treturn;",
          "content_same": false
        },
        {
          "line": 2173,
          "old_api": "count",
          "new_api": null,
          "old_text": "parallel_replica_offset == 0) && unreplicated_reader && values.count(0))\n\t{\n\t\tres = unreplicated_reader->read(real_column_n",
          "new_text": null,
          "old_line_content": "\t\tLOG_ERROR(log, \"Won't add nonincrement_block_numbers because part spans too much blocks (\" << part_length_in_blocks << \")\");",
          "new_line_content": "\t\t* - потребовалось бы создать слишком много (больше 1000) узлов;",
          "content_same": false
        },
        {
          "line": 2179,
          "old_api": "max_block_size, threads, &part_index, 0);\n\n\t\tfor (auto & virtual_column : virt_column_names)",
          "new_api": null,
          "old_text": "\tmax_block_size, threads, &part_index, 0);\n\n\t\tfor (auto & virtual_column : virt_column_names)\n\t\t",
          "new_text": null,
          "old_line_content": "\t\tLOG_ERROR(log, \"Won't add nonincrement_block_numbers because part is one of first in partition\");",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2183,
          "old_api": "{\n\t\t\t\tfor (auto & str",
          "new_api": null,
          "old_text": "\t{\n\t\t\t\tfor (auto & str",
          "new_text": null,
          "old_line_content": "\tconst auto partition_str = part_name.substr(0, 6);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2187,
          "old_api": ")\n\t{\n\t\t/** Настройка select_sequential_consistency имеет два смысла:\n\t\t  * 1. Кидать исключение,",
          "new_api": null,
          "old_text": ")\n\t{\n\t\t/** Настройка select_sequential_consistency имеет два смысла:\n\t\t  * 1. Кидать исключение, ",
          "new_text": null,
          "old_line_content": "\t\tzookeeper->createIfNotExists(zookeeper_path + \"/nonincrement_block_numbers/\" + partition_str, \"\");",
          "new_line_content": "\t\treturn;",
          "content_same": false
        },
        {
          "line": 2188,
          "old_api": "на реплике есть не все куски, которые были записаны на кворум остальных реплик.\n\t\t  * 2. Не читать куски, которые ещё не были записаны на кворум реплик.\n\t\t  * Для",
          "new_api": null,
          "old_text": " на реплике есть не все куски, которые были записаны на кворум остальных реплик.\n\t\t  * 2. Не читать куски, которые ещё не были записаны на кворум реплик.\n\t\t  * Для ",
          "new_text": null,
          "old_line_content": "\t\tAbandonableLockInZooKeeper::createAbandonedIfNotExists(",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 2189,
          "old_api": "а кворум ре",
          "new_api": null,
          "old_text": "а кворум ре",
          "new_text": null,
          "old_line_content": "\t\t\tzookeeper_path + \"/nonincrement_block_numbers/\" + partition_str + \"/block-\" + padIndex(i),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2197,
          "old_api": "o_read = 0;\n\t\tif (settings.select_sequential_consistency",
          "new_api": null,
          "old_text": "o_read = 0;\n\t\tif (settings.select_sequential_consistency",
          "new_text": null,
          "old_line_content": "\tLOG_WARNING(log, \"Checker: Checking part \" << part_name);",
          "new_line_content": "\t\t\t*zookeeper);",
          "content_same": false
        },
        {
          "line": 2198,
          "old_api": "{\n\t\t\tauto zookeeper = getZooKeeper();\n\t\t\tString last_part;",
          "new_api": null,
          "old_text": "\t{\n\t\t\tauto zookeeper = getZooKeeper();\n\t\t\tString last_part;\n\t",
          "new_text": null,
          "old_line_content": "\tProfileEvents::increment(ProfileEvents::ReplicatedPartChecks);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 2200,
          "old_api": "Get",
          "new_api": null,
          "old_text": "Get(zookeeper_path + \"/quorum/last_part",
          "new_text": null,
          "old_line_content": "\tauto part = data.getActiveContainingPart(part_name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2210,
          "old_api": "M);\n\n\t\t\tif (la",
          "new_api": null,
          "old_text": "M);\n\n\t\t\tif (la",
          "new_text": null,
          "old_line_content": "\t\tauto zookeeper = getZooKeeper();",
          "new_line_content": "\tif (!part)",
          "content_same": false
        },
        {
          "line": 2211,
          "old_api": "сли ещё ни один кусо",
          "new_api": null,
          "old_text": "сли ещё ни один кусо",
          "new_text": null,
          "old_line_content": "\t\tauto table_lock = lockStructure(false);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2214,
          "old_api": "licatedMergeTreeQuorumEntry quorum_entry;\n\t\t\t\t\tquorum_e",
          "new_api": null,
          "old_text": "licatedMergeTreeQuorumEntry quorum_entry;\n\t\t\t\t\tquorum_e",
          "new_text": null,
          "old_line_content": "\t\tif (zookeeper->exists(replica_path + \"/parts/\" + part_name))",
          "new_line_content": "\t/// У нас есть этот кусок, и он активен. Будем проверять, нужен ли нам этот кусок и правильные ли у него данные.",
          "content_same": false
        },
        {
          "line": 2216,
          "old_api": "String",
          "new_api": null,
          "old_text": "String(quorum_str);\n\t\t\t\t\tActiveDataPartSet::Part part_info;\n\t\t\t\t\tActive",
          "new_text": null,
          "old_line_content": "\t\t\tLOG_WARNING(log, \"Checker: Checking data of part \" << part_name << \".\");",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": ".part_name, part_info);\n\t\t\t\t\tmax_block_number_to_read = part_info.left - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tActiveDataPa",
          "new_api": null,
          "old_text": ".part_name, part_info);\n\t\t\t\t\tmax_block_number_to_read = part_info.left - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tActiveDataPa",
          "new_text": null,
          "old_line_content": "\t\t\t\tauto zk_checksums = MergeTreeData::DataPart::Checksums::parse(",
          "new_line_content": "\t\t/// Если кусок есть в ZooKeeper, сверим его данные с его чексуммами, а их с ZooKeeper.",
          "content_same": false
        },
        {
          "line": 2222,
          "old_api": ":Part part_info;\n\t\t\t\tActiveDataPartSet::parseP",
          "new_api": null,
          "old_text": ":Part part_info;\n\t\t\t\tActiveDataPartSet::parseP",
          "new_text": null,
          "old_line_content": "\t\t\t\tzk_checksums.checkEqual(part->checksums, true);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": "read",
          "new_api": null,
          "old_text": "nfo);\n\t\t\t\tmax_block_number_to_read = part_info.right;\n\t\t\t}\n\t\t}\n\n\t\tauto res2 = reader.read(\n\t\t\trea",
          "new_text": null,
          "old_line_content": "\t\t\t\tauto zk_columns = NamesAndTypesList::parse(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2225,
          "old_api": "read",
          "new_api": null,
          "old_text": "ead = part_info.right;\n\t\t\t}\n\t\t}\n\n\t\tauto res2 = reader.read(\n\t\t\tre",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tzookeeper->get(replica_path + \"/parts/\" + part_name + \"/columns\"));",
          "new_line_content": "\t\t\ttry",
          "content_same": false
        },
        {
          "line": 2230,
          "old_api": "f (virtual_column == \"_replicated\")\n\t\t\t{\n\t\t\t\tfor (au",
          "new_api": null,
          "old_text": "f (virtual_column == \"_replicated\")\n\t\t\t{\n\t\t\t\tfor (au",
          "new_text": null,
          "old_line_content": "\t\t\t\tsettings.setIndexGranularity(data.index_granularity);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2233,
          "old_api": "insert",
          "new_api": null,
          "old_text": "ew DataTypeUInt8, 1, \"_replicated\");\n\t\t\t}\n\t\t}\n\n\t\tres.insert(res.end(), res2.begin(), res2.end());\n\t}\n\n\treturn re",
          "new_text": null,
          "old_line_content": "\t\t\t\tMergeTreePartChecker::checkDataPart(",
          "new_line_content": "\t\t\t\tif (part->columns != zk_columns)",
          "content_same": false
        },
        {
          "line": 2236,
          "old_api": "BlockOutputStreamPtr StorageReplicatedMergeTree::write(ASTPtr",
          "new_api": null,
          "old_text": "BlockOutputStreamPtr StorageReplicatedMergeTree::write(ASTPtr ",
          "new_text": null,
          "old_line_content": "\t\t\t\tLOG_INFO(log, \"Checker: Part \" << part_name << \" looks good.\");",
          "new_line_content": "\t\t\t\tMergeTreePartChecker::Settings settings;",
          "content_same": false
        },
        {
          "line": 2242,
          "old_api": "in readonly mode\", ErrorCodes::TABLE_IS_READ_ONLY);\n\n\tString insert_id;\n\tif (query)\n\t\tif (ASTInser",
          "new_api": null,
          "old_text": " in readonly mode\", ErrorCodes::TABLE_IS_READ_ONLY);\n\n\tString insert_id;\n\tif (query)\n\t\tif (ASTInser",
          "new_text": null,
          "old_line_content": "\t\t\t\tLOG_ERROR(log, \"Checker: Part \" << part_name << \" looks broken. Removing it and queueing a fetch.\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2245,
          "old_api": ">insert_id;\n\n\treturn new ReplicatedM",
          "new_api": null,
          "old_text": ">insert_id;\n\n\treturn new ReplicatedM",
          "new_text": null,
          "old_line_content": "\t\t\t\tremovePartAndEnqueueFetch(part_name);",
          "new_line_content": "\t\t\tcatch (...)",
          "content_same": false
        },
        {
          "line": 2248,
          "old_api": "rt_quorum);\n}\n\n\nbool StorageReplicatedMer",
          "new_api": null,
          "old_text": "rt_quorum);\n}\n\n\nbool StorageReplicatedMer",
          "new_text": null,
          "old_line_content": "\t\t\t\tdata.renameAndDetachPart(part, \"broken_\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": "ated.",
          "new_api": null,
          "old_text": "ated.\n\t",
          "new_text": null,
          "old_line_content": "\t\telse if (part->modification_time + MAX_AGE_OF_LOCAL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < time(0))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2256,
          "old_api": "selectPartsToMerge",
          "new_api": null,
          "old_text": "{ return true; };\n\tif (!unreplicated_merger->selectPartsToMerge(par",
          "new_text": null,
          "old_line_content": "\t\t\tProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": "getMergeList",
          "new_api": null,
          "old_text": "ry = context.getMergeList().insert(database_n",
          "new_text": null,
          "old_line_content": "\t\t\tdata.renameAndDetachPart(part, \"unexpected_\");",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2264,
          "old_api": "y, sett",
          "new_api": null,
          "old_text": "y, sett",
          "new_text": null,
          "old_line_content": "\t\t\t\t<< \" with age \" << (time(0) - part->modification_time)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2272,
          "old_api": ", \"Doing ALTER\");\n\n\tNamesAndTypesList new_columns;\n\tNamesAndTypesList new_materialized_col",
          "new_api": null,
          "old_text": ", \"Doing ALTER\");\n\n\tNamesAndTypesList new_columns;\n\tNamesAndTypesList new_materialized_col",
          "new_text": null,
          "old_line_content": "\t\tLOG_WARNING(log, \"Checker: We have part \" << part->name << \" covering part \" << part_name);",
          "new_line_content": "\t\t\t\t<< \" seconds hasn't been added to ZooKeeper yet. It's ok.\");",
          "content_same": false
        },
        {
          "line": 2289,
          "old_api": "checkAlter",
          "new_api": null,
          "old_text": "checkAlter(params);\n\n\t\tnew_c",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (parts_to_check_queue.empty())",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": "olumnsListNonMaterialized",
          "new_api": null,
          "old_text": "olumnsListNonMaterialized(",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tif (!parts_to_check_set.empty())",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2293,
          "old_api": "alized_columns = data.materialized_columns;\n\t\tnew_alias_columns = data.alias_columns;\n\t\tnew_column_defa",
          "new_api": null,
          "old_text": "alized_columns = data.materialized_columns;\n\t\tnew_alias_columns = data.alias_columns;\n\t\tnew_column_defa",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tLOG_ERROR(log, \"Checker: Non-empty parts_to_check_set with empty parts_to_check_queue. This is a bug.\");",
          "new_line_content": "\t\t\tString part_name;",
          "content_same": false
        },
        {
          "line": 2294,
          "old_api": "ata.column_defaults;\n\t\tpar",
          "new_api": null,
          "old_text": "ata.column_defaults;\n\t\tpar",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tparts_to_check_set.clear();",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": ", new_alias_columns, new_col",
          "new_api": null,
          "old_text": ", new_alias_columns, new_col",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tpart_name = parts_to_check_queue.front();",
          "new_line_content": "\t\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 2303,
          "old_api": "_columns_str = Co",
          "new_api": null,
          "old_text": "_columns_str = Co",
          "new_text": null,
          "old_line_content": "\t\t\tif (part_name.empty())",
          "new_line_content": "\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 2305,
          "old_api": "ption<false>{\n\t\t\tnew_column",
          "new_api": null,
          "old_text": "ption<false>{\n\t\t\tnew_column",
          "new_text": null,
          "old_line_content": "\t\t\t\tparts_to_check_event.wait();",
          "new_line_content": "\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": "ns,\n\t\t\tnew_alias_col",
          "new_api": null,
          "old_text": "ns,\n\t\t\tnew_alias_col",
          "new_text": null,
          "old_line_content": "\t\t\tcheckPart(part_name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": "}\n\n\tLOG_DEBUG(log, \"Updated",
          "new_api": null,
          "old_text": "\t}\n\n\tLOG_DEBUG(log, \"Updated",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (parts_to_check_queue.empty() || parts_to_check_queue.front() != part_name)",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": "толбцов, чтобы перестать ждать,",
          "new_api": null,
          "old_text": "толбцов, чтобы перестать ждать, ",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tparts_to_check_queue.pop_front();",
          "new_line_content": "\t\t\t\tstd::lock_guard<std::mutex> lock(parts_to_check_mutex);",
          "content_same": false
        },
        {
          "line": 2336,
          "old_api": "ersion)\n\t{\n\t\tLOG_WARNING(log,",
          "new_api": null,
          "old_text": "ersion)\n\t{\n\t\tLOG_WARNING(log, ",
          "new_text": null,
          "old_line_content": "\tLOG_INFO(log, \"Became leader\");",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 2338,
          "old_api": "finished; \"\n\t\t\t\"overlapping ALTER-s are fine but use caution with n",
          "new_api": null,
          "old_text": " finished; \"\n\t\t\t\"overlapping ALTER-s are fine but use caution with n",
          "new_text": null,
          "old_line_content": "\tmerge_selecting_thread = std::thread(&StorageReplicatedMergeTree::mergeSelectingThread, this);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2344,
          "old_api": "t String & rep",
          "new_api": null,
          "old_text": "t String & rep",
          "new_text": null,
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "\tis_leader_node = true;",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": "\"/replicas/\"",
          "new_api": null,
          "old_text": " \"/replicas/\" ",
          "new_text": null,
          "old_line_content": "\tstd::random_shuffle(replicas.begin(), replicas.end());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2353,
          "old_api": "= stat.version;\n\n\t\t\tif (replica_columns_str == new_columns_str)\n\t\t\t\tbreak",
          "new_api": null,
          "old_text": "= stat.version;\n\n\t\t\tif (replica_columns_str == new_columns_str)\n\t\t\t\tbreak",
          "new_text": null,
          "old_line_content": "\t\t\t(!active || zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2367,
          "old_api": "ery_event))",
          "new_api": null,
          "old_text": "ery_event))\n\t\t",
          "new_text": null,
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2378,
          "old_api": "Num",
          "new_api": null,
          "old_text": "Num(start_time);\n\tDayNum_t right_date = DayNum_t(st",
          "new_text": null,
          "old_line_content": "\twhile (zookeeper->tryGet(quorum_status_path, value, &stat))",
          "new_line_content": "\t/// Имя предыдущего куска, для которого был достигнут кворум.",
          "content_same": false
        },
        {
          "line": 2381,
          "old_api": "ime) - 1);\n\n\t/// Уровень - rig",
          "new_api": null,
          "old_text": "ime) - 1);\n\n\t/// Уровень - rig",
          "new_text": null,
          "old_line_content": "\t\tquorum_entry.fromString(value);",
          "new_line_content": "\tString value;",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": "catedMergeTree::dropUnreplicatedPartition(",
          "new_api": null,
          "old_text": "catedMergeTree::dropUnreplicatedPartition(",
          "new_text": null,
          "old_line_content": "\t\tquorum_entry.replicas.insert(replica_name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2391,
          "old_api": "ld & partition, const bool d",
          "new_api": null,
          "old_text": "ld & partition, const bool d",
          "new_text": null,
          "old_line_content": "\t\tif (quorum_entry.replicas.size() >= quorum_entry.required_number_of_replicas)",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2397,
          "old_api": "Num",
          "new_api": null,
          "old_text": "Num(partition);\n\n\tsize_t removed_parts = 0;\n\tMergeTreeData::DataParts parts ",
          "new_text": null,
          "old_line_content": "\t\t\tops.push_back(new zkutil::Op::SetData(quorum_last_part_path, part_name, -1));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2415,
          "old_api": "eplicated parts inside \" << apply_visitor(FieldVi",
          "new_api": null,
          "old_text": "eplicated parts inside \" << apply_visitor(FieldVi",
          "new_text": null,
          "old_line_content": "\t\t\t\tthrow zkutil::KeeperException(code, quorum_status_path);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": "s)\n{\n\tif (unreplicated)",
          "new_api": null,
          "old_text": "s)\n{\n\tif (unreplicated)",
          "new_text": null,
          "old_line_content": "\t\t\tauto code = zookeeper->trySet(quorum_status_path, quorum_entry.toString(), stat.version);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 2437,
          "old_api": "rCodes::NO_ACTIVE_REPLICAS);\n\n\t\tstd::sort(live_re",
          "new_api": null,
          "old_text": "rCodes::NO_ACTIVE_REPLICAS);\n\n\t\tstd::sort(live_re",
          "new_text": null,
          "old_line_content": "\t\t\t\tthrow zkutil::KeeperException(code, quorum_status_path);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": "ame)\n\t\t\tthrow",
          "new_api": null,
          "old_text": "ame)\n\t\t\tthrow ",
          "new_text": null,
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 2447,
          "old_api": "ption",
          "new_api": null,
          "old_text": "ption(\"Leader was suddenly changed or logical error.\", ErrorCodes::LEADER",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Fetching part \" << part_name << \" from \" << replica_path);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2451,
          "old_api": "ookeeper_path + \"/r",
          "new_api": null,
          "old_text": "ookeeper_path + \"/r",
          "new_text": null,
          "old_line_content": "\t\ttable_lock = lockStructure(true);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2453,
          "old_api": "clone",
          "new_api": null,
          "old_text": " new_query = query->clone();\n\t\tauto & ",
          "new_text": null,
          "old_line_content": "\tReplicatedMergeTreeAddress address(zookeeper->get(replica_path + \"/host\"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2455,
          "old_api": "y);\n\n\t\talter.database = leader_address.database;\n\t\talter.table = leader_address.table;\n\n\t\t/// N",
          "new_api": null,
          "old_text": "y);\n\n\t\talter.database = leader_address.database;\n\t\talter.table = leader_address.table;\n\n\t\t/// N",
          "new_text": null,
          "old_line_content": "\tMergeTreeData::MutableDataPartPtr part = fetcher.fetchPart(part_name, replica_path, address.host, address.replication_port, to_detached);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2463,
          "old_api": "(\n\t\t\tleader_address.host,\n\t\t\tleader_address.queries_port,",
          "new_api": null,
          "old_text": "(\n\t\t\tleader_address.host,\n\t\t\tleader_address.queries_port,\n",
          "new_text": null,
          "old_line_content": "\t\tauto removed_parts = data.renameTempPartAndReplace(part, nullptr, &transaction);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2465,
          "old_api": "ader_address.database",
          "new_api": null,
          "old_text": "ader_address.database",
          "new_text": null,
          "old_line_content": "\t\tzookeeper->multi(ops);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2466,
          "old_api": "\"\", \"\", \"ClickHouse",
          "new_api": null,
          "old_text": "\t\"\", \"\", \"ClickHouse",
          "new_text": null,
          "old_line_content": "\t\ttransaction.commit();",
          "new_line_content": "\t\tzkutil::Ops ops;",
          "content_same": false
        },
        {
          "line": 2474,
          "old_api": "ятся слияния удаляемых куск",
          "new_api": null,
          "old_text": "ятся слияния удаляемых куск",
          "new_text": null,
          "old_line_content": "\t\tmerge_selecting_event.set();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2478,
          "old_api": "поддержать запрос DROP PART, для него придется придумать какой-нибудь новый механизм,\n\t  *        чтоб",
          "new_api": null,
          "old_text": " поддержать запрос DROP PART, для него придется придумать какой-нибудь новый механизм,\n\t  *        чтоб",
          "new_text": null,
          "old_line_content": "\t\t\tLOG_DEBUG(log, \"Part \" << removed_part->name << \" is rendered obsolete by fetching part \" << part_name);",
          "new_line_content": "\t\tif (quorum)",
          "content_same": false
        },
        {
          "line": 2484,
          "old_api": "getNumber",
          "new_api": null,
          "old_text": "r_lock.getNumber()",
          "new_text": null,
          "old_line_content": "\t\tPoco::File(data.getFullPath() + \"detached/tmp_\" + part_name).renameTo(data.getFullPath() + \"detached/\" + part_name);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2487,
          "old_api": "/// Такого никогда не должно происходить.\n\tif (right == 0)",
          "new_api": null,
          "old_text": "\n\n\t/// Такого никогда не должно происходить.\n\tif (right == 0)\n",
          "new_text": null,
          "old_line_content": "\tProfileEvents::increment(ProfileEvents::ReplicatedPartFetches);",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 2489,
          "old_api": "row Exception(\"Logical error: just allocated block number is zero\", ErrorCodes::LOGICAL_ERROR);\n\t--right;\n\n\tString fake_part_",
          "new_api": null,
          "old_text": "row Exception(\"Logical error: just allocated block number is zero\", ErrorCodes::LOGICAL_ERROR);\n\t--right;\n\n\tString fake_part_",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Fetched part \" << part_name << \" from \" << replica_path << (to_detached ? \" (to 'detached' directory)\" : \"\"));",
          "new_line_content": "\telse",
          "content_same": false
        },
        {
          "line": 2497,
          "old_api": "слияния удаляемые куски -",
          "new_api": null,
          "old_text": "слияния удаляемые куски -",
          "new_text": null,
          "old_line_content": "\t\trestarting_thread->stop();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2498,
          "old_api": "лаем вид, что их всех уже",
          "new_api": null,
          "old_text": "лаем вид, что их всех уже",
          "new_text": null,
          "old_line_content": "\t\trestarting_thread.reset();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2509,
          "old_api": "ятся слиян",
          "new_api": null,
          "old_text": "ятся слиян",
          "new_text": null,
          "old_line_content": "\t\tshutdown();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2513,
          "old_api": "*/\n\t{\n\t\tstd::lock_guard<std::mutex> merge",
          "new_api": null,
          "old_text": "  */\n\t{\n\t\tstd::lock_guard<std::mutex> merge",
          "new_text": null,
          "old_line_content": "\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2539,
          "old_api": "g>();\n\telse\n\t\tpartition = Merge",
          "new_api": null,
          "old_text": "g>();\n\telse\n\t\tpartition = Merge",
          "new_text": null,
          "old_line_content": "\t\t\tvirt_column_names.push_back(it);",
          "new_line_content": "\t  *  или, при использовании в WHERE - выбрать данные только из одной части.",
          "content_same": false
        },
        {
          "line": 2541,
          "old_api": "tMonthName",
          "new_api": null,
          "old_text": "tMonthName(field);\n\n\tString sou",
          "new_text": null,
          "old_line_content": "\t\t\treal_column_names.push_back(it);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2543,
          "old_api": "ted ? \"unreplicated/\" : \"detached/\");\n\n\t///",
          "new_api": null,
          "old_text": "ted ? \"unreplicated/\" : \"detached/\");\n\n\t///",
          "new_text": null,
          "old_line_content": "\tauto & select = typeid_cast<const ASTSelectQuery &>(*query);",
          "new_line_content": "\tNames real_column_names;",
          "content_same": false
        },
        {
          "line": 2553,
          "old_api": "++it)\n\t\t{\n\t\t\tStr",
          "new_api": null,
          "old_text": " ++it)\n\t\t{\n\t\t\tStr",
          "new_text": null,
          "old_line_content": "\tcolumn->getData()[0] = 0;",
          "new_line_content": "\tif (settings.optimize_move_to_prewhere)",
          "content_same": false
        },
        {
          "line": 2554,
          "old_api": "name",
          "new_api": null,
          "old_text": " it.name();\n\t\t\tif",
          "new_text": null,
          "old_line_content": "\tcolumn->getData()[1] = 1;",
          "new_line_content": "\t\tif (select.where_expression && !select.prewhere_expression)",
          "content_same": false
        },
        {
          "line": 2555,
          "old_api": "compare",
          "new_api": null,
          "old_text": "ame))\n\t\t\t\tcontinue;\n\t\t\tif (0 != name.compare(0, partition.size(), p",
          "new_text": null,
          "old_line_content": "\tvirtual_columns_block.insert(ColumnWithTypeAndName(column_ptr, new DataTypeUInt8, \"_replicated\"));",
          "new_line_content": "\t\t\tMergeTreeWhereOptimizer{query, context, data, real_column_names, log};",
          "content_same": false
        },
        {
          "line": 2558,
          "old_api": "size",
          "new_api": null,
          "old_text": "g, active_parts.size() <<",
          "new_text": null,
          "old_line_content": "\tif (!virt_column_names.empty())",
          "new_line_content": "\tColumnUInt8 * column = new ColumnUInt8(2);",
          "content_same": false
        },
        {
          "line": 2559,
          "old_api": "getParts",
          "new_api": null,
          "old_text": "f them are active\");\n\t\tparts = active_parts.getParts();\n\t}\n\n\t/// Синхронно пров",
          "new_text": null,
          "old_line_content": "\t\tVirtualColumnUtils::filterBlockWithQuery(query, virtual_columns_block, context);",
          "new_line_content": "\tColumnPtr column_ptr = column;",
          "content_same": false
        },
        {
          "line": 2573,
          "old_api": ");\n\tstd::list<L",
          "new_api": null,
          "old_text": ");\n\tstd::list<L",
          "new_text": null,
          "old_line_content": "\tif ((settings.parallel_replica_offset == 0) && unreplicated_reader && values.count(0))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2575,
          "old_api": "ies;\n\tzkutil::Ops ops;\n\tfor (const String & part_name : parts)\n\t{\n\t\tActiveDataPartSet::Part part;\n\t\tActiveDataPartSet::parsePartName(part_name, part",
          "new_api": null,
          "old_text": "ies;\n\tzkutil::Ops ops;\n\tfor (const String & part_name : parts)\n\t{\n\t\tActiveDataPartSet::Part part;\n\t\tActiveDataPartSet::parsePartName(part_name, part",
          "new_text": null,
          "old_line_content": "\t\tres = unreplicated_reader->read(real_column_names, query,",
          "new_line_content": "\t  * Для реплицируемых, данные разбиваются таким же механизмом, как работает секция SAMPLE.",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": "ies.emplace_bac",
          "new_api": null,
          "old_text": "ies.emplace_bac",
          "new_text": null,
          "old_line_content": "\tif (values.count(1))",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 2599,
          "old_api": "tions_sync !=",
          "new_api": null,
          "old_text": "tions_sync != ",
          "new_text": null,
          "old_line_content": "\t\t\tauto zookeeper = getZooKeeper();",
          "new_line_content": "\t\t  * 1. Кидать исключение, если на реплике есть не все куски, которые были записаны на кворум остальных реплик.",
          "content_same": false
        },
        {
          "line": 2601,
          "old_api": "r (LogEntry & entry : entries)\n\t\t{\n\t\t\tString log_znode_path = dyna",
          "new_api": null,
          "old_text": "r (LogEntry & entry : entries)\n\t\t{\n\t\t\tString log_znode_path = dyna",
          "new_text": null,
          "old_line_content": "\t\t\tzookeeper->tryGet(zookeeper_path + \"/quorum/last_part\", last_part);",
          "new_line_content": "\t\t  * Для этого приходится синхронно сходить в ZooKeeper.",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": "getPathCreated",
          "new_api": null,
          "old_text": "s[i]).getPathCreated();\n\t\t\tentr",
          "new_text": null,
          "old_line_content": "\t\t\tif (!last_part.empty() && !data.getPartIfExists(last_part))\t/// TODO Отключение реплики при распределённых запросах.",
          "new_line_content": "\t\tInt64 max_block_number_to_read = 0;",
          "content_same": false
        },
        {
          "line": 2604,
          "old_api": "partitions_sync == 1)\n\t\t\t\twaitForReplicaToProcessLogEntry(replica_name, entry);\n\t\t\telse\n\t\t\t\twaitForAllReplicasToProcessLogEntry(entry);\n\n\t\t\t++i;\n\t\t}\n\t}\n}\n\n\nvoid StorageReplicatedMergeTree::drop()\n{\n\tif (is_readonly)\n\t\tthrow Exception(\"Can't dro",
          "new_api": null,
          "old_text": "partitions_sync == 1)\n\t\t\t\twaitForReplicaToProcessLogEntry(replica_name, entry);\n\t\t\telse\n\t\t\t\twaitForAllReplicasToProcessLogEntry(entry);\n\n\t\t\t++i;\n\t\t}\n\t}\n}\n\n\nvoid StorageReplicatedMergeTree::drop()\n{\n\tif (is_readonly)\n\t\tthrow Exception(\"Can't dro",
          "new_text": null,
          "old_line_content": "\t\t\t\tthrow Exception(\"Replica doesn't have part \" + last_part + \" which was successfully written to quorum of other replicas.\"",
          "new_line_content": "\t\tif (settings.select_sequential_consistency)",
          "content_same": false
        },
        {
          "line": 2607,
          "old_api": "replicated table",
          "new_api": null,
          "old_text": " replicated table",
          "new_text": null,
          "old_line_content": "\t\t\tif (last_part.empty())\t/// Если ещё ни один кусок не был записан с кворумом.",
          "new_line_content": "\t\t\tString last_part;",
          "content_same": false
        },
        {
          "line": 2613,
          "old_api": ");\n\n\t/// Проверяем, что zookeeper_p",
          "new_api": null,
          "old_text": ");\n\n\t/// Проверяем, что zookeeper_p",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tquorum_entry.fromString(quorum_str);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2615,
          "old_api": "а после выполнения предыдущей строки.\n\tStrings replicas;\n\tif (zooke",
          "new_api": null,
          "old_text": "а после выполнения предыдущей строки.\n\tStrings replicas;\n\tif (zooke",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tActiveDataPartSet::parsePartName(quorum_entry.part_name, part_info);",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 2627,
          "old_api": "AllData",
          "new_api": null,
          "old_text": "AllData();\n}\n\n\nvoid StorageReplicatedMergeTree::rename(const String & new_path_to_db, const String & new_database_name, const String & new_ta",
          "new_text": null,
          "old_line_content": "\t\tauto res2 = reader.read(",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 2639,
          "old_api": "able_name;",
          "new_api": null,
          "old_text": "able_name;",
          "new_text": null,
          "old_line_content": "\t\tres.insert(res.end(), res2.begin(), res2.end());",
          "new_line_content": "\t\t\tif (virtual_column == \"_replicated\")",
          "content_same": false
        },
        {
          "line": 2649,
          "old_api": "umber",
          "new_api": null,
          "old_text": "umber(const String & month_name)\n{\n\tauto zookeeper = getZooKeeper();\n\n",
          "new_text": null,
          "old_line_content": "\t\tthrow Exception(\"Table is in readonly mode\", ErrorCodes::TABLE_IS_READ_ONLY);",
          "new_line_content": "\treturn res;",
          "content_same": false
        },
        {
          "line": 2653,
          "old_api": "exists",
          "new_api": null,
          "old_text": "me;\n\tif (!zookeeper->exists(month_path",
          "new_text": null,
          "old_line_content": "\t\tif (ASTInsertQuery * insert = typeid_cast<ASTInsertQuery *>(&*query))",
          "new_line_content": "BlockOutputStreamPtr StorageReplicatedMergeTree::write(ASTPtr query, const Settings & settings)",
          "content_same": false
        },
        {
          "line": 2670,
          "old_api": "::CreateMode::Persistent));\n\t\t\tops",
          "new_api": null,
          "old_text": "::CreateMode::Persistent));\n\t\t\tops",
          "new_text": null,
          "old_line_content": "\tunreplicated_data->clearOldParts();",
          "new_line_content": "\t/// TODO: Мерджить реплицируемые куски тоже.",
          "content_same": false
        },
        {
          "line": 2675,
          "old_api": "tryMulti",
          "new_api": null,
          "old_text": "tryMulti(ops);\n\t}\n\n\treturn AbandonableLockInZooKeeper(\n\t\tzookeeper_path + \"/block_numbers/\" + month",
          "new_text": null,
          "old_line_content": "\tif (!unreplicated_merger->selectPartsToMerge(parts, merged_name, 0, true, true, false, always_can_merge))",
          "new_line_content": "\tstd::lock_guard<std::mutex> lock(unreplicated_mutex);",
          "content_same": false
        },
        {
          "line": 2678,
          "old_api": "*zookeeper);\n}\n\n\nvoid StorageReplicatedMergeTree::waitForAllReplicasT",
          "new_api": null,
          "old_text": "*zookeeper);\n}\n\n\nvoid StorageReplicatedMergeTree::waitForAllReplicasT",
          "new_text": null,
          "old_line_content": "\tconst auto & merge_entry = context.getMergeList().insert(database_name, table_name, merged_name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2679,
          "old_api": "ocessLogEntry",
          "new_api": null,
          "old_text": "ocessLogEntry(const LogEntry & entry)\n{\n\tauto zookeeper = getZooKeeper();\n\tLOG_DEBUG(log, \"Waiting for",
          "new_text": null,
          "old_line_content": "\tunreplicated_merger->mergeParts(parts, merged_name, *merge_entry, settings.min_bytes_to_use_direct_io);",
          "new_line_content": "\tMergeTreeData::DataPartsVector parts;",
          "content_same": false
        },
        {
          "line": 2688,
          "old_api": "essLogEntry",
          "new_api": null,
          "old_text": "essLogEntry(re",
          "new_text": null,
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "\treturn true;",
          "content_same": false
        },
        {
          "line": 2691,
          "old_api": "eplicatedMergeTree::waitForReplicaToProcessLogEntry(const Str",
          "new_api": null,
          "old_text": "eplicatedMergeTree::waitForReplicaToProcessLogEntry(const Str",
          "new_text": null,
          "old_line_content": "\t\tstd::make_unique<MergeTreeMergeBlocker>(*unreplicated_merger) : nullptr;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2693,
          "old_api": "const LogEntry & entry)\n{\n\ta",
          "new_api": null,
          "old_text": " const LogEntry & entry)\n{\n\ta",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Doing ALTER\");",
          "new_line_content": "\tconst String & database_name, const String & table_name, Context & context)",
          "content_same": false
        },
        {
          "line": 2704,
          "old_api": "* 2. Из директории queu",
          "new_api": null,
          "old_text": "* 2. Из директории queu",
          "new_text": null,
          "old_line_content": "\t\tauto table_lock = lockStructureForAlter();",
          "new_line_content": "\tNamesAndTypesList new_alias_columns;",
          "content_same": false
        },
        {
          "line": 2707,
          "old_api": "облема в том, что номера (sequential нод) элементов очереди в log и в q",
          "new_api": null,
          "old_text": "облема в том, что номера (sequential нод) элементов очереди в log и в q",
          "new_text": null,
          "old_line_content": "\t\t\tthrow Exception(\"Can't ALTER readonly table\", ErrorCodes::TABLE_IS_READ_ONLY);",
          "new_line_content": "\tint new_columns_version;",
          "content_same": false
        },
        {
          "line": 2709,
          "old_api": "не совпадают.\n\t  * (И в",
          "new_api": null,
          "old_text": "не совпадают.\n\t  * (И в",
          "new_text": null,
          "old_line_content": "\t\tdata.checkAlter(params);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2715,
          "old_api": "ёт к себе в queue элемент очереди из log,\n\t  *  если она ещё этого не сделала (см. функцию",
          "new_api": null,
          "old_text": "ёт к себе в queue элемент очереди из log,\n\t  *  если она ещё этого не сделала (см. функцию ",
          "new_text": null,
          "old_line_content": "\t\tparams.apply(new_columns, new_materialized_columns, new_alias_columns, new_column_defaults);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2717,
          "old_api": "* Для этого проверяем её узел log_pointer - максимальный номер взятого элемента из log плюс единица.\n\t  */\n\n\tif (0 == entr",
          "new_api": null,
          "old_text": "\t  * Для этого проверяем её узел log_pointer - максимальный номер взятого элемента из log плюс единица.\n\t  */\n\n\tif (0 == entr",
          "new_text": null,
          "old_line_content": "\t\tnew_columns_str = ColumnsDescription<false>{",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2723,
          "old_api": "\"log-\"), \"log-\"))\n\t{\n\t\t/** В этом случае просто берём номер из имени но",
          "new_api": null,
          "old_text": "\"log-\"), \"log-\"))\n\t{\n\t\t/** В этом случае просто берём номер из имени но",
          "new_text": null,
          "old_line_content": "\t\tzookeeper->set(zookeeper_path + \"/columns\", new_columns_str, -1, &stat);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2728,
          "old_api": "substr",
          "new_api": null,
          "old_text": "= parse<UInt64>(entry.znode_name.substr(entry.znode_name.size() - 10));\n\t\tlog_node_nam",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Updated columns in ZooKeeper. Waiting for replicas to apply changes.\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2733,
          "old_api": "get",
          "new_api": null,
          "old_text": " log_pointer = zookeeper->get(zookeeper_path + \"/replicas/\" + replica + ",
          "new_text": null,
          "old_line_content": "\tif (!zookeeper->exists(zookeeper_path + \"/columns\", &stat, alter_query_event))",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": "empty",
          "new_api": null,
          "old_text": "ter\", nullptr, event);\n\t\t\tif (!log_pointer.empty() && parse<UInt64>(log_pointer)",
          "new_text": null,
          "old_line_content": "\t\tthrow Exception(zookeeper_path + \"/columns doesn't exist\", ErrorCodes::NOT_FOUND_NODE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2738,
          "old_api": "compare",
          "new_api": null,
          "old_text": "\n\telse if (0 == entry.znode_name.compare(0, strlen(\"queue-\"), \"queue-\"))\n\t{\n\t\t/** В этом случае номер log-ноды неизвестен. Нужно просмотреть все от log_pointer",
          "new_text": null,
          "old_line_content": "\t\tLOG_WARNING(log, zookeeper_path + \"/columns changed before this ALTER finished; \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2743,
          "old_api": "е содержимым. И если мы её не найдём - значит реплик",
          "new_api": null,
          "old_text": "е содержимым. И если мы её не найдём - значит реплик",
          "new_text": null,
          "old_line_content": "\tStrings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "new_line_content": "\tif (stat.version != new_columns_version)",
          "content_same": false
        },
        {
          "line": 2746,
          "old_api": "get",
          "new_api": null,
          "old_text": "tring log_pointer = zookeeper->get(zookeeper_path + \"/replicas/\"",
          "new_text": null,
          "old_line_content": "\t\tLOG_DEBUG(log, \"Waiting for \" << replica << \" to apply changes\");",
          "new_line_content": "\t\t\t\"overlapping ALTER-s are fine but use caution with nontransitive changes\");",
          "content_same": false
        },
        {
          "line": 2755,
          "old_api": "substr",
          "new_api": null,
          "old_text": "name.substr(log_entry_name.size() - 10));\n\n",
          "new_text": null,
          "old_line_content": "\t\t\t\tLOG_WARNING(log, replica << \" was removed\");",
          "new_line_content": "\t\twhile (!shutdown_called)",
          "content_same": false
        },
        {
          "line": 2764,
          "old_api": "tryGet",
          "new_api": null,
          "old_text": "per->tryGet(zookeeper_path + \"/log/\" + log_entry_name",
          "new_text": null,
          "old_line_content": "\t\t\tif (!zookeeper->exists(zookeeper_path + \"/columns\", &stat))",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 2765,
          "old_api": "str);\n\t\t\tif (exists && entry_str == log_entry_str)\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tlo",
          "new_api": null,
          "old_text": "str);\n\t\t\tif (exists && entry_str == log_entry_str)\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tlo",
          "new_text": null,
          "old_line_content": "\t\t\t\tthrow Exception(zookeeper_path + \"/columns doesn't exist\", ErrorCodes::NOT_FOUND_NODE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2769,
          "old_api": "(found)\n\t\t{\n\t\t\tLOG_DEBUG(log, \"Waiting for \" << replica << \" to pull \" << log_node_name << \" to queue\");\n\n\t\t\t/// Дождемся, пока запись попадет в очередь реп",
          "new_api": null,
          "old_text": "(found)\n\t\t{\n\t\t\tLOG_DEBUG(log, \"Waiting for \" << replica << \" to pull \" << log_node_name << \" to queue\");\n\n\t\t\t/// Дождемся, пока запись попадет в очередь реп",
          "new_text": null,
          "old_line_content": "\t\t\t\tLOG_WARNING(log, zookeeper_path + \"/columns changed before ALTER finished; \"",
          "new_line_content": "\t\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 2774,
          "old_api": "get",
          "new_api": null,
          "old_text": "\t\t\tzkutil::EventPtr event = new Poco::Event;\n\n\t\t\t\tString log_pointer = zookeeper->get(zookeeper_p",
          "new_text": null,
          "old_line_content": "\t\t\tif (!zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/columns\", &stat, alter_query_event))",
          "new_line_content": "\t\t\tif (stat.version != new_columns_version)",
          "content_same": false
        },
        {
          "line": 2798,
          "old_api": "адать ни с log-узло",
          "new_api": null,
          "old_text": "адать ни с log-узло",
          "new_text": null,
          "old_line_content": "\tconst auto & lut = DateLUT::instance();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2799,
          "old_api": "ас).\n\t  * Поэтому, ищем путём ср",
          "new_api": null,
          "old_text": "ас).\n\t  * Поэтому, ищем путём ср",
          "new_text": null,
          "old_line_content": "\ttime_t start_time = lut.YYYYMMDDToDate(parse<UInt32>(month_name + \"01\"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2800,
          "old_api": "/\n\n\tStrings queue_entrie",
          "new_api": null,
          "old_text": "/\n\n\tStrings queue_entrie",
          "new_text": null,
          "old_line_content": "\tDayNum_t left_date = lut.toDayNum(start_time);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2801,
          "old_api": "+ \"/queue\");\n\tString queue_",
          "new_api": null,
          "old_text": "+ \"/queue\");\n\tString queue_",
          "new_text": null,
          "old_line_content": "\tDayNum_t right_date = DayNum_t(static_cast<size_t>(left_date) + lut.daysInMonth(start_time) - 1);",
          "new_line_content": "/// Название воображаемого куска, покрывающего все возможные куски в указанном месяце с номерами в указанном диапазоне.",
          "content_same": false
        },
        {
          "line": 2804,
          "old_api": "queue_entry_str);\n\t\tif (exists && queue_entry_str == entry_str)\n\t\t{\n\t\t\tqueue_entry_t",
          "new_api": null,
          "old_text": "queue_entry_str);\n\t\tif (exists && queue_entry_str == entry_str)\n\t\t{\n\t\t\tqueue_entry_t",
          "new_text": null,
          "old_line_content": "\treturn ActiveDataPartSet::getPartName(left_date, right_date, left, right, right - left + 1);",
          "new_line_content": "\t/// Диапазон дат - весь месяц.",
          "content_same": false
        },
        {
          "line": 2816,
          "old_api": "t_for);\n}\n\n\nvoid St",
          "new_api": null,
          "old_text": "t_for);\n}\n\n\nvoid St",
          "new_text": null,
          "old_line_content": "\tauto structure_lock = lockStructure(true);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2818,
          "old_api": "etStatus",
          "new_api": null,
          "old_text": "etStatus(Status & res, bool with_zk_fiel",
          "new_text": null,
          "old_line_content": "\tconst DayNum_t month = MergeTreeData::getMonthDayNum(partition);",
          "new_line_content": "\t\treturn;",
          "content_same": false
        },
        {
          "line": 2821,
          "old_api": "der_node;\n\tres.is_readonly = is_r",
          "new_api": null,
          "old_text": "der_node;\n\tres.is_readonly = is_r",
          "new_text": null,
          "old_line_content": "\tMergeTreeData::DataParts parts = unreplicated_data->getDataParts();",
          "new_line_content": "\t/// Это защищает от \"оживания\" данных за удалённую партицию после завершения мерджа.",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "w_part_name\n\t\t\t\t\t+ \" because part \" + name + \" is not r",
          "new_api": null,
          "old_text": "w_part_name\n\t\t\t\t\t+ \" because part \" + name + \" is not r",
          "new_text": null,
          "old_line_content": "\t\tString s = zookeeper->get(replica_path + \"/queue/\" + child, &stat);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": "that part is being proce",
          "new_api": null,
          "old_text": "that part is being proce",
          "new_text": null,
          "old_line_content": "\t\tLogEntryPtr entry = LogEntry::parse(s, stat);",
          "new_line_content": "\tfor (const String & child : children)",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": "n);\n\t\t\t\tout_postpone_reason = reason;",
          "new_api": null,
          "old_text": "n);\n\t\t\t\tout_postpone_reason = reason;",
          "new_text": null,
          "old_line_content": "\t\tentry->addResultToVirtualParts(*this);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": "return false;\n\t\t\t}",
          "new_api": null,
          "old_text": "\treturn false;\n\t\t\t}\n\t\t",
          "new_text": null,
          "old_line_content": "\t\tqueue.push_back(entry);",
          "new_line_content": "\tfor (auto & future : futures)",
          "content_same": false
        },
        {
          "line": 2832,
          "old_api": "size",
          "new_api": null,
          "old_text": "e = queue.size();\n\t\tres.last_queue_update = last",
          "new_text": null,
          "old_line_content": "\t\t\tunreplicated_data->renameAndDetachPart(part, \"\");",
          "new_line_content": "\t\tif (part->month != month)",
          "content_same": false
        },
        {
          "line": 2834,
          "old_api": "e;\n\n\t\tres.inserts_in_queue = 0;\n\t\tres.merges_in_qu",
          "new_api": null,
          "old_text": "e;\n\n\t\tres.inserts_in_queue = 0;\n\t\tres.merges_in_qu",
          "new_text": null,
          "old_line_content": "\t\t\tunreplicated_data->replaceParts({part}, {}, false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2837,
          "old_api": "& entry : queue)\n\t\t{",
          "new_api": null,
          "old_text": " & entry : queue)\n\t\t{\n",
          "new_text": null,
          "old_line_content": "\tLOG_INFO(log, (detach ? \"Detached \" : \"Removed \") << removed_parts << \" unreplicated parts inside \" << apply_visitor(FieldVisitorToString(), partition) << \".\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": "n = reason;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn",
          "new_api": null,
          "old_text": "n = reason;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn ",
          "new_text": null,
          "old_line_content": "\tString index_str = zookeeper->get(replica_path + \"/log_pointer\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "executeDropRange(entry);\n\t\treturn true;\n\t}",
          "new_api": null,
          "old_text": "\t\texecuteDropRange(entry);\n\t\treturn true;\n\t}\n\n\t",
          "new_text": null,
          "old_line_content": "\t\tStrings entries = zookeeper->getChildren(zookeeper_path + \"/log\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2845,
          "old_api": "{\n\t\t\t\t++res.inserts_in_queue;\n\n\t\t\t\tif (entry->cr",
          "new_api": null,
          "old_text": "\t\t{\n\t\t\t\t++res.inserts_in_queue;\n\n\t\t\t\tif (entry->cr",
          "new_text": null,
          "old_line_content": "\t\tdropUnreplicatedPartition(field, detach, settings);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": "щий его кусок,",
          "new_api": null,
          "old_text": "щий его кусок, ",
          "new_text": null,
          "old_line_content": "\t\tzookeeper->set(replica_path + \"/log_pointer\", toString(index));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2849,
          "old_api": "time || entry-",
          "new_api": null,
          "old_text": "time || entry-",
          "new_text": null,
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2850,
          "old_api": "rts_oldest_time))\n\t\t\t\t{\n\t\t\t\t\tres.i",
          "new_api": null,
          "old_text": "rts_oldest_time))\n\t\t\t\t{\n\t\t\t\t\tres.i",
          "new_text": null,
          "old_line_content": "\tString month_name = MergeTreeData::getMonthName(field);",
          "new_line_content": "\tif (unreplicated)",
          "content_same": false
        },
        {
          "line": 2858,
          "old_api": "e && (!res.merges_oldest_time || entry->create_time < res.merge",
          "new_api": null,
          "old_text": "e && (!res.merges_oldest_time || entry->create_time < res.merge",
          "new_text": null,
          "old_line_content": "\t\t\tthrow Exception(\"No active replicas\", ErrorCodes::NO_ACTIVE_REPLICAS);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": "быть в zookeepe",
          "new_api": null,
          "old_text": "быть в zookeepe",
          "new_text": null,
          "old_line_content": "\twhile (zookeeper->tryGet(zookeeper_path + \"/log/log-\" + padIndex(index), entry_str, &stat))",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 2860,
          "old_api": "oldest_time = entry",
          "new_api": null,
          "old_text": "oldest_time = entry",
          "new_text": null,
          "old_line_content": "\t\tstd::sort(live_replicas.begin(), live_replicas.end());",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2861,
          "old_api": "}\n\t\t}\n\t}\n\n\t{\n\t\tstd:",
          "new_api": null,
          "old_text": "\t\t}\n\t\t}\n\t}\n\n\t{\n\t\tstd:",
          "new_text": null,
          "old_line_content": "\t\tconst auto leader = zookeeper->get(zookeeper_path + \"/leader_election/\" + live_replicas.front());",
          "new_line_content": "\t\t/// Проксируем запрос в лидера.",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "sts",
          "new_api": null,
          "old_text": "sts(replica_path + \"/parts/\" + c",
          "new_text": null,
          "old_line_content": "\t\tLogEntryPtr entry = LogEntry::parse(entry_str, stat);",
          "new_line_content": "\tString entry_str;",
          "content_same": false
        },
        {
          "line": 2866,
          "old_api": "es.replica_path = replica_path;\n\tres.columns_version = columns_v",
          "new_api": null,
          "old_text": "es.replica_path = replica_path;\n\tres.columns_version = columns_v",
          "new_text": null,
          "old_line_content": "\t\tReplicatedMergeTreeAddress leader_address(zookeeper->get(zookeeper_path + \"/replicas/\" + leader + \"/host\"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": "\" << entry.new_part_name << \" - part already exists.\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (entry.type == LogEntry::GET_PART && entry.source_replica == replica_",
          "new_api": null,
          "old_text": " \" << entry.new_part_name << \" - part already exists.\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (entry.type == LogEntry::GET_PART && entry.source_replica == replica_",
          "new_text": null,
          "old_line_content": "\t\tops.push_back(new zkutil::Op::Create(",
          "new_line_content": "\t\t++count;",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": "(entry.type == LogEntry::",
          "new_api": null,
          "old_text": " (entry.type == LogEntry::",
          "new_text": null,
          "old_line_content": "\t\t\treplica_path + \"/queue/queue-\", entry_str, zookeeper->getDefaultACL(), zkutil::CreateMode::PersistentSequential));",
          "new_line_content": "\t\t++index;",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": ")\n\t\tLOG_WARNING(log, \"Part \" << entry.new_part_name << \" from own log doesn't exist.\");\n\n\t///",
          "new_api": null,
          "old_text": ")\n\t\tLOG_WARNING(log, \"Part \" << entry.new_part_name << \" from own log doesn't exist.\");\n\n\t/// ",
          "new_text": null,
          "old_line_content": "\t\tops.push_back(new zkutil::Op::SetData(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2869,
          "old_api": "{\n\t\tres.log_max_index = 0;\n\t\tres.log_p",
          "new_api": null,
          "old_text": "\n\t{\n\t\tres.log_max_index = 0;\n\t\tres.log_p",
          "new_text": null,
          "old_line_content": "\t\tauto & alter = typeid_cast<ASTAlterQuery &>(*new_query);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": "к нам не нужен, так к",
          "new_api": null,
          "old_text": "к нам не нужен, так к",
          "new_text": null,
          "old_line_content": "\t\tauto results = zookeeper->multi(ops);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": "ворум пофейлился (см. ниже про /quorum/failed_parts).\n\tif (",
          "new_api": null,
          "old_text": "ворум пофейлился (см. ниже про /quorum/failed_parts).\n\tif (",
          "new_text": null,
          "old_line_content": "\t\tString path_created = dynamic_cast<zkutil::Op::Create &>(ops[0]).getPathCreated();",
          "new_line_content": "\t\tzkutil::Ops ops;",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": "\" becau",
          "new_api": null,
          "old_text": "\" becau",
          "new_text": null,
          "old_line_content": "\tlast_queue_update = time(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2882,
          "old_api": "UInt64>(log_pointer_str",
          "new_api": null,
          "old_text": "UInt64>(log_pointer_str",
          "new_text": null,
          "old_line_content": "\t\tRemoteBlockInputStream stream(connection, formattedAST(new_query), &settings);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2885,
          "old_api": "zookeeper_path + \"/repli",
          "new_api": null,
          "old_text": "zookeeper_path + \"/repli",
          "new_text": null,
          "old_line_content": "\t\tcopyData(stream, output);",
          "new_line_content": "\t\t\tleader_address.queries_port,",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": "}\n\n\tbool do_fetch = fa",
          "new_api": null,
          "old_text": "\n\t}\n\n\tbool do_fetch = fa",
          "new_text": null,
          "old_line_content": "\t\t\tnext_update_event->set();",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "gEntry::MERGE_PARTS",
          "new_api": null,
          "old_text": "gEntry::MERGE_PARTS",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Pulled \" << count << \" entries to queue: log-\" << padIndex(first_index) << \" - log-\" << padIndex(index - 1));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2898,
          "old_api": "}\n\n\nvoid StorageReplicatedMerg",
          "new_api": null,
          "old_text": "\n}\n\n\nvoid StorageReplicatedMerg",
          "new_text": null,
          "old_line_content": "\t\tAbandonableLockInZooKeeper block_number_lock = allocateBlockNumber(month_name);",
          "new_line_content": "\t  * Инвариант: в логе не появятся слияния удаляемых кусков с другими кусками.",
          "content_same": false
        },
        {
          "line": 2899,
          "old_api": "Partition",
          "new_api": null,
          "old_text": "Partition(const Field & parti",
          "new_text": null,
          "old_line_content": "\t\tright = block_number_lock.getNumber();",
          "new_line_content": "\t  * NOTE: Если понадобится аналогично поддержать запрос DROP PART, для него придется придумать какой-нибудь новый механизм,",
          "content_same": false
        },
        {
          "line": 2900,
          "old_api": ", const String & from_, co",
          "new_api": null,
          "old_text": ", const String & from_, co",
          "new_text": null,
          "old_line_content": "\t\tblock_number_lock.unlock();",
          "new_line_content": "\t  *        чтобы гарантировать этот инвариант.",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "getActiveContainingPart",
          "new_api": null,
          "old_text": ".getActiveContainingPart(name);\n\t\t\tif (",
          "new_text": null,
          "old_line_content": "\t\tif (future_parts.count(entry.new_part_name))",
          "new_line_content": "bool StorageReplicatedMergeTree::shouldExecuteLogEntry(const LogEntry & entry, String & out_postpone_reason)",
          "content_same": false
        },
        {
          "line": 2908,
          "old_api": "partition \" << partition_str << \" from shard",
          "new_api": null,
          "old_text": "partition \" << partition_str << \" from shard",
          "new_text": null,
          "old_line_content": "\tString fake_part_name = getFakePartNameForDrop(month_name, 0, right);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": "d into \" << entry.new_",
          "new_api": null,
          "old_text": "d into \" << entry.new_",
          "new_text": null,
          "old_line_content": "\t\t\tLOG_DEBUG(log, reason);",
          "new_line_content": "\tif (entry.type == LogEntry::MERGE_PARTS || entry.type == LogEntry::GET_PART || entry.type == LogEntry::ATTACH_PART)",
          "content_same": false
        },
        {
          "line": 2916,
          "old_api": "\" + partition_str + \" is already",
          "new_api": null,
          "old_text": "\" + partition_str + \" is already ",
          "new_text": null,
          "old_line_content": "\t\tvirtual_parts.add(fake_part_name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": "SpaceMonitor::reserve(full_path, sum_parts_size_in_bytes);\n\n\t\t\taut",
          "new_api": null,
          "old_text": "SpaceMonitor::reserve(full_path, sum_parts_size_in_bytes);\n\n\t\t\taut",
          "new_text": null,
          "old_line_content": "\t\tActiveDataPartSet::parsePartName(entry.new_part_name, result_part);",
          "new_line_content": "\t\t\t  *  и элемент очереди будет сразу считаться обработанным.",
          "content_same": false
        },
        {
          "line": 2925,
          "old_api": "replica + \"/is_a",
          "new_api": null,
          "old_text": "replica + \"/is_a",
          "new_text": null,
          "old_line_content": "\tString log_znode_path = zookeeper->create(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2926,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"No active replicas fo",
          "new_text": null,
          "old_line_content": "\tentry.znode_name = log_znode_path.substr(log_znode_path.find_last_of('/') + 1);",
          "new_line_content": "\t/// Наконец, добившись нужных инвариантов, можно положить запись в лог.",
          "content_same": false
        },
        {
          "line": 2927,
          "old_api": "::NO_AC",
          "new_api": null,
          "old_text": "::NO_AC",
          "new_text": null,
          "old_line_content": "\tentry.create_time = time(0);",
          "new_line_content": "\tLogEntry entry;",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": "mergeParts",
          "new_api": null,
          "old_text": "ger.mergeParts(\n\t\t\t\tparts, entry.new_part_name, *merge_entry, a",
          "new_text": null,
          "old_line_content": "\t\t\tActiveDataPartSet::parsePartName(future_part_name, future_part);",
          "new_line_content": "\t\tActiveDataPartSet::Part result_part;",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": "ld, &transaction, reserved_space)",
          "new_api": null,
          "old_text": "ld, &transaction, reserved_space)",
          "new_text": null,
          "old_line_content": "\t\t\tif (future_part.contains(result_part))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "иже к zookeeper->multi",
          "new_api": null,
          "old_text": "иже к zookeeper->multi",
          "new_text": null,
          "old_line_content": "\t\t\t\tLOG_DEBUG(log, reason);",
          "new_line_content": "\t\t\tActiveDataPartSet::Part future_part;",
          "content_same": false
        },
        {
          "line": 2935,
          "old_api": "NOTE Разумеется, здесь есть data race-ы. М",
          "new_api": null,
          "old_text": "NOTE Разумеется, здесь есть data race-ы. М",
          "new_text": null,
          "old_line_content": "\t\t\twaitForAllReplicasToProcessLogEntry(entry);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2946,
          "old_api": "replica;\n\n\t\tString log",
          "new_api": null,
          "old_text": " replica;\n\n\t\tString log",
          "new_text": null,
          "old_line_content": "\t\tpartition = field.safeGet<String>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2948,
          "old_api": "get",
          "new_api": null,
          "old_text": "er->get(current_replica_path + \"/l",
          "new_text": null,
          "old_line_content": "\t\tpartition = MergeTreeData::getMonthName(field);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": "ок есть, ещё сама не усп",
          "new_api": null,
          "old_text": "ок есть, ещё сама не усп",
          "new_text": null,
          "old_line_content": "\t\t\tif (future_parts.count(name))",
          "new_line_content": "\t\t/** Если какая-то из нужных частей сейчас передается или мерджится, подождем окончания этой операции.",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "eplica == replica_name",
          "new_api": null,
          "old_text": "eplica == replica_name",
          "new_text": null,
          "old_line_content": "\t\t\t\tLOG_TRACE(log, reason);",
          "new_line_content": "\t\t  */",
          "content_same": false
        },
        {
          "line": 2956,
          "old_api": "numChildren;\n\n\t\tif (log_po",
          "new_api": null,
          "old_text": "numChildren;\n\n\t\tif (log_po",
          "new_text": null,
          "old_line_content": "\t\tparts.push_back(partition);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2960,
          "old_api": "pointer\n\t\t\t|| (log_pointer == max_log_pointer && queue_size < min_queue_size))\n\t\t{\n\t\t\tm",
          "new_api": null,
          "old_text": "pointer\n\t\t\t|| (log_pointer == max_log_pointer && queue_size < min_queue_size))\n\t\t{\n\t\t\tm",
          "new_text": null,
          "old_line_content": "\t\tLOG_DEBUG(log, \"Looking for parts for partition \" << partition << \" in \" << source_dir);",
          "new_line_content": "\tStrings parts;",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": "ATTACH_PART log ent",
          "new_api": null,
          "old_text": " ATTACH_PART log ent",
          "new_text": null,
          "old_line_content": "\t\tif (merger.isCancelled())",
          "new_line_content": "\t\t\t\t\t+ \" because part \" + name + \" is not ready yet (log entry for that part is being processed).\";",
          "content_same": false
        },
        {
          "line": 2962,
          "old_api": "hrow Exception(\"Logical e",
          "new_api": null,
          "old_text": "hrow Exception(\"Logical e",
          "new_text": null,
          "old_line_content": "\t\tfor (Poco::DirectoryIterator it = Poco::DirectoryIterator(full_path + source_dir); it != Poco::DirectoryIterator(); ++it)",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": "подцепит кусок.\n\t\t\t\tw",
          "new_api": null,
          "old_text": " подцепит кусок.\n\t\t\t\tw",
          "new_text": null,
          "old_line_content": "\t\t\tLOG_DEBUG(log, reason);",
          "new_line_content": "\t\t\t\treturn false;",
          "content_same": false
        },
        {
          "line": 2964,
          "old_api": "ica.\", Er",
          "new_api": null,
          "old_text": "ica.\", Er",
          "new_text": null,
          "old_line_content": "\t\t\tString name = it.name();",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 2965,
          "old_api": "LOGICAL_ERROR);\n\n\tLOG_INFO(log, \"Found \"",
          "new_api": null,
          "old_text": "LOGICAL_ERROR);\n\n\tLOG_INFO(log, \"Found \"",
          "new_text": null,
          "old_line_content": "\t\t\tif (!ActiveDataPartSet::isPartDirectory(name))",
          "new_line_content": "\telse",
          "content_same": false
        },
        {
          "line": 2970,
          "old_api": "tch from.\");\n\n\tString",
          "new_api": null,
          "old_text": "tch from.\");\n\n\tString ",
          "new_text": null,
          "old_line_content": "\t\t\tactive_parts.add(name);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2973,
          "old_api": "ки есть на лучшей репли",
          "new_api": null,
          "old_text": "ки есть на лучшей репли",
          "new_text": null,
          "old_line_content": "\t\tparts = active_parts.getParts();",
          "new_line_content": "\t\t\t\tcontinue;",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": "щё недостигнут",
          "new_api": null,
          "old_text": "щё недостигнут",
          "new_text": null,
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "рямо сейчас скачать),",
          "new_api": null,
          "old_text": "рямо сейчас скачать),\n\t",
          "new_text": null,
          "old_line_content": "\t\texecuteDropRange(entry);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2981,
          "old_api": "if (try_no >= 5)\n\t\t\tthrow Exception(\"Too much",
          "new_api": null,
          "old_text": "\tif (try_no >= 5)\n\t\t\tthrow Exception(\"Too much",
          "new_text": null,
          "old_line_content": "\t\tdata.loadPartAndFixMetadata(source_dir + part);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "ion",
          "new_api": null,
          "old_text": "ion(\"Logical error: log entry with quorum have em",
          "new_text": null,
          "old_line_content": "\t\tMergeTreeData::DataPartPtr containing_part = data.getActiveContainingPart(entry.new_part_name);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 2990,
          "old_api": ":move(parts_to_fetc",
          "new_api": null,
          "old_text": ":move(parts_to_fetc",
          "new_text": null,
          "old_line_content": "\t\tauto existing_parts = data.getDataParts();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "* - если реплики не стали активными;\n\t\t\t\t\t  * - если сущест",
          "new_api": null,
          "old_text": "\n\t\t\t\t\t  * - если реплики не стали активными;\n\t\t\t\t\t  * - если сущест",
          "new_text": null,
          "old_line_content": "\t\tif (containing_part && zookeeper->exists(replica_path + \"/parts/\" + containing_part->name))",
          "new_line_content": "\t\tentry.type == LogEntry::MERGE_PARTS ||",
          "content_same": false
        },
        {
          "line": 2993,
          "old_api": "\" on \" + best_replica_path + \" doesn",
          "new_api": null,
          "old_text": " \" on \" + best_replica_path + \" doesn",
          "new_text": null,
          "old_line_content": "\t\t\t\tmin_used_number = std::min(min_used_number, part->left);",
          "new_line_content": "\tInt64 min_used_number = RESERVED_BLOCK_NUMBERS;",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": "nt_block_numbers, чтобы разрешить мерджи через номер потерянного куска;\n\t\t\t\t\t  * - добавим кусо",
          "new_api": null,
          "old_text": "nt_block_numbers, чтобы разрешить мерджи через номер потерянного куска;\n\t\t\t\t\t  * - добавим кусо",
          "new_text": null,
          "old_line_content": "\t\t\t\tLOG_DEBUG(log, \"Skipping action for part \" << entry.new_part_name << \" - part already exists.\");",
          "new_line_content": "\t\t/// Если у нас уже есть этот кусок или покрывающий его кусок, ничего делать не нужно.",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "_num, то удалим его;\n\t\t\t\t\t  *\n\t\t\t\t\t  * Если что-то изменится, то ничего не сделаем",
          "new_api": null,
          "old_text": "_num, то удалим его;\n\t\t\t\t\t  *\n\t\t\t\t\t  * Если что-то изменится, то ничего не сделаем",
          "new_text": null,
          "old_line_content": "\t\tLOG_WARNING(log, \"Part \" << entry.new_part_name << \" from own log doesn't exist.\");",
          "new_line_content": "\t\t\tif (!(entry.type == LogEntry::GET_PART && entry.source_replica == replica_name))",
          "content_same": false
        },
        {
          "line": 3003,
          "old_api": "empty",
          "new_api": null,
          "old_text": "g_part.empty())\n\t\t\t\t\tparts_to_fetch.push_back(con",
          "new_text": null,
          "old_line_content": "\t\tActiveDataPartSet::parsePartName(part_name, part);",
          "new_line_content": "\t/// Добавим записи в лог.",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "волит проследить, что реплики не стали активными.\n\t\t\t\t\t  */\n\n\t\t\t\t\tStrings replica",
          "new_api": null,
          "old_text": "волит проследить, что реплики не стали активными.\n\t\t\t\t\t  */\n\n\t\t\t\t\tStrings replica",
          "new_text": null,
          "old_line_content": "\tif (entry.quorum && zookeeper->exists(zookeeper_path + \"/quorum/failed_parts/\" + entry.new_part_name))",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 3005,
          "old_api": "\" on replica \" << best_replica_path << \" has been vanished.\");\n\t\t\t}\n\t\t}\n\n\t\tLOG_INFO(log, \"Parts to",
          "new_api": null,
          "old_text": "\" on replica \" << best_replica_path << \" has been vanished.\");\n\t\t\t}\n\t\t}\n\n\t\tLOG_INFO(log, \"Parts to",
          "new_text": null,
          "old_line_content": "\t\tString new_part_name = ActiveDataPartSet::getPartName(part.left_date, part.right_date, part.left, part.right, part.level);",
          "new_line_content": "\tstd::list<LogEntry> entries;",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "keeper->getChildren(zookeeper_path + \"/replicas\");\n\n\t\t\t\t\tzkutil::Ops ops;\n\n\t\t\t\t\tfor (size_t i = 0, size = replica",
          "new_text": null,
          "old_line_content": "\t\tLOG_DEBUG(log, \"Skipping action for part \" << entry.new_part_name << \" because quorum for that part was failed.\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3007,
          "old_api": "size",
          "new_api": null,
          "old_text": "h: \" << parts_to_fetch.size());\n\n\t\tmissing_parts.clear();\n\t\tfor (cons",
          "new_text": null,
          "old_line_content": "\t\tLOG_INFO(log, \"Will attach \" << part_name << \" as \" << new_part_name);",
          "new_line_content": "\tfor (const String & part_name : parts)",
          "content_same": false
        },
        {
          "line": 3009,
          "old_api": "ing & part : parts_to_",
          "new_api": null,
          "old_text": "ing & part : parts_to_",
          "new_text": null,
          "old_line_content": "\t\tentries.emplace_back();",
          "new_line_content": "\t\tActiveDataPartSet::Part part;",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": "жным куском.\n\t\t\t\t\treplic",
          "new_api": null,
          "old_text": "жным куском.\n\t\t\t\t\treplic",
          "new_text": null,
          "old_line_content": "\t\tdo_fetch = !executeAttachPart(entry);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3018,
          "old_api": "empty",
          "new_api": null,
          "old_text": "\t\t\t}\n\t\t}\n\n\t\t++try_no;\n\t} while (!missing_parts.empty());\n}\n\n\nvoid StorageReplicatedMergeTree::freezePartition(const Field & partition, const Settings & setting",
          "new_text": null,
          "old_line_content": "\t\tops.push_back(new zkutil::Op::Create(",
          "new_line_content": "\t\tentry.type = LogEntry::ATTACH_PART;",
          "content_same": false
        },
        {
          "line": 3019,
          "old_api": "ree::freezePartition(const",
          "new_api": null,
          "old_text": "ree::freezePartition(const",
          "new_text": null,
          "old_line_content": "\t\t\tzookeeper_path + \"/log/log-\", entry.toString(), zookeeper->getDefaultACL(), zkutil::CreateMode::PersistentSequential));",
          "new_line_content": "\t\tentry.source_replica = replica_name;",
          "content_same": false
        },
        {
          "line": 3022,
          "old_api": "// Префикс может быть произвольным. Не о",
          "new_api": null,
          "old_text": "// Префикс может быть произвольным. Не о",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Adding attaches to log\");",
          "new_line_content": "\t\tentry.attach_unreplicated = unreplicated;",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": "го тоже не может быть.",
          "new_api": null,
          "old_text": "го тоже не может быть.\n\n\t\t\t",
          "new_text": null,
          "old_line_content": "\t\tfor (auto i : ext::range(0, entry.parts_to_merge.size()))",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": "str = zookeeper->ge",
          "new_api": null,
          "old_text": "str = zookeeper->ge",
          "new_text": null,
          "old_line_content": "\t\tLOG_TRACE(log, log_message.rdbuf());",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 3031,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tString log_znode_path = dynamic_cast<zkutil::Op::Create &>(ops[i]).getPathCreated();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3032,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tentry.znode_name = log_znode_path.substr(log_znode_path.find_last_of('/') + 1);",
          "new_line_content": "\t/// Если надо - дожидаемся выполнения операции на себе или на всех репликах.",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": ".new_part_name)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tops",
          "new_api": null,
          "old_text": ".new_part_name)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tops",
          "new_text": null,
          "old_line_content": "\t\t\tMergeTreeData::DataPartPtr part = data.getActiveContainingPart(name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3035,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\t\twaitForReplicaToProcessLogEntry(replica_name, entry);",
          "new_line_content": "\t\tsize_t i = 0;",
          "content_same": false
        },
        {
          "line": 3037,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\t\twaitForAllReplicasToProcessLogEntry(entry);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": "substr",
          "new_api": null,
          "old_text": "r = entry.new_part_name.substr(0, 6);\n\t\t\t\t\t\t\tActiveDataPartSet::Part part_info;\n\t\t\t\t\t\t\tActiveDataPartSet::parsePartName(entry.new_part_name, part_info);\n\n\t\t\t\t\t\t\tif (",
          "new_text": null,
          "old_line_content": "\t\t\t\tLOG_WARNING(log, \"Part \" << name << \" is covered by \" << part->name",
          "new_line_content": "\t\t\tif (!part)",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "Exception",
          "new_api": null,
          "old_text": "Exception(\"Logical er",
          "new_text": null,
          "old_line_content": "\t\t\tparts.push_back(part);",
          "new_line_content": "\t\t\tif (part->name != name)",
          "content_same": false
        },
        {
          "line": 3048,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tthrow Exception(\"Can't drop readonly replicated table (need to drop data in ZooKeeper as well)\", ErrorCodes::TABLE_IS_READ_ONLY);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 3050,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3052,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tshutdown();",
          "new_line_content": "void StorageReplicatedMergeTree::drop()",
          "content_same": false
        },
        {
          "line": 3054,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tLOG_INFO(log, \"Removing replica \" << replica_path);",
          "new_line_content": "\tif (is_readonly)",
          "content_same": false
        },
        {
          "line": 3056,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tzookeeper->tryRemoveRecursive(replica_path);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3060,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tif (zookeeper->tryGetChildren(zookeeper_path + \"/replicas\", replicas) == ZOK && replicas.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3062,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tLOG_INFO(log, \"Removing table \" << zookeeper_path << \" (this might take several minutes)\");",
          "new_line_content": "\treplica_is_active_node = nullptr;",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": "ath + \"/blocks/\" + entry.block_id))",
          "new_api": null,
          "old_text": "ath + \"/blocks/\" + entry.block_id))\n\t\t\t\t\t\t\t",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tpool_context.incrementCounter(\"big merges\");",
          "new_line_content": "\t\telse",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "\t\t\tops.push_back(new zkutil::Op::Remove(zookeeper_path",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tpool_context.incrementCounter(\"replicated big merges\");",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 3066,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tdata.dropAllData();",
          "new_line_content": "\tStrings replicas;",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "push_back(new zkutil::Op::Remove(zookeeper_path + \"/b",
          "new_text": null,
          "old_line_content": "\t\t\tsize_t sum_parts_size_in_bytes = MergeTreeDataMerger::estimateDiskSpaceForMerge(parts);",
          "new_line_content": "\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": "locks/\" + entry.block_id, -1));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tauto code =",
          "new_api": null,
          "old_text": "locks/\" + entry.block_id, -1));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tauto code = ",
          "new_text": null,
          "old_line_content": "\t\t\tDiskSpaceMonitor::ReservationPtr reserved_space = DiskSpaceMonitor::reserve(full_path, sum_parts_size_in_bytes);",
          "new_line_content": "\t\t\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 3072,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tstd::string new_full_path = new_path_to_db + escapeForFileName(new_table_name) + '/';",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": ";\n\n\t\t\t\t\t\t\tif (code =",
          "new_api": null,
          "old_text": ";\n\n\t\t\t\t\t\t\tif (code =",
          "new_text": null,
          "old_line_content": "\t\t\tauto table_lock = lockStructure(false);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 3074,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tdata.setPath(new_full_path, true);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3076,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tunreplicated_data->setPath(new_full_path + \"unreplicated/\", false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": "о нужно только для ме",
          "new_api": null,
          "old_text": "о нужно только для ме",
          "new_text": null,
          "old_line_content": "\t\t\tsize_t aio_threshold = context.getSettings().min_bytes_to_use_direct_io;",
          "new_line_content": "\t\t\t/// Может бросить исключение.",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": "ODE || code == ZNODEEXISTS)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tLOG_DEBUG(log, \"State was changed or isn't expected when trying",
          "new_api": null,
          "old_text": "ODE || code == ZNODEEXISTS)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tLOG_DEBUG(log, \"State was changed or isn't expected when trying ",
          "new_text": null,
          "old_line_content": "\t\t\tMergeTreeData::DataPartPtr part = merger.mergeParts(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": "<< entry.new_part_name << \"",
          "new_api": null,
          "old_text": "\t\t\t\t\t\t\t\t\t<< entry.new_part_name << \" ",
          "new_text": null,
          "old_line_content": "\t\t\tcheckPartAndAddToZooKeeper(part, ops);",
          "new_line_content": "\t\t\tMergeTreeData::Transaction transaction;",
          "content_same": false
        },
        {
          "line": 3088,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": "ns entry about anothe",
          "new_api": null,
          "old_text": "ns entry about anothe",
          "new_text": null,
          "old_line_content": "\t\t\tzookeeper->multi(ops);",
          "new_line_content": "\t\t\tzkutil::Ops ops;",
          "content_same": false
        },
        {
          "line": 3091,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tif (!zookeeper->exists(month_path))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3096,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tauto acl = zookeeper->getDefaultACL();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3097,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tops.push_back(new zkutil::Op::Create(month_path, \"\", acl, zkutil::CreateMode::Persistent));",
          "new_line_content": "\tString month_path = zookeeper_path + \"/block_numbers/\" + month_name;",
          "content_same": false
        },
        {
          "line": 1050,
          "old_api": "+ replica, false, en",
          "new_api": null,
          "old_text": "+ replica, false, en",
          "new_text": null,
          "old_line_content": "\t\t\ttransaction.commit();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "uorum);\n\n\t\t\tif (entry.type",
          "new_api": null,
          "old_text": "uorum);\n\n\t\t\tif (entry.type ",
          "new_text": null,
          "old_line_content": "\t\t\tmerge_selecting_event.set();",
          "new_line_content": "\t\t\t/** Удаление старых кусков из ZK и с диска делается отложенно - см. ReplicatedMergeTreeCleanupThread, clearOldParts.",
          "content_same": false
        },
        {
          "line": 3100,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tops.push_back(new zkutil::Op::Create(month_path + \"/skip_increment\", \"\", acl, zkutil::CreateMode::Persistent));",
          "new_line_content": "\t\t/// Создадим в block_numbers ноду для месяца и пропустим в ней 200 значений инкремента.",
          "content_same": false
        },
        {
          "line": 1053,
          "old_api": "Entry::MERGE_PARTS)\n\t\t\t\tProfileEvents::increment(ProfileEvent",
          "new_api": null,
          "old_text": "Entry::MERGE_PARTS)\n\t\t\t\tProfileEvents::increment(ProfileEvent",
          "new_text": null,
          "old_line_content": "\t\t\tProfileEvents::increment(ProfileEvents::ReplicatedPartMerges);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3101,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tops.push_back(new zkutil::Op::Remove(month_path + \"/skip_increment\", -1));",
          "new_line_content": "\t\t/// Нужно, чтобы в будущем при необходимости можно было добавить данные в начало.",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": "ого мерджа,\n\t\t\t  * а попытаться сразу получить п",
          "new_api": null,
          "old_text": "ого мерджа,\n\t\t\t  * а попытаться сразу получить п",
          "new_text": null,
          "old_line_content": "\t\t\treplica = findReplicaHavingPart(entry.new_part_name, true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3115,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "\t\tzookeeper_path + \"/block_numbers/\" + month_name + \"/block-\",",
          "content_same": false
        },
        {
          "line": 1069,
          "old_api": "й кусок. Чтобы",
          "new_api": null,
          "old_text": "й кусок. Чтобы ",
          "new_text": null,
          "old_line_content": "\t\t\tif (replica.empty() && entry.type == LogEntry::ATTACH_PART)",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 3116,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Waiting for all replicas to process \" << entry.znode_name);",
          "new_line_content": "\t\tzookeeper_path + \"/temp\", *zookeeper);",
          "content_same": false
        },
        {
          "line": 3118,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tStrings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3120,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\twaitForReplicaToProcessLogEntry(replica, entry);",
          "new_line_content": "void StorageReplicatedMergeTree::waitForAllReplicasToProcessLogEntry(const LogEntry & entry)",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": "end",
          "new_api": null,
          "old_text": "begin(), (*it)->parts_to_merge.end(), entry.new_part_name)\n\t\t\t\t\t\t\t!= (*it)->parts_to_merge.end())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparts_for_merge = StringSet((*it)->parts_to_mer",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tthrow Exception(\"Logical error: no source replica specified for ATTACH_PART log entry;\"",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 3128,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "empty",
          "new_api": null,
          "old_text": "\t\tif (!parts_for_merge.empty())\n\t\t\t\t{\n\t\t\t\t\t/// Переместим в ",
          "new_text": null,
          "old_line_content": "\t\t\t\twaitForReplicaToProcessLogEntry(entry.source_replica, entry);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "йствия, получающие parts_for_merge.\n\t\t\t\t\tfor (Lo",
          "new_api": null,
          "old_text": "йствия, получающие parts_for_merge.\n\t\t\t\t\tfor (Lo",
          "new_text": null,
          "old_line_content": "\t\t\t\treplica = findReplicaHavingPart(entry.new_part_name, true);",
          "new_line_content": "\t\t\t\t/// Кусок должен быть на реплике-инициаторе.",
          "content_same": false
        },
        {
          "line": 3130,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tString entry_str = entry.toString();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": "tor it = queue.",
          "new_api": null,
          "old_text": "tor it = queue.",
          "new_text": null,
          "old_line_content": "\t\t\tif (replica.empty())",
          "new_line_content": "\t\t\t\t\t\t\" or trying to fetch part on source replica\", ErrorCodes::LOGICAL_ERROR);",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": "empty",
          "new_api": null,
          "old_text": "росать исключение, чтобы queueTask лишний раз не спала.\n\t\t\t\t\t  */\n\t\t\t\t\tif (replica.empty())\n\t\t\t\t\t{\n\t\t",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tthrow Exception(\"Logical error: log entry with quorum but type is not GET_PART\", ErrorCodes::LOGICAL_ERROR);",
          "new_line_content": "\t\t\t\t  *  то (из-за того, что кусок невозможно прямо сейчас скачать),",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": "(log, \"No active repli",
          "new_api": null,
          "old_text": "(log, \"No active repli",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tif (entry.block_id.empty())",
          "new_line_content": "\t\t\t\t  * TODO Сложный код, вынести отдельно.",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": "<< entry.new_part_name << \". Will fetch merged part instead.\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}",
          "new_api": null,
          "old_text": "<< entry.new_part_name << \". Will fetch merged part instead.\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tthrow Exception(\"Logical error: log entry with quorum have empty block_id\", ErrorCodes::LOGICAL_ERROR);",
          "new_line_content": "\t\t\t\t  */",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": "* Если ни у какой активной реплики нет куска, и в очереди нет слияний с его участием,\n\t\t\t\t  * проверим, есть ли у любой (активной или неактивной) реплики такой ку",
          "new_api": null,
          "old_text": "* Если ни у какой активной реплики нет куска, и в очереди нет слияний с его участием,\n\t\t\t\t  * проверим, есть ли у любой (активной или неактивной) реплики такой ку",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tLOG_DEBUG(log, \"No active replica has part \" << entry.new_part_name << \" which needs to be written with quorum.\"",
          "new_line_content": "\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 3149,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tif (0 == entry.znode_name.compare(0, strlen(\"log-\"), \"log-\"))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3154,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tUInt64 log_index = parse<UInt64>(entry.znode_name.substr(entry.znode_name.size() - 10));",
          "new_line_content": "\t  */",
          "content_same": false
        },
        {
          "line": 3157,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tLOG_DEBUG(log, \"Waiting for \" << replica << \" to pull \" << log_node_name << \" to queue\");",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 3165,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tif (!log_pointer.empty() && parse<UInt64>(log_pointer) > log_index)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": "erase",
          "new_api": null,
          "old_text": ":error2string(code));\n\t\t\t\tqueue.erase(it++);\n\t\t\t\t++r",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tStrings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");",
          "new_line_content": "\t\t\t\t\t  */",
          "content_same": false
        },
        {
          "line": 3168,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tevent->wait();",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1123,
          "old_api": "og, \"Removed \"",
          "new_api": null,
          "old_text": "og, \"Removed \" ",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tfor (size_t i = 0, size = replicas.size(); i < size; ++i)",
          "new_line_content": "\t\t\t\t\t  * Это позволит проследить, что реплики не стали активными.",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": "g.\");\n\n\t\t/// Дождемся завер",
          "new_api": null,
          "old_text": "g.\");\n\n\t\t/// Дождемся завер",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tzookeeper->get(path, &stat);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": "ераций с кусками, содержащимися в удаляемом диапазоне.",
          "new_api": null,
          "old_text": "ераций с кусками, содержащимися в удаляемом диапазоне.\n\t",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tops.push_back(new zkutil::Op::Check(path, stat.version));",
          "new_line_content": "\t\t\t\t\tzkutil::Ops ops;",
          "content_same": false
        },
        {
          "line": 3177,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tString log_pointer = zookeeper->get(zookeeper_path + \"/replicas/\" + replica + \"/log_pointer\");",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 3179,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tStrings log_entries = zookeeper->getChildren(zookeeper_path + \"/log\");",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": "taching\" : \"Removing\") << \" parts.\");\n\tsize_t re",
          "new_api": null,
          "old_text": "taching\" : \"Removing\") << \" parts.\");\n\tsize_t re",
          "new_text": null,
          "old_line_content": "\t\t\t\t\treplica = findReplicaHavingPart(entry.new_part_name, true);",
          "new_line_content": "\t\t\t\t\t\tStat stat;",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": "<< part->name);",
          "new_api": null,
          "old_text": "<< part->name);",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tif (replica.empty())",
          "new_line_content": "\t\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 3185,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tlog_index = parse<UInt64>(log_entry_name.substr(log_entry_name.size() - 10));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3187,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tif (!log_pointer.empty() && log_index < parse<UInt64>(log_pointer))",
          "new_line_content": "\t\tUInt64 log_index = 0;",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": "renameAndDetachPart",
          "new_api": null,
          "old_text": "ntry.detach)\n\t\t\tdata.renameAndDetachPart(",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tString quorum_str = zookeeper->get(quorum_path, &quorum_stat);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": "multi",
          "new_api": null,
          "old_text": "name, ops);\n\t\tzookeeper->multi(ops)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tquorum_entry.fromString(quorum_str);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3191,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tbool exists = zookeeper->tryGet(zookeeper_path + \"/log/\" + log_entry_name, log_entry_str);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": "replaceParts",
          "new_api": null,
          "old_text": "ний в ZooKeeper.\n\t\tif (!entry.detach)\n\t\t\tdata.replaceParts({part}, {}, ",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tops.push_back(new zkutil::Op::Remove(quorum_path, quorum_stat.version));",
          "new_line_content": "\t\t\t\t\t\tString quorum_path = zookeeper_path + \"/quorum/status\";",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": "ch ? \"Detached \" : \"Removed \") <",
          "new_api": null,
          "old_text": "ch ? \"Detached \" : \"Removed \") <",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tconst auto partition_str = entry.new_part_name.substr(0, 6);",
          "new_line_content": "\t\t\t\t\t\tReplicatedMergeTreeQuorumEntry quorum_entry;",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": "rt_name << \".\");\n}\n\n\nbool StorageReplicatedMergeTree::executeAtt",
          "new_api": null,
          "old_text": "rt_name << \".\");\n}\n\n\nbool StorageReplicatedMergeTree::executeAtt",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tActiveDataPartSet::parsePartName(entry.new_part_name, part_info);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3202,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tLOG_DEBUG(log, \"Waiting for \" << replica << \" to pull \" << log_node_name << \" to queue\");",
          "new_line_content": "\t\t\t\tlog_node_name = log_entry_name;",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": "O",
          "new_api": null,
          "old_text": "O(log, \"Attaching part \" <",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tauto acl = zookeeper->getDefaultACL();",
          "new_line_content": "\t\t\t\t\t\t\tActiveDataPartSet::Part part_info;",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": "getFullPath",
          "new_api": null,
          "old_text": "urce_part_name << \" from \" << source_path << \" as \" << entry.new_part_name);\n\n\tif (!Poco::File(data.getFullPath() + source_path).exists())\n\t{\n\t\tLOG_INFO(log, \"No part at \" << source_path << \". Will fetch it instead\"",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tops.push_back(new zkutil::Op::Create(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "exists",
          "new_api": null,
          "old_text": "ath).exists())\n\t{\n\t\tLOG_",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\tzookeeper_path + \"/nonincrement_block_numbers/\" + partition_str + \"/block-\" + padIndex(part_info.left),",
          "new_line_content": "\t\t\t\t\t\t\tif (part_info.left != part_info.right)",
          "content_same": false
        },
        {
          "line": 3210,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (!log_pointer.empty() && parse<UInt64>(log_pointer) > log_index)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "loadPartAndFixMetadata",
          "new_api": null,
          "old_text": "n false;\n\t}\n\n\tLOG_DEBUG(log, \"Checking data\");\n\tMergeTreeData::MutableDataPartPtr part = data.loadPartAndFixMetadata(source_path);\n\n\tzkutil::Ops ops;\n\tcheckPartAndAddToZooKeep",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tops.push_back(new zkutil::Op::Create(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3213,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\t\tevent->wait();",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 3218,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tthrow Exception(\"Logical error: unexpected name of log node: \" + entry.znode_name, ErrorCodes::LOGICAL_ERROR);",
          "new_line_content": "\t\t\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": "getPartIfExists",
          "new_api": null,
          "old_text": "rt = unreplicated_data->getPartIfExists(entry.source_part_name);\n\t\tif (unreplicated_part)\n\t\t\tunrepl",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\tops.push_back(new zkutil::Op::Remove(zookeeper_path + \"/blocks/\" + entry.block_id + \"/number\", -1));",
          "new_line_content": "\t\t\t\t\t\t\t\t\"\",",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": "detachPartInPlace",
          "new_api": null,
          "old_text": "a->detachPartInPlace(unreplicated_part);\n\t\telse\n\t\t\tLOG_WARNING(log, \"Unreplicated part \" << entry.sou",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\tops.push_back(new zkutil::Op::Remove(zookeeper_path + \"/blocks/\" + entry.block_id + \"/checksum\", -1));",
          "new_line_content": "\t\t\t\t\t\t\t\tacl,",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": "multi",
          "new_api": null,
          "old_text": "ame << \" is already detached\");\n\t}\n\n\tzookeeper->multi(ops);\n\n\t/// NOTE: Не можем исполь",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\tops.push_back(new zkutil::Op::Remove(zookeeper_path + \"/blocks/\" + entry.block_id, -1));",
          "new_line_content": "\t\t\t\t\t\t\t\tzkutil::CreateMode::Persistent));",
          "content_same": false
        },
        {
          "line": 3221,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tLOG_DEBUG(log, \"Looking for node corresponding to \" << log_node_name << \" in \" << replica << \" queue\");",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 3223,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tLOG_DEBUG(log, \"Looking for corresponding node in \" << replica << \" queue\");",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": "n true;\n}\n\n\nvoid StorageReplicatedMergeTree::queueUpdatingThread()\n{\n\tsetThreadName(\"ReplMTQueueUpd\");\n\n\twhile (!shutdown_called)\n\t{\n\t\ttry",
          "new_api": null,
          "old_text": "n true;\n}\n\n\nvoid StorageReplicatedMergeTree::queueUpdatingThread()\n{\n\tsetThreadName(\"ReplMTQueueUpd\");\n\n\twhile (!shutdown_called)\n\t{\n\t\ttry\n",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\tLOG_DEBUG(log, \"State was changed or isn't expected when trying to mark quorum for part \"",
          "new_line_content": "\t\t\t\t\t\t\tif (code == ZOK)",
          "content_same": false
        },
        {
          "line": 3236,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tbool exists = zookeeper->tryGet(zookeeper_path + \"/replicas/\" + replica + \"/queue/\" + entry_name, queue_entry_str);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "_event);\n\t\t\tqueue_updating_ev",
          "new_api": null,
          "old_text": "_event);\n\t\t\tqueue_updating_ev",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\tthrow zkutil::KeeperException(code);",
          "new_line_content": "\t\t\t\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": "wakeup",
          "new_api": null,
          "old_text": "il::KeeperException & e)\n\t\t{\n\t\t\tif (e.code == ZINVALIDSTATE)\n\t\t\t\trestarting_thread->wakeup();\n\n\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);\n\n\t\t\tqueue_updating_event->tryWait(ERROR_SLEEP_MS);\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);\n\n\t\t\tqueue_updating_event->tryWait(ERROR_SLEEP_MS);\n\t\t}\n\t}\n\n\tLOG_DEBUG(log, \"Queue updati",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tLOG_WARNING(log, \"No active replica has part \" << entry.new_part_name",
          "new_line_content": "\t\t\t\t\t\t\t\t\t<< entry.new_part_name << \" as failed.\");",
          "content_same": false
        },
        {
          "line": 3245,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tif (queue_entry_to_wait_for.empty())",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 3247,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tLOG_DEBUG(log, \"No corresponding node found. Assuming it has been already processed.\");",
          "new_line_content": "\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": "torageReplicate",
          "new_api": null,
          "old_text": "torageReplicate",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (replica.empty())",
          "new_line_content": "\t\t\t\t\t\t\t\t<< \", but that part needs quorum and /quorum/status contains entry about another part \" << quorum_entry.part_name",
          "content_same": false
        },
        {
          "line": 3251,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Waiting for \" << queue_entry_to_wait_for << \" to disappear from \" << replica << \" queue\");",
          "new_line_content": "\t/// Пока искали запись, ее уже выполнили и удалили.",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": "ueueTask",
          "new_api": null,
          "old_text": "ueueTask(BackgroundProcessingPool::Context & pool_context)\n{\n\tLogEnt",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tProfileEvents::increment(ProfileEvents::ReplicatedPartFailedFetches);",
          "new_line_content": "\t\t\t\t\t\t\t\t<< \" Or it is a bug.\");",
          "content_same": false
        },
        {
          "line": 1206,
          "old_api": "empty",
          "new_api": null,
          "old_text": "\n\ttry\n\t{\n\t\tstd::lock_guard<std::mutex> lock(queue_mutex);\n\t\tbool empty = queue.empty();\n\t\tif (!",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tthrow Exception(\"No active replica has part \" + entry.new_part_name, ErrorCodes::NO_REPLICA_HAS_PART);",
          "new_line_content": "\t\t\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 3260,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "\t/// Третье - дождемся, пока запись исчезнет из очереди реплики.",
          "content_same": false
        },
        {
          "line": 3264,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tres.is_session_expired = !zookeeper || zookeeper->expired();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3268,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tres.future_parts = future_parts.size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3269,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tres.queue_size = queue.size();",
          "new_line_content": "\tres.is_leader = is_leader_node;",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": "success = t",
          "new_api": null,
          "old_text": "success = t",
          "new_text": null,
          "old_line_content": "\t\t\t\tfor (LogEntries::iterator it = queue.begin(); it != queue.end(); ++it)",
          "new_line_content": "\t\t\ttry",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": "}\n\tcatch (const Exception",
          "new_api": null,
          "old_text": "}\n\tcatch (const Exception ",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tif (std::find((*it)->parts_to_merge.begin(), (*it)->parts_to_merge.end(), entry.new_part_name)",
          "new_line_content": "\t\t\t\t/// Найдем действие по объединению этого куска с другими. Запомним других.",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": "es::NO_REPLICA_HAS_PART)",
          "new_api": null,
          "old_text": "es::NO_REPLICA_HAS_PART)\n\t",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t!= (*it)->parts_to_merge.end())",
          "new_line_content": "\t\t\t\tStringSet parts_for_merge;",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "xception",
          "new_api": null,
          "old_text": "xception(__",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tfor (LogEntries::iterator it = queue.begin(); it != queue.end();)",
          "new_line_content": "\t\t\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": "notify_all",
          "new_api": null,
          "old_text": "entry->execution_complete.notify_all();\n\n\tif",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t&& parts_for_merge.count((*it0)->new_part_name))",
          "new_line_content": "\t\t\t\t\t\tauto it0 = it;",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": "ание из оче",
          "new_api": null,
          "old_text": "ание из оче",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tqueue.splice(queue.end(), queue, it0, it);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3309,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tres.parts_to_check = parts_to_check_set.size();",
          "new_line_content": "\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": "ного времени тратиться на определение, можно ли мерджить два рядом стоящих куска.\n\t  * Два рядом стоящих к",
          "new_api": null,
          "old_text": "ного времени тратиться на определение, можно ли мерджить два рядом стоящих куска.\n\t  * Два рядом стоящих к",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tLOG_INFO(log, \"No active replica has part \" << entry.new_part_name << \". Will fetch merged part instead.\");",
          "new_line_content": "\t\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 1273,
          "old_api": "рджить.\n\t  *",
          "new_api": null,
          "old_text": "рджить.\n\t  *\n\t ",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (replica.empty())",
          "new_line_content": "\t\t\t\t\t\treturn false;",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": "ользуемся утверждением, что если пару ку",
          "new_api": null,
          "old_text": "ользуемся утверждением, что если пару ку",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tenqueuePartForCheck(entry.new_part_name);",
          "new_line_content": "\t\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": "мердж ещё не запланирован,\n\t  *  то и сейча",
          "new_api": null,
          "old_text": "мердж ещё не запланирован,\n\t  *  то и сейча",
          "new_text": null,
          "old_line_content": "\t\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "\t\t\t\t  * проверим, есть ли у любой (активной или неактивной) реплики такой кусок или покрывающий его.",
          "content_same": false
        },
        {
          "line": 3326,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tauto log_entries = zookeeper->getChildren(zookeeper_path + \"/log\");",
          "new_line_content": "\t\tres.log_max_index = 0;",
          "content_same": false
        },
        {
          "line": 3328,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tif (log_entries.empty())",
          "new_line_content": "\t\tres.total_replicas = 0;",
          "content_same": false
        },
        {
          "line": 3334,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tconst String & last_log_entry = *std::max_element(log_entries.begin(), log_entries.end());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3338,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tString log_pointer_str = zookeeper->get(replica_path + \"/log_pointer\");",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 1291,
          "old_api": "ARTITION и зат",
          "new_api": null,
          "old_text": "ARTITION и зат",
          "new_text": null,
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3339,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tres.log_pointer = log_pointer_str.empty() ? 0 : parse<UInt64>(log_pointer_str);",
          "new_line_content": "\t\telse",
          "content_same": false
        },
        {
          "line": 1293,
          "old_api": "TTACH PARTITION.\n\t  */\n\tstd::set<std::pair<std::string, std::string>> memoized_parts_that_could_be_merged;",
          "new_api": null,
          "old_text": "TTACH PARTITION.\n\t  */\n\tstd::set<std::pair<std::string, std::string>> memoized_parts_that_could_be_merged;",
          "new_text": null,
          "old_line_content": "\tLOG_INFO(log, (entry.detach ? \"Detaching\" : \"Removing\") << \" parts inside \" << entry.new_part_name << \".\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1301,
          "old_api": "ft->name ||",
          "new_api": null,
          "old_text": "ft->name ||",
          "new_text": null,
          "old_line_content": "\t\tfor (LogEntries::iterator it = queue.begin(); it != queue.end();)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1304,
          "old_api": "td::make_pair(left->name, right->name);\n\t\tif (memoized_parts_that_coul",
          "new_api": null,
          "old_text": "td::make_pair(left->name, right->name);\n\t\tif (memoized_parts_that_coul",
          "new_text": null,
          "old_line_content": "\t\t\t\tActiveDataPartSet::contains(entry.new_part_name, (*it)->new_part_name))",
          "new_line_content": "\t\tsize_t removed_entries = 0;",
          "content_same": false
        },
        {
          "line": 3354,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tres.clear();",
          "new_line_content": "\t\t\t\t++res.active_replicas;",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": "g month_name = left->n",
          "new_api": null,
          "old_text": "g month_name = left->n",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tto_wait.push_back(*it);",
          "new_line_content": "\t\tstd::unique_lock<std::mutex> lock(queue_mutex);",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": "для которого неудовлетворён кворум.\n\t\t/// Замечание: теоретически, это можно было бы разрешить. Но это сделает логику более сложной.",
          "new_api": null,
          "old_text": " для которого неудовлетворён кворум.\n\t\t/// Замечание: теоретически, это можно было бы разрешить. Но это сделает логику более сложной.\n\t\t",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tLOG_INFO(log, \"Couldn't remove \" << replica_path + \"/queue/\" + (*it)->znode_name << \": \"",
          "new_line_content": "\t\t\tif (((*it)->type == LogEntry::GET_PART || (*it)->type == LogEntry::MERGE_PARTS) &&",
          "content_same": false
        },
        {
          "line": 3358,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tres.reserve(queue.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": "quorum_node_valu",
          "new_api": null,
          "old_text": " quorum_node_valu",
          "new_text": null,
          "old_line_content": "\t\t\t\tqueue.erase(it++);",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 3360,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tres.emplace_back(*entry);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": "fromString",
          "new_api": null,
          "old_text": "y.fromString(q",
          "new_text": null,
          "old_line_content": "\t\t\t\"Waiting for \" << to_wait.size() << \" entries that are currently executing.\");",
          "new_line_content": "\t\t\t\t++removed_entries;",
          "content_same": false
        },
        {
          "line": 3369,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\trestarting_thread->getReplicaDelays(out_absolute_delay, out_relative_delay);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": "rs more than one block numbers\", ErrorCodes::LOGICAL_ERROR);\n\n\t\t\tif (left->right <= pa",
          "new_api": null,
          "old_text": "rs more than one block numbers\", ErrorCodes::LOGICAL_ERROR);\n\n\t\t\tif (left->right <= pa",
          "new_text": null,
          "old_line_content": "\t\t\tentry->execution_complete.wait(lock, [&entry] { return !entry->currently_executing; });",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 3375,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3377,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tString partition_str = MergeTreeData::getMonthName(partition);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3380,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tif (from.back() == '/')",
          "new_line_content": "void StorageReplicatedMergeTree::fetchPartition(const Field & partition, const String & from_, const Settings & settings)",
          "content_same": false
        },
        {
          "line": 3381,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tfrom.resize(from.size() - 1);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3383,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tLOG_INFO(log, \"Will fetch partition \" << partition_str << \" from shard \" << from_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1336,
          "old_api": "{\n\t\t\tString path1 = zookeeper_path +",
          "new_api": null,
          "old_text": "{\n\t\t\tString path1 = zookeeper_path +          ",
          "new_text": null,
          "old_line_content": "\t\tLOG_DEBUG(log, \"Removing part \" << part->name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3389,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tfor (Poco::DirectoryIterator dir_it{data.getFullPath() + \"detached/\"}; dir_it != dir_end; ++dir_it)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3391,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tthrow Exception(\"Detached partition \" + partition_str + \" is already exists.\", ErrorCodes::PARTITION_ALREADY_EXISTS);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": "kInZooKeeper::ABANDONED &&\n\t\t\t\tAbandonab",
          "new_api": null,
          "old_text": "kInZooKeeper::ABANDONED &&\n\t\t\t\tAbandonab",
          "new_text": null,
          "old_line_content": "\t\tremovePartFromZooKeeper(part->name, ops);",
          "new_line_content": "\t\t++removed_parts;",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": "ckInZooKeeper::check(",
          "new_api": null,
          "old_text": "ckInZooKeeper::check(",
          "new_text": null,
          "old_line_content": "\t\tzookeeper->multi(ops);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3394,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tzkutil::Strings replicas = zookeeper->getChildren(from + \"/replicas\");",
          "new_line_content": "\t  */",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": "ed && is_leader_node)\n\t{\n\t\tbool suc",
          "new_api": null,
          "old_text": "ed && is_leader_node)\n\t{\n\t\tbool suc",
          "new_text": null,
          "old_line_content": "\t\t\tdata.replaceParts({part}, {}, true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3402,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tactive_replicas.push_back(replica);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3404,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tif (active_replicas.empty())",
          "new_line_content": "\tzkutil::Strings active_replicas;",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": "rts).\n\t\t\t\tpull",
          "new_api": null,
          "old_text": "rts).\n\t\t\t\tpull",
          "new_text": null,
          "old_line_content": "\tauto zookeeper = getZooKeeper();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1362,
          "old_api": "* Если их больше половины от размера пула потоков для мерджа, то можно мерджить только мелкие куски.\n\t\t\t  */",
          "new_api": null,
          "old_text": "\n\t\t\t  * Если их больше половины от размера пула потоков для мерджа, то можно мерджить только мелкие куски.\n\t\t\t  */\n\t\t\t",
          "new_text": null,
          "old_line_content": "\tLOG_INFO(log, \"Attaching part \" << entry.source_part_name << \" from \" << source_path << \" as \" << entry.new_part_name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": "ol = context.getBa",
          "new_api": null,
          "old_text": "ol = context.getBa",
          "new_text": null,
          "old_line_content": "\tif (!Poco::File(data.getFullPath() + source_path).exists())",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": "getCounter",
          "new_api": null,
          "old_text": "merges_current = background_pool.getCounter(\"replicated big merges\");\n\t\t",
          "new_text": null,
          "old_line_content": "\t\tLOG_INFO(log, \"No part at \" << source_path << \". Will fetch it instead\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3414,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tUInt64 min_queue_size = std::numeric_limits<UInt64>::max();",
          "new_line_content": "\t/** Надо выбрать лучшую (наиболее актуальную) реплику.",
          "content_same": false
        },
        {
          "line": 1370,
          "old_api": "ig_merges = background_pool.get",
          "new_api": null,
          "old_text": "ig_merges = background_pool.get",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Checking data\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1374,
          "old_api": "rrent < max_number_of_big_merges)\n\t\t\t{\n\t\t\t\tstd::lock_guard",
          "new_api": null,
          "old_text": "rrent < max_number_of_big_merges)\n\t\t\t{\n\t\t\t\tstd::lock_guard",
          "new_text": null,
          "old_line_content": "\tcheckPartAndAddToZooKeeper(part, ops, entry.new_part_name);",
          "new_line_content": "\t\treturn false;",
          "content_same": false
        },
        {
          "line": 3422,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tInt64 log_pointer = log_pointer_str.empty() ? 0 : parse<UInt64>(log_pointer_str);",
          "new_line_content": "\tString best_replica;",
          "content_same": false
        },
        {
          "line": 3425,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tzookeeper->get(current_replica_path + \"/queue\", &stat);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": "queued < max_number_of_big_merges)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (",
          "new_api": null,
          "old_text": "queued < max_number_of_big_merges)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (",
          "new_text": null,
          "old_line_content": "\t\t\tunreplicated_data->detachPartInPlace(unreplicated_part);",
          "new_line_content": "\tzkutil::Ops ops;",
          "content_same": false
        },
        {
          "line": 1382,
          "old_api": "& name : entry->parts_to_merge)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMergeTreeData::DataPartPtr part = data.g",
          "new_api": null,
          "old_text": " & name : entry->parts_to_merge)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMergeTreeData::DataPartPtr part = data.g",
          "new_text": null,
          "old_line_content": "\t\t\tLOG_WARNING(log, \"Unreplicated part \" << entry.source_part_name << \" is already detached\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1388,
          "old_api": "}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool onl",
          "new_api": null,
          "old_text": "\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool onl",
          "new_text": null,
          "old_line_content": "\tpart->renameTo(entry.new_part_name);",
          "new_line_content": "\t\telse",
          "content_same": false
        },
        {
          "line": 3437,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tif (best_replica.empty())",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": "ges_queued >= max_number_of_big_merges;\n\n\t\t\tif (big",
          "new_api": null,
          "old_text": "ges_queued >= max_number_of_big_merges;\n\n\t\t\tif (big",
          "new_text": null,
          "old_line_content": "\tActiveDataPartSet::parsePartName(part->name, *part);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 3438,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tthrow Exception(\"Logical error: cannot choose best replica.\", ErrorCodes::LOGICAL_ERROR);",
          "new_line_content": "\t\t\tmax_log_pointer = log_pointer;",
          "content_same": false
        },
        {
          "line": 3440,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tLOG_INFO(log, \"Found \" << replicas.size() << \" replicas, \" << active_replicas.size() << \" of them are active.\"",
          "new_line_content": "\t\t\tbest_replica = replica;",
          "content_same": false
        },
        {
          "line": 1394,
          "old_api": "ued)\n\t\t\t\tLOG_TRACE(log, \"Currently executing big merges: \" << bi",
          "new_api": null,
          "old_text": "ued)\n\t\t\t\tLOG_TRACE(log, \"Currently executing big merges: \" << bi",
          "new_text": null,
          "old_line_content": "\tLOG_INFO(log, \"Finished attaching part \" << entry.new_part_name);",
          "new_line_content": "\t/// NOTE: Не можем использовать renameTempPartAndAdd, потому что кусок не временный - если что-то пойдет не так, его не нужно удалять.",
          "content_same": false
        },
        {
          "line": 1405,
          "old_api": "small parts to merge.\" : \".\"))",
          "new_api": null,
          "old_text": " small parts to merge.\" : \".\"))",
          "new_text": null,
          "old_line_content": "\tsetThreadName(\"ReplMTQueueUpd\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3457,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tLOG_INFO(log, \"Some of parts (\" << missing_parts.size() << \") are missing. Will try to fetch covering parts.\");",
          "new_line_content": "\t  */",
          "content_same": false
        },
        {
          "line": 1411,
          "old_api": "er",
          "new_api": null,
          "old_text": "er();\n\n\t\t\t\tif (merges_queued >= data.",
          "new_text": null,
          "old_line_content": "\t\t\tpullLogsToQueue(queue_updating_event);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3460,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tthrow Exception(\"Too much retries to fetch parts from \" + best_replica_path, ErrorCodes::TOO_MUCH_RETRIES_TO_FETCH_PARTS);",
          "new_line_content": "\tStrings missing_parts;",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tStrings parts = zookeeper->getChildren(best_replica_path + \"/parts\");",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 1417,
          "old_api": "is greater than max_replic",
          "new_api": null,
          "old_text": " is greater than max_replic",
          "new_text": null,
          "old_line_content": "\t\t\t\trestarting_thread->wakeup();",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 3466,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tif (missing_parts.empty())",
          "new_line_content": "\t\tif (try_no >= 5)",
          "content_same": false
        },
        {
          "line": 3468,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tparts_to_fetch = active_parts_set.getParts();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1421,
          "old_api": "icated_merges_in_queue << \"), so won't select",
          "new_api": null,
          "old_text": "icated_merges_in_queue << \"), so won't select",
          "new_text": null,
          "old_line_content": "\t\t\tqueue_updating_event->tryWait(ERROR_SLEEP_MS);",
          "new_line_content": "\t\tcatch (const zkutil::KeeperException & e)",
          "content_same": false
        },
        {
          "line": 1425,
          "old_api": "break;\n\t\t\t\t}\n\n\t\t\t\tMergeTreeData::DataPart",
          "new_api": null,
          "old_text": "\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tMergeTreeData::DataPart",
          "new_text": null,
          "old_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3474,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tparts_to_fetch_partition.push_back(part);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": "r parts;\n\n\t\t\t\tString merged_name;\n\n\t\t\t\tsize_t",
          "new_api": null,
          "old_text": "r parts;\n\n\t\t\t\tString merged_name;\n\n\t\t\t\tsize_t",
          "new_text": null,
          "old_line_content": "\t\t\tqueue_updating_event->tryWait(ERROR_SLEEP_MS);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3476,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tparts_to_fetch = std::move(parts_to_fetch_partition);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3478,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tif (parts_to_fetch.empty())",
          "new_line_content": "\t\t\tStrings parts_to_fetch_partition;",
          "content_same": false
        },
        {
          "line": 1431,
          "old_api": "= DiskSpaceMonitor::getUnreservedFreeSpace(full",
          "new_api": null,
          "old_text": " = DiskSpaceMonitor::getUnreservedFreeSpace(full",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Queue updating thread finished\");",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 3479,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\t\tthrow Exception(\"Partition \" + partition_str + \" on \" + best_replica_path + \" doesn't exist\", ErrorCodes::PARTITION_DOESNT_EXIST);",
          "new_line_content": "\t\t\tfor (const String & part : parts_to_fetch)",
          "content_same": false
        },
        {
          "line": 3487,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tparts_to_fetch.push_back(containing_part);",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 3489,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tLOG_WARNING(log, \"Part \" << missing_part << \" on replica \" << best_replica_path << \" has been vanished.\");",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": ", only_small,",
          "new_api": null,
          "old_text": ", only_small,",
          "new_text": null,
          "old_line_content": "\t\tbool empty = queue.empty();",
          "new_line_content": "bool StorageReplicatedMergeTree::queueTask(BackgroundProcessingPool::Context & pool_context)",
          "content_same": false
        },
        {
          "line": 1445,
          "old_api": "onst auto &",
          "new_api": null,
          "old_text": "onst auto &",
          "new_text": null,
          "old_line_content": "\t\t\tfor (LogEntries::iterator it = queue.begin(); it != queue.end(); ++it)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3495,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tmissing_parts.clear();",
          "new_line_content": "\t\t\t\telse",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": "exists",
          "new_api": null,
          "old_text": "ZK, не будем сливать.\n\t\t\t\t\tif (!zookeeper->exists(r",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (shouldExecuteLogEntry(**it, (*it)->postpone_reason))",
          "new_line_content": "\t\tif (!empty)",
          "content_same": false
        },
        {
          "line": 1453,
          "old_api": ">name))\n\t\t\t\t\t{\n\t\t\t\t\t\tall_in_z",
          "new_api": null,
          "old_text": ">name))\n\t\t\t\t\t{\n\t\t\t\t\t\tall_in_z",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tentry->tagPartAsFuture(*this);",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 1454,
          "old_api": "(part->mod",
          "new_api": null,
          "old_text": " (part->mod",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tqueue.splice(queue.end(), queue, it);",
          "new_line_content": "\t\t\t\tif ((*it)->currently_executing)",
          "content_same": false
        },
        {
          "line": 3504,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (e.code() != ErrorCodes::RECEIVED_ERROR_FROM_REMOTE_IO_SERVER)",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 3508,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\t\tmissing_parts.push_back(part);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 1463,
          "old_api": "odifica",
          "new_api": null,
          "old_text": "odifica",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t(*it)->last_postpone_time = time(0);",
          "new_line_content": "\t\t\t\t\t++entry->num_tries;",
          "content_same": false
        },
        {
          "line": 3513,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t} while (!missing_parts.empty());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3521,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t? toString(partition.get<UInt64>())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3522,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t: partition.safeGet<String>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3524,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tdata.freezePartition(prefix);",
          "new_line_content": "void StorageReplicatedMergeTree::freezePartition(const Field & partition, const Settings & settings)",
          "content_same": false
        },
        {
          "line": 3526,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tunreplicated_data->freezePartition(prefix);",
          "new_line_content": "\t/// Префикс может быть произвольным. Не обязательно месяц - можно указать лишь год.",
          "content_same": false
        },
        {
          "line": 1484,
          "old_api": "LogEntry entry;\n\t\t\t\tentry.type = Lo",
          "new_api": null,
          "old_text": "\t\tLogEntry entry;\n\t\t\t\tentry.type = Lo",
          "new_text": null,
          "old_line_content": "\t\t\tif (executeLogEntry(*entry, pool_context))",
          "new_line_content": "\tbool success = false;",
          "content_same": false
        },
        {
          "line": 1486,
          "old_api": "ry.source_repl",
          "new_api": null,
          "old_text": "ry.source_repl",
          "new_text": null,
          "old_line_content": "\t\t\t\tauto zookeeper = getZooKeeper();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": ";\n\t\t\t\tentry.new_part_name = merged_name;\n\t\t\t\tentry.create_time = t",
          "new_api": null,
          "old_text": ";\n\t\t\t\tentry.new_part_name = merged_name;\n\t\t\t\tentry.create_time = t",
          "new_text": null,
          "old_line_content": "\t\t\t\tauto code = zookeeper->tryRemove(replica_path + \"/queue/\" + entry->znode_name);",
          "new_line_content": "\ttry",
          "content_same": false
        },
        {
          "line": 1490,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "& part : parts)\n\t\t\t\t\tentry.parts_to_merge.push_back(part->name);\n\n\t\t\t\tneed_pull = true;\n\n\t\t\t\tzookeeper->create(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::Creat",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tLOG_ERROR(log, \"Couldn't remove \" << replica_path + \"/queue/\" + entry->znode_name << \": \"",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": "ки о нес",
          "new_api": null,
          "old_text": "ки о нес",
          "new_text": null,
          "old_line_content": "\t\tif (e.code() == ErrorCodes::NO_REPLICA_HAS_PART)",
          "new_line_content": "\t\t\tthrow;",
          "content_same": false
        },
        {
          "line": 1509,
          "old_api": "umber));",
          "new_api": null,
          "old_text": "umber));\n\t\t\t\t\t\t",
          "new_text": null,
          "old_line_content": "\t\t\tLOG_INFO(log, e.displayText());",
          "new_line_content": "\t\twas_exception = false;",
          "content_same": false
        },
        {
          "line": 1511,
          "old_api": "ve",
          "new_api": null,
          "old_text": "ve(zooke",
          "new_text": null,
          "old_line_content": "\t\telse if (e.code() == ErrorCodes::ABORTED)",
          "new_line_content": "\tcatch (const Exception & e)",
          "content_same": false
        },
        {
          "line": 1514,
          "old_api": "}\n\t\t\t\t}\n\n\t\t\t\tsuccess = true;",
          "new_api": null,
          "old_text": "\t\t}\n\t\t\t\t}\n\n\t\t\t\tsuccess = true;\n\t",
          "new_text": null,
          "old_line_content": "\t\t\tLOG_INFO(log, \"Merge cancelled\");",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1517,
          "old_api": "lse);\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t\ttryLogCurren",
          "new_api": null,
          "old_text": "lse);\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t\ttryLogCurren",
          "new_text": null,
          "old_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 1530,
          "old_api": "rageReplicatedMergeTree::alterThread()",
          "new_api": null,
          "old_text": "rageReplicatedMergeTree::alterThread()",
          "new_text": null,
          "old_line_content": "\tentry->execution_complete.notify_all();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1536,
          "old_api": "писания отлич",
          "new_api": null,
          "old_text": "писания отлич",
          "new_text": null,
          "old_line_content": "\t\tfor (LogEntries::iterator it = queue.end(); it != queue.begin();)",
          "new_line_content": "\tentry->exception = saved_exception;",
          "content_same": false
        },
        {
          "line": 1541,
          "old_api": "и запомненная в",
          "new_api": null,
          "old_text": "и запомненная в",
          "new_text": null,
          "old_line_content": "\t\t\t\tqueue.erase(it);",
          "new_line_content": "\t\t/// Удалим задание из очереди.",
          "content_same": false
        },
        {
          "line": 1554,
          "old_api": "елом, ничего не меняет.\n\t\t\t  *",
          "new_api": null,
          "old_text": "елом, ничего не меняет.\n\t\t\t  * ",
          "new_text": null,
          "old_line_content": "\tsetThreadName(\"ReplMTMergeSel\");",
          "new_line_content": "\t/// Если не было исключения, не нужно спать.",
          "content_same": false
        },
        {
          "line": 1576,
          "old_api": "уру таблицы локально.\n\t\t\t\tif (changed_versi",
          "new_api": null,
          "old_text": "уру таблицы локально.\n\t\t\t\tif (changed_versi",
          "new_text": null,
          "old_line_content": "\t\tif (virtual_parts.getContainingPart(left->name) != left->name ||",
          "new_line_content": "\t  */",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": "FO",
          "new_api": null,
          "old_text": "FO(log, \"Changed version of 'columns' node i",
          "new_text": null,
          "old_line_content": "\t\t\tvirtual_parts.getContainingPart(right->name) != right->name)",
          "new_line_content": "\tstd::set<std::pair<std::string, std::string>> memoized_parts_that_could_be_merged;",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": ";\n\n\t\t\t\t\tauto table_lock = lockStructure",
          "new_api": null,
          "old_text": ";\n\n\t\t\t\t\tauto table_lock = lockStructure",
          "new_text": null,
          "old_line_content": "\t\tauto key = std::make_pair(left->name, right->name);",
          "new_line_content": "\t\t(const MergeTreeData::DataPartPtr & left, const MergeTreeData::DataPartPtr & right) -> bool",
          "content_same": false
        },
        {
          "line": 1581,
          "old_api": "();\n\n\t\t\t\t\tconst auto columns_changed = columns",
          "new_api": null,
          "old_text": "();\n\n\t\t\t\t\tconst auto columns_changed = columns",
          "new_text": null,
          "old_line_content": "\t\tif (memoized_parts_that_could_be_merged.count(key))",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 1585,
          "old_api": "d = materializ",
          "new_api": null,
          "old_text": "d = materializ",
          "new_text": null,
          "old_line_content": "\t\tauto zookeeper = getZooKeeper();",
          "new_line_content": "\t\t\treturn false;",
          "content_same": false
        },
        {
          "line": 1590,
          "old_api": "r. Applying changes locally.\");\n\n\t\t\t\t\t\tInterpreterAlterQuery::updateMet",
          "new_api": null,
          "old_text": "r. Applying changes locally.\");\n\n\t\t\t\t\t\tInterpreterAlterQuery::updateMet",
          "new_text": null,
          "old_line_content": "\t\tif (zookeeper->tryGet(zookeeper_path + \"/quorum/status\", quorum_node_value))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": "ized_columns, alias_columns, column_defaul",
          "new_api": null,
          "old_text": "ized_columns, alias_columns, column_defaul",
          "new_text": null,
          "old_line_content": "\t\t\tquorum_entry.fromString(quorum_node_value);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1596,
          "old_api": "setColumnsList",
          "new_api": null,
          "old_text": "\t\t\t\t{\n\t\t\t\t\t\t\tdata.setColumnsList(columns);\n\n\t\t\t\t\t\t\tif (unreplicated",
          "new_text": null,
          "old_line_content": "\t\t\tActiveDataPartSet::parsePartName(quorum_entry.part_name, part_info);",
          "new_line_content": "\t\tString quorum_node_value;",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": "s);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (materialized_columns_changed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis->materialized_columns = materialized_colu",
          "new_api": null,
          "old_text": "s);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (materialized_columns_changed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis->materialized_columns = materialized_colu",
          "new_text": null,
          "old_line_content": "\t\t\t\tthrow Exception(\"Logical error: part written with quorum covers more than one block numbers\", ErrorCodes::LOGICAL_ERROR);",
          "new_line_content": "\t\t\tReplicatedMergeTreeQuorumEntry quorum_entry;",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": "lied changes to table.\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{",
          "new_api": null,
          "old_text": "lied changes to table.\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{",
          "new_text": null,
          "old_line_content": "\t\tfor (Int64 number = std::max(RESERVED_BLOCK_NUMBERS, left->right + 1); number <= right->left - 1; ++number)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": "получить список",
          "new_api": null,
          "old_text": "получить список ",
          "new_text": null,
          "old_line_content": "\t\t\tString path1 = zookeeper_path +              \"/block_numbers/\" + month_name + \"/block-\" + padIndex(number);",
          "new_line_content": "\t\t\t\treturn false;",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": "ataParts",
          "new_api": null,
          "old_text": "ataParts();\n\n\t\t\t",
          "new_text": null,
          "old_line_content": "\t\t\tString path2 = zookeeper_path + \"/nonincrement_block_numbers/\" + month_name + \"/block-\" + padIndex(number);",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": "version = stat.version;\n\t\t\t\t}\n\n\t\t\t\t/// Обновим куски",
          "new_api": null,
          "old_text": "version = stat.version;\n\t\t\t\t}\n\n\t\t\t\t/// Обновим куски",
          "new_text": null,
          "old_line_content": "\t\t\tif (AbandonableLockInZooKeeper::check(path1, *zookeeper) != AbandonableLockInZooKeeper::ABANDONED &&",
          "new_line_content": "\t\t/// Можно слить куски, если все номера между ними заброшены - не соответствуют никаким блокам.",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": "{\n\t\t\t\t\tauto table_lock = lockStructure(false);",
          "new_api": null,
          "old_text": "\n\t\t\t\t{\n\t\t\t\t\tauto table_lock = lockStructure(false);\n",
          "new_text": null,
          "old_line_content": "\t\t\t\tAbandonableLockInZooKeeper::check(path2, *zookeeper) != AbandonableLockInZooKeeper::ABANDONED)",
          "new_line_content": "\t\t/// Номера до RESERVED_BLOCK_NUMBERS всегда не соответствуют никаким блокам.",
          "content_same": false
        },
        {
          "line": 1633,
          "old_api": "olumns_plus_mater",
          "new_api": null,
          "old_text": "olumns_plus_mater",
          "new_text": null,
          "old_line_content": "\t\t\t\tpullLogsToQueue();",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1642,
          "old_api": "multi",
          "new_api": null,
          "old_text": "oString(), -1));\n\t\t\t\t\t\tzookeeper->multi(ops);\n\n\t\t\t\t",
          "new_text": null,
          "old_line_content": "\t\t\tsize_t big_merges_current = background_pool.getCounter(\"replicated big merges\");",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 1643,
          "old_api": "commit",
          "new_api": null,
          "old_text": "transaction->commit();\n\t\t\t\t\t}\n\n\t\t\t\t\t",
          "new_text": null,
          "old_line_content": "\t\t\tsize_t max_number_of_big_merges = background_pool.getNumberOfThreads() / 2;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": "lumns\", columns_str);\n\n\t\t\t\t\tif (ch",
          "new_api": null,
          "old_text": "lumns\", columns_str);\n\n\t\t\t\t\tif (ch",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\tMergeTreeData::DataPartPtr part = data.getActiveContainingPart(name);",
          "new_line_content": "\t\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 1679,
          "old_api": "tryWait",
          "new_api": null,
          "old_text": "UNCTION__);\n\n\t\t\tforce_recheck_parts = true;\n\n\t\t\talter_thread_event->tryWait(ERROR_SLEEP_MS);\n\t\t}\n\t}\n\n\tLOG_DEBUG(log, \"Alter thread finished\");\n}\n\n\nvoid StorageReplicatedMergeTree::removePartFromZooKeeper(const String & part_name, zkutil::Ops & ops)\n{\n\tString part_path = replica_path + \"/parts/\" + part_name;\n\n\tops.push",
          "new_text": null,
          "old_line_content": "\t\t\t\tLOG_TRACE(log, \"Currently executing big merges: \" << big_merges_current",
          "new_line_content": "\t\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 1687,
          "old_api": "ath + \"/checks",
          "new_api": null,
          "old_text": "ath + \"/checks",
          "new_text": null,
          "old_line_content": "\t\t\t\tauto zookeeper = getZooKeeper();",
          "new_line_content": "\t\t\t\t\t<< \". Queued big merges: \" << big_merges_queued",
          "content_same": false
        },
        {
          "line": 1691,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "push_back(new zkutil::Op::Remove(part_path, -1));\n}\n\n\nvoid StorageReplicatedMergeTree::removePartAndEnqueueFetch(const String & part_name)\n{\n\tauto zookeeper = getZooKeeper();\n\n\tString part_path = replica_path + \"/parts/\"",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tLOG_TRACE(log, \"Number of queued merges (\" << merges_queued",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": "ime = tryGetPartCreateTime(zookeeper, replica_path,",
          "new_api": null,
          "old_text": "ime = tryGetPartCreateTime(zookeeper, replica_path,",
          "new_text": null,
          "old_line_content": "\t\t\t\tsize_t disk_space = DiskSpaceMonitor::getUnreservedFreeSpace(full_path);",
          "new_line_content": "\t\t\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": "og_entry->source_replica = \"\";\n\tlog_entry->new_part_name = part_name;\n\n\tzkutil::Ops ops;\n\tops.",
          "new_api": null,
          "old_text": "og_entry->source_replica = \"\";\n\tlog_entry->new_part_name = part_name;\n\n\tzkutil::Ops ops;\n\tops.",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (   !merger.selectPartsToMerge(parts, merged_name, disk_space, false, false, only_small, can_merge)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": "toString",
          "new_api": null,
          "old_text": "new zkutil::Op::Create(\n\t\treplica_path + \"/queue/queue-\", log_entry->toString(), zookeeper->g",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t&& !merger.selectPartsToMerge(parts, merged_name, disk_space, true, false, only_small, can_merge))",
          "new_line_content": "\t\t\t\tMergeTreeData::DataPartsVector parts;",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": "getPathCreated",
          "new_api": null,
          "old_text": "ic_cast<zkutil::Op::Create &>(ops[0]).getPathCreated();\n",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tif (!zookeeper->exists(replica_path + \"/parts/\" + part->name))",
          "new_line_content": "\t\t\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 1717,
          "old_api": ");\n\t\tqu",
          "new_api": null,
          "old_text": ");\n\t\tqu",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tif (part->modification_time + MAX_AGE_OF_LOCAL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < time(0))",
          "new_line_content": "\t\t\t\tfor (const auto & part : parts)",
          "content_same": false
        },
        {
          "line": 1719,
          "old_api": "count",
          "new_api": null,
          "old_text": "_entry);\n\t}\n}\n\n\nvoid StorageReplicatedMergeTree::enqueuePartForCheck(const String & name)\n{\n\tstd::lock_guard<std::mutex> lock(parts_to_check_mutex);\n\n\tif (parts_to_check_set.count(name))\n\t\treturn;\n\tparts_to_check_queue.push_back(name);\n\tparts_to_check_set.inse",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tLOG_WARNING(log, \"Part \" << part->name << \" (that was selected for merge)\"",
          "new_line_content": "\t\t\t\t\t/// Если о каком-то из кусков нет информации в ZK, не будем сливать.",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": "set",
          "new_api": null,
          "old_text": "\n\tparts_to_check_event.set();\n}",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tenqueuePartForCheck(part->name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": "го отту",
          "new_api": null,
          "old_text": "го отту",
          "new_text": null,
          "old_line_content": "\t\t\t\tentry.create_time = time(0);",
          "new_line_content": "\t\t\t\tif (!all_in_zk)",
          "content_same": false
        },
        {
          "line": 1737,
          "old_api": "exists",
          "new_api": null,
          "old_text": "\tif (zookeeper->exists(part_path))\n\t{\n\t\tLO",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tentry.parts_to_merge.push_back(part->name);",
          "new_line_content": "\t\t\t\tLogEntry entry;",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": "ment",
          "new_api": null,
          "old_text": "ment(ProfileEvents::Replica",
          "new_text": null,
          "old_line_content": "\t\t\t\tString month_name = parts[0]->name.substr(0, 6);",
          "new_line_content": "\t\t\t\tfor (const auto & part : parts)",
          "content_same": false
        },
        {
          "line": 1747,
          "old_api": "Set::parsePartName(part_name, part_info);\n\n\t/** Логик",
          "new_api": null,
          "old_text": "Set::parsePartName(part_name, part_info);\n\n\t/** Логик",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tfor (Int64 number = std::max(RESERVED_BLOCK_NUMBERS, parts[i]->right + 1); number <= parts[i + 1]->left - 1; ++number)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1749,
          "old_api": "я затем при обра",
          "new_api": null,
          "old_text": "я затем при обра",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tzookeeper->tryRemove(zookeeper_path +              \"/block_numbers/\" + month_name + \"/block-\" + padIndex(number));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": "крывающего его куска, то\n\t\t*   - если у ког",
          "new_api": null,
          "old_text": "крывающего его куска, то\n\t\t*   - если у ког",
          "new_text": null,
          "old_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": "го нет всех составляющих кусков, то признаем кусо",
          "new_api": null,
          "old_text": "го нет всех составляющих кусков, то признаем кусо",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Merge selecting thread finished\");",
          "new_line_content": "\t\tif (shutdown_called || !is_leader_node)",
          "content_same": false
        },
        {
          "line": 1776,
          "old_api": "репликации.\n\t\t*/\n\n\tLOG_WARN",
          "new_api": null,
          "old_text": " репликации.\n\t\t*/\n\n\tLOG_WARN",
          "new_text": null,
          "old_line_content": "\tsetThreadName(\"ReplMTAlter\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1807,
          "old_api": "x> lock(queue_",
          "new_api": null,
          "old_text": "x> lock(queue_",
          "new_text": null,
          "old_line_content": "\t\t\tauto zookeeper = getZooKeeper();",
          "new_line_content": "\t\t\t  * Поэтому, в первый раз, независимо от изменений, проверяем структуру всех part-ов,",
          "content_same": false
        },
        {
          "line": 1810,
          "old_api": "end",
          "new_api": null,
          "old_text": "; it != queue.end();)\n\t\t{\n\t\t\tif ((*it)->new_part_name == part_name)\n\t\t",
          "new_text": null,
          "old_line_content": "\t\t\tconst String columns_str = zookeeper->get(zookeeper_path + \"/columns\", &stat, alter_thread_event);",
          "new_line_content": "\t\t\t  *",
          "content_same": false
        },
        {
          "line": 1811,
          "old_api": "ve",
          "new_api": null,
          "old_text": "ve(replica_path + \"/queue/\" + (*it)->znode_n",
          "new_text": null,
          "old_line_content": "\t\t\tauto columns_desc = ColumnsDescription<true>::parse(columns_str);",
          "new_line_content": "\t\t\t  * TODO: Слишком сложно, всё переделать.",
          "content_same": false
        },
        {
          "line": 1827,
          "old_api": "отсутствующий кусок в block_numbers, чтобы он н",
          "new_api": null,
          "old_text": "отсутствующий кусок в block_numbers, чтобы он н",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tmerge_blocker = std::make_unique<MergeTreeMergeBlocker>(merger);",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 1829,
          "old_api": "ь не можем - если так сделать,\n\t\t*  ZooKeeper зачем-то пропус",
          "new_api": null,
          "old_text": "ь не можем - если так сделать,\n\t\t*  ZooKeeper зачем-то пропус",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tunreplicated_merge_blocker = std::make_unique<MergeTreeMergeBlocker>(*unreplicated_merger);",
          "new_line_content": "\t\t\t\tstd::unique_ptr<MergeTreeMergeBlocker> merge_blocker;",
          "content_same": false
        },
        {
          "line": 1837,
          "old_api": "дут делаться сквозь эти отсутствующие куски.\n\t\t*\n\t\t* А ещё, не будем добавлять, если:\n\t\t* - потреб",
          "new_api": null,
          "old_text": "дут делаться сквозь эти отсутствующие куски.\n\t\t*\n\t\t* А ещё, не будем добавлять, если:\n\t\t* - потреб",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tLOG_INFO(log, \"Changed version of 'columns' node in ZooKeeper. Waiting for structure write lock.\");",
          "new_line_content": "\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": "много (больше 1000) уз",
          "new_api": null,
          "old_text": " много (больше 1000) уз",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tauto table_lock = lockStructureForAlter();",
          "new_line_content": "\t\t\t\tMergeTreeData::DataParts parts;",
          "content_same": false
        },
        {
          "line": 1841,
          "old_api": "был при-ATTACH-ен.\n\t\t* NOTE Возможно",
          "new_api": null,
          "old_text": "был при-ATTACH-ен.\n\t\t* NOTE Возможно",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tconst auto columns_changed = columns != data.getColumnsListNonMaterialized();",
          "new_line_content": "\t\t\t\t/// Если описание столбцов изменилось, обновим структуру таблицы локально.",
          "content_same": false
        },
        {
          "line": 1849,
          "old_api": "substr",
          "new_api": null,
          "old_text": "ion\");\n\t\treturn;\n\t}\n\n\tconst auto partition_str = part_name.substr(0, 6);\n\tfor",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tLOG_INFO(log, \"Columns list changed in ZooKeeper. Applying changes locally.\");",
          "new_line_content": "\t\t\t\t\tconst auto materialized_columns_changed = materialized_columns != data.materialized_columns;",
          "content_same": false
        },
        {
          "line": 1851,
          "old_api": "createIfNotExists",
          "new_api": null,
          "old_text": "= part_info.left; i <= part_info.right; ++i)\n\t{\n\t\tzookeeper->createIfNotExists(zookeeper_path + \"/nonincrement_block_numbers\", \"\");\n\t\tzookeeper",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tInterpreterAlterQuery::updateMetadata(database_name, table_name, columns,",
          "new_line_content": "\t\t\t\t\tconst auto column_defaults_changed = column_defaults != data.column_defaults;",
          "content_same": false
        },
        {
          "line": 1859,
          "old_api": "eper::createAbandonedIfNotExists(\n\t\t\tzooke",
          "new_api": null,
          "old_text": "eper::createAbandonedIfNotExists(\n\t\t\tzooke",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\tunreplicated_data->setColumnsList(columns);",
          "new_line_content": "\t\t\t\t\t\t\tmaterialized_columns, alias_columns, column_defaults, context);",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": "const String & part_name)\n{\n\tLO",
          "new_api": null,
          "old_text": "const String & part_name)\n{\n\tLO",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tdata.materialized_columns = std::move(materialized_columns);",
          "new_line_content": "\t\t\t\t\t\t\tif (unreplicated_data)",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": "to part = data.getActive",
          "new_api": null,
          "old_text": "to part = data.getActive",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tdata.alias_columns = std::move(alias_columns);",
          "new_line_content": "\t\t\t\t\t\t\tthis->materialized_columns = materialized_columns;",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": "нас есть этот кусок, и он",
          "new_api": null,
          "old_text": " нас есть этот кусок, и он",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tdata.column_defaults = std::move(column_defaults);",
          "new_line_content": "\t\t\t\t\t\t\tthis->alias_columns = alias_columns;",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": "роверять, нужен ли нам этот кусок и правил",
          "new_api": null,
          "old_text": "роверять, нужен ли нам этот кусок и правил",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tLOG_INFO(log, \"Applied changes to table.\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1888,
          "old_api": "ing data of part \"",
          "new_api": null,
          "old_text": "ing data of part \" ",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tparts = data.getDataParts();",
          "new_line_content": "\t\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 1896,
          "old_api": "+ \"/checksums\"));",
          "new_api": null,
          "old_text": "+ \"/checksums\"));\n\t\t",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tauto table_lock = lockStructure(false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1899,
          "old_api": "cksums, true);\n\n\t\t\t\tauto zk_colu",
          "new_api": null,
          "old_text": "cksums, true);\n\n\t\t\t\tauto zk_colu",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tLOG_INFO(log, \"ALTER-ing parts\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1904,
          "old_api": "s/\" + part_name + \"",
          "new_api": null,
          "old_text": "s/\" + part_name + \"",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tparts = data.getDataParts();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1922,
          "old_api": "ProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);\n\n\t\t\t\tremovePartAndEnqueueFetch(part_name);\n\n\t\t\t\t/// Удалим кусок локально.",
          "new_api": null,
          "old_text": "ProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);\n\n\t\t\t\tremovePartAndEnqueueFetch(part_name);\n\n\t\t\t\t/// Удалим кусок локально.",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tops.push_back(new zkutil::Op::SetData(",
          "new_line_content": "\t\t\t\t\t\tif (!transaction)",
          "content_same": false
        },
        {
          "line": 1923,
          "old_api": "h",
          "new_api": null,
          "old_text": "h(part_name);\n\n\t\t\t\t/// Удалим кусок лок",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\treplica_path + \"/parts/\" + part->name + \"/columns\", transaction->getNewColumns().toString(), -1));",
          "new_line_content": "\t\t\t\t\t\t\tcontinue;",
          "content_same": false
        },
        {
          "line": 1924,
          "old_api": "renameAndDetachPart",
          "new_api": null,
          "old_text": "a.renameAndDetachPart(part, \"broken_\");\n\t\t\t}\n\t\t}\n\t\telse if (part->modification_time + MAX_AGE_OF_LOCAL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < time(0)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tops.push_back(new zkutil::Op::SetData(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1925,
          "old_api": "AL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < t",
          "new_api": null,
          "old_text": "AL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < t",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\treplica_path + \"/parts/\" + part->name + \"/checksums\", transaction->getNewChecksums().toString(), -1));",
          "new_line_content": "\t\t\t\t\t\t++changed_parts;",
          "content_same": false
        },
        {
          "line": 1926,
          "old_api": "/// Если куска нет в",
          "new_api": null,
          "old_text": "\t/// Если куска нет в",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tzookeeper->multi(ops);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1935,
          "old_api": "tedPartChecksFailed);\n\n\t\t\tLOG_ERR",
          "new_api": null,
          "old_text": "tedPartChecksFailed);\n\n\t\t\tLOG_ERR",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tparts = unreplicated_data->getDataParts();",
          "new_line_content": "\t\t\t\t\t\t/// Применим изменения файлов.",
          "content_same": false
        },
        {
          "line": 1939,
          "old_api": "ndDetachPart",
          "new_api": null,
          "old_text": "ndDetachPart(part, \"unexpected_\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLOG_TRACE(lo",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tauto transaction = unreplicated_data->alterDataPart(part, columns_plus_materialized);",
          "new_line_content": "\t\t\t\t\t/// То же самое для нереплицируемых данных.",
          "content_same": false
        },
        {
          "line": 1951,
          "old_api": "вающий кусок, игнорируем все проблемы с этим куском.",
          "new_api": null,
          "old_text": "вающий кусок, игнорируем все проблемы с этим куском.\n\t",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tzookeeper->set(replica_path + \"/columns\", columns_str);",
          "new_line_content": "\t\t\t\t\t\t\t++changed_parts;",
          "content_same": false
        },
        {
          "line": 1956,
          "old_api": "шибки, пока кусок не удалится как старый.\n\t\tLOG_WARNING",
          "new_api": null,
          "old_text": "шибки, пока кусок не удалится как старый.\n\t\tLOG_WARNING",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tLOG_INFO(log, \"ALTER-ed \" << changed_parts << \" parts\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1967,
          "old_api": "{\n\t\t\t/// Достанем из оч",
          "new_api": null,
          "old_text": "\n\t\t{\n\t\t\t/// Достанем из оч",
          "new_text": null,
          "old_line_content": "\t\t\talter_thread_event->wait();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1971,
          "old_api": "String part_name;\n\t\t\t{\n\t\t\t\tstd::lock_guar",
          "new_api": null,
          "old_text": "\t\tString part_name;\n\t\t\t{\n\t\t\t\tstd::lock_guar",
          "new_text": null,
          "old_line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);",
          "new_line_content": "\t\t\t\t/// Важно, что уничтожается parts и merge_blocker перед wait-ом.",
          "content_same": false
        },
        {
          "line": 1975,
          "old_api": "empty",
          "new_api": null,
          "old_text": "x);\n\t\t\t\tif (parts_to_check_queue.empty())\n\t",
          "new_text": null,
          "old_line_content": "\t\t\talter_thread_event->tryWait(ERROR_SLEEP_MS);",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 1979,
          "old_api": "empty",
          "new_api": null,
          "old_text": "f (!parts_to_check_set.empty())\n\t\t\t\t\t{\n",
          "new_text": null,
          "old_line_content": "\tLOG_DEBUG(log, \"Alter thread finished\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1987,
          "old_api": "front",
          "new_api": null,
          "old_text": "\t{\n\t\t\t\t\tpart_name = parts_to_check_queue.front();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif",
          "new_text": null,
          "old_line_content": "\tops.push_back(new zkutil::Op::Remove(part_path + \"/checksums\", -1));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1988,
          "old_api": "empty",
          "new_api": null,
          "old_text": "art_name.empty())\n\t\t\t{\n\t\t\t\tparts_to_check_event.wait();\n\t\t\t\tconti",
          "new_text": null,
          "old_line_content": "\tops.push_back(new zkutil::Op::Remove(part_path + \"/columns\", -1));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": ";\n\t\t\t}\n\n\t\t\tcheckPart(part_name);\n\n\t\t\t/// Удалим кусо",
          "new_api": null,
          "old_text": ";\n\t\t\t}\n\n\t\t\tcheckPart(part_name);\n\n\t\t\t/// Удалим кусо",
          "new_text": null,
          "old_line_content": "\tops.push_back(new zkutil::Op::Remove(part_path, -1));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2001,
          "old_api": "pop_front",
          "new_api": null,
          "old_text": "\n\t\t\t\t\tparts_to_check_queue.pop_front();\n\t\t\t\t\tparts_to_ch",
          "new_text": null,
          "old_line_content": "\tlog_entry->create_time = tryGetPartCreateTime(zookeeper, replica_path, part_name);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2006,
          "old_api": "tryWait",
          "new_api": null,
          "old_text": "FUNCTION__);\n\t\t\tparts_to_check_event.tryWait(ERROR_SLEEP_MS);\n\t\t}\n\t}\n}\n\n\nvoid StorageReplicatedMergeTree::becomeLeader()\n{\n\tLOG_INFO(log, \"Became leader\");\n\tis_leader_",
          "new_text": null,
          "old_line_content": "\tops.push_back(new zkutil::Op::Create(",
          "new_line_content": "\tLogEntryPtr log_entry = new LogEntry;",
          "content_same": false
        },
        {
          "line": 2007,
          "old_api": "MergeTree::becomeLeader()",
          "new_api": null,
          "old_text": "MergeTree::becomeLeader()\n",
          "new_text": null,
          "old_line_content": "\t\treplica_path + \"/queue/queue-\", log_entry->toString(), zookeeper->getDefaultACL(),",
          "new_line_content": "\tlog_entry->type = LogEntry::GET_PART;",
          "content_same": false
        },
        {
          "line": 2010,
          "old_api": "= true;\n\tmerge_selecting_thread = std:",
          "new_api": null,
          "old_text": " = true;\n\tmerge_selecting_thread = std:",
          "new_text": null,
          "old_line_content": "\tremovePartFromZooKeeper(part_name, ops);",
          "new_line_content": "\tlog_entry->new_part_name = part_name;",
          "content_same": false
        },
        {
          "line": 2012,
          "old_api": "licatedMergeTree::mer",
          "new_api": null,
          "old_text": "licatedMergeTree::mer",
          "new_text": null,
          "old_line_content": "\tauto results = zookeeper->multi(ops);",
          "new_line_content": "\tzkutil::Ops ops;",
          "content_same": false
        },
        {
          "line": 2018,
          "old_api": "getChildren",
          "new_api": null,
          "old_text": "eper->getChildren(zookeeper_pa",
          "new_text": null,
          "old_line_content": "\t\tlog_entry->znode_name = path_created.substr(path_created.find_last_of('/') + 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2020,
          "old_api": "ок, выберем одну равноверо",
          "new_api": null,
          "old_text": "ок, выберем одну равноверо",
          "new_text": null,
          "old_line_content": "\t\tqueue.push_back(log_entry);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2029,
          "old_api": "\"/replicas/\" + replica + \"/par",
          "new_api": null,
          "old_text": "\"/replicas/\" + replica + \"/par",
          "new_text": null,
          "old_line_content": "\tif (parts_to_check_set.count(name))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2031,
          "old_api": "ame) &&\n\t\t\t(!active || zookeeper->ex",
          "new_api": null,
          "old_text": "ame) &&\n\t\t\t(!active || zookeeper->ex",
          "new_text": null,
          "old_line_content": "\tparts_to_check_queue.push_back(name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2032,
          "old_api": "s",
          "new_api": null,
          "old_text": "s(zookeeper_path + \"/replicas/\"",
          "new_text": null,
          "old_line_content": "\tparts_to_check_set.insert(name);",
          "new_line_content": "void StorageReplicatedMergeTree::enqueuePartForCheck(const String & name)",
          "content_same": false
        },
        {
          "line": 2033,
          "old_api": "replica + \"/is_active\")))",
          "new_api": null,
          "old_text": "replica + \"/is_active\")))\n",
          "new_text": null,
          "old_line_content": "\tparts_to_check_event.set();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2043,
          "old_api": "r",
          "new_api": null,
          "old_text": "r();\n\n\t/// Информация, на ка",
          "new_text": null,
          "old_line_content": "\tif (zookeeper->exists(part_path))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2045,
          "old_api": "лики был добавлен кусок, если кворум ещё не достигнут.\n\tconst String quorum_status_path = zookeeper_path + \"/quorum/status\";\n\t/// Имя предыдущ",
          "new_api": null,
          "old_text": "лики был добавлен кусок, если кворум ещё не достигнут.\n\tconst String quorum_status_path = zookeeper_path + \"/quorum/status\";\n\t/// Имя предыдущ",
          "new_text": null,
          "old_line_content": "\t\tLOG_WARNING(log, \"Checker: Part \" << part_name << \" exists in ZooKeeper but not locally. \"",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2047,
          "old_api": "куска, для которого был достигнут кворум.\n\tconst String quorum_last",
          "new_api": null,
          "old_text": "куска, для которого был достигнут кворум.\n\tconst String quorum_last",
          "new_text": null,
          "old_line_content": "\t\tProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);",
          "new_line_content": "\tString part_path = replica_path + \"/parts/\" + part_name;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 154,
      "total_additions": 509,
      "total_deletions": 507,
      "total_api_changes": 1170
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 12,
        "api_related_lines": 1170,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          784,
          785,
          773,
          774
        ]
      }
    },
    "api_calls_before": 994,
    "api_calls_after": 998,
    "diff_info": {
      "added_lines": 11,
      "removed_lines": 4,
      "total_diff_lines": 29
    }
  }
}