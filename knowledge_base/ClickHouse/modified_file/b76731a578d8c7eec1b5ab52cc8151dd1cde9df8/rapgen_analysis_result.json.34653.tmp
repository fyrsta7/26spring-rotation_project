{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/b76731a578d8c7eec1b5ab52cc8151dd1cde9df8",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/b76731a578d8c7eec1b5ab52cc8151dd1cde9df8/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/b76731a578d8c7eec1b5ab52cc8151dd1cde9df8/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/b76731a578d8c7eec1b5ab52cc8151dd1cde9df8/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [],
      "additions": [],
      "deletions": [
        {
          "line": 2049,
          "api": "_path = zookeeper_path + \"/quorum/la",
          "text": "_path = zookeeper_path + \"/quorum/la",
          "line_content": "\t\tremovePartAndEnqueueFetch(part_name);"
        },
        {
          "line": 2055,
          "api": "tryGet",
          "text": "zookeeper->tryGet(quorum_status_path, value, &stat))\n\t",
          "line_content": "\tActiveDataPartSet::parsePartName(part_name, part_info);"
        },
        {
          "line": 2067,
          "api": ");\n\n\t\t\tif (code == ZOK)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (code == ZNONODE)\n\t\t\t{\n\t\t\t\t///",
          "text": ");\n\n\t\t\tif (code == ZOK)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (code == ZNONODE)\n\t\t\t{\n\t\t\t\t///",
          "line_content": "\tLOG_WARNING(log, \"Checker: Checking if anyone has part covering \" << part_name << \".\");"
        },
        {
          "line": 2074,
          "api": "nue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow zkutil::KeeperException(",
          "text": "nue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow zkutil::KeeperException(",
          "line_content": "\tStrings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");"
        },
        {
          "line": 2077,
          "api": "eTree::fetchPart(const String & part_name, const String & replica_path, bo",
          "text": "eTree::fetchPart(const String & part_name, const String & replica_path, bo",
          "line_content": "\t\tStrings parts = zookeeper->getChildren(zookeeper_path + \"/replicas/\" + replica + \"/parts\");"
        },
        {
          "line": 2080,
          "api": "g part \" << part_name << \" from \" << replica_path);\n\n\tT",
          "text": "g part \" << part_name << \" from \" << replica_path);\n\n\tT",
          "line_content": "\t\t\tif (part_on_replica == part_name || ActiveDataPartSet::contains(part_on_replica, part_name))"
        },
        {
          "line": 2083,
          "api": "e_lock;\n\tif (!to_detached)\n\t\ttable_lock = lockStructure(true);\n\n\tReplicatedMerge",
          "text": "e_lock;\n\tif (!to_detached)\n\t\ttable_lock = lockStructure(true);\n\n\tReplicatedMerge",
          "line_content": "\t\t\t\tLOG_WARNING(log, \"Checker: Found part \" << part_on_replica << \" on \" << replica);"
        },
        {
          "line": 2087,
          "api": "get",
          "text": "per->get(replica_path + \"/host\"));\n\n\tMergeTreeData::Mut",
          "line_content": "\t\t\tif (ActiveDataPartSet::contains(part_name, part_on_replica))"
        },
        {
          "line": 2090,
          "api": "ath, address.host, address.replication_port, to_detached);\n\n\tif (!to_de",
          "text": "ath, address.host, address.replication_port, to_detached);\n\n\tif (!to_de",
          "line_content": "\t\t\t\tActiveDataPartSet::parsePartName(part_on_replica, part_on_replica_info);"
        },
        {
          "line": 2093,
          "api": "nsaction;\n\t\tauto removed_parts = data.renam",
          "text": "nsaction;\n\t\tauto removed_parts = data.renam",
          "line_content": "\t\t\t\t\tfound_blocks.at(block_num - part_info.left) = 1;"
        },
        {
          "line": 2113,
          "api": "getFullPath",
          "text": "teReplicatedParts);\n\t\t}\n\t}\n\telse\n\t{\n\t\tPoco::File(data.getFullPath() + \"detached/tmp_\" + part_nam",
          "line_content": "\t\tLOG_WARNING(log, \"Checker: Found all blocks for missing part. Will wait for them to be merged.\");"
        },
        {
          "line": 2118,
          "api": "Events::increment(ProfileEvents::ReplicatedPartFetches);\n\n\tLOG_DEBUG(",
          "text": "Events::increment(ProfileEvents::ReplicatedPartFetches);\n\n\tLOG_DEBUG(",
          "line_content": "\tLOG_ERROR(log, \"Checker: No replica has part covering \" << part_name);"
        },
        {
          "line": 2121,
          "api": "<< \" from \" << replica_path << (to_detached ? \" (to 'detached' directory)\" : \"\"));\n}\n\n\nvoid StorageReplicatedMergeTree::shutdown()\n{\n\tif (restarting_thread)\n\t{\n\t\trestarting_thre",
          "text": " << \" from \" << replica_path << (to_detached ? \" (to 'detached' directory)\" : \"\"));\n}\n\n\nvoid StorageReplicatedMergeTree::shutdown()\n{\n\tif (restarting_thread)\n\t{\n\t\trestarting_thre",
          "line_content": "\t\tLOG_WARNING(log, \"When looking for smaller parts, that is covered by \" << part_name"
        },
        {
          "line": 2124,
          "api": "reset",
          "text": "stop();\n\t\trestarting_thread.reset();\n\t}\n\n\tendpoint_holder = nullptr",
          "line_content": "\tProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);"
        },
        {
          "line": 2131,
          "api": "gs,\n\tQueryP",
          "text": "gs,\n\tQueryP",
          "line_content": "\t\tfor (LogEntries::iterator it = queue.begin(); it != queue.end();)"
        },
        {
          "line": 2135,
          "api": "block_size,\n\tconst unsigned threads)\n{\n\t/** У таблицы может быть д",
          "text": "block_size,\n\tconst unsigned threads)\n{\n\t/** У таблицы может быть д",
          "line_content": "\t\t\t\tzookeeper->tryRemove(replica_path + \"/queue/\" + (*it)->znode_name);"
        },
        {
          "line": 2136,
          "api": "а данных:\n\t  * -",
          "text": "а данных:\n\t  * - ",
          "line_content": "\t\t\t\tqueue.erase(it++);"
        },
        {
          "line": 96,
          "api": "== ZCONNECTIONLOSS)",
          "text": "== ZCONNECTIONLOSS)\n\t\t",
          "line_content": "\tcurrent_zookeeper(context.getZooKeeper()), database_name(database_name_),"
        },
        {
          "line": 97,
          "api": "nullptr;\n\t\t}\n\t\telse\n\t\t\tthrow",
          "text": " nullptr;\n\t\t}\n\t\telse\n\t\t\tthrow",
          "line_content": "\ttable_name(name_), full_path(path_ + escapeForFileName(table_name) + '/'),"
        },
        {
          "line": 98,
          "api": "(skip_sanity_checks);\n\n\tif (!current_zookee",
          "text": "(skip_sanity_checks);\n\n\tif (!current_zookee",
          "line_content": "\tzookeeper_path(context.getMacros().expand(zookeeper_path_)),"
        },
        {
          "line": 99,
          "api": "tach)\n\t\t\tthrow Exception(\"Can't create re",
          "text": "tach)\n\t\t\tthrow Exception(\"Can't create re",
          "line_content": "\treplica_name(context.getMacros().expand(replica_name_)),"
        },
        {
          "line": 2147,
          "api": "ность использовать \"виртуальные столбцы\".\n\t  * Один из них - _replicated позволя",
          "text": "ность использовать \"виртуальные столбцы\".\n\t  * Один из них - _replicated позволя",
          "line_content": "\t\tLOG_ERROR(log, \"Checker: Missing part \" << part_name << \" is not in our queue.\");"
        },
        {
          "line": 105,
          "api": "nclean DROP table or manual intervention. You must either clear directory by hand or use",
          "text": "nclean DROP table or manual intervention. You must either clear directory by hand or use",
          "line_content": "\t\t std::bind(&StorageReplicatedMergeTree::enqueuePartForCheck, this, std::placeholders::_1)),"
        },
        {
          "line": 2154,
          "api": "uery &>(*query);\n\n\t/// Try transferring some condition from WHERE to",
          "text": "uery &>(*query);\n\n\t/// Try transferring some condition from WHERE to",
          "line_content": "\tLOG_ERROR(log, \"Checker: Part \" << part_name << \" is lost forever.\");"
        },
        {
          "line": 107,
          "api": "CT_DATA);\n\n\t\tcreateTableIfNotExists();\n\n\t\tcheckTableStructure(false, false);",
          "text": "CT_DATA);\n\n\t\tcreateTableIfNotExists();\n\n\t\tcheckTableStructure(false, false);\n\t\t",
          "line_content": "\tlog(&Logger::get(database_name + \".\" + table_name + \" (StorageReplicatedMergeTree)\"))"
        },
        {
          "line": 2155,
          "api": "EWHERE if enabled and viable\n\tif (settings.optimize_move_to",
          "text": "EWHERE if enabled and viable\n\tif (settings.optimize_move_to",
          "line_content": "\tProfileEvents::increment(ProfileEvents::ReplicatedDataLoss);"
        },
        {
          "line": 109,
          "api": "TableStructure",
          "text": "TableStructure(skip_s",
          "line_content": "\tif (!zookeeper_path.empty() && zookeeper_path.back() == '/')"
        },
        {
          "line": 110,
          "api": "(skip_sanity_checks);",
          "text": "(skip_sanity_checks);",
          "line_content": "\t\tzookeeper_path.resize(zookeeper_path.size() - 1);"
        },
        {
          "line": 117,
          "api": "exists",
          "text": "d_path).exists())\n\t{\n\t\tunreplicated_data.reset(new MergeTreeData(unre",
          "line_content": "\t\tif (current_zookeeper && current_zookeeper->exists(replica_path + \"/flags/force_restore_data\"))"
        },
        {
          "line": 120,
          "api": "d_columns_, alias_columns_, column_defaults_,\n\t\t\tcontext_, primary_ex",
          "text": "d_columns_, alias_columns_, column_defaults_,\n\t\t\tcontext_, primary_ex",
          "line_content": "\t\t\tcurrent_zookeeper->remove(replica_path + \"/flags/force_restore_data\");"
        },
        {
          "line": 122,
          "api": "_,\n\t\t\tdate_column_name_, sampling_expression_, index_granularity_, mode_, sign_column_, columns_to_sum_, settings_,\n\t\t\tdatabase_name_ + \".\" + table_",
          "text": "_,\n\t\t\tdate_column_name_, sampling_expression_, index_granularity_, mode_, sign_column_, columns_to_sum_, settings_,\n\t\t\tdatabase_name_ + \".\" + table_",
          "line_content": "\t\t\tLOG_WARNING(log, \"Skipping the limits on severity of changes to data parts and columns (flag \""
        },
        {
          "line": 2173,
          "api": "count",
          "text": "parallel_replica_offset == 0) && unreplicated_reader && values.count(0))\n\t{\n\t\tres = unreplicated_reader->read(real_column_n",
          "line_content": "\t\tLOG_ERROR(log, \"Won't add nonincrement_block_numbers because part spans too much blocks (\" << part_length_in_blocks << \")\");"
        },
        {
          "line": 131,
          "api": "et",
          "text": "et(new MergeTreeDataSelectExecutor(*unrepli",
          "line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);"
        },
        {
          "line": 2179,
          "api": "max_block_size, threads, &part_index, 0);\n\n\t\tfor (auto & virtual_column : virt_column_names)",
          "text": "\tmax_block_size, threads, &part_index, 0);\n\n\t\tfor (auto & virtual_column : virt_column_names)\n\t\t",
          "line_content": "\t\tLOG_ERROR(log, \"Won't add nonincrement_block_numbers because part is one of first in partition\");"
        },
        {
          "line": 2183,
          "api": "{\n\t\t\t\tfor (auto & str",
          "text": "\t{\n\t\t\t\tfor (auto & str",
          "line_content": "\tconst auto partition_str = part_name.substr(0, 6);"
        },
        {
          "line": 138,
          "api": "Merger",
          "text": "Merger(*unreplicated_data));\n\t\t}\n\t}\n\n\t",
          "line_content": "\tdata.loadDataParts(skip_sanity_checks);"
        },
        {
          "line": 2186,
          "api": "nt8>(stream, new DataTypeUInt8, 0, \"_replicated\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (values.coun",
          "text": "nt8>(stream, new DataTypeUInt8, 0, \"_replicated\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (values.coun",
          "line_content": "\t\tzookeeper->createIfNotExists(zookeeper_path + \"/nonincrement_block_numbers\", \"\");"
        },
        {
          "line": 2187,
          "api": ")\n\t{\n\t\t/** Настройка select_sequential_consistency имеет два смысла:\n\t\t  * 1. Кидать исключение,",
          "text": ")\n\t{\n\t\t/** Настройка select_sequential_consistency имеет два смысла:\n\t\t  * 1. Кидать исключение, ",
          "line_content": "\t\tzookeeper->createIfNotExists(zookeeper_path + \"/nonincrement_block_numbers/\" + partition_str, \"\");"
        },
        {
          "line": 2188,
          "api": "на реплике есть не все куски, которые были записаны на кворум остальных реплик.\n\t\t  * 2. Не читать куски, которые ещё не были записаны на кворум реплик.\n\t\t  * Для",
          "text": " на реплике есть не все куски, которые были записаны на кворум остальных реплик.\n\t\t  * 2. Не читать куски, которые ещё не были записаны на кворум реплик.\n\t\t  * Для ",
          "line_content": "\t\tAbandonableLockInZooKeeper::createAbandonedIfNotExists("
        },
        {
          "line": 2189,
          "api": "а кворум ре",
          "text": "а кворум ре",
          "line_content": "\t\t\tzookeeper_path + \"/nonincrement_block_numbers/\" + partition_str + \"/block-\" + padIndex(i),"
        },
        {
          "line": 143,
          "api": "reset",
          "text": "вана.\n\trestarting_thread.reset(new ReplicatedMergeTreeRestartingThread(*this));\n}\n\n\nvo",
          "line_content": "\t\t\tthrow Exception(\"Can't create replicated table without ZooKeeper\", ErrorCodes::NO_ZOOKEEPER);"
        },
        {
          "line": 2197,
          "api": "o_read = 0;\n\t\tif (settings.select_sequential_consistency",
          "text": "o_read = 0;\n\t\tif (settings.select_sequential_consistency",
          "line_content": "\tLOG_WARNING(log, \"Checker: Checking part \" << part_name);"
        },
        {
          "line": 2198,
          "api": "{\n\t\t\tauto zookeeper = getZooKeeper();\n\t\t\tString last_part;",
          "text": "\t{\n\t\t\tauto zookeeper = getZooKeeper();\n\t\t\tString last_part;\n\t",
          "line_content": "\tProfileEvents::increment(ProfileEvents::ReplicatedPartChecks);"
        },
        {
          "line": 151,
          "api": "ateIfNotExists",
          "text": "ateIfNotExists(zookeeper_pa",
          "line_content": "\t\tif (!data.getDataParts().empty())"
        },
        {
          "line": 152,
          "api": "createIfNotExists",
          "text": "um\", \"\");\n\tzookeeper->createIfNotExists(zookeeper_path + \"/quorum/last_part\", \"\");\n\tzookeeper->createIfNotExists(zookeeper_path + \"/quorum/failed_parts\", \"\");\n\n\t/// Отслеживание отставания реплик.\n\tzookeeper->createIfNotExists(replica_path + \"/min_unprocessed_insert_time",
          "line_content": "\t\t\tthrow Exception(\"Data directory for table already containing data parts - probably it was unclean DROP table or manual intervention. You must either clear directory by hand or use ATTACH TABLE instead of CREATE TABLE if you need to use that parts.\", ErrorCodes::INCORRECT_DATA);"
        },
        {
          "line": 2200,
          "api": "Get",
          "text": "Get(zookeeper_path + \"/quorum/last_part",
          "line_content": "\tauto part = data.getActiveContainingPart(part_name);"
        },
        {
          "line": 154,
          "api": ");\n}\n\n\nStoragePtr Storag",
          "text": ");\n}\n\n\nStoragePtr Storag",
          "line_content": "\t\tcreateTableIfNotExists();"
        },
        {
          "line": 156,
          "api": "icatedMergeTree::create(\n\tconst S",
          "text": "icatedMergeTree::create(\n\tconst S",
          "line_content": "\t\tcheckTableStructure(false, false);"
        },
        {
          "line": 157,
          "api": "g & zookeeper_p",
          "text": "g & zookeeper_p",
          "line_content": "\t\tcreateReplica();"
        },
        {
          "line": 2205,
          "api": "е реплики при распределённых за",
          "text": "е реплики при распределённых за",
          "line_content": "\t\tsearchForMissingPart(part_name);"
        },
        {
          "line": 161,
          "api": "ing & replica_name_,\n\tbool attach,\n\tconst Str",
          "text": "ing & replica_name_,\n\tbool attach,\n\tconst Str",
          "line_content": "\t\tcheckTableStructure(skip_sanity_checks, true);"
        },
        {
          "line": 162,
          "api": "& path_, const String & databa",
          "text": "& path_, const String & databa",
          "line_content": "\t\tcheckParts(skip_sanity_checks);"
        },
        {
          "line": 2210,
          "api": "M);\n\n\t\t\tif (la",
          "text": "M);\n\n\t\t\tif (la",
          "line_content": "\t\tauto zookeeper = getZooKeeper();"
        },
        {
          "line": 2211,
          "api": "сли ещё ни один кусо",
          "text": "сли ещё ни один кусо",
          "line_content": "\t\tauto table_lock = lockStructure(false);"
        },
        {
          "line": 165,
          "api": "_, const String & name_,",
          "text": "_, const String & name_,\n",
          "line_content": "\tcreateNewZooKeeperNodes();"
        },
        {
          "line": 2214,
          "api": "licatedMergeTreeQuorumEntry quorum_entry;\n\t\t\t\t\tquorum_e",
          "text": "licatedMergeTreeQuorumEntry quorum_entry;\n\t\t\t\t\tquorum_e",
          "line_content": "\t\tif (zookeeper->exists(replica_path + \"/parts/\" + part_name))"
        },
        {
          "line": 167,
          "api": "esAndTypesListPtr",
          "text": "esAndTypesListPtr ",
          "line_content": "\tinitVirtualParts();"
        },
        {
          "line": 2216,
          "api": "String",
          "text": "String(quorum_str);\n\t\t\t\t\tActiveDataPartSet::Part part_info;\n\t\t\t\t\tActive",
          "line_content": "\t\t\tLOG_WARNING(log, \"Checker: Checking data of part \" << part_name << \".\");"
        },
        {
          "line": 170,
          "api": "t NamesAndTypesList & alias_columns_,",
          "text": "t NamesAndTypesList & alias_columns_,\n",
          "line_content": "\tif (Poco::File(unreplicated_path).exists())"
        },
        {
          "line": 172,
          "api": "ColumnDefaults & column_defaults_,\n\tContext & context_,\n\tASTPtr & primary_expr_ast_,\n\tconst String & date_column_name_,\n\tconst ASTPtr & sampling_expression_,\n\tsize_t index_granularity_,\n\tMergeTreeData::Mode mode_,\n\tconst String & sign_column_,\n\tconst Names & columns_to_sum_,\n\tconst MergeTreeSettings & settings_)\n{\n\tauto res = new StorageR",
          "text": "ColumnDefaults & column_defaults_,\n\tContext & context_,\n\tASTPtr & primary_expr_ast_,\n\tconst String & date_column_name_,\n\tconst ASTPtr & sampling_expression_,\n\tsize_t index_granularity_,\n\tMergeTreeData::Mode mode_,\n\tconst String & sign_column_,\n\tconst Names & columns_to_sum_,\n\tconst MergeTreeSettings & settings_)\n{\n\tauto res = new StorageR",
          "line_content": "\t\tunreplicated_data.reset(new MergeTreeData(unreplicated_path, columns_,"
        },
        {
          "line": 2220,
          "api": ".part_name, part_info);\n\t\t\t\t\tmax_block_number_to_read = part_info.left - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tActiveDataPa",
          "text": ".part_name, part_info);\n\t\t\t\t\tmax_block_number_to_read = part_info.left - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tActiveDataPa",
          "line_content": "\t\t\t\tauto zk_checksums = MergeTreeData::DataPart::Checksums::parse("
        },
        {
          "line": 2221,
          "api": "_read = part_info.left - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tActiveDataP",
          "text": "_read = part_info.left - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tActiveDataP",
          "line_content": "\t\t\t\t\tzookeeper->get(replica_path + \"/parts/\" + part_name + \"/checksums\"));"
        },
        {
          "line": 2222,
          "api": ":Part part_info;\n\t\t\t\tActiveDataPartSet::parseP",
          "text": ":Part part_info;\n\t\t\t\tActiveDataPartSet::parseP",
          "line_content": "\t\t\t\tzk_checksums.checkEqual(part->checksums, true);"
        },
        {
          "line": 2224,
          "api": "read",
          "text": "nfo);\n\t\t\t\tmax_block_number_to_read = part_info.right;\n\t\t\t}\n\t\t}\n\n\t\tauto res2 = reader.read(\n\t\t\trea",
          "line_content": "\t\t\t\tauto zk_columns = NamesAndTypesList::parse("
        },
        {
          "line": 2225,
          "api": "read",
          "text": "ead = part_info.right;\n\t\t\t}\n\t\t}\n\n\t\tauto res2 = reader.read(\n\t\t\tre",
          "line_content": "\t\t\t\t\tzookeeper->get(replica_path + \"/parts/\" + part_name + \"/columns\"));"
        },
        {
          "line": 178,
          "api": "atedMergeTree{\n\t\tzookeeper_path_, replica_name_, att",
          "text": "atedMergeTree{\n\t\tzookeeper_path_, replica_name_, att",
          "line_content": "\t\tunreplicated_data->loadDataParts(skip_sanity_checks);"
        },
        {
          "line": 2227,
          "api": "d_stage, max_block_size, threads, &part_index, max_block_number_to_read);\n\n\t\tfor",
          "text": "d_stage, max_block_size, threads, &part_index, max_block_number_to_read);\n\n\t\tfor ",
          "line_content": "\t\t\t\t\tthrow Exception(\"Columns of local part \" + part_name + \" are different from ZooKeeper\");"
        },
        {
          "line": 180,
          "api": "th_, database_name_, name_,\n\t\tcolumns_, materia",
          "text": "th_, database_name_, name_,\n\t\tcolumns_, materia",
          "line_content": "\t\tif (unreplicated_data->getDataPartsVector().empty())"
        },
        {
          "line": 182,
          "api": "umns_, alias_columns_, co",
          "text": "umns_, alias_columns_, co",
          "line_content": "\t\t\tunreplicated_data.reset();"
        },
        {
          "line": 2230,
          "api": "f (virtual_column == \"_replicated\")\n\t\t\t{\n\t\t\t\tfor (au",
          "text": "f (virtual_column == \"_replicated\")\n\t\t\t{\n\t\t\t\tfor (au",
          "line_content": "\t\t\t\tsettings.setIndexGranularity(data.index_granularity);"
        },
        {
          "line": 2231,
          "api": "tream : res2)\n\t\t\t\t\tstream = new Ad",
          "text": "tream : res2)\n\t\t\t\t\tstream = new Ad",
          "line_content": "\t\t\t\tsettings.setRequireChecksums(true);"
        },
        {
          "line": 2232,
          "api": "nstColumnBlockInputStream<UInt8>(str",
          "text": "nstColumnBlockInputStream<UInt8>(str",
          "line_content": "\t\t\t\tsettings.setRequireColumnFiles(true);"
        },
        {
          "line": 186,
          "api": "ntext_, primary_expr_ast_, date_column_",
          "text": "ntext_, primary_expr_ast_, date_column_",
          "line_content": "\t\t\tLOG_INFO(log, \"Have unreplicated data\");"
        },
        {
          "line": 187,
          "api": ",\n\t\tsampling_expression_, index_granularity_, mode_,\n\t\tsign_column_, columns_t",
          "text": ",\n\t\tsampling_expression_, index_granularity_, mode_,\n\t\tsign_column_, columns_t",
          "line_content": "\t\t\tunreplicated_reader.reset(new MergeTreeDataSelectExecutor(*unreplicated_data));"
        },
        {
          "line": 188,
          "api": "thisPtr",
          "text": "_, settings_};\n\n\tStoragePtr res_ptr = res->thisPtr();\n\n\tif (res->getZo",
          "line_content": "\t\t\tunreplicated_merger.reset(new MergeTreeDataMerger(*unreplicated_data));"
        },
        {
          "line": 2233,
          "api": "insert",
          "text": "ew DataTypeUInt8, 1, \"_replicated\");\n\t\t\t}\n\t\t}\n\n\t\tres.insert(res.end(), res2.begin(), res2.end());\n\t}\n\n\treturn re",
          "line_content": "\t\t\t\tMergeTreePartChecker::checkDataPart("
        },
        {
          "line": 2234,
          "api": "insert",
          "text": "\t\t}\n\n\t\tres.insert(",
          "line_content": "\t\t\t\t\tdata.getFullPath() + part_name, settings, data.primary_key_data_types);"
        },
        {
          "line": 2236,
          "api": "BlockOutputStreamPtr StorageReplicatedMergeTree::write(ASTPtr",
          "text": "BlockOutputStreamPtr StorageReplicatedMergeTree::write(ASTPtr ",
          "line_content": "\t\t\t\tLOG_INFO(log, \"Checker: Part \" << part_name << \" looks good.\");"
        },
        {
          "line": 192,
          "api": "{\n\t\tString",
          "text": "\t{\n\t\tString",
          "line_content": "\tloadQueue();"
        },
        {
          "line": 2240,
          "api": "s)\n{\n\tif (is_readonly)\n\t\tthrow Exception(\"T",
          "text": "s)\n{\n\tif (is_readonly)\n\t\tthrow Exception(\"T",
          "line_content": "\t\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);"
        },
        {
          "line": 2242,
          "api": "in readonly mode\", ErrorCodes::TABLE_IS_READ_ONLY);\n\n\tString insert_id;\n\tif (query)\n\t\tif (ASTInser",
          "text": " in readonly mode\", ErrorCodes::TABLE_IS_READ_ONLY);\n\n\tString insert_id;\n\tif (query)\n\t\tif (ASTInser",
          "line_content": "\t\t\t\tLOG_ERROR(log, \"Checker: Part \" << part_name << \" looks broken. Removing it and queueing a fetch.\");"
        },
        {
          "line": 195,
          "api": "r endpoint = new ReplicatedMergeTreePartsServer(res->data, *res);\n\t\tres",
          "text": "r endpoint = new ReplicatedMergeTreePartsServer(res->data, *res);\n\t\tres",
          "line_content": "\trestarting_thread.reset(new ReplicatedMergeTreeRestartingThread(*this));"
        },
        {
          "line": 2243,
          "api": "* insert = typeid_cast<ASTInsertQuery *>(&*query))\n\t\t\tinsert_id =",
          "text": " * insert = typeid_cast<ASTInsertQuery *>(&*query))\n\t\t\tinsert_id = ",
          "line_content": "\t\t\t\tProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);"
        },
        {
          "line": 2245,
          "api": ">insert_id;\n\n\treturn new ReplicatedM",
          "text": ">insert_id;\n\n\treturn new ReplicatedM",
          "line_content": "\t\t\t\tremovePartAndEnqueueFetch(part_name);"
        },
        {
          "line": 2248,
          "api": "rt_quorum);\n}\n\n\nbool StorageReplicatedMer",
          "text": "rt_quorum);\n}\n\n\nbool StorageReplicatedMer",
          "line_content": "\t\t\t\tdata.renameAndDetachPart(part, \"broken_\");"
        },
        {
          "line": 201,
          "api": "text.getInters",
          "text": "text.getInters",
          "line_content": "\tauto zookeeper = getZooKeeper();"
        },
        {
          "line": 2251,
          "api": "ated.",
          "text": "ated.\n\t",
          "line_content": "\t\telse if (part->modification_time + MAX_AGE_OF_LOCAL_PART_THAT_WASNT_ADDED_TO_ZOOKEEPER < time(0))"
        },
        {
          "line": 204,
          "api": "static String formattedAST(const ASTPtr & ast)\n{\n\tif (!ast)",
          "text": "\nstatic String formattedAST(const ASTPtr & ast)\n{\n\tif (!ast)",
          "line_content": "\tzookeeper->createIfNotExists(zookeeper_path + \"/quorum\", \"\");"
        },
        {
          "line": 205,
          "api": "return \"\";\n\tstd::stringstream ss;\n\tformatAST(*ast, ss, 0, false, true)",
          "text": "return \"\";\n\tstd::stringstream ss;\n\tformatAST(*ast, ss, 0, false, true)",
          "line_content": "\tzookeeper->createIfNotExists(zookeeper_path + \"/quorum/last_part\", \"\");"
        },
        {
          "line": 206,
          "api": "str",
          "text": "return ss.str();\n}\n\n\nvoid StorageReplicatedMergeTree::createTableIfNotExi",
          "line_content": "\tzookeeper->createIfNotExists(zookeeper_path + \"/quorum/failed_parts\", \"\");"
        },
        {
          "line": 2256,
          "api": "selectPartsToMerge",
          "text": "{ return true; };\n\tif (!unreplicated_merger->selectPartsToMerge(par",
          "line_content": "\t\t\tProfileEvents::increment(ProfileEvents::ReplicatedPartChecksFailed);"
        },
        {
          "line": 209,
          "api": "keeper_path))\n\t\treturn;\n\n\tLOG_DEBUG(log, \"Creating table \" << zookeeper_path);",
          "text": "keeper_path))\n\t\treturn;\n\n\tLOG_DEBUG(log, \"Creating table \" << zookeeper_path);\n",
          "line_content": "\tzookeeper->createIfNotExists(replica_path + \"/min_unprocessed_insert_time\", \"\");"
        },
        {
          "line": 2258,
          "api": "rged_name, 0, true, true, false, always_can_merge))\n\t\treturn false;\n\n\tconst auto & merg",
          "text": "rged_name, 0, true, true, false, always_can_merge))\n\t\treturn false;\n\n\tconst auto & merg",
          "line_content": "\t\t\tLOG_ERROR(log, \"Checker: Unexpected part \" << part_name << \" in filesystem. Removing.\");"
        },
        {
          "line": 2259,
          "api": "getMergeList",
          "text": "ry = context.getMergeList().insert(database_n",
          "line_content": "\t\t\tdata.renameAndDetachPart(part, \"unexpected_\");"
        },
        {
          "line": 2263,
          "api": "mergeParts",
          "text": "ged_name);\n\tunreplicated_merger->mergeParts(parts, merged_name, *merge_entry, settings.min_bytes_to_use_direct_io);\n\n\treturn true;\n}\n\n\nvoid StorageReplicatedMergeTree::alter",
          "line_content": "\t\t\tLOG_TRACE(log, \"Checker: Young part \" << part_name"
        },
        {
          "line": 2264,
          "api": "y, sett",
          "text": "y, sett",
          "line_content": "\t\t\t\t<< \" with age \" << (time(0) - part->modification_time)"
        },
        {
          "line": 2272,
          "api": ", \"Doing ALTER\");\n\n\tNamesAndTypesList new_columns;\n\tNamesAndTypesList new_materialized_col",
          "text": ", \"Doing ALTER\");\n\n\tNamesAndTypesList new_columns;\n\tNamesAndTypesList new_materialized_col",
          "line_content": "\t\tLOG_WARNING(log, \"Checker: We have part \" << part->name << \" covering part \" << part_name);"
        },
        {
          "line": 2279,
          "api": "_column_defaults;\n\tString new_co",
          "text": "_column_defaults;\n\tString new_co",
          "line_content": "\tsetThreadName(\"ReplMTPartCheck\");"
        },
        {
          "line": 240,
          "api": "data.getColu",
          "text": "\t\tdata.getColu",
          "line_content": "\tStoragePtr res_ptr = res->thisPtr();"
        },
        {
          "line": 2289,
          "api": "checkAlter",
          "text": "checkAlter(params);\n\n\t\tnew_c",
          "line_content": "\t\t\t\tif (parts_to_check_queue.empty())"
        },
        {
          "line": 242,
          "api": "onMaterialized",
          "text": "onMaterialized(), d",
          "line_content": "\tif (res->getZooKeeper())"
        },
        {
          "line": 2291,
          "api": "olumnsListNonMaterialized",
          "text": "olumnsListNonMaterialized(",
          "line_content": "\t\t\t\t\tif (!parts_to_check_set.empty())"
        },
        {
          "line": 2293,
          "api": "alized_columns = data.materialized_columns;\n\t\tnew_alias_columns = data.alias_columns;\n\t\tnew_column_defa",
          "text": "alized_columns = data.materialized_columns;\n\t\tnew_alias_columns = data.alias_columns;\n\t\tnew_column_defa",
          "line_content": "\t\t\t\t\t\tLOG_ERROR(log, \"Checker: Non-empty parts_to_check_set with empty parts_to_check_queue. This is a bug.\");"
        },
        {
          "line": 246,
          "api": "push_back",
          "text": "));\n\tops.push_back(new zkutil::Op::Cre",
          "line_content": "\t\tres->endpoint_holder = new InterserverIOEndpointHolder(endpoint_name, endpoint, res->context.getInterserverIOHandler());"
        },
        {
          "line": 2294,
          "api": "ata.column_defaults;\n\t\tpar",
          "text": "ata.column_defaults;\n\t\tpar",
          "line_content": "\t\t\t\t\t\tparts_to_check_set.clear();"
        },
        {
          "line": 2299,
          "api": ", new_alias_columns, new_col",
          "text": ", new_alias_columns, new_col",
          "line_content": "\t\t\t\t\tpart_name = parts_to_check_queue.front();"
        },
        {
          "line": 2303,
          "api": "_columns_str = Co",
          "text": "_columns_str = Co",
          "line_content": "\t\t\tif (part_name.empty())"
        },
        {
          "line": 2305,
          "api": "ption<false>{\n\t\t\tnew_column",
          "text": "ption<false>{\n\t\t\tnew_column",
          "line_content": "\t\t\t\tparts_to_check_event.wait();"
        },
        {
          "line": 258,
          "api": "ookeeper_path + \"/block_numbers\", \"",
          "text": "ookeeper_path + \"/block_numbers\", \"",
          "line_content": "\tformatAST(*ast, ss, 0, false, true);"
        },
        {
          "line": 259,
          "api": "acl,",
          "text": "\t\t\t acl,",
          "line_content": "\treturn ss.str();"
        },
        {
          "line": 2309,
          "api": "ns,\n\t\t\tnew_alias_col",
          "text": "ns,\n\t\t\tnew_alias_col",
          "line_content": "\t\t\tcheckPart(part_name);"
        },
        {
          "line": 265,
          "api": "ath + \"/noninc",
          "text": "ath + \"/noninc",
          "line_content": "\tauto zookeeper = getZooKeeper();"
        },
        {
          "line": 2314,
          "api": "}\n\n\tLOG_DEBUG(log, \"Updated",
          "text": "\t}\n\n\tLOG_DEBUG(log, \"Updated",
          "line_content": "\t\t\t\tif (parts_to_check_queue.empty() || parts_to_check_queue.front() != part_name)"
        },
        {
          "line": 267,
          "api": "lock_numbers\", \"\",\n\t\t\t\t\t\t\t\t\t\t acl",
          "text": "lock_numbers\", \"\",\n\t\t\t\t\t\t\t\t\t\t acl",
          "line_content": "\tif (zookeeper->exists(zookeeper_path))"
        },
        {
          "line": 2316,
          "api": "ting for replicas to apply changes.\");\n\n\t/// Ждем, пока все реплики обновят данные.\n\n\t/",
          "text": "ting for replicas to apply changes.\");\n\n\t/// Ждем, пока все реплики обновят данные.\n\n\t/",
          "line_content": "\t\t\t\t\tLOG_ERROR(log, \"Checker: Someone changed parts_to_check_queue.front(). This is a bug.\");"
        },
        {
          "line": 270,
          "api": "push_back",
          "text": "teMode::Persistent));\n\tops.push_back(new zkutil::Op",
          "line_content": "\tLOG_DEBUG(log, \"Creating table \" << zookeeper_path);"
        },
        {
          "line": 272,
          "api": "eate",
          "text": "eate(zookeeper_path + \"/leader_election\", ",
          "line_content": "\tzookeeper->createAncestors(zookeeper_path);"
        },
        {
          "line": 2320,
          "api": "толбцов, чтобы перестать ждать,",
          "text": "толбцов, чтобы перестать ждать, ",
          "line_content": "\t\t\t\t\tparts_to_check_queue.pop_front();"
        },
        {
          "line": 2321,
          "api": "о-то еще сделает ALTER.\n\tif (!zooke",
          "text": "о-то еще сделает ALTER.\n\tif (!zooke",
          "line_content": "\t\t\t\t\tparts_to_check_set.erase(part_name);"
        },
        {
          "line": 2327,
          "api": "s\", &stat, alter_query_event))\n\t\tthrow Exce",
          "text": "s\", &stat, alter_query_event))\n\t\tthrow Exce",
          "line_content": "\t\t\ttryLogCurrentException(__PRETTY_FUNCTION__);"
        },
        {
          "line": 280,
          "api": "!= ZNODEEXISTS)\n\t\tthrow zkutil::Keepe",
          "text": " != ZNODEEXISTS)\n\t\tthrow zkutil::Keepe",
          "line_content": "\t\t\t<< \"sampling expression: \" << formattedAST(data.sampling_expression) << \"\\n\""
        },
        {
          "line": 2328,
          "api": "(zookeeper_path + \"/columns doesn't exist\",",
          "text": "(zookeeper_path + \"/columns doesn't exist\", ",
          "line_content": "\t\t\tparts_to_check_event.tryWait(ERROR_SLEEP_MS);"
        },
        {
          "line": 282,
          "api": "указанными в ZK (/metadata)",
          "text": "указанными в ZK (/metadata)",
          "line_content": "\t\t\t<< \"mode: \" << static_cast<int>(data.mode) << \"\\n\""
        },
        {
          "line": 284,
          "api": "tructure",
          "text": "tructure(bool skip_sanity_checks, b",
          "line_content": "\t\t\t<< \"primary key: \" << formattedAST(data.primary_expr_ast) << \"\\n\";"
        },
        {
          "line": 287,
          "api": "ookeeper = getZooKeeper();",
          "text": "ookeeper = getZooKeeper();",
          "line_content": "\tauto acl = zookeeper->getDefaultACL();"
        },
        {
          "line": 2336,
          "api": "ersion)\n\t{\n\t\tLOG_WARNING(log,",
          "text": "ersion)\n\t{\n\t\tLOG_WARNING(log, ",
          "line_content": "\tLOG_INFO(log, \"Became leader\");"
        },
        {
          "line": 290,
          "api": "get",
          "text": " = zookeeper->get(zookeeper_path + \"/metadata\");\n\tReadBufferFromString buf(metadata_str);\n\tassertString(\"",
          "line_content": "\tops.push_back(new zkutil::Op::Create(zookeeper_path, \"\","
        },
        {
          "line": 2338,
          "api": "finished; \"\n\t\t\t\"overlapping ALTER-s are fine but use caution with n",
          "text": " finished; \"\n\t\t\t\"overlapping ALTER-s are fine but use caution with n",
          "line_content": "\tmerge_selecting_thread = std::thread(&StorageReplicatedMergeTree::mergeSelectingThread, this);"
        },
        {
          "line": 292,
          "api": "adata format version: 1\", buf);\n\tassertString(\"\\ndate column: \", buf);\n\tassertString(data.date_column_name, buf);\n\tassertStri",
          "text": "adata format version: 1\", buf);\n\tassertString(\"\\ndate column: \", buf);\n\tassertString(data.date_column_name, buf);\n\tassertStri",
          "line_content": "\tops.push_back(new zkutil::Op::Create(zookeeper_path + \"/metadata\", metadata,"
        },
        {
          "line": 294,
          "api": "ampling_expression), buf);\n\tassertString(\"\\nindex granularity: \", buf);\n\tassertString(toString(data.index_granularity), buf);\n\tassertString(\"\\nmode: \",",
          "text": "ampling_expression), buf);\n\tassertString(\"\\nindex granularity: \", buf);\n\tassertString(toString(data.index_granularity), buf);\n\tassertString(\"\\nmode: \", ",
          "line_content": "\tops.push_back(new zkutil::Op::Create(zookeeper_path + \"/columns\", ColumnsDescription<false>{"
        },
        {
          "line": 295,
          "api": "ertString",
          "text": "ertString(\"\\nindex granularity: \", b",
          "line_content": "\t\t\t\tdata.getColumnsListNonMaterialized(), data.materialized_columns,"
        },
        {
          "line": 2344,
          "api": "t String & rep",
          "text": "t String & rep",
          "line_content": "\tauto zookeeper = getZooKeeper();"
        },
        {
          "line": 2345,
          "api": "LOG_DEBUG",
          "text": "LOG_DEBUG(log, \"Waiting for \" << replica << \" to app",
          "line_content": "\tStrings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");"
        },
        {
          "line": 298,
          "api": "de)), buf);\n\tassertString(\"\\nsign column: \", buf);\n\tassertString(data.sign_column, buf);\n\tassertString(\"\\nprimary",
          "text": "de)), buf);\n\tassertString(\"\\nsign column: \", buf);\n\tassertString(data.sign_column, buf);\n\tassertString(\"\\nprimary ",
          "line_content": "\tops.push_back(new zkutil::Op::Create(zookeeper_path + \"/log\", \"\","
        },
        {
          "line": 300,
          "api": ": \", buf);\n\t/// NOTE: Можно сделать менее строгую проверку совпадения выражений, чтобы таблицы не ломались от небольш",
          "text": ": \", buf);\n\t/// NOTE: Можно сделать менее строгую проверку совпадения выражений, чтобы таблицы не ломались от небольш",
          "line_content": "\tops.push_back(new zkutil::Op::Create(zookeeper_path + \"/blocks\", \"\","
        },
        {
          "line": 2348,
          "api": "\"/replicas/\"",
          "text": " \"/replicas/\" ",
          "line_content": "\tstd::random_shuffle(replicas.begin(), replicas.end());"
        },
        {
          "line": 302,
          "api": "изменений\n\t///       в коде formatAST.\n\tassertString(formattedAST(data.primary_expr_ast), buf);\n\tassertString(\"\\n\", buf);\n\ta",
          "text": "изменений\n\t///       в коде formatAST.\n\tassertString(formattedAST(data.primary_expr_ast), buf);\n\tassertString(\"\\n\", buf);\n\ta",
          "line_content": "\tops.push_back(new zkutil::Op::Create(zookeeper_path + \"/block_numbers\", \"\","
        },
        {
          "line": 304,
          "api": "get",
          "text": "rtEOF(buf);\n\n\tzkutil::Stat stat;\n\tauto columns_desc = ColumnsDescription<true>::parse(zookeeper->get(zookeeper_path + \"/columns\", &stat))",
          "line_content": "\tops.push_back(new zkutil::Op::Create(zookeeper_path + \"/nonincrement_block_numbers\", \"\","
        },
        {
          "line": 2352,
          "api": "{\n\t\t\t\tLOG_WARNING(log, replica << \" was removed\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint repli",
          "text": "\t\t{\n\t\t\t\tLOG_WARNING(log, replica << \" was removed\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint repli",
          "line_content": "\t\tif (zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/parts/\" + part_name) &&"
        },
        {
          "line": 306,
          "api": "auto & columns = columns_desc.columns;\n\tauto & materialized_columns = columns_desc.materialized;\n\tauto & alias_columns = colu",
          "text": "\tauto & columns = columns_desc.columns;\n\tauto & materialized_columns = columns_desc.materialized;\n\tauto & alias_columns = colu",
          "line_content": "\tops.push_back(new zkutil::Op::Create(zookeeper_path + \"/leader_election\", \"\","
        },
        {
          "line": 2353,
          "api": "= stat.version;\n\n\t\t\tif (replica_columns_str == new_columns_str)\n\t\t\t\tbreak",
          "text": "= stat.version;\n\n\t\t\tif (replica_columns_str == new_columns_str)\n\t\t\t\tbreak",
          "line_content": "\t\t\t(!active || zookeeper->exists(zookeeper_path + \"/replicas/\" + replica + \"/is_active\")))"
        },
        {
          "line": 308,
          "api": "_desc.alias;\n\tauto & column_defaults = columns_desc.defaults;\n\tcolumns_version = stat.version;\n\n\tif (columns != dat",
          "text": "_desc.alias;\n\tauto & column_defaults = columns_desc.defaults;\n\tcolumns_version = stat.version;\n\n\tif (columns != dat",
          "line_content": "\tops.push_back(new zkutil::Op::Create(zookeeper_path + \"/temp\", \"\","
        },
        {
          "line": 310,
          "api": "etColumnsListNonMaterialized",
          "text": "etColumnsListNonMaterialized() ||\n\t\tmaterialized_columns != data.materialized_columns ||\n\t\talias_columns != data.alias_",
          "line_content": "\tops.push_back(new zkutil::Op::Create(zookeeper_path + \"/replicas\", \"\","
        },
        {
          "line": 313,
          "api": "umn_defaults != data.col",
          "text": "umn_defaults != data.col",
          "line_content": "\tauto code = zookeeper->tryMulti(ops);"
        },
        {
          "line": 315,
          "api": "ty_checks ||\n\t\t\t data.getColu",
          "text": "ty_checks ||\n\t\t\t data.getColu",
          "line_content": "\t\tthrow zkutil::KeeperException(code);"
        },
        {
          "line": 2367,
          "api": "ery_event))",
          "text": "ery_event))\n\t\t",
          "line_content": "\tauto zookeeper = getZooKeeper();"
        },
        {
          "line": 324,
          "api": "updateMetadata",
          "text": "updateMetadata",
          "line_content": "\tauto zookeeper = getZooKeeper();"
        },
        {
          "line": 326,
          "api": ", columns,\n\t\t\t\tmaterialized_columns, alias_c",
          "text": ", columns,\n\t\t\t\tmaterialized_columns, alias_c",
          "line_content": "\tString metadata_str = zookeeper->get(zookeeper_path + \"/metadata\");"
        },
        {
          "line": 328,
          "api": "etColumnsList",
          "text": "etColumnsList(columns);\n\t\t\tdata.materialized_co",
          "line_content": "\tassertString(\"metadata format version: 1\", buf);"
        },
        {
          "line": 329,
          "api": "ns = std::move(materialized_columns)",
          "text": "ns = std::move(materialized_columns)",
          "line_content": "\tassertString(\"\\ndate column: \", buf);"
        },
        {
          "line": 330,
          "api": "data.alias_columns = std::move(alias_c",
          "text": "\t\tdata.alias_columns = std::move(alias_c",
          "line_content": "\tassertString(data.date_column_name, buf);"
        },
        {
          "line": 331,
          "api": "mns);\n\t\t\tdata.column_defaults = std::move(co",
          "text": "mns);\n\t\t\tdata.column_defaults = std::move(co",
          "line_content": "\tassertString(\"\\nsampling expression: \", buf);"
        },
        {
          "line": 332,
          "api": "}\n\t\telse\n\t\t{\n\t\t\tthrow Exception(\"Tab",
          "text": "\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow Exception(\"Tab",
          "line_content": "\tassertString(formattedAST(data.sampling_expression), buf);"
        },
        {
          "line": 333,
          "api": "ure in ZooKeeper is too different from loc",
          "text": "ure in ZooKeeper is too different from loc",
          "line_content": "\tassertString(\"\\nindex granularity: \", buf);"
        },
        {
          "line": 334,
          "api": "re.\",\n\t\t\t\t\t\t\tErrorCodes::INCOMPA",
          "text": "re.\",\n\t\t\t\t\t\t\tErrorCodes::INCOMPA",
          "line_content": "\tassertString(toString(data.index_granularity), buf);"
        },
        {
          "line": 335,
          "api": "UMNS);\n\t\t}\n\t}\n}\n\n\n/** При нео",
          "text": "UMNS);\n\t\t}\n\t}\n}\n\n\n/** При нео",
          "line_content": "\tassertString(\"\\nmode: \", buf);"
        },
        {
          "line": 336,
          "api": "усок, реплика сама добавляе",
          "text": "усок, реплика сама добавляе",
          "line_content": "\tassertString(toString(static_cast<int>(data.mode)), buf);"
        },
        {
          "line": 337,
          "api": "чередь запись на его получение.\n  *",
          "text": "чередь запись на его получение.\n  * ",
          "line_content": "\tassertString(\"\\nsign column: \", buf);"
        },
        {
          "line": 338,
          "api": "ое поставить время для этой записи",
          "text": "ое поставить время для этой записи ",
          "line_content": "\tassertString(data.sign_column, buf);"
        },
        {
          "line": 339,
          "api": "череди? Время учитывается при расчёт",
          "text": "череди? Время учитывается при расчёт",
          "line_content": "\tassertString(\"\\nprimary key: \", buf);"
        },
        {
          "line": 2381,
          "api": "ime) - 1);\n\n\t/// Уровень - rig",
          "text": "ime) - 1);\n\n\t/// Уровень - rig",
          "line_content": "\t\tquorum_entry.fromString(value);"
        },
        {
          "line": 2389,
          "api": "catedMergeTree::dropUnreplicatedPartition(",
          "text": "catedMergeTree::dropUnreplicatedPartition(",
          "line_content": "\t\tquorum_entry.replicas.insert(replica_name);"
        },
        {
          "line": 342,
          "api": "& zookeeper, const String & replica",
          "text": "& zookeeper, const String & replica",
          "line_content": "\tassertString(formattedAST(data.primary_expr_ast), buf);"
        },
        {
          "line": 343,
          "api": "nst String & part_name)",
          "text": "nst String & part_name)",
          "line_content": "\tassertString(\"\\n\", buf);"
        },
        {
          "line": 344,
          "api": "time_t res =",
          "text": "\ttime_t res = ",
          "line_content": "\tassertEOF(buf);"
        },
        {
          "line": 2391,
          "api": "ld & partition, const bool d",
          "text": "ld & partition, const bool d",
          "line_content": "\t\tif (quorum_entry.replicas.size() >= quorum_entry.required_number_of_replicas)"
        },
        {
          "line": 347,
          "api": "мер, смерджен).\n\tzkutil::Stat stat;\n\tString unused",
          "text": "мер, смерджен).\n\tzkutil::Stat stat;\n\tString unused",
          "line_content": "\tauto columns_desc = ColumnsDescription<true>::parse(zookeeper->get(zookeeper_path + \"/columns\", &stat));"
        },
        {
          "line": 2396,
          "api": "k = lockStructure(true);\n\n\tconst DayNum_t month = MergeTreeData::getMon",
          "text": "k = lockStructure(true);\n\n\tconst DayNum_t month = MergeTreeData::getMon",
          "line_content": "\t\t\tops.push_back(new zkutil::Op::Remove(quorum_status_path, stat.version));"
        },
        {
          "line": 2397,
          "api": "Num",
          "text": "Num(partition);\n\n\tsize_t removed_parts = 0;\n\tMergeTreeData::DataParts parts ",
          "line_content": "\t\t\tops.push_back(new zkutil::Op::SetData(quorum_last_part_path, part_name, -1));"
        },
        {
          "line": 2398,
          "api": "getDataParts",
          "text": "ta->getDataParts();\n\n\tfo",
          "line_content": "\t\t\tauto code = zookeeper->tryMulti(ops);"
        },
        {
          "line": 355,
          "api": "<< replica_path);\n\n\t/// Создадим пу",
          "text": " << replica_path);\n\n\t/// Создадим пу",
          "line_content": "\tif (columns != data.getColumnsListNonMaterialized() ||"
        },
        {
          "line": 362,
          "api": "zkutil::Op::Create(replica_path, \"\", acl, zkutil::CreateMode:",
          "text": " zkutil::Op::Create(replica_path, \"\", acl, zkutil::CreateMode:",
          "line_content": "\t\t\t data.getColumnsListNonMaterialized().sizeOfDifference(columns) +"
        },
        {
          "line": 363,
          "api": "push_back",
          "text": "tent));\n\tops.push_back(new zkutil::Op::Create(replica_path + \"/h",
          "line_content": "\t\t\t data.materialized_columns.sizeOfDifference(materialized_columns) <= 2))"
        },
        {
          "line": 365,
          "api": "push_back",
          "text": "zkutil::CreateMode::Persistent));\n\tops.push_back(new zkutil::Op::Create(replica_path + \"/log_pointer\", \"\", acl, zk",
          "line_content": "\t\t\tLOG_WARNING(log, \"Table structure in ZooKeeper is a little different from local table structure. Assuming ALTER.\");"
        },
        {
          "line": 2415,
          "api": "eplicated parts inside \" << apply_visitor(FieldVi",
          "text": "eplicated parts inside \" << apply_visitor(FieldVi",
          "line_content": "\t\t\t\tthrow zkutil::KeeperException(code, quorum_status_path);"
        },
        {
          "line": 368,
          "api": "push_back",
          "text": "Mode::Persistent));\n\tops.push_back(new zkutil::Op::Create(replica_path + \"/parts\", \"\", acl, zkutil::CreateMode::Persistent));\n\tops.push_back",
          "line_content": "\t\t\tInterpreterAlterQuery::updateMetadata(database_name, table_name, columns,"
        },
        {
          "line": 370,
          "api": "zkutil::Op::Create(replica_p",
          "text": "zkutil::Op::Create(replica_p",
          "line_content": "\t\t\tdata.setColumnsList(columns);"
        },
        {
          "line": 371,
          "api": "CreateMode::Persistent));\n\n\ttry",
          "text": "CreateMode::Persistent));\n\n\ttry",
          "line_content": "\t\t\tdata.materialized_columns = std::move(materialized_columns);"
        },
        {
          "line": 372,
          "api": ");\n\t}\n\tcatch (const zkut",
          "text": ");\n\t}\n\tcatch (const zkut",
          "line_content": "\t\t\tdata.alias_columns = std::move(alias_columns);"
        },
        {
          "line": 373,
          "api": "if (e.code == ZNODEEXIST",
          "text": "\t\tif (e.code == ZNODEEXIST",
          "line_content": "\t\t\tdata.column_defaults = std::move(column_defaults);"
        },
        {
          "line": 2420,
          "api": "s)\n{\n\tif (unreplicated)",
          "text": "s)\n{\n\tif (unreplicated)",
          "line_content": "\t\t\tauto code = zookeeper->trySet(quorum_status_path, quorum_entry.toString(), stat.version);"
        },
        {
          "line": 377,
          "api": "lica \" + replica_path + \" is already exist.\", ErrorCodes::REPLICA_IS_ALREADY_EXIST);\n\n\t\tthrow;\n\t}\n\n\t/** Нужно изменить данные н",
          "text": "lica \" + replica_path + \" is already exist.\", ErrorCodes::REPLICA_IS_ALREADY_EXIST);\n\n\t\tthrow;\n\t}\n\n\t/** Нужно изменить данные н",
          "line_content": "\t\t\tthrow Exception(\"Table structure in ZooKeeper is too different from local table structure.\","
        },
        {
          "line": 2437,
          "api": "rCodes::NO_ACTIVE_REPLICAS);\n\n\t\tstd::sort(live_re",
          "text": "rCodes::NO_ACTIVE_REPLICAS);\n\n\t\tstd::sort(live_re",
          "line_content": "\t\t\t\tthrow zkutil::KeeperException(code, quorum_status_path);"
        },
        {
          "line": 396,
          "api": "))\n\t{\n\t\tLOG_INFO(log, \"This is the first replica\");\n\t}\n\telse\n\t{\n\t\tLOG_",
          "text": "))\n\t{\n\t\tLOG_INFO(log, \"This is the first replica\");\n\t}\n\telse\n\t{\n\t\tLOG_",
          "line_content": "\tif (zookeeper->tryGet(replica_path + \"/parts/\" + part_name, unused, &stat))"
        },
        {
          "line": 2445,
          "api": "ame)\n\t\t\tthrow",
          "text": "ame)\n\t\t\tthrow ",
          "line_content": "\tauto zookeeper = getZooKeeper();"
        },
        {
          "line": 2447,
          "api": "ption",
          "text": "ption(\"Leader was suddenly changed or logical error.\", ErrorCodes::LEADER",
          "line_content": "\tLOG_DEBUG(log, \"Fetching part \" << part_name << \" from \" << replica_path);"
        },
        {
          "line": 2451,
          "api": "ookeeper_path + \"/r",
          "text": "ookeeper_path + \"/r",
          "line_content": "\t\ttable_lock = lockStructure(true);"
        },
        {
          "line": 405,
          "api": "/** Если эт",
          "text": "\n\t\t/** Если эт",
          "line_content": "\tauto zookeeper = getZooKeeper();"
        },
        {
          "line": 2453,
          "api": "clone",
          "text": " new_query = query->clone();\n\t\tauto & ",
          "line_content": "\tReplicatedMergeTreeAddress address(zookeeper->get(replica_path + \"/host\"));"
        },
        {
          "line": 407,
          "api": "ная реплика еще не до конца создана, подождем.",
          "text": "ная реплика еще не до конца создана, подождем.\n\t\t  ",
          "line_content": "\tLOG_DEBUG(log, \"Creating replica \" << replica_path);"
        },
        {
          "line": 2455,
          "api": "y);\n\n\t\talter.database = leader_address.database;\n\t\talter.table = leader_address.table;\n\n\t\t/// N",
          "text": 