{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/d98f41ba3dafbf6304ce5f1d250629f5a8cb1dd5",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/d98f41ba3dafbf6304ce5f1d250629f5a8cb1dd5/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/d98f41ba3dafbf6304ce5f1d250629f5a8cb1dd5/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/d98f41ba3dafbf6304ce5f1d250629f5a8cb1dd5/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 423,
          "old_api": "eableState;",
          "new_api": "ключам.\n\t  *",
          "old_text": "eableState;\n\t\n",
          "new_text": " ключам.\n\t  * ",
          "old_line_content": null,
          "new_line_content": "\tif (streams.size() > settings.max_threads)",
          "content_same": true
        },
        {
          "line": 424,
          "old_api": "size",
          "new_api": "отать rows_before_limit_at_least (это нормально).\n\t  *",
          "old_text": "полняем параллельную агрегацию\n\tif (streams.size() > 1",
          "new_text": "отать rows_before_limit_at_least (это нормально).\n\t  *",
          "old_line_content": null,
          "new_line_content": "\t\tstreams = narrowBlockInputStreams(streams, settings.max_threads);",
          "content_same": true
        },
        {
          "line": 441,
          "old_api": "regateDescriptions",
          "new_api": "als, separate_tota",
          "old_text": "regateDescriptions",
          "new_text": "als, separate_tota",
          "old_line_content": null,
          "new_line_content": "\t\tQuotaForIntervals & quota = context.getQuota();",
          "content_same": true
        },
        {
          "line": 443,
          "old_api": ");\n\t\n\t/// Фин",
          "new_api": "settings.lim",
          "old_text": ");\n\t\n\t/// Фин",
          "new_text": " settings.lim",
          "old_line_content": null,
          "new_line_content": "\t\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.end(); ++it)",
          "content_same": true
        },
        {
          "line": 445,
          "old_api": "слений на готовые значения\n\tBlockInputStreamPtr &",
          "new_api": "gBlockInputStream",
          "old_text": "слений на готовые значения\n\tBlockInputStreamPtr &",
          "new_text": "gBlockInputStream(\n\t\t\t\t\tnew UnionBlockInputStream",
          "old_line_content": null,
          "new_line_content": "\t\t\tif (IProfilingBlockInputStream * stream = dynamic_cast<IProfilingBlockInputStream *>(&**it))",
          "content_same": true
        },
        {
          "line": 447,
          "old_api": "treams[0];\n\tstream = mayb",
          "new_api": "ettings.max_threads), key",
          "old_text": "treams[0];\n\tstream = mayb",
          "new_text": "ettings.max_threads), key",
          "old_line_content": null,
          "new_line_content": "\t\t\t\tstream->setLimits(limits);",
          "content_same": true
        },
        {
          "line": 448,
          "old_api": "hronous",
          "new_api": ", aggregates, settings.max_threads)),\n\t\t\tsettings.asynchronous)",
          "old_text": "hronous(new FinalizingAggregatedBlockInputStream(stream, aggreg",
          "new_text": ", aggregates, settings.max_threads)),\n\t\t\tsettings.asynchronous)",
          "old_line_content": null,
          "new_line_content": "\t\t\t\tstream->setQuota(quota, IProfilingBlockInputStream::QUOTA_READ);",
          "content_same": true
        },
        {
          "line": 459,
          "old_api": "Склеим нескол",
          "new_api": "imits.max_rows",
          "old_text": " Склеим нескол",
          "new_text": "imits.max_rows",
          "old_line_content": null,
          "new_line_content": "\tbool is_async = settings.asynchronous && streams.size() <= settings.max_threads;",
          "content_same": true
        },
        {
          "line": 460,
          "old_api": "ads);\n\tstream",
          "new_api": "InterpreterSe",
          "old_text": "ads);\n\tstream",
          "new_text": "InterpreterSe",
          "old_line_content": null,
          "new_line_content": "\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.end(); ++it)",
          "content_same": true
        },
        {
          "line": 463,
          "old_api": "singStage::WithMergeableState;\n\n\t/// Теперь объединим агрегированные блоки\n\tNam",
          "new_api": "eams)\n{\n\tNames key_names;\n\tAggregateDescriptions aggregates;\n\tquery_analyzer->g",
          "old_text": "singStage::WithMergeableState;\n\n\t/// Теперь объединим агрегированные блоки\n\tNam",
          "new_text": "eams)\n{\n\tNames key_names;\n\tAggregateDescriptions aggregates;\n\tquery_analyzer->g",
          "old_line_content": null,
          "new_line_content": "\t\tstream = maybeAsynchronous(new ExpressionBlockInputStream(stream, expression), is_async);",
          "content_same": true
        },
        {
          "line": 464,
          "old_api": "getAggregateInfo",
          "new_api": "тные функции - заменяем их состояния вы",
          "old_text": "getAggregateInfo(key_names, aggregates)",
          "new_text": "тные функции - заменяем их состояния вы",
          "old_line_content": null,
          "new_line_content": "\t\tstream = maybeAsynchronous(new FilterBlockInputStream(stream, query.where_expression->getColumnName()), is_async);",
          "content_same": true
        },
        {
          "line": 471,
          "old_api": ";\n}\n\n\nvoid Int",
          "new_api": "nchronous);\n}",
          "old_text": ";\n}\n\n\nvoid Int",
          "new_text": "nchronous);\n}\n",
          "old_line_content": null,
          "new_line_content": "\tbool is_async = settings.asynchronous && streams.size() <= settings.max_threads;",
          "content_same": true
        },
        {
          "line": 472,
          "old_api": "ression)\n{\n\tb",
          "new_api": "/ Если объеди",
          "old_text": "ression)\n{\n\tb",
          "new_text": "/ Если объеди",
          "old_line_content": null,
          "new_line_content": "\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.end(); ++it)",
          "content_same": true
        },
        {
          "line": 475,
          "old_api": "begin",
          "new_api": "несколько источников в один\n\tstreams[0] = new UnionBlockInputStream(streams, s",
          "old_text": "ttings.max_threads;\n\tfor (BlockInputStreams::iterator it = streams.begin(); it ",
          "new_text": " несколько источников в один\n\tstreams[0] = new UnionBlockInputStream(streams, s",
          "old_line_content": null,
          "new_line_content": "\t\tstream = maybeAsynchronous(new ExpressionBlockInputStream(stream, expression), is_async);",
          "content_same": true
        },
        {
          "line": 482,
          "old_api": "ionBlockInputStream",
          "new_api": "ergeableState;\n\n\t/// Теперь объединим агрегированные бл",
          "old_text": "ionBlockInputStream(stream, expression), is_async);\n\t\ts",
          "new_text": "ergeableState;\n\n\t/// Теперь объединим агрегированные бл",
          "old_line_content": null,
          "new_line_content": "\tquery_analyzer->getAggregateInfo(key_names, aggregates);",
          "content_same": true
        },
        {
          "line": 491,
          "old_api": "begin",
          "new_api": "d",
          "old_text": "streams.begin(); it != streams.end(); ++it)\n\t{\n\t\tBlockInputStreamPtr & stream = *it;\n\t\tstream = maybeAsynchronous(new ExpressionBlockInputStream(stream, expression), is_async);\n\t}\n}\n\n\nvoid InterpreterSelectQuery::executeOrder(BlockInputStreams & streams)\n{\n\tSor",
          "new_text": "d(); ++it)\n\t{\n\t\tBlockInputStreamPtr & stream = *it;\n\t\tstre",
          "old_line_content": "\t\tstream = maybeAsynchronous(new ParallelAggregatingBlockInputStream(streams, key_names, aggregates, query.group_by_with_totals, separate_totals,",
          "new_line_content": "\tgetLimitLengthAndOffset(query, limit_length, limit_offset);",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "{\n\t\tsize_t lim",
          "new_api": "lockInputStreams",
          "old_text": "{\n\t\tsize_t lim",
          "new_text": "lockInputStreams ",
          "old_line_content": "\tbool is_async = settings.asynchronous && streams.size() <= settings.max_threads;",
          "new_line_content": "\tstreams.resize(1);",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": "ом источнике, если источников несколько, до",
          "new_api": "(stream, setti",
          "old_text": "ом источнике, если источников несколько, до",
          "new_text": "(stream, setti",
          "old_line_content": "\t\tit != query.order_expression_list->children.end();",
          "new_line_content": "\tbool is_async = settings.asynchronous && streams.size() <= settings.max_threads;",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "e_t limit_offset = 0;\n\tgetLimitLengthAn",
          "new_api": "size",
          "old_text": "e_t limit_offset = 0;\n\tgetLimitLengthAn",
          "new_text": "ко потоков, то объединяем их в один\n\tif (streams.size() > 1)\n\t{\n\t\tstreams[0] = ",
          "old_line_content": "\t\torder_descr.push_back(SortColumnDescription(name, dynamic_cast<ASTOrderByElement &>(**it).direction));",
          "new_line_content": "\t\tstream = maybeAsynchronous(new ExpressionBlockInputStream(stream, expression), is_async);",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "InterpreterSe",
          "new_api": "erSelectQuery::executePreLimit(BlockInputStre",
          "old_text": " InterpreterSe",
          "new_text": "erSelectQuery::executePreLimit(BlockInputStre",
          "old_line_content": "\tbool is_async = settings.asynchronous && streams.size() <= settings.max_threads;",
          "new_line_content": "\tfor (ASTs::iterator it = query.order_expression_list->children.begin();",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": "limit_offset",
          "new_api": "ams)\n{\n\tsize_t limit_length = 0;\n\tsize_t li",
          "old_text": " limit_offset",
          "new_text": "ams)\n{\n\tsize_t limit_length = 0;\n\tsize_t li",
          "old_line_content": "\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.end(); ++it)",
          "new_line_content": "\t\tit != query.order_expression_list->children.end();",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "faultFormat",
          "new_api": "0);\n\t\t}\n\t}\n}\n\n\nvoid InterpreterSelectQuery::executeLimit(B",
          "old_text": "faultFormat();\n\n\tBlockInputStream",
          "new_text": "0);\n\t\t}\n\t}\n}\n\n\nvoid InterpreterSelectQuery::executeLimit(B",
          "old_line_content": "\t\tsorting_stream->setLimits(limits);",
          "new_line_content": "\tgetLimitLengthAndOffset(query, limit_length, limit_offset);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 645,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t}",
          "new_line_content": "\t\tgetLimitLengthAndOffset(query, limit_length, limit_offset);",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "ize() <= settings.max_threads;\n\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.end(); ++it)\n\t{\n\t\tBlockInputStreamPtr & stream = *it;\n\t\tIProfilingBlockInputStream * sorting_stream = new PartialSortingBlockInpu",
          "old_line_content": "}",
          "new_line_content": "\t\tstream = maybeAsynchronous(new AggregatingBlockInputStream(stream, key_names, aggregates, query.group_by_with_totals, separate_totals,",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t{",
          "new_line_content": "\t\tbool is_async = settings.asynchronous && streams.size() <= settings.max_threads;",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tstreams[0] = new UnionBlockInputStream(streams, settings.max_threads);",
          "new_line_content": "\t\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.end(); ++it)",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": null,
          "new_api": "= settings.limits.max_rows_to_sort;\n\t\tlimits.max_bytes_",
          "old_text": null,
          "new_text": "= settings.limits.max_rows_to_sort;\n\t\tlimits.max_bytes_",
          "old_line_content": "\t/// Склеим несколько источников в один",
          "new_line_content": "\tquery_analyzer->getAggregateInfo(key_names, aggregates);",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "}",
          "new_line_content": "\t\t\tstream = maybeAsynchronous(new DistinctBlockInputStream(stream, settings.limits, limit_for_distinct), is_async);",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": null,
          "new_api": "reamPtr & stream = streams[0];\n\n\t/// Если потоков несколько, то объединяем их в один\n\tif (streams.size",
          "old_text": null,
          "new_text": "reamPtr & stream = streams[0];\n\n\t/// Если потоков несколько, то объединяем их в один\n\tif (streams.size",
          "old_line_content": "\tbool separate_totals = to_stage > QueryProcessingStage::WithMergeableState;",
          "new_line_content": "\tstream = maybeAsynchronous(new FinalizingAggregatedBlockInputStream(stream, aggregates), settings.asynchronous);",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tif (streams.size() > 1)",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": null,
          "new_api": ": таймаут на с",
          "old_text": null,
          "new_text": ": таймаут на с",
          "old_line_content": "}",
          "new_line_content": "\tif (streams.size() == 1)",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t{",
          "new_line_content": "\t\tstreams.resize(1);",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "void InterpreterSelectQuery::executeLimit(BlockInputStreams & streams)",
          "new_line_content": "\tgetLimitLengthAndOffset(query, limit_length, limit_offset);",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": null,
          "new_api": "{\n\t\tBlockInputStreamPtr & stream = *it;\n\t\tstream = mayb",
          "old_text": null,
          "new_text": "{\n\t\tBlockInputStreamPtr & stream = *it;\n\t\tstream = mayb",
          "old_line_content": "}",
          "new_line_content": "\tquery_analyzer->getAggregateInfo(key_names, aggregates);",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": null,
          "new_api": "w ExpressionBlockInputStream(stream, expression), is_async);\n\t}\n}\n\n\nvoid InterpreterSelectQuery::executeDistinct(BlockInputStreams & streams, bool before_order",
          "old_text": null,
          "new_text": "w ExpressionBlockInputStream(stream, expression), is_async);\n\t}\n}\n\n\nvoid InterpreterSelectQuery::executeDistinct(BlockInputStreams & streams, bool before_order",
          "old_line_content": "",
          "new_line_content": "\tstreams[0] = maybeAsynchronous(new MergingAggregatedBlockInputStream(streams[0], key_names, aggregates, query.group_by_with_totals, separate_totals), settings.asynchronous);",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.end(); ++it)",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": null,
          "new_api": "imit_for_disti",
          "old_text": null,
          "new_text": "imit_for_disti",
          "old_line_content": "\t{",
          "new_line_content": "\tbool is_async = settings.asynchronous && streams.size() <= settings.max_threads;",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": null,
          "new_api": "достать не бо",
          "old_text": null,
          "new_text": "достать не бо",
          "old_line_content": "\t\tBlockInputStreamPtr & stream = *it;",
          "new_line_content": "\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.end(); ++it)",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": null,
          "new_api": "y.order_expression_list || !before_order)\n\t\t\tlimit_for_distinct = limit_length",
          "old_text": null,
          "new_text": "y.order_expression_list || !before_order)\n\t\t\tlimit_for_distinct = limit_length ",
          "old_line_content": "}",
          "new_line_content": "\t\tstream = maybeAsynchronous(new ExpressionBlockInputStream(stream, expression), is_async);",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "s.size() <= settings.max_threads;\n\t\tfor ",
          "old_line_content": "",
          "new_line_content": "\t\tstream = maybeAsynchronous(new FilterBlockInputStream(stream, query.having_expression->getColumnName()), is_async);",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "uteUnion",
          "old_text": null,
          "new_text": "uteUnion(Bloc",
          "old_line_content": "\t\t++it)",
          "new_line_content": "\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.end(); ++it)",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tBlock sample = getSampleBlock();",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": null,
          "new_api": "м источнике, если источников несколько, до и",
          "old_text": null,
          "new_text": "м источнике, если источников несколько, до и",
          "old_line_content": "",
          "new_line_content": "\torder_descr.reserve(query.order_expression_list->children.size());",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tString format_name = query.format ? dynamic_cast<ASTIdentifier &>(*query.format).name : context.getDefaultFormat();",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tBlockInputStreamPtr in = execute();",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tBlockOutputStreamPtr out = context.getFormatFactory().getOutput(format_name, buf, sample);",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": null,
          "new_api": "hAndOffset",
          "old_text": null,
          "new_text": "hAndOffset(query, limit_length, limit_o",
          "old_line_content": "\t\tIProfilingBlockInputStream * sorting_stream = new PartialSortingBlockInputStream(stream, order_descr, limit);",
          "new_line_content": "\t\tString name = (*it)->children.front()->getColumnName();",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": null,
          "new_api": "{\n\t\tfor (BlockInputStreams::iterator",
          "old_text": null,
          "new_text": "\n\t{\n\t\tfor (BlockInputStreams::iterator ",
          "old_line_content": "",
          "new_line_content": "\t\torder_descr.push_back(SortColumnDescription(name, dynamic_cast<ASTOrderByElement &>(**it).direction));",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tcopyData(*in, *out);",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": null,
          "new_api": "tLengthAndOffs",
          "old_text": null,
          "new_text": "tLengthAndOffs",
          "old_line_content": "\t}",
          "new_line_content": "\tbool is_async = settings.asynchronous && streams.size() <= settings.max_threads;",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": null,
          "new_api": "BlockInput",
          "old_text": null,
          "new_text": "\n\t\tBlockInput",
          "old_line_content": "",
          "new_line_content": "\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.end(); ++it)",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": null,
          "new_api": ", buf, sample);\n\n\tcopyData(*in, *",
          "old_text": null,
          "new_text": ", buf, sample);\n\n\tcopyData(*in, *",
          "old_line_content": "\t/// Сливаем сортированные блоки TODO: таймаут на слияние.",
          "new_line_content": "\t\tsorting_stream->setLimits(limits);",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": null,
          "new_api": ";\n}\n\n\n}",
          "old_text": null,
          "new_text": ";\n}\n\n\n}\n",
          "old_line_content": "}",
          "new_line_content": "\t\tstream = maybeAsynchronous(sorting_stream, is_async);",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\tstream = maybeAsynchronous(new MergeSortingBlockInputStream(stream, order_descr, limit), is_async);",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "\t\tsize_t limit_offset = 0;",
          "new_line_content": "\tbool is_async = settings.asynchronous && streams.size() <= settings.max_threads;",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": null,
          "new_api": "maybeAsynchro",
          "old_text": null,
          "new_text": " maybeAsynchro",
          "old_line_content": "\t\tstreams.resize(1);*/",
          "new_line_content": "\tif (streams.size() > 1)",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "lockInputStream(stream, expression), is_async);\n\t}\n}\n\n\nvoid InterpreterSelectQuery::executeOrder(BlockInputStreams & streams)\n{\n\tSortDescription order_descr;\n\torder_descr.reserve(query.order_expression_list->children.size());\n\tfor (ASTs::iterator it = query.ord",
          "old_line_content": "\telse",
          "new_line_content": "\t\tstream = maybeAsynchronous(new ParallelAggregatingBlockInputStream(streams, key_names, aggregates, query.group_by_with_totals, separate_totals,",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "\t\tstream = maybeAsynchronous(new ExpressionBlockInputStream(stream, expression), is_async);",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": null,
          "new_api": "xpression_list->c",
          "old_text": null,
          "new_text": "xpression_list->c",
          "old_line_content": "\t\t\tsettings.limits.max_rows_to_group_by, settings.limits.group_by_overflow_mode), settings.asynchronous);",
          "new_line_content": "\t\tstreams.resize(1);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 640,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.end(); ++it)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 515,
          "old_api": "rder_descr, limit);\n\n\t\t/// Ограничения на сортировку",
          "new_api": null,
          "old_text": "rder_descr, limit);\n\n\t\t/// Ограничения на сортировку\n\t\t",
          "new_text": null,
          "old_line_content": "\tquery_analyzer->getAggregateInfo(key_names, aggregates);",
          "new_line_content": "\t\t\tsettings.asynchronous);",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\t\tstream = maybeAsynchronous(new DistinctBlockInputStream(stream, settings.limits, limit_for_distinct), is_async);",
          "new_line_content": "\t\tsize_t limit_length = 0;",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": "setLimits",
          "new_api": null,
          "old_text": "overflow_mode;\n\t\tsorting_stream->setLimits(limits);\n\t\t\t\n\t\tstream = maybeAsynchronous(sorting_stream, i",
          "new_text": null,
          "old_line_content": "\tstream = maybeAsynchronous(new FinalizingAggregatedBlockInputStream(stream, aggregates), settings.asynchronous);",
          "new_line_content": "\telse",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tif (streams.size() > 1)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": "stream = new U",
          "new_api": null,
          "old_text": "stream = new U",
          "new_text": null,
          "old_line_content": "\tif (streams.size() == 1)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tstreams.resize(1);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "ous",
          "new_api": null,
          "old_text": "ous(new MergeSort",
          "new_text": null,
          "old_line_content": "\tstreams.resize(1);",
          "new_line_content": "\t/// Финализируем агрегатные функции - заменяем их состояния вычислений на готовые значения",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tgetLimitLengthAndOffset(query, limit_length, limit_offset);",
          "new_line_content": "\t/// Если до сих пор есть несколько потоков, то объединяем их в один",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "size",
          "new_api": null,
          "old_text": "s && streams.size() <= settings.max_threads;\n\tfor (Bloc",
          "new_text": null,
          "old_line_content": "\tquery_analyzer->getAggregateInfo(key_names, aggregates);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "begin",
          "new_api": null,
          "old_text": "terator it = streams.begin(); it != streams.end(); ++it)\n\t{\n\t\tBlockInputStreamPtr & stream = *it;\n\t\tstream = maybeAsynchronous(new ExpressionBlockInputStream(s",
          "new_text": null,
          "old_line_content": "\tstreams[0] = maybeAsynchronous(new MergingAggregatedBlockInputStream(streams[0], key_names, aggregates, query.group_by_with_totals, separate_totals), settings.asynchronous);",
          "new_line_content": "\t/// Если объединять нечего",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.end(); ++it)",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": "limit_offset",
          "new_api": null,
          "old_text": " limit_offset",
          "new_text": null,
          "old_line_content": "\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.end(); ++it)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": "стадии DISTINCT не будет выполняться ORDER BY, то можно достать не более limit_",
          "new_api": null,
          "old_text": "стадии DISTINCT не будет выполняться ORDER BY, то можно достать не более limit_",
          "new_text": null,
          "old_line_content": "\t\tstream = maybeAsynchronous(new ExpressionBlockInputStream(stream, expression), is_async);",
          "new_line_content": "\t/// Теперь объединим агрегированные блоки",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": "on_list || !before_order)\n\t\t\tlimit_for_d",
          "new_api": null,
          "old_text": "on_list || !before_order)\n\t\t\tlimit_for_d",
          "new_text": null,
          "old_line_content": "\t\tstream = maybeAsynchronous(new FilterBlockInputStream(stream, query.having_expression->getColumnName()), is_async);",
          "new_line_content": "\tNames key_names;",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tgetLimitLengthAndOffset(query, limit_length, limit_offset);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": "it != streams",
          "new_api": null,
          "old_text": " it != streams",
          "new_text": null,
          "old_line_content": "\tbool is_async = settings.asynchronous && streams.size() <= settings.max_threads;",
          "new_line_content": "void InterpreterSelectQuery::executeHaving(BlockInputStreams & streams, ExpressionActionsPtr expression)",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": "ew DistinctBl",
          "new_api": null,
          "old_text": "ew DistinctBl",
          "new_text": null,
          "old_line_content": "\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.end(); ++it)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": "is_async);\n\t\t}\n\t}\n}\n\n\nvoid InterpreterSelectQuery::executeUnion(BlockInputStre",
          "new_api": null,
          "old_text": " is_async);\n\t\t}\n\t}\n}\n\n\nvoid InterpreterSelectQuery::executeUnion(BlockInputStre",
          "new_text": null,
          "old_line_content": "\t\tstream = maybeAsynchronous(new ExpressionBlockInputStream(stream, expression), is_async);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tBlock sample = getSampleBlock();",
          "new_line_content": "\tsize_t limit_offset = 0;",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": "UnionBlockInputStream",
          "new_api": null,
          "old_text": "UnionBlockInputStream(streams, settings.max_",
          "new_text": null,
          "old_line_content": "\torder_descr.reserve(query.order_expression_list->children.size());",
          "new_line_content": "void InterpreterSelectQuery::executeOuterExpression(BlockInputStreams & streams, ExpressionActionsPtr expression)",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": ";\n\t}\n}\n\n\n/// Предварительный LIMIT - применяе",
          "new_api": null,
          "old_text": ";\n\t}\n}\n\n\n/// Предварительный LIMIT - применяе",
          "new_text": null,
          "old_line_content": "\tfor (ASTs::iterator it = query.order_expression_list->children.begin();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tBlockInputStreamPtr in = execute();",
          "new_line_content": "\t/// Если есть LIMIT",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tBlockOutputStreamPtr out = context.getFormatFactory().getOutput(format_name, buf, sample);",
          "new_line_content": "\tif (query.limit_length)",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": "terSelectQuery::executePreLimit(BlockIn",
          "new_api": null,
          "old_text": "terSelectQuery::executePreLimit(BlockIn",
          "new_text": null,
          "old_line_content": "\t\tString name = (*it)->children.front()->getColumnName();",
          "new_line_content": "\t\tBlockInputStreamPtr & stream = *it;",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tcopyData(*in, *out);",
          "new_line_content": "\t\tBlockInputStreamPtr & stream = streams[0];",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": "d",
          "new_api": null,
          "old_text": "d(); ++it)\n\t\t{\n\t\t\tBlockInputStreamPtr & stream = *it;\n\t\t\ts",
          "new_text": null,
          "old_line_content": "\tgetLimitLengthAndOffset(query, limit_length, limit_offset);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": ");\n\tBlockOutputStreamPtr out = context.getF",
          "new_api": null,
          "old_text": ");\n\tBlockOutputStreamPtr out = context.getF",
          "new_text": null,
          "old_line_content": "\t\tstream = maybeAsynchronous(sorting_stream, is_async);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tif (streams.size() > 1)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tstreams.resize(1);",
          "new_line_content": "\t\tlimits.max_rows_to_read = settings.limits.max_rows_to_sort;",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tstream = maybeAsynchronous(new MergeSortingBlockInputStream(stream, order_descr, limit), is_async);",
          "new_line_content": "\t\t\t",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\tbool is_async = settings.asynchronous && streams.size() <= settings.max_threads;",
          "new_line_content": "\t/// Если потоков несколько, то объединяем их в один",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": "(BlockInputStr",
          "new_api": null,
          "old_text": "(BlockInputStr",
          "new_text": null,
          "old_line_content": "\tif (streams.size() > 1)",
          "new_line_content": "\tsize_t limit_length = 0;",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": "cription order_de",
          "new_api": null,
          "old_text": "cription order_de",
          "new_text": null,
          "old_line_content": "\t\tstreams.resize(1);",
          "new_line_content": "\tif (query.limit_length && !query.having_expression && !query.order_expression_list",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "size",
          "new_api": null,
          "old_text": "y, limit_length, limit_offset);\n\tsize_t limit = limit_length + limit_offset;\n\n\tbool is_async = settings.asynchronous && streams.size() <= settings.max_threads;\n\tfor (BlockInputStreams::iterator it = streams.begin(); it != streams.",
          "new_text": null,
          "old_line_content": "\t\tstream = maybeAsynchronous(new AggregatingBlockInputStream(stream, key_names, aggregates, query.group_by_with_totals, separate_totals,",
          "new_line_content": "\t\t\tsettings.max_threads, settings.limits.max_rows_to_group_by, settings.limits.group_by_overflow_mode), settings.asynchronous);",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "\t\tbool is_async = settings.asynchronous && streams.size() <= settings.max_threads;",
          "new_line_content": "void InterpreterSelectQuery::executeDistinct(BlockInputStreams & streams, bool before_order)",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 22,
      "total_additions": 37,
      "total_deletions": 36,
      "total_api_changes": 95
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 15,
        "api_related_lines": 95,
        "non_api_lines": 12,
        "non_api_line_numbers": [
          484,
          485,
          486,
          487,
          488,
          490,
          492,
          494,
          495,
          496,
          497,
          498
        ]
      }
    },
    "api_calls_before": 203,
    "api_calls_after": 204,
    "diff_info": {
      "added_lines": 15,
      "removed_lines": 1,
      "total_diff_lines": 28
    }
  }
}