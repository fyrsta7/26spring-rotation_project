{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/8ab4f8c9cfaa6665967ccd6c26cb216a35c2943f",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/8ab4f8c9cfaa6665967ccd6c26cb216a35c2943f/before.h",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/8ab4f8c9cfaa6665967ccd6c26cb216a35c2943f/after.h",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ClickHouse/modified_file/8ab4f8c9cfaa6665967ccd6c26cb216a35c2943f/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1176,
          "old_api": "getOffsets",
          "new_api": "hasEqualOffsets",
          "old_text": "left_array_col->getOffsets()",
          "new_text": "left_array_col->hasEqualOffsets(*right_array_col)",
          "old_line_content": "        const auto & left_offsets = left_array_col->getOffsets();",
          "new_line_content": "        if (!left_array_col->hasEqualOffsets(*right_array_col))",
          "content_same": false
        },
        {
          "line": 1177,
          "old_api": "getOffsets",
          "new_api": "getName",
          "old_text": "right_array_col->getOffsets()",
          "new_text": "getName()",
          "old_line_content": "        const auto & right_offsets = right_array_col->getOffsets();",
          "new_line_content": "            throw Exception(ErrorCodes::SIZES_OF_ARRAYS_DONT_MATCH, \"Two arguments for function {} must have equal sizes\", getName());",
          "content_same": false
        },
        {
          "line": 1179,
          "old_api": "size",
          "new_api": "get",
          "old_text": "right_offsets.size()",
          "new_text": "arguments[0].type.get()",
          "old_line_content": "        chassert(left_offsets.size() == right_offsets.size() && \"Unexpected difference in number of offsets\");",
          "new_line_content": "        const auto & left_array_type = typeid_cast<const DataTypeArray *>(arguments[0].type.get())->getNestedType();",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": "hasEqualOffsets",
          "new_api": "getDataPtr",
          "old_text": "right_array_col->hasEqualOffsets(*left_array_col)",
          "new_text": "right_array_col->getDataPtr()",
          "old_line_content": "            if (right_array_col->hasEqualOffsets(*left_array_col))",
          "new_line_content": "        new_arguments[1] = {right_array_col->getDataPtr(), right_array_type, arguments[1].name};",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": "data",
          "new_api": "get",
          "old_text": "Exception(ErrorCodes::SIZES_OF_ARRAYS_DONT_MATCH,\n                \"Cannot apply operation for arrays of different sizes. Size of the first argument: {}, size of the second argument: {}\",\n                *left_array_col->getOffsets().data(),\n                *right_array_col ->getOffsets().data())",
          "new_text": "result_type.get()",
          "old_line_content": "                throw Exception(ErrorCodes::SIZES_OF_ARRAYS_DONT_MATCH,",
          "new_line_content": "        result_array_type = typeid_cast<const DataTypeArray *>(result_type.get())->getNestedType();",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": "data",
          "new_api": "getOffsets",
          "old_text": "right_array_col ->getOffsets().data()",
          "new_text": "left_array_col->getOffsets()",
          "old_line_content": "                *right_array_col ->getOffsets().data());",
          "new_line_content": "        const auto & left_offsets = left_array_col->getOffsets();",
          "content_same": false
        },
        {
          "line": 1193,
          "old_api": "getDataPtr",
          "new_api": "get",
          "old_text": "left_array_col->getDataPtr()",
          "new_text": "arguments[0].column.get()",
          "old_line_content": "        new_arguments[0] = {left_array_col->getDataPtr(), left_array_type, arguments[0].name};",
          "new_line_content": "        return ColumnArray::create(res, typeid_cast<const ColumnArray *>(arguments[0].column.get())->getOffsetsPtr());",
          "content_same": false
        },
        {
          "line": 1202,
          "old_api": "back",
          "new_api": "isNumber",
          "old_text": "left_offsets.back()",
          "new_text": "isNumber(arguments[0].type)",
          "old_line_content": "            rows_count = left_offsets.back();",
          "new_line_content": "        if (isNumber(arguments[0].type))",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": "executeImpl",
          "new_api": "std::swap(new_arguments[0], new_arguments[1])",
          "old_text": "executeImpl(new_arguments, result_array_type, rows_count)",
          "new_text": "std::swap(new_arguments[0], new_arguments[1])",
          "old_line_content": "        auto res = executeImpl(new_arguments, result_array_type, rows_count);",
          "new_line_content": "            std::swap(new_arguments[0], new_arguments[1]);",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": "get",
          "new_api": "build",
          "old_text": "arguments[0].column.get()",
          "new_text": "function_builder->build(new_arguments)",
          "old_line_content": "        return ColumnArray::create(res, typeid_cast<const ColumnArray *>(arguments[0].column.get())->getOffsetsPtr());",
          "new_line_content": "        auto function = function_builder->build(new_arguments);",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": "build",
          "new_api": "getScale",
          "old_text": "function_builder->build(new_arguments)",
          "new_text": "col.getScale()",
          "old_line_content": "        auto function = function_builder->build(new_arguments);",
          "new_line_content": "            return DecimalUtils::convertTo<NativeResultType>(col_const->template getValue<T>(), col.getScale());",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": "execute",
          "new_api": "col_const->template getValue<T>()",
          "old_text": "function->execute(new_arguments, result_type, input_rows_count)",
          "new_text": "col_const->template getValue<T>()",
          "old_line_content": "        return function->execute(new_arguments, result_type, input_rows_count);",
          "new_line_content": "            return col_const->template getValue<T>().value;",
          "content_same": false
        },
        {
          "line": 1286,
          "old_api": "scaleFactorFor",
          "new_api": "helperGetOrConvert<T0, ResultDataType>(col_left_const, left)",
          "old_text": "[&]\n        {\n                if constexpr (is_multiply)\n                    return ResultType{1};\n                else\n                    return type.scaleFactorFor(right, is_division);\n        }()",
          "new_text": "helperGetOrConvert<T0, ResultDataType>(col_left_const, left)",
          "old_line_content": "        const ResultType scale_b = [&]",
          "new_line_content": "                helperGetOrConvert<T0, ResultDataType>(col_left_const, left));",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": "static_cast<NativeResultType>(\n                helperGetOrConvert<T0, ResultDataType>(col_left_const, left))",
          "new_api": "getScale",
          "old_text": "static_cast<NativeResultType>(\n                helperGetOrConvert<T0, ResultDataType>(col_left_const, left))",
          "new_text": "type.getScale()",
          "old_line_content": "            const NativeResultType const_a = static_cast<NativeResultType>(",
          "new_line_content": "                .createColumnConst(col_left_const->size(), toField(res, type.getScale()));",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": "helperGetOrConvert<T1, ResultDataType>(col_right_const, right)",
          "new_api": "getScale",
          "old_text": "helperGetOrConvert<T1, ResultDataType>(col_right_const, right)",
          "new_text": "type.getScale()",
          "old_line_content": "                helperGetOrConvert<T1, ResultDataType>(col_right_const, right));",
          "new_line_content": "        col_res = ColVecResult::create(0, type.getScale());",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": "getScale",
          "new_api": "getData",
          "old_text": "type.getScale()",
          "new_text": "col_right->getData()",
          "old_line_content": "            return ResultDataType(type.getPrecision(), type.getScale())",
          "new_line_content": "                col_left->getData(), col_right->getData(), vec_res, scale_a, scale_b, right_nullmap);",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": "getScale",
          "new_api": "static_cast<NativeResultType>(\n                helperGetOrConvert<T0, ResultDataType>(col_left_const, left))",
          "old_text": "type.getScale()",
          "new_text": "static_cast<NativeResultType>(\n                helperGetOrConvert<T0, ResultDataType>(col_left_const, left))",
          "old_line_content": "        col_res = ColVecResult::create(0, type.getScale());",
          "new_line_content": "            const NativeResultType const_a = static_cast<NativeResultType>(",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": "resize",
          "new_api": "getData",
          "old_text": "vec_res.resize(col_left_size)",
          "new_text": "helperInvokeEither<OpCase::LeftConstant, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(\n                const_a, col_right->getData(), vec_res, scale_a, scale_b, right_nullmap)",
          "old_line_content": "        vec_res.resize(col_left_size);",
          "new_line_content": "            helperInvokeEither<OpCase::LeftConstant, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": "getData",
          "new_api": "static_cast<NativeResultType>(\n                helperGetOrConvert<T1, ResultDataType>(col_right_const, right))",
          "old_text": "col_right->getData()",
          "new_text": "static_cast<NativeResultType>(\n                helperGetOrConvert<T1, ResultDataType>(col_right_const, right))",
          "old_line_content": "                col_left->getData(), col_right->getData(), vec_res, scale_a, scale_b, right_nullmap);",
          "new_line_content": "            const NativeResultType const_b = static_cast<NativeResultType>(",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": "static_cast<NativeResultType>(\n                helperGetOrConvert<T0, ResultDataType>(col_left_const, left))",
          "new_api": "getData",
          "old_text": "static_cast<NativeResultType>(\n                helperGetOrConvert<T0, ResultDataType>(col_left_const, left))",
          "new_text": "col_left->getData()",
          "old_line_content": "            const NativeResultType const_a = static_cast<NativeResultType>(",
          "new_line_content": "                col_left->getData(), const_b, vec_res, scale_a, scale_b, right_nullmap);",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": "helperGetOrConvert<T1, ResultDataType>(col_right_const, right)",
          "new_api": "constexpr",
          "old_text": "helperGetOrConvert<T1, ResultDataType>(col_right_const, right)",
          "new_text": "constexpr",
          "old_line_content": "                helperGetOrConvert<T1, ResultDataType>(col_right_const, right));",
          "new_line_content": "    static constexpr auto name = Name::name;",
          "content_same": false
        },
        {
          "line": 1336,
          "old_api": "getData",
          "new_api": "explicit",
          "old_text": "col_left->getData()",
          "new_text": "explicit",
          "old_line_content": "                col_left->getData(), const_b, vec_res, scale_a, scale_b, right_nullmap);",
          "new_line_content": "    explicit FunctionBinaryArithmetic(ContextPtr context_)",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": "equals",
          "new_api": "std::make_shared<DataTypeUInt32>()",
          "old_text": "arguments[0]->equals(*arguments[1])",
          "new_text": "std::make_shared<DataTypeUInt32>()",
          "old_line_content": "            if (!arguments[0]->equals(*arguments[1]))",
          "new_line_content": "                    isIPv4(arguments[0]) ? std::make_shared<DataTypeUInt32>() : arguments[0],",
          "content_same": false
        },
        {
          "line": 1391,
          "old_api": "getName",
          "new_api": "std::make_shared<DataTypeUInt32>()",
          "old_text": "Exception(ErrorCodes::CANNOT_ADD_DIFFERENT_AGGREGATE_STATES,\n                    \"Cannot add aggregate states of different functions: {} and {}\",\n                    arguments[0]->getName(), arguments[1]->getName())",
          "new_text": "std::make_shared<DataTypeUInt32>()",
          "old_line_content": "                throw Exception(ErrorCodes::CANNOT_ADD_DIFFERENT_AGGREGATE_STATES,",
          "new_line_content": "                    isIPv4(arguments[1]) ? std::make_shared<DataTypeUInt32>() : arguments[1],",
          "content_same": false
        },
        {
          "line": 1403,
          "old_api": "std::make_shared<DataTypeUInt32>()",
          "new_api": "getNestedType",
          "old_text": "std::make_shared<DataTypeUInt32>()",
          "new_text": "static_cast<const DataTypeArray &>(*arguments[0]).getNestedType()",
          "old_line_content": "                    isIPv4(arguments[1]) ? std::make_shared<DataTypeUInt32>() : arguments[1],",
          "new_line_content": "                        static_cast<const DataTypeArray &>(*arguments[0]).getNestedType(),",
          "content_same": false
        },
        {
          "line": 1412,
          "old_api": "isArray",
          "new_api": "getFunctionForIntervalArithmetic",
          "old_text": "isArray(arguments[1])",
          "new_text": "getFunctionForIntervalArithmetic(arguments[0], arguments[1], context)",
          "old_line_content": "            if (isArray(arguments[0]) && isArray(arguments[1]))",
          "new_line_content": "        if (auto function_builder = getFunctionForIntervalArithmetic(arguments[0], arguments[1], context))",
          "content_same": false
        },
        {
          "line": 1424,
          "old_api": "getFunctionForIntervalArithmetic",
          "new_api": "std::make_shared<DataTypeNumber<DataTypeInterval::FieldType>>()",
          "old_text": "getFunctionForIntervalArithmetic(arguments[0], arguments[1], context)",
          "new_text": "std::make_shared<DataTypeNumber<DataTypeInterval::FieldType>>()",
          "old_line_content": "        if (auto function_builder = getFunctionForIntervalArithmetic(arguments[0], arguments[1], context))",
          "new_line_content": "            new_arguments[1].type = std::make_shared<DataTypeNumber<DataTypeInterval::FieldType>>();",
          "content_same": false
        },
        {
          "line": 1443,
          "old_api": "getFunctionForTupleArithmetic",
          "new_api": "getFunctionForDateTupleOfIntervalsArithmetic",
          "old_text": "getFunctionForTupleArithmetic(arguments[0], arguments[1], context)",
          "new_text": "getFunctionForDateTupleOfIntervalsArithmetic(arguments[0], arguments[1], context)",
          "old_line_content": "        if (auto function_builder = getFunctionForTupleArithmetic(arguments[0], arguments[1], context))",
          "new_line_content": "        if (auto function_builder = getFunctionForDateTupleOfIntervalsArithmetic(arguments[0], arguments[1], context))",
          "content_same": false
        },
        {
          "line": 1451,
          "old_api": "getResultType",
          "new_api": "isTuple",
          "old_text": "function->getResultType()",
          "new_text": "isTuple(new_arguments[0].type)",
          "old_line_content": "            return function->getResultType();",
          "new_line_content": "            if (isTuple(new_arguments[0].type))",
          "content_same": false
        },
        {
          "line": 1455,
          "old_api": "getFunctionForDateTupleOfIntervalsArithmetic",
          "new_api": "getResultType",
          "old_text": "getFunctionForDateTupleOfIntervalsArithmetic(arguments[0], arguments[1], context)",
          "new_text": "function->getResultType()",
          "old_line_content": "        if (auto function_builder = getFunctionForDateTupleOfIntervalsArithmetic(arguments[0], arguments[1], context))",
          "new_line_content": "            return function->getResultType();",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": "getFunctionForMergeIntervalsArithmetic",
          "new_api": "getFunctionForTupleAndNumberArithmetic",
          "old_text": "getFunctionForMergeIntervalsArithmetic(arguments[0], arguments[1], context)",
          "new_text": "getFunctionForTupleAndNumberArithmetic(arguments[0], arguments[1], context)",
          "old_line_content": "        if (auto function_builder = getFunctionForMergeIntervalsArithmetic(arguments[0], arguments[1], context))",
          "new_line_content": "        if (auto function_builder = getFunctionForTupleAndNumberArithmetic(arguments[0], arguments[1], context))",
          "content_same": false
        },
        {
          "line": 1479,
          "old_api": "getResultType",
          "new_api": "isNumber",
          "old_text": "function->getResultType()",
          "new_text": "isNumber(new_arguments[0].type)",
          "old_line_content": "            return function->getResultType();",
          "new_line_content": "            if (isNumber(new_arguments[0].type))",
          "content_same": false
        },
        {
          "line": 1483,
          "old_api": "getFunctionForTupleAndNumberArithmetic",
          "new_api": "getResultType",
          "old_text": "getFunctionForTupleAndNumberArithmetic(arguments[0], arguments[1], context)",
          "new_text": "function->getResultType()",
          "old_line_content": "        if (auto function_builder = getFunctionForTupleAndNumberArithmetic(arguments[0], arguments[1], context))",
          "new_line_content": "            return function->getResultType();",
          "content_same": false
        },
        {
          "line": 1535,
          "old_api": "getN",
          "new_api": "getKind",
          "old_text": "left.getN()",
          "new_text": "right.getKind()",
          "old_line_content": "                    type_res = std::make_shared<LeftDataType>(left.getN());",
          "new_line_content": "                        if (left.getKind() == right.getKind())",
          "content_same": false
        },
        {
          "line": 1537,
          "old_api": "std::make_shared<DataTypeString>()",
          "new_api": "getKind",
          "old_text": "std::make_shared<DataTypeString>()",
          "new_text": "left.getKind()",
          "old_line_content": "                    type_res = std::make_shared<DataTypeString>();",
          "new_line_content": "                            type_res = std::make_shared<LeftDataType>(left.getKind());",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": "Exception",
          "new_api": "getScale",
          "old_text": "Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Overflow during decimal division\")",
          "new_text": "right.getScale()",
          "old_line_content": "                                    throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Overflow during decimal division\");",
          "new_line_content": "                        type_res = std::make_shared<RightDataType>(right.getPrecision(), right.getScale());",
          "content_same": false
        },
        {
          "line": 1587,
          "old_api": "getScale",
          "new_api": "std::make_shared<ResultDataType>(*tz)",
          "old_text": "right.getScale()",
          "new_text": "std::make_shared<ResultDataType>(*tz)",
          "old_line_content": "                        type_res = std::make_shared<RightDataType>(right.getPrecision(), right.getScale());",
          "new_line_content": "                        type_res = std::make_shared<ResultDataType>(*tz);",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": "getName",
          "new_api": "checkAndGetColumnConst<ColumnFixedString>(col_left_raw)",
          "old_text": "Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal types {} and {} of arguments of function {}\",\n            arguments[0]->getName(), arguments[1]->getName(), String(name))",
          "new_text": "checkAndGetColumnConst<ColumnFixedString>(col_left_raw)",
          "old_line_content": "        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal types {} and {} of arguments of function {}\",",
          "new_line_content": "        if (const auto * col_left_const = checkAndGetColumnConst<ColumnFixedString>(col_left_raw))",
          "content_same": false
        },
        {
          "line": 1624,
          "old_api": "checkAndGetColumnConst<ColumnFixedString>(col_left_raw)",
          "new_api": "ColumnUInt16::create()",
          "old_text": "checkAndGetColumnConst<ColumnFixedString>(col_left_raw)",
          "new_text": "ColumnUInt16::create()",
          "old_line_content": "        if (const auto * col_left_const = checkAndGetColumnConst<ColumnFixedString>(col_left_raw))",
          "new_line_content": "                    auto col_res = ColumnUInt16::create();",
          "content_same": false
        },
        {
          "line": 1626,
          "old_api": "checkAndGetColumnConst<ColumnFixedString>(col_right_raw)",
          "new_api": "size",
          "old_text": "checkAndGetColumnConst<ColumnFixedString>(col_right_raw)",
          "new_text": "col_left->size()",
          "old_line_content": "            if (const auto * col_right_const = checkAndGetColumnConst<ColumnFixedString>(col_right_raw))",
          "new_line_content": "                    data.resize_fill(col_left->size());",
          "content_same": false
        },
        {
          "line": 1628,
          "old_api": "getDataColumn",
          "new_api": "data",
          "old_text": "col_left_const->getDataColumn()",
          "new_text": "OpReduceImpl::template process<OpCase::Vector>(\n                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN())",
          "old_line_content": "                const auto * col_left = checkAndGetColumn<ColumnFixedString>(col_left_const->getDataColumn());",
          "new_line_content": "                    OpReduceImpl::template process<OpCase::Vector>(",
          "content_same": false
        },
        {
          "line": 1629,
          "old_api": "getDataColumn",
          "new_api": "getN",
          "old_text": "col_right_const->getDataColumn()",
          "new_text": "col_left->getN()",
          "old_line_content": "                const auto * col_right = checkAndGetColumn<ColumnFixedString>(col_right_const->getDataColumn());",
          "new_line_content": "                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN());",
          "content_same": false
        },
        {
          "line": 1631,
          "old_api": "getN",
          "new_api": "size",
          "old_text": "col_right->getN()",
          "new_text": "col_left_raw->size()",
          "old_line_content": "                if (col_left->getN() != col_right->getN())",
          "new_line_content": "                    return ColumnConst::create(std::move(col_res), col_left_raw->size());",
          "content_same": false
        },
        {
          "line": 1636,
          "old_api": "ColumnUInt16::create()",
          "new_api": "getChars",
          "old_text": "ColumnUInt16::create()",
          "new_text": "col_res->getChars()",
          "old_line_content": "                    auto col_res = ColumnUInt16::create();",
          "new_line_content": "                    auto & out_chars = col_res->getChars();",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": "size",
          "new_api": "getN",
          "old_text": "col_left->size()",
          "new_text": "col_left->getN()",
          "old_line_content": "                    data.resize_fill(col_left->size());",
          "new_line_content": "                    out_chars.resize(col_left->getN());",
          "content_same": false
        },
        {
          "line": 1641,
          "old_api": "getN",
          "new_api": "size",
          "old_text": "col_left->getN()",
          "new_text": "out_chars.size()",
          "old_line_content": "                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN());",
          "new_line_content": "                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), {});",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": "getN",
          "new_api": "checkAndGetColumnConst<ColumnFixedString>(col_right_raw)",
          "old_text": "col_left->getN()",
          "new_text": "checkAndGetColumnConst<ColumnFixedString>(col_right_raw)",
          "old_line_content": "                    out_chars.resize(col_left->getN());",
          "new_line_content": "        const bool is_right_column_const = checkAndGetColumnConst<ColumnFixedString>(col_right_raw) != nullptr;",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": "size",
          "new_api": "getDataColumn",
          "old_text": "out_chars.size()",
          "new_text": "checkAndGetColumn<ColumnFixedString>(\n                            checkAndGetColumnConst<ColumnFixedString>(col_left_raw)->getDataColumn())",
          "old_line_content": "                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), {});",
          "new_line_content": "                        ? checkAndGetColumn<ColumnFixedString>(",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": "size",
          "new_api": "checkAndGetColumn<ColumnFixedString>(col_left_raw)",
          "old_text": "col_left_raw->size()",
          "new_text": "checkAndGetColumn<ColumnFixedString>(col_left_raw)",
          "old_line_content": "                    return ColumnConst::create(std::move(col_res), col_left_raw->size());",
          "new_line_content": "                        : checkAndGetColumn<ColumnFixedString>(col_left_raw);",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": "getDataColumn",
          "new_api": "getData",
          "old_text": "checkAndGetColumn<ColumnFixedString>(\n                            checkAndGetColumnConst<ColumnFixedString>(col_right_raw)->getDataColumn())",
          "new_text": "col_res->getData()",
          "old_line_content": "                        ? checkAndGetColumn<ColumnFixedString>(",
          "new_line_content": "                auto & data = col_res->getData();",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": "getDataColumn",
          "new_api": "size",
          "old_text": "checkAndGetColumnConst<ColumnFixedString>(col_right_raw)->getDataColumn()",
          "new_text": "col_right->size()",
          "old_line_content": "                            checkAndGetColumnConst<ColumnFixedString>(col_right_raw)->getDataColumn())",
          "new_line_content": "                data.resize_fill(is_right_column_const ? col_left->size() : col_right->size());",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": "ColumnUInt16::create()",
          "new_api": "getN",
          "old_text": "ColumnUInt16::create()",
          "new_text": "col_left->getN()",
          "old_line_content": "                auto col_res = ColumnUInt16::create();",
          "new_line_content": "                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN());",
          "content_same": false
        },
        {
          "line": 1736,
          "old_api": "get",
          "new_api": "OpImpl::constConst(a, b)",
          "old_text": "arguments[1].column.get()",
          "new_text": "OpImpl::constConst(a, b)",
          "old_line_content": "        const auto * const col_right_raw = arguments[1].column.get();",
          "new_line_content": "                auto res = OpImpl::constConst(a, b);",
          "content_same": false
        },
        {
          "line": 1738,
          "old_api": "checkAndGetColumnConst<ColumnString>(col_left_raw)",
          "new_api": "createColumnConst",
          "old_text": "checkAndGetColumnConst<ColumnString>(col_left_raw)",
          "new_text": "DataTypeUInt64{}.createColumnConst(1, res)",
          "old_line_content": "        if (const auto * col_left_const = checkAndGetColumnConst<ColumnString>(col_left_raw))",
          "new_line_content": "                return DataTypeUInt64{}.createColumnConst(1, res);",
          "content_same": false
        },
        {
          "line": 1742,
          "old_api": "getDataColumn",
          "new_api": "checkAndGetColumnConst<ColumnString>(col_left_raw)",
          "old_text": "col_left_const->getDataColumn()",
          "new_text": "checkAndGetColumnConst<ColumnString>(col_left_raw)",
          "old_line_content": "                const auto * col_left = checkAndGetColumn<ColumnString>(col_left_const->getDataColumn());",
          "new_line_content": "        const bool is_left_column_const = checkAndGetColumnConst<ColumnString>(col_left_raw) != nullptr;",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": "getDataColumn",
          "new_api": "checkAndGetColumnConst<ColumnString>(col_right_raw)",
          "old_text": "col_right_const->getDataColumn()",
          "new_text": "checkAndGetColumnConst<ColumnString>(col_right_raw)",
          "old_line_content": "                const auto * col_right = checkAndGetColumn<ColumnString>(col_right_const->getDataColumn());",
          "new_line_content": "        const bool is_right_column_const = checkAndGetColumnConst<ColumnString>(col_right_raw) != nullptr;",
          "content_same": false
        },
        {
          "line": 1746,
          "old_api": "toView",
          "new_api": "getDataColumn",
          "old_text": "col_right->getDataAt(0).toView()",
          "new_text": "checkAndGetColumnConst<ColumnString>(col_left_raw)->getDataColumn()",
          "old_line_content": "                std::string_view b = col_right->getDataAt(0).toView();",
          "new_line_content": "            ? checkAndGetColumn<ColumnString>(checkAndGetColumnConst<ColumnString>(col_left_raw)->getDataColumn())",
          "content_same": false
        },
        {
          "line": 1750,
          "old_api": "createColumnConst",
          "new_api": "checkAndGetColumn<ColumnString>(col_right_raw)",
          "old_text": "DataTypeUInt64{}.createColumnConst(1, res)",
          "new_text": "checkAndGetColumn<ColumnString>(col_right_raw)",
          "old_line_content": "                return DataTypeUInt64{}.createColumnConst(1, res);",
          "new_line_content": "            : checkAndGetColumn<ColumnString>(col_right_raw);",
          "content_same": false
        },
        {
          "line": 1754,
          "old_api": "checkAndGetColumnConst<ColumnString>(col_left_raw)",
          "new_api": "ColumnUInt64::create()",
          "old_text": "checkAndGetColumnConst<ColumnString>(col_left_raw)",
          "new_text": "ColumnUInt64::create()",
          "old_line_content": "        const bool is_left_column_const = checkAndGetColumnConst<ColumnString>(col_left_raw) != nullptr;",
          "new_line_content": "            auto col_res = ColumnUInt64::create();",
          "content_same": false
        },
        {
          "line": 1755,
          "old_api": "checkAndGetColumnConst<ColumnString>(col_right_raw)",
          "new_api": "getData",
          "old_text": "checkAndGetColumnConst<ColumnString>(col_right_raw)",
          "new_text": "col_res->getData()",
          "old_line_content": "        const bool is_right_column_const = checkAndGetColumnConst<ColumnString>(col_right_raw) != nullptr;",
          "new_line_content": "            auto & data = col_res->getData();",
          "content_same": false
        },
        {
          "line": 1761,
          "old_api": "getDataColumn",
          "new_api": "getOffsets",
          "old_text": "checkAndGetColumnConst<ColumnString>(col_right_raw)->getDataColumn()",
          "new_text": "col_right->getOffsets()",
          "old_line_content": "            ? checkAndGetColumn<ColumnString>(checkAndGetColumnConst<ColumnString>(col_right_raw)->getDataColumn())",
          "new_line_content": "                    col_left->getChars(), col_left->getOffsets(), col_right->getChars(), col_right->getOffsets(), data);",
          "content_same": false
        },
        {
          "line": 1766,
          "old_api": "ColumnUInt64::create()",
          "new_api": "getOffsets",
          "old_text": "ColumnUInt64::create()",
          "new_text": "col_right->getOffsets()",
          "old_line_content": "            auto col_res = ColumnUInt64::create();",
          "new_line_content": "                OpImpl::vectorConstant(col_right->getChars(), col_right->getOffsets(), str_view, data);",
          "content_same": false
        },
        {
          "line": 1797,
          "old_api": "get",
          "new_api": "getDataColumn",
          "old_text": "arguments[0].column.get()",
          "new_text": "col_left_const->getDataColumn()",
          "old_line_content": "        const auto * const col_left_raw = arguments[0].column.get();",
          "new_line_content": "        const auto * col_left = col_left_const ? checkAndGetColumn<LeftColumnType>(col_left_const->getDataColumn())",
          "content_same": false
        },
        {
          "line": 1798,
          "old_api": "get",
          "new_api": "checkAndGetColumn<LeftColumnType>(col_left_raw)",
          "old_text": "arguments[1].column.get()",
          "new_text": "checkAndGetColumn<LeftColumnType>(col_left_raw)",
          "old_line_content": "        const auto * const col_right_raw = arguments[1].column.get();",
          "new_line_content": "                                               : checkAndGetColumn<LeftColumnType>(col_left_raw);",
          "content_same": false
        },
        {
          "line": 1803,
          "old_api": "checkAndGetColumnConst<ColVecT1>(col_right_raw)",
          "new_api": "getChars",
          "old_text": "checkAndGetColumnConst<ColVecT1>(col_right_raw)",
          "new_text": "col_left->getChars()",
          "old_line_content": "        const ColumnConst * const col_right_const = checkAndGetColumnConst<ColVecT1>(col_right_raw);",
          "new_line_content": "        const typename LeftColumnType::Chars & in_vec = col_left->getChars();",
          "content_same": false
        },
        {
          "line": 1807,
          "old_api": "checkAndGetColumnConst<LeftColumnType>(col_left_raw)",
          "new_api": "getN",
          "old_text": "checkAndGetColumnConst<LeftColumnType>(col_left_raw)",
          "new_text": "col_left->getN()",
          "old_line_content": "        const ColumnConst * const col_left_const = checkAndGetColumnConst<LeftColumnType>(col_left_raw);",
          "new_line_content": "            col_res = LeftColumnType::create(col_left->getN());",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": "getDataColumn",
          "new_api": "LeftColumnType::create()",
          "old_text": "col_left_const->getDataColumn()",
          "new_text": "LeftColumnType::create()",
          "old_line_content": "        const auto * col_left = col_left_const ? checkAndGetColumn<LeftColumnType>(col_left_const->getDataColumn())",
          "new_line_content": "            col_res = LeftColumnType::create();",
          "content_same": false
        },
        {
          "line": 1815,
          "old_api": "getChars",
          "new_api": "col_right_const->template getValue<T1>()",
          "old_text": "col_left->getChars()",
          "new_text": "col_right_const->template getValue<T1>()",
          "old_line_content": "        const typename LeftColumnType::Chars & in_vec = col_left->getChars();",
          "new_line_content": "            const T1 value = col_right_const->template getValue<T1>();",
          "content_same": false
        },
        {
          "line": 1823,
          "old_api": "getChars",
          "new_api": "data",
          "old_text": "col_res->getChars()",
          "new_text": "col_left->getOffsets().data()",
          "old_line_content": "        typename LeftColumnType::Chars & out_vec = col_res->getChars();",
          "new_line_content": "                OpImpl::template processString<OpCase::Vector>(in_vec.data(), col_left->getOffsets().data(), &value, out_vec, out_offsets, 1);",
          "content_same": false
        },
        {
          "line": 1838,
          "old_api": "size",
          "new_api": "data",
          "old_text": "col_left_const->size()",
          "new_text": "OpImpl::template processString<OpCase::Vector>(\n                    in_vec.data(), col_left->getOffsets().data(), col_right->getData().data(), out_vec, out_offsets, col_left->size())",
          "old_line_content": "            return ColumnConst::create(std::move(col_res), col_left_const->size());",
          "new_line_content": "                OpImpl::template processString<OpCase::Vector>(",
          "content_same": false
        },
        {
          "line": 1851,
          "old_api": "size",
          "new_api": "getOffsets",
          "old_text": "col_left->size()",
          "new_text": "col_res->getOffsets()",
          "old_line_content": "                    in_vec.data(), col_left->getOffsets().data(), col_right->getData().data(), out_vec, out_offsets, col_left->size());",
          "new_line_content": "                ColumnString::Offsets & out_offsets = col_res->getOffsets();",
          "content_same": false
        },
        {
          "line": 1859,
          "old_api": "size",
          "new_api": "col_right_const->template getValue<T1>()",
          "old_text": "col_right->size()",
          "new_text": "col_right_const->template getValue<T1>()",
          "old_line_content": "                    in_vec.data(), col_left->getN(), col_right->getData().data(), out_vec, col_right->size());",
          "new_line_content": "            const T1 value = col_right_const->template getValue<T1>();",
          "content_same": false
        },
        {
          "line": 1866,
          "old_api": "size",
          "new_api": "getOffsets",
          "old_text": "col_right->size()",
          "new_text": "col_res->getOffsets()",
          "old_line_content": "                    in_vec.data(), col_left->getOffsets().data(), col_right->getData().data(), out_vec, out_offsets, col_right->size());",
          "new_line_content": "                ColumnString::Offsets & out_offsets = col_res->getOffsets();",
          "content_same": false
        },
        {
          "line": 1918,
          "old_api": "std::make_shared<DataTypeFloat64>()",
          "new_api": "size",
          "old_text": "std::make_shared<DataTypeFloat64>()",
          "new_text": "col_left_raw->size()",
          "old_line_content": "                const auto converted_type = std::make_shared<DataTypeFloat64>();",
          "new_line_content": "            const size_t col_left_size = col_left_raw->size();",
          "content_same": false
        },
        {
          "line": 1920,
          "old_api": "castColumn",
          "new_api": "checkAndGetColumnConst<ColVecT0>(col_left_raw)",
          "old_text": "castColumn(arguments[1], converted_type)",
          "new_text": "checkAndGetColumnConst<ColVecT0>(col_left_raw)",
          "old_line_content": "                right_col = castColumn(arguments[1], converted_type);",
          "new_line_content": "            const ColumnConst * const col_left_const = checkAndGetColumnConst<ColVecT0>(col_left_raw);",
          "content_same": false
        },
        {
          "line": 1928,
          "old_api": "get",
          "new_api": "executeNumericWithDecimal<LeftDataType, RightDataType, ResultDataType>(\n                    left, right,\n                    col_left_const, col_right_const,\n                    col_left, col_right,\n                    col_left_size,\n                    right_nullmap)",
          "old_text": "right_col.get()",
          "new_text": "executeNumericWithDecimal<LeftDataType, RightDataType, ResultDataType>(\n                    left, right,\n                    col_left_const, col_right_const,\n                    col_left, col_right,\n                    col_left_size,\n                    right_nullmap)",
          "old_line_content": "            const auto * const col_right_raw = right_col.get();",
          "new_line_content": "                return executeNumericWithDecimal<LeftDataType, RightDataType, ResultDataType>(",
          "content_same": false
        },
        {
          "line": 1957,
          "old_api": "col_right_const->template getValue<T1>()",
          "new_api": "data",
          "old_text": "col_right_const->template getValue<T1>()",
          "new_text": "OpImpl::template process<OpCase::Vector>(\n                        col_left->getData().data(),\n                        col_right->getData().data(),\n                        vec_res.data(),\n                        vec_res.size(),\n                        right_nullmap)",
          "old_line_content": "                        col_right_const->template getValue<T1>());",
          "new_line_content": "                    OpImpl::template process<OpCase::Vector>(",
          "content_same": false
        },
        {
          "line": 1959,
          "old_api": "toField",
          "new_api": "data",
          "old_text": "toField(res)",
          "new_text": "col_right->getData().data()",
          "old_line_content": "                    return ResultDataType().createColumnConst(col_left_const->size(), toField(res));",
          "new_line_content": "                        col_right->getData().data(),",
          "content_same": false
        },
        {
          "line": 1972,
          "old_api": "data",
          "new_api": "size",
          "old_text": "vec_res.data()",
          "new_text": "vec_res.size()",
          "old_line_content": "                        vec_res.data(),",
          "new_line_content": "                        vec_res.size(),",
          "content_same": false
        },
        {
          "line": 1980,
          "old_api": "data",
          "new_api": "size",
          "old_text": "OpImpl::template process<OpCase::LeftConstant>(\n                        &value,\n                        col_right->getData().data(),\n                        vec_res.data(),\n                        vec_res.size(),\n                        right_nullmap)",
          "new_text": "vec_res.size()",
          "old_line_content": "                    OpImpl::template process<OpCase::LeftConstant>(",
          "new_line_content": "                        col_left->getData().data(), &value, vec_res.data(), vec_res.size(), right_nullmap);",
          "content_same": false
        },
        {
          "line": 2005,
          "old_api": "isAggregateMultiply",
          "new_api": "getFunctionForIntervalArithmetic",
          "old_text": "isAggregateMultiply(arguments[0].type, arguments[1].type)",
          "new_text": "getFunctionForIntervalArithmetic(arguments[0].type, arguments[1].type, context)",
          "old_line_content": "        if (isAggregateMultiply(arguments[0].type, arguments[1].type))",
          "new_line_content": "        if (auto function_builder = getFunctionForIntervalArithmetic(arguments[0].type, arguments[1].type, context))",
          "content_same": false
        },
        {
          "line": 2007,
          "old_api": "executeAggregateMultiply",
          "new_api": "executeDateTimeIntervalPlusMinus",
          "old_text": "executeAggregateMultiply(arguments, result_type, input_rows_count)",
          "new_text": "executeDateTimeIntervalPlusMinus(arguments, result_type, input_rows_count, function_builder)",
          "old_line_content": "            return executeAggregateMultiply(arguments, result_type, input_rows_count);",
          "new_line_content": "            return executeDateTimeIntervalPlusMinus(arguments, result_type, input_rows_count, function_builder);",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": "isAggregateAddition",
          "new_api": "getFunctionForDateTupleOfIntervalsArithmetic",
          "old_text": "isAggregateAddition(arguments[0].type, arguments[1].type)",
          "new_text": "getFunctionForDateTupleOfIntervalsArithmetic(arguments[0].type, arguments[1].type, context)",
          "old_line_content": "        if (isAggregateAddition(arguments[0].type, arguments[1].type))",
          "new_line_content": "        if (auto function_builder = getFunctionForDateTupleOfIntervalsArithmetic(arguments[0].type, arguments[1].type, context))",
          "content_same": false
        },
        {
          "line": 2013,
          "old_api": "executeAggregateAddition",
          "new_api": "executeDateTimeTupleOfIntervalsPlusMinus",
          "old_text": "executeAggregateAddition(arguments, result_type, input_rows_count)",
          "new_text": "executeDateTimeTupleOfIntervalsPlusMinus(arguments, result_type, input_rows_count, function_builder)",
          "old_line_content": "            return executeAggregateAddition(arguments, result_type, input_rows_count);",
          "new_line_content": "            return executeDateTimeTupleOfIntervalsPlusMinus(arguments, result_type, input_rows_count, function_builder);",
          "content_same": false
        },
        {
          "line": 2017,
          "old_api": "getFunctionForIntervalArithmetic",
          "new_api": "getFunctionForMergeIntervalsArithmetic",
          "old_text": "getFunctionForIntervalArithmetic(arguments[0].type, arguments[1].type, context)",
          "new_text": "getFunctionForMergeIntervalsArithmetic(arguments[0].type, arguments[1].type, context)",
          "old_line_content": "        if (auto function_builder = getFunctionForIntervalArithmetic(arguments[0].type, arguments[1].type, context))",
          "new_line_content": "        if (auto function_builder = getFunctionForMergeIntervalsArithmetic(arguments[0].type, arguments[1].type, context))",
          "content_same": false
        },
        {
          "line": 2019,
          "old_api": "executeDateTimeIntervalPlusMinus",
          "new_api": "executeIntervalTupleOfIntervalsPlusMinus",
          "old_text": "executeDateTimeIntervalPlusMinus(arguments, result_type, input_rows_count, function_builder)",
          "new_text": "executeIntervalTupleOfIntervalsPlusMinus(arguments, result_type, input_rows_count, function_builder)",
          "old_line_content": "            return executeDateTimeIntervalPlusMinus(arguments, result_type, input_rows_count, function_builder);",
          "new_line_content": "            return executeIntervalTupleOfIntervalsPlusMinus(arguments, result_type, input_rows_count, function_builder);",
          "content_same": false
        },
        {
          "line": 2023,
          "old_api": "getFunctionForDateTupleOfIntervalsArithmetic",
          "new_api": "getFunctionForTupleArithmetic",
          "old_text": "getFunctionForDateTupleOfIntervalsArithmetic(arguments[0].type, arguments[1].type, context)",
          "new_text": "getFunctionForTupleArithmetic(arguments[0].type, arguments[1].type, context)",
          "old_line_content": "        if (auto function_builder = getFunctionForDateTupleOfIntervalsArithmetic(arguments[0].type, arguments[1].type, context))",
          "new_line_content": "        if (auto function_builder = getFunctionForTupleArithmetic(arguments[0].type, arguments[1].type, context))",
          "content_same": false
        },
        {
          "line": 2025,
          "old_api": "executeDateTimeTupleOfIntervalsPlusMinus",
          "new_api": "build",
          "old_text": "executeDateTimeTupleOfIntervalsPlusMinus(arguments, result_type, input_rows_count, function_builder)",
          "new_text": "function_builder->build(arguments)->execute(arguments, result_type, input_rows_count)",
          "old_line_content": "            return executeDateTimeTupleOfIntervalsPlusMinus(arguments, result_type, input_rows_count, function_builder);",
          "new_line_content": "            return function_builder->build(arguments)->execute(arguments, result_type, input_rows_count);",
          "content_same": false
        },
        {
          "line": 2029,
          "old_api": "getFunctionForMergeIntervalsArithmetic",
          "new_api": "getFunctionForTupleAndNumberArithmetic",
          "old_text": "getFunctionForMergeIntervalsArithmetic(arguments[0].type, arguments[1].type, context)",
          "new_text": "getFunctionForTupleAndNumberArithmetic(arguments[0].type, arguments[1].type, context)",
          "old_line_content": "        if (auto function_builder = getFunctionForMergeIntervalsArithmetic(arguments[0].type, arguments[1].type, context))",
          "new_line_content": "        if (auto function_builder = getFunctionForTupleAndNumberArithmetic(arguments[0].type, arguments[1].type, context))",
          "content_same": false
        },
        {
          "line": 2031,
          "old_api": "executeIntervalTupleOfIntervalsPlusMinus",
          "new_api": "executeTupleNumberOperator",
          "old_text": "executeIntervalTupleOfIntervalsPlusMinus(arguments, result_type, input_rows_count, function_builder)",
          "new_text": "executeTupleNumberOperator(arguments, result_type, input_rows_count, function_builder)",
          "old_line_content": "            return executeIntervalTupleOfIntervalsPlusMinus(arguments, result_type, input_rows_count, function_builder);",
          "new_line_content": "            return executeTupleNumberOperator(arguments, result_type, input_rows_count, function_builder);",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": "executeImpl2",
          "new_api": "isNullable",
          "old_text": "executeImpl2(arguments, result_type, input_rows_count)",
          "new_text": "right_argument.type->isNullable()",
          "old_line_content": "        return executeImpl2(arguments, result_type, input_rows_count);",
          "new_line_content": "            assert(right_argument.type->isNullable());",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": "isNullable",
          "new_api": "isIPv4",
          "old_text": "right_argument.type->isNullable()",
          "new_text": "isIPv4(arguments[1].type)",
          "old_line_content": "            assert(right_argument.type->isNullable());",
          "new_line_content": "        if (isIPv4(arguments[0].type) || isIPv4(arguments[1].type))",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": "checkAndGetColumn<ColumnNullable>(*right_argument.column)",
          "new_api": "std::make_shared<DataTypeUInt32>()",
          "old_text": "checkAndGetColumn<ColumnNullable>(*right_argument.column)",
          "new_text": "std::make_shared<DataTypeUInt32>()",
          "old_line_content": "                                                              : checkAndGetColumn<ColumnNullable>(*right_argument.column);",
          "new_line_content": "                    isIPv4(arguments[0].type) ? castColumn(arguments[0], std::make_shared<DataTypeUInt32>()) : arguments[0].column,",
          "content_same": false
        },
        {
          "line": 2080,
          "old_api": "std::make_shared<DataTypeUInt32>()",
          "new_api": "castBothTypes",
          "old_text": "std::make_shared<DataTypeUInt32>()",
          "new_text": "castBothTypes(left_generic, right_generic, [&](const auto & left, const auto & right)\n        {\n            using LeftDataType = std::decay_t<decltype(left)>;\n            using RightDataType = std::decay_t<decltype(right)>;\n\n            if constexpr ((std::is_same_v<DataTypeFixedString, LeftDataType> || std::is_same_v<DataTypeString, LeftDataType>) ||\n                          (std::is_same_v<DataTypeFixedString, RightDataType> || std::is_same_v<DataTypeString, RightDataType>))\n            {\n                if constexpr (std::is_same_v<DataTypeFixedString, LeftDataType> &&\n                              std::is_same_v<DataTypeFixedString, RightDataType>)\n                {\n                    if constexpr (!Op<DataTypeFixedString, DataTypeFixedString>::allow_fixed_string)\n                        return false;\n                    else\n                        return (res = executeFixedString(arguments)) != nullptr;\n                }\n\n                if constexpr (\n                    is_bit_hamming_distance\n                    && std::is_same_v<DataTypeString, LeftDataType> && std::is_same_v<DataTypeString, RightDataType>)\n                    return (res = executeString(arguments)) != nullptr;\n                else if constexpr (!Op<LeftDataType, RightDataType>::allow_string_integer)\n                    return false;\n                else if constexpr (!IsIntegral<RightDataType>)\n                    return false;\n                else if constexpr (std::is_same_v<DataTypeFixedString, LeftDataType>)\n                {\n                    return (res = executeStringInteger<ColumnFixedString>(arguments, left, right)) != nullptr;\n                }\n                else if constexpr (std::is_same_v<DataTypeString, LeftDataType>)\n                    return (res = executeStringInteger<ColumnString>(arguments, left, right)) != nullptr;\n            }\n            else\n                return (res = executeNumeric(arguments, left, right, right_nullmap)) != nullptr;\n        })",
          "old_line_content": "                    isIPv4(arguments[1].type) ? std::make_shared<DataTypeUInt32>() : arguments[1].type,",
          "new_line_content": "        const bool valid = castBothTypes(left_generic, right_generic, [&](const auto & left, const auto & right)",
          "content_same": false
        },
        {
          "line": 2125,
          "old_api": "executeNumeric",
          "new_api": "getName",
          "old_text": "executeNumeric(arguments, left, right, right_nullmap)",
          "new_text": "getName()",
          "old_line_content": "                return (res = executeNumeric(arguments, left, right, right_nullmap)) != nullptr;",
          "new_line_content": "                \" '{}' of type '{}'\", getName(),",
          "content_same": false
        },
        {
          "line": 2139,
          "old_api": "getName",
          "new_api": "canBeNativeType",
          "old_text": "right_argument.type->getName()",
          "new_text": "canBeNativeType(*result_type)",
          "old_line_content": "                right_argument.name, right_argument.type->getName());",
          "new_line_content": "        if (!canBeNativeType(*arguments[0]) || !canBeNativeType(*arguments[1]) || !canBeNativeType(*result_type))",
          "content_same": false
        },
        {
          "line": 2148,
          "old_api": "size",
          "new_api": "get",
          "old_text": "arguments.size()",
          "new_text": "arguments[1].get()",
          "old_line_content": "        if (2 != arguments.size())",
          "new_line_content": "        return castBothTypes(arguments[0].get(), arguments[1].get(), [&](const auto & left, const auto & right)",
          "content_same": false
        },
        {
          "line": 2243,
          "old_api": "size",
          "new_api": "cloneResized",
          "old_text": "arguments.size()",
          "new_text": "right.column->cloneResized(input_rows_count)",
          "old_line_content": "        if (left.column && isColumnConst(*left.column) && arguments.size() == 1)",
          "new_line_content": "                   {right.column->cloneResized(input_rows_count), right.type, right.name}};",
          "content_same": false
        },
        {
          "line": 2282,
          "old_api": "Field",
          "new_api": "FieldVisitorAccurateEquals",
          "old_text": "Field(0)",
          "new_text": "FieldVisitorAccurateEquals()",
          "old_line_content": "                    if (applyVisitor(FieldVisitorAccurateEquals(), constant, Field(0)))",
          "new_line_content": "        if (applyVisitor(FieldVisitorAccurateEquals(), left_point, right_point))",
          "content_same": false
        },
        {
          "line": 2303,
          "old_api": "removeLowCardinality",
          "new_api": "Base::executeImpl(columns_with_constant, ret_type, 1)",
          "old_text": "removeLowCardinality(right.type)",
          "new_text": "Base::executeImpl(columns_with_constant, ret_type, 1)",
          "old_line_content": "                auto right_type = removeNullable(removeLowCardinality(right.type));",
          "new_line_content": "                    auto col = Base::executeImpl(columns_with_constant, ret_type, 1);",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": "createColumnConst",
          "new_api": "FieldVisitorAccurateLess",
          "old_text": "left_type->createColumnConst(1, (*left.column)[0])",
          "new_text": "FieldVisitorAccurateLess()",
          "old_line_content": "                        = {{left_type->createColumnConst(1, (*left.column)[0]), left_type, left.name},",
          "new_line_content": "                bool is_positive_monotonicity = applyVisitor(FieldVisitorAccurateLess(), left_point, right_point)",
          "content_same": false
        },
        {
          "line": 2310,
          "old_api": "createColumnConst",
          "new_api": "transform",
          "old_text": "right_type->createColumnConst(1, point)",
          "new_text": "transform(right_point)",
          "old_line_content": "                           {right_type->createColumnConst(1, point), right_type, right.name}};",
          "new_line_content": "                            == applyVisitor(FieldVisitorAccurateLess(), transform(left_point), transform(right_point));",
          "content_same": false
        },
        {
          "line": 2342,
          "old_api": "isColumnConst",
          "new_api": "Base::executeImpl(columns_with_constant, ret_type, 1)",
          "old_text": "isColumnConst(*right.column)",
          "new_text": "Base::executeImpl(columns_with_constant, ret_type, 1)",
          "old_line_content": "            else if (right.column && isColumnConst(*right.column))",
          "new_line_content": "                    auto col = Base::executeImpl(columns_with_constant, ret_type, 1);",
          "content_same": false
        },
        {
          "line": 2344,
          "old_api": "removeLowCardinality",
          "new_api": "get",
          "old_text": "removeLowCardinality(left.type)",
          "new_text": "col->get(0, point_transformed)",
          "old_line_content": "                auto left_type = removeNullable(removeLowCardinality(left.type));",
          "new_line_content": "                    col->get(0, point_transformed);",
          "content_same": false
        },
        {
          "line": 2361,
          "old_api": "FieldVisitorAccurateLess",
          "new_api": "isColumnConst",
          "old_text": "FieldVisitorAccurateLess()",
          "new_text": "isColumnConst(*left.column)",
          "old_line_content": "                if (applyVisitor(FieldVisitorAccurateLess(), left_point, right_point)",
          "new_line_content": "            if (left.column && isColumnConst(*left.column))",
          "content_same": false
        },
        {
          "line": 2381,
          "old_api": "Field",
          "new_api": "isColumnConst",
          "old_text": "Field(0)",
          "new_text": "isColumnConst(*right.column)",
          "old_line_content": "                    && applyVisitor(FieldVisitorAccurateLess(), right_point, Field(0)))",
          "new_line_content": "            else if (right.column && isColumnConst(*right.column))",
          "content_same": false
        },
        {
          "line": 2433,
          "old_api": "isNullable",
          "new_api": "FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments, false>::create(\n                    arguments[0], arguments[1], return_type, context)",
          "old_text": "arguments[1].type->isNullable()",
          "new_text": "FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments, false>::create(\n                    arguments[0], arguments[1], return_type, context)",
          "old_line_content": "        bool division_by_nullable = !arguments[0].type->onlyNull() && !arguments[1].type->onlyNull() && arguments[1].type->isNullable()",
          "new_line_content": "                : FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments, false>::create(",
          "content_same": false
        },
        {
          "line": 2436,
          "old_api": "isDecimalOrNullableDecimal",
          "new_api": "std::make_unique<FunctionToFunctionBaseAdaptor>(\n                function,\n                collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),\n                return_type)",
          "old_text": "isDecimalOrNullableDecimal(arguments[1].type)",
          "new_text": "std::make_unique<FunctionToFunctionBaseAdaptor>(\n                function,\n                collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),\n                return_type)",
          "old_line_content": "                    && (isDecimalOrNullableDecimal(arguments[0].type) || isDecimalOrNullableDecimal(arguments[1].type))));",
          "new_line_content": "            return std::make_unique<FunctionToFunctionBaseAdaptor>(",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": "FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments, true>::create(\n                    arguments[0], arguments[1], return_type, context)",
          "new_api": "FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, false>::create(context)",
          "old_text": "FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments, true>::create(\n                    arguments[0], arguments[1], return_type, context)",
          "new_text": "FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, false>::create(context)",
          "old_line_content": "            auto function = division_by_nullable ? FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments, true>::create(",
          "new_line_content": "            : FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, false>::create(context);",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": "FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments, false>::create(\n                    arguments[0], arguments[1], return_type, context)",
          "new_api": "std::make_unique<FunctionToFunctionBaseAdaptor>(\n            function,\n            collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),\n            return_type)",
          "old_text": "FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments, false>::create(\n                    arguments[0], arguments[1], return_type, context)",
          "new_text": "std::make_unique<FunctionToFunctionBaseAdaptor>(\n            function,\n            collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),\n            return_type)",
          "old_line_content": "                : FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments, false>::create(",
          "new_line_content": "        return std::make_unique<FunctionToFunctionBaseAdaptor>(",
          "content_same": false
        },
        {
          "line": 2454,
          "old_api": "FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, true>::create(context)",
          "new_api": "size",
          "old_text": "FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, true>::create(context)",
          "new_text": "arguments.size()",
          "old_line_content": "            ? FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, true>::create(context)",
          "new_line_content": "        if (arguments.size() != 2)",
          "content_same": false
        },
        {
          "line": 2455,
          "old_api": "FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, false>::create(context)",
          "new_api": "size",
          "old_text": "FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, false>::create(context)",
          "new_text": "Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n                \"Number of arguments for function {} doesn't match: passed {}, should be 2\",\n                getName(), arguments.size())",
          "old_line_content": "            : FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, false>::create(context);",
          "new_line_content": "            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,",
          "content_same": false
        },
        {
          "line": 2457,
          "old_api": "std::make_unique<FunctionToFunctionBaseAdaptor>(\n            function,\n            collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),\n            return_type)",
          "new_api": "size",
          "old_text": "std::make_unique<FunctionToFunctionBaseAdaptor>(\n            function,\n            collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),\n            return_type)",
          "new_text": "arguments.size()",
          "old_line_content": "        return std::make_unique<FunctionToFunctionBaseAdaptor>(",
          "new_line_content": "                getName(), arguments.size());",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2048,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "right_argument.column.get()",
          "old_line_content": "",
          "new_line_content": "            bool is_const = checkColumnConst<ColumnNullable>(right_argument.column.get());",
          "content_same": false
        },
        {
          "line": 2049,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "right_argument.column.get()",
          "old_line_content": "    ColumnPtr executeImpl2(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count, const NullMap * right_nullmap = nullptr) const",
          "new_line_content": "            const ColumnNullable * nullable_column = is_const ? checkAndGetColumnConstData<ColumnNullable>(right_argument.column.get())",
          "content_same": false
        },
        {
          "line": 2050,
          "old_api": null,
          "new_api": "checkAndGetColumn<ColumnNullable>(*right_argument.column)",
          "old_text": null,
          "new_text": "checkAndGetColumn<ColumnNullable>(*right_argument.column)",
          "old_line_content": "    {",
          "new_line_content": "                                                              : checkAndGetColumn<ColumnNullable>(*right_argument.column);",
          "content_same": false
        },
        {
          "line": 2052,
          "old_api": null,
          "new_api": "getNullMapData",
          "old_text": null,
          "new_text": "nullable_column->getNullMapData()",
          "old_line_content": "        const auto & right_argument = arguments[1];",
          "new_line_content": "            const auto & null_bytemap = nullable_column->getNullMapData();",
          "content_same": false
        },
        {
          "line": 2053,
          "old_api": null,
          "new_api": "removeNullable",
          "old_text": null,
          "new_text": "removeNullable(result_type)",
          "old_line_content": "",
          "new_line_content": "            auto res = executeImpl2(createBlockWithNestedColumns(arguments), removeNullable(result_type), input_rows_count, &null_bytemap);",
          "content_same": false
        },
        {
          "line": 2054,
          "old_api": null,
          "new_api": "wrapInNullable",
          "old_text": null,
          "new_text": "wrapInNullable(res, arguments, result_type, input_rows_count)",
          "old_line_content": "        /// Process special case when operation is divide, intDiv or modulo and denominator",
          "new_line_content": "            return wrapInNullable(res, arguments, result_type, input_rows_count);",
          "content_same": false
        },
        {
          "line": 2063,
          "old_api": null,
          "new_api": "std::make_shared<DataTypeUInt32>()",
          "old_text": null,
          "new_text": "std::make_shared<DataTypeUInt32>()",
          "old_line_content": "",
          "new_line_content": "                    isIPv4(arguments[0].type) ? std::make_shared<DataTypeUInt32>() : arguments[0].type,",
          "content_same": false
        },
        {
          "line": 1553,
          "old_api": null,
          "new_api": "getSettingsRef",
          "old_text": null,
          "new_text": "context->getSettingsRef()",
          "old_line_content": "                }",
          "new_line_content": "                            if (context->getSettingsRef().decimal_check_overflow)",
          "content_same": false
        },
        {
          "line": 2067,
          "old_api": null,
          "new_api": "std::make_shared<DataTypeUInt32>()",
          "old_text": null,
          "new_text": "std::make_shared<DataTypeUInt32>()",
          "old_line_content": "        }",
          "new_line_content": "                    isIPv4(arguments[1].type) ? castColumn(arguments[1], std::make_shared<DataTypeUInt32>()) : arguments[1].column,",
          "content_same": false
        },
        {
          "line": 2068,
          "old_api": null,
          "new_api": "std::make_shared<DataTypeUInt32>()",
          "old_text": null,
          "new_text": "std::make_shared<DataTypeUInt32>()",
          "old_line_content": "",
          "new_line_content": "                    isIPv4(arguments[1].type) ? std::make_shared<DataTypeUInt32>() : arguments[1].type,",
          "content_same": false
        },
        {
          "line": 2073,
          "old_api": null,
          "new_api": "executeImpl2",
          "old_text": null,
          "new_text": "executeImpl2(new_arguments, result_type, input_rows_count, right_nullmap)",
          "old_line_content": "                {",
          "new_line_content": "            return executeImpl2(new_arguments, result_type, input_rows_count, right_nullmap);",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": null,
          "new_api": "ResultDataType::maxPrecision()",
          "old_text": null,
          "new_text": "ResultDataType::maxPrecision()",
          "old_line_content": "                    {",
          "new_line_content": "                                if (left.getScale() + right.getScale() > ResultDataType::maxPrecision())",
          "content_same": false
        },
        {
          "line": 1563,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Overflow during decimal division\")",
          "old_line_content": "                        if constexpr (is_division)",
          "new_line_content": "                                    throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Overflow during decimal division\");",
          "content_same": false
        },
        {
          "line": 2076,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "left_argument.type.get()",
          "old_line_content": "                    arguments[0].name,",
          "new_line_content": "        const auto * const left_generic = left_argument.type.get();",
          "content_same": false
        },
        {
          "line": 2077,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "right_argument.type.get()",
          "old_line_content": "                },",
          "new_line_content": "        const auto * const right_generic = right_argument.type.get();",
          "content_same": false
        },
        {
          "line": 1566,
          "old_api": null,
          "new_api": "decimalResultType<is_multiply, is_division>(left, right)",
          "old_text": null,
          "new_text": "decimalResultType<is_multiply, is_division>(left, right)",
          "old_line_content": "                            {",
          "new_line_content": "                        ResultDataType result_type = decimalResultType<is_multiply, is_division>(left, right);",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": null,
          "new_api": "getScale",
          "old_text": null,
          "new_text": "result_type.getScale()",
          "old_line_content": "                                /// Check overflow by using operands scale (based on big decimal division implementation details):",
          "new_line_content": "                        type_res = std::make_shared<ResultDataType>(result_type.getPrecision(), result_type.getScale());",
          "content_same": false
        },
        {
          "line": 1571,
          "old_api": null,
          "new_api": "std::make_shared<DataTypeFloat64>()",
          "old_text": null,
          "new_text": "std::make_shared<DataTypeFloat64>()",
          "old_line_content": "                                /// BigInt result = left*10^(left_scale + right_scale) / right * 10^right_scale",
          "new_line_content": "                        type_res = std::make_shared<DataTypeFloat64>();",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": null,
          "new_api": "getScale",
          "old_text": null,
          "new_text": "left.getScale()",
          "old_line_content": "                                /// Note: it doesn't detect all possible overflow during big decimal division",
          "new_line_content": "                        type_res = std::make_shared<LeftDataType>(left.getPrecision(), left.getScale());",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": null,
          "new_api": "executeFixedString",
          "old_text": null,
          "new_text": "executeFixedString(arguments)",
          "old_line_content": "            using LeftDataType = std::decay_t<decltype(left)>;",
          "new_line_content": "                        return (res = executeFixedString(arguments)) != nullptr;",
          "content_same": false
        },
        {
          "line": 2100,
          "old_api": null,
          "new_api": "executeString",
          "old_text": null,
          "new_text": "executeString(arguments)",
          "old_line_content": "                if constexpr (std::is_same_v<DataTypeFixedString, LeftDataType> &&",
          "new_line_content": "                    return (res = executeString(arguments)) != nullptr;",
          "content_same": false
        },
        {
          "line": 1590,
          "old_api": null,
          "new_api": "std::make_shared<ResultDataType>()",
          "old_text": null,
          "new_text": "std::make_shared<ResultDataType>()",
          "old_line_content": "                        // Special case for DateTime: binary OPS should reuse timezone",
          "new_line_content": "                        type_res = std::make_shared<ResultDataType>();",
          "content_same": false
        },
        {
          "line": 2107,
          "old_api": null,
          "new_api": "executeStringInteger<ColumnFixedString>(arguments, left, right)",
          "old_text": null,
          "new_text": "executeStringInteger<ColumnFixedString>(arguments, left, right)",
          "old_line_content": "                }",
          "new_line_content": "                    return (res = executeStringInteger<ColumnFixedString>(arguments, left, right)) != nullptr;",
          "content_same": false
        },
        {
          "line": 2110,
          "old_api": null,
          "new_api": "executeStringInteger<ColumnString>(arguments, left, right)",
          "old_text": null,
          "new_text": "executeStringInteger<ColumnString>(arguments, left, right)",
          "old_line_content": "                    is_bit_hamming_distance",
          "new_line_content": "                    return (res = executeStringInteger<ColumnString>(arguments, left, right)) != nullptr;",
          "content_same": false
        },
        {
          "line": 1600,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal types {} and {} of arguments of function {}\",\n            arguments[0]->getName(), arguments[1]->getName(), String(name))",
          "old_line_content": "                    }",
          "new_line_content": "        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal types {} and {} of arguments of function {}\",",
          "content_same": false
        },
        {
          "line": 2113,
          "old_api": null,
          "new_api": "executeNumeric",
          "old_text": null,
          "new_text": "executeNumeric(arguments, left, right, right_nullmap)",
          "old_line_content": "                else if constexpr (!Op<LeftDataType, RightDataType>::allow_string_integer)",
          "new_line_content": "                return (res = executeNumeric(arguments, left, right, right_nullmap)) != nullptr;",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": null,
          "new_api": "String",
          "old_text": null,
          "new_text": "String(name)",
          "old_line_content": "                    else",
          "new_line_content": "            arguments[0]->getName(), arguments[1]->getName(), String(name));",
          "content_same": false
        },
        {
          "line": 2116,
          "old_api": null,
          "new_api": "isArray",
          "old_text": null,
          "new_text": "isArray(result_type)",
          "old_line_content": "                    return false;",
          "new_line_content": "        if (isArray(result_type))",
          "content_same": false
        },
        {
          "line": 2117,
          "old_api": null,
          "new_api": "executeArrayImpl",
          "old_text": null,
          "new_text": "executeArrayImpl(arguments, result_type, input_rows_count)",
          "old_line_content": "                else if constexpr (std::is_same_v<DataTypeFixedString, LeftDataType>)",
          "new_line_content": "            return executeArrayImpl(arguments, result_type, input_rows_count);",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "arguments[0].column.get()",
          "old_line_content": "        if (valid)",
          "new_line_content": "        const auto * const col_left_raw = arguments[0].column.get();",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "arguments[1].column.get()",
          "old_line_content": "            return type_res;",
          "new_line_content": "        const auto * const col_right_raw = arguments[1].column.get();",
          "content_same": false
        },
        {
          "line": 2123,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::LOGICAL_ERROR,\n                \"Arguments of '{}' have incorrect data types: '{}' of type '{}',\"\n                \" '{}' of type '{}'\", getName(),\n                left_argument.name, left_argument.type->getName(),\n                right_argument.name, right_argument.type->getName())",
          "old_line_content": "            }",
          "new_line_content": "            throw Exception(ErrorCodes::LOGICAL_ERROR,",
          "content_same": false
        },
        {
          "line": 2126,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "left_argument.type->getName()",
          "old_line_content": "        });",
          "new_line_content": "                left_argument.name, left_argument.type->getName(),",
          "content_same": false
        },
        {
          "line": 2127,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "right_argument.type->getName()",
          "old_line_content": "",
          "new_line_content": "                right_argument.name, right_argument.type->getName());",
          "content_same": false
        },
        {
          "line": 1614,
          "old_api": null,
          "new_api": "checkAndGetColumnConst<ColumnFixedString>(col_right_raw)",
          "old_text": null,
          "new_text": "checkAndGetColumnConst<ColumnFixedString>(col_right_raw)",
          "old_line_content": "    }",
          "new_line_content": "            if (const auto * col_right_const = checkAndGetColumnConst<ColumnFixedString>(col_right_raw))",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": null,
          "new_api": "getDataColumn",
          "old_text": null,
          "new_text": "col_left_const->getDataColumn()",
          "old_line_content": "    ColumnPtr executeFixedString(const ColumnsWithTypeAndName & arguments) const",
          "new_line_content": "                const auto * col_left = checkAndGetColumn<ColumnFixedString>(col_left_const->getDataColumn());",
          "content_same": false
        },
        {
          "line": 1617,
          "old_api": null,
          "new_api": "getDataColumn",
          "old_text": null,
          "new_text": "col_right_const->getDataColumn()",
          "old_line_content": "    {",
          "new_line_content": "                const auto * col_right = checkAndGetColumn<ColumnFixedString>(col_right_const->getDataColumn());",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": null,
          "new_api": "getN",
          "old_text": null,
          "new_text": "col_right->getN()",
          "old_line_content": "        using OpReduceImpl = FixedStringReduceOperationImpl<Op<UInt8, UInt8>>;",
          "new_line_content": "                if (col_left->getN() != col_right->getN())",
          "content_same": false
        },
        {
          "line": 2136,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "arguments.size()",
          "old_line_content": "                \"Arguments of '{}' have incorrect data types: '{}' of type '{}',\"",
          "new_line_content": "        if (2 != arguments.size())",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": null,
          "new_api": "getData",
          "old_text": null,
          "new_text": "col_res->getData()",
          "old_line_content": "        {",
          "new_line_content": "                    auto & data = col_res->getData();",
          "content_same": false
        },
        {
          "line": 2144,
          "old_api": null,
          "new_api": "isDateTime",
          "old_text": null,
          "new_text": "data_type_lhs.isDateTime()",
          "old_line_content": "",
          "new_line_content": "        if ((data_type_lhs.isDateOrDate32() || data_type_lhs.isDateTime()) ||",
          "content_same": false
        },
        {
          "line": 2145,
          "old_api": null,
          "new_api": "isDateTime",
          "old_text": null,
          "new_text": "data_type_rhs.isDateTime()",
          "old_line_content": "#if USE_EMBEDDED_COMPILER",
          "new_line_content": "            (data_type_rhs.isDateOrDate32() || data_type_rhs.isDateTime()))",
          "content_same": false
        },
        {
          "line": 1635,
          "old_api": null,
          "new_api": "getN",
          "old_text": null,
          "new_text": "col_left->getN()",
          "old_line_content": "                {",
          "new_line_content": "                    auto col_res = ColumnFixedString::create(col_left->getN());",
          "content_same": false
        },
        {
          "line": 1649,
          "old_api": null,
          "new_api": "checkAndGetColumnConst<ColumnFixedString>(col_left_raw)",
          "old_text": null,
          "new_text": "checkAndGetColumnConst<ColumnFixedString>(col_left_raw)",
          "old_line_content": "",
          "new_line_content": "        const bool is_left_column_const = checkAndGetColumnConst<ColumnFixedString>(col_left_raw) != nullptr;",
          "content_same": false
        },
        {
          "line": 1654,
          "old_api": null,
          "new_api": "getDataColumn",
          "old_text": null,
          "new_text": "checkAndGetColumnConst<ColumnFixedString>(col_left_raw)->getDataColumn()",
          "old_line_content": "",
          "new_line_content": "                            checkAndGetColumnConst<ColumnFixedString>(col_left_raw)->getDataColumn())",
          "content_same": false
        },
        {
          "line": 2168,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "arguments.size()",
          "old_line_content": "            {",
          "new_line_content": "        assert(2 == arguments.size());",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": null,
          "new_api": "getDataColumn",
          "old_text": null,
          "new_text": "checkAndGetColumn<ColumnFixedString>(\n                            checkAndGetColumnConst<ColumnFixedString>(col_right_raw)->getDataColumn())",
          "old_line_content": "",
          "new_line_content": "                        ? checkAndGetColumn<ColumnFixedString>(",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": null,
          "new_api": "getDataColumn",
          "old_text": null,
          "new_text": "checkAndGetColumnConst<ColumnFixedString>(col_right_raw)->getDataColumn()",
          "old_line_content": "            }",
          "new_line_content": "                            checkAndGetColumnConst<ColumnFixedString>(col_right_raw)->getDataColumn())",
          "content_same": false
        },
        {
          "line": 2171,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "arguments[1].type.get()",
          "old_line_content": "                if constexpr (!std::is_same_v<ResultDataType, InvalidType> && !IsDataTypeDecimal<ResultDataType> && OpSpec::compilable)",
          "new_line_content": "        castBothTypes(arguments[0].type.get(), arguments[1].type.get(), [&](const auto & left, const auto & right)",
          "content_same": false
        },
        {
          "line": 1659,
          "old_api": null,
          "new_api": "checkAndGetColumn<ColumnFixedString>(col_right_raw)",
          "old_text": null,
          "new_text": "checkAndGetColumn<ColumnFixedString>(col_right_raw)",
          "old_line_content": "        }",
          "new_line_content": "                        : checkAndGetColumn<ColumnFixedString>(col_right_raw);",
          "content_same": false
        },
        {
          "line": 1663,
          "old_api": null,
          "new_api": "getN",
          "old_text": null,
          "new_text": "col_right->getN()",
          "old_line_content": "",
          "new_line_content": "            if (col_left->getN() != col_right->getN())",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": null,
          "new_api": "ColumnUInt16::create()",
          "old_text": null,
          "new_text": "ColumnUInt16::create()",
          "old_line_content": "        const auto * col_right = is_right_column_const",
          "new_line_content": "                auto col_res = ColumnUInt16::create();",
          "content_same": false
        },
        {
          "line": 2184,
          "old_api": null,
          "new_api": "static_cast<llvm::IRBuilder<> &>(builder)",
          "old_text": null,
          "new_text": "static_cast<llvm::IRBuilder<> &>(builder)",
          "old_line_content": "        {",
          "new_line_content": "                    auto & b = static_cast<llvm::IRBuilder<> &>(builder);",
          "content_same": false
        },
        {
          "line": 2185,
          "old_api": null,
          "new_api": "nativeCast",
          "old_text": null,
          "new_text": "nativeCast(b, arguments[0], result_type)",
          "old_line_content": "            using LeftDataType = std::decay_t<decltype(left)>;",
          "new_line_content": "                    auto * lval = nativeCast(b, arguments[0], result_type);",
          "content_same": false
        },
        {
          "line": 2186,
          "old_api": null,
          "new_api": "nativeCast",
          "old_text": null,
          "new_text": "nativeCast(b, arguments[1], result_type)",
          "old_line_content": "            using RightDataType = std::decay_t<decltype(right)>;",
          "new_line_content": "                    auto * rval = nativeCast(b, arguments[1], result_type);",
          "content_same": false
        },
        {
          "line": 2187,
          "old_api": null,
          "new_api": "OpSpec::compile(b, lval, rval, std::is_signed_v<typename ResultDataType::FieldType>)",
          "old_text": null,
          "new_text": "OpSpec::compile(b, lval, rval, std::is_signed_v<typename ResultDataType::FieldType>)",
          "old_line_content": "            if constexpr (!std::is_same_v<DataTypeFixedString, LeftDataType> &&",
          "new_line_content": "                    result = OpSpec::compile(b, lval, rval, std::is_signed_v<typename ResultDataType::FieldType>);",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "OpReduceImpl::template process<OpCase::Vector>(\n                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN())",
          "old_line_content": "        {",
          "new_line_content": "                    OpReduceImpl::template process<OpCase::Vector>(",
          "content_same": false
        },
        {
          "line": 1679,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "OpReduceImpl::template process<OpCase::LeftConstant>(\n                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN())",
          "old_line_content": "            {",
          "new_line_content": "                    OpReduceImpl::template process<OpCase::LeftConstant>(",
          "content_same": false
        },
        {
          "line": 1684,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "OpReduceImpl::template process<OpCase::RightConstant>(\n                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN())",
          "old_line_content": "                if (!is_left_column_const && !is_right_column_const)",
          "new_line_content": "                    OpReduceImpl::template process<OpCase::RightConstant>(",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": null,
          "new_api": "getN",
          "old_text": null,
          "new_text": "col_left->getN()",
          "old_line_content": "                {",
          "new_line_content": "                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN());",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": null,
          "new_api": "getDataPtr",
          "old_text": null,
          "new_text": "left_array_col->getDataPtr()",
          "old_line_content": "        /// Unpacking non-const arrays and checking sizes of them.",
          "new_line_content": "        new_arguments[0] = {left_array_col->getDataPtr(), left_array_type, arguments[0].name};",
          "content_same": false
        },
        {
          "line": 1693,
          "old_api": null,
          "new_api": "getChars",
          "old_text": null,
          "new_text": "col_res->getChars()",
          "old_line_content": "                }",
          "new_line_content": "                auto & out_chars = col_res->getChars();",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "arguments[1].type.get()",
          "old_line_content": "        {",
          "new_line_content": "        const auto & right_array_type = typeid_cast<const DataTypeArray *>(arguments[1].type.get())->getNestedType();",
          "content_same": false
        },
        {
          "line": 1694,
          "old_api": null,
          "new_api": "getN",
          "old_text": null,
          "new_text": "col_left->getN()",
          "old_line_content": "                else",
          "new_line_content": "                out_chars.resize((is_right_column_const ? col_left->size() : col_right->size()) * col_left->getN());",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "OpImpl::template process<OpCase::Vector>(\n                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), {})",
          "old_line_content": "                }",
          "new_line_content": "                    OpImpl::template process<OpCase::Vector>(",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "out_chars.size()",
          "old_line_content": "",
          "new_line_content": "                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), {});",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "left_offsets.empty()",
          "old_line_content": "            }",
          "new_line_content": "        if (!left_offsets.empty())",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "left_offsets.back()",
          "old_line_content": "        }",
          "new_line_content": "            rows_count = left_offsets.back();",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": null,
          "new_api": "executeImpl",
          "old_text": null,
          "new_text": "executeImpl(new_arguments, result_array_type, rows_count)",
          "old_line_content": "",
          "new_line_content": "        auto res = executeImpl(new_arguments, result_array_type, rows_count);",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "OpImpl::template process<OpCase::LeftConstant>(\n                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), col_left->getN())",
          "old_line_content": "            {",
          "new_line_content": "                    OpImpl::template process<OpCase::LeftConstant>(",
          "content_same": false
        },
        {
          "line": 2217,
          "old_api": null,
          "new_api": "std::make_shared<FunctionBinaryArithmeticWithConstants>(left_, right_, return_type_, context)",
          "old_text": null,
          "new_text": "std::make_shared<FunctionBinaryArithmeticWithConstants>(left_, right_, return_type_, context)",
          "old_line_content": "class FunctionBinaryArithmeticWithConstants : public FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, division_by_nullable>",
          "new_line_content": "        return std::make_shared<FunctionBinaryArithmeticWithConstants>(left_, right_, return_type_, context);",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "OpImpl::template process<OpCase::RightConstant>(\n                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), col_left->getN())",
          "old_line_content": "                if (!is_left_column_const && !is_right_column_const)",
          "new_line_content": "                    OpImpl::template process<OpCase::RightConstant>(",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": null,
          "new_api": "getN",
          "old_text": null,
          "new_text": "col_left->getN()",
          "old_line_content": "                {",
          "new_line_content": "                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), col_left->getN());",
          "content_same": false
        },
        {
          "line": 2231,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "arguments.size()",
          "old_line_content": "",
          "new_line_content": "        if (left.column && isColumnConst(*left.column) && arguments.size() == 1)",
          "content_same": false
        },
        {
          "line": 1207,
          "old_api": null,
          "new_api": "execute",
          "old_text": null,
          "new_text": "function->execute(new_arguments, result_type, input_rows_count)",
          "old_line_content": "",
          "new_line_content": "        return function->execute(new_arguments, result_type, input_rows_count);",
          "content_same": false
        },
        {
          "line": 2234,
          "old_api": null,
          "new_api": "cloneResized",
          "old_text": null,
          "new_text": "left.column->cloneResized(input_rows_count)",
          "old_line_content": "        const ColumnWithTypeAndName & right_,",
          "new_line_content": "                = {{left.column->cloneResized(input_rows_count), left.type, left.name},",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "arguments[0].column.get()",
          "old_line_content": "",
          "new_line_content": "        const auto * const col_left_raw = arguments[0].column.get();",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "arguments[1].column.get()",
          "old_line_content": "                return col_res;",
          "new_line_content": "        const auto * const col_right_raw = arguments[1].column.get();",
          "content_same": false
        },
        {
          "line": 2237,
          "old_api": null,
          "new_api": "Base::executeImpl(columns_with_constant, result_type, input_rows_count)",
          "old_text": null,
          "new_text": "Base::executeImpl(columns_with_constant, result_type, input_rows_count)",
          "old_line_content": "        : Base(context_), left(left_), right(right_), return_type(return_type_)",
          "new_line_content": "            return Base::executeImpl(columns_with_constant, result_type, input_rows_count);",
          "content_same": false
        },
        {
          "line": 1726,
          "old_api": null,
          "new_api": "checkAndGetColumnConst<ColumnString>(col_left_raw)",
          "old_text": null,
          "new_text": "checkAndGetColumnConst<ColumnString>(col_left_raw)",
          "old_line_content": "        }",
          "new_line_content": "        if (const auto * col_left_const = checkAndGetColumnConst<ColumnString>(col_left_raw))",
          "content_same": false
        },
        {
          "line": 2239,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "arguments.size()",
          "old_line_content": "    }",
          "new_line_content": "        else if (right.column && isColumnConst(*right.column) && arguments.size() == 1)",
          "content_same": false
        },
        {
          "line": 1728,
          "old_api": null,
          "new_api": "checkAndGetColumnConst<ColumnString>(col_right_raw)",
          "old_text": null,
          "new_text": "checkAndGetColumnConst<ColumnString>(col_right_raw)",
          "old_line_content": "    }",
          "new_line_content": "            if (const auto * col_right_const = checkAndGetColumnConst<ColumnString>(col_right_raw))",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": null,
          "new_api": "getDataColumn",
          "old_text": null,
          "new_text": "col_left_const->getDataColumn()",
          "old_line_content": "    /// Only used for bitHammingDistance",
          "new_line_content": "                const auto * col_left = checkAndGetColumn<ColumnString>(col_left_const->getDataColumn());",
          "content_same": false
        },
        {
          "line": 1731,
          "old_api": null,
          "new_api": "getDataColumn",
          "old_text": null,
          "new_text": "col_right_const->getDataColumn()",
          "old_line_content": "    ColumnPtr executeString(const ColumnsWithTypeAndName & arguments) const",
          "new_line_content": "                const auto * col_right = checkAndGetColumn<ColumnString>(col_right_const->getDataColumn());",
          "content_same": false
        },
        {
          "line": 2245,
          "old_api": null,
          "new_api": "Base::executeImpl(columns_with_constant, result_type, input_rows_count)",
          "old_text": null,
          "new_text": "Base::executeImpl(columns_with_constant, result_type, input_rows_count)",
          "old_line_content": "            ColumnsWithTypeAndName columns_with_constant",
          "new_line_content": "            return Base::executeImpl(columns_with_constant, result_type, input_rows_count);",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": null,
          "new_api": "col_const->template getValue<T>()",
          "old_text": null,
          "new_text": "col_const->template getValue<T>()",
          "old_line_content": "",
          "new_line_content": "            return col_const->template getValue<T>();",
          "content_same": false
        },
        {
          "line": 1733,
          "old_api": null,
          "new_api": "toView",
          "old_text": null,
          "new_text": "col_left->getDataAt(0).toView()",
          "old_line_content": "        using OpImpl = StringReduceOperationImpl<Op<UInt8, UInt8>>;",
          "new_line_content": "                std::string_view a = col_left->getDataAt(0).toView();",
          "content_same": false
        },
        {
          "line": 2248,
          "old_api": null,
          "new_api": "Base::executeImpl(arguments, result_type, input_rows_count)",
          "old_text": null,
          "new_text": "Base::executeImpl(arguments, result_type, input_rows_count)",
          "old_line_content": "",
          "new_line_content": "            return Base::executeImpl(arguments, result_type, input_rows_count);",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": null,
          "new_api": "toView",
          "old_text": null,
          "new_text": "col_right->getDataAt(0).toView()",
          "old_line_content": "",
          "new_line_content": "                std::string_view b = col_right->getDataAt(0).toView();",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": null,
          "new_api": "OpImplCheck::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap)",
          "old_text": null,
          "new_text": "OpImplCheck::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap)",
          "old_line_content": "        if constexpr (IsFloatingPoint<ResultDataType> && is_decimal<T>)",
          "new_line_content": "            OpImplCheck::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap);",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": null,
          "new_api": "OpImpl::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap)",
          "old_text": null,
          "new_text": "OpImpl::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap)",
          "old_line_content": "        else if constexpr (is_decimal<T>)",
          "new_line_content": "            OpImpl::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap);",
          "content_same": false
        },
        {
          "line": 1747,
          "old_api": null,
          "new_api": "checkAndGetColumn<ColumnString>(col_left_raw)",
          "old_text": null,
          "new_text": "checkAndGetColumn<ColumnString>(col_left_raw)",
          "old_line_content": "",
          "new_line_content": "            : checkAndGetColumn<ColumnString>(col_left_raw);",
          "content_same": false
        },
        {
          "line": 1749,
          "old_api": null,
          "new_api": "getDataColumn",
          "old_text": null,
          "new_text": "checkAndGetColumnConst<ColumnString>(col_right_raw)->getDataColumn()",
          "old_line_content": "",
          "new_line_content": "            ? checkAndGetColumn<ColumnString>(checkAndGetColumnConst<ColumnString>(col_right_raw)->getDataColumn())",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": null,
          "new_api": "isNull",
          "old_text": null,
          "new_text": "right_point.isNull()",
          "old_line_content": "",
          "new_line_content": "        if (left_point.isNull() || right_point.isNull())",
          "content_same": false
        },
        {
          "line": 2267,
          "old_api": null,
          "new_api": "isColumnConst",
          "old_text": null,
          "new_text": "isColumnConst(*right.column)",
          "old_line_content": "    }",
          "new_line_content": "                if (right.column && isColumnConst(*right.column))",
          "content_same": false
        },
        {
          "line": 1756,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "col_right->size()",
          "old_line_content": "",
          "new_line_content": "            data.resize(is_right_column_const ? col_left->size() : col_right->size());",
          "content_same": false
        },
        {
          "line": 2270,
          "old_api": null,
          "new_api": "Field",
          "old_text": null,
          "new_text": "Field(0)",
          "old_line_content": "    {",
          "new_line_content": "                    if (applyVisitor(FieldVisitorAccurateEquals(), constant, Field(0)))",
          "content_same": false
        },
        {
          "line": 2272,
          "old_api": null,
          "new_api": "Field",
          "old_text": null,
          "new_text": "Field(0)",
          "old_line_content": "",
          "new_line_content": "                    bool is_constant_positive = applyVisitor(FieldVisitorAccurateLess(), Field(0), constant);",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": null,
          "new_api": "getChars",
          "old_text": null,
          "new_text": "OpImpl::vectorVector(\n                    col_left->getChars(), col_left->getOffsets(), col_right->getChars(), col_right->getOffsets(), data)",
          "old_line_content": "        const auto * col_right = is_right_column_const",
          "new_line_content": "                OpImpl::vectorVector(",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "        size_t col_left_size, const NullMap * right_nullmap) const",
          "new_line_content": "        static constexpr const bool left_is_decimal = is_decimal<T0>;",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "    {",
          "new_line_content": "        static constexpr const bool right_is_decimal = is_decimal<T1>;",
          "content_same": false
        },
        {
          "line": 1765,
          "old_api": null,
          "new_api": "toView",
          "old_text": null,
          "new_text": "col_left->getDataAt(0).toView()",
          "old_line_content": "        {",
          "new_line_content": "                std::string_view str_view = col_left->getDataAt(0).toView();",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": null,
          "new_api": "decimalResultType<is_multiply, is_division>(left, right)",
          "old_text": null,
          "new_text": "decimalResultType<is_multiply, is_division>(left, right)",
          "old_line_content": "",
          "new_line_content": "        const ResultDataType type = decimalResultType<is_multiply, is_division>(left, right);",
          "content_same": false
        },
        {
          "line": 1257,
          "old_api": null,
          "new_api": "getScaleMultiplier",
          "old_text": null,
          "new_text": "[&]\n        {\n            if constexpr (IsDataTypeDecimal<RightDataType> && is_division)\n                return right.getScaleMultiplier(); // the division impl uses only the scale_a\n            else\n            {\n                if constexpr (is_multiply)\n                    // the decimal impl uses scales, but if the result is decimal, both of the arguments are decimal,\n                    // so they would multiply correctly, so we need to scale the result to the neutral element (1).\n                    // The explicit type is needed as the int (in contrast with float) can't be implicitly converted\n                    // to decimal.\n                    return ResultType{1};\n                else\n                    return type.scaleFactorFor(left, false);\n            }\n        }()",
          "old_line_content": "        using OpImpl = DecimalBinaryOperation<Op, ResultType, false>;",
          "new_line_content": "        const ResultType scale_a = [&]",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": null,
          "new_api": "toView",
          "old_text": null,
          "new_text": "col_right->getDataAt(0).toView()",
          "old_line_content": "            if (!is_left_column_const && !is_right_column_const)",
          "new_line_content": "                std::string_view str_view = col_right->getDataAt(0).toView();",
          "content_same": false
        },
        {
          "line": 1771,
          "old_api": null,
          "new_api": "getOffsets",
          "old_text": null,
          "new_text": "col_left->getOffsets()",
          "old_line_content": "            {",
          "new_line_content": "                OpImpl::vectorConstant(col_left->getChars(), col_left->getOffsets(), str_view, data);",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": null,
          "new_api": "getScaleMultiplier",
          "old_text": null,
          "new_text": "right.getScaleMultiplier()",
          "old_line_content": "        using ColVecResult = ColumnVectorOrDecimal<ResultType>;",
          "new_line_content": "                return right.getScaleMultiplier(); // the division impl uses only the scale_a",
          "content_same": false
        },
        {
          "line": 2288,
          "old_api": null,
          "new_api": "isColumnConst",
          "old_text": null,
          "new_text": "isColumnConst(*left.column)",
          "old_line_content": "                }",
          "new_line_content": "            if (left.column && isColumnConst(*left.column))",
          "content_same": false
        },
        {
          "line": 2290,
          "old_api": null,
          "new_api": "removeLowCardinality",
          "old_text": null,
          "new_text": "removeLowCardinality(left.type)",
          "old_line_content": "            return {false, true, false, false};",
          "new_line_content": "                auto left_type = removeNullable(removeLowCardinality(left.type));",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": null,
          "new_api": "removeLowCardinality",
          "old_text": null,
          "new_text": "removeLowCardinality(right.type)",
          "old_line_content": "        }",
          "new_line_content": "                auto right_type = removeNullable(removeLowCardinality(right.type));",
          "content_same": false
        },
        {
          "line": 2292,
          "old_api": null,
          "new_api": "removeLowCardinality",
          "old_text": null,
          "new_text": "removeLowCardinality(return_type)",
          "old_line_content": "",
          "new_line_content": "                auto ret_type = removeNullable(removeLowCardinality(return_type));",
          "content_same": false
        },
        {
          "line": 1270,
          "old_api": null,
          "new_api": "scaleFactorFor",
          "old_text": null,
          "new_text": "type.scaleFactorFor(left, false)",
          "old_line_content": "        {",
          "new_line_content": "                    return type.scaleFactorFor(left, false);",
          "content_same": false
        },
        {
          "line": 2297,
          "old_api": null,
          "new_api": "createColumnConst",
          "old_text": null,
          "new_text": "left_type->createColumnConst(1, (*left.column)[0])",
          "old_line_content": "        if (name_view == \"minus\" || name_view == \"plus\")",
          "new_line_content": "                        = {{left_type->createColumnConst(1, (*left.column)[0]), left_type, left.name},",
          "content_same": false
        },
        {
          "line": 2298,
          "old_api": null,
          "new_api": "createColumnConst",
          "old_text": null,
          "new_text": "right_type->createColumnConst(1, point)",
          "old_line_content": "        {",
          "new_line_content": "                           {right_type->createColumnConst(1, point), right_type, right.name}};",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": null,
          "new_api": "scaleFactorFor",
          "old_text": null,
          "new_text": "[&]\n        {\n                if constexpr (is_multiply)\n                    return ResultType{1};\n                else\n                    return type.scaleFactorFor(right, is_division);\n        }()",
          "old_line_content": "            {",
          "new_line_content": "        const ResultType scale_b = [&]",
          "content_same": false
        },
        {
          "line": 1785,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "arguments[0].column.get()",
          "old_line_content": "",
          "new_line_content": "        const auto * const col_left_raw = arguments[0].column.get();",
          "content_same": false
        },
        {
          "line": 1786,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "arguments[1].column.get()",
          "old_line_content": "            return col_res;",
          "new_line_content": "        const auto * const col_right_raw = arguments[1].column.get();",
          "content_same": false
        },
        {
          "line": 1790,
          "old_api": null,
          "new_api": "checkAndGetColumn<ColVecT1>(col_right_raw)",
          "old_text": null,
          "new_text": "checkAndGetColumn<ColVecT1>(col_right_raw)",
          "old_line_content": "",
          "new_line_content": "        const ColVecT1 * const col_right = checkAndGetColumn<ColVecT1>(col_right_raw);",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": null,
          "new_api": "scaleFactorFor",
          "old_text": null,
          "new_text": "type.scaleFactorFor(right, is_division)",
          "old_line_content": "                    // to decimal.",
          "new_line_content": "                    return type.scaleFactorFor(right, is_division);",
          "content_same": false
        },
        {
          "line": 1791,
          "old_api": null,
          "new_api": "checkAndGetColumnConst<ColVecT1>(col_right_raw)",
          "old_text": null,
          "new_text": "checkAndGetColumnConst<ColVecT1>(col_right_raw)",
          "old_line_content": "template <typename LeftColumnType, typename A, typename B>",
          "new_line_content": "        const ColumnConst * const col_right_const = checkAndGetColumnConst<ColVecT1>(col_right_raw);",
          "content_same": false
        },
        {
          "line": 2305,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "col->get(0, point_transformed)",
          "old_line_content": "",
          "new_line_content": "                    col->get(0, point_transformed);",
          "content_same": false
        },
        {
          "line": 1795,
          "old_api": null,
          "new_api": "checkAndGetColumnConst<LeftColumnType>(col_left_raw)",
          "old_text": null,
          "new_text": "checkAndGetColumnConst<LeftColumnType>(col_left_raw)",
          "old_line_content": "        using RightDataType = std::decay_t<decltype(right)>;",
          "new_line_content": "        const ColumnConst * const col_left_const = checkAndGetColumnConst<LeftColumnType>(col_left_raw);",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": null,
          "new_api": "static_cast<NativeResultType>(\n                helperGetOrConvert<T0, ResultDataType>(col_left_const, left))",
          "old_text": null,
          "new_text": "static_cast<NativeResultType>(\n                helperGetOrConvert<T0, ResultDataType>(col_left_const, left))",
          "old_line_content": "",
          "new_line_content": "            const NativeResultType const_a = static_cast<NativeResultType>(",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": null,
          "new_api": "static_cast<NativeResultType>(\n                helperGetOrConvert<T1, ResultDataType>(col_right_const, right))",
          "old_text": null,
          "new_text": "static_cast<NativeResultType>(\n                helperGetOrConvert<T1, ResultDataType>(col_right_const, right))",
          "old_line_content": "        {",
          "new_line_content": "            const NativeResultType const_b = static_cast<NativeResultType>(",
          "content_same": false
        },
        {
          "line": 1288,
          "old_api": null,
          "new_api": "helperGetOrConvert<T1, ResultDataType>(col_right_const, right)",
          "old_text": null,
          "new_text": "helperGetOrConvert<T1, ResultDataType>(col_right_const, right)",
          "old_line_content": "                if constexpr (is_multiply)",
          "new_line_content": "                helperGetOrConvert<T1, ResultDataType>(col_right_const, right));",
          "content_same": false
        },
        {
          "line": 1293,
          "old_api": null,
          "new_api": "OpImplCheck::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b)",
          "old_text": null,
          "new_text": "OpImplCheck::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b)",
          "old_line_content": "",
          "new_line_content": "                    ? OpImplCheck::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b)",
          "content_same": false
        },
        {
          "line": 1294,
          "old_api": null,
          "new_api": "OpImpl::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b)",
          "old_text": null,
          "new_text": "OpImpl::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b)",
          "old_line_content": "        /// non-vector result",
          "new_line_content": "                    : OpImpl::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b);",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": null,
          "new_api": "getScale",
          "old_text": null,
          "new_text": "type.getScale()",
          "old_line_content": "        {",
          "new_line_content": "            return ResultDataType(type.getPrecision(), type.getScale())",
          "content_same": false
        },
        {
          "line": 1811,
          "old_api": null,
          "new_api": "getChars",
          "old_text": null,
          "new_text": "col_res->getChars()",
          "old_line_content": "",
          "new_line_content": "        typename LeftColumnType::Chars & out_vec = col_res->getChars();",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": null,
          "new_api": "getData",
          "old_text": null,
          "new_text": "col_res->getData()",
          "old_line_content": "            ResultType res = {};",
          "new_line_content": "        auto & vec_res = col_res->getData();",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "vec_res.resize(col_left_size)",
          "old_line_content": "            if (!right_nullmap || !(*right_nullmap)[0])",
          "new_line_content": "        vec_res.resize(col_left_size);",
          "content_same": false
        },
        {
          "line": 2330,
          "old_api": null,
          "new_api": "isColumnConst",
          "old_text": null,
          "new_text": "isColumnConst(*right.column)",
          "old_line_content": "                        return {false, true, false, false};",
          "new_line_content": "            else if (right.column && isColumnConst(*right.column))",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": null,
          "new_api": "getData",
          "old_text": null,
          "new_text": "helperInvokeEither<OpCase::Vector, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(\n                col_left->getData(), col_right->getData(), vec_res, scale_a, scale_b, right_nullmap)",
          "old_line_content": "",
          "new_line_content": "            helperInvokeEither<OpCase::Vector, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": null,
          "new_api": "removeLowCardinality",
          "old_text": null,
          "new_text": "removeLowCardinality(left.type)",
          "old_line_content": "                else",
          "new_line_content": "                auto left_type = removeNullable(removeLowCardinality(left.type));",
          "content_same": false
        },
        {
          "line": 2333,
          "old_api": null,
          "new_api": "removeLowCardinality",
          "old_text": null,
          "new_text": "removeLowCardinality(right.type)",
          "old_line_content": "                {",
          "new_line_content": "                auto right_type = removeNullable(removeLowCardinality(right.type));",
          "content_same": false
        },
        {
          "line": 2334,
          "old_api": null,
          "new_api": "removeLowCardinality",
          "old_text": null,
          "new_text": "removeLowCardinality(return_type)",
          "old_line_content": "                    // Check if there is an overflow",
          "new_line_content": "                auto ret_type = removeNullable(removeLowCardinality(return_type));",
          "content_same": false
        },
        {
          "line": 1818,
          "old_api": null,
          "new_api": "getN",
          "old_text": null,
          "new_text": "col_left->getN()",
          "old_line_content": "        if constexpr (std::is_same_v<LeftDataType, DataTypeFixedString>)",
          "new_line_content": "                OpImpl::template processFixedString<OpCase::Vector>(in_vec.data(), col_left->getN(), &value, out_vec, 1);",
          "content_same": false
        },
        {
          "line": 1822,
          "old_api": null,
          "new_api": "getOffsets",
          "old_text": null,
          "new_text": "col_res->getOffsets()",
          "old_line_content": "",
          "new_line_content": "                ColumnString::Offsets & out_offsets = col_res->getOffsets();",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": null,
          "new_api": "helperGetOrConvert<T0, ResultDataType>(col_left_const, left)",
          "old_text": null,
          "new_text": "helperGetOrConvert<T0, ResultDataType>(col_left_const, left)",
          "old_line_content": "",
          "new_line_content": "                helperGetOrConvert<T0, ResultDataType>(col_left_const, left));",
          "content_same": false
        },
        {
          "line": 1826,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "col_left_const->size()",
          "old_line_content": "        {",
          "new_line_content": "            return ColumnConst::create(std::move(col_res), col_left_const->size());",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": null,
          "new_api": "createColumnConst",
          "old_text": null,
          "new_text": "left_type->createColumnConst(1, point)",
          "old_line_content": "                }",
          "new_line_content": "                        = {{left_type->createColumnConst(1, point), left_type, left.name},",
          "content_same": false
        },
        {
          "line": 2340,
          "old_api": null,
          "new_api": "createColumnConst",
          "old_text": null,
          "new_text": "right_type->createColumnConst(1, (*right.column)[0])",
          "old_line_content": "            }",
          "new_line_content": "                           {right_type->createColumnConst(1, (*right.column)[0]), right_type, right.name}};",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": null,
          "new_api": "getData",
          "old_text": null,
          "new_text": "col_right->getData()",
          "old_line_content": "",
          "new_line_content": "                const_a, col_right->getData(), vec_res, scale_a, scale_b, right_nullmap);",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "col_left->size()",
          "old_line_content": "            else",
          "new_line_content": "                OpImpl::template processFixedString<OpCase::Vector>(in_vec.data(), col_left->getN(), col_right->getData().data(), out_vec, col_left->size());",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": null,
          "new_api": "helperGetOrConvert<T1, ResultDataType>(col_right_const, right)",
          "old_text": null,
          "new_text": "helperGetOrConvert<T1, ResultDataType>(col_right_const, right)",
          "old_line_content": "        }",
          "new_line_content": "                helperGetOrConvert<T1, ResultDataType>(col_right_const, right));",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": null,
          "new_api": "getData",
          "old_text": null,
          "new_text": "helperInvokeEither<OpCase::RightConstant, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(\n                col_left->getData(), const_b, vec_res, scale_a, scale_b, right_nullmap)",
          "old_line_content": "        {",
          "new_line_content": "            helperInvokeEither<OpCase::RightConstant, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(",
          "content_same": false
        },
        {
          "line": 1836,
          "old_api": null,
          "new_api": "getOffsets",
          "old_text": null,
          "new_text": "col_res->getOffsets()",
          "old_line_content": "            }",
          "new_line_content": "                ColumnString::Offsets & out_offsets = col_res->getOffsets();",
          "content_same": false
        },
        {
          "line": 2349,
          "old_api": null,
          "new_api": "FieldVisitorAccurateLess",
          "old_text": null,
          "new_text": "FieldVisitorAccurateLess()",
          "old_line_content": "                {",
          "new_line_content": "                if (applyVisitor(FieldVisitorAccurateLess(), left_point, right_point)",
          "content_same": false
        },
        {
          "line": 2350,
          "old_api": null,
          "new_api": "transform",
          "old_text": null,
          "new_text": "transform(right_point)",
          "old_line_content": "                    ColumnsWithTypeAndName columns_with_constant",
          "new_line_content": "                    == applyVisitor(FieldVisitorAccurateLess(), transform(left_point), transform(right_point)))",
          "content_same": false
        },
        {
          "line": 1837,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "col_left->size()",
          "old_line_content": "",
          "new_line_content": "                out_offsets.reserve(col_left->size());",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "col_left->size()",
          "old_line_content": "        }",
          "new_line_content": "                    in_vec.data(), col_left->getOffsets().data(), col_right->getData().data(), out_vec, out_offsets, col_left->size());",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": null,
          "new_api": "std::make_shared<FunctionBinaryArithmetic>(context)",
          "old_text": null,
          "new_text": "std::make_shared<FunctionBinaryArithmetic>(context)",
          "old_line_content": "",
          "new_line_content": "    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionBinaryArithmetic>(context); }",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "OpImpl::template processFixedString<OpCase::LeftConstant>(\n                    in_vec.data(), col_left->getN(), col_right->getData().data(), out_vec, col_right->size())",
          "old_line_content": "            else",
          "new_line_content": "                OpImpl::template processFixedString<OpCase::LeftConstant>(",
          "content_same": false
        },
        {
          "line": 1847,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "col_right->size()",
          "old_line_content": "            {",
          "new_line_content": "                    in_vec.data(), col_left->getN(), col_right->getData().data(), out_vec, col_right->size());",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": null,
          "new_api": "decimalCheckArithmeticOverflow",
          "old_text": null,
          "new_text": "decimalCheckArithmeticOverflow(context)",
          "old_line_content": "        else",
          "new_line_content": "        check_decimal_overflow(decimalCheckArithmeticOverflow(context))",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": null,
          "new_api": "Field",
          "old_text": null,
          "new_text": "Field(0)",
          "old_line_content": "                else",
          "new_line_content": "                if (applyVisitor(FieldVisitorAccurateEquals(), constant, Field(0)))",
          "content_same": false
        },
        {
          "line": 1852,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "col_right->size()",
          "old_line_content": "            }",
          "new_line_content": "                out_offsets.reserve(col_right->size());",
          "content_same": false
        },
        {
          "line": 1853,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "OpImpl::template processString<OpCase::LeftConstant>(\n                    in_vec.data(), col_left->getOffsets().data(), col_right->getData().data(), out_vec, out_offsets, col_right->size())",
          "old_line_content": "        }",
          "new_line_content": "                OpImpl::template processString<OpCase::LeftConstant>(",
          "content_same": false
        },
        {
          "line": 2367,
          "old_api": null,
          "new_api": "Field",
          "old_text": null,
          "new_text": "Field(0)",
          "old_line_content": "        }",
          "new_line_content": "                bool is_constant_positive = applyVisitor(FieldVisitorAccurateLess(), Field(0), constant);",
          "content_same": false
        },
        {
          "line": 2368,
          "old_api": null,
          "new_api": "Field",
          "old_text": null,
          "new_text": "Field(0)",
          "old_line_content": "        if (name_view == \"divide\" || name_view == \"intDiv\")",
          "new_line_content": "                if (applyVisitor(FieldVisitorAccurateLess(), left_point, Field(0))",
          "content_same": false
        },
        {
          "line": 2369,
          "old_api": null,
          "new_api": "Field",
          "old_text": null,
          "new_text": "Field(0)",
          "old_line_content": "        {",
          "new_line_content": "                    && applyVisitor(FieldVisitorAccurateLess(), right_point, Field(0)))",
          "content_same": false
        },
        {
          "line": 1854,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "col_right->size()",
          "old_line_content": "        else if (col_left_const && col_right)",
          "new_line_content": "                    in_vec.data(), col_left->getOffsets().data(), col_right->getData().data(), out_vec, out_offsets, col_right->size());",
          "content_same": false
        },
        {
          "line": 2374,
          "old_api": null,
          "new_api": "Field",
          "old_text": null,
          "new_text": "Field(0)",
          "old_line_content": "            {",
          "new_line_content": "                    applyVisitor(FieldVisitorAccurateLess(), Field(0), left_point)",
          "content_same": false
        },
        {
          "line": 2375,
          "old_api": null,
          "new_api": "Field",
          "old_text": null,
          "new_text": "Field(0)",
          "old_line_content": "                auto constant = (*left.column)[0];",
          "new_line_content": "                    && applyVisitor(FieldVisitorAccurateLess(), Field(0), right_point))",
          "content_same": false
        },
        {
          "line": 1862,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "col_left->size()",
          "old_line_content": "            {",
          "new_line_content": "                OpImpl::template processFixedString<OpCase::RightConstant>(in_vec.data(), col_left->getN(), &value, out_vec, col_left->size());",
          "content_same": false
        },
        {
          "line": 1867,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "col_left->size()",
          "old_line_content": "            }",
          "new_line_content": "                out_offsets.reserve(col_left->size());",
          "content_same": false
        },
        {
          "line": 1868,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "OpImpl::template processString<OpCase::RightConstant>(\n                    in_vec.data(), col_left->getOffsets().data(), &value, out_vec, out_offsets, col_left->size())",
          "old_line_content": "        }",
          "new_line_content": "                OpImpl::template processString<OpCase::RightConstant>(",
          "content_same": false
        },
        {
          "line": 1357,
          "old_api": null,
          "new_api": "isDecimalOrNullableDecimal",
          "old_text": null,
          "new_text": "isDecimalOrNullableDecimal(arguments[1].type)",
          "old_line_content": "    bool useDefaultImplementationForNulls() const override",
          "new_line_content": "                && (isDecimalOrNullableDecimal(arguments[0].type) || isDecimalOrNullableDecimal(arguments[1].type)));",
          "content_same": false
        },
        {
          "line": 1869,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "col_left->size()",
          "old_line_content": "        else if (col_right_const)",
          "new_line_content": "                    in_vec.data(), col_left->getOffsets().data(), &value, out_vec, out_offsets, col_left->size());",
          "content_same": false
        },
        {
          "line": 2384,
          "old_api": null,
          "new_api": "Field",
          "old_text": null,
          "new_text": "Field(0)",
          "old_line_content": "                }",
          "new_line_content": "                if (applyVisitor(FieldVisitorAccurateEquals(), constant, Field(0)))",
          "content_same": false
        },
        {
          "line": 1362,
          "old_api": null,
          "new_api": "getReturnTypeImplStatic",
          "old_text": null,
          "new_text": "getReturnTypeImplStatic(arguments, context)",
          "old_line_content": "        return !division_by_nullable;",
          "new_line_content": "        return getReturnTypeImplStatic(arguments, context);",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": null,
          "new_api": "isAggregateMultiply",
          "old_text": null,
          "new_text": "isAggregateMultiply(arguments[0], arguments[1])",
          "old_line_content": "            || (IsOperation<Op>::div_floating",
          "new_line_content": "        if (isAggregateMultiply(arguments[0], arguments[1]))",
          "content_same": false
        },
        {
          "line": 1370,
          "old_api": null,
          "new_api": "isAggregateFunction",
          "old_text": null,
          "new_text": "WhichDataType(arguments[0]).isAggregateFunction()",
          "old_line_content": "    }",
          "new_line_content": "            if (WhichDataType(arguments[0]).isAggregateFunction())",
          "content_same": false
        },
        {
          "line": 1376,
          "old_api": null,
          "new_api": "isAggregateAddition",
          "old_text": null,
          "new_text": "isAggregateAddition(arguments[0], arguments[1])",
          "old_line_content": "",
          "new_line_content": "        if (isAggregateAddition(arguments[0], arguments[1]))",
          "content_same": false
        },
        {
          "line": 1378,
          "old_api": null,
          "new_api": "equals",
          "old_text": null,
          "new_text": "arguments[0]->equals(*arguments[1])",
          "old_line_content": "    {",
          "new_line_content": "            if (!arguments[0]->equals(*arguments[1]))",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "Exception(ErrorCodes::CANNOT_ADD_DIFFERENT_AGGREGATE_STATES,\n                    \"Cannot add aggregate states of different functions: {} and {}\",\n                    arguments[0]->getName(), arguments[1]->getName())",
          "old_line_content": "        /// Special case when multiply aggregate function state",
          "new_line_content": "                throw Exception(ErrorCodes::CANNOT_ADD_DIFFERENT_AGGREGATE_STATES,",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "    template <typename A, typename B>",
          "new_line_content": "            constexpr bool decimal_with_float = (IsDataTypeDecimal<LeftDataType> && IsFloatingPoint<RightDataType>)",
          "content_same": false
        },
        {
          "line": 2405,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "    }",
          "new_line_content": "    static constexpr auto name = Name::name;",
          "content_same": false
        },
        {
          "line": 1381,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "arguments[1]->getName()",
          "old_line_content": "        {",
          "new_line_content": "                    arguments[0]->getName(), arguments[1]->getName());",
          "content_same": false
        },
        {
          "line": 2408,
          "old_api": null,
          "new_api": "std::make_unique<BinaryArithmeticOverloadResolver>(context)",
          "old_text": null,
          "new_text": "std::make_unique<BinaryArithmeticOverloadResolver>(context)",
          "old_line_content": "    ColumnWithTypeAndName left;",
          "new_line_content": "        return std::make_unique<BinaryArithmeticOverloadResolver>(context);",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "};",
          "new_line_content": "    explicit BinaryArithmeticOverloadResolver(ContextPtr context_) : context(context_) {}",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": null,
          "new_api": "isIPv4",
          "old_text": null,
          "new_text": "isIPv4(arguments[1])",
          "old_line_content": "        /// Special case - addition of two aggregate functions states",
          "new_line_content": "        if (isIPv4(arguments[0]) || isIPv4(arguments[1]))",
          "content_same": false
        },
        {
          "line": 1394,
          "old_api": null,
          "new_api": "getReturnTypeImplStatic",
          "old_text": null,
          "new_text": "getReturnTypeImplStatic(new_arguments, context)",
          "old_line_content": "",
          "new_line_content": "            return getReturnTypeImplStatic(new_arguments, context);",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": null,
          "new_api": "std::make_shared<DataTypeFloat64>()",
          "old_text": null,
          "new_text": "std::make_shared<DataTypeFloat64>()",
          "old_line_content": "            using T1 = std::conditional_t<decimal_with_float, Float64, typename RightDataType::FieldType>;",
          "new_line_content": "                const auto converted_type = std::make_shared<DataTypeFloat64>();",
          "content_same": false
        },
        {
          "line": 1907,
          "old_api": null,
          "new_api": "castColumn",
          "old_text": null,
          "new_text": "castColumn(arguments[0], converted_type)",
          "old_line_content": "            using ResultType = typename ResultDataType::FieldType;",
          "new_line_content": "                left_col = castColumn(arguments[0], converted_type);",
          "content_same": false
        },
        {
          "line": 2421,
          "old_api": null,
          "new_api": "isNullable",
          "old_text": null,
          "new_text": "arguments[1].type->isNullable()",
          "old_line_content": "    }",
          "new_line_content": "        bool division_by_nullable = !arguments[0].type->onlyNull() && !arguments[1].type->onlyNull() && arguments[1].type->isNullable()",
          "content_same": false
        },
        {
          "line": 1908,
          "old_api": null,
          "new_api": "castColumn",
          "old_text": null,
          "new_text": "castColumn(arguments[1], converted_type)",
          "old_line_content": "            using ColVecT0 = ColumnVectorOrDecimal<T0>;",
          "new_line_content": "                right_col = castColumn(arguments[1], converted_type);",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": null,
          "new_api": "isDecimalOrNullableDecimal",
          "old_text": null,
          "new_text": "isDecimalOrNullableDecimal(arguments[1].type)",
          "old_line_content": "",
          "new_line_content": "                    && (isDecimalOrNullableDecimal(arguments[0].type) || isDecimalOrNullableDecimal(arguments[1].type))));",
          "content_same": false
        },
        {
          "line": 1400,
          "old_api": null,
          "new_api": "isArray",
          "old_text": null,
          "new_text": "isArray(arguments[1])",
          "old_line_content": "        {",
          "new_line_content": "            if (isArray(arguments[0]) && isArray(arguments[1]))",
          "content_same": false
        },
        {
          "line": 2427,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "arguments.size()",
          "old_line_content": "    bool isVariadic() const override { return false; }",
          "new_line_content": "        if (arguments.size() == 2",
          "content_same": false
        },
        {
          "line": 2428,
          "old_api": null,
          "new_api": "isColumnConst",
          "old_text": null,
          "new_text": "isColumnConst(*arguments[0].column)",
          "old_line_content": "",
          "new_line_content": "            && ((arguments[0].column && isColumnConst(*arguments[0].column))",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": null,
          "new_api": "isColumnConst",
          "old_text": null,
          "new_text": "isColumnConst(*arguments[1].column)",
          "old_line_content": "    FunctionBasePtr buildImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & return_type) const override",
          "new_line_content": "                || (arguments[1].column && isColumnConst(*arguments[1].column))))",
          "content_same": false
        },
        {
          "line": 1404,
          "old_api": null,
          "new_api": "getNestedType",
          "old_text": null,
          "new_text": "static_cast<const DataTypeArray &>(*arguments[1]).getNestedType()",
          "old_line_content": "            };",
          "new_line_content": "                        static_cast<const DataTypeArray &>(*arguments[1]).getNestedType(),",
          "content_same": false
        },
        {
          "line": 2431,
          "old_api": null,
          "new_api": "FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments, true>::create(\n                    arguments[0], arguments[1], return_type, context)",
          "old_text": null,
          "new_text": "FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments, true>::create(\n                    arguments[0], arguments[1], return_type, context)",
          "old_line_content": "        /// Check the case when operation is divide, intDiv or modulo and denominator is Nullable(Something).",
          "new_line_content": "            auto function = division_by_nullable ? FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments, true>::create(",
          "content_same": false
        },
        {
          "line": 1915,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "left_col.get()",
          "old_line_content": "            /// When Decimal op Float32/64, convert both of them into Float64",
          "new_line_content": "            const auto * const col_left_raw = left_col.get();",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "right_col.get()",
          "old_line_content": "            if constexpr (decimal_with_float)",
          "new_line_content": "            const auto * const col_right_raw = right_col.get();",
          "content_same": false
        },
        {
          "line": 1921,
          "old_api": null,
          "new_api": "checkAndGetColumnConst<ColVecT1>(col_right_raw)",
          "old_text": null,
          "new_text": "checkAndGetColumnConst<ColVecT1>(col_right_raw)",
          "old_line_content": "            }",
          "new_line_content": "            const ColumnConst * const col_right_const = checkAndGetColumnConst<ColVecT1>(col_right_raw);",
          "content_same": false
        },
        {
          "line": 1923,
          "old_api": null,
          "new_api": "checkAndGetColumn<ColVecT0>(col_left_raw)",
          "old_text": null,
          "new_text": "checkAndGetColumn<ColVecT0>(col_left_raw)",
          "old_line_content": "            {",
          "new_line_content": "            const ColVecT0 * const col_left = checkAndGetColumn<ColVecT0>(col_left_raw);",
          "content_same": false
        },
        {
          "line": 1924,
          "old_api": null,
          "new_api": "checkAndGetColumn<ColVecT1>(col_right_raw)",
          "old_text": null,
          "new_text": "checkAndGetColumn<ColVecT1>(col_right_raw)",
          "old_line_content": "                left_col = arguments[0].column;",
          "new_line_content": "            const ColVecT1 * const col_right = checkAndGetColumn<ColVecT1>(col_right_raw);",
          "content_same": false
        },
        {
          "line": 2438,
          "old_api": null,
          "new_api": "collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; })",
          "old_text": null,
          "new_text": "collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; })",
          "old_line_content": "        /// More efficient specialization for two numeric arguments.",
          "new_line_content": "                collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),",
          "content_same": false
        },
        {
          "line": 2442,
          "old_api": null,
          "new_api": "FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, true>::create(context)",
          "old_text": null,
          "new_text": "FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, true>::create(context)",
          "old_line_content": "        {",
          "new_line_content": "            ? FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, true>::create(context)",
          "content_same": false
        },
        {
          "line": 1420,
          "old_api": null,
          "new_api": "isDateTime64",
          "old_text": null,
          "new_text": "isDateTime64(new_arguments[1].type)",
          "old_line_content": "        }",
          "new_line_content": "            if (isDateOrDate32(new_arguments[1].type) || isDateTime(new_arguments[1].type) || isDateTime64(new_arguments[1].type))",
          "content_same": false
        },
        {
          "line": 1421,
          "old_api": null,
          "new_api": "std::swap(new_arguments[0], new_arguments[1])",
          "old_text": null,
          "new_text": "std::swap(new_arguments[0], new_arguments[1])",
          "old_line_content": "",
          "new_line_content": "                std::swap(new_arguments[0], new_arguments[1]);",
          "content_same": false
        },
        {
          "line": 2447,
          "old_api": null,
          "new_api": "collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; })",
          "old_text": null,
          "new_text": "collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; })",
          "old_line_content": "",
          "new_line_content": "            collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),",
          "content_same": false
        },
        {
          "line": 1426,
          "old_api": null,
          "new_api": "build",
          "old_text": null,
          "new_text": "function_builder->build(new_arguments)",
          "old_line_content": "            ColumnsWithTypeAndName new_arguments(2);",
          "new_line_content": "            auto function = function_builder->build(new_arguments);",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": null,
          "new_api": "getResultType",
          "old_text": null,
          "new_text": "function->getResultType()",
          "old_line_content": "",
          "new_line_content": "            return function->getResultType();",
          "content_same": false
        },
        {
          "line": 1431,
          "old_api": null,
          "new_api": "getFunctionForTupleArithmetic",
          "old_text": null,
          "new_text": "getFunctionForTupleArithmetic(arguments[0], arguments[1], context)",
          "old_line_content": "            /// Interval argument must be second.",
          "new_line_content": "        if (auto function_builder = getFunctionForTupleArithmetic(arguments[0], arguments[1], context))",
          "content_same": false
        },
        {
          "line": 1943,
          "old_api": null,
          "new_api": "OpImpl::process(\n                        col_left_const->template getValue<T0>(),\n                        col_right_const->template getValue<T1>())",
          "old_text": null,
          "new_text": "OpImpl::process(\n                        col_left_const->template getValue<T0>(),\n                        col_right_const->template getValue<T1>())",
          "old_line_content": "                    col_left, col_right,",
          "new_line_content": "                    const auto res = right_nullmap && (*right_nullmap)[0] ? ResultType() : OpImpl::process(",
          "content_same": false
        },
        {
          "line": 1944,
          "old_api": null,
          "new_api": "col_left_const->template getValue<T0>()",
          "old_text": null,
          "new_text": "col_left_const->template getValue<T0>()",
          "old_line_content": "                    col_left_size,",
          "new_line_content": "                        col_left_const->template getValue<T0>(),",
          "content_same": false
        },
        {
          "line": 2458,
          "old_api": null,
          "new_api": "FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments>::getReturnTypeImplStatic(arguments, context)",
          "old_text": null,
          "new_text": "FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments>::getReturnTypeImplStatic(arguments, context)",
          "old_line_content": "            function,",
          "new_line_content": "        return FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments>::getReturnTypeImplStatic(arguments, context);",
          "content_same": false
        },
        {
          "line": 1945,
          "old_api": null,
          "new_api": "col_right_const->template getValue<T1>()",
          "old_text": null,
          "new_text": "col_right_const->template getValue<T1>()",
          "old_line_content": "                    right_nullmap);",
          "new_line_content": "                        col_right_const->template getValue<T1>());",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": null,
          "new_api": "toField",
          "old_text": null,
          "new_text": "toField(res)",
          "old_line_content": "            else // can't avoid else and another indentation level, otherwise the compiler would try to instantiate",
          "new_line_content": "                    return ResultDataType().createColumnConst(col_left_const->size(), toField(res));",
          "content_same": false
        },
        {
          "line": 1950,
          "old_api": null,
          "new_api": "ColVecResult::create()",
          "old_text": null,
          "new_text": "ColVecResult::create()",
          "old_line_content": "                using OpImpl = BinaryOperationImpl<T0, T1, Op<T0, T1>, ResultType>;",
          "new_line_content": "                typename ColVecResult::MutablePtr col_res = ColVecResult::create();",
          "content_same": false
        },
        {
          "line": 1952,
          "old_api": null,
          "new_api": "getData",
          "old_text": null,
          "new_text": "col_res->getData()",
          "old_line_content": "                /// non-vector result",
          "new_line_content": "                auto & vec_res = col_res->getData();",
          "content_same": false
        },
        {
          "line": 1953,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "vec_res.resize(col_left_size)",
          "old_line_content": "                if (col_left_const && col_right_const)",
          "new_line_content": "                vec_res.resize(col_left_size);",
          "content_same": false
        },
        {
          "line": 1958,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "col_left->getData().data()",
          "old_line_content": "",
          "new_line_content": "                        col_left->getData().data(),",
          "content_same": false
        },
        {
          "line": 1960,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "vec_res.data()",
          "old_line_content": "                }",
          "new_line_content": "                        vec_res.data(),",
          "content_same": false
        },
        {
          "line": 1961,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vec_res.size()",
          "old_line_content": "",
          "new_line_content": "                        vec_res.size(),",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": null,
          "new_api": "std::swap(new_arguments[0], new_arguments[1])",
          "old_text": null,
          "new_text": "std::swap(new_arguments[0], new_arguments[1])",
          "old_line_content": "        }",
          "new_line_content": "                std::swap(new_arguments[0], new_arguments[1]);",
          "content_same": false
        },
        {
          "line": 1454,
          "old_api": null,
          "new_api": "build",
          "old_text": null,
          "new_text": "function_builder->build(new_arguments)",
          "old_line_content": "        /// Special case when the function is plus or minus, one of arguments is Date/DateTime and another is Tuple.",
          "new_line_content": "            auto function = function_builder->build(new_arguments);",
          "content_same": false
        },
        {
          "line": 1966,
          "old_api": null,
          "new_api": "col_left_const->template getValue<T0>()",
          "old_text": null,
          "new_text": "col_left_const->template getValue<T0>()",
          "old_line_content": "",
          "new_line_content": "                    const T0 value = col_left_const->template getValue<T0>();",
          "content_same": false
        },
        {
          "line": 1968,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "OpImpl::template process<OpCase::LeftConstant>(\n                        &value,\n                        col_right->getData().data(),\n                        vec_res.data(),\n                        vec_res.size(),\n                        right_nullmap)",
          "old_line_content": "                {",
          "new_line_content": "                    OpImpl::template process<OpCase::LeftConstant>(",
          "content_same": false
        },
        {
          "line": 1459,
          "old_api": null,
          "new_api": "getFunctionForMergeIntervalsArithmetic",
          "old_text": null,
          "new_text": "getFunctionForMergeIntervalsArithmetic(arguments[0], arguments[1], context)",
          "old_line_content": "            for (size_t i = 0; i < 2; ++i)",
          "new_line_content": "        if (auto function_builder = getFunctionForMergeIntervalsArithmetic(arguments[0], arguments[1], context))",
          "content_same": false
        },
        {
          "line": 1977,
          "old_api": null,
          "new_api": "col_right_const->template getValue<T1>()",
          "old_text": null,
          "new_text": "col_right_const->template getValue<T1>()",
          "old_line_content": "                {",
          "new_line_content": "                    const T1 value = col_right_const->template getValue<T1>();",
          "content_same": false
        },
        {
          "line": 1979,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "OpImpl::template process<OpCase::RightConstant>(\n                        col_left->getData().data(), &value, vec_res.data(), vec_res.size(), right_nullmap)",
          "old_line_content": "",
          "new_line_content": "                    OpImpl::template process<OpCase::RightConstant>(",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": null,
          "new_api": "std::swap(new_arguments[0], new_arguments[1])",
          "old_text": null,
          "new_text": "std::swap(new_arguments[0], new_arguments[1])",
          "old_line_content": "        }",
          "new_line_content": "                std::swap(new_arguments[0], new_arguments[1]);",
          "content_same": false
        },
        {
          "line": 1993,
          "old_api": null,
          "new_api": "isAggregateMultiply",
          "old_text": null,
          "new_text": "isAggregateMultiply(arguments[0].type, arguments[1].type)",
          "old_line_content": "                }",
          "new_line_content": "        if (isAggregateMultiply(arguments[0].type, arguments[1].type))",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": null,
          "new_api": "build",
          "old_text": null,
          "new_text": "function_builder->build(new_arguments)",
          "old_line_content": "        /// Special case when the function is multiply or divide, one of arguments is Tuple and another is Number.",
          "new_line_content": "            auto function = function_builder->build(new_arguments);",
          "content_same": false
        },
        {
          "line": 1995,
          "old_api": null,
          "new_api": "executeAggregateMultiply",
          "old_text": null,
          "new_text": "executeAggregateMultiply(arguments, result_type, input_rows_count)",
          "old_line_content": "                    return nullptr;",
          "new_line_content": "            return executeAggregateMultiply(arguments, result_type, input_rows_count);",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": null,
          "new_api": "isAggregateAddition",
          "old_text": null,
          "new_text": "isAggregateAddition(arguments[0].type, arguments[1].type)",
          "old_line_content": "        }",
          "new_line_content": "        if (isAggregateAddition(arguments[0].type, arguments[1].type))",
          "content_same": false
        },
        {
          "line": 1488,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "arguments[1].get()",
          "old_line_content": "                new_arguments[i].type = arguments[i];",
          "new_line_content": "        const bool valid = castBothTypes(arguments[0].get(), arguments[1].get(), [&](const auto & left, const auto & right)",
          "content_same": false
        },
        {
          "line": 2001,
          "old_api": null,
          "new_api": "executeAggregateAddition",
          "old_text": null,
          "new_text": "executeAggregateAddition(arguments, result_type, input_rows_count)",
          "old_line_content": "",
          "new_line_content": "            return executeAggregateAddition(arguments, result_type, input_rows_count);",
          "content_same": false
        },
        {
          "line": 1503,
          "old_api": null,
          "new_api": "getN",
          "old_text": null,
          "new_text": "right.getN()",
          "old_line_content": "            using RightDataType = std::decay_t<decltype(right)>;",
          "new_line_content": "                        if (left.getN() == right.getN())",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": null,
          "new_api": "std::make_shared<DataTypeUInt16>()",
          "old_text": null,
          "new_text": "std::make_shared<DataTypeUInt16>()",
          "old_line_content": "                (std::is_same_v<DataTypeFixedString, RightDataType> || std::is_same_v<DataTypeString, RightDataType>))",
          "new_line_content": "                                type_res = std::make_shared<DataTypeUInt16>();",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": null,
          "new_api": "getN",
          "old_text": null,
          "new_text": "left.getN()",
          "old_line_content": "                if constexpr (std::is_same_v<DataTypeFixedString, LeftDataType> &&",
          "new_line_content": "                                type_res = std::make_shared<LeftDataType>(left.getN());",
          "content_same": false
        },
        {
          "line": 1517,
          "old_api": null,
          "new_api": "std::make_shared<DataTypeUInt64>()",
          "old_text": null,
          "new_text": "std::make_shared<DataTypeUInt64>()",
          "old_line_content": "                            if constexpr (is_bit_hamming_distance)",
          "new_line_content": "                    type_res = std::make_shared<DataTypeUInt64>();",
          "content_same": false
        },
        {
          "line": 2034,
          "old_api": null,
          "new_api": "executeImpl2",
          "old_text": null,
          "new_text": "executeImpl2(arguments, result_type, input_rows_count)",
          "old_line_content": "        /// Special case when the function is plus, minus or multiply, both arguments are tuples.",
          "new_line_content": "        return executeImpl2(arguments, result_type, input_rows_count);",
          "content_same": false
        },
        {
          "line": 1523,
          "old_api": null,
          "new_api": "getN",
          "old_text": null,
          "new_text": "left.getN()",
          "old_line_content": "                    }",
          "new_line_content": "                    type_res = std::make_shared<LeftDataType>(left.getN());",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": null,
          "new_api": "std::make_shared<DataTypeString>()",
          "old_text": null,
          "new_text": "std::make_shared<DataTypeString>()",
          "old_line_content": "",
          "new_line_content": "                    type_res = std::make_shared<DataTypeString>();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1547,
          "old_api": "getKind",
          "new_api": null,
          "old_text": "right.getKind()",
          "new_text": null,
          "old_line_content": "                        if (left.getKind() == right.getKind())",
          "new_line_content": "                if constexpr (!std::is_same_v<ResultDataType, InvalidType>)",
          "content_same": false
        },
        {
          "line": 2060,
          "old_api": "get",
          "new_api": null,
          "old_text": "right_argument.column.get()",
          "new_text": null,
          "old_line_content": "            bool is_const = checkColumnConst<ColumnNullable>(right_argument.column.get());",
          "new_line_content": "            ColumnsWithTypeAndName new_arguments {",
          "content_same": false
        },
        {
          "line": 2061,
          "old_api": "get",
          "new_api": null,
          "old_text": "right_argument.column.get()",
          "new_text": null,
          "old_line_content": "            const ColumnNullable * nullable_column = is_const ? checkAndGetColumnConstData<ColumnNullable>(right_argument.column.get())",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": "getKind",
          "new_api": null,
          "old_text": "left.getKind()",
          "new_text": null,
          "old_line_content": "                            type_res = std::make_shared<LeftDataType>(left.getKind());",
          "new_line_content": "                    if constexpr (IsDataTypeDecimal<LeftDataType> && IsDataTypeDecimal<RightDataType>)",
          "content_same": false
        },
        {
          "line": 2064,
          "old_api": "getNullMapData",
          "new_api": null,
          "old_text": "nullable_column->getNullMapData()",
          "new_text": null,
          "old_line_content": "            const auto & null_bytemap = nullable_column->getNullMapData();",
          "new_line_content": "                    arguments[0].name,",
          "content_same": false
        },
        {
          "line": 2065,
          "old_api": "removeNullable",
          "new_api": null,
          "old_text": "removeNullable(result_type)",
          "new_text": null,
          "old_line_content": "            auto res = executeImpl2(createBlockWithNestedColumns(arguments), removeNullable(result_type), input_rows_count, &null_bytemap);",
          "new_line_content": "                },",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": "wrapInNullable",
          "new_api": null,
          "old_text": "wrapInNullable(res, arguments, result_type, input_rows_count)",
          "new_text": null,
          "old_line_content": "            return wrapInNullable(res, arguments, result_type, input_rows_count);",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 2070,
          "old_api": "isIPv4",
          "new_api": null,
          "old_text": "isIPv4(arguments[1].type)",
          "new_text": null,
          "old_line_content": "        if (isIPv4(arguments[0].type) || isIPv4(arguments[1].type))",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 2074,
          "old_api": "std::make_shared<DataTypeUInt32>()",
          "new_api": null,
          "old_text": "std::make_shared<DataTypeUInt32>()",
          "new_text": null,
          "old_line_content": "                    isIPv4(arguments[0].type) ? castColumn(arguments[0], std::make_shared<DataTypeUInt32>()) : arguments[0].column,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2075,
          "old_api": "std::make_shared<DataTypeUInt32>()",
          "new_api": null,
          "old_text": "std::make_shared<DataTypeUInt32>()",
          "new_text": null,
          "old_line_content": "                    isIPv4(arguments[0].type) ? std::make_shared<DataTypeUInt32>() : arguments[0].type,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": "getSettingsRef",
          "new_api": null,
          "old_text": "context->getSettingsRef()",
          "new_text": null,
          "old_line_content": "                            if (context->getSettingsRef().decimal_check_overflow)",
          "new_line_content": "                        }",
          "content_same": false
        },
        {
          "line": 2041,
          "old_api": "getFunctionForTupleAndNumberArithmetic",
          "new_api": null,
          "old_text": "getFunctionForTupleAndNumberArithmetic(arguments[0].type, arguments[1].type, context)",
          "new_text": null,
          "old_line_content": "        if (auto function_builder = getFunctionForTupleAndNumberArithmetic(arguments[0].type, arguments[1].type, context))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2079,
          "old_api": "std::make_shared<DataTypeUInt32>()",
          "new_api": null,
          "old_text": "std::make_shared<DataTypeUInt32>()",
          "new_text": null,
          "old_line_content": "                    isIPv4(arguments[1].type) ? castColumn(arguments[1], std::make_shared<DataTypeUInt32>()) : arguments[1].column,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2085,
          "old_api": "executeImpl2",
          "new_api": null,
          "old_text": "executeImpl2(new_arguments, result_type, input_rows_count, right_nullmap)",
          "new_text": null,
          "old_line_content": "            return executeImpl2(new_arguments, result_type, input_rows_count, right_nullmap);",
          "new_line_content": "            if constexpr ((std::is_same_v<DataTypeFixedString, LeftDataType> || std::is_same_v<DataTypeString, LeftDataType>) ||",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": "ResultDataType::maxPrecision()",
          "new_api": null,
          "old_text": "ResultDataType::maxPrecision()",
          "new_text": null,
          "old_line_content": "                                if (left.getScale() + right.getScale() > ResultDataType::maxPrecision())",
          "new_line_content": "                    else if constexpr (IsDataTypeDecimal<RightDataType>)",
          "content_same": false
        },
        {
          "line": 2088,
          "old_api": "get",
          "new_api": null,
          "old_text": "left_argument.type.get()",
          "new_text": null,
          "old_line_content": "        const auto * const left_generic = left_argument.type.get();",
          "new_line_content": "                if constexpr (std::is_same_v<DataTypeFixedString, LeftDataType> &&",
          "content_same": false
        },
        {
          "line": 2089,
          "old_api": "get",
          "new_api": null,
          "old_text": "right_argument.type.get()",
          "new_text": null,
          "old_line_content": "        const auto * const right_generic = right_argument.type.get();",
          "new_line_content": "                              std::is_same_v<DataTypeFixedString, RightDataType>)",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": "decimalResultType<is_multiply, is_division>(left, right)",
          "new_api": null,
          "old_text": "decimalResultType<is_multiply, is_division>(left, right)",
          "new_text": null,
          "old_line_content": "                        ResultDataType result_type = decimalResultType<is_multiply, is_division>(left, right);",
          "new_line_content": "                        // Special case for DateTime: binary OPS should reuse timezone",
          "content_same": false
        },
        {
          "line": 1579,
          "old_api": "getScale",
          "new_api": null,
          "old_text": "result_type.getScale()",
          "new_text": null,
          "old_line_content": "                        type_res = std::make_shared<ResultDataType>(result_type.getPrecision(), result_type.getScale());",
          "new_line_content": "                        // of DateTime argument as timezeone of result type.",
          "content_same": false
        },
        {
          "line": 2092,
          "old_api": "castBothTypes",
          "new_api": null,
          "old_text": "castBothTypes(left_generic, right_generic, [&](const auto & left, const auto & right)\n        {\n            using LeftDataType = std::decay_t<decltype(left)>;\n            using RightDataType = std::decay_t<decltype(right)>;\n\n            if constexpr ((std::is_same_v<DataTypeFixedString, LeftDataType> || std::is_same_v<DataTypeString, LeftDataType>) ||\n                          (std::is_same_v<DataTypeFixedString, RightDataType> || std::is_same_v<DataTypeString, RightDataType>))\n            {\n                if constexpr (std::is_same_v<DataTypeFixedString, LeftDataType> &&\n                              std::is_same_v<DataTypeFixedString, RightDataType>)\n                {\n                    if constexpr (!Op<DataTypeFixedString, DataTypeFixedString>::allow_fixed_string)\n                        return false;\n                    else\n                        return (res = executeFixedString(arguments)) != nullptr;\n                }\n\n                if constexpr (\n                    is_bit_hamming_distance\n                    && std::is_same_v<DataTypeString, LeftDataType> && std::is_same_v<DataTypeString, RightDataType>)\n                    return (res = executeString(arguments)) != nullptr;\n                else if constexpr (!Op<LeftDataType, RightDataType>::allow_string_integer)\n                    return false;\n                else if constexpr (!IsIntegral<RightDataType>)\n                    return false;\n                else if constexpr (std::is_same_v<DataTypeFixedString, LeftDataType>)\n                {\n                    return (res = executeStringInteger<ColumnFixedString>(arguments, left, right)) != nullptr;\n                }\n                else if constexpr (std::is_same_v<DataTypeString, LeftDataType>)\n                    return (res = executeStringInteger<ColumnString>(arguments, left, right)) != nullptr;\n            }\n            else\n                return (res = executeNumeric(arguments, left, right, right_nullmap)) != nullptr;\n        })",
          "new_text": null,
          "old_line_content": "        const bool valid = castBothTypes(left_generic, right_generic, [&](const auto & left, const auto & right)",
          "new_line_content": "                        return false;",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": "std::make_shared<DataTypeFloat64>()",
          "new_api": null,
          "old_text": "std::make_shared<DataTypeFloat64>()",
          "new_text": null,
          "old_line_content": "                        type_res = std::make_shared<DataTypeFloat64>();",
          "new_line_content": "                        if constexpr (std::is_same_v<RightDataType, DataTypeDateTime>)",
          "content_same": false
        },
        {
          "line": 1585,
          "old_api": "getScale",
          "new_api": null,
          "old_text": "left.getScale()",
          "new_text": null,
          "old_line_content": "                        type_res = std::make_shared<LeftDataType>(left.getPrecision(), left.getScale());",
          "new_line_content": "                        if constexpr (std::is_same_v<LeftDataType, DataTypeDateTime>)",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": "executeFixedString",
          "new_api": null,
          "old_text": "executeFixedString(arguments)",
          "new_text": null,
          "old_line_content": "                        return (res = executeFixedString(arguments)) != nullptr;",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": "std::make_shared<ResultDataType>(*tz)",
          "new_api": null,
          "old_text": "std::make_shared<ResultDataType>(*tz)",
          "new_text": null,
          "old_line_content": "                        type_res = std::make_shared<ResultDataType>(*tz);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2112,
          "old_api": "executeString",
          "new_api": null,
          "old_text": "executeString(arguments)",
          "new_text": null,
          "old_line_content": "                    return (res = executeString(arguments)) != nullptr;",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": "std::make_shared<ResultDataType>()",
          "new_api": null,
          "old_text": "std::make_shared<ResultDataType>()",
          "new_text": null,
          "old_line_content": "                        type_res = std::make_shared<ResultDataType>();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2119,
          "old_api": "executeStringInteger<ColumnFixedString>(arguments, left, right)",
          "new_api": null,
          "old_text": "executeStringInteger<ColumnFixedString>(arguments, left, right)",
          "new_text": null,
          "old_line_content": "                    return (res = executeStringInteger<ColumnFixedString>(arguments, left, right)) != nullptr;",
          "new_line_content": "        if (!valid)",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": "executeStringInteger<ColumnString>(arguments, left, right)",
          "new_api": null,
          "old_text": "executeStringInteger<ColumnString>(arguments, left, right)",
          "new_text": null,
          "old_line_content": "                    return (res = executeStringInteger<ColumnString>(arguments, left, right)) != nullptr;",
          "new_line_content": "            // by getReturnTypeImpl().",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": "String",
          "new_api": null,
          "old_text": "String(name)",
          "new_text": null,
          "old_line_content": "            arguments[0]->getName(), arguments[1]->getName(), String(name));",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2128,
          "old_api": "isArray",
          "new_api": null,
          "old_text": "isArray(result_type)",
          "new_text": null,
          "old_line_content": "        if (isArray(result_type))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2129,
          "old_api": "executeArrayImpl",
          "new_api": null,
          "old_text": "executeArrayImpl(arguments, result_type, input_rows_count)",
          "new_text": null,
          "old_line_content": "            return executeArrayImpl(arguments, result_type, input_rows_count);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": "get",
          "new_api": null,
          "old_text": "arguments[0].column.get()",
          "new_text": null,
          "old_line_content": "        const auto * const col_left_raw = arguments[0].column.get();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1622,
          "old_api": "get",
          "new_api": null,
          "old_text": "arguments[1].column.get()",
          "new_text": null,
          "old_line_content": "        const auto * const col_right_raw = arguments[1].column.get();",
          "new_line_content": "                if constexpr (is_bit_hamming_distance)",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": "getName",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::LOGICAL_ERROR,\n                \"Arguments of '{}' have incorrect data types: '{}' of type '{}',\"\n                \" '{}' of type '{}'\", getName(),\n                left_argument.name, left_argument.type->getName(),\n                right_argument.name, right_argument.type->getName())",
          "new_text": null,
          "old_line_content": "            throw Exception(ErrorCodes::LOGICAL_ERROR,",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2137,
          "old_api": "getName",
          "new_api": null,
          "old_text": "getName()",
          "new_text": null,
          "old_line_content": "                \" '{}' of type '{}'\", getName(),",
          "new_line_content": "            return false;",
          "content_same": false
        },
        {
          "line": 2138,
          "old_api": "getName",
          "new_api": null,
          "old_text": "left_argument.type->getName()",
          "new_text": null,
          "old_line_content": "                left_argument.name, left_argument.type->getName(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1637,
          "old_api": "getData",
          "new_api": null,
          "old_text": "col_res->getData()",
          "new_text": null,
          "old_line_content": "                    auto & data = col_res->getData();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2151,
          "old_api": "canBeNativeType",
          "new_api": null,
          "old_text": "canBeNativeType(*result_type)",
          "new_text": null,
          "old_line_content": "        if (!canBeNativeType(*arguments[0]) || !canBeNativeType(*arguments[1]) || !canBeNativeType(*result_type))",
          "new_line_content": "            using RightDataType = std::decay_t<decltype(right)>;",
          "content_same": false
        },
        {
          "line": 2156,
          "old_api": "isDateTime",
          "new_api": null,
          "old_text": "data_type_lhs.isDateTime()",
          "new_text": null,
          "old_line_content": "        if ((data_type_lhs.isDateOrDate32() || data_type_lhs.isDateTime()) ||",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 2157,
          "old_api": "isDateTime",
          "new_api": null,
          "old_text": "data_type_rhs.isDateTime()",
          "new_text": null,
          "old_line_content": "            (data_type_rhs.isDateOrDate32() || data_type_rhs.isDateTime()))",
          "new_line_content": "                using ResultDataType = typename BinaryOperationTraits<Op, LeftDataType, RightDataType>::ResultDataType;",
          "content_same": false
        },
        {
          "line": 1647,
          "old_api": "getN",
          "new_api": null,
          "old_text": "col_left->getN()",
          "new_text": null,
          "old_line_content": "                    auto col_res = ColumnFixedString::create(col_left->getN());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2160,
          "old_api": "get",
          "new_api": null,
          "old_text": "arguments[1].get()",
          "new_text": null,
          "old_line_content": "        return castBothTypes(arguments[0].get(), arguments[1].get(), [&](const auto & left, const auto & right)",
          "new_line_content": "                    return true;",
          "content_same": false
        },
        {
          "line": 1648,
          "old_api": "getChars",
          "new_api": null,
          "old_text": "col_res->getChars()",
          "new_text": null,
          "old_line_content": "                    auto & out_chars = col_res->getChars();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1652,
          "old_api": "data",
          "new_api": null,
          "old_text": "OpImpl::template process<OpCase::Vector>(\n                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), {})",
          "new_text": null,
          "old_line_content": "                    OpImpl::template process<OpCase::Vector>(",
          "new_line_content": "        const auto * col_left = is_left_column_const",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": "checkAndGetColumnConst<ColumnFixedString>(col_left_raw)",
          "new_api": null,
          "old_text": "checkAndGetColumnConst<ColumnFixedString>(col_left_raw)",
          "new_text": null,
          "old_line_content": "        const bool is_left_column_const = checkAndGetColumnConst<ColumnFixedString>(col_left_raw) != nullptr;",
          "new_line_content": "        if (col_left && col_right)",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": "checkAndGetColumnConst<ColumnFixedString>(col_right_raw)",
          "new_api": null,
          "old_text": "checkAndGetColumnConst<ColumnFixedString>(col_right_raw)",
          "new_text": null,
          "old_line_content": "        const bool is_right_column_const = checkAndGetColumnConst<ColumnFixedString>(col_right_raw) != nullptr;",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": "getDataColumn",
          "new_api": null,
          "old_text": "checkAndGetColumn<ColumnFixedString>(\n                            checkAndGetColumnConst<ColumnFixedString>(col_left_raw)->getDataColumn())",
          "new_text": null,
          "old_line_content": "                        ? checkAndGetColumn<ColumnFixedString>(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": "getDataColumn",
          "new_api": null,
          "old_text": "checkAndGetColumnConst<ColumnFixedString>(col_left_raw)->getDataColumn()",
          "new_text": null,
          "old_line_content": "                            checkAndGetColumnConst<ColumnFixedString>(col_left_raw)->getDataColumn())",
          "new_line_content": "            if constexpr (is_bit_hamming_distance)",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": "checkAndGetColumn<ColumnFixedString>(col_left_raw)",
          "new_api": null,
          "old_text": "checkAndGetColumn<ColumnFixedString>(col_left_raw)",
          "new_text": null,
          "old_line_content": "                        : checkAndGetColumn<ColumnFixedString>(col_left_raw);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 2180,
          "old_api": "size",
          "new_api": null,
          "old_text": "arguments.size()",
          "new_text": null,
          "old_line_content": "        assert(2 == arguments.size());",
          "new_line_content": "                using ResultDataType = typename BinaryOperationTraits<Op, LeftDataType, RightDataType>::ResultDataType;",
          "content_same": false
        },
        {
          "line": 2183,
          "old_api": "get",
          "new_api": null,
          "old_text": "arguments[1].type.get()",
          "new_text": null,
          "old_line_content": "        castBothTypes(arguments[0].type.get(), arguments[1].type.get(), [&](const auto & left, const auto & right)",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": "checkAndGetColumn<ColumnFixedString>(col_right_raw)",
          "new_api": null,
          "old_text": "checkAndGetColumn<ColumnFixedString>(col_right_raw)",
          "new_text": null,
          "old_line_content": "                        : checkAndGetColumn<ColumnFixedString>(col_right_raw);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": "getData",
          "new_api": null,
          "old_text": "col_res->getData()",
          "new_text": null,
          "old_line_content": "                auto & data = col_res->getData();",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1682,
          "old_api": "size",
          "new_api": null,
          "old_text": "col_right->size()",
          "new_text": null,
          "old_line_content": "                data.resize_fill(is_right_column_const ? col_left->size() : col_right->size());",
          "new_line_content": "                else",
          "content_same": false
        },
        {
          "line": 2196,
          "old_api": "static_cast<llvm::IRBuilder<> &>(builder)",
          "new_api": null,
          "old_text": "static_cast<llvm::IRBuilder<> &>(builder)",
          "new_text": null,
          "old_line_content": "                    auto & b = static_cast<llvm::IRBuilder<> &>(builder);",
          "new_line_content": "        return result;",
          "content_same": false
        },
        {
          "line": 2197,
          "old_api": "nativeCast",
          "new_api": null,
          "old_text": "nativeCast(b, arguments[0], result_type)",
          "new_text": null,
          "old_line_content": "                    auto * lval = nativeCast(b, arguments[0], result_type);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2198,
          "old_api": "nativeCast",
          "new_api": null,
          "old_text": "nativeCast(b, arguments[1], result_type)",
          "new_text": null,
          "old_line_content": "                    auto * rval = nativeCast(b, arguments[1], result_type);",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 2199,
          "old_api": "OpSpec::compile(b, lval, rval, std::is_signed_v<typename ResultDataType::FieldType>)",
          "new_api": null,
          "old_text": "OpSpec::compile(b, lval, rval, std::is_signed_v<typename ResultDataType::FieldType>)",
          "new_text": null,
          "old_line_content": "                    result = OpSpec::compile(b, lval, rval, std::is_signed_v<typename ResultDataType::FieldType>);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1686,
          "old_api": "data",
          "new_api": null,
          "old_text": "OpReduceImpl::template process<OpCase::Vector>(\n                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN())",
          "new_text": null,
          "old_line_content": "                    OpReduceImpl::template process<OpCase::Vector>(",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1687,
          "old_api": "getN",
          "new_api": null,
          "old_text": "col_left->getN()",
          "new_text": null,
          "old_line_content": "                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1691,
          "old_api": "data",
          "new_api": null,
          "old_text": "OpReduceImpl::template process<OpCase::LeftConstant>(\n                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN())",
          "new_text": null,
          "old_line_content": "                    OpReduceImpl::template process<OpCase::LeftConstant>(",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1181,
          "old_api": "size",
          "new_api": null,
          "old_text": "left_offsets.size()",
          "new_text": null,
          "old_line_content": "        for (auto offset_index = 0U; offset_index < left_offsets.size(); ++offset_index)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": "data",
          "new_api": null,
          "old_text": "OpReduceImpl::template process<OpCase::RightConstant>(\n                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN())",
          "new_text": null,
          "old_line_content": "                    OpReduceImpl::template process<OpCase::RightConstant>(",
          "new_line_content": "                if (!is_left_column_const && !is_right_column_const)",
          "content_same": false
        },
        {
          "line": 1697,
          "old_api": "getN",
          "new_api": null,
          "old_text": "col_left->getN()",
          "new_text": null,
          "old_line_content": "                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN());",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": "data",
          "new_api": null,
          "old_text": "left_array_col->getOffsets().data()",
          "new_text": null,
          "old_line_content": "                *left_array_col->getOffsets().data(),",
          "new_line_content": "        size_t rows_count = 0;",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": "get",
          "new_api": null,
          "old_text": "arguments[0].type.get()",
          "new_text": null,
          "old_line_content": "        const auto & left_array_type = typeid_cast<const DataTypeArray *>(arguments[0].type.get())->getNestedType();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1705,
          "old_api": "getChars",
          "new_api": null,
          "old_text": "col_res->getChars()",
          "new_text": null,
          "old_line_content": "                auto & out_chars = col_res->getChars();",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "getN",
          "new_api": null,
          "old_text": "col_left->getN()",
          "new_text": null,
          "old_line_content": "                out_chars.resize((is_right_column_const ? col_left->size() : col_right->size()) * col_left->getN());",
          "new_line_content": "                else",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": "get",
          "new_api": null,
          "old_text": "arguments[1].type.get()",
          "new_text": null,
          "old_line_content": "        const auto & right_array_type = typeid_cast<const DataTypeArray *>(arguments[1].type.get())->getNestedType();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": "getDataPtr",
          "new_api": null,
          "old_text": "right_array_col->getDataPtr()",
          "new_text": null,
          "old_line_content": "        new_arguments[1] = {right_array_col->getDataPtr(), right_array_type, arguments[1].name};",
          "new_line_content": "    ColumnPtr executeTupleNumberOperator(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type,",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": "get",
          "new_api": null,
          "old_text": "result_type.get()",
          "new_text": null,
          "old_line_content": "        result_array_type = typeid_cast<const DataTypeArray *>(result_type.get())->getNestedType();",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": "data",
          "new_api": null,
          "old_text": "OpImpl::template process<OpCase::Vector>(\n                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), {})",
          "new_text": null,
          "old_line_content": "                    OpImpl::template process<OpCase::Vector>(",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": "size",
          "new_api": null,
          "old_text": "out_chars.size()",
          "new_text": null,
          "old_line_content": "                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), {});",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": "empty",
          "new_api": null,
          "old_text": "left_offsets.empty()",
          "new_text": null,
          "old_line_content": "        if (!left_offsets.empty())",
          "new_line_content": "        /// Number argument must be second.",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": "data",
          "new_api": null,
          "old_text": "OpImpl::template process<OpCase::LeftConstant>(\n                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), col_left->getN())",
          "new_text": null,
          "old_line_content": "                    OpImpl::template process<OpCase::LeftConstant>(",
          "new_line_content": "        return nullptr;",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": "getN",
          "new_api": null,
          "old_text": "col_left->getN()",
          "new_text": null,
          "old_line_content": "                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), col_left->getN());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2229,
          "old_api": "std::make_shared<FunctionBinaryArithmeticWithConstants>(left_, right_, return_type_, context)",
          "new_api": null,
          "old_text": "std::make_shared<FunctionBinaryArithmeticWithConstants>(left_, right_, return_type_, context)",
          "new_text": null,
          "old_line_content": "        return std::make_shared<FunctionBinaryArithmeticWithConstants>(left_, right_, return_type_, context);",
          "new_line_content": "    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override",
          "content_same": false
        },
        {
          "line": 1720,
          "old_api": "data",
          "new_api": null,
          "old_text": "OpImpl::template process<OpCase::RightConstant>(\n                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), col_left->getN())",
          "new_text": null,
          "old_line_content": "                    OpImpl::template process<OpCase::RightConstant>(",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": "getN",
          "new_api": null,
          "old_text": "col_left->getN()",
          "new_text": null,
          "old_line_content": "                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), col_left->getN());",
          "new_line_content": "        using OpImpl = StringReduceOperationImpl<Op<UInt8, UInt8>>;",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": "isNumber",
          "new_api": null,
          "old_text": "isNumber(arguments[0].type)",
          "new_text": null,
          "old_line_content": "        if (isNumber(arguments[0].type))",
          "new_line_content": "        using NativeResultType = NativeType<ResultType>;",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": "std::swap(new_arguments[0], new_arguments[1])",
          "new_api": null,
          "old_text": "std::swap(new_arguments[0], new_arguments[1])",
          "new_text": null,
          "old_line_content": "            std::swap(new_arguments[0], new_arguments[1]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2246,
          "old_api": "cloneResized",
          "new_api": null,
          "old_text": "left.column->cloneResized(input_rows_count)",
          "new_text": null,
          "old_line_content": "                = {{left.column->cloneResized(input_rows_count), left.type, left.name},",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1735,
          "old_api": "get",
          "new_api": null,
          "old_text": "arguments[0].column.get()",
          "new_text": null,
          "old_line_content": "        const auto * const col_left_raw = arguments[0].column.get();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2249,
          "old_api": "Base::executeImpl(columns_with_constant, result_type, input_rows_count)",
          "new_api": null,
          "old_text": "Base::executeImpl(columns_with_constant, result_type, input_rows_count)",
          "new_text": null,
          "old_line_content": "            return Base::executeImpl(columns_with_constant, result_type, input_rows_count);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": "size",
          "new_api": null,
          "old_text": "arguments.size()",
          "new_text": null,
          "old_line_content": "        else if (right.column && isColumnConst(*right.column) && arguments.size() == 1)",
          "new_line_content": "    bool hasInformationAboutMonotonicity() const override",
          "content_same": false
        },
        {
          "line": 1740,
          "old_api": "checkAndGetColumnConst<ColumnString>(col_right_raw)",
          "new_api": null,
          "old_text": "checkAndGetColumnConst<ColumnString>(col_right_raw)",
          "new_text": null,
          "old_line_content": "            if (const auto * col_right_const = checkAndGetColumnConst<ColumnString>(col_right_raw))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": "getScale",
          "new_api": null,
          "old_text": "col.getScale()",
          "new_text": null,
          "old_line_content": "            return DecimalUtils::convertTo<NativeResultType>(col_const->template getValue<T>(), col.getScale());",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 2255,
          "old_api": "cloneResized",
          "new_api": null,
          "old_text": "right.column->cloneResized(input_rows_count)",
          "new_text": null,
          "old_line_content": "                   {right.column->cloneResized(input_rows_count), right.type, right.name}};",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1231,
          "old_api": "col_const->template getValue<T>()",
          "new_api": null,
          "old_text": "col_const->template getValue<T>()",
          "new_text": null,
          "old_line_content": "            return col_const->template getValue<T>().value;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2257,
          "old_api": "Base::executeImpl(columns_with_constant, result_type, input_rows_count)",
          "new_api": null,
          "old_text": "Base::executeImpl(columns_with_constant, result_type, input_rows_count)",
          "new_text": null,
          "old_line_content": "            return Base::executeImpl(columns_with_constant, result_type, input_rows_count);",
          "new_line_content": "    Monotonicity getMonotonicityForRange(const IDataType &, const Field & left_point, const Field & right_point) const override",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": "col_const->template getValue<T>()",
          "new_api": null,
          "old_text": "col_const->template getValue<T>()",
          "new_text": null,
          "old_line_content": "            return col_const->template getValue<T>();",
          "new_line_content": "    template <class LeftDataType, class RightDataType, class ResultDataType>",
          "content_same": false
        },
        {
          "line": 1745,
          "old_api": "toView",
          "new_api": null,
          "old_text": "col_left->getDataAt(0).toView()",
          "new_text": null,
          "old_line_content": "                std::string_view a = col_left->getDataAt(0).toView();",
          "new_line_content": "        const auto * col_left = is_left_column_const",
          "content_same": false
        },
        {
          "line": 2260,
          "old_api": "Base::executeImpl(arguments, result_type, input_rows_count)",
          "new_api": null,
          "old_text": "Base::executeImpl(arguments, result_type, input_rows_count)",
          "new_text": null,
          "old_line_content": "            return Base::executeImpl(arguments, result_type, input_rows_count);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1748,
          "old_api": "OpImpl::constConst(a, b)",
          "new_api": null,
          "old_text": "OpImpl::constConst(a, b)",
          "new_text": null,
          "old_line_content": "                auto res = OpImpl::constConst(a, b);",
          "new_line_content": "        const auto * col_right = is_right_column_const",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": "OpImplCheck::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap)",
          "new_api": null,
          "old_text": "OpImplCheck::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap)",
          "new_text": null,
          "old_line_content": "            OpImplCheck::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap);",
          "new_line_content": "        using T0 = typename LeftDataType::FieldType;",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": "OpImpl::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap)",
          "new_api": null,
          "old_text": "OpImpl::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap)",
          "new_text": null,
          "old_line_content": "            OpImpl::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap);",
          "new_line_content": "        using ResultType = typename ResultDataType::FieldType;",
          "content_same": false
        },
        {
          "line": 1758,
          "old_api": "getDataColumn",
          "new_api": null,
          "old_text": "checkAndGetColumnConst<ColumnString>(col_left_raw)->getDataColumn()",
          "new_text": null,
          "old_line_content": "            ? checkAndGetColumn<ColumnString>(checkAndGetColumnConst<ColumnString>(col_left_raw)->getDataColumn())",
          "new_line_content": "            if (!is_left_column_const && !is_right_column_const)",
          "content_same": false
        },
        {
          "line": 1759,
          "old_api": "checkAndGetColumn<ColumnString>(col_left_raw)",
          "new_api": null,
          "old_text": "checkAndGetColumn<ColumnString>(col_left_raw)",
          "new_text": null,
          "old_line_content": "            : checkAndGetColumn<ColumnString>(col_left_raw);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 2274,
          "old_api": "isNull",
          "new_api": null,
          "old_text": "right_point.isNull()",
          "new_text": null,
          "old_line_content": "        if (left_point.isNull() || right_point.isNull())",
          "new_line_content": "                    // division is saturated to `inf`, thus it doesn't have overflow issues.",
          "content_same": false
        },
        {
          "line": 1762,
          "old_api": "checkAndGetColumn<ColumnString>(col_right_raw)",
          "new_api": null,
          "old_text": "checkAndGetColumn<ColumnString>(col_right_raw)",
          "new_text": null,
          "old_line_content": "            : checkAndGetColumn<ColumnString>(col_right_raw);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": "isColumnConst",
          "new_api": null,
          "old_text": "isColumnConst(*right.column)",
          "new_text": null,
          "old_line_content": "                if (right.column && isColumnConst(*right.column))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1767,
          "old_api": "getData",
          "new_api": null,
          "old_text": "col_res->getData()",
          "new_text": null,
          "old_line_content": "            auto & data = col_res->getData();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1768,
          "old_api": "size",
          "new_api": null,
          "old_text": "col_right->size()",
          "new_text": null,
          "old_line_content": "            data.resize(is_right_column_const ? col_left->size() : col_right->size());",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 2284,
          "old_api": "Field",
          "new_api": null,
          "old_text": "Field(0)",
          "new_text": null,
          "old_line_content": "                    bool is_constant_positive = applyVisitor(FieldVisitorAccurateLess(), Field(0), constant);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1772,
          "old_api": "getChars",
          "new_api": null,
          "old_text": "OpImpl::vectorVector(\n                    col_left->getChars(), col_left->getOffsets(), col_right->getChars(), col_right->getOffsets(), data)",
          "new_text": null,
          "old_line_content": "                OpImpl::vectorVector(",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1262,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "        static constexpr const bool left_is_decimal = is_decimal<T0>;",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1263,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "        static constexpr const bool right_is_decimal = is_decimal<T1>;",
          "new_line_content": "                if constexpr (is_multiply)",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": "getOffsets",
          "new_api": null,
          "old_text": "col_right->getOffsets()",
          "new_text": null,
          "old_line_content": "                    col_left->getChars(), col_left->getOffsets(), col_right->getChars(), col_right->getOffsets(), data);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": "toView",
          "new_api": null,
          "old_text": "col_left->getDataAt(0).toView()",
          "new_text": null,
          "old_line_content": "                std::string_view str_view = col_left->getDataAt(0).toView();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1778,
          "old_api": "getOffsets",
          "new_api": null,
          "old_text": "col_right->getOffsets()",
          "new_text": null,
          "old_line_content": "                OpImpl::vectorConstant(col_right->getChars(), col_right->getOffsets(), str_view, data);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1267,
          "old_api": "decimalResultType<is_multiply, is_division>(left, right)",
          "new_api": null,
          "old_text": "decimalResultType<is_multiply, is_division>(left, right)",
          "new_text": null,
          "old_line_content": "        const ResultDataType type = decimalResultType<is_multiply, is_division>(left, right);",
          "new_line_content": "                    // to decimal.",
          "content_same": false
        },
        {
          "line": 1269,
          "old_api": "getScaleMultiplier",
          "new_api": null,
          "old_text": "[&]\n        {\n            if constexpr (IsDataTypeDecimal<RightDataType> && is_division)\n                return right.getScaleMultiplier(); // the division impl uses only the scale_a\n            else\n            {\n                if constexpr (is_multiply)\n                    // the decimal impl uses scales, but if the result is decimal, both of the arguments are decimal,\n                    // so they would multiply correctly, so we need to scale the result to the neutral element (1).\n                    // The explicit type is needed as the int (in contrast with float) can't be implicitly converted\n                    // to decimal.\n                    return ResultType{1};\n                else\n                    return type.scaleFactorFor(left, false);\n            }\n        }()",
          "new_text": null,
          "old_line_content": "        const ResultType scale_a = [&]",
          "new_line_content": "                else",
          "content_same": false
        },
        {
          "line": 2294,
          "old_api": "FieldVisitorAccurateEquals",
          "new_api": null,
          "old_text": "FieldVisitorAccurateEquals()",
          "new_text": null,
          "old_line_content": "        if (applyVisitor(FieldVisitorAccurateEquals(), left_point, right_point))",
          "new_line_content": "                auto transform = [&](const Field & point)",
          "content_same": false
        },
        {
          "line": 1782,
          "old_api": "toView",
          "new_api": null,
          "old_text": "col_right->getDataAt(0).toView()",
          "new_text": null,
          "old_line_content": "                std::string_view str_view = col_right->getDataAt(0).toView();",
          "new_line_content": "        using LeftDataType = std::decay_t<decltype(left)>;",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": "getScaleMultiplier",
          "new_api": null,
          "old_text": "right.getScaleMultiplier()",
          "new_text": null,
          "old_line_content": "                return right.getScaleMultiplier(); // the division impl uses only the scale_a",
          "new_line_content": "        }();",
          "content_same": false
        },
        {
          "line": 1783,
          "old_api": "getOffsets",
          "new_api": null,
          "old_text": "col_left->getOffsets()",
          "new_text": null,
          "old_line_content": "                OpImpl::vectorConstant(col_left->getChars(), col_left->getOffsets(), str_view, data);",
          "new_line_content": "        using RightDataType = std::decay_t<decltype(right)>;",
          "content_same": false
        },
        {
          "line": 2300,
          "old_api": "isColumnConst",
          "new_api": null,
          "old_text": "isColumnConst(*left.column)",
          "new_text": null,
          "old_line_content": "            if (left.column && isColumnConst(*left.column))",
          "new_line_content": "                    /// This is a bit dangerous to call Base::executeImpl cause it ignores `use Default Implementation For XXX` flags.",
          "content_same": false
        },
        {
          "line": 2302,
          "old_api": "removeLowCardinality",
          "new_api": null,
          "old_text": "removeLowCardinality(left.type)",
          "new_text": null,
          "old_line_content": "                auto left_type = removeNullable(removeLowCardinality(left.type));",
          "new_line_content": "                    /// Adding removeNullable above fixes the issue, but some other inconsistency may left.",
          "content_same": false
        },
        {
          "line": 2304,
          "old_api": "removeLowCardinality",
          "new_api": null,
          "old_text": "removeLowCardinality(return_type)",
          "new_text": null,
          "old_line_content": "                auto ret_type = removeNullable(removeLowCardinality(return_type));",
          "new_line_content": "                    Field point_transformed;",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": "scaleFactorFor",
          "new_api": null,
          "old_text": "type.scaleFactorFor(left, false)",
          "new_text": null,
          "old_line_content": "                    return type.scaleFactorFor(left, false);",
          "new_line_content": "        /// non-vector result",
          "content_same": false
        },
        {
          "line": 1802,
          "old_api": "checkAndGetColumn<ColVecT1>(col_right_raw)",
          "new_api": null,
          "old_text": "checkAndGetColumn<ColVecT1>(col_right_raw)",
          "new_text": null,
          "old_line_content": "        const ColVecT1 * const col_right = checkAndGetColumn<ColVecT1>(col_right_raw);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2315,
          "old_api": "Base::executeImpl(columns_with_constant, ret_type, 1)",
          "new_api": null,
          "old_text": "Base::executeImpl(columns_with_constant, ret_type, 1)",
          "new_text": null,
          "old_line_content": "                    auto col = Base::executeImpl(columns_with_constant, ret_type, 1);",
          "new_line_content": "                    if (is_positive_monotonicity)",
          "content_same": false
        },
        {
          "line": 1291,
          "old_api": "scaleFactorFor",
          "new_api": null,
          "old_text": "type.scaleFactorFor(right, is_division)",
          "new_text": null,
          "old_line_content": "                    return type.scaleFactorFor(right, is_division);",
          "new_line_content": "            if (!right_nullmap || !(*right_nullmap)[0])",
          "content_same": false
        },
        {
          "line": 2317,
          "old_api": "get",
          "new_api": null,
          "old_text": "col->get(0, point_transformed)",
          "new_text": null,
          "old_line_content": "                    col->get(0, point_transformed);",
          "new_line_content": "                    else",
          "content_same": false
        },
        {
          "line": 2321,
          "old_api": "FieldVisitorAccurateLess",
          "new_api": null,
          "old_text": "FieldVisitorAccurateLess()",
          "new_text": null,
          "old_line_content": "                bool is_positive_monotonicity = applyVisitor(FieldVisitorAccurateLess(), left_point, right_point)",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 2322,
          "old_api": "transform",
          "new_api": null,
          "old_text": "transform(right_point)",
          "new_text": null,
          "old_line_content": "                            == applyVisitor(FieldVisitorAccurateLess(), transform(left_point), transform(right_point));",
          "new_line_content": "                    // Check if there is an overflow",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": "helperGetOrConvert<T0, ResultDataType>(col_left_const, left)",
          "new_api": null,
          "old_text": "helperGetOrConvert<T0, ResultDataType>(col_left_const, left)",
          "new_text": null,
          "old_line_content": "                helperGetOrConvert<T0, ResultDataType>(col_left_const, left));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": "static_cast<NativeResultType>(\n                helperGetOrConvert<T1, ResultDataType>(col_right_const, right))",
          "new_api": null,
          "old_text": "static_cast<NativeResultType>(\n                helperGetOrConvert<T1, ResultDataType>(col_right_const, right))",
          "new_text": null,
          "old_line_content": "            const NativeResultType const_b = static_cast<NativeResultType>(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1810,
          "old_api": "checkAndGetColumn<LeftColumnType>(col_left_raw)",
          "new_api": null,
          "old_text": "checkAndGetColumn<LeftColumnType>(col_left_raw)",
          "new_text": null,
          "old_line_content": "                                               : checkAndGetColumn<LeftColumnType>(col_left_raw);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1305,
          "old_api": "OpImplCheck::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b)",
          "new_api": null,
          "old_text": "OpImplCheck::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b)",
          "new_text": null,
          "old_line_content": "                    ? OpImplCheck::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b)",
          "new_line_content": "        if (col_left && col_right)",
          "content_same": false
        },
        {
          "line": 1306,
          "old_api": "OpImpl::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b)",
          "new_api": null,
          "old_text": "OpImpl::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b)",
          "new_text": null,
          "old_line_content": "                    : OpImpl::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1819,
          "old_api": "getN",
          "new_api": null,
          "old_text": "col_left->getN()",
          "new_text": null,
          "old_line_content": "            col_res = LeftColumnType::create(col_left->getN());",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": "getScale",
          "new_api": null,
          "old_text": "type.getScale()",
          "new_text": null,
          "old_line_content": "                .createColumnConst(col_left_const->size(), toField(res, type.getScale()));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": "LeftColumnType::create()",
          "new_api": null,
          "old_text": "LeftColumnType::create()",
          "new_text": null,
          "old_line_content": "            col_res = LeftColumnType::create();",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": "getData",
          "new_api": null,
          "old_text": "col_res->getData()",
          "new_text": null,
          "old_line_content": "        auto & vec_res = col_res->getData();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1827,
          "old_api": "col_right_const->template getValue<T1>()",
          "new_api": null,
          "old_text": "col_right_const->template getValue<T1>()",
          "new_text": null,
          "old_line_content": "            const T1 value = col_right_const->template getValue<T1>();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": "getN",
          "new_api": null,
          "old_text": "col_left->getN()",
          "new_text": null,
          "old_line_content": "                OpImpl::template processFixedString<OpCase::Vector>(in_vec.data(), col_left->getN(), &value, out_vec, 1);",
          "new_line_content": "            if constexpr (std::is_same_v<LeftDataType, DataTypeFixedString>)",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": "getData",
          "new_api": null,
          "old_text": "helperInvokeEither<OpCase::Vector, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(\n                col_left->getData(), col_right->getData(), vec_res, scale_a, scale_b, right_nullmap)",
          "new_text": null,
          "old_line_content": "            helperInvokeEither<OpCase::Vector, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2345,
          "old_api": "removeLowCardinality",
          "new_api": null,
          "old_text": "removeLowCardinality(right.type)",
          "new_text": null,
          "old_line_content": "                auto right_type = removeNullable(removeLowCardinality(right.type));",
          "new_line_content": "                    return point_transformed;",
          "content_same": false
        },
        {
          "line": 2346,
          "old_api": "removeLowCardinality",
          "new_api": null,
          "old_text": "removeLowCardinality(return_type)",
          "new_text": null,
          "old_line_content": "                auto ret_type = removeNullable(removeLowCardinality(return_type));",
          "new_line_content": "                };",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": "getOffsets",
          "new_api": null,
          "old_text": "col_res->getOffsets()",
          "new_text": null,
          "old_line_content": "                ColumnString::Offsets & out_offsets = col_res->getOffsets();",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 1835,
          "old_api": "data",
          "new_api": null,
          "old_text": "col_left->getOffsets().data()",
          "new_text": null,
          "old_line_content": "                OpImpl::template processString<OpCase::Vector>(in_vec.data(), col_left->getOffsets().data(), &value, out_vec, out_offsets, 1);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": "helperGetOrConvert<T0, ResultDataType>(col_left_const, left)",
          "new_api": null,
          "old_text": "helperGetOrConvert<T0, ResultDataType>(col_left_const, left)",
          "new_text": null,
          "old_line_content": "                helperGetOrConvert<T0, ResultDataType>(col_left_const, left));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2351,
          "old_api": "createColumnConst",
          "new_api": null,
          "old_text": "left_type->createColumnConst(1, point)",
          "new_text": null,
          "old_line_content": "                        = {{left_type->createColumnConst(1, point), left_type, left.name},",
          "new_line_content": "                    return {true, true, false, true};",
          "content_same": false
        },
        {
          "line": 2352,
          "old_api": "createColumnConst",
          "new_api": null,
          "old_text": "right_type->createColumnConst(1, (*right.column)[0])",
          "new_text": null,
          "old_line_content": "                           {right_type->createColumnConst(1, (*right.column)[0]), right_type, right.name}};",
          "new_line_content": "                else",
          "content_same": false
        },
        {
          "line": 1327,
          "old_api": "getData",
          "new_api": null,
          "old_text": "helperInvokeEither<OpCase::LeftConstant, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(\n                const_a, col_right->getData(), vec_res, scale_a, scale_b, right_nullmap)",
          "new_text": null,
          "old_line_content": "            helperInvokeEither<OpCase::LeftConstant, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(",
          "new_line_content": "            return nullptr;",
          "content_same": false
        },
        {
          "line": 2354,
          "old_api": "Base::executeImpl(columns_with_constant, ret_type, 1)",
          "new_api": null,
          "old_text": "Base::executeImpl(columns_with_constant, ret_type, 1)",
          "new_text": null,
          "old_line_content": "                    auto col = Base::executeImpl(columns_with_constant, ret_type, 1);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": "getData",
          "new_api": null,
          "old_text": "col_right->getData()",
          "new_text": null,
          "old_line_content": "                const_a, col_right->getData(), vec_res, scale_a, scale_b, right_nullmap);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": "get",
          "new_api": null,
          "old_text": "col->get(0, point_transformed)",
          "new_text": null,
          "old_line_content": "                    col->get(0, point_transformed);",
          "new_line_content": "        if (name_view == \"divide\" || name_view == \"intDiv\")",
          "content_same": false
        },
        {
          "line": 1332,
          "old_api": "static_cast<NativeResultType>(\n                helperGetOrConvert<T1, ResultDataType>(col_right_const, right))",
          "new_api": null,
          "old_text": "static_cast<NativeResultType>(\n                helperGetOrConvert<T1, ResultDataType>(col_right_const, right))",
          "new_text": null,
          "old_line_content": "            const NativeResultType const_b = static_cast<NativeResultType>(",
          "new_line_content": "public:",
          "content_same": false
        },
        {
          "line": 1844,
          "old_api": "size",
          "new_api": null,
          "old_text": "col_left->size()",
          "new_text": null,
          "old_line_content": "                OpImpl::template processFixedString<OpCase::Vector>(in_vec.data(), col_left->getN(), col_right->getData().data(), out_vec, col_left->size());",
          "new_line_content": "            if constexpr (std::is_same_v<LeftDataType, DataTypeFixedString>)",
          "content_same": false
        },
        {
          "line": 1335,
          "old_api": "getData",
          "new_api": null,
          "old_text": "helperInvokeEither<OpCase::RightConstant, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(\n                col_left->getData(), const_b, vec_res, scale_a, scale_b, right_nullmap)",
          "new_text": null,
          "old_line_content": "            helperInvokeEither<OpCase::RightConstant, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": "getOffsets",
          "new_api": null,
          "old_text": "col_res->getOffsets()",
          "new_text": null,
          "old_line_content": "                ColumnString::Offsets & out_offsets = col_res->getOffsets();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1849,
          "old_api": "size",
          "new_api": null,
          "old_text": "col_left->size()",
          "new_text": null,
          "old_line_content": "                out_offsets.reserve(col_left->size());",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 2362,
          "old_api": "transform",
          "new_api": null,
          "old_text": "transform(right_point)",
          "new_text": null,
          "old_line_content": "                    == applyVisitor(FieldVisitorAccurateLess(), transform(left_point), transform(right_point)))",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1850,
          "old_api": "data",
          "new_api": null,
          "old_text": "OpImpl::template processString<OpCase::Vector>(\n                    in_vec.data(), col_left->getOffsets().data(), col_right->getData().data(), out_vec, out_offsets, col_left->size())",
          "new_text": null,
          "old_line_content": "                OpImpl::template processString<OpCase::Vector>(",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "    static constexpr auto name = Name::name;",
          "new_line_content": "    bool useDefaultImplementationForNulls() const override",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": "std::make_shared<FunctionBinaryArithmetic>(context)",
          "new_api": null,
          "old_text": "std::make_shared<FunctionBinaryArithmetic>(context)",
          "new_text": null,
          "old_line_content": "    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionBinaryArithmetic>(context); }",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": "data",
          "new_api": null,
          "old_text": "OpImpl::template processFixedString<OpCase::LeftConstant>(\n                    in_vec.data(), col_left->getN(), col_right->getData().data(), out_vec, col_right->size())",
          "new_text": null,
          "old_line_content": "                OpImpl::template processFixedString<OpCase::LeftConstant>(",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1348,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "    explicit FunctionBinaryArithmetic(ContextPtr context_)",
          "new_line_content": "        /// intDiv or modulo and denominator is Nullable(Something), because it may cause division",
          "content_same": false
        },
        {
          "line": 2373,
          "old_api": "isColumnConst",
          "new_api": null,
          "old_text": "isColumnConst(*left.column)",
          "new_text": null,
          "old_line_content": "            if (left.column && isColumnConst(*left.column))",
          "new_line_content": "                else if (",
          "content_same": false
        },
        {
          "line": 1350,
          "old_api": "decimalCheckArithmeticOverflow",
          "new_api": null,
          "old_text": "decimalCheckArithmeticOverflow(context)",
          "new_text": null,
          "old_line_content": "        check_decimal_overflow(decimalCheckArithmeticOverflow(context))",
          "new_line_content": "        return !division_by_nullable;",
          "content_same": false
        },
        {
          "line": 1863,
          "old_api": "getOffsets",
          "new_api": null,
          "old_text": "col_res->getOffsets()",
          "new_text": null,
          "old_line_content": "                ColumnString::Offsets & out_offsets = col_res->getOffsets();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2376,
          "old_api": "Field",
          "new_api": null,
          "old_text": "Field(0)",
          "new_text": null,
          "old_line_content": "                if (applyVisitor(FieldVisitorAccurateEquals(), constant, Field(0)))",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 1864,
          "old_api": "size",
          "new_api": null,
          "old_text": "col_right->size()",
          "new_text": null,
          "old_line_content": "                out_offsets.reserve(col_right->size());",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": "data",
          "new_api": null,
          "old_text": "OpImpl::template processString<OpCase::LeftConstant>(\n                    in_vec.data(), col_left->getOffsets().data(), col_right->getData().data(), out_vec, out_offsets, col_right->size())",
          "new_text": null,
          "old_line_content": "                OpImpl::template processString<OpCase::LeftConstant>(",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 2379,
          "old_api": "Field",
          "new_api": null,
          "old_text": "Field(0)",
          "new_text": null,
          "old_line_content": "                bool is_constant_positive = applyVisitor(FieldVisitorAccurateLess(), Field(0), constant);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2380,
          "old_api": "Field",
          "new_api": null,
          "old_text": "Field(0)",
          "new_text": null,
          "old_line_content": "                if (applyVisitor(FieldVisitorAccurateLess(), left_point, Field(0))",
          "new_line_content": "            // variable / constant",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": "col_right_const->template getValue<T1>()",
          "new_api": null,
          "old_text": "col_right_const->template getValue<T1>()",
          "new_text": null,
          "old_line_content": "            const T1 value = col_right_const->template getValue<T1>();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": "Field",
          "new_api": null,
          "old_text": "Field(0)",
          "new_text": null,
          "old_line_content": "                    applyVisitor(FieldVisitorAccurateLess(), Field(0), left_point)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": "size",
          "new_api": null,
          "old_text": "col_left->size()",
          "new_text": null,
          "old_line_content": "                OpImpl::template processFixedString<OpCase::RightConstant>(in_vec.data(), col_left->getN(), &value, out_vec, col_left->size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": "getOffsets",
          "new_api": null,
          "old_text": "col_res->getOffsets()",
          "new_text": null,
          "old_line_content": "                ColumnString::Offsets & out_offsets = col_res->getOffsets();",
          "new_line_content": "    template <typename A, typename B>",
          "content_same": false
        },
        {
          "line": 1879,
          "old_api": "size",
          "new_api": null,
          "old_text": "col_left->size()",
          "new_text": null,
          "old_line_content": "                out_offsets.reserve(col_left->size());",
          "new_line_content": "    ColumnPtr executeNumeric(const ColumnsWithTypeAndName & arguments, const A & left, const B & right, const NullMap * right_nullmap) const",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": "data",
          "new_api": null,
          "old_text": "OpImpl::template processString<OpCase::RightConstant>(\n                    in_vec.data(), col_left->getOffsets().data(), &value, out_vec, out_offsets, col_left->size())",
          "new_text": null,
          "old_line_content": "                OpImpl::template processString<OpCase::RightConstant>(",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2393,
          "old_api": "isColumnConst",
          "new_api": null,
          "old_text": "isColumnConst(*right.column)",
          "new_text": null,
          "old_line_content": "            else if (right.column && isColumnConst(*right.column))",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": "isDecimalOrNullableDecimal",
          "new_api": null,
          "old_text": "isDecimalOrNullableDecimal(arguments[1].type)",
          "new_text": null,
          "old_line_content": "                && (isDecimalOrNullableDecimal(arguments[0].type) || isDecimalOrNullableDecimal(arguments[1].type)));",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1881,
          "old_api": "size",
          "new_api": null,
          "old_text": "col_left->size()",
          "new_text": null,
          "old_line_content": "                    in_vec.data(), col_left->getOffsets().data(), &value, out_vec, out_offsets, col_left->size());",
          "new_line_content": "        using LeftDataType = std::decay_t<decltype(left)>;",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": "Field",
          "new_api": null,
          "old_text": "Field(0)",
          "new_text": null,
          "old_line_content": "                if (applyVisitor(FieldVisitorAccurateEquals(), constant, Field(0)))",
          "new_line_content": "    ColumnWithTypeAndName left;",
          "content_same": false
        },
        {
          "line": 1374,
          "old_api": "getReturnTypeImplStatic",
          "new_api": null,
          "old_text": "getReturnTypeImplStatic(arguments, context)",
          "new_text": null,
          "old_line_content": "        return getReturnTypeImplStatic(arguments, context);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2399,
          "old_api": "Field",
          "new_api": null,
          "old_text": "Field(0)",
          "new_text": null,
          "old_line_content": "                bool is_constant_positive = applyVisitor(FieldVisitorAccurateLess(), Field(0), constant);",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": "isAggregateMultiply",
          "new_api": null,
          "old_text": "isAggregateMultiply(arguments[0], arguments[1])",
          "new_text": null,
          "old_line_content": "        if (isAggregateMultiply(arguments[0], arguments[1]))",
          "new_line_content": "                    \"Cannot add aggregate states of different functions: {} and {}\",",
          "content_same": false
        },
        {
          "line": 1382,
          "old_api": "isAggregateFunction",
          "new_api": null,
          "old_text": "WhichDataType(arguments[0]).isAggregateFunction()",
          "new_text": null,
          "old_line_content": "            if (WhichDataType(arguments[0]).isAggregateFunction())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1388,
          "old_api": "isAggregateAddition",
          "new_api": null,
          "old_text": "isAggregateAddition(arguments[0], arguments[1])",
          "new_text": null,
          "old_line_content": "        if (isAggregateAddition(arguments[0], arguments[1]))",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1902,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "            constexpr bool decimal_with_float = (IsDataTypeDecimal<LeftDataType> && IsFloatingPoint<RightDataType>)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2417,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "    static constexpr auto name = Name::name;",
          "new_line_content": "    FunctionBasePtr buildImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & return_type) const override",
          "content_same": false
        },
        {
          "line": 1393,
          "old_api": "getName",
          "new_api": null,
          "old_text": "arguments[1]->getName()",
          "new_text": null,
          "old_line_content": "                    arguments[0]->getName(), arguments[1]->getName());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": "std::make_unique<BinaryArithmeticOverloadResolver>(context)",
          "new_api": null,
          "old_text": "std::make_unique<BinaryArithmeticOverloadResolver>(context)",
          "new_text": null,
          "old_line_content": "        return std::make_unique<BinaryArithmeticOverloadResolver>(context);",
          "new_line_content": "        /// For divide operation we should check only Nullable(Decimal), because only this case can throw division by zero error.",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "    explicit BinaryArithmeticOverloadResolver(ContextPtr context_) : context(context_) {}",
          "new_line_content": "                || (IsOperation<Op>::div_floating",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": "isIPv4",
          "new_api": null,
          "old_text": "isIPv4(arguments[1])",
          "new_text": null,
          "old_line_content": "        if (isIPv4(arguments[0]) || isIPv4(arguments[1]))",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1402,
          "old_api": "std::make_shared<DataTypeUInt32>()",
          "new_api": null,
          "old_text": "std::make_shared<DataTypeUInt32>()",
          "new_text": null,
          "old_line_content": "                    isIPv4(arguments[0]) ? std::make_shared<DataTypeUInt32>() : arguments[0],",
          "new_line_content": "                DataTypes new_arguments {",
          "content_same": false
        },
        {
          "line": 1919,
          "old_api": "castColumn",
          "new_api": null,
          "old_text": "castColumn(arguments[0], converted_type)",
          "new_text": null,
          "old_line_content": "                left_col = castColumn(arguments[0], converted_type);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2439,
          "old_api": "size",
          "new_api": null,
          "old_text": "arguments.size()",
          "new_text": null,
          "old_line_content": "        if (arguments.size() == 2",
          "new_line_content": "                return_type);",
          "content_same": false
        },
        {
          "line": 2440,
          "old_api": "isColumnConst",
          "new_api": null,
          "old_text": "isColumnConst(*arguments[0].column)",
          "new_text": null,
          "old_line_content": "            && ((arguments[0].column && isColumnConst(*arguments[0].column))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2441,
          "old_api": "isColumnConst",
          "new_api": null,
          "old_text": "isColumnConst(*arguments[1].column)",
          "new_text": null,
          "old_line_content": "                || (arguments[1].column && isColumnConst(*arguments[1].column))))",
          "new_line_content": "        auto function = division_by_nullable",
          "content_same": false
        },
        {
          "line": 1415,
          "old_api": "getNestedType",
          "new_api": null,
          "old_text": "static_cast<const DataTypeArray &>(*arguments[0]).getNestedType()",
          "new_text": null,
          "old_line_content": "                        static_cast<const DataTypeArray &>(*arguments[0]).getNestedType(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1416,
          "old_api": "getNestedType",
          "new_api": null,
          "old_text": "static_cast<const DataTypeArray &>(*arguments[1]).getNestedType()",
          "new_text": null,
          "old_line_content": "                        static_cast<const DataTypeArray &>(*arguments[1]).getNestedType(),",
          "new_line_content": "            for (size_t i = 0; i < 2; ++i)",
          "content_same": false
        },
        {
          "line": 1418,
          "old_api": "getReturnTypeImplStatic",
          "new_api": null,
          "old_text": "getReturnTypeImplStatic(new_arguments, context)",
          "new_text": null,
          "old_line_content": "                return std::make_shared<DataTypeArray>(getReturnTypeImplStatic(new_arguments, context));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1927,
          "old_api": "get",
          "new_api": null,
          "old_text": "left_col.get()",
          "new_text": null,
          "old_line_content": "            const auto * const col_left_raw = left_col.get();",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1930,
          "old_api": "size",
          "new_api": null,
          "old_text": "col_left_raw->size()",
          "new_text": null,
          "old_line_content": "            const size_t col_left_size = col_left_raw->size();",
          "new_line_content": "                    col_left_const, col_right_const,",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": "checkAndGetColumnConst<ColVecT0>(col_left_raw)",
          "new_api": null,
          "old_text": "checkAndGetColumnConst<ColVecT0>(col_left_raw)",
          "new_text": null,
          "old_line_content": "            const ColumnConst * const col_left_const = checkAndGetColumnConst<ColVecT0>(col_left_raw);",
          "new_line_content": "                    col_left_size,",
          "content_same": false
        },
        {
          "line": 2448,
          "old_api": "std::make_unique<FunctionToFunctionBaseAdaptor>(\n                function,\n                collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),\n                return_type)",
          "new_api": null,
          "old_text": "std::make_unique<FunctionToFunctionBaseAdaptor>(\n                function,\n                collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),\n                return_type)",
          "new_text": null,
          "old_line_content": "            return std::make_unique<FunctionToFunctionBaseAdaptor>(",
          "new_line_content": "            return_type);",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": "checkAndGetColumnConst<ColVecT1>(col_right_raw)",
          "new_api": null,
          "old_text": "checkAndGetColumnConst<ColVecT1>(col_right_raw)",
          "new_text": null,
          "old_line_content": "            const ColumnConst * const col_right_const = checkAndGetColumnConst<ColVecT1>(col_right_raw);",
          "new_line_content": "                    right_nullmap);",
          "content_same": false
        },
        {
          "line": 2450,
          "old_api": "collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; })",
          "new_api": null,
          "old_text": "collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; })",
          "new_text": null,
          "old_line_content": "                collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1935,
          "old_api": "checkAndGetColumn<ColVecT0>(col_left_raw)",
          "new_api": null,
          "old_text": "checkAndGetColumn<ColVecT0>(col_left_raw)",
          "new_text": null,
          "old_line_content": "            const ColVecT0 * const col_left = checkAndGetColumn<ColVecT0>(col_left_raw);",
          "new_line_content": "            else // can't avoid else and another indentation level, otherwise the compiler would try to instantiate",
          "content_same": false
        },
        {
          "line": 1936,
          "old_api": "checkAndGetColumn<ColVecT1>(col_right_raw)",
          "new_api": null,
          "old_text": "checkAndGetColumn<ColVecT1>(col_right_raw)",
          "new_text": null,
          "old_line_content": "            const ColVecT1 * const col_right = checkAndGetColumn<ColVecT1>(col_right_raw);",
          "new_line_content": "                 // ColVecResult for Decimals which would lead to a compile error.",
          "content_same": false
        },
        {
          "line": 1940,
          "old_api": "executeNumericWithDecimal<LeftDataType, RightDataType, ResultDataType>(\n                    left, right,\n                    col_left_const, col_right_const,\n                    col_left, col_right,\n                    col_left_size,\n                    right_nullmap)",
          "new_api": null,
          "old_text": "executeNumericWithDecimal<LeftDataType, RightDataType, ResultDataType>(\n                    left, right,\n                    col_left_const, col_right_const,\n                    col_left, col_right,\n                    col_left_size,\n                    right_nullmap)",
          "new_text": null,
          "old_line_content": "                return executeNumericWithDecimal<LeftDataType, RightDataType, ResultDataType>(",
          "new_line_content": "                /// non-vector result",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": "isDateTime64",
          "new_api": null,
          "old_text": "isDateTime64(new_arguments[1].type)",
          "new_text": null,
          "old_line_content": "            if (isDateOrDate32(new_arguments[1].type) || isDateTime(new_arguments[1].type) || isDateTime64(new_arguments[1].type))",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1433,
          "old_api": "std::swap(new_arguments[0], new_arguments[1])",
          "new_api": null,
          "old_text": "std::swap(new_arguments[0], new_arguments[1])",
          "new_text": null,
          "old_line_content": "                std::swap(new_arguments[0], new_arguments[1]);",
          "new_line_content": "            ColumnsWithTypeAndName new_arguments(2);",
          "content_same": false
        },
        {
          "line": 2459,
          "old_api": "collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; })",
          "new_api": null,
          "old_text": "collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; })",
          "new_text": null,
          "old_line_content": "            collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1436,
          "old_api": "std::make_shared<DataTypeNumber<DataTypeInterval::FieldType>>()",
          "new_api": null,
          "old_text": "std::make_shared<DataTypeNumber<DataTypeInterval::FieldType>>()",
          "new_text": null,
          "old_line_content": "            new_arguments[1].type = std::make_shared<DataTypeNumber<DataTypeInterval::FieldType>>();",
          "new_line_content": "                new_arguments[i].type = arguments[i];",
          "content_same": false
        },
        {
          "line": 2466,
          "old_api": "size",
          "new_api": null,
          "old_text": "arguments.size()",
          "new_text": null,
          "old_line_content": "        if (arguments.size() != 2)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2467,
          "old_api": "size",
          "new_api": null,
          "old_text": "Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n                \"Number of arguments for function {} doesn't match: passed {}, should be 2\",\n                getName(), arguments.size())",
          "new_text": null,
          "old_line_content": "            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1955,
          "old_api": "OpImpl::process(\n                        col_left_const->template getValue<T0>(),\n                        col_right_const->template getValue<T1>())",
          "new_api": null,
          "old_text": "OpImpl::process(\n                        col_left_const->template getValue<T0>(),\n                        col_right_const->template getValue<T1>())",
          "new_text": null,
          "old_line_content": "                    const auto res = right_nullmap && (*right_nullmap)[0] ? ResultType() : OpImpl::process(",
          "new_line_content": "                if (col_left && col_right)",
          "content_same": false
        },
        {
          "line": 2469,
          "old_api": "size",
          "new_api": null,
          "old_text": "arguments.size()",
          "new_text": null,
          "old_line_content": "                getName(), arguments.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2470,
          "old_api": "FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments>::getReturnTypeImplStatic(arguments, context)",
          "new_api": null,
          "old_text": "FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments>::getReturnTypeImplStatic(arguments, context)",
          "new_text": null,
          "old_line_content": "        return FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments>::getReturnTypeImplStatic(arguments, context);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1956,
          "old_api": "col_left_const->template getValue<T0>()",
          "new_api": null,
          "old_text": "col_left_const->template getValue<T0>()",
          "new_text": null,
          "old_line_content": "                        col_left_const->template getValue<T0>(),",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": "build",
          "new_api": null,
          "old_text": "function_builder->build(new_arguments)",
          "new_text": null,
          "old_line_content": "            auto function = function_builder->build(new_arguments);",
          "new_line_content": "            /// Tuple argument must be second.",
          "content_same": false
        },
        {
          "line": 1962,
          "old_api": "ColVecResult::create()",
          "new_api": null,
          "old_text": "ColVecResult::create()",
          "new_text": null,
          "old_line_content": "                typename ColVecResult::MutablePtr col_res = ColVecResult::create();",
          "new_line_content": "                        right_nullmap);",
          "content_same": false
        },
        {
          "line": 1964,
          "old_api": "getData",
          "new_api": null,
          "old_text": "col_res->getData()",
          "new_text": null,
          "old_line_content": "                auto & vec_res = col_res->getData();",
          "new_line_content": "                else if (col_left_const && col_right)",
          "content_same": false
        },
        {
          "line": 1965,
          "old_api": "resize",
          "new_api": null,
          "old_text": "vec_res.resize(col_left_size)",
          "new_text": null,
          "old_line_content": "                vec_res.resize(col_left_size);",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 1969,
          "old_api": "data",
          "new_api": null,
          "old_text": "OpImpl::template process<OpCase::Vector>(\n                        col_left->getData().data(),\n                        col_right->getData().data(),\n                        vec_res.data(),\n                        vec_res.size(),\n                        right_nullmap)",
          "new_text": null,
          "old_line_content": "                    OpImpl::template process<OpCase::Vector>(",
          "new_line_content": "                        &value,",
          "content_same": false
        },
        {
          "line": 1973,
          "old_api": "size",
          "new_api": null,
          "old_text": "vec_res.size()",
          "new_text": null,
          "old_line_content": "                        vec_res.size(),",
          "new_line_content": "                        right_nullmap);",
          "content_same": false
        },
        {
          "line": 1463,
          "old_api": "isTuple",
          "new_api": null,
          "old_text": "isTuple(new_arguments[0].type)",
          "new_text": null,
          "old_line_content": "            if (isTuple(new_arguments[0].type))",
          "new_line_content": "            for (size_t i = 0; i < 2; ++i)",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": "std::swap(new_arguments[0], new_arguments[1])",
          "new_api": null,
          "old_text": "std::swap(new_arguments[0], new_arguments[1])",
          "new_text": null,
          "old_line_content": "                std::swap(new_arguments[0], new_arguments[1]);",
          "new_line_content": "                new_arguments[i].type = arguments[i];",
          "content_same": false
        },
        {
          "line": 1978,
          "old_api": "col_left_const->template getValue<T0>()",
          "new_api": null,
          "old_text": "col_left_const->template getValue<T0>()",
          "new_text": null,
          "old_line_content": "                    const T0 value = col_left_const->template getValue<T0>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1982,
          "old_api": "data",
          "new_api": null,
          "old_text": "col_right->getData().data()",
          "new_text": null,
          "old_line_content": "                        col_right->getData().data(),",
          "new_line_content": "                else",
          "content_same": false
        },
        {
          "line": 1983,
          "old_api": "data",
          "new_api": null,
          "old_text": "vec_res.data()",
          "new_text": null,
          "old_line_content": "                        vec_res.data(),",
          "new_line_content": "                    return nullptr;",
          "content_same": false
        },
        {
          "line": 1984,
          "old_api": "size",
          "new_api": null,
          "old_text": "vec_res.size()",
          "new_text": null,
          "old_line_content": "                        vec_res.size(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": "col_right_const->template getValue<T1>()",
          "new_api": null,
          "old_text": "col_right_const->template getValue<T1>()",
          "new_text": null,
          "old_line_content": "                    const T1 value = col_right_const->template getValue<T1>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1478,
          "old_api": "build",
          "new_api": null,
          "old_text": "function_builder->build(new_arguments)",
          "new_text": null,
          "old_line_content": "            auto function = function_builder->build(new_arguments);",
          "new_line_content": "            /// Number argument must be second.",
          "content_same": false
        },
        {
          "line": 1991,
          "old_api": "data",
          "new_api": null,
          "old_text": "OpImpl::template process<OpCase::RightConstant>(\n                        col_left->getData().data(), &value, vec_res.data(), vec_res.size(), right_nullmap)",
          "new_text": null,
          "old_line_content": "                    OpImpl::template process<OpCase::RightConstant>(",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1992,
          "old_api": "size",
          "new_api": null,
          "old_text": "vec_res.size()",
          "new_text": null,
          "old_line_content": "                        col_left->getData().data(), &value, vec_res.data(), vec_res.size(), right_nullmap);",
          "new_line_content": "        /// Special case when multiply aggregate function state",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": "isNumber",
          "new_api": null,
          "old_text": "isNumber(new_arguments[0].type)",
          "new_text": null,
          "old_line_content": "            if (isNumber(new_arguments[0].type))",
          "new_line_content": "            using RightDataType = std::decay_t<decltype(right)>;",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": "std::swap(new_arguments[0], new_arguments[1])",
          "new_api": null,
          "old_text": "std::swap(new_arguments[0], new_arguments[1])",
          "new_text": null,
          "old_line_content": "                std::swap(new_arguments[0], new_arguments[1]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1494,
          "old_api": "build",
          "new_api": null,
          "old_text": "function_builder->build(new_arguments)",
          "new_text": null,
          "old_line_content": "            auto function = function_builder->build(new_arguments);",
          "new_line_content": "                (std::is_same_v<DataTypeFixedString, RightDataType> || std::is_same_v<DataTypeString, RightDataType>))",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": "getResultType",
          "new_api": null,
          "old_text": "function->getResultType()",
          "new_text": null,
          "old_line_content": "            return function->getResultType();",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": "get",
          "new_api": null,
          "old_text": "arguments[1].get()",
          "new_text": null,
          "old_line_content": "        const bool valid = castBothTypes(arguments[0].get(), arguments[1].get(), [&](const auto & left, const auto & right)",
          "new_line_content": "                        return false;",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": "getN",
          "new_api": null,
          "old_text": "right.getN()",
          "new_text": null,
          "old_line_content": "                        if (left.getN() == right.getN())",
          "new_line_content": "                    is_bit_hamming_distance",
          "content_same": false
        },
        {
          "line": 1518,
          "old_api": "std::make_shared<DataTypeUInt16>()",
          "new_api": null,
          "old_text": "std::make_shared<DataTypeUInt16>()",
          "new_text": null,
          "old_line_content": "                                type_res = std::make_shared<DataTypeUInt16>();",
          "new_line_content": "                else if constexpr (!Op<LeftDataType, RightDataType>::allow_string_integer)",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": "getN",
          "new_api": null,
          "old_text": "left.getN()",
          "new_text": null,
          "old_line_content": "                                type_res = std::make_shared<LeftDataType>(left.getN());",
          "new_line_content": "                else if constexpr (!IsIntegral<RightDataType>)",
          "content_same": false
        },
        {
          "line": 2035,
          "old_api": "getFunctionForTupleArithmetic",
          "new_api": null,
          "old_text": "getFunctionForTupleArithmetic(arguments[0].type, arguments[1].type, context)",
          "new_text": null,
          "old_line_content": "        if (auto function_builder = getFunctionForTupleArithmetic(arguments[0].type, arguments[1].type, context))",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2037,
          "old_api": "build",
          "new_api": null,
          "old_text": "function_builder->build(arguments)->execute(arguments, result_type, input_rows_count)",
          "new_text": null,
          "old_line_content": "            return function_builder->build(arguments)->execute(arguments, result_type, input_rows_count);",
          "new_line_content": "    ColumnPtr executeImpl2(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count, const NullMap * right_nullmap = nullptr) const",
          "content_same": false
        },
        {
          "line": 1529,
          "old_api": "std::make_shared<DataTypeUInt64>()",
          "new_api": null,
          "old_text": "std::make_shared<DataTypeUInt64>()",
          "new_text": null,
          "old_line_content": "                    type_res = std::make_shared<DataTypeUInt64>();",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 2043,
          "old_api": "executeTupleNumberOperator",
          "new_api": null,
          "old_text": "executeTupleNumberOperator(arguments, result_type, input_rows_count, function_builder)",
          "new_text": null,
          "old_line_content": "            return executeTupleNumberOperator(arguments, result_type, input_rows_count, function_builder);",
          "new_line_content": "        /// is Nullable(Something) to prevent division by zero error.",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 113,
      "total_additions": 239,
      "total_deletions": 244,
      "total_api_changes": 596
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 15,
        "api_related_lines": 596,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          1184,
          1186,
          1178
        ]
      }
    },
    "api_calls_before": 931,
    "api_calls_after": 923,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 15,
      "total_diff_lines": 37
    }
  }
}