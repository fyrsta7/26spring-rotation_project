{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/hyperscan/modified_file/843ca0e7ccb651f4bfc45abcb81a95c34b920256",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/hyperscan/modified_file/843ca0e7ccb651f4bfc45abcb81a95c34b920256/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/hyperscan/modified_file/843ca0e7ccb651f4bfc45abcb81a95c34b920256/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/hyperscan/modified_file/843ca0e7ccb651f4bfc45abcb81a95c34b920256/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 666,
          "old_api": "end",
          "new_api": "find",
          "old_text": "accel->precalc.end()",
          "new_text": "accel->precalc.find(state_set)",
          "old_line_content": "        if (p_it != accel->precalc.end()) {",
          "new_line_content": "        auto p_it = accel->precalc.find(state_set);",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "assert",
          "new_api": "max",
          "old_text": "assert(offset <= MAX_ACCEL_DEPTH)",
          "new_text": "max(pa.double_offset, pa.single_offset)",
          "old_line_content": "            assert(offset <= MAX_ACCEL_DEPTH);",
          "new_line_content": "            offset = max(pa.double_offset, pa.single_offset);",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": "doAccelCommon",
          "new_api": "nfaFindAccelSchemes",
          "old_text": "doAccelCommon(bi.h, bi.accel.accel_map, bi.state_ids, bi.br_cyclic,\n                  bi.num_states, &bi.accel, bi.cc)",
          "new_text": "nfaFindAccelSchemes(bi.h, bi.br_cyclic, &bi.accel.accel_map)",
          "old_line_content": "    doAccelCommon(bi.h, bi.accel.accel_map, bi.state_ids, bi.br_cyclic,",
          "new_line_content": "    nfaFindAccelSchemes(bi.h, bi.br_cyclic, &bi.accel.accel_map);",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": "DEBUG_PRINTF",
          "new_api": "gatherAccelStates",
          "old_text": "DEBUG_PRINTF(\"no accelerable states\\n\")",
          "new_text": "gatherAccelStates(args, accelStates)",
          "old_line_content": "        DEBUG_PRINTF(\"no accelerable states\\n\");",
          "new_line_content": "    gatherAccelStates(args, accelStates);",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": "minimiseAccel",
          "new_api": "combineAccel",
          "old_text": "minimiseAccel(accelOuts[i])",
          "new_text": "combineAccel(accelStates[j], accelOuts[i])",
          "old_line_content": "        minimiseAccel(accelOuts[i]);",
          "new_line_content": "                combineAccel(accelStates[j], accelOuts[i]);",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": "resize",
          "new_api": "minimiseAccel",
          "old_text": "accelTable.resize(accelCount)",
          "new_text": "minimiseAccel(accelOuts[i])",
          "old_line_content": "    accelTable.resize(accelCount);",
          "new_line_content": "        minimiseAccel(accelOuts[i]);",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": "size",
          "new_api": "memset",
          "old_text": "accelStates.size()",
          "new_text": "memset(&aux, 0, sizeof(aux))",
          "old_line_content": "        for (u32 j = 0; j < accelStates.size(); j++) {",
          "new_line_content": "        memset(&aux, 0, sizeof(aux));",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": "push_back",
          "new_api": "AccelAuxCmp",
          "old_text": "auxvec.push_back(aux)",
          "new_text": "AccelAuxCmp(aux)",
          "old_line_content": "            auxvec.push_back(aux);",
          "new_line_content": "        auto it = find_if(auxvec.begin(), auxvec.end(), AccelAuxCmp(aux));",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "begin",
          "new_api": "size",
          "old_text": "auxvec.begin()",
          "new_text": "auxvec.size()",
          "old_line_content": "            accelTable[i] = verify_u8(it - auxvec.begin());",
          "new_line_content": "            accelTable[i] = verify_u8(auxvec.size());",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": "set",
          "new_api": "at",
          "old_text": "accelFriendsMask.set(as.state)",
          "new_text": "args.state_ids.at(v)",
          "old_line_content": "        accelFriendsMask.set(as.state);",
          "new_line_content": "        assert(v && args.state_ids.at(v) == as.state);",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": "contains",
          "new_api": "set",
          "old_text": "contains(accel.friends, v)",
          "new_text": "accelMask.set(as.state)",
          "old_line_content": "        if (!contains(accel.friends, v)) {",
          "new_line_content": "        accelMask.set(as.state);",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": "DEBUG_PRINTF",
          "new_api": "size",
          "old_text": "DEBUG_PRINTF(\"--> %u\\n\", state_id)",
          "new_text": "friends.size()",
          "old_line_content": "            DEBUG_PRINTF(\"--> %u\\n\", state_id);",
          "new_line_content": "        DEBUG_PRINTF(\"%u has %zu friends\\n\", as.state, friends.size());",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": "vertices_range",
          "new_api": "resize",
          "old_text": "vertices_range(h)",
          "new_text": "acceptMask.resize(args.num_states)",
          "old_line_content": "    for (auto v : vertices_range(h)) {",
          "new_line_content": "    acceptMask.resize(args.num_states);",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": "at",
          "new_api": "resize",
          "old_text": "args.state_ids.at(v)",
          "new_text": "acceptEodMask.resize(args.num_states)",
          "old_line_content": "        u32 state_id = args.state_ids.at(v);",
          "new_line_content": "    acceptEodMask.resize(args.num_states);",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "is_match_vertex",
          "new_api": "vertices_range",
          "old_text": "is_match_vertex(v, h)",
          "new_text": "vertices_range(h)",
          "old_line_content": "        if (state_id == NO_STATE || !is_match_vertex(v, h)) {",
          "new_line_content": "    for (auto v : vertices_range(h)) {",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": "size",
          "new_api": "end",
          "old_text": "squash.size()",
          "new_text": "squash.end()",
          "old_line_content": "                squashMaskOffset = verify_u32(squash.size());",
          "new_line_content": "            if (it != squash.end()) {",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "push_back",
          "new_api": "begin",
          "old_text": "squash.push_back(sit->second)",
          "new_text": "squash.begin()",
          "old_line_content": "                squash.push_back(sit->second);",
          "new_line_content": "                squashMaskOffset = verify_u32(distance(squash.begin(), it));",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": "edge",
          "new_api": "set",
          "old_text": "edge(v, h.acceptEod, h)",
          "new_text": "acceptMask.set(state_id)",
          "old_line_content": "            assert(edge(v, h.acceptEod, h).second);",
          "new_line_content": "            acceptMask.set(state_id);",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": "NFAStateSet",
          "new_api": "DEBUG_PRINTF",
          "old_text": "NFAStateSet(args.num_states)",
          "new_text": "DEBUG_PRINTF(\"we have %u top masks\\n\", numMasks)",
          "old_line_content": "    topMasks.assign(numMasks, NFAStateSet(args.num_states)); // all zeroes",
          "new_line_content": "    DEBUG_PRINTF(\"we have %u top masks\\n\", numMasks);",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": "assert",
          "new_api": "at",
          "old_text": "assert(mask_idx < numMasks)",
          "new_text": "args.state_ids.at(m.second)",
          "old_line_content": "        assert(mask_idx < numMasks);",
          "new_line_content": "        u32 state_id = args.state_ids.at(m.second);",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": "assert",
          "new_api": "DEBUG_PRINTF",
          "old_text": "assert(state_id != NO_STATE)",
          "new_text": "DEBUG_PRINTF(\"state %u is in top mask %u\\n\", state_id, mask_idx)",
          "old_line_content": "        assert(state_id != NO_STATE);",
          "new_line_content": "        DEBUG_PRINTF(\"state %u is in top mask %u\\n\", state_id, mask_idx);",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "set",
          "new_api": "assert",
          "old_text": "topMasks[mask_idx].set(state_id)",
          "new_text": "assert(mask_idx < numMasks)",
          "old_line_content": "        topMasks[mask_idx].set(state_id);",
          "new_line_content": "        assert(mask_idx < numMasks);",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "size",
          "new_api": "at",
          "old_text": "initDs.size()",
          "new_text": "DEBUG_PRINTF(\"checking squash mask for state %u\\n\",\n                     args.state_ids.at(m.first))",
          "old_line_content": "        assert(squashed.size() == initDs.size());",
          "new_line_content": "        DEBUG_PRINTF(\"checking squash mask for state %u\\n\",",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": "intersects",
          "new_api": "at",
          "old_text": "squashed.intersects(initDs)",
          "new_text": "args.state_ids.at(m.first)",
          "old_line_content": "        if (squashed.intersects(initDs)) {",
          "new_line_content": "                     args.state_ids.at(m.first));",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": "at",
          "new_api": "size",
          "old_text": "args.state_ids.at(m.first)",
          "new_text": "initDs.size()",
          "old_line_content": "                         args.state_ids.at(m.first));",
          "new_line_content": "        assert(squashed.size() == initDs.size());",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": "size",
          "new_api": "at",
          "old_text": "initDs.size()",
          "new_text": "DEBUG_PRINTF(\"checking report squash mask for state %u\\n\",\n                     args.state_ids.at(m.first))",
          "old_line_content": "        assert(squashed.size() == initDs.size());",
          "new_line_content": "        DEBUG_PRINTF(\"checking report squash mask for state %u\\n\",",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": "intersects",
          "new_api": "at",
          "old_text": "squashed.intersects(initDs)",
          "new_text": "args.state_ids.at(m.first)",
          "old_line_content": "        if (squashed.intersects(initDs)) {",
          "new_line_content": "                     args.state_ids.at(m.first));",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": "at",
          "new_api": "size",
          "old_text": "args.state_ids.at(m.first)",
          "new_text": "initDs.size()",
          "old_line_content": "                         args.state_ids.at(m.first));",
          "new_line_content": "        assert(squashed.size() == initDs.size());",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "at",
          "new_api": "generates_callbacks",
          "old_text": "args.state_ids.at(h.startDs)",
          "new_text": "generates_callbacks(h)",
          "old_line_content": "        u32 sds_i = args.state_ids.at(h.startDs);",
          "new_line_content": "    if (!generates_callbacks(h)) {",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": "DEBUG_PRINTF",
          "new_api": "at",
          "old_text": "DEBUG_PRINTF(\"masking out initds state\\n\")",
          "new_text": "args.state_ids.at(h.startDs)",
          "old_line_content": "            DEBUG_PRINTF(\"masking out initds state\\n\");",
          "new_line_content": "        u32 sds_i = args.state_ids.at(h.startDs);",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": "source",
          "new_api": "hasInitDsStates",
          "old_text": "source(e, h)",
          "new_text": "hasInitDsStates(h, args.state_ids)",
          "old_line_content": "            u32 from = args.state_ids.at(source(e, h));",
          "new_line_content": "    if (generates_callbacks(h) && !hasInitDsStates(h, args.state_ids)) {",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": "assert",
          "new_api": "maskFill",
          "old_text": "assert(sizeUncompressed <= sizeof(limex->compressMask))",
          "new_text": "maskFill(limex->compressMask, 0xff)",
          "old_line_content": "    assert(sizeUncompressed <= sizeof(limex->compressMask));",
          "new_line_content": "    maskFill(limex->compressMask, 0xff);",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": "DEBUG_PRINTF",
          "new_api": "assert",
          "old_text": "DEBUG_PRINTF(\"compression disabled, uncompressed state size %u\\n\",\n                     sizeUncompressed)",
          "new_text": "assert(sizeUncompressed <= sizeof(limex->compressMask))",
          "old_line_content": "        DEBUG_PRINTF(\"compression disabled, uncompressed state size %u\\n\",",
          "new_line_content": "    assert(sizeUncompressed <= sizeof(limex->compressMask));",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": "assert",
          "new_api": "findMaskedCompressionStates",
          "old_text": "assert(sizeCompressed <= sizeof(limex->compressMask))",
          "new_text": "findMaskedCompressionStates(args, maskedStates)",
          "old_line_content": "    assert(sizeCompressed <= sizeof(limex->compressMask));",
          "new_line_content": "    findMaskedCompressionStates(args, maskedStates);",
          "content_same": false
        },
        {
          "line": 1069,
          "old_api": "DEBUG_PRINTF",
          "new_api": "compressedStateSize",
          "old_text": "DEBUG_PRINTF(\"compressed=%u, uncompressed=%u\\n\", sizeCompressed,\n                 sizeUncompressed)",
          "new_text": "compressedStateSize(args.h, maskedStates, args.state_ids)",
          "old_line_content": "    DEBUG_PRINTF(\"compressed=%u, uncompressed=%u\\n\", sizeCompressed,",
          "new_line_content": "    u32 sizeCompressed = compressedStateSize(args.h, maskedStates, args.state_ids);",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": "any",
          "new_api": "setLimexFlag",
          "old_text": "maskedStates.any()",
          "new_text": "setLimexFlag(limex, LIMEX_FLAG_COMPRESS_STATE)",
          "old_line_content": "        if (maskedStates.any()) {",
          "new_line_content": "        setLimexFlag(limex, LIMEX_FLAG_COMPRESS_STATE);",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "find_first",
          "new_api": "any",
          "old_text": "maskedStates.find_first()",
          "new_text": "maskedStates.any()",
          "old_line_content": "            for (size_t i = maskedStates.find_first(); i != NFAStateSet::npos;",
          "new_line_content": "        if (maskedStates.any()) {",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": "find_next",
          "new_api": "count",
          "old_text": "maskedStates.find_next(i)",
          "new_text": "maskedStates.count()",
          "old_line_content": "                    i = maskedStates.find_next(i)) {",
          "new_line_content": "            DEBUG_PRINTF(\"masking %zu states\\n\", maskedStates.count());",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": "maskClearBit",
          "new_api": "setLimexFlag",
          "old_text": "maskClearBit(limex->compressMask, i)",
          "new_text": "setLimexFlag(limex, LIMEX_FLAG_COMPRESS_MASKED)",
          "old_line_content": "                maskClearBit(limex->compressMask, i);",
          "new_line_content": "            setLimexFlag(limex, LIMEX_FLAG_COMPRESS_MASKED);",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": "size",
          "new_api": "find",
          "old_text": "exceptionReports.size()",
          "new_text": "reportListCache.find(r)",
          "old_line_content": "        assert(idx < exceptionReports.size());",
          "new_line_content": "    auto it = reportListCache.find(r);",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": "begin",
          "new_api": "end",
          "old_text": "exceptionReports.begin()",
          "new_text": "reportListCache.end()",
          "old_line_content": "        assert(equal(r.begin(), r.end(), exceptionReports.begin() + idx));",
          "new_line_content": "    if (it != reportListCache.end()) {",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": "push_back",
          "new_api": "size",
          "old_text": "exceptionReports.push_back(MO_INVALID_IDX)",
          "new_text": "exceptionReports.size()",
          "old_line_content": "    exceptionReports.push_back(MO_INVALID_IDX); // terminator",
          "new_line_content": "    u32 idx = verify_u32(exceptionReports.size());",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": "getReportListIndex",
          "new_api": "size",
          "old_text": "getReportListIndex(reports, exceptionReports, reportListCache)",
          "new_text": "reports.size()",
          "old_line_content": "                getReportListIndex(reports, exceptionReports, reportListCache);",
          "new_line_content": "                         \"(%zu reports)\\n\", i, reports.size());",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": "find",
          "new_api": "getReportListIndex",
          "old_text": "args.reportSquashMap.find(v)",
          "new_text": "getReportListIndex(reports, exceptionReports, reportListCache)",
          "old_line_content": "            auto mi = args.reportSquashMap.find(v);",
          "new_line_content": "                getReportListIndex(reports, exceptionReports, reportListCache);",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": "size",
          "new_api": "find",
          "old_text": "mi->second.size()",
          "new_text": "args.reportSquashMap.find(v)",
          "old_line_content": "                assert(e.squash_states.size() == mi->second.size());",
          "new_line_content": "            auto mi = args.reportSquashMap.find(v);",
          "content_same": false
        },
        {
          "line": 1224,
          "old_api": "DEBUG_PRINTF",
          "new_api": "assert",
          "old_text": "DEBUG_PRINTF(\"state %u has pos trigger for repeat %u\\n\", i,\n                         repeat_index)",
          "new_text": "assert(e.trigger == LIMEX_TRIGGER_NONE)",
          "old_line_content": "            DEBUG_PRINTF(\"state %u has pos trigger for repeat %u\\n\", i,",
          "new_line_content": "            assert(e.trigger == LIMEX_TRIGGER_NONE);",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": "DEBUG_PRINTF",
          "new_api": "at",
          "old_text": "DEBUG_PRINTF(\"state %u has tug trigger for repeat %u, can squash \"\n                         \"state %u\\n\", i, repeat_index, cyclic)",
          "new_text": "args.state_ids.at(args.repeats[repeat_index].cyclic)",
          "old_line_content": "            DEBUG_PRINTF(\"state %u has tug trigger for repeat %u, can squash \"",
          "new_line_content": "            u32 cyclic = args.state_ids.at(args.repeats[repeat_index].cyclic);",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": "at",
          "new_api": "out_edges_range",
          "old_text": "args.state_ids.at(w)",
          "new_text": "out_edges_range(v, h)",
          "old_line_content": "                u32 w_idx = args.state_ids.at(w);",
          "new_line_content": "        for (const auto &oe : out_edges_range(v, h)) {",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": "assert",
          "new_api": "contains",
          "old_text": "assert(w_idx != NO_STATE)",
          "new_text": "contains(exceptional, oe)",
          "old_line_content": "                assert(w_idx != NO_STATE);",
          "new_line_content": "            if (contains(exceptional, oe)) {",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": "set",
          "new_api": "target",
          "old_text": "e.succ_states.set(w_idx)",
          "new_text": "target(oe, h)",
          "old_line_content": "                e.succ_states.set(w_idx);",
          "new_line_content": "                NFAVertex w = target(oe, h);",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": "DEBUG_PRINTF",
          "new_api": "at",
          "old_text": "DEBUG_PRINTF(\"exceptional transition %u->%u\\n\", i, w_idx)",
          "new_text": "args.state_ids.at(w)",
          "old_line_content": "                DEBUG_PRINTF(\"exceptional transition %u->%u\\n\", i, w_idx);",
          "new_line_content": "                u32 w_idx = args.state_ids.at(w);",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": "size",
          "new_api": "find",
          "old_text": "DEBUG_PRINTF(\"e.squash_states.size() == %zu, \"\n                                 \"mi->second.size() = %zu\\n\",\n                                 e.squash_states.size(), mi->second.size())",
          "new_text": "args.squashMap.find(w)",
          "old_line_content": "                    DEBUG_PRINTF(\"e.squash_states.size() == %zu, \"",
          "new_line_content": "                auto mi = args.squashMap.find(w);",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": "size",
          "new_api": "DEBUG_PRINTF",
          "old_text": "mi->second.size()",
          "new_text": "DEBUG_PRINTF(\"squasher edge (%u, %u)\\n\", i, j)",
          "old_line_content": "                                 e.squash_states.size(), mi->second.size());",
          "new_line_content": "                    DEBUG_PRINTF(\"squasher edge (%u, %u)\\n\", i, j);",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": "at",
          "new_api": "source",
          "old_text": "state_ids.at(to)",
          "new_text": "source(e, h)",
          "old_line_content": "        u32 t = state_ids.at(to);",
          "new_line_content": "        NFAVertex from = source(e, h);",
          "content_same": false
        },
        {
          "line": 1330,
          "old_api": "isLimitedTransition",
          "new_api": "target",
          "old_text": "isLimitedTransition(f, t, NFATraits<dtype>::maxShift)",
          "new_text": "target(e, h)",
          "old_line_content": "        if (!isLimitedTransition(f, t, NFATraits<dtype>::maxShift)) {",
          "new_line_content": "        NFAVertex to = target(e, h);",
          "content_same": false
        },
        {
          "line": 1401,
          "old_api": "end",
          "new_api": "size",
          "old_text": "args.repeats.end()",
          "new_text": "args.repeats.size()",
          "old_line_content": "        for (auto it = args.repeats.begin(), ite = args.repeats.end();",
          "new_line_content": "        out.reserve(args.repeats.size());",
          "content_same": false
        },
        {
          "line": 1404,
          "old_api": "at",
          "new_api": "end",
          "old_text": "args.state_ids.at(br.cyclic)",
          "new_text": "args.repeats.end()",
          "old_line_content": "            assert(args.state_ids.at(br.cyclic) != NO_STATE);",
          "new_line_content": "        for (auto it = args.repeats.begin(), ite = args.repeats.end();",
          "content_same": false
        },
        {
          "line": 1407,
          "old_api": "repeatAllocSize",
          "new_api": "at",
          "old_text": "repeatAllocSize(br, &tableOffset, &tugMaskOffset)",
          "new_text": "args.state_ids.at(br.cyclic)",
          "old_line_content": "            size_t len = repeatAllocSize(br, &tableOffset, &tugMaskOffset);",
          "new_line_content": "            assert(args.state_ids.at(br.cyclic) != NO_STATE);",
          "content_same": false
        },
        {
          "line": 1458,
          "old_api": "assert",
          "new_api": "maskSetBit",
          "old_text": "assert(streamStateLen)",
          "new_text": "maskSetBit(*tugMask, state_id)",
          "old_line_content": "            assert(streamStateLen);",
          "new_line_content": "                maskSetBit(*tugMask, state_id);",
          "content_same": false
        },
        {
          "line": 1475,
          "old_api": "maskSetBit",
          "new_api": "at",
          "old_text": "maskSetBit(limex->init, s_i)",
          "new_text": "args.state_ids.at(h.startDs)",
          "old_line_content": "            maskSetBit(limex->init, s_i);",
          "new_line_content": "        u32 sds_i = args.state_ids.at(h.startDs);",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": "ISALIGNED",
          "new_api": "memset",
          "old_text": "ISALIGNED(etable)",
          "new_text": "memset(limex->exceptionMap, 0xff, sizeof(limex->exceptionMap))",
          "old_line_content": "        assert(ISALIGNED(etable));",
          "new_line_content": "        memset(limex->exceptionMap, 0xff, sizeof(limex->exceptionMap));",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": "verify_u8",
          "new_api": "maskSetBits",
          "old_text": "verify_u8(proto.squash)",
          "new_text": "maskSetBits(e.squash, proto.squash_states)",
          "old_line_content": "            e.hasSquash = verify_u8(proto.squash);",
          "new_line_content": "            maskSetBits(e.squash, proto.squash_states);",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": "verify_u8",
          "new_api": "maskSetBits",
          "old_text": "verify_u8(proto.trigger)",
          "new_text": "maskSetBits(e.successors, proto.succ_states)",
          "old_line_content": "            e.trigger = verify_u8(proto.trigger);",
          "new_line_content": "            maskSetBits(e.successors, proto.succ_states);",
          "content_same": false
        },
        {
          "line": 1592,
          "old_api": "end",
          "new_api": "DEBUG_PRINTF",
          "old_text": "reachMap.end()",
          "new_text": "DEBUG_PRINTF(\"reachOffset=%u\\n\", reachOffset)",
          "old_line_content": "        copy(reachMap.begin(), reachMap.end(), &limex->reachMap[0]);",
          "new_line_content": "        DEBUG_PRINTF(\"reachOffset=%u\\n\", reachOffset);",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": "maskSetBits",
          "new_api": "ISALIGNED",
          "old_text": "maskSetBits(topMasks[i], tops[i])",
          "new_text": "ISALIGNED(topMasks)",
          "old_line_content": "            maskSetBits(topMasks[i], tops[i]);",
          "new_line_content": "        assert(ISALIGNED(topMasks));",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": "size",
          "new_api": "maskSetBits",
          "old_text": "tops.size()",
          "new_text": "maskSetBits(topMasks[i], tops[i])",
          "old_line_content": "        limex->topCount = verify_u32(tops.size());",
          "new_line_content": "            maskSetBits(topMasks[i], tops[i]);",
          "content_same": false
        },
        {
          "line": 1628,
          "old_api": "DEBUG_PRINTF",
          "new_api": "find_first",
          "old_text": "DEBUG_PRINTF(\"accel num=%u, state=%u\\n\", num, state_id)",
          "new_text": "accelMask.find_first()",
          "old_line_content": "            DEBUG_PRINTF(\"accel num=%u, state=%u\\n\", num, state_id);",
          "new_line_content": "        for (size_t i = accelMask.find_first(); i != accelMask.npos;",
          "content_same": false
        },
        {
          "line": 1635,
          "old_api": "maskSetByte",
          "new_api": "DEBUG_PRINTF",
          "old_text": "maskSetByte(*perm, num, ((state_id % 128U) / 8U))",
          "new_text": "DEBUG_PRINTF(\"mask_idx=%zu\\n\", mask_idx)",
          "old_line_content": "            maskSetByte(*perm, num, ((state_id % 128U) / 8U));",
          "new_line_content": "            DEBUG_PRINTF(\"mask_idx=%zu\\n\", mask_idx);",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": "size",
          "new_api": "end",
          "old_text": "accelTable.size()",
          "new_text": "accelAux.end()",
          "old_line_content": "        limex->accelCount = verify_u32(accelTable.size());",
          "new_line_content": "        copy(accelAux.begin(), accelAux.end(), auxTable);",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": "maskSetBits",
          "new_api": "size",
          "old_text": "maskSetBits(limex->accel, accelMask)",
          "new_text": "accelAux.size()",
          "old_line_content": "        maskSetBits(limex->accel, accelMask);",
          "new_line_content": "        limex->accelAuxCount = verify_u32(accelAux.size());",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": "writeAccelSsse3Masks",
          "new_api": "maskClear",
          "old_text": "writeAccelSsse3Masks(accelMask, limex)",
          "new_text": "maskClear(limex->accelCompare)",
          "old_line_content": "            writeAccelSsse3Masks(accelMask, limex);",
          "new_line_content": "        maskClear(limex->accelCompare);",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": "ISALIGNED",
          "new_api": "size",
          "old_text": "ISALIGNED(acceptsTable)",
          "new_text": "accepts.size()",
          "old_line_content": "        assert(ISALIGNED(acceptsTable));",
          "new_line_content": "        limex->acceptCount = verify_u32(accepts.size());",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": "end",
          "new_api": "size",
          "old_text": "accepts.end()",
          "new_text": "accepts.size()",
          "old_line_content": "        copy(accepts.begin(), accepts.end(), acceptsTable);",
          "new_line_content": "        DEBUG_PRINTF(\"NFA has %zu accepts\\n\", accepts.size());",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "ISALIGNED",
          "new_api": "size",
          "old_text": "ISALIGNED(acceptsEodTable)",
          "new_text": "acceptsEod.size()",
          "old_line_content": "        assert(ISALIGNED(acceptsEodTable));",
          "new_line_content": "        limex->acceptEodCount = verify_u32(acceptsEod.size());",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": "end",
          "new_api": "size",
          "old_text": "acceptsEod.end()",
          "new_text": "acceptsEod.size()",
          "old_line_content": "        copy(acceptsEod.begin(), acceptsEod.end(), acceptsEodTable);",
          "new_line_content": "        DEBUG_PRINTF(\"NFA has %zu EOD accepts\\n\", acceptsEod.size());",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": "size",
          "new_api": "end",
          "old_text": "squash.size()",
          "new_text": "acceptsEod.end()",
          "old_line_content": "        limex->squashCount = verify_u32(squash.size());",
          "new_line_content": "        copy(acceptsEod.begin(), acceptsEod.end(), acceptsEodTable);",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": "resize",
          "new_api": "DEBUG_PRINTF",
          "old_text": "repeatOffsets.resize(num_repeats)",
          "new_text": "DEBUG_PRINTF(\"repeatOffsetsOffset=%u, repeatOffset=%u\\n\",\n                      repeatOffsetsOffset, repeatOffset)",
          "old_line_content": "        repeatOffsets.resize(num_repeats);",
          "new_line_content": "        DEBUG_PRINTF(\"repeatOffsetsOffset=%u, repeatOffset=%u\\n\",",
          "content_same": false
        },
        {
          "line": 1756,
          "old_api": "ISALIGNED_N",
          "new_api": "DEBUG_PRINTF",
          "old_text": "ISALIGNED_N((char *)limex + exceptionReportsOffset,\n                           alignof(ReportID))",
          "new_text": "DEBUG_PRINTF(\"exceptionReportsOffset=%u\\n\", exceptionReportsOffset)",
          "old_line_content": "        assert(ISALIGNED_N((char *)limex + exceptionReportsOffset,",
          "new_line_content": "        DEBUG_PRINTF(\"exceptionReportsOffset=%u\\n\", exceptionReportsOffset);",
          "content_same": false
        },
        {
          "line": 1785,
          "old_api": "DEBUG_PRINTF",
          "new_api": "buildExceptionMap",
          "old_text": "DEBUG_PRINTF(\"too many exceptions!\\n\")",
          "new_text": "buildExceptionMap(args, exceptional, exceptionMap, exceptionReports)",
          "old_line_content": "            DEBUG_PRINTF(\"too many exceptions!\\n\");",
          "new_line_content": "        buildExceptionMap(args, exceptional, exceptionMap, exceptionReports);",
          "content_same": false
        },
        {
          "line": 1861,
          "old_api": "get",
          "new_api": "aligned_zmalloc_unique<NFA>(nfaSize)",
          "old_text": "nfa.get()",
          "new_text": "aligned_zmalloc_unique<NFA>(nfaSize)",
          "old_line_content": "        implNFA_t *limex = (implNFA_t *)getMutableImplNfa(nfa.get());",
          "new_line_content": "        auto nfa = aligned_zmalloc_unique<NFA>(nfaSize);",
          "content_same": false
        },
        {
          "line": 1862,
          "old_api": "ISALIGNED",
          "new_api": "assert",
          "old_text": "ISALIGNED(limex)",
          "new_text": "assert(nfa)",
          "old_line_content": "        assert(ISALIGNED(limex));",
          "new_line_content": "        assert(nfa); // otherwise we would have thrown std::bad_alloc",
          "content_same": false
        },
        {
          "line": 1864,
          "old_api": "writeReachMapping",
          "new_api": "get",
          "old_text": "writeReachMapping(reach, reachMap, limex, reachOffset)",
          "new_text": "nfa.get()",
          "old_line_content": "        writeReachMapping(reach, reachMap, limex, reachOffset);",
          "new_line_content": "        implNFA_t *limex = (implNFA_t *)getMutableImplNfa(nfa.get());",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": "writeAccepts",
          "new_api": "writeAccel",
          "old_text": "writeAccepts(acceptMask, acceptEodMask, accepts, acceptsEod, squash,\n                     limex, acceptsOffset, acceptsEodOffset, squashOffset)",
          "new_text": "writeAccel(accelMask, accelFriendsMask, accelAux, accelTable,\n                   limex, accelTableOffset, accelAuxOffset)",
          "old_line_content": "        writeAccepts(acceptMask, acceptEodMask, accepts, acceptsEod, squash,",
          "new_line_content": "        writeAccel(accelMask, accelFriendsMask, accelAux, accelTable,",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": "writeShiftMasks",
          "new_api": "writeAccepts",
          "old_text": "writeShiftMasks(args, limex)",
          "new_text": "writeAccepts(acceptMask, acceptEodMask, accepts, acceptsEod, squash,\n                     limex, acceptsOffset, acceptsEodOffset, squashOffset)",
          "old_line_content": "        writeShiftMasks(args, limex);",
          "new_line_content": "        writeAccepts(acceptMask, acceptEodMask, accepts, acceptsEod, squash,",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": "findStateSize",
          "new_api": "writeShiftMasks",
          "old_text": "findStateSize(args, limex)",
          "new_text": "writeShiftMasks(args, limex)",
          "old_line_content": "        findStateSize(args, limex);",
          "new_line_content": "        writeShiftMasks(args, limex);",
          "content_same": false
        },
        {
          "line": 1886,
          "old_api": "writeExceptions",
          "new_api": "writeRepeats",
          "old_text": "writeExceptions(exceptionMap, repeatOffsets, limex, exceptionsOffset)",
          "new_text": "writeRepeats(repeats, repeatOffsets, limex, repeatOffsetsOffset,\n                     repeatsOffset)",
          "old_line_content": "        writeExceptions(exceptionMap, repeatOffsets, limex, exceptionsOffset);",
          "new_line_content": "        writeRepeats(repeats, repeatOffsets, limex, repeatOffsetsOffset,",
          "content_same": false
        },
        {
          "line": 1893,
          "old_api": "verify_u32",
          "new_api": "get",
          "old_text": "verify_u32(nfaSize)",
          "new_text": "nfa.get()",
          "old_line_content": "        nfa->length = verify_u32(nfaSize);",
          "new_line_content": "        allocState(nfa.get(), repeats_full_state, repeats_stream_state);",
          "content_same": false
        },
        {
          "line": 1896,
          "old_api": "empty",
          "new_api": "verify_u32",
          "old_text": "args.zombies.empty()",
          "new_text": "verify_u32(nfaSize)",
          "old_line_content": "        if (!args.zombies.empty()) {",
          "new_line_content": "        nfa->length = verify_u32(nfaSize);",
          "content_same": false
        },
        {
          "line": 1958,
          "old_api": "count",
          "new_api": "set",
          "old_text": "exceptionalStates.count()",
          "new_text": "exceptionalStates.set(from)",
          "old_line_content": "        DEBUG_PRINTF(\"%zu exceptional states\\n\", exceptionalStates.count());",
          "new_line_content": "                exceptionalStates.set(from);",
          "content_same": false
        },
        {
          "line": 2044,
          "old_api": "vertices_range",
          "new_api": "insert",
          "old_text": "vertices_range(h)",
          "new_text": "top_starts.insert(m.second)",
          "old_line_content": "    for (auto v : vertices_range(h)) {",
          "new_line_content": "        top_starts.insert(m.second);",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": "contains",
          "new_api": "DEBUG_PRINTF",
          "old_text": "contains(seen, i)",
          "new_text": "DEBUG_PRINTF(\"checking vertex %u (state %u)\\n\", h[v].index,\n                     i)",
          "old_line_content": "        if (i >= num_states || contains(seen, i)) {",
          "new_line_content": "        DEBUG_PRINTF(\"checking vertex %u (state %u)\\n\", h[v].index,",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": "insert",
          "new_api": "DEBUG_PRINTF",
          "old_text": "seen.insert(i)",
          "new_text": "DEBUG_PRINTF(\"vertex %u/%u has invalid state\\n\", i, num_states)",
          "old_line_content": "        seen.insert(i);",
          "new_line_content": "            DEBUG_PRINTF(\"vertex %u/%u has invalid state\\n\", i, num_states);",
          "content_same": false
        },
        {
          "line": 2065,
          "old_api": "none",
          "new_api": "insert",
          "old_text": "h[v].char_reach.none()",
          "new_text": "seen.insert(i)",
          "old_line_content": "        if (h[v].char_reach.none()) {",
          "new_line_content": "        seen.insert(i);",
          "content_same": false
        },
        {
          "line": 2096,
          "old_api": "DEBUG_PRINTF",
          "new_api": "max",
          "old_text": "DEBUG_PRINTF(\"max %u\\n\", rv)",
          "new_text": "max(m.second, rv)",
          "old_line_content": "    DEBUG_PRINTF(\"max %u\\n\", rv);",
          "new_line_content": "            rv = max(m.second, rv);",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": "isSane",
          "new_api": "DEBUG_PRINTF",
          "old_text": "isSane(h, tops, states, num_states)",
          "new_text": "DEBUG_PRINTF(\"hint=%u\\n\", hint)",
          "old_line_content": "    assert(isSane(h, tops, states, num_states));",
          "new_line_content": "    DEBUG_PRINTF(\"hint=%u\\n\", hint);",
          "content_same": false
        },
        {
          "line": 2146,
          "old_api": "make_pair",
          "new_api": "DISPATCH_BY_LIMEX_TYPE",
          "old_text": "make_pair(score, ntype)",
          "new_text": "DISPATCH_BY_LIMEX_TYPE(ntype, scoreNfa, arg)",
          "old_line_content": "                scores.push_back(make_pair(score, ntype));",
          "new_line_content": "            int score = DISPATCH_BY_LIMEX_TYPE(ntype, scoreNfa, arg);",
          "content_same": false
        },
        {
          "line": 2159,
          "old_api": "end",
          "new_api": "greater<EngineScore>()",
          "old_text": "scores.end()",
          "new_text": "greater<EngineScore>()",
          "old_line_content": "    for (auto i = scores.begin(); !nfa && i != scores.end(); ++i) {",
          "new_line_content": "    sort(scores.begin(), scores.end(), greater<EngineScore>());",
          "content_same": false
        },
        {
          "line": 2204,
          "old_api": "DEBUG_PRINTF",
          "new_api": "fillAccelInfo",
          "old_text": "DEBUG_PRINTF(\"found %u accel states\\n\", num_accel)",
          "new_text": "fillAccelInfo(bi)",
          "old_line_content": "    DEBUG_PRINTF(\"found %u accel states\\n\", num_accel);",
          "new_line_content": "    fillAccelInfo(bi);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2048,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "contains(state_ids, v)",
          "old_line_content": "            return false;",
          "new_line_content": "        if (!contains(state_ids, v)) {",
          "content_same": false
        },
        {
          "line": 2049,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"no entry for vertex %u in state map\\n\",\n                         h[v].index)",
          "old_line_content": "        }",
          "new_line_content": "            DEBUG_PRINTF(\"no entry for vertex %u in state map\\n\",",
          "content_same": false
        },
        {
          "line": 2053,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "state_ids.at(v)",
          "old_line_content": "        }",
          "new_line_content": "        const u32 i = state_ids.at(v);",
          "content_same": false
        },
        {
          "line": 2061,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "contains(seen, i)",
          "old_line_content": "        }",
          "new_line_content": "        if (i >= num_states || contains(seen, i)) {",
          "content_same": false
        },
        {
          "line": 2068,
          "old_api": null,
          "new_api": "none",
          "old_text": null,
          "new_text": "h[v].char_reach.none()",
          "old_line_content": "        }",
          "new_line_content": "        if (h[v].char_reach.none()) {",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"vertex %u has empty reachability\\n\", h[v].index)",
          "old_line_content": "",
          "new_line_content": "            DEBUG_PRINTF(\"vertex %u has empty reachability\\n\", h[v].index);",
          "content_same": false
        },
        {
          "line": 2075,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "contains(top_starts, v)",
          "old_line_content": "            return false;",
          "new_line_content": "        if (v != h.start && v != h.startDs && !contains(top_starts, v)",
          "content_same": false
        },
        {
          "line": 2076,
          "old_api": null,
          "new_api": "proper_in_degree",
          "old_text": null,
          "new_text": "proper_in_degree(v, h)",
          "old_line_content": "        }",
          "new_line_content": "            && !proper_in_degree(v, h)) {",
          "content_same": false
        },
        {
          "line": 2077,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"vertex %u has no pred\\n\", h[v].index)",
          "old_line_content": "    }",
          "new_line_content": "            DEBUG_PRINTF(\"vertex %u has no pred\\n\", h[v].index);",
          "content_same": false
        },
        {
          "line": 2082,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "seen.size()",
          "old_line_content": "",
          "new_line_content": "    if (seen.size() != num_states) {",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"state %u\\n\", m.second)",
          "old_line_content": "        }",
          "new_line_content": "        DEBUG_PRINTF(\"state %u\\n\", m.second);",
          "content_same": false
        },
        {
          "line": 2099,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"max %u\\n\", rv)",
          "old_line_content": "",
          "new_line_content": "    DEBUG_PRINTF(\"max %u\\n\", rv);",
          "content_same": false
        },
        {
          "line": 2114,
          "old_api": null,
          "new_api": "max_state",
          "old_text": null,
          "new_text": "max_state(states)",
          "old_line_content": "    if (!cc.grey.allowLimExNFA) {",
          "new_line_content": "    const u32 num_states = max_state(states) + 1;",
          "content_same": false
        },
        {
          "line": 2118,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"limex not allowed\\n\")",
          "old_line_content": "",
          "new_line_content": "        DEBUG_PRINTF(\"limex not allowed\\n\");",
          "content_same": false
        },
        {
          "line": 2123,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(hint == INVALID_NFA || hint <= LAST_LIMEX_NFA)",
          "old_line_content": "    // Sanity check the input data.",
          "new_line_content": "    assert(hint == INVALID_NFA || hint <= LAST_LIMEX_NFA);",
          "content_same": false
        },
        {
          "line": 2127,
          "old_api": null,
          "new_api": "isSane",
          "old_text": null,
          "new_text": "isSane(h, tops, states, num_states)",
          "old_line_content": "    build_info arg(h, states, repeats, reportSquashMap, squashMap, tops,",
          "new_line_content": "    assert(isSane(h, tops, states, num_states));",
          "content_same": false
        },
        {
          "line": 2134,
          "old_api": null,
          "new_api": "fillAccelInfo",
          "old_text": null,
          "new_text": "fillAccelInfo(arg)",
          "old_line_content": "    vector<EngineScore> scores;",
          "new_line_content": "    fillAccelInfo(arg);",
          "content_same": false
        },
        {
          "line": 2141,
          "old_api": null,
          "new_api": "make_pair",
          "old_text": null,
          "new_text": "make_pair(0, (NFAEngineType)hint)",
          "old_line_content": "            NFAEngineType ntype = (NFAEngineType)i;",
          "new_line_content": "        scores.push_back(make_pair(0, (NFAEngineType)hint));",
          "content_same": false
        },
        {
          "line": 2148,
          "old_api": null,
          "new_api": "nfa_type_name",
          "old_text": null,
          "new_text": "nfa_type_name(ntype)",
          "old_line_content": "        }",
          "new_line_content": "                DEBUG_PRINTF(\"%s scores %d\\n\", nfa_type_name(ntype), score);",
          "content_same": false
        },
        {
          "line": 2149,
          "old_api": null,
          "new_api": "make_pair",
          "old_text": null,
          "new_text": "make_pair(score, ntype)",
          "old_line_content": "    }",
          "new_line_content": "                scores.push_back(make_pair(score, ntype));",
          "content_same": false
        },
        {
          "line": 2154,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "scores.empty()",
          "old_line_content": "    }",
          "new_line_content": "    if (scores.empty()) {",
          "content_same": false
        },
        {
          "line": 2155,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"No NFA returned a valid score for this case.\\n\")",
          "old_line_content": "",
          "new_line_content": "        DEBUG_PRINTF(\"No NFA returned a valid score for this case.\\n\");",
          "content_same": false
        },
        {
          "line": 2162,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "scores.end()",
          "old_line_content": "    }",
          "new_line_content": "    for (auto i = scores.begin(); !nfa && i != scores.end(); ++i) {",
          "content_same": false
        },
        {
          "line": 2163,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(i->first >= 0)",
          "old_line_content": "",
          "new_line_content": "        assert(i->first >= 0);",
          "content_same": false
        },
        {
          "line": 2164,
          "old_api": null,
          "new_api": "DISPATCH_BY_LIMEX_TYPE",
          "old_text": null,
          "new_text": "DISPATCH_BY_LIMEX_TYPE(i->second, generateNfa, arg)",
          "old_line_content": "    if (!nfa) {",
          "new_line_content": "        nfa = DISPATCH_BY_LIMEX_TYPE(i->second, generateNfa, arg);",
          "content_same": false
        },
        {
          "line": 2168,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"NFA build failed.\\n\")",
          "old_line_content": "",
          "new_line_content": "        DEBUG_PRINTF(\"NFA build failed.\\n\");",
          "content_same": false
        },
        {
          "line": 2172,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"successful build with NFA engine: %s\\n\",\n                 nfa_type_name((NFAEngineType)nfa->type))",
          "old_line_content": "}",
          "new_line_content": "    DEBUG_PRINTF(\"successful build with NFA engine: %s\\n\",",
          "content_same": false
        },
        {
          "line": 2173,
          "old_api": null,
          "new_api": "nfa_type_name",
          "old_text": null,
          "new_text": "nfa_type_name((NFAEngineType)nfa->type)",
          "old_line_content": "",
          "new_line_content": "                 nfa_type_name((NFAEngineType)nfa->type));",
          "content_same": false
        },
        {
          "line": 2185,
          "old_api": null,
          "new_api": "max_state",
          "old_text": null,
          "new_text": "max_state(states)",
          "old_line_content": "    if (!cc.grey.allowLimExNFA) {",
          "new_line_content": "    const u32 num_states = max_state(states) + 1;",
          "content_same": false
        },
        {
          "line": 2189,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"limex not allowed\\n\")",
          "old_line_content": "",
          "new_line_content": "        DEBUG_PRINTF(\"limex not allowed\\n\");",
          "content_same": false
        },
        {
          "line": 2194,
          "old_api": null,
          "new_api": "isSane",
          "old_text": null,
          "new_text": "isSane(h, tops, states, num_states)",
          "old_line_content": "    const bool state_compression = false;",
          "new_line_content": "    assert(isSane(h, tops, states, num_states));",
          "content_same": false
        },
        {
          "line": 2206,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "bi.accel.accelerable.size()",
          "old_line_content": "}",
          "new_line_content": "    u32 num_accel = verify_u32(bi.accel.accelerable.size());",
          "content_same": false
        },
        {
          "line": 2207,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"found %u accel states\\n\", num_accel)",
          "old_line_content": "",
          "new_line_content": "    DEBUG_PRINTF(\"found %u accel states\\n\", num_accel);",
          "content_same": false
        },
        {
          "line": 2208,
          "old_api": null,
          "new_api": "min",
          "old_text": null,
          "new_text": "min(num_accel, (u32)NFA_MAX_ACCEL_STATES)",
          "old_line_content": "} // namespace ue2",
          "new_line_content": "    return min(num_accel, (u32)NFA_MAX_ACCEL_STATES);",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "accel->precalc.end()",
          "old_line_content": "            const precalcAccel &pa = p_it->second;",
          "new_line_content": "        if (p_it != accel->precalc.end()) {",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(offset <= MAX_ACCEL_DEPTH)",
          "old_line_content": "",
          "new_line_content": "            assert(offset <= MAX_ACCEL_DEPTH);",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "accel->accelerable.insert(v)",
          "old_line_content": "    }",
          "new_line_content": "        accel->accelerable.insert(v);",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": null,
          "new_api": "findAccelFriends",
          "old_text": null,
          "new_text": "findAccelFriends(g, v, br_cyclic, offset, &accel->friends[v])",
          "old_line_content": "",
          "new_line_content": "            findAccelFriends(g, v, br_cyclic, offset, &accel->friends[v]);",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": null,
          "new_api": "filterAccelStates",
          "old_text": null,
          "new_text": "filterAccelStates(bi.h, bi.tops, &bi.accel.accel_map)",
          "old_line_content": "                  bi.num_states, &bi.accel, bi.cc);",
          "new_line_content": "    filterAccelStates(bi.h, bi.tops, &bi.accel.accel_map);",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "bi.accel.accel_map.size()",
          "old_line_content": "}",
          "new_line_content": "    assert(bi.accel.accel_map.size() <= NFA_MAX_ACCEL_STATES);",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": null,
          "new_api": "doAccelCommon",
          "old_text": null,
          "new_text": "doAccelCommon(bi.h, bi.accel.accel_map, bi.state_ids, bi.br_cyclic,\n                  bi.num_states, &bi.accel, bi.cc)",
          "old_line_content": "",
          "new_line_content": "    doAccelCommon(bi.h, bi.accel.accel_map, bi.state_ids, bi.br_cyclic,",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": null,
          "new_api": "alignof",
          "old_text": null,
          "new_text": "alignof(AccelAux)",
          "old_line_content": "static",
          "new_line_content": "typedef vector<AccelAux, AlignedAllocator<AccelAux, alignof(AccelAux)> >",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "accelMask.resize(args.num_states)",
          "old_line_content": "    if (!args.do_accel) {",
          "new_line_content": "    accelMask.resize(args.num_states);",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "accelFriendsMask.resize(args.num_states)",
          "old_line_content": "        return;",
          "new_line_content": "    accelFriendsMask.resize(args.num_states);",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "accelStates.empty()",
          "old_line_content": "    }",
          "new_line_content": "    if (accelStates.empty()) {",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"no accelerable states\\n\")",
          "old_line_content": "",
          "new_line_content": "        DEBUG_PRINTF(\"no accelerable states\\n\");",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "accelStates.size()",
          "old_line_content": "",
          "new_line_content": "    assert(accelStates.size() < 32);",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "accelStates.size()",
          "old_line_content": "    // Set up a unioned AccelBuild for every possible combination of the set",
          "new_line_content": "    const u32 accelCount = 1U << accelStates.size();",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(accelCount <= 256)",
          "old_line_content": "    // bits in accelStates.",
          "new_line_content": "    assert(accelCount <= 256);",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "accelStates.size()",
          "old_line_content": "            }",
          "new_line_content": "        for (u32 j = 0, j_end = accelStates.size(); j < j_end; j++) {",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "accelTable.resize(accelCount)",
          "old_line_content": "    // of each unique accel scheme into the bytecode, using the accelTable as",
          "new_line_content": "    accelTable.resize(accelCount);",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "AccelAux",
          "old_text": null,
          "new_text": "AccelAux()",
          "old_line_content": "",
          "new_line_content": "    auxvec.push_back(AccelAux());",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(&auxvec[0], 0, sizeof(AccelAux))",
          "old_line_content": "    AccelAux aux;",
          "new_line_content": "    memset(&auxvec[0], 0, sizeof(AccelAux));",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "accelStates.size()",
          "old_line_content": "            }",
          "new_line_content": "        for (u32 j = 0; j < accelStates.size(); j++) {",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "states.set(accelStates[j].state)",
          "old_line_content": "",
          "new_line_content": "                states.set(accelStates[j].state);",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "contains(accel.precalc, states)",
          "old_line_content": "                ainfo.ma_len1 = precalc.ma_info.len1;",
          "new_line_content": "        if (contains(accel.precalc, states)) {",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "accel.precalc.at(states)",
          "old_line_content": "                ainfo.ma_len2 = precalc.ma_info.len2;",
          "new_line_content": "            const precalcAccel &precalc = accel.precalc.at(states);",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": null,
          "new_api": "buildAccelAux",
          "old_text": null,
          "new_text": "buildAccelAux(ainfo, &aux)",
          "old_line_content": "        // we've already built before.",
          "new_line_content": "        buildAccelAux(ainfo, &aux);",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "auxvec.end()",
          "old_line_content": "        } else {",
          "new_line_content": "        if (it == auxvec.end()) {",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "auxvec.push_back(aux)",
          "old_line_content": "        }",
          "new_line_content": "            auxvec.push_back(aux);",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "auxvec.begin()",
          "old_line_content": "",
          "new_line_content": "            accelTable[i] = verify_u8(it - auxvec.begin());",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "auxvec.size()",
          "old_line_content": "    // XXX: ACCEL_NONE?",
          "new_line_content": "    DEBUG_PRINTF(\"%zu unique accel schemes (of max %u)\\n\", auxvec.size(),",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "accelFriendsMask.set(as.state)",
          "old_line_content": "            continue;",
          "new_line_content": "        accelFriendsMask.set(as.state);",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "contains(accel.friends, v)",
          "old_line_content": "        // Add the friends of this state to the friends mask.",
          "new_line_content": "        if (!contains(accel.friends, v)) {",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "args.state_ids.at(friend_v)",
          "old_line_content": "        }",
          "new_line_content": "            u32 state_id = args.state_ids.at(friend_v);",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"--> %u\\n\", state_id)",
          "old_line_content": "    }",
          "new_line_content": "            DEBUG_PRINTF(\"--> %u\\n\", state_id);",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "accelFriendsMask.set(state_id)",
          "old_line_content": "}",
          "new_line_content": "            accelFriendsMask.set(state_id);",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "args.state_ids.at(v)",
          "old_line_content": "            continue;",
          "new_line_content": "        u32 state_id = args.state_ids.at(v);",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": null,
          "new_api": "is_match_vertex",
          "old_text": null,
          "new_text": "is_match_vertex(v, h)",
          "old_line_content": "",
          "new_line_content": "        if (state_id == NO_STATE || !is_match_vertex(v, h)) {",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "args.reportSquashMap.find(v)",
          "old_line_content": "            // see if we've already seen it, otherwise add a new one.",
          "new_line_content": "        auto sit = args.reportSquashMap.find(v);",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "squash.end()",
          "old_line_content": "            } else {",
          "new_line_content": "            auto it = find(squash.begin(), squash.end(), sit->second);",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "squash.size()",
          "old_line_content": "        }",
          "new_line_content": "                squashMaskOffset = verify_u32(squash.size());",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "squash.push_back(sit->second)",
          "old_line_content": "",
          "new_line_content": "                squash.push_back(sit->second);",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": null,
          "new_api": "edge",
          "old_text": null,
          "new_text": "edge(v, h.accept, h)",
          "old_line_content": "        } else {",
          "new_line_content": "        if (edge(v, h.accept, h).second) {",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": null,
          "new_api": "edge",
          "old_text": null,
          "new_text": "edge(v, h.acceptEod, h)",
          "old_line_content": "        }",
          "new_line_content": "            assert(edge(v, h.acceptEod, h).second);",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "acceptEodMask.set(state_id)",
          "old_line_content": "",
          "new_line_content": "            acceptEodMask.set(state_id);",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": null,
          "new_api": "NFAAccept",
          "old_text": null,
          "new_text": "NFAAccept()",
          "old_line_content": "            a.externalId = report;",
          "new_line_content": "            accepts_out->push_back(NFAAccept());",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "accepts_out->back()",
          "old_line_content": "            a.squash = squashMaskOffset;",
          "new_line_content": "            NFAAccept &a = accepts_out->back();",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"Accept: state=%u, externalId=%u\\n\", state_id, report)",
          "old_line_content": "}",
          "new_line_content": "            DEBUG_PRINTF(\"Accept: state=%u, externalId=%u\\n\", state_id, report);",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "args.tops.empty()",
          "old_line_content": "",
          "new_line_content": "    if (args.tops.empty()) {",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": null,
          "new_api": "rbegin",
          "old_text": null,
          "new_text": "args.tops.rbegin()",
          "old_line_content": "",
          "new_line_content": "    u32 numMasks = args.tops.rbegin()->first + 1; // max mask index",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(numMasks <= NFA_MAX_TOP_MASKS)",
          "old_line_content": "",
          "new_line_content": "    assert(numMasks <= NFA_MAX_TOP_MASKS);",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": null,
          "new_api": "NFAStateSet",
          "old_text": null,
          "new_text": "NFAStateSet(args.num_states)",
          "old_line_content": "        u32 mask_idx = m.first;",
          "new_line_content": "    topMasks.assign(numMasks, NFAStateSet(args.num_states)); // all zeroes",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(state_id != NO_STATE)",
          "old_line_content": "    }",
          "new_line_content": "        assert(state_id != NO_STATE);",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "topMasks[mask_idx].set(state_id)",
          "old_line_content": "",
          "new_line_content": "        topMasks[mask_idx].set(state_id);",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": null,
          "new_api": "ROUNDUP_N",
          "old_text": null,
          "new_text": "ROUNDUP_N(num_states, 8)",
          "old_line_content": "static",
          "new_line_content": "    return ROUNDUP_N(num_states, 8)/8;",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": null,
          "new_api": "vertices_range",
          "old_text": null,
          "new_text": "vertices_range(h)",
          "old_line_content": "            continue;",
          "new_line_content": "    for (auto v : vertices_range(h)) {",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "state_ids.at(v)",
          "old_line_content": "        }",
          "new_line_content": "        u32 i = state_ids.at(v);",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": null,
          "new_api": "test",
          "old_text": null,
          "new_text": "maskedStates.test(i)",
          "old_line_content": "        const CharReach &cr = h[v].char_reach;",
          "new_line_content": "        if (i == NO_STATE || maskedStates.test(i)) {",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": null,
          "new_api": "find_next",
          "old_text": null,
          "new_text": "cr.find_next(j)",
          "old_line_content": "    }",
          "new_line_content": "        for (size_t j = cr.find_first(); j != cr.npos; j = cr.find_next(j)) {",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "allreach.end()",
          "old_line_content": "}",
          "new_line_content": "    u32 maxreach = *max_element(allreach.begin(), allreach.end());",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"max reach is %u\\n\", maxreach)",
          "old_line_content": "",
          "new_line_content": "    DEBUG_PRINTF(\"max reach is %u\\n\", maxreach);",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "args.squashMap.empty()",
          "old_line_content": "    }",
          "new_line_content": "    if (args.squashMap.empty()) {",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"squash map is empty\\n\")",
          "old_line_content": "",
          "new_line_content": "        DEBUG_PRINTF(\"squash map is empty\\n\");",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "args.state_ids.at(h.startDs)",
          "old_line_content": "        return false;",
          "new_line_content": "    u32 sds_state = args.state_ids.at(h.startDs);",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"no states in initds\\n\")",
          "old_line_content": "",
          "new_line_content": "        DEBUG_PRINTF(\"no states in initds\\n\");",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "initDs.set(sds_state)",
          "old_line_content": "",
          "new_line_content": "    initDs.set(sds_state);",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": null,
          "new_api": "intersects",
          "old_text": null,
          "new_text": "squashed.intersects(initDs)",
          "old_line_content": "            return true;",
          "new_line_content": "        if (squashed.intersects(initDs)) {",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"state %u squashes initds states\\n\",\n                         args.state_ids.at(m.first))",
          "old_line_content": "        }",
          "new_line_content": "            DEBUG_PRINTF(\"state %u squashes initds states\\n\",",
          "content_same": false
        },
        {
          "line": 950,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "args.state_ids.at(m.first)",
          "old_line_content": "    }",
          "new_line_content": "                         args.state_ids.at(m.first));",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": null,
          "new_api": "intersects",
          "old_text": null,
          "new_text": "squashed.intersects(initDs)",
          "old_line_content": "            return true;",
          "new_line_content": "        if (squashed.intersects(initDs)) {",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"state %u squashes initds states\\n\",\n                         args.state_ids.at(m.first))",
          "old_line_content": "        }",
          "new_line_content": "            DEBUG_PRINTF(\"state %u squashes initds states\\n\",",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "args.state_ids.at(m.first)",
          "old_line_content": "    }",
          "new_line_content": "                         args.state_ids.at(m.first));",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "state_ids.at(h.startDs)",
          "old_line_content": "",
          "new_line_content": "    if (state_ids.at(h.startDs) != NO_STATE) {",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "state_ids.at(h.start)",
          "old_line_content": "",
          "new_line_content": "    if (is_triggered(h) && state_ids.at(h.start) != NO_STATE) {",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": null,
          "new_api": "hasSquashableInitDs",
          "old_text": null,
          "new_text": "hasSquashableInitDs(args)",
          "old_line_content": "        }",
          "new_line_content": "        if (sds_i != NO_STATE && !hasSquashableInitDs(args)) {",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "maskedStates.set(sds_i)",
          "old_line_content": "    }",
          "new_line_content": "            maskedStates.set(sds_i);",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"masking out initds state\\n\")",
          "old_line_content": "",
          "new_line_content": "            DEBUG_PRINTF(\"masking out initds state\\n\");",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": null,
          "new_api": "edges_range",
          "old_text": null,
          "new_text": "edges_range(h)",
          "old_line_content": "            if (from == NO_STATE) {",
          "new_line_content": "        for (const auto &e : edges_range(h)) {",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": null,
          "new_api": "source",
          "old_text": null,
          "new_text": "source(e, h)",
          "old_line_content": "                continue;",
          "new_line_content": "            u32 from = args.state_ids.at(source(e, h));",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": null,
          "new_api": "target",
          "old_text": null,
          "new_text": "target(e, h)",
          "old_line_content": "            }",
          "new_line_content": "            u32 to = args.state_ids.at(target(e, h));",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": null,
          "new_api": "target",
          "old_text": null,
          "new_text": "target(e, h)",
          "old_line_content": "",
          "new_line_content": "            if (to == NO_STATE && target(e, h) != h.acceptEod) {",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "nonleaf.set(from)",
          "old_line_content": "        for (u32 i = 0; i < args.num_states; i++) {",
          "new_line_content": "            nonleaf.set(from);",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": null,
          "new_api": "test",
          "old_text": null,
          "new_text": "nonleaf.test(i)",
          "old_line_content": "        }",
          "new_line_content": "            if (!nonleaf.test(i)) {",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "maskedStates.set(i)",
          "old_line_content": "",
          "new_line_content": "                maskedStates.set(i);",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "maskedStates.count()",
          "old_line_content": "",
          "new_line_content": "        DEBUG_PRINTF(\"masking out %zu leaf states\\n\", maskedStates.count());",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(flag)",
          "old_line_content": "}",
          "new_line_content": "    assert(flag);",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert((flag & (flag - 1)) == 0)",
          "old_line_content": "",
          "new_line_content": "    assert((flag & (flag - 1)) == 0);",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(flag)",
          "old_line_content": "}",
          "new_line_content": "    assert(flag);",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert((flag & (flag - 1)) == 0)",
          "old_line_content": "",
          "new_line_content": "    assert((flag & (flag - 1)) == 0);",
          "content_same": false
        },
        {
          "line": 1056,
          "old_api": null,
          "new_api": "uncompressedStateSize",
          "old_text": null,
          "new_text": "uncompressedStateSize(args.num_states)",
          "old_line_content": "    if (!args.stateCompression) {",
          "new_line_content": "    u32 sizeUncompressed = uncompressedStateSize(args.num_states);",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"compression disabled, uncompressed state size %u\\n\",\n                     sizeUncompressed)",
          "old_line_content": "        return;",
          "new_line_content": "        DEBUG_PRINTF(\"compression disabled, uncompressed state size %u\\n\",",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(sizeCompressed <= sizeof(limex->compressMask))",
          "old_line_content": "                 sizeUncompressed);",
          "new_line_content": "    assert(sizeCompressed <= sizeof(limex->compressMask));",
          "content_same": false
        },
        {
          "line": 1072,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"compressed=%u, uncompressed=%u\\n\", sizeCompressed,\n                 sizeUncompressed)",
          "old_line_content": "    // Must be at least a 10% saving.",
          "new_line_content": "    DEBUG_PRINTF(\"compressed=%u, uncompressed=%u\\n\", sizeCompressed,",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"using compression, state size %u\\n\",\n                     sizeCompressed)",
          "old_line_content": "        limex->stateSize = sizeCompressed;",
          "new_line_content": "        DEBUG_PRINTF(\"using compression, state size %u\\n\",",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": null,
          "new_api": "find_first",
          "old_text": null,
          "new_text": "maskedStates.find_first()",
          "old_line_content": "            }",
          "new_line_content": "            for (size_t i = maskedStates.find_first(); i != NFAStateSet::npos;",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": null,
          "new_api": "find_next",
          "old_text": null,
          "new_text": "maskedStates.find_next(i)",
          "old_line_content": "        }",
          "new_line_content": "                    i = maskedStates.find_next(i)) {",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": null,
          "new_api": "maskClearBit",
          "old_text": null,
          "new_text": "maskClearBit(limex->compressMask, i)",
          "old_line_content": "    } else {",
          "new_line_content": "                maskClearBit(limex->compressMask, i);",
          "content_same": false
        },
        {
          "line": 1091,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"not using compression, state size %u\\n\",\n                     sizeUncompressed)",
          "old_line_content": "    }",
          "new_line_content": "        DEBUG_PRINTF(\"not using compression, state size %u\\n\",",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "        // so we start with all-ones.",
          "new_line_content": "    explicit ExceptionProto(u32 num_states)",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "squash_states.set()",
          "old_line_content": "    bool operator<(const ExceptionProto &b) const {",
          "new_line_content": "        squash_states.set();",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": null,
          "new_api": "ORDER_CHECK",
          "old_text": null,
          "new_text": "ORDER_CHECK(squash)",
          "old_line_content": "",
          "new_line_content": "        ORDER_CHECK(squash);",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": null,
          "new_api": "ORDER_CHECK",
          "old_text": null,
          "new_text": "ORDER_CHECK(succ_states)",
          "old_line_content": "        return false;",
          "new_line_content": "        ORDER_CHECK(succ_states);",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": null,
          "new_api": "ORDER_CHECK",
          "old_text": null,
          "new_text": "ORDER_CHECK(squash_states)",
          "old_line_content": "    }",
          "new_line_content": "        ORDER_CHECK(squash_states);",
          "content_same": false
        },
        {
          "line": 1143,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "reports.empty()",
          "old_line_content": "",
          "new_line_content": "    if (reports.empty()) {",
          "content_same": false
        },
        {
          "line": 1152,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "exceptionReports.size()",
          "old_line_content": "    }",
          "new_line_content": "        assert(idx < exceptionReports.size());",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "exceptionReports.begin()",
          "old_line_content": "",
          "new_line_content": "        assert(equal(r.begin(), r.end(), exceptionReports.begin() + idx));",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "r.end()",
          "old_line_content": "}",
          "new_line_content": "    exceptionReports.insert(exceptionReports.end(), r.begin(), r.end());",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "exceptionReports.push_back(MO_INVALID_IDX)",
          "old_line_content": "",
          "new_line_content": "    exceptionReports.push_back(MO_INVALID_IDX); // terminator",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "args.repeats.size()",
          "old_line_content": "        pos_trigger[br.pos_trigger] = i;",
          "new_line_content": "    for (u32 i = 0; i < args.repeats.size(); i++) {",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "contains(tug_trigger, v)",
          "old_line_content": "    }",
          "new_line_content": "            assert(!contains(tug_trigger, v));",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": null,
          "new_api": "vertices_range",
          "old_text": null,
          "new_text": "vertices_range(h)",
          "old_line_content": "        if (i == NO_STATE) {",
          "new_line_content": "    for (auto v : vertices_range(h)) {",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "args.state_ids.at(v)",
          "old_line_content": "            continue;",
          "new_line_content": "        const u32 i = args.state_ids.at(v);",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": null,
          "new_api": "generates_callbacks",
          "old_text": null,
          "new_text": "generates_callbacks(h)",
          "old_line_content": "            const auto &reports = h[v].reports;",
          "new_line_content": "        if (edge(v, h.accept, h).second && generates_callbacks(h)) {",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"state %u is exceptional due to accept \"\n                         \"(%zu reports)\\n\", i, reports.size())",
          "old_line_content": "            e.reports_index =",
          "new_line_content": "            DEBUG_PRINTF(\"state %u is exceptional due to accept \"",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "args.reportSquashMap.end()",
          "old_line_content": "                e.squash_states = mi->second;",
          "new_line_content": "            if (mi != args.reportSquashMap.end()) {",
          "content_same": false
        },
        {
          "line": 1213,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"report squashes states\\n\")",
          "old_line_content": "                e.squash = LIMEX_SQUASH_REPORT;",
          "new_line_content": "                DEBUG_PRINTF(\"report squashes states\\n\");",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "mi->second.size()",
          "old_line_content": "            }",
          "new_line_content": "                assert(e.squash_states.size() == mi->second.size());",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "contains(pos_trigger, v)",
          "old_line_content": "            e.trigger = LIMEX_TRIGGER_POS;",
          "new_line_content": "        if (contains(pos_trigger, v)) {",
          "content_same": false
        },
        {
          "line": 1227,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"state %u has pos trigger for repeat %u\\n\", i,\n                         repeat_index)",
          "old_line_content": "        }",
          "new_line_content": "            DEBUG_PRINTF(\"state %u has pos trigger for repeat %u\\n\", i,",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "contains(tug_trigger, v)",
          "old_line_content": "            e.trigger = LIMEX_TRIGGER_TUG;",
          "new_line_content": "        if (contains(tug_trigger, v)) {",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(e.trigger == LIMEX_TRIGGER_NONE)",
          "old_line_content": "",
          "new_line_content": "            assert(e.trigger == LIMEX_TRIGGER_NONE);",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "e.squash_states.reset(cyclic)",
          "old_line_content": "                         \"state %u\\n\", i, repeat_index, cyclic);",
          "new_line_content": "            e.squash_states.reset(cyclic);",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"state %u has tug trigger for repeat %u, can squash \"\n                         \"state %u\\n\", i, repeat_index, cyclic)",
          "old_line_content": "        }",
          "new_line_content": "            DEBUG_PRINTF(\"state %u has tug trigger for repeat %u, can squash \"",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(w_idx != NO_STATE)",
          "old_line_content": "                addMe = true;",
          "new_line_content": "                assert(w_idx != NO_STATE);",
          "content_same": false
        },
        {
          "line": 1253,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "e.succ_states.set(w_idx)",
          "old_line_content": "            }",
          "new_line_content": "                e.succ_states.set(w_idx);",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"exceptional transition %u->%u\\n\", i, w_idx)",
          "old_line_content": "        }",
          "new_line_content": "                DEBUG_PRINTF(\"exceptional transition %u->%u\\n\", i, w_idx);",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": null,
          "new_api": "adjacent_vertices_range",
          "old_text": null,
          "new_text": "adjacent_vertices_range(v, h)",
          "old_line_content": "                }",
          "new_line_content": "            for (auto w : adjacent_vertices_range(v, h)) {",
          "content_same": false
        },
        {
          "line": 1269,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "args.state_ids.at(w)",
          "old_line_content": "                }",
          "new_line_content": "                u32 j = args.state_ids.at(w);",
          "content_same": false
        },
        {
          "line": 1275,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "args.squashMap.end()",
          "old_line_content": "                                 \"mi->second.size() = %zu\\n\",",
          "new_line_content": "                if (mi != args.squashMap.end()) {",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "mi->second.size()",
          "old_line_content": "",
          "new_line_content": "                                 e.squash_states.size(), mi->second.size());",
          "content_same": false
        },
        {
          "line": 1280,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "mi->second.size()",
          "old_line_content": "                    // NOTE: this might be being combined with the report",
          "new_line_content": "                    assert(e.squash_states.size() == mi->second.size());",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"squashing succ %u (turns off %zu states)\\n\",\n                                 j, mi->second.size() - mi->second.count())",
          "old_line_content": "                }",
          "new_line_content": "                    DEBUG_PRINTF(\"squashing succ %u (turns off %zu states)\\n\",",
          "content_same": false
        },
        {
          "line": 1288,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "mi->second.count()",
          "old_line_content": "            }",
          "new_line_content": "                                 j, mi->second.size() - mi->second.count());",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "e.succ_states.size()",
          "old_line_content": "        }",
          "new_line_content": "            assert(e.succ_states.size() == num_states);",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "e.squash_states.size()",
          "old_line_content": "    }",
          "new_line_content": "            assert(e.squash_states.size() == num_states);",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "exceptionMap[e].push_back(i)",
          "old_line_content": "",
          "new_line_content": "            exceptionMap[e].push_back(i);",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "exceptionMap.size()",
          "old_line_content": "static",
          "new_line_content": "    DEBUG_PRINTF(\"%zu unique exceptions found.\\n\", exceptionMap.size());",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": null,
          "new_api": "is_reachable",
          "old_text": null,
          "new_text": "d.is_reachable()",
          "old_line_content": "    }",
          "new_line_content": "    assert(d.is_reachable());",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": null,
          "new_api": "is_infinite",
          "old_text": null,
          "new_text": "d.is_infinite()",
          "old_line_content": "",
          "new_line_content": "    if (d.is_infinite()) {",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(d_val < REPEAT_INF)",
          "old_line_content": "",
          "new_line_content": "    assert(d_val < REPEAT_INF);",
          "content_same": false
        },
        {
          "line": 1331,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "state_ids.at(from)",
          "old_line_content": "            return true;",
          "new_line_content": "        u32 f = state_ids.at(from);",
          "content_same": false
        },
        {
          "line": 1332,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "state_ids.at(to)",
          "old_line_content": "        }",
          "new_line_content": "        u32 t = state_ids.at(to);",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": null,
          "new_api": "isLimitedTransition",
          "old_text": null,
          "new_text": "isLimitedTransition(f, t, NFATraits<dtype>::maxShift)",
          "old_line_content": "",
          "new_line_content": "        if (!isLimitedTransition(f, t, NFATraits<dtype>::maxShift)) {",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "contains(tugs, from)",
          "old_line_content": "        return false;",
          "new_line_content": "        if (contains(tugs, from)) {",
          "content_same": false
        },
        {
          "line": 1347,
          "old_api": null,
          "new_api": "getMutableImplNfa",
          "old_text": null,
          "new_text": "getMutableImplNfa(nfa)",
          "old_line_content": "        // 1. state bitvector (always present)",
          "new_line_content": "        implNFA_t *limex = (implNFA_t *)getMutableImplNfa(nfa);",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"bitvector=%zu/%u, repeat full=%u, stream=%u\\n\",\n                     sizeof(limex->init), stateSize, repeatscratchStateSize,\n                     repeatStreamState)",
          "old_line_content": "",
          "new_line_content": "        DEBUG_PRINTF(\"bitvector=%zu/%u, repeat full=%u, stream=%u\\n\",",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": null,
          "new_api": "alignof",
          "old_text": null,
          "new_text": "alignof(RepeatControl)",
          "old_line_content": "        size_t streamStateSize = stateSize + repeatStreamState;",
          "new_line_content": "                = ROUNDUP_N(scratchStateSize, alignof(RepeatControl));",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": null,
          "new_api": "verify_u32",
          "old_text": null,
          "new_text": "verify_u32(scratchStateSize)",
          "old_line_content": "",
          "new_line_content": "        nfa->scratchStateSize = verify_u32(scratchStateSize);",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": null,
          "new_api": "verify_u32",
          "old_text": null,
          "new_text": "verify_u32(streamStateSize)",
          "old_line_content": "    static",
          "new_line_content": "        nfa->streamStateSize = verify_u32(streamStateSize);",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": null,
          "new_api": "alignof",
          "old_text": null,
          "new_text": "alignof(u64a)",
          "old_line_content": "        } else {",
          "new_line_content": "            len = ROUNDUP_N(len, alignof(u64a));",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": null,
          "new_api": "verify_u32",
          "old_text": null,
          "new_text": "verify_u32(len)",
          "old_line_content": "            *tableOffset = 0;",
          "new_line_content": "            *tableOffset = verify_u32(len);",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": null,
          "new_api": "alignof",
          "old_text": null,
          "new_text": "alignof(tableRow_t)",
          "old_line_content": "",
          "new_line_content": "        len = ROUNDUP_N(len, alignof(tableRow_t));",
          "content_same": false
        },
        {
          "line": 1388,
          "old_api": null,
          "new_api": "verify_u32",
          "old_text": null,
          "new_text": "verify_u32(len)",
          "old_line_content": "        // to simplify layout.",
          "new_line_content": "        *tugMaskOffset = verify_u32(len);",
          "content_same": false
        },
        {
          "line": 1392,
          "old_api": null,
          "new_api": "ROUNDUP_CL",
          "old_text": null,
          "new_text": "ROUNDUP_CL(len)",
          "old_line_content": "    }",
          "new_line_content": "        len = ROUNDUP_CL(len);",
          "content_same": false
        },
        {
          "line": 1410,
          "old_api": null,
          "new_api": "repeatAllocSize",
          "old_text": null,
          "new_text": "repeatAllocSize(br, &tableOffset, &tugMaskOffset)",
          "old_line_content": "",
          "new_line_content": "            size_t len = repeatAllocSize(br, &tableOffset, &tugMaskOffset);",
          "content_same": false
        },
        {
          "line": 1411,
          "old_api": null,
          "new_api": "aligned_zmalloc_unique<NFARepeatInfo>(len)",
          "old_text": null,
          "new_text": "aligned_zmalloc_unique<NFARepeatInfo>(len)",
          "old_line_content": "            // Collect state space info.",
          "new_line_content": "            auto info = aligned_zmalloc_unique<NFARepeatInfo>(len);",
          "content_same": false
        },
        {
          "line": 1412,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "info.get()",
          "old_line_content": "            RepeatStateInfo rsi(br.type, br.repeatMin, br.repeatMax, br.minPeriod);",
          "new_line_content": "            char *info_ptr = (char *)info.get();",
          "content_same": false
        },
        {
          "line": 1419,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "args.state_ids.at(br.cyclic)",
          "old_line_content": "            info->stateOffset = *streamState + rsi.packedCtrlSize;",
          "new_line_content": "            info->cyclicState = args.state_ids.at(br.cyclic);",
          "content_same": false
        },
        {
          "line": 1430,
          "old_api": null,
          "new_api": "depth_to_u32",
          "old_text": null,
          "new_text": "depth_to_u32(br.repeatMin)",
          "old_line_content": "            repeat->packedCtrlSize = rsi.packedCtrlSize;",
          "new_line_content": "            repeat->repeatMin = depth_to_u32(br.repeatMin);",
          "content_same": false
        },
        {
          "line": 1431,
          "old_api": null,
          "new_api": "depth_to_u32",
          "old_text": null,
          "new_text": "depth_to_u32(br.repeatMax)",
          "old_line_content": "            repeat->stateSize = rsi.stateSize;",
          "new_line_content": "            repeat->repeatMax = depth_to_u32(br.repeatMax);",
          "content_same": false
        },
        {
          "line": 1435,
          "old_api": null,
          "new_api": "copy_bytes",
          "old_text": null,
          "new_text": "copy_bytes(repeat->packedFieldSizes, rsi.packedFieldSizes)",
          "old_line_content": "            repeat->encodingSize = rsi.encodingSize;",
          "new_line_content": "            copy_bytes(repeat->packedFieldSizes, rsi.packedFieldSizes);",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "rsi.table.empty()",
          "old_line_content": "",
          "new_line_content": "                assert(!rsi.table.empty());",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": null,
          "new_api": "copy_bytes",
          "old_text": null,
          "new_text": "copy_bytes(info_ptr + tableOffset, rsi.table)",
          "old_line_content": "            // Fill the tug mask.",
          "new_line_content": "                copy_bytes(info_ptr + tableOffset, rsi.table);",
          "content_same": false
        },
        {
          "line": 1456,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "args.state_ids.at(v)",
          "old_line_content": "            }",
          "new_line_content": "                u32 state_id = args.state_ids.at(v);",
          "content_same": false
        },
        {
          "line": 1457,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(state_id != NO_STATE)",
          "old_line_content": "",
          "new_line_content": "                assert(state_id != NO_STATE);",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(streamStateLen)",
          "old_line_content": "",
          "new_line_content": "            assert(streamStateLen);",
          "content_same": false
        },
        {
          "line": 1465,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(info)",
          "old_line_content": "",
          "new_line_content": "            out.emplace_back(move(info), len);",
          "content_same": false
        },
        {
          "line": 1474,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "args.state_ids.at(h.start)",
          "old_line_content": "        if (s_i != NO_STATE) {",
          "new_line_content": "        u32 s_i = args.state_ids.at(h.start);",
          "content_same": false
        },
        {
          "line": 1478,
          "old_api": null,
          "new_api": "maskSetBit",
          "old_text": null,
          "new_text": "maskSetBit(limex->init, s_i)",
          "old_line_content": "            }",
          "new_line_content": "            maskSetBit(limex->init, s_i);",
          "content_same": false
        },
        {
          "line": 1479,
          "old_api": null,
          "new_api": "is_triggered",
          "old_text": null,
          "new_text": "is_triggered(h)",
          "old_line_content": "        }",
          "new_line_content": "            if (is_triggered(h)) {",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": null,
          "new_api": "maskSetBit",
          "old_text": null,
          "new_text": "maskSetBit(limex->initDS, s_i)",
          "old_line_content": "",
          "new_line_content": "                maskSetBit(limex->initDS, s_i);",
          "content_same": false
        },
        {
          "line": 1485,
          "old_api": null,
          "new_api": "maskSetBit",
          "old_text": null,
          "new_text": "maskSetBit(limex->init, sds_i)",
          "old_line_content": "",
          "new_line_content": "            maskSetBit(limex->init, sds_i);",
          "content_same": false
        },
        {
          "line": 1486,
          "old_api": null,
          "new_api": "maskSetBit",
          "old_text": null,
          "new_text": "maskSetBit(limex->initDS, sds_i)",
          "old_line_content": "        // Zombie mask.",
          "new_line_content": "            maskSetBit(limex->initDS, sds_i);",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "args.state_ids.at(v)",
          "old_line_content": "        }",
          "new_line_content": "            u32 state_id = args.state_ids.at(v);",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(state_id != NO_STATE)",
          "old_line_content": "",
          "new_line_content": "            assert(state_id != NO_STATE);",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": null,
          "new_api": "maskSetBit",
          "old_text": null,
          "new_text": "maskSetBit(limex->zombieMask, state_id)",
          "old_line_content": "        // Repeat cyclic mask.",
          "new_line_content": "            maskSetBit(limex->zombieMask, state_id);",
          "content_same": false
        },
        {
          "line": 1498,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "args.state_ids.at(br.cyclic)",
          "old_line_content": "        }",
          "new_line_content": "            u32 cyclic = args.state_ids.at(br.cyclic);",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(cyclic != NO_STATE)",
          "old_line_content": "    }",
          "new_line_content": "            assert(cyclic != NO_STATE);",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": null,
          "new_api": "maskSetBit",
          "old_text": null,
          "new_text": "maskSetBit(limex->repeatCyclicMask, cyclic)",
          "old_line_content": "",
          "new_line_content": "            maskSetBit(limex->repeatCyclicMask, cyclic);",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": null,
          "new_api": "edges_range",
          "old_text": null,
          "new_text": "edges_range(h)",
          "old_line_content": "            if (from == NO_STATE || to == NO_STATE) {",
          "new_line_content": "        for (const auto &e : edges_range(h)) {",
          "content_same": false
        },
        {
          "line": 1509,
          "old_api": null,
          "new_api": "source",
          "old_text": null,
          "new_text": "source(e, h)",
          "old_line_content": "                continue;",
          "new_line_content": "            u32 from = args.state_ids.at(source(e, h));",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": null,
          "new_api": "target",
          "old_text": null,
          "new_text": "target(e, h)",
          "old_line_content": "            }",
          "new_line_content": "            u32 to = args.state_ids.at(target(e, h));",
          "content_same": false
        },
        {
          "line": 1518,
          "old_api": null,
          "new_api": "isExceptionalTransition",
          "old_text": null,
          "new_text": "isExceptionalTransition(h, e, args.state_ids, args.tugs)",
          "old_line_content": "        }",
          "new_line_content": "            if (!isExceptionalTransition(h, e, args.state_ids, args.tugs)) {",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": null,
          "new_api": "maskSetBit",
          "old_text": null,
          "new_text": "maskSetBit(limex->shift[to - from], from)",
          "old_line_content": "    }",
          "new_line_content": "                maskSetBit(limex->shift[to - from], from);",
          "content_same": false
        },
        {
          "line": 1529,
          "old_api": null,
          "new_api": "edges_range",
          "old_text": null,
          "new_text": "edges_range(h)",
          "old_line_content": "            if (from == NO_STATE || to == NO_STATE) {",
          "new_line_content": "        for (const auto &e : edges_range(h)) {",
          "content_same": false
        },
        {
          "line": 1530,
          "old_api": null,
          "new_api": "source",
          "old_text": null,
          "new_text": "source(e, h)",
          "old_line_content": "                continue;",
          "new_line_content": "            u32 from = args.state_ids.at(source(e, h));",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": null,
          "new_api": "target",
          "old_text": null,
          "new_text": "target(e, h)",
          "old_line_content": "            }",
          "new_line_content": "            u32 to = args.state_ids.at(target(e, h));",
          "content_same": false
        },
        {
          "line": 1536,
          "old_api": null,
          "new_api": "isExceptionalTransition",
          "old_text": null,
          "new_text": "isExceptionalTransition(h, e, args.state_ids, args.tugs)",
          "old_line_content": "        }",
          "new_line_content": "            if (isExceptionalTransition(h, e, args.state_ids, args.tugs)) {",
          "content_same": false
        },
        {
          "line": 1537,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "exceptional.insert(e)",
          "old_line_content": "    }",
          "new_line_content": "                exceptional.insert(e);",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"exceptionsOffset=%u\\n\", exceptionsOffset)",
          "old_line_content": "        // values",
          "new_line_content": "        DEBUG_PRINTF(\"exceptionsOffset=%u\\n\", exceptionsOffset);",
          "content_same": false
        },
        {
          "line": 1553,
          "old_api": null,
          "new_api": "ISALIGNED",
          "old_text": null,
          "new_text": "ISALIGNED(etable)",
          "old_line_content": "        for (const auto &m : exceptionMap) {",
          "new_line_content": "        assert(ISALIGNED(etable));",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"exception %u, triggered by %zu states.\\n\", ecount,\n                         states.size())",
          "old_line_content": "            // Write the exception entry.",
          "new_line_content": "            DEBUG_PRINTF(\"exception %u, triggered by %zu states.\\n\", ecount,",
          "content_same": false
        },
        {
          "line": 1560,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "states.size()",
          "old_line_content": "            exception_t &e = etable[ecount];",
          "new_line_content": "                         states.size());",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": null,
          "new_api": "verify_u8",
          "old_text": null,
          "new_text": "verify_u8(proto.squash)",
          "old_line_content": "                                    ? MO_INVALID_IDX",
          "new_line_content": "            e.hasSquash = verify_u8(proto.squash);",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": null,
          "new_api": "verify_u8",
          "old_text": null,
          "new_text": "verify_u8(proto.trigger)",
          "old_line_content": "                                    : repeatOffsets[proto.repeat_index];",
          "new_line_content": "            e.trigger = verify_u8(proto.trigger);",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": null,
          "new_api": "maskSetBit",
          "old_text": null,
          "new_text": "maskSetBit(limex->exceptionMask, state_id)",
          "old_line_content": "            }",
          "new_line_content": "                maskSetBit(limex->exceptionMask, state_id);",
          "content_same": false
        },
        {
          "line": 1595,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "reachMap.end()",
          "old_line_content": "        tableRow_t *reachMask = (tableRow_t *)((char *)limex + reachOffset);",
          "new_line_content": "        copy(reachMap.begin(), reachMap.end(), &limex->reachMap[0]);",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": null,
          "new_api": "ISALIGNED",
          "old_text": null,
          "new_text": "ISALIGNED(reachMask)",
          "old_line_content": "        }",
          "new_line_content": "        assert(ISALIGNED(reachMask));",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": null,
          "new_api": "maskSetBits",
          "old_text": null,
          "new_text": "maskSetBits(reachMask[i], reach[i])",
          "old_line_content": "    }",
          "new_line_content": "            maskSetBits(reachMask[i], reach[i]);",
          "content_same": false
        },
        {
          "line": 1603,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "reach.size()",
          "old_line_content": "    static",
          "new_line_content": "        limex->reachSize = verify_u32(reach.size());",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"topsOffset=%u\\n\", topsOffset)",
          "old_line_content": "        tableRow_t *topMasks = (tableRow_t *)((char *)limex + topsOffset);",
          "new_line_content": "        DEBUG_PRINTF(\"topsOffset=%u\\n\", topsOffset);",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "tops.size()",
          "old_line_content": "",
          "new_line_content": "        for (size_t i = 0, end = tops.size(); i < end; i++) {",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "tops.size()",
          "old_line_content": "    static",
          "new_line_content": "        limex->topCount = verify_u32(tops.size());",
          "content_same": false
        },
        {
          "line": 1629,
          "old_api": null,
          "new_api": "find_next",
          "old_text": null,
          "new_text": "accelMask.find_next(i)",
          "old_line_content": "",
          "new_line_content": "             i = accelMask.find_next(i), ++num) {",
          "content_same": false
        },
        {
          "line": 1630,
          "old_api": null,
          "new_api": "verify_u32",
          "old_text": null,
          "new_text": "verify_u32(i)",
          "old_line_content": "            // PSHUFB permute and compare masks",
          "new_line_content": "            u32 state_id = verify_u32(i);",
          "content_same": false
        },
        {
          "line": 1631,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"accel num=%u, state=%u\\n\", num, state_id)",
          "old_line_content": "            size_t mask_idx = sizeof(u_128) * (state_id / 128U);",
          "new_line_content": "            DEBUG_PRINTF(\"accel num=%u, state=%u\\n\", num, state_id);",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": null,
          "new_api": "maskSetByte",
          "old_text": null,
          "new_text": "maskSetByte(*perm, num, ((state_id % 128U) / 8U))",
          "old_line_content": "    }",
          "new_line_content": "            maskSetByte(*perm, num, ((state_id % 128U) / 8U));",
          "content_same": false
        },
        {
          "line": 1639,
          "old_api": null,
          "new_api": "maskSetByte",
          "old_text": null,
          "new_text": "maskSetByte(*comp, num, ~(1U << (state_id % 8U)))",
          "old_line_content": "",
          "new_line_content": "            maskSetByte(*comp, num, ~(1U << (state_id % 8U)));",
          "content_same": false
        },
        {
          "line": 1649,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"accelTableOffset=%u, accelAuxOffset=%u\\n\",\n                      accelTableOffset, accelAuxOffset)",
          "old_line_content": "        // Write accel lookup table.",
          "new_line_content": "        DEBUG_PRINTF(\"accelTableOffset=%u, accelAuxOffset=%u\\n\",",
          "content_same": false
        },
        {
          "line": 1654,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "accelTable.end()",
          "old_line_content": "        // Write accel aux structures.",
          "new_line_content": "        copy(accelTable.begin(), accelTable.end(),",
          "content_same": false
        },
        {
          "line": 1660,
          "old_api": null,
          "new_api": "ISALIGNED",
          "old_text": null,
          "new_text": "ISALIGNED(auxTable)",
          "old_line_content": "        // Write LimEx structure members.",
          "new_line_content": "        assert(ISALIGNED(auxTable));",
          "content_same": false
        },
        {
          "line": 1664,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "accelTable.size()",
          "old_line_content": "",
          "new_line_content": "        limex->accelCount = verify_u32(accelTable.size());",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": null,
          "new_api": "maskSetBits",
          "old_text": null,
          "new_text": "maskSetBits(limex->accel, accelMask)",
          "old_line_content": "        // We can use PSHUFB-based shuffles for models >= 128 states. These",
          "new_line_content": "        maskSetBits(limex->accel, accelMask);",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": null,
          "new_api": "maskSetBits",
          "old_text": null,
          "new_text": "maskSetBits(limex->accel_and_friends, accelFriendsMask)",
          "old_line_content": "        // require some additional masks in the bytecode.",
          "new_line_content": "        maskSetBits(limex->accel_and_friends, accelFriendsMask);",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": null,
          "new_api": "maskFill",
          "old_text": null,
          "new_text": "maskFill(limex->accelPermute, (char)0x80)",
          "old_line_content": "        }",
          "new_line_content": "        maskFill(limex->accelPermute, (char)0x80);",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": null,
          "new_api": "writeAccelSsse3Masks",
          "old_text": null,
          "new_text": "writeAccelSsse3Masks(accelMask, limex)",
          "old_line_content": "",
          "new_line_content": "            writeAccelSsse3Masks(accelMask, limex);",
          "content_same": false
        },
        {
          "line": 1689,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"acceptsOffset=%u, acceptsEodOffset=%u, squashOffset=%u\\n\",\n                     acceptsOffset, acceptsEodOffset, squashOffset)",
          "old_line_content": "        // LimEx masks (in structure)",
          "new_line_content": "        DEBUG_PRINTF(\"acceptsOffset=%u, acceptsEodOffset=%u, squashOffset=%u\\n\",",
          "content_same": false
        },
        {
          "line": 1693,
          "old_api": null,
          "new_api": "maskSetBits",
          "old_text": null,
          "new_text": "maskSetBits(limex->accept, acceptMask)",
          "old_line_content": "        // Write accept table.",
          "new_line_content": "        maskSetBits(limex->accept, acceptMask);",
          "content_same": false
        },
        {
          "line": 1694,
          "old_api": null,
          "new_api": "maskSetBits",
          "old_text": null,
          "new_text": "maskSetBits(limex->acceptAtEOD, acceptEodMask)",
          "old_line_content": "        limex->acceptOffset = acceptsOffset;",
          "new_line_content": "        maskSetBits(limex->acceptAtEOD, acceptEodMask);",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": null,
          "new_api": "ISALIGNED",
          "old_text": null,
          "new_text": "ISALIGNED(acceptsTable)",
          "old_line_content": "        // Write eod accept table.",
          "new_line_content": "        assert(ISALIGNED(acceptsTable));",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "accepts.end()",
          "old_line_content": "        limex->acceptEodOffset = acceptsEodOffset;",
          "new_line_content": "        copy(accepts.begin(), accepts.end(), acceptsTable);",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": null,
          "new_api": "ISALIGNED",
          "old_text": null,
          "new_text": "ISALIGNED(acceptsEodTable)",
          "old_line_content": "        // Write squash mask table.",
          "new_line_content": "        assert(ISALIGNED(acceptsEodTable));",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "squash.size()",
          "old_line_content": "        tableRow_t *mask = (tableRow_t *)((char *)limex + squashOffset);",
          "new_line_content": "        limex->squashCount = verify_u32(squash.size());",
          "content_same": false
        },
        {
          "line": 1717,
          "old_api": null,
          "new_api": "ISALIGNED",
          "old_text": null,
          "new_text": "ISALIGNED(mask)",
          "old_line_content": "        }",
          "new_line_content": "        assert(ISALIGNED(mask));",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "squash.size()",
          "old_line_content": "    }",
          "new_line_content": "        for (size_t i = 0, end = squash.size(); i < end; i++) {",
          "content_same": false
        },
        {
          "line": 1719,
          "old_api": null,
          "new_api": "maskSetBits",
          "old_text": null,
          "new_text": "maskSetBits(mask[i], squash[i])",
          "old_line_content": "",
          "new_line_content": "            maskSetBits(mask[i], squash[i]);",
          "content_same": false
        },
        {
          "line": 1728,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "repeats.size()",
          "old_line_content": "                      repeatOffsetsOffset, repeatOffset);",
          "new_line_content": "        const u32 num_repeats = verify_u32(repeats.size());",
          "content_same": false
        },
        {
          "line": 1733,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "repeatOffsets.resize(num_repeats)",
          "old_line_content": "        for (u32 i = 0; i < num_repeats; i++) {",
          "new_line_content": "        repeatOffsets.resize(num_repeats);",
          "content_same": false
        },
        {
          "line": 1738,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(repeats[i].first)",
          "old_line_content": "            offset += repeats[i].second;",
          "new_line_content": "            assert(repeats[i].first);",
          "content_same": false
        },
        {
          "line": 1739,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "repeats[i].first.get()",
          "old_line_content": "        }",
          "new_line_content": "            memcpy((char *)limex + offset, repeats[i].first.get(),",
          "content_same": false
        },
        {
          "line": 1745,
          "old_api": null,
          "new_api": "alignof",
          "old_text": null,
          "new_text": "alignof(u32)",
          "old_line_content": "        limex->repeatOffset = repeatOffsetsOffset;",
          "new_line_content": "        assert(ISALIGNED_N((char *)limex + repeatOffsetsOffset, alignof(u32)));",
          "content_same": false
        },
        {
          "line": 1746,
          "old_api": null,
          "new_api": "copy_bytes",
          "old_text": null,
          "new_text": "copy_bytes((char *)limex + repeatOffsetsOffset, repeatOffsets)",
          "old_line_content": "        limex->repeatCount = num_repeats;",
          "new_line_content": "        copy_bytes((char *)limex + repeatOffsetsOffset, repeatOffsets);",
          "content_same": false
        },
        {
          "line": 1759,
          "old_api": null,
          "new_api": "ISALIGNED_N",
          "old_text": null,
          "new_text": "ISALIGNED_N((char *)limex + exceptionReportsOffset,\n                           alignof(ReportID))",
          "old_line_content": "    }",
          "new_line_content": "        assert(ISALIGNED_N((char *)limex + exceptionReportsOffset,",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": null,
          "new_api": "alignof",
          "old_text": null,
          "new_text": "alignof(ReportID)",
          "old_line_content": "",
          "new_line_content": "                           alignof(ReportID)));",
          "content_same": false
        },
        {
          "line": 1761,
          "old_api": null,
          "new_api": "copy_bytes",
          "old_text": null,
          "new_text": "copy_bytes((char *)limex + exceptionReportsOffset, reports)",
          "old_line_content": "    static",
          "new_line_content": "        copy_bytes((char *)limex + exceptionReportsOffset, reports);",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": null,
          "new_api": "buildRepeats",
          "old_text": null,
          "new_text": "buildRepeats(args, repeats, &repeats_full_state, &repeats_stream_state)",
          "old_line_content": "            repeatSize += repeats[i].second;",
          "new_line_content": "        buildRepeats(args, repeats, &repeats_full_state, &repeats_stream_state);",
          "content_same": false
        },
        {
          "line": 1776,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "repeats.size()",
          "old_line_content": "",
          "new_line_content": "        for (size_t i = 0; i < repeats.size(); i++) {",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": null,
          "new_api": "findExceptionalTransitions",
          "old_text": null,
          "new_text": "findExceptionalTransitions(args, exceptional)",
          "old_line_content": "        vector<ReportID> exceptionReports;",
          "new_line_content": "        findExceptionalTransitions(args, exceptional);",
          "content_same": false
        },
        {
          "line": 1787,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "exceptionMap.size()",
          "old_line_content": "        }",
          "new_line_content": "        if (exceptionMap.size() > ~0U) {",
          "content_same": false
        },
        {
          "line": 1788,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"too many exceptions!\\n\")",
          "old_line_content": "",
          "new_line_content": "            DEBUG_PRINTF(\"too many exceptions!\\n\");",
          "content_same": false
        },
        {
          "line": 1795,
          "old_api": null,
          "new_api": "buildReachMapping",
          "old_text": null,
          "new_text": "buildReachMapping(args, reach, reachMap)",
          "old_line_content": "        vector<NFAStateSet> tops;",
          "new_line_content": "        buildReachMapping(args, reach, reachMap);",
          "content_same": false
        },
        {
          "line": 1799,
          "old_api": null,
          "new_api": "buildTopMasks",
          "old_text": null,
          "new_text": "buildTopMasks(args, tops)",
          "old_line_content": "        NFAStateSet acceptMask, acceptEodMask;",
          "new_line_content": "        buildTopMasks(args, tops);",
          "content_same": false
        },
        {
          "line": 1805,
          "old_api": null,
          "new_api": "buildAccepts",
          "old_text": null,
          "new_text": "buildAccepts(args, acceptMask, acceptEodMask, accepts, acceptsEod,\n                     squash)",
          "old_line_content": "        // Build all our accel info.",
          "new_line_content": "        buildAccepts(args, acceptMask, acceptEodMask, accepts, acceptsEod,",
          "content_same": false
        },
        {
          "line": 1812,
          "old_api": null,
          "new_api": "buildAccel",
          "old_text": null,
          "new_text": "buildAccel(args, accelMask, accelFriendsMask, accelAux, accelTable)",
          "old_line_content": "        // our structures. First, the NFA and LimEx structures. All other",
          "new_line_content": "        buildAccel(args, accelMask, accelFriendsMask, accelAux, accelTable);",
          "content_same": false
        },
        {
          "line": 1827,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "accelTable.size()",
          "old_line_content": "        const u32 accelAuxOffset = offset;",
          "new_line_content": "        offset += sizeof(u8) * accelTable.size();",
          "content_same": false
        },
        {
          "line": 1829,
          "old_api": null,
          "new_api": "alignof",
          "old_text": null,
          "new_text": "alignof(AccelAux)",
          "old_line_content": "",
          "new_line_content": "        offset = ROUNDUP_N(offset, alignof(AccelAux));",
          "content_same": false
        },
        {
          "line": 1831,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "accelAux.size()",
          "old_line_content": "        const u32 acceptsOffset = offset;",
          "new_line_content": "        offset += sizeof(AccelAux) * accelAux.size();",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": null,
          "new_api": "alignof",
          "old_text": null,
          "new_text": "alignof(NFAAccept)",
          "old_line_content": "        const u32 acceptsEodOffset = offset;",
          "new_line_content": "        offset = ROUNDUP_N(offset, alignof(NFAAccept));",
          "content_same": false
        },
        {
          "line": 1835,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "accepts.size()",
          "old_line_content": "",
          "new_line_content": "        offset += sizeof(NFAAccept) * accepts.size();",
          "content_same": false
        },
        {
          "line": 1837,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "acceptsEod.size()",
          "old_line_content": "        const u32 squashOffset = offset;",
          "new_line_content": "        offset += sizeof(NFAAccept) * acceptsEod.size();",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": null,
          "new_api": "ROUNDUP_CL",
          "old_text": null,
          "new_text": "ROUNDUP_CL(offset)",
          "old_line_content": "",
          "new_line_content": "        offset = ROUNDUP_CL(offset);",
          "content_same": false
        },
        {
          "line": 1841,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "squash.size()",
          "old_line_content": "        const u32 exceptionsOffset = offset;",
          "new_line_content": "        offset += sizeof(tableRow_t) * squash.size();",
          "content_same": false
        },
        {
          "line": 1843,
          "old_api": null,
          "new_api": "ROUNDUP_CL",
          "old_text": null,
          "new_text": "ROUNDUP_CL(offset)",
          "old_line_content": "",
          "new_line_content": "        offset = ROUNDUP_CL(offset);",
          "content_same": false
        },
        {
          "line": 1851,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "args.repeats.size()",
          "old_line_content": "        const u32 repeatsOffset = offset;",
          "new_line_content": "        offset += sizeof(u32) * args.repeats.size();",
          "content_same": false
        },
        {
          "line": 1853,
          "old_api": null,
          "new_api": "ROUNDUP_CL",
          "old_text": null,
          "new_text": "ROUNDUP_CL(offset)",
          "old_line_content": "",
          "new_line_content": "        offset = ROUNDUP_CL(offset);",
          "content_same": false
        },
        {
          "line": 1860,
          "old_api": null,
          "new_api": "DEBUG_PRINTF",
          "old_text": null,
          "new_text": "DEBUG_PRINTF(\"nfa size %zu\\n\", nfaSize)",
          "old_line_content": "",
          "new_line_content": "        DEBUG_PRINTF(\"nfa size %zu\\n\", nfaSize);",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": null,
          "new_api": "ISALIGNED",
          "old_text": null,
          "new_text": "ISALIGNED(limex)",
          "old_line_content": "",
          "new_line_content": "        assert(ISALIGNED(limex));",
          "content_same": false
        },
        {
          "line": 1867,
          "old_api": null,
          "new_api": "writeReachMapping",
          "old_text": null,
          "new_text": "writeReachMapping(reach, reachMap, limex, reachOffset)",
          "old_line_content": "",
          "new_line_content": "        writeReachMapping(reach, reachMap, limex, reachOffset);",
          "content_same": false
        },
        {
          "line": 1869,
          "old_api": null,
          "new_api": "writeTopMasks",
          "old_text": null,
          "new_text": "writeTopMasks(tops, limex, topsOffset)",
          "old_line_content": "                   limex, accelTableOffset, accelAuxOffset);",
          "new_line_content": "        writeTopMasks(tops, limex, topsOffset);",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": null,
          "new_api": "findStateSize",
          "old_text": null,
          "new_text": "findStateSize(args, limex)",
          "old_line_content": "",
          "new_line_content": "        findStateSize(args, limex);",
          "content_same": false
        },
        {
          "line": 1882,
          "old_api": null,
          "new_api": "writeExceptionReports",
          "old_text": null,
          "new_text": "writeExceptionReports(exceptionReports, limex, exceptionReportsOffset)",
          "old_line_content": "        vector<u32> repeatOffsets;",
          "new_line_content": "        writeExceptionReports(exceptionReports, limex, exceptionReportsOffset);",
          "content_same": false
        },
        {
          "line": 1889,
          "old_api": null,
          "new_api": "writeExceptions",
          "old_text": null,
          "new_text": "writeExceptions(exceptionMap, repeatOffsets, limex, exceptionsOffset)",
          "old_line_content": "",
          "new_line_content": "        writeExceptions(exceptionMap, repeatOffsets, limex, exceptionsOffset);",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": null,
          "new_api": "writeLimexMasks",
          "old_text": null,
          "new_text": "writeLimexMasks(args, limex)",
          "old_line_content": "",
          "new_line_content": "        writeLimexMasks(args, limex);",
          "content_same": false
        },
        {
          "line": 1902,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "acceptsEod.empty()",
          "old_line_content": "",
          "new_line_content": "        if (!acceptsEod.empty()) {",
          "content_same": false
        },
        {
          "line": 1903,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "nfa.get()",
          "old_line_content": "        return nfa;",
          "new_line_content": "            setNfaFlag(nfa.get(), NFA_ACCEPTS_EOD);",
          "content_same": false
        },
        {
          "line": 1915,
          "old_api": null,
          "new_api": "findContainerSize",
          "old_text": null,
          "new_text": "findContainerSize(num_states)",
          "old_line_content": "        }",
          "new_line_content": "        size_t sz = findContainerSize(num_states);",
          "content_same": false
        },
        {
          "line": 1950,
          "old_api": null,
          "new_api": "edges_range",
          "old_text": null,
          "new_text": "edges_range(h)",
          "old_line_content": "            if (from == NO_STATE || to == NO_STATE) {",
          "new_line_content": "        for (const auto &e : edges_range(h)) {",
          "content_same": false
        },
        {
          "line": 1951,
          "old_api": null,
          "new_api": "source",
          "old_text": null,
          "new_text": "source(e, h)",
          "old_line_content": "                continue;",
          "new_line_content": "            u32 from = args.state_ids.at(source(e, h));",
          "content_same": false
        },
        {
          "line": 1952,
          "old_api": null,
          "new_api": "target",
          "old_text": null,
          "new_text": "target(e, h)",
          "old_line_content": "            }",
          "new_line_content": "            u32 to = args.state_ids.at(target(e, h));",
          "content_same": false
        },
        {
          "line": 1957,
          "old_api": null,
          "new_api": "isExceptionalTransition",
          "old_text": null,
          "new_text": "isExceptionalTransition(h, e, args.state_ids, args.tugs)",
          "old_line_content": "        }",
          "new_line_content": "            if (isExceptionalTransition(h, e, args.state_ids, args.tugs)) {",
          "content_same": false
        },
        {
          "line": 1961,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "exceptionalStates.count()",
          "old_line_content": "        /* ensure that we always report a valid score if have the right number",
          "new_line_content": "        DEBUG_PRINTF(\"%zu exceptional states\\n\", exceptionalStates.count());",
          "content_same": false
        },
        {
          "line": 1962,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "exceptionalStates.count()",
          "old_line_content": "         * of states */",
          "new_line_content": "        score -= EXCEPTION_COST * exceptionalStates.count();",
          "content_same": false
        },
        {
          "line": 1977,
          "old_api": null,
          "new_api": "Factory<dtype>::generateNfa(args)",
          "old_text": null,
          "new_text": "Factory<dtype>::generateNfa(args)",
          "old_line_content": "",
          "new_line_content": "        return Factory<dtype>::generateNfa(args);",
          "content_same": false
        },
        {
          "line": 1984,
          "old_api": null,
          "new_api": "Factory<dtype>::score(args)",
          "old_text": null,
          "new_text": "Factory<dtype>::score(args)",
          "old_line_content": "",
          "new_line_content": "        return Factory<dtype>::score(args);",
          "content_same": false
        },
        {
          "line": 2029,
          "old_api": null,
          "new_api": "MAKE_LIMEX_TRAITS",
          "old_text": null,
          "new_text": "MAKE_LIMEX_TRAITS(512, 5)",
          "old_line_content": "",
          "new_line_content": "MAKE_LIMEX_TRAITS(512, 5)",
          "content_same": false
        },
        {
          "line": 2030,
          "old_api": null,
          "new_api": "MAKE_LIMEX_TRAITS",
          "old_text": null,
          "new_text": "MAKE_LIMEX_TRAITS(512, 6)",
          "old_line_content": "} // namespace",
          "new_line_content": "MAKE_LIMEX_TRAITS(512, 6)",
          "content_same": false
        },
        {
          "line": 2031,
          "old_api": null,
          "new_api": "MAKE_LIMEX_TRAITS",
          "old_text": null,
          "new_text": "MAKE_LIMEX_TRAITS(512, 7)",
          "old_line_content": "",
          "new_line_content": "MAKE_LIMEX_TRAITS(512, 7)",
          "content_same": false
        },
        {
          "line": 2047,
          "old_api": null,
          "new_api": "vertices_range",
          "old_text": null,
          "new_text": "vertices_range(h)",
          "old_line_content": "                         h[v].index);",
          "new_line_content": "    for (auto v : vertices_range(h)) {",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2050,
          "old_api": "at",
          "new_api": null,
          "old_text": "state_ids.at(v)",
          "new_text": null,
          "old_line_content": "        const u32 i = state_ids.at(v);",
          "new_line_content": "                         h[v].index);",
          "content_same": false
        },
        {
          "line": 2055,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"checking vertex %u (state %u)\\n\", h[v].index,\n                     i)",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"checking vertex %u (state %u)\\n\", h[v].index,",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 2059,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"vertex %u/%u has invalid state\\n\", i, num_states)",
          "new_text": null,
          "old_line_content": "            DEBUG_PRINTF(\"vertex %u/%u has invalid state\\n\", i, num_states);",
          "new_line_content": "                     i);",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"vertex %u has empty reachability\\n\", h[v].index)",
          "new_text": null,
          "old_line_content": "            DEBUG_PRINTF(\"vertex %u has empty reachability\\n\", h[v].index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2072,
          "old_api": "contains",
          "new_api": null,
          "old_text": "contains(top_starts, v)",
          "new_text": null,
          "old_line_content": "        if (v != h.start && v != h.startDs && !contains(top_starts, v)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2073,
          "old_api": "proper_in_degree",
          "new_api": null,
          "old_text": "proper_in_degree(v, h)",
          "new_text": null,
          "old_line_content": "            && !proper_in_degree(v, h)) {",
          "new_line_content": "        // Every state that isn't a start state (or top, in triggered NFAs)",
          "content_same": false
        },
        {
          "line": 2074,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"vertex %u has no pred\\n\", h[v].index)",
          "new_text": null,
          "old_line_content": "            DEBUG_PRINTF(\"vertex %u has no pred\\n\", h[v].index);",
          "new_line_content": "        // must have at least one predecessor that is not itself.",
          "content_same": false
        },
        {
          "line": 2079,
          "old_api": "size",
          "new_api": null,
          "old_text": "seen.size()",
          "new_text": null,
          "old_line_content": "    if (seen.size() != num_states) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2091,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"state %u\\n\", m.second)",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"state %u\\n\", m.second);",
          "new_line_content": "u32 max_state(const ue2::unordered_map<NFAVertex, u32> &state_ids) {",
          "content_same": false
        },
        {
          "line": 2093,
          "old_api": "max",
          "new_api": null,
          "old_text": "max(m.second, rv)",
          "new_text": null,
          "old_line_content": "            rv = max(m.second, rv);",
          "new_line_content": "    for (const auto &m : state_ids) {",
          "content_same": false
        },
        {
          "line": 2111,
          "old_api": "max_state",
          "new_api": null,
          "old_text": "max_state(states)",
          "new_text": null,
          "old_line_content": "    const u32 num_states = max_state(states) + 1;",
          "new_line_content": "                         bool stateCompression,",
          "content_same": false
        },
        {
          "line": 2112,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"total states: %u\\n\", num_states)",
          "new_text": null,
          "old_line_content": "    DEBUG_PRINTF(\"total states: %u\\n\", num_states);",
          "new_line_content": "                         u32 hint,",
          "content_same": false
        },
        {
          "line": 2120,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(hint == INVALID_NFA || hint <= LAST_LIMEX_NFA)",
          "new_text": null,
          "old_line_content": "    assert(hint == INVALID_NFA || hint <= LAST_LIMEX_NFA);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2121,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"hint=%u\\n\", hint)",
          "new_text": null,
          "old_line_content": "    DEBUG_PRINTF(\"hint=%u\\n\", hint);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2131,
          "old_api": "fillAccelInfo",
          "new_api": null,
          "old_text": "fillAccelInfo(arg)",
          "new_text": null,
          "old_line_content": "    fillAccelInfo(arg);",
          "new_line_content": "                   zombies, do_accel, stateCompression, cc, num_states);",
          "content_same": false
        },
        {
          "line": 2138,
          "old_api": "make_pair",
          "new_api": null,
          "old_text": "make_pair(0, (NFAEngineType)hint)",
          "new_text": null,
          "old_line_content": "        scores.push_back(make_pair(0, (NFAEngineType)hint));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2143,
          "old_api": "DISPATCH_BY_LIMEX_TYPE",
          "new_api": null,
          "old_text": "DISPATCH_BY_LIMEX_TYPE(ntype, scoreNfa, arg)",
          "new_text": null,
          "old_line_content": "            int score = DISPATCH_BY_LIMEX_TYPE(ntype, scoreNfa, arg);",
          "new_line_content": "        for (size_t i = 0; i <= LAST_LIMEX_NFA; i++) {",
          "content_same": false
        },
        {
          "line": 2145,
          "old_api": "nfa_type_name",
          "new_api": null,
          "old_text": "nfa_type_name(ntype)",
          "new_text": null,
          "old_line_content": "                DEBUG_PRINTF(\"%s scores %d\\n\", nfa_type_name(ntype), score);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2151,
          "old_api": "empty",
          "new_api": null,
          "old_text": "scores.empty()",
          "new_text": null,
          "old_line_content": "    if (scores.empty()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2152,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"No NFA returned a valid score for this case.\\n\")",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"No NFA returned a valid score for this case.\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2156,
          "old_api": "greater<EngineScore>()",
          "new_api": null,
          "old_text": "greater<EngineScore>()",
          "new_text": null,
          "old_line_content": "    sort(scores.begin(), scores.end(), greater<EngineScore>());",
          "new_line_content": "        return nullptr;",
          "content_same": false
        },
        {
          "line": 2160,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(i->first >= 0)",
          "new_text": null,
          "old_line_content": "        assert(i->first >= 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2161,
          "old_api": "DISPATCH_BY_LIMEX_TYPE",
          "new_api": null,
          "old_text": "DISPATCH_BY_LIMEX_TYPE(i->second, generateNfa, arg)",
          "new_text": null,
          "old_line_content": "        nfa = DISPATCH_BY_LIMEX_TYPE(i->second, generateNfa, arg);",
          "new_line_content": "    aligned_unique_ptr<NFA> nfa;",
          "content_same": false
        },
        {
          "line": 2165,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"NFA build failed.\\n\")",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"NFA build failed.\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"successful build with NFA engine: %s\\n\",\n                 nfa_type_name((NFAEngineType)nfa->type))",
          "new_text": null,
          "old_line_content": "    DEBUG_PRINTF(\"successful build with NFA engine: %s\\n\",",
          "new_line_content": "        return nullptr;",
          "content_same": false
        },
        {
          "line": 2170,
          "old_api": "nfa_type_name",
          "new_api": null,
          "old_text": "nfa_type_name((NFAEngineType)nfa->type)",
          "new_text": null,
          "old_line_content": "                 nfa_type_name((NFAEngineType)nfa->type));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2182,
          "old_api": "max_state",
          "new_api": null,
          "old_text": "max_state(states)",
          "new_text": null,
          "old_line_content": "    const u32 num_states = max_state(states) + 1;",
          "new_line_content": "                     const map<u32, NFAVertex> &tops,",
          "content_same": false
        },
        {
          "line": 2183,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"total states: %u\\n\", num_states)",
          "new_text": null,
          "old_line_content": "    DEBUG_PRINTF(\"total states: %u\\n\", num_states);",
          "new_line_content": "                     const set<NFAVertex> &zombies,",
          "content_same": false
        },
        {
          "line": 2191,
          "old_api": "isSane",
          "new_api": null,
          "old_text": "isSane(h, tops, states, num_states)",
          "new_text": null,
          "old_line_content": "    assert(isSane(h, tops, states, num_states));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2201,
          "old_api": "fillAccelInfo",
          "new_api": null,
          "old_text": "fillAccelInfo(bi)",
          "new_text": null,
          "old_line_content": "    fillAccelInfo(bi);",
          "new_line_content": "                  do_accel, state_compression, cc, num_states);",
          "content_same": false
        },
        {
          "line": 2203,
          "old_api": "size",
          "new_api": null,
          "old_text": "bi.accel.accelerable.size()",
          "new_text": null,
          "old_line_content": "    u32 num_accel = verify_u32(bi.accel.accelerable.size());",
          "new_line_content": "    // Acceleration analysis.",
          "content_same": false
        },
        {
          "line": 2205,
          "old_api": "min",
          "new_api": null,
          "old_text": "min(num_accel, (u32)NFA_MAX_ACCEL_STATES)",
          "new_text": null,
          "old_line_content": "    return min(num_accel, (u32)NFA_MAX_ACCEL_STATES);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": "find",
          "new_api": null,
          "old_text": "accel->precalc.find(state_set)",
          "new_text": null,
          "old_line_content": "        auto p_it = accel->precalc.find(state_set);",
          "new_line_content": "        bool is_multi = false;",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": "max",
          "new_api": null,
          "old_text": "max(pa.double_offset, pa.single_offset)",
          "new_text": null,
          "old_line_content": "            offset = max(pa.double_offset, pa.single_offset);",
          "new_line_content": "            const precalcAccel &pa = p_it->second;",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": "insert",
          "new_api": null,
          "old_text": "accel->accelerable.insert(v)",
          "new_text": null,
          "old_line_content": "        accel->accelerable.insert(v);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": "findAccelFriends",
          "new_api": null,
          "old_text": "findAccelFriends(g, v, br_cyclic, offset, &accel->friends[v])",
          "new_text": null,
          "old_line_content": "        findAccelFriends(g, v, br_cyclic, offset, &accel->friends[v]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": "nfaFindAccelSchemes",
          "new_api": null,
          "old_text": "nfaFindAccelSchemes(bi.h, bi.br_cyclic, &bi.accel.accel_map)",
          "new_text": null,
          "old_line_content": "    nfaFindAccelSchemes(bi.h, bi.br_cyclic, &bi.accel.accel_map);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": "filterAccelStates",
          "new_api": null,
          "old_text": "filterAccelStates(bi.h, bi.tops, &bi.accel.accel_map)",
          "new_text": null,
          "old_line_content": "    filterAccelStates(bi.h, bi.tops, &bi.accel.accel_map);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 685,
          "old_api": "size",
          "new_api": null,
          "old_text": "bi.accel.accel_map.size()",
          "new_text": null,
          "old_line_content": "    assert(bi.accel.accel_map.size() <= NFA_MAX_ACCEL_STATES);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": "alignof",
          "new_api": null,
          "old_text": "alignof(AccelAux)",
          "new_text": null,
          "old_line_content": "typedef vector<AccelAux, AlignedAllocator<AccelAux, alignof(AccelAux)> >",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": "resize",
          "new_api": null,
          "old_text": "accelMask.resize(args.num_states)",
          "new_text": null,
          "old_line_content": "    accelMask.resize(args.num_states);",
          "new_line_content": "    const limex_accel_info &accel = args.accel;",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": "resize",
          "new_api": null,
          "old_text": "accelFriendsMask.resize(args.num_states)",
          "new_text": null,
          "old_line_content": "    accelFriendsMask.resize(args.num_states);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": "gatherAccelStates",
          "new_api": null,
          "old_text": "gatherAccelStates(args, accelStates)",
          "new_text": null,
          "old_line_content": "    gatherAccelStates(args, accelStates);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": "empty",
          "new_api": null,
          "old_text": "accelStates.empty()",
          "new_text": null,
          "old_line_content": "    if (accelStates.empty()) {",
          "new_line_content": "    vector<AccelBuild> accelStates;",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": "size",
          "new_api": null,
          "old_text": "accelStates.size()",
          "new_text": null,
          "old_line_content": "    assert(accelStates.size() < 32);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": "size",
          "new_api": null,
          "old_text": "accelStates.size()",
          "new_text": null,
          "old_line_content": "    const u32 accelCount = 1U << accelStates.size();",
          "new_line_content": "    // We have 2^n different accel entries, one for each possible",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(accelCount <= 256)",
          "new_text": null,
          "old_line_content": "    assert(accelCount <= 256);",
          "new_line_content": "    // combination of accelerable states.",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": "size",
          "new_api": null,
          "old_text": "accelStates.size()",
          "new_text": null,
          "old_line_content": "        for (u32 j = 0, j_end = accelStates.size(); j < j_end; j++) {",
          "new_line_content": "    // bits in accelStates.",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "combineAccel",
          "new_api": null,
          "old_text": "combineAccel(accelStates[j], accelOuts[i])",
          "new_text": null,
          "old_line_content": "                combineAccel(accelStates[j], accelOuts[i]);",
          "new_line_content": "    for (u32 i = 1; i < accelCount; i++) {",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "AccelAux",
          "new_api": null,
          "old_text": "AccelAux()",
          "new_text": null,
          "old_line_content": "    auxvec.push_back(AccelAux());",
          "new_line_content": "    // an index.",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(&auxvec[0], 0, sizeof(AccelAux))",
          "new_text": null,
          "old_line_content": "    memset(&auxvec[0], 0, sizeof(AccelAux));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(&aux, 0, sizeof(aux))",
          "new_text": null,
          "old_line_content": "        memset(&aux, 0, sizeof(aux));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "set",
          "new_api": null,
          "old_text": "states.set(accelStates[j].state)",
          "new_text": null,
          "old_line_content": "                states.set(accelStates[j].state);",
          "new_line_content": "        NFAStateSet states(args.num_states);",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "contains",
          "new_api": null,
          "old_text": "contains(accel.precalc, states)",
          "new_text": null,
          "old_line_content": "        if (contains(accel.precalc, states)) {",
          "new_line_content": "        ainfo.double_stop1 = accelOuts[i].stop1;",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": "at",
          "new_api": null,
          "old_text": "accel.precalc.at(states)",
          "new_text": null,
          "old_line_content": "            const precalcAccel &precalc = accel.precalc.at(states);",
          "new_line_content": "        ainfo.double_stop2 = accelOuts[i].stop2;",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "buildAccelAux",
          "new_api": null,
          "old_text": "buildAccelAux(ainfo, &aux)",
          "new_text": null,
          "old_line_content": "        buildAccelAux(ainfo, &aux);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": "AccelAuxCmp",
          "new_api": null,
          "old_text": "AccelAuxCmp(aux)",
          "new_text": null,
          "old_line_content": "        auto it = find_if(auxvec.begin(), auxvec.end(), AccelAuxCmp(aux));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "end",
          "new_api": null,
          "old_text": "auxvec.end()",
          "new_text": null,
          "old_line_content": "        if (it == auxvec.end()) {",
          "new_line_content": "        // FIXME: We may want a faster way to find AccelAux structures that",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": "size",
          "new_api": null,
          "old_text": "auxvec.size()",
          "new_text": null,
          "old_line_content": "            accelTable[i] = verify_u8(auxvec.size());",
          "new_line_content": "        // we've already built before.",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": "size",
          "new_api": null,
          "old_text": "auxvec.size()",
          "new_text": null,
          "old_line_content": "    DEBUG_PRINTF(\"%zu unique accel schemes (of max %u)\\n\", auxvec.size(),",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": "at",
          "new_api": null,
          "old_text": "args.state_ids.at(v)",
          "new_text": null,
          "old_line_content": "        assert(v && args.state_ids.at(v) == as.state);",
          "new_line_content": "    // XXX: ACCEL_NONE?",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "set",
          "new_api": null,
          "old_text": "accelMask.set(as.state)",
          "new_text": null,
          "old_line_content": "        accelMask.set(as.state);",
          "new_line_content": "        NFAVertex v = as.v;",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": "at",
          "new_api": null,
          "old_text": "accel.friends.at(v)",
          "new_text": null,
          "old_line_content": "        const flat_set<NFAVertex> &friends = accel.friends.at(v);",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": "size",
          "new_api": null,
          "old_text": "friends.size()",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"%u has %zu friends\\n\", as.state, friends.size());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": "set",
          "new_api": null,
          "old_text": "accelFriendsMask.set(state_id)",
          "new_text": null,
          "old_line_content": "            accelFriendsMask.set(state_id);",
          "new_line_content": "        for (auto friend_v : friends) {",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": "resize",
          "new_api": null,
          "old_text": "acceptMask.resize(args.num_states)",
          "new_text": null,
          "old_line_content": "    acceptMask.resize(args.num_states);",
          "new_line_content": "                  vector<NFAAccept> &acceptsEod, vector<NFAStateSet> &squash) {",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": "resize",
          "new_api": null,
          "old_text": "acceptEodMask.resize(args.num_states)",
          "new_text": null,
          "old_line_content": "    acceptEodMask.resize(args.num_states);",
          "new_line_content": "    const NGHolder &h = args.h;",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": "find",
          "new_api": null,
          "old_text": "args.reportSquashMap.find(v)",
          "new_text": null,
          "old_line_content": "        auto sit = args.reportSquashMap.find(v);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": "end",
          "new_api": null,
          "old_text": "args.reportSquashMap.end()",
          "new_text": null,
          "old_line_content": "        if (sit != args.reportSquashMap.end()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": "end",
          "new_api": null,
          "old_text": "squash.end()",
          "new_text": null,
          "old_line_content": "            if (it != squash.end()) {",
          "new_line_content": "            // This state has a squash mask. Paw through the existing vector to",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": "begin",
          "new_api": null,
          "old_text": "squash.begin()",
          "new_text": null,
          "old_line_content": "                squashMaskOffset = verify_u32(distance(squash.begin(), it));",
          "new_line_content": "            // see if we've already seen it, otherwise add a new one.",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "edge",
          "new_api": null,
          "old_text": "edge(v, h.accept, h)",
          "new_text": null,
          "old_line_content": "        if (edge(v, h.accept, h).second) {",
          "new_line_content": "        // Add an accept (or acceptEod) per report ID.",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": "set",
          "new_api": null,
          "old_text": "acceptMask.set(state_id)",
          "new_text": null,
          "old_line_content": "            acceptMask.set(state_id);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": "set",
          "new_api": null,
          "old_text": "acceptEodMask.set(state_id)",
          "new_text": null,
          "old_line_content": "            acceptEodMask.set(state_id);",
          "new_line_content": "            accepts_out = &accepts;",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": "NFAAccept",
          "new_api": null,
          "old_text": "NFAAccept()",
          "new_text": null,
          "old_line_content": "            accepts_out->push_back(NFAAccept());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "back",
          "new_api": null,
          "old_text": "accepts_out->back()",
          "new_text": null,
          "old_line_content": "            NFAAccept &a = accepts_out->back();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"Accept: state=%u, externalId=%u\\n\", state_id, report)",
          "new_text": null,
          "old_line_content": "            DEBUG_PRINTF(\"Accept: state=%u, externalId=%u\\n\", state_id, report);",
          "new_line_content": "            a.state = state_id;",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": "empty",
          "new_api": null,
          "old_text": "args.tops.empty()",
          "new_text": null,
          "old_line_content": "    if (args.tops.empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": "rbegin",
          "new_api": null,
          "old_text": "args.tops.rbegin()",
          "new_text": null,
          "old_line_content": "    u32 numMasks = args.tops.rbegin()->first + 1; // max mask index",
          "new_line_content": "        return; // No tops, probably an outfix NFA.",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"we have %u top masks\\n\", numMasks)",
          "new_text": null,
          "old_line_content": "    DEBUG_PRINTF(\"we have %u top masks\\n\", numMasks);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(numMasks <= NFA_MAX_TOP_MASKS)",
          "new_text": null,
          "old_line_content": "    assert(numMasks <= NFA_MAX_TOP_MASKS);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": "at",
          "new_api": null,
          "old_text": "args.state_ids.at(m.second)",
          "new_text": null,
          "old_line_content": "        u32 state_id = args.state_ids.at(m.second);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"state %u is in top mask %u\\n\", state_id, mask_idx)",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"state %u is in top mask %u\\n\", state_id, mask_idx);",
          "new_line_content": "    for (const auto &m : args.tops) {",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": "ROUNDUP_N",
          "new_api": null,
          "old_text": "ROUNDUP_N(num_states, 8)",
          "new_text": null,
          "old_line_content": "    return ROUNDUP_N(num_states, 8)/8;",
          "new_line_content": "static",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": "vertices_range",
          "new_api": null,
          "old_text": "vertices_range(h)",
          "new_text": null,
          "old_line_content": "    for (auto v : vertices_range(h)) {",
          "new_line_content": "    // Shrink state requirement to enough to fit the compressed largest reach.",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": "at",
          "new_api": null,
          "old_text": "state_ids.at(v)",
          "new_text": null,
          "old_line_content": "        u32 i = state_ids.at(v);",
          "new_line_content": "    vector<u32> allreach(N_CHARS, 0);",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "test",
          "new_api": null,
          "old_text": "maskedStates.test(i)",
          "new_text": null,
          "old_line_content": "        if (i == NO_STATE || maskedStates.test(i)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": "find_next",
          "new_api": null,
          "old_text": "cr.find_next(j)",
          "new_text": null,
          "old_line_content": "        for (size_t j = cr.find_first(); j != cr.npos; j = cr.find_next(j)) {",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": "end",
          "new_api": null,
          "old_text": "allreach.end()",
          "new_text": null,
          "old_line_content": "    u32 maxreach = *max_element(allreach.begin(), allreach.end());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"max reach is %u\\n\", maxreach)",
          "new_text": null,
          "old_line_content": "    DEBUG_PRINTF(\"max reach is %u\\n\", maxreach);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": "empty",
          "new_api": null,
          "old_text": "args.squashMap.empty()",
          "new_text": null,
          "old_line_content": "    if (args.squashMap.empty()) {",
          "new_line_content": "bool hasSquashableInitDs(const build_info &args) {",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"squash map is empty\\n\")",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"squash map is empty\\n\");",
          "new_line_content": "    const NGHolder &h = args.h;",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": "at",
          "new_api": null,
          "old_text": "args.state_ids.at(h.startDs)",
          "new_text": null,
          "old_line_content": "    u32 sds_state = args.state_ids.at(h.startDs);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"no states in initds\\n\")",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"no states in initds\\n\");",
          "new_line_content": "    NFAStateSet initDs(args.num_states);",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": "set",
          "new_api": null,
          "old_text": "initDs.set(sds_state)",
          "new_text": null,
          "old_line_content": "    initDs.set(sds_state);",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "at",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"checking squash mask for state %u\\n\",\n                     args.state_ids.at(m.first))",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"checking squash mask for state %u\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "at",
          "new_api": null,
          "old_text": "args.state_ids.at(m.first)",
          "new_text": null,
          "old_line_content": "                     args.state_ids.at(m.first));",
          "new_line_content": "    // Check normal squash map.",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": "at",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"state %u squashes initds states\\n\",\n                         args.state_ids.at(m.first))",
          "new_text": null,
          "old_line_content": "            DEBUG_PRINTF(\"state %u squashes initds states\\n\",",
          "new_line_content": "        NFAStateSet squashed = ~(m.second); // flip mask",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": "at",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"checking report squash mask for state %u\\n\",\n                     args.state_ids.at(m.first))",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"checking report squash mask for state %u\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": "at",
          "new_api": null,
          "old_text": "args.state_ids.at(m.first)",
          "new_text": null,
          "old_line_content": "                     args.state_ids.at(m.first));",
          "new_line_content": "    // Check report squash map.",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": "at",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"state %u squashes initds states\\n\",\n                         args.state_ids.at(m.first))",
          "new_text": null,
          "old_line_content": "            DEBUG_PRINTF(\"state %u squashes initds states\\n\",",
          "new_line_content": "        NFAStateSet squashed = ~(m.second); // flip mask",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": "at",
          "new_api": null,
          "old_text": "state_ids.at(h.startDs)",
          "new_text": null,
          "old_line_content": "    if (state_ids.at(h.startDs) != NO_STATE) {",
          "new_line_content": "static",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": "at",
          "new_api": null,
          "old_text": "state_ids.at(h.start)",
          "new_text": null,
          "old_line_content": "    if (is_triggered(h) && state_ids.at(h.start) != NO_STATE) {",
          "new_line_content": "        return true;",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": "generates_callbacks",
          "new_api": null,
          "old_text": "generates_callbacks(h)",
          "new_text": null,
          "old_line_content": "    if (!generates_callbacks(h)) {",
          "new_line_content": "void findMaskedCompressionStates(const build_info &args,",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": "hasSquashableInitDs",
          "new_api": null,
          "old_text": "hasSquashableInitDs(args)",
          "new_text": null,
          "old_line_content": "        if (sds_i != NO_STATE && !hasSquashableInitDs(args)) {",
          "new_line_content": "        // Rose leftfixes can mask out initds, which is worth doing if it will",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": "set",
          "new_api": null,
          "old_text": "maskedStates.set(sds_i)",
          "new_text": null,
          "old_line_content": "            maskedStates.set(sds_i);",
          "new_line_content": "        // stay on forever (i.e. it's not squashable).",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "hasInitDsStates",
          "new_api": null,
          "old_text": "hasInitDsStates(h, args.state_ids)",
          "new_text": null,
          "old_line_content": "    if (generates_callbacks(h) && !hasInitDsStates(h, args.state_ids)) {",
          "new_line_content": "    // Suffixes and outfixes can mask out leaf states, which should all be",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "edges_range",
          "new_api": null,
          "old_text": "edges_range(h)",
          "new_text": null,
          "old_line_content": "        for (const auto &e : edges_range(h)) {",
          "new_line_content": "    // as we switch that on unconditionally in the expand call.",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": "target",
          "new_api": null,
          "old_text": "target(e, h)",
          "new_text": null,
          "old_line_content": "            u32 to = args.state_ids.at(target(e, h));",
          "new_line_content": "        NFAStateSet nonleaf(args.num_states);",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": "target",
          "new_api": null,
          "old_text": "target(e, h)",
          "new_text": null,
          "old_line_content": "            if (to == NO_STATE && target(e, h) != h.acceptEod) {",
          "new_line_content": "            // We cannot mask out EOD accepts, as they have to perform an",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": "set",
          "new_api": null,
          "old_text": "nonleaf.set(from)",
          "new_text": null,
          "old_line_content": "            nonleaf.set(from);",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": "test",
          "new_api": null,
          "old_text": "nonleaf.test(i)",
          "new_text": null,
          "old_line_content": "            if (!nonleaf.test(i)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "set",
          "new_api": null,
          "old_text": "maskedStates.set(i)",
          "new_text": null,
          "old_line_content": "                maskedStates.set(i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": "count",
          "new_api": null,
          "old_text": "maskedStates.count()",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"masking out %zu leaf states\\n\", maskedStates.count());",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(flag)",
          "new_text": null,
          "old_line_content": "    assert(flag);",
          "new_line_content": "template<class implNFA_t>",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert((flag & (flag - 1)) == 0)",
          "new_text": null,
          "old_line_content": "    assert((flag & (flag - 1)) == 0);",
          "new_line_content": "static",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(flag)",
          "new_text": null,
          "old_line_content": "    assert(flag);",
          "new_line_content": "/** \\brief Sets a given flag in the NFA structure */",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert((flag & (flag - 1)) == 0)",
          "new_text": null,
          "old_line_content": "    assert((flag & (flag - 1)) == 0);",
          "new_line_content": "static",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "maskFill",
          "new_api": null,
          "old_text": "maskFill(limex->compressMask, 0xff)",
          "new_text": null,
          "old_line_content": "    maskFill(limex->compressMask, 0xff);",
          "new_line_content": "static",
          "content_same": false
        },
        {
          "line": 1053,
          "old_api": "uncompressedStateSize",
          "new_api": null,
          "old_text": "uncompressedStateSize(args.num_states)",
          "new_text": null,
          "old_line_content": "    u32 sizeUncompressed = uncompressedStateSize(args.num_states);",
          "new_line_content": "    // Nothing is masked off by default.",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": "findMaskedCompressionStates",
          "new_api": null,
          "old_text": "findMaskedCompressionStates(args, maskedStates)",
          "new_text": null,
          "old_line_content": "    findMaskedCompressionStates(args, maskedStates);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": "compressedStateSize",
          "new_api": null,
          "old_text": "compressedStateSize(args.h, maskedStates, args.state_ids)",
          "new_text": null,
          "old_line_content": "    u32 sizeCompressed = compressedStateSize(args.h, maskedStates, args.state_ids);",
          "new_line_content": "    NFAStateSet maskedStates(args.num_states);",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"using compression, state size %u\\n\",\n                     sizeCompressed)",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"using compression, state size %u\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": "setLimexFlag",
          "new_api": null,
          "old_text": "setLimexFlag(limex, LIMEX_FLAG_COMPRESS_STATE)",
          "new_text": null,
          "old_line_content": "        setLimexFlag(limex, LIMEX_FLAG_COMPRESS_STATE);",
          "new_line_content": "    if ((sizeCompressed * 100) <= (sizeUncompressed * 90)) {",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "count",
          "new_api": null,
          "old_text": "maskedStates.count()",
          "new_text": null,
          "old_line_content": "            DEBUG_PRINTF(\"masking %zu states\\n\", maskedStates.count());",
          "new_line_content": "        limex->stateSize = sizeCompressed;",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "setLimexFlag",
          "new_api": null,
          "old_text": "setLimexFlag(limex, LIMEX_FLAG_COMPRESS_MASKED)",
          "new_text": null,
          "old_line_content": "            setLimexFlag(limex, LIMEX_FLAG_COMPRESS_MASKED);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"not using compression, state size %u\\n\",\n                     sizeUncompressed)",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"not using compression, state size %u\\n\",",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "    explicit ExceptionProto(u32 num_states)",
          "new_line_content": "    enum LimExTrigger trigger = LIMEX_TRIGGER_NONE;",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": "set",
          "new_api": null,
          "old_text": "squash_states.set()",
          "new_text": null,
          "old_line_content": "        squash_states.set();",
          "new_line_content": "        : succ_states(num_states), squash_states(num_states) {",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": "ORDER_CHECK",
          "new_api": null,
          "old_text": "ORDER_CHECK(reports_index)",
          "new_text": null,
          "old_line_content": "        ORDER_CHECK(reports_index);",
          "new_line_content": "    bool operator<(const ExceptionProto &b) const {",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": "ORDER_CHECK",
          "new_api": null,
          "old_text": "ORDER_CHECK(repeat_index)",
          "new_text": null,
          "old_line_content": "        ORDER_CHECK(repeat_index);",
          "new_line_content": "        const ExceptionProto &a = *this;",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": "ORDER_CHECK",
          "new_api": null,
          "old_text": "ORDER_CHECK(trigger)",
          "new_text": null,
          "old_line_content": "        ORDER_CHECK(trigger);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": "empty",
          "new_api": null,
          "old_text": "reports.empty()",
          "new_text": null,
          "old_line_content": "    if (reports.empty()) {",
          "new_line_content": "u32 getReportListIndex(const flat_set<ReportID> &reports,",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": "end",
          "new_api": null,
          "old_text": "reports.end()",
          "new_text": null,
          "old_line_content": "    const vector<ReportID> r(reports.begin(), reports.end());",
          "new_line_content": "        return MO_INVALID_IDX;",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": "find",
          "new_api": null,
          "old_text": "reportListCache.find(r)",
          "new_text": null,
          "old_line_content": "    auto it = reportListCache.find(r);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": "size",
          "new_api": null,
          "old_text": "exceptionReports.size()",
          "new_text": null,
          "old_line_content": "    u32 idx = verify_u32(exceptionReports.size());",
          "new_line_content": "        return idx;",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": "end",
          "new_api": null,
          "old_text": "r.end()",
          "new_text": null,
          "old_line_content": "    exceptionReports.insert(exceptionReports.end(), r.begin(), r.end());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1172,
          "old_api": "size",
          "new_api": null,
          "old_text": "args.repeats.size()",
          "new_text": null,
          "old_line_content": "    for (u32 i = 0; i < args.repeats.size(); i++) {",
          "new_line_content": "    ue2::unordered_map<NFAVertex, u32> pos_trigger;",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": "contains",
          "new_api": null,
          "old_text": "contains(pos_trigger, br.pos_trigger)",
          "new_text": null,
          "old_line_content": "        assert(!contains(pos_trigger, br.pos_trigger));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": "vertices_range",
          "new_api": null,
          "old_text": "vertices_range(h)",
          "new_text": null,
          "old_line_content": "    for (auto v : vertices_range(h)) {",
          "new_line_content": "    // list in case we can reuse them.",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": "at",
          "new_api": null,
          "old_text": "args.state_ids.at(v)",
          "new_text": null,
          "old_line_content": "        const u32 i = args.state_ids.at(v);",
          "new_line_content": "    map<vector<ReportID>, u32> reportListCache;",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": "generates_callbacks",
          "new_api": null,
          "old_text": "generates_callbacks(h)",
          "new_text": null,
          "old_line_content": "        if (edge(v, h.accept, h).second && generates_callbacks(h)) {",
          "new_line_content": "        bool addMe = false;",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": "size",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"state %u is exceptional due to accept \"\n                         \"(%zu reports)\\n\", i, reports.size())",
          "new_text": null,
          "old_line_content": "            DEBUG_PRINTF(\"state %u is exceptional due to accept \"",
          "new_line_content": "             * states as exceptional */",
          "content_same": false
        },
        {
          "line": 1202,
          "old_api": "size",
          "new_api": null,
          "old_text": "reports.size()",
          "new_text": null,
          "old_line_content": "                         \"(%zu reports)\\n\", i, reports.size());",
          "new_line_content": "            const auto &reports = h[v].reports;",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": "end",
          "new_api": null,
          "old_text": "args.reportSquashMap.end()",
          "new_text": null,
          "old_line_content": "            if (mi != args.reportSquashMap.end()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"report squashes states\\n\")",
          "new_text": null,
          "old_line_content": "                DEBUG_PRINTF(\"report squashes states\\n\");",
          "new_line_content": "            // We may be applying a report squash too.",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": "contains",
          "new_api": null,
          "old_text": "contains(pos_trigger, v)",
          "new_text": null,
          "old_line_content": "        if (contains(pos_trigger, v)) {",
          "new_line_content": "            addMe = true;",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(e.trigger == LIMEX_TRIGGER_NONE)",
          "new_text": null,
          "old_line_content": "            assert(e.trigger == LIMEX_TRIGGER_NONE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": "contains",
          "new_api": null,
          "old_text": "contains(tug_trigger, v)",
          "new_text": null,
          "old_line_content": "        if (contains(tug_trigger, v)) {",
          "new_line_content": "            addMe = true;",
          "content_same": false
        },
        {
          "line": 1231,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(e.trigger == LIMEX_TRIGGER_NONE)",
          "new_text": null,
          "old_line_content": "            assert(e.trigger == LIMEX_TRIGGER_NONE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1236,
          "old_api": "at",
          "new_api": null,
          "old_text": "args.state_ids.at(args.repeats[repeat_index].cyclic)",
          "new_text": null,
          "old_line_content": "            u32 cyclic = args.state_ids.at(args.repeats[repeat_index].cyclic);",
          "new_line_content": "            e.repeat_index = repeat_index;",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": "reset",
          "new_api": null,
          "old_text": "e.squash_states.reset(cyclic)",
          "new_text": null,
          "old_line_content": "            e.squash_states.reset(cyclic);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "out_edges_range",
          "new_api": null,
          "old_text": "out_edges_range(v, h)",
          "new_text": null,
          "old_line_content": "        for (const auto &oe : out_edges_range(v, h)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": "contains",
          "new_api": null,
          "old_text": "contains(exceptional, oe)",
          "new_text": null,
          "old_line_content": "            if (contains(exceptional, oe)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": "target",
          "new_api": null,
          "old_text": "target(oe, h)",
          "new_text": null,
          "old_line_content": "                NFAVertex w = target(oe, h);",
          "new_line_content": "        // are we a non-limited transition?",
          "content_same": false
        },
        {
          "line": 1262,
          "old_api": "adjacent_vertices_range",
          "new_api": null,
          "old_text": "adjacent_vertices_range(v, h)",
          "new_text": null,
          "old_line_content": "            for (auto w : adjacent_vertices_range(v, h)) {",
          "new_line_content": "        /* The above comment is IMHO bogus and would result in all squashing",
          "content_same": false
        },
        {
          "line": 1266,
          "old_api": "at",
          "new_api": null,
          "old_text": "args.state_ids.at(w)",
          "new_text": null,
          "old_line_content": "                u32 j = args.state_ids.at(w);",
          "new_line_content": "                if (w == v) {",
          "content_same": false
        },
        {
          "line": 1270,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"we are checking if succ %u is a squasher\\n\", j)",
          "new_text": null,
          "old_line_content": "                DEBUG_PRINTF(\"we are checking if succ %u is a squasher\\n\", j);",
          "new_line_content": "                if (j == NO_STATE) {",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": "find",
          "new_api": null,
          "old_text": "args.squashMap.find(w)",
          "new_text": null,
          "old_line_content": "                auto mi = args.squashMap.find(w);",
          "new_line_content": "                    continue;",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": "end",
          "new_api": null,
          "old_text": "args.squashMap.end()",
          "new_text": null,
          "old_line_content": "                if (mi != args.squashMap.end()) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1284,
          "old_api": "size",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"squashing succ %u (turns off %zu states)\\n\",\n                                 j, mi->second.size() - mi->second.count())",
          "new_text": null,
          "old_line_content": "                    DEBUG_PRINTF(\"squashing succ %u (turns off %zu states)\\n\",",
          "new_line_content": "                    // squashing above.",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": "count",
          "new_api": null,
          "old_text": "mi->second.count()",
          "new_text": null,
          "old_line_content": "                                 j, mi->second.size() - mi->second.count());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1294,
          "old_api": "size",
          "new_api": null,
          "old_text": "e.succ_states.size()",
          "new_text": null,
          "old_line_content": "            assert(e.succ_states.size() == num_states);",
          "new_line_content": "        if (addMe) {",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": "size",
          "new_api": null,
          "old_text": "e.squash_states.size()",
          "new_text": null,
          "old_line_content": "            assert(e.squash_states.size() == num_states);",
          "new_line_content": "            // Add 'e' if it isn't in the map, and push state i on to its list",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "exceptionMap[e].push_back(i)",
          "new_text": null,
          "old_line_content": "            exceptionMap[e].push_back(i);",
          "new_line_content": "            // of states.",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": "size",
          "new_api": null,
          "old_text": "exceptionMap.size()",
          "new_text": null,
          "old_line_content": "    DEBUG_PRINTF(\"%zu unique exceptions found.\\n\", exceptionMap.size());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1305,
          "old_api": "is_reachable",
          "new_api": null,
          "old_text": "d.is_reachable()",
          "new_text": null,
          "old_line_content": "    assert(d.is_reachable());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1306,
          "old_api": "is_infinite",
          "new_api": null,
          "old_text": "d.is_infinite()",
          "new_text": null,
          "old_line_content": "    if (d.is_infinite()) {",
          "new_line_content": "static",
          "content_same": false
        },
        {
          "line": 1311,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(d_val < REPEAT_INF)",
          "new_text": null,
          "old_line_content": "    assert(d_val < REPEAT_INF);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": "source",
          "new_api": null,
          "old_text": "source(e, h)",
          "new_text": null,
          "old_line_content": "        NFAVertex from = source(e, h);",
          "new_line_content": "    bool isExceptionalTransition(const NGHolder &h, const NFAEdge &e,",
          "content_same": false
        },
        {
          "line": 1327,
          "old_api": "target",
          "new_api": null,
          "old_text": "target(e, h)",
          "new_text": null,
          "old_line_content": "        NFAVertex to = target(e, h);",
          "new_line_content": "                                 const ue2::unordered_map<NFAVertex, u32> &state_ids,",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": "at",
          "new_api": null,
          "old_text": "state_ids.at(from)",
          "new_text": null,
          "old_line_content": "        u32 f = state_ids.at(from);",
          "new_line_content": "                                 const ue2::unordered_set<NFAVertex> &tugs) {",
          "content_same": false
        },
        {
          "line": 1335,
          "old_api": "contains",
          "new_api": null,
          "old_text": "contains(tugs, from)",
          "new_text": null,
          "old_line_content": "        if (contains(tugs, from)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": "getMutableImplNfa",
          "new_api": null,
          "old_text": "getMutableImplNfa(nfa)",
          "new_text": null,
          "old_line_content": "        implNFA_t *limex = (implNFA_t *)getMutableImplNfa(nfa);",
          "new_line_content": "    static",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"bitvector=%zu/%u, repeat full=%u, stream=%u\\n\",\n                     sizeof(limex->init), stateSize, repeatscratchStateSize,\n                     repeatStreamState)",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"bitvector=%zu/%u, repeat full=%u, stream=%u\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1360,
          "old_api": "alignof",
          "new_api": null,
          "old_text": "alignof(RepeatControl)",
          "new_text": null,
          "old_line_content": "                = ROUNDUP_N(scratchStateSize, alignof(RepeatControl));",
          "new_line_content": "        size_t scratchStateSize = sizeof(limex->init);",
          "content_same": false
        },
        {
          "line": 1365,
          "old_api": "verify_u32",
          "new_api": null,
          "old_text": "verify_u32(scratchStateSize)",
          "new_text": null,
          "old_line_content": "        nfa->scratchStateSize = verify_u32(scratchStateSize);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": "verify_u32",
          "new_api": null,
          "old_text": "verify_u32(streamStateSize)",
          "new_text": null,
          "old_line_content": "        nfa->streamStateSize = verify_u32(streamStateSize);",
          "new_line_content": "        size_t streamStateSize = stateSize + repeatStreamState;",
          "content_same": false
        },
        {
          "line": 1376,
          "old_api": "alignof",
          "new_api": null,
          "old_text": "alignof(u64a)",
          "new_text": null,
          "old_line_content": "            len = ROUNDUP_N(len, alignof(u64a));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1377,
          "old_api": "verify_u32",
          "new_api": null,
          "old_text": "verify_u32(len)",
          "new_text": null,
          "old_line_content": "            *tableOffset = verify_u32(len);",
          "new_line_content": "        // sparse lookup table.",
          "content_same": false
        },
        {
          "line": 1384,
          "old_api": "alignof",
          "new_api": null,
          "old_text": "alignof(tableRow_t)",
          "new_text": null,
          "old_line_content": "        len = ROUNDUP_N(len, alignof(tableRow_t));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1385,
          "old_api": "verify_u32",
          "new_api": null,
          "old_text": "verify_u32(len)",
          "new_text": null,
          "old_line_content": "        *tugMaskOffset = verify_u32(len);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1389,
          "old_api": "ROUNDUP_CL",
          "new_api": null,
          "old_text": "ROUNDUP_CL(len)",
          "new_text": null,
          "old_line_content": "        len = ROUNDUP_CL(len);",
          "new_line_content": "        len += sizeof(tableRow_t);",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": "size",
          "new_api": null,
          "old_text": "args.repeats.size()",
          "new_text": null,
          "old_line_content": "        out.reserve(args.repeats.size());",
          "new_line_content": "    void buildRepeats(const build_info &args,",
          "content_same": false
        },
        {
          "line": 1408,
          "old_api": "aligned_zmalloc_unique<NFARepeatInfo>(len)",
          "new_api": null,
          "old_text": "aligned_zmalloc_unique<NFARepeatInfo>(len)",
          "new_text": null,
          "old_line_content": "            auto info = aligned_zmalloc_unique<NFARepeatInfo>(len);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1409,
          "old_api": "get",
          "new_api": null,
          "old_text": "info.get()",
          "new_text": null,
          "old_line_content": "            char *info_ptr = (char *)info.get();",
          "new_line_content": "            u32 tableOffset, tugMaskOffset;",
          "content_same": false
        },
        {
          "line": 1416,
          "old_api": "at",
          "new_api": null,
          "old_text": "args.state_ids.at(br.cyclic)",
          "new_text": null,
          "old_line_content": "            info->cyclicState = args.state_ids.at(br.cyclic);",
          "new_line_content": "            u32 streamStateLen = rsi.packedCtrlSize + rsi.stateSize;",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": "depth_to_u32",
          "new_api": null,
          "old_text": "depth_to_u32(br.repeatMin)",
          "new_text": null,
          "old_line_content": "            repeat->repeatMin = depth_to_u32(br.repeatMin);",
          "new_line_content": "            RepeatInfo *repeat =",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": "depth_to_u32",
          "new_api": null,
          "old_text": "depth_to_u32(br.repeatMax)",
          "new_text": null,
          "old_line_content": "            repeat->repeatMax = depth_to_u32(br.repeatMax);",
          "new_line_content": "                (RepeatInfo *)(info_ptr + sizeof(NFARepeatInfo));",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": "copy_bytes",
          "new_api": null,
          "old_text": "copy_bytes(repeat->packedFieldSizes, rsi.packedFieldSizes)",
          "new_text": null,
          "old_line_content": "            copy_bytes(repeat->packedFieldSizes, rsi.packedFieldSizes);",
          "new_line_content": "            repeat->horizon = rsi.horizon;",
          "content_same": false
        },
        {
          "line": 1446,
          "old_api": "empty",
          "new_api": null,
          "old_text": "rsi.table.empty()",
          "new_text": null,
          "old_line_content": "                assert(!rsi.table.empty());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1447,
          "old_api": "copy_bytes",
          "new_api": null,
          "old_text": "copy_bytes(info_ptr + tableOffset, rsi.table)",
          "new_text": null,
          "old_line_content": "                copy_bytes(info_ptr + tableOffset, rsi.table);",
          "new_line_content": "            // Copy in the sparse lookup table.",
          "content_same": false
        },
        {
          "line": 1453,
          "old_api": "at",
          "new_api": null,
          "old_text": "args.state_ids.at(v)",
          "new_text": null,
          "old_line_content": "                u32 state_id = args.state_ids.at(v);",
          "new_line_content": "            // Fill the tug mask.",
          "content_same": false
        },
        {
          "line": 1454,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(state_id != NO_STATE)",
          "new_text": null,
          "old_line_content": "                assert(state_id != NO_STATE);",
          "new_line_content": "            tableRow_t *tugMask = (tableRow_t *)(info_ptr + tugMaskOffset);",
          "content_same": false
        },
        {
          "line": 1455,
          "old_api": "maskSetBit",
          "new_api": null,
          "old_text": "maskSetBit(*tugMask, state_id)",
          "new_text": null,
          "old_line_content": "                maskSetBit(*tugMask, state_id);",
          "new_line_content": "            for (auto v : br.tug_triggers) {",
          "content_same": false
        },
        {
          "line": 1462,
          "old_api": "move",
          "new_api": null,
          "old_text": "move(info)",
          "new_text": null,
          "old_line_content": "            out.emplace_back(move(info), len);",
          "new_line_content": "            *streamState += streamStateLen;",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": "at",
          "new_api": null,
          "old_text": "args.state_ids.at(h.start)",
          "new_text": null,
          "old_line_content": "        u32 s_i = args.state_ids.at(h.start);",
          "new_line_content": "        const NGHolder &h = args.h;",
          "content_same": false
        },
        {
          "line": 1472,
          "old_api": "at",
          "new_api": null,
          "old_text": "args.state_ids.at(h.startDs)",
          "new_text": null,
          "old_line_content": "        u32 sds_i = args.state_ids.at(h.startDs);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1476,
          "old_api": "is_triggered",
          "new_api": null,
          "old_text": "is_triggered(h)",
          "new_text": null,
          "old_line_content": "            if (is_triggered(h)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1477,
          "old_api": "maskSetBit",
          "new_api": null,
          "old_text": "maskSetBit(limex->initDS, s_i)",
          "new_text": null,
          "old_line_content": "                maskSetBit(limex->initDS, s_i);",
          "new_line_content": "        if (s_i != NO_STATE) {",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": "maskSetBit",
          "new_api": null,
          "old_text": "maskSetBit(limex->init, sds_i)",
          "new_text": null,
          "old_line_content": "            maskSetBit(limex->init, sds_i);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1483,
          "old_api": "maskSetBit",
          "new_api": null,
          "old_text": "maskSetBit(limex->initDS, sds_i)",
          "new_text": null,
          "old_line_content": "            maskSetBit(limex->initDS, sds_i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1488,
          "old_api": "at",
          "new_api": null,
          "old_text": "args.state_ids.at(v)",
          "new_text": null,
          "old_line_content": "            u32 state_id = args.state_ids.at(v);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1489,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(state_id != NO_STATE)",
          "new_text": null,
          "old_line_content": "            assert(state_id != NO_STATE);",
          "new_line_content": "        // Zombie mask.",
          "content_same": false
        },
        {
          "line": 1490,
          "old_api": "maskSetBit",
          "new_api": null,
          "old_text": "maskSetBit(limex->zombieMask, state_id)",
          "new_text": null,
          "old_line_content": "            maskSetBit(limex->zombieMask, state_id);",
          "new_line_content": "        for (auto v : args.zombies) {",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": "at",
          "new_api": null,
          "old_text": "args.state_ids.at(br.cyclic)",
          "new_text": null,
          "old_line_content": "            u32 cyclic = args.state_ids.at(br.cyclic);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(cyclic != NO_STATE)",
          "new_text": null,
          "old_line_content": "            assert(cyclic != NO_STATE);",
          "new_line_content": "        // Repeat cyclic mask.",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": "maskSetBit",
          "new_api": null,
          "old_text": "maskSetBit(limex->repeatCyclicMask, cyclic)",
          "new_text": null,
          "old_line_content": "            maskSetBit(limex->repeatCyclicMask, cyclic);",
          "new_line_content": "        for (const auto &br : args.repeats) {",
          "content_same": false
        },
        {
          "line": 1505,
          "old_api": "edges_range",
          "new_api": null,
          "old_text": "edges_range(h)",
          "new_text": null,
          "old_line_content": "        for (const auto &e : edges_range(h)) {",
          "new_line_content": "    void writeShiftMasks(const build_info &args, implNFA_t *limex) {",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": "source",
          "new_api": null,
          "old_text": "source(e, h)",
          "new_text": null,
          "old_line_content": "            u32 from = args.state_ids.at(source(e, h));",
          "new_line_content": "        const NGHolder &h = args.h;",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": "target",
          "new_api": null,
          "old_text": "target(e, h)",
          "new_text": null,
          "old_line_content": "            u32 to = args.state_ids.at(target(e, h));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": "isExceptionalTransition",
          "new_api": null,
          "old_text": "isExceptionalTransition(h, e, args.state_ids, args.tugs)",
          "new_text": null,
          "old_line_content": "            if (!isExceptionalTransition(h, e, args.state_ids, args.tugs)) {",
          "new_line_content": "            // We check for exceptional transitions here, as we don't want tug",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": "maskSetBit",
          "new_api": null,
          "old_text": "maskSetBit(limex->shift[to - from], from)",
          "new_text": null,
          "old_line_content": "                maskSetBit(limex->shift[to - from], from);",
          "new_line_content": "            // trigger transitions emitted as limited transitions (even if they",
          "content_same": false
        },
        {
          "line": 1526,
          "old_api": "edges_range",
          "new_api": null,
          "old_text": "edges_range(h)",
          "new_text": null,
          "old_line_content": "        for (const auto &e : edges_range(h)) {",
          "new_line_content": "                                    ue2::unordered_set<NFAEdge> &exceptional) {",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": "source",
          "new_api": null,
          "old_text": "source(e, h)",
          "new_text": null,
          "old_line_content": "            u32 from = args.state_ids.at(source(e, h));",
          "new_line_content": "        const NGHolder &h = args.h;",
          "content_same": false
        },
        {
          "line": 1528,
          "old_api": "target",
          "new_api": null,
          "old_text": "target(e, h)",
          "new_text": null,
          "old_line_content": "            u32 to = args.state_ids.at(target(e, h));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1533,
          "old_api": "isExceptionalTransition",
          "new_api": null,
          "old_text": "isExceptionalTransition(h, e, args.state_ids, args.tugs)",
          "new_text": null,
          "old_line_content": "            if (isExceptionalTransition(h, e, args.state_ids, args.tugs)) {",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 1534,
          "old_api": "insert",
          "new_api": null,
          "old_text": "exceptional.insert(e)",
          "new_text": null,
          "old_line_content": "                exceptional.insert(e);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1543,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"exceptionsOffset=%u\\n\", exceptionsOffset)",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"exceptionsOffset=%u\\n\", exceptionsOffset);",
          "new_line_content": "    void writeExceptions(const map<ExceptionProto, vector<u32> > &exceptionMap,",
          "content_same": false
        },
        {
          "line": 1547,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(limex->exceptionMap, 0xff, sizeof(limex->exceptionMap))",
          "new_text": null,
          "old_line_content": "        memset(limex->exceptionMap, 0xff, sizeof(limex->exceptionMap));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": "size",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"exception %u, triggered by %zu states.\\n\", ecount,\n                         states.size())",
          "new_text": null,
          "old_line_content": "            DEBUG_PRINTF(\"exception %u, triggered by %zu states.\\n\", ecount,",
          "new_line_content": "        for (const auto &m : exceptionMap) {",
          "content_same": false
        },
        {
          "line": 1557,
          "old_api": "size",
          "new_api": null,
          "old_text": "states.size()",
          "new_text": null,
          "old_line_content": "                         states.size());",
          "new_line_content": "            const ExceptionProto &proto = m.first;",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": "maskSetBits",
          "new_api": null,
          "old_text": "maskSetBits(e.squash, proto.squash_states)",
          "new_text": null,
          "old_line_content": "            maskSetBits(e.squash, proto.squash_states);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": "maskSetBits",
          "new_api": null,
          "old_text": "maskSetBits(e.successors, proto.succ_states)",
          "new_text": null,
          "old_line_content": "            maskSetBits(e.successors, proto.succ_states);",
          "new_line_content": "            // Write the exception entry.",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": "maskSetBit",
          "new_api": null,
          "old_text": "maskSetBit(limex->exceptionMask, state_id)",
          "new_text": null,
          "old_line_content": "                maskSetBit(limex->exceptionMask, state_id);",
          "new_line_content": "            // for each state that can switch it on",
          "content_same": false
        },
        {
          "line": 1589,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"reachOffset=%u\\n\", reachOffset)",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"reachOffset=%u\\n\", reachOffset);",
          "new_line_content": "    void writeReachMapping(const vector<NFAStateSet> &reach,",
          "content_same": false
        },
        {
          "line": 1596,
          "old_api": "ISALIGNED",
          "new_api": null,
          "old_text": "ISALIGNED(reachMask)",
          "new_text": null,
          "old_line_content": "        assert(ISALIGNED(reachMask));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1597,
          "old_api": "size",
          "new_api": null,
          "old_text": "reach.size()",
          "new_text": null,
          "old_line_content": "        for (size_t i = 0, end = reach.size(); i < end; i++) {",
          "new_line_content": "        // Reach table is right after the LimEx structure.",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": "maskSetBits",
          "new_api": null,
          "old_text": "maskSetBits(reachMask[i], reach[i])",
          "new_text": null,
          "old_line_content": "            maskSetBits(reachMask[i], reach[i]);",
          "new_line_content": "        tableRow_t *reachMask = (tableRow_t *)((char *)limex + reachOffset);",
          "content_same": false
        },
        {
          "line": 1606,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"topsOffset=%u\\n\", topsOffset)",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"topsOffset=%u\\n\", topsOffset);",
          "new_line_content": "    static",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": "ISALIGNED",
          "new_api": null,
          "old_text": "ISALIGNED(topMasks)",
          "new_text": null,
          "old_line_content": "        assert(ISALIGNED(topMasks));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": "size",
          "new_api": null,
          "old_text": "tops.size()",
          "new_text": null,
          "old_line_content": "        for (size_t i = 0, end = tops.size(); i < end; i++) {",
          "new_line_content": "        tableRow_t *topMasks = (tableRow_t *)((char *)limex + topsOffset);",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": "find_first",
          "new_api": null,
          "old_text": "accelMask.find_first()",
          "new_text": null,
          "old_line_content": "        for (size_t i = accelMask.find_first(); i != accelMask.npos;",
          "new_line_content": "        char *comp_base = (char *)&limex->accelCompare;",
          "content_same": false
        },
        {
          "line": 1626,
          "old_api": "find_next",
          "new_api": null,
          "old_text": "accelMask.find_next(i)",
          "new_text": null,
          "old_line_content": "             i = accelMask.find_next(i), ++num) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1627,
          "old_api": "verify_u32",
          "new_api": null,
          "old_text": "verify_u32(i)",
          "new_text": null,
          "old_line_content": "            u32 state_id = verify_u32(i);",
          "new_line_content": "        u32 num = 0; // index in accel table.",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"mask_idx=%zu\\n\", mask_idx)",
          "new_text": null,
          "old_line_content": "            DEBUG_PRINTF(\"mask_idx=%zu\\n\", mask_idx);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1636,
          "old_api": "maskSetByte",
          "new_api": null,
          "old_text": "maskSetByte(*comp, num, ~(1U << (state_id % 8U)))",
          "new_text": null,
          "old_line_content": "            maskSetByte(*comp, num, ~(1U << (state_id % 8U)));",
          "new_line_content": "            u_128 *perm = (u_128 *)(perm_base + mask_idx);",
          "content_same": false
        },
        {
          "line": 1646,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"accelTableOffset=%u, accelAuxOffset=%u\\n\",\n                      accelTableOffset, accelAuxOffset)",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"accelTableOffset=%u, accelAuxOffset=%u\\n\",",
          "new_line_content": "                    const AccelAuxVector &accelAux,",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": "end",
          "new_api": null,
          "old_text": "accelTable.end()",
          "new_text": null,
          "old_line_content": "        copy(accelTable.begin(), accelTable.end(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": "ISALIGNED",
          "new_api": null,
          "old_text": "ISALIGNED(auxTable)",
          "new_text": null,
          "old_line_content": "        assert(ISALIGNED(auxTable));",
          "new_line_content": "        // Write accel aux structures.",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": "end",
          "new_api": null,
          "old_text": "accelAux.end()",
          "new_text": null,
          "old_line_content": "        copy(accelAux.begin(), accelAux.end(), auxTable);",
          "new_line_content": "        limex->accelAuxOffset = accelAuxOffset;",
          "content_same": false
        },
        {
          "line": 1663,
          "old_api": "size",
          "new_api": null,
          "old_text": "accelAux.size()",
          "new_text": null,
          "old_line_content": "        limex->accelAuxCount = verify_u32(accelAux.size());",
          "new_line_content": "        // Write LimEx structure members.",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": "maskSetBits",
          "new_api": null,
          "old_text": "maskSetBits(limex->accel_and_friends, accelFriendsMask)",
          "new_text": null,
          "old_line_content": "        maskSetBits(limex->accel_and_friends, accelFriendsMask);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": "maskClear",
          "new_api": null,
          "old_text": "maskClear(limex->accelCompare)",
          "new_text": null,
          "old_line_content": "        maskClear(limex->accelCompare);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": "maskFill",
          "new_api": null,
          "old_text": "maskFill(limex->accelPermute, (char)0x80)",
          "new_text": null,
          "old_line_content": "        maskFill(limex->accelPermute, (char)0x80);",
          "new_line_content": "        // We can use PSHUFB-based shuffles for models >= 128 states. These",
          "content_same": false
        },
        {
          "line": 1686,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"acceptsOffset=%u, acceptsEodOffset=%u, squashOffset=%u\\n\",\n                     acceptsOffset, acceptsEodOffset, squashOffset)",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"acceptsOffset=%u, acceptsEodOffset=%u, squashOffset=%u\\n\",",
          "new_line_content": "                      const vector<NFAStateSet> &squash, implNFA_t *limex,",
          "content_same": false
        },
        {
          "line": 1690,
          "old_api": "maskSetBits",
          "new_api": null,
          "old_text": "maskSetBits(limex->accept, acceptMask)",
          "new_text": null,
          "old_line_content": "        maskSetBits(limex->accept, acceptMask);",
          "new_line_content": "                     acceptsOffset, acceptsEodOffset, squashOffset);",
          "content_same": false
        },
        {
          "line": 1691,
          "old_api": "maskSetBits",
          "new_api": null,
          "old_text": "maskSetBits(limex->acceptAtEOD, acceptEodMask)",
          "new_text": null,
          "old_line_content": "        maskSetBits(limex->acceptAtEOD, acceptEodMask);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1695,
          "old_api": "size",
          "new_api": null,
          "old_text": "accepts.size()",
          "new_text": null,
          "old_line_content": "        limex->acceptCount = verify_u32(accepts.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": "size",
          "new_api": null,
          "old_text": "accepts.size()",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"NFA has %zu accepts\\n\", accepts.size());",
          "new_line_content": "        // Write accept table.",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": "size",
          "new_api": null,
          "old_text": "acceptsEod.size()",
          "new_text": null,
          "old_line_content": "        limex->acceptEodCount = verify_u32(acceptsEod.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": "size",
          "new_api": null,
          "old_text": "acceptsEod.size()",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"NFA has %zu EOD accepts\\n\", acceptsEod.size());",
          "new_line_content": "        // Write eod accept table.",
          "content_same": false
        },
        {
          "line": 1712,
          "old_api": "size",
          "new_api": null,
          "old_text": "squash.size()",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"NFA has %zu report squash masks\\n\", squash.size());",
          "new_line_content": "        // Write squash mask table.",
          "content_same": false
        },
        {
          "line": 1714,
          "old_api": "ISALIGNED",
          "new_api": null,
          "old_text": "ISALIGNED(mask)",
          "new_text": null,
          "old_line_content": "        assert(ISALIGNED(mask));",
          "new_line_content": "        limex->squashOffset = squashOffset;",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": "maskSetBits",
          "new_api": null,
          "old_text": "maskSetBits(mask[i], squash[i])",
          "new_text": null,
          "old_line_content": "            maskSetBits(mask[i], squash[i]);",
          "new_line_content": "        tableRow_t *mask = (tableRow_t *)((char *)limex + squashOffset);",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": "size",
          "new_api": null,
          "old_text": "repeats.size()",
          "new_text": null,
          "old_line_content": "        const u32 num_repeats = verify_u32(repeats.size());",
          "new_line_content": "                                        size_t>> &repeats,",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"repeatOffsetsOffset=%u, repeatOffset=%u\\n\",\n                      repeatOffsetsOffset, repeatOffset)",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"repeatOffsetsOffset=%u, repeatOffset=%u\\n\",",
          "new_line_content": "                      const u32 repeatOffsetsOffset, const u32 repeatOffset) {",
          "content_same": false
        },
        {
          "line": 1735,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(repeats[i].first)",
          "new_text": null,
          "old_line_content": "            assert(repeats[i].first);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1736,
          "old_api": "get",
          "new_api": null,
          "old_text": "repeats[i].first.get()",
          "new_text": null,
          "old_line_content": "            memcpy((char *)limex + offset, repeats[i].first.get(),",
          "new_line_content": "        for (u32 i = 0; i < num_repeats; i++) {",
          "content_same": false
        },
        {
          "line": 1742,
          "old_api": "alignof",
          "new_api": null,
          "old_text": "alignof(u32)",
          "new_text": null,
          "old_line_content": "        assert(ISALIGNED_N((char *)limex + repeatOffsetsOffset, alignof(u32)));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": "copy_bytes",
          "new_api": null,
          "old_text": "copy_bytes((char *)limex + repeatOffsetsOffset, repeatOffsets)",
          "new_text": null,
          "old_line_content": "        copy_bytes((char *)limex + repeatOffsetsOffset, repeatOffsets);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"exceptionReportsOffset=%u\\n\", exceptionReportsOffset)",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"exceptionReportsOffset=%u\\n\", exceptionReportsOffset);",
          "new_line_content": "    void writeExceptionReports(const vector<ReportID> &reports,",
          "content_same": false
        },
        {
          "line": 1757,
          "old_api": "alignof",
          "new_api": null,
          "old_text": "alignof(ReportID)",
          "new_text": null,
          "old_line_content": "                           alignof(ReportID)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1758,
          "old_api": "copy_bytes",
          "new_api": null,
          "old_text": "copy_bytes((char *)limex + exceptionReportsOffset, reports)",
          "new_text": null,
          "old_line_content": "        copy_bytes((char *)limex + exceptionReportsOffset, reports);",
          "new_line_content": "        limex->exReportOffset = exceptionReportsOffset;",
          "content_same": false
        },
        {
          "line": 1771,
          "old_api": "buildRepeats",
          "new_api": null,
          "old_text": "buildRepeats(args, repeats, &repeats_full_state, &repeats_stream_state)",
          "new_text": null,
          "old_line_content": "        buildRepeats(args, repeats, &repeats_full_state, &repeats_stream_state);",
          "new_line_content": "        vector<pair<aligned_unique_ptr<NFARepeatInfo>, size_t>> repeats;",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": "size",
          "new_api": null,
          "old_text": "repeats.size()",
          "new_text": null,
          "old_line_content": "        for (size_t i = 0; i < repeats.size(); i++) {",
          "new_line_content": "        u32 repeats_stream_state = 0;",
          "content_same": false
        },
        {
          "line": 1778,
          "old_api": "findExceptionalTransitions",
          "new_api": null,
          "old_text": "findExceptionalTransitions(args, exceptional)",
          "new_text": null,
          "old_line_content": "        findExceptionalTransitions(args, exceptional);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1782,
          "old_api": "buildExceptionMap",
          "new_api": null,
          "old_text": "buildExceptionMap(args, exceptional, exceptionMap, exceptionReports)",
          "new_text": null,
          "old_line_content": "        buildExceptionMap(args, exceptional, exceptionMap, exceptionReports);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1784,
          "old_api": "size",
          "new_api": null,
          "old_text": "exceptionMap.size()",
          "new_text": null,
          "old_line_content": "        if (exceptionMap.size() > ~0U) {",
          "new_line_content": "        vector<ReportID> exceptionReports;",
          "content_same": false
        },
        {
          "line": 1792,
          "old_api": "buildReachMapping",
          "new_api": null,
          "old_text": "buildReachMapping(args, reach, reachMap)",
          "new_text": null,
          "old_line_content": "        buildReachMapping(args, reach, reachMap);",
          "new_line_content": "        // Build reach table and character mapping.",
          "content_same": false
        },
        {
          "line": 1796,
          "old_api": "buildTopMasks",
          "new_api": null,
          "old_text": "buildTopMasks(args, tops)",
          "new_text": null,
          "old_line_content": "        buildTopMasks(args, tops);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1802,
          "old_api": "buildAccepts",
          "new_api": null,
          "old_text": "buildAccepts(args, acceptMask, acceptEodMask, accepts, acceptsEod,\n                     squash)",
          "new_text": null,
          "old_line_content": "        buildAccepts(args, acceptMask, acceptEodMask, accepts, acceptsEod,",
          "new_line_content": "        NFAStateSet acceptMask, acceptEodMask;",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": "buildAccel",
          "new_api": null,
          "old_text": "buildAccel(args, accelMask, accelFriendsMask, accelAux, accelTable)",
          "new_text": null,
          "old_line_content": "        buildAccel(args, accelMask, accelFriendsMask, accelAux, accelTable);",
          "new_line_content": "        NFAStateSet accelMask, accelFriendsMask;",
          "content_same": false
        },
        {
          "line": 1818,
          "old_api": "size",
          "new_api": null,
          "old_text": "reach.size()",
          "new_text": null,
          "old_line_content": "        offset += sizeof(tableRow_t) * reach.size();",
          "new_line_content": "        u32 offset = sizeof(implNFA_t);",
          "content_same": false
        },
        {
          "line": 1826,
          "old_api": "alignof",
          "new_api": null,
          "old_text": "alignof(AccelAux)",
          "new_text": null,
          "old_line_content": "        offset = ROUNDUP_N(offset, alignof(AccelAux));",
          "new_line_content": "        const u32 accelTableOffset = offset;",
          "content_same": false
        },
        {
          "line": 1828,
          "old_api": "size",
          "new_api": null,
          "old_text": "accelAux.size()",
          "new_text": null,
          "old_line_content": "        offset += sizeof(AccelAux) * accelAux.size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": "alignof",
          "new_api": null,
          "old_text": "alignof(NFAAccept)",
          "new_text": null,
          "old_line_content": "        offset = ROUNDUP_N(offset, alignof(NFAAccept));",
          "new_line_content": "        const u32 accelAuxOffset = offset;",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": "size",
          "new_api": null,
          "old_text": "accepts.size()",
          "new_text": null,
          "old_line_content": "        offset += sizeof(NFAAccept) * accepts.size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": "size",
          "new_api": null,
          "old_text": "acceptsEod.size()",
          "new_text": null,
          "old_line_content": "        offset += sizeof(NFAAccept) * acceptsEod.size();",
          "new_line_content": "        const u32 acceptsOffset = offset;",
          "content_same": false
        },
        {
          "line": 1836,
          "old_api": "ROUNDUP_CL",
          "new_api": null,
          "old_text": "ROUNDUP_CL(offset)",
          "new_text": null,
          "old_line_content": "        offset = ROUNDUP_CL(offset);",
          "new_line_content": "        const u32 acceptsEodOffset = offset;",
          "content_same": false
        },
        {
          "line": 1838,
          "old_api": "size",
          "new_api": null,
          "old_text": "squash.size()",
          "new_text": null,
          "old_line_content": "        offset += sizeof(tableRow_t) * squash.size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": "ROUNDUP_CL",
          "new_api": null,
          "old_text": "ROUNDUP_CL(offset)",
          "new_text": null,
          "old_line_content": "        offset = ROUNDUP_CL(offset);",
          "new_line_content": "        const u32 squashOffset = offset;",
          "content_same": false
        },
        {
          "line": 1842,
          "old_api": "size",
          "new_api": null,
          "old_text": "exceptionMap.size()",
          "new_text": null,
          "old_line_content": "        offset += sizeof(exception_t) * exceptionMap.size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1850,
          "old_api": "ROUNDUP_CL",
          "new_api": null,
          "old_text": "ROUNDUP_CL(offset)",
          "new_text": null,
          "old_line_content": "        offset = ROUNDUP_CL(offset);",
          "new_line_content": "        const u32 repeatOffsetsOffset = offset;",
          "content_same": false
        },
        {
          "line": 1857,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"nfa size %zu\\n\", nfaSize)",
          "new_text": null,
          "old_line_content": "        DEBUG_PRINTF(\"nfa size %zu\\n\", nfaSize);",
          "new_line_content": "        // Now we can allocate space for the NFA and get to work on layout.",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": "aligned_zmalloc_unique<NFA>(nfaSize)",
          "new_api": null,
          "old_text": "aligned_zmalloc_unique<NFA>(nfaSize)",
          "new_text": null,
          "old_line_content": "        auto nfa = aligned_zmalloc_unique<NFA>(nfaSize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1859,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(nfa)",
          "new_text": null,
          "old_line_content": "        assert(nfa); // otherwise we would have thrown std::bad_alloc",
          "new_line_content": "        size_t nfaSize = sizeof(NFA) + offset;",
          "content_same": false
        },
        {
          "line": 1866,
          "old_api": "writeTopMasks",
          "new_api": null,
          "old_text": "writeTopMasks(tops, limex, topsOffset)",
          "new_text": null,
          "old_line_content": "        writeTopMasks(tops, limex, topsOffset);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1868,
          "old_api": "writeAccel",
          "new_api": null,
          "old_text": "writeAccel(accelMask, accelFriendsMask, accelAux, accelTable,\n                   limex, accelTableOffset, accelAuxOffset)",
          "new_text": null,
          "old_line_content": "        writeAccel(accelMask, accelFriendsMask, accelAux, accelTable,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1879,
          "old_api": "writeExceptionReports",
          "new_api": null,
          "old_text": "writeExceptionReports(exceptionReports, limex, exceptionReportsOffset)",
          "new_text": null,
          "old_line_content": "        writeExceptionReports(exceptionReports, limex, exceptionReportsOffset);",
          "new_line_content": "        // Determine the state required for our state vector.",
          "content_same": false
        },
        {
          "line": 1883,
          "old_api": "writeRepeats",
          "new_api": null,
          "old_text": "writeRepeats(repeats, repeatOffsets, limex, repeatOffsetsOffset,\n                     repeatsOffset)",
          "new_text": null,
          "old_line_content": "        writeRepeats(repeats, repeatOffsets, limex, repeatOffsetsOffset,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1888,
          "old_api": "writeLimexMasks",
          "new_api": null,
          "old_text": "writeLimexMasks(args, limex)",
          "new_text": null,
          "old_line_content": "        writeLimexMasks(args, limex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": "get",
          "new_api": null,
          "old_text": "nfa.get()",
          "new_text": null,
          "old_line_content": "        allocState(nfa.get(), repeats_full_state, repeats_stream_state);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1897,
          "old_api": "get",
          "new_api": null,
          "old_text": "nfa.get()",
          "new_text": null,
          "old_line_content": "            setNfaFlag(nfa.get(), NFA_ZOMBIE);",
          "new_line_content": "        nfa->nPositions = args.num_states;",
          "content_same": false
        },
        {
          "line": 1912,
          "old_api": "findContainerSize",
          "new_api": null,
          "old_text": "findContainerSize(num_states)",
          "new_text": null,
          "old_line_content": "        size_t sz = findContainerSize(num_states);",
          "new_line_content": "        // LimEx NFAs are available in sizes from 32 to 512-bit.",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": "edges_range",
          "new_api": null,
          "old_text": "edges_range(h)",
          "new_text": null,
          "old_line_content": "        for (const auto &e : edges_range(h)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1948,
          "old_api": "source",
          "new_api": null,
          "old_text": "source(e, h)",
          "new_text": null,
          "old_line_content": "            u32 from = args.state_ids.at(source(e, h));",
          "new_line_content": "        NFAStateSet exceptionalStates(num_states); // outbound exc trans",
          "content_same": false
        },
        {
          "line": 1949,
          "old_api": "target",
          "new_api": null,
          "old_text": "target(e, h)",
          "new_text": null,
          "old_line_content": "            u32 to = args.state_ids.at(target(e, h));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1954,
          "old_api": "isExceptionalTransition",
          "new_api": null,
          "old_text": "isExceptionalTransition(h, e, args.state_ids, args.tugs)",
          "new_text": null,
          "old_line_content": "            if (isExceptionalTransition(h, e, args.state_ids, args.tugs)) {",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 1955,
          "old_api": "set",
          "new_api": null,
          "old_text": "exceptionalStates.set(from)",
          "new_text": null,
          "old_line_content": "                exceptionalStates.set(from);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1959,
          "old_api": "count",
          "new_api": null,
          "old_text": "exceptionalStates.count()",
          "new_text": null,
          "old_line_content": "        score -= EXCEPTION_COST * exceptionalStates.count();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1974,
          "old_api": "Factory<dtype>::generateNfa(args)",
          "new_api": null,
          "old_text": "Factory<dtype>::generateNfa(args)",
          "new_text": null,
          "old_line_content": "        return Factory<dtype>::generateNfa(args);",
          "new_line_content": "template<NFAEngineType dtype>",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": "Factory<dtype>::score(args)",
          "new_api": null,
          "old_text": "Factory<dtype>::score(args)",
          "new_text": null,
          "old_line_content": "        return Factory<dtype>::score(args);",
          "new_line_content": "template<NFAEngineType dtype>",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": "MAKE_LIMEX_TRAITS",
          "new_api": null,
          "old_text": "MAKE_LIMEX_TRAITS(32, 1)",
          "new_text": null,
          "old_line_content": "MAKE_LIMEX_TRAITS(32, 1)",
          "new_line_content": "        static const u32 maxShift = mlt_shift;                          \\",
          "content_same": false
        },
        {
          "line": 1995,
          "old_api": "MAKE_LIMEX_TRAITS",
          "new_api": null,
          "old_text": "MAKE_LIMEX_TRAITS(32, 2)",
          "new_text": null,
          "old_line_content": "MAKE_LIMEX_TRAITS(32, 2)",
          "new_line_content": "    };                                                                  \\",
          "content_same": false
        },
        {
          "line": 1996,
          "old_api": "MAKE_LIMEX_TRAITS",
          "new_api": null,
          "old_text": "MAKE_LIMEX_TRAITS(32, 3)",
          "new_text": null,
          "old_line_content": "MAKE_LIMEX_TRAITS(32, 3)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2041,
          "old_api": "insert",
          "new_api": null,
          "old_text": "top_starts.insert(m.second)",
          "new_text": null,
          "old_line_content": "        top_starts.insert(m.second);",
          "new_line_content": "    ue2::unordered_set<u32> seen;",
          "content_same": false
        },
        {
          "line": 2045,
          "old_api": "contains",
          "new_api": null,
          "old_text": "contains(state_ids, v)",
          "new_text": null,
          "old_line_content": "        if (!contains(state_ids, v)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": "DEBUG_PRINTF",
          "new_api": null,
          "old_text": "DEBUG_PRINTF(\"no entry for vertex %u in state map\\n\",\n                         h[v].index)",
          "new_text": null,
          "old_line_content": "            DEBUG_PRINTF(\"no entry for vertex %u in state map\\n\",",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 98,
      "total_additions": 309,
      "total_deletions": 309,
      "total_api_changes": 716
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 716,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          2,
          675,
          670
        ]
      }
    },
    "api_calls_before": 737,
    "api_calls_after": 737,
    "diff_info": {
      "added_lines": 5,
      "removed_lines": 2,
      "total_diff_lines": 32
    }
  }
}