{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/xgboost/modified_file/5c8ccf4455e3eef3f863573958853bd6240800bd",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/xgboost/modified_file/5c8ccf4455e3eef3f863573958853bd6240800bd/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/xgboost/modified_file/5c8ccf4455e3eef3f863573958853bd6240800bd/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/xgboost/modified_file/5c8ccf4455e3eef3f863573958853bd6240800bd/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 741,
          "old_api": "Info",
          "new_api": "Start",
          "old_text": "fmat.Info()",
          "new_text": "builder_monitor_.Start(\"InitData\")",
          "old_line_content": "  const auto& info = fmat.Info();",
          "new_line_content": "  builder_monitor_.Start(\"InitData\");",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": "Init",
          "new_api": "Ptrs",
          "old_text": "hist_.Init(nbins)",
          "new_text": "gmat.cut.Ptrs().back()",
          "old_line_content": "    hist_.Init(nbins);",
          "new_line_content": "    uint32_t nbins = gmat.cut.Ptrs().back();",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "resize",
          "new_api": "Data",
          "old_text": "row_indices.resize(info.num_row_)",
          "new_text": "row_set_collection_.Data()",
          "old_line_content": "    row_indices.resize(info.num_row_);",
          "new_line_content": "    std::vector<size_t>& row_indices = *row_set_collection_.Data();",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": "data",
          "new_api": "resize",
          "old_text": "row_indices.data()",
          "new_text": "row_indices.resize(info.num_row_)",
          "old_line_content": "    size_t* p_row_indices = row_indices.data();",
          "new_line_content": "    row_indices.resize(info.num_row_);",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": "std::fill(p_buff, p_buff + this->nthread_, false)",
          "new_api": "Get",
          "old_text": "std::fill(p_buff, p_buff + this->nthread_, false)",
          "new_text": "buff.Get()",
          "old_line_content": "      std::fill(p_buff, p_buff + this->nthread_, false);",
          "new_line_content": "      bool* p_buff = buff.Get();",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": "static_cast<size_t>(info.num_row_)",
          "new_api": "static_cast<size_t>(ibegin + block_size)",
          "old_text": "static_cast<size_t>(info.num_row_)",
          "new_text": "static_cast<size_t>(ibegin + block_size)",
          "old_line_content": "            static_cast<size_t>(info.num_row_));",
          "new_line_content": "        const size_t iend = std::min(static_cast<size_t>(ibegin + block_size),",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": "static_cast<size_t>(info.num_row_)",
          "new_api": "static_cast<size_t>(ibegin + block_size)",
          "old_text": "static_cast<size_t>(info.num_row_)",
          "new_text": "static_cast<size_t>(ibegin + block_size)",
          "old_line_content": "              static_cast<size_t>(info.num_row_));",
          "new_line_content": "          const size_t iend = std::min(static_cast<size_t>(ibegin + block_size),",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": "size",
          "new_api": "Ptrs",
          "old_text": "row_ptr.size()",
          "new_text": "gmat.cut.Ptrs()",
          "old_line_content": "    const auto nfeature = static_cast<bst_uint>(row_ptr.size() - 1);",
          "new_line_content": "    const std::vector<uint32_t>& row_ptr = gmat.cut.Ptrs();",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "clear",
          "new_api": "reserve",
          "old_text": "snode_.clear()",
          "new_text": "snode_.reserve(256)",
          "old_line_content": "    snode_.clear();",
          "new_line_content": "    snode_.reserve(256);",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": "std::max(1, this->nthread_)",
          "new_api": "size",
          "old_text": "std::max(1, this->nthread_)",
          "new_text": "nodes_set.size()",
          "old_line_content": "  const size_t nthread = std::max(1, this->nthread_);",
          "new_line_content": "  const size_t n_nodes_in_set = nodes_set.size();",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": "ConstHostVector",
          "new_api": "end",
          "old_text": "features_sets[nid_in_set]->ConstHostVector()",
          "new_text": "r.end()",
          "old_line_content": "      const auto fid = features_sets[nid_in_set]->ConstHostVector()[idx_in_feature_set];",
          "new_line_content": "    for (auto idx_in_feature_set = r.begin(); idx_in_feature_set < r.end(); ++idx_in_feature_set) {",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "Query",
          "new_api": "ConstHostVector",
          "old_text": "interaction_constraints_.Query(nid, fid)",
          "new_text": "features_sets[nid_in_set]->ConstHostVector()",
          "old_line_content": "      if (interaction_constraints_.Query(nid, fid)) {",
          "new_line_content": "      const auto fid = features_sets[nid_in_set]->ConstHostVector()[idx_in_feature_set];",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": "this->EnumerateSplit<+1>(\n            gmat, node_hist, snode_[nid],\n            &best_split_tloc_[nthread * nid_in_set + tid], fid, nid, evaluator)",
          "new_api": "Query",
          "old_text": "this->EnumerateSplit<+1>(\n            gmat, node_hist, snode_[nid],\n            &best_split_tloc_[nthread * nid_in_set + tid], fid, nid, evaluator)",
          "new_text": "interaction_constraints_.Query(nid, fid)",
          "old_line_content": "        auto grad_stats = this->EnumerateSplit<+1>(",
          "new_line_content": "      if (interaction_constraints_.Query(nid, fid)) {",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": "this->EnumerateSplit<-1>(\n              gmat, node_hist, snode_[nid],\n              &best_split_tloc_[nthread * nid_in_set + tid], fid, nid,\n              evaluator)",
          "new_api": "SplitContainsMissingValues",
          "old_text": "this->EnumerateSplit<-1>(\n              gmat, node_hist, snode_[nid],\n              &best_split_tloc_[nthread * nid_in_set + tid], fid, nid,\n              evaluator)",
          "new_text": "SplitContainsMissingValues(grad_stats, snode_[nid])",
          "old_line_content": "          this->EnumerateSplit<-1>(",
          "new_line_content": "        if (SplitContainsMissingValues(grad_stats, snode_[nid])) {",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "GetFeatureBinIdxPtr",
          "new_api": "GetBaseIdx",
          "old_text": "column.GetFeatureBinIdxPtr().data()",
          "new_text": "column.GetBaseIdx()",
          "old_line_content": "  const BinIdxType* idx = column.GetFeatureBinIdxPtr().data();",
          "new_line_content": "  const int32_t offset = column.GetBaseIdx();",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": "data",
          "new_api": "GetFeatureBinIdxPtr",
          "old_text": "left_part.data()",
          "new_text": "column.GetFeatureBinIdxPtr().data()",
          "old_line_content": "  size_t* p_left_part = left_part.data();",
          "new_line_content": "  const BinIdxType* idx = column.GetFeatureBinIdxPtr().data();",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": "Size",
          "new_api": "GetRowData",
          "old_text": "column.Size()",
          "new_text": "column.GetRowData()",
          "old_line_content": "  const size_t column_size = column.Size();",
          "new_line_content": "  const size_t* row_data = column.GetRowData();",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": "size",
          "new_api": "Size",
          "old_text": "rid_span.size()",
          "new_text": "column.Size()",
          "old_line_content": "  if (rid_span.size()) {  // ensure that rid_span is nonempty range",
          "new_line_content": "  const size_t column_size = column.Size();",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "back",
          "new_api": "GetRowIdx",
          "old_text": "rid_span.back()",
          "new_text": "column.GetRowIdx(cursor)",
          "old_line_content": "               && column.GetRowIdx(cursor) <= rid_span.back()) {",
          "new_line_content": "               && column.GetRowIdx(cursor) < rid",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": "GetGlobalBinIdx",
          "new_api": "GetRowIdx",
          "old_text": "column.GetGlobalBinIdx(cursor)",
          "new_text": "column.GetRowIdx(cursor)",
          "old_line_content": "          if (static_cast<int32_t>(column.GetGlobalBinIdx(cursor)) <= split_cond) {",
          "new_line_content": "        if (cursor < column_size && column.GetRowIdx(cursor) == rid) {",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": "size",
          "new_api": "end",
          "old_text": "rid_span.size()",
          "new_text": "rid_span.end()",
          "old_line_content": "        nleft_elems = rid_span.size();",
          "new_line_content": "        std::copy(rid_span.begin(), rid_span.end(), p_left_part);",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "size",
          "new_api": "end",
          "old_text": "rid_span.size()",
          "new_text": "rid_span.end()",
          "old_line_content": "        nright_elems = rid_span.size();",
          "new_line_content": "        std::copy(rid_span.begin(), rid_span.end(), p_right_part);",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": "GetLeftBuffer",
          "new_api": "end",
          "old_text": "partition_builder_.GetLeftBuffer(node_in_set,\n                                                                range.begin(), range.end())",
          "new_text": "range.end()",
          "old_line_content": "  common::Span<size_t> left  = partition_builder_.GetLeftBuffer(node_in_set,",
          "new_line_content": "  common::Span<const size_t> rid_span(rid + range.begin(), rid + range.end());",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "end",
          "new_api": "GetLeftBuffer",
          "old_text": "range.end()",
          "new_text": "partition_builder_.GetLeftBuffer(node_in_set,\n                                                                range.begin(), range.end())",
          "old_line_content": "                                                                range.begin(), range.end());",
          "new_line_content": "  common::Span<size_t> left  = partition_builder_.GetLeftBuffer(node_in_set,",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "GetRightBuffer",
          "new_api": "end",
          "old_text": "partition_builder_.GetRightBuffer(node_in_set,\n                                                                 range.begin(), range.end())",
          "new_text": "range.end()",
          "old_line_content": "  common::Span<size_t> right = partition_builder_.GetRightBuffer(node_in_set,",
          "new_line_content": "                                                                range.begin(), range.end());",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "end",
          "new_api": "GetRightBuffer",
          "old_text": "range.end()",
          "new_text": "partition_builder_.GetRightBuffer(node_in_set,\n                                                                 range.begin(), range.end())",
          "old_line_content": "                                                                 range.begin(), range.end());",
          "new_line_content": "  common::Span<size_t> right = partition_builder_.GetRightBuffer(node_in_set,",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": "SplitIndex",
          "new_api": "end",
          "old_text": "tree[nid].SplitIndex()",
          "new_text": "range.end()",
          "old_line_content": "  const bst_uint fid = tree[nid].SplitIndex();",
          "new_line_content": "                                                                 range.begin(), range.end());",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": "DefaultLeft",
          "new_api": "SplitIndex",
          "old_text": "tree[nid].DefaultLeft()",
          "new_text": "tree[nid].SplitIndex()",
          "old_line_content": "  const bool default_left = tree[nid].DefaultLeft();",
          "new_line_content": "  const bst_uint fid = tree[nid].SplitIndex();",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": "column_matrix.GetColumn<BinIdxType>(fid)",
          "new_api": "DefaultLeft",
          "old_text": "column_matrix.GetColumn<BinIdxType>(fid)",
          "new_text": "tree[nid].DefaultLeft()",
          "old_line_content": "  const auto column_ptr = column_matrix.GetColumn<BinIdxType>(fid);",
          "new_line_content": "  const bool default_left = tree[nid].DefaultLeft();",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": "PartitionDenseKernel<true, true>(column, rid_span, split_cond,\n                                                             left, right)",
          "new_api": "AnyMissing",
          "old_text": "PartitionDenseKernel<true, true>(column, rid_span, split_cond,\n                                                             left, right)",
          "new_text": "column_matrix.AnyMissing()",
          "old_line_content": "        child_nodes_sizes = PartitionDenseKernel<true, true>(column, rid_span, split_cond,",
          "new_line_content": "      if (column_matrix.AnyMissing()) {",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": "PartitionDenseKernel<false, true>(column, rid_span, split_cond,\n                                                              left, right)",
          "new_api": "AnyMissing",
          "old_text": "PartitionDenseKernel<false, true>(column, rid_span, split_cond,\n                                                              left, right)",
          "new_text": "column_matrix.AnyMissing()",
          "old_line_content": "        child_nodes_sizes = PartitionDenseKernel<false, true>(column, rid_span, split_cond,",
          "new_line_content": "      if (column_matrix.AnyMissing()) {",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": "resize",
          "new_api": "size",
          "old_text": "split_conditions->resize(n_nodes)",
          "new_text": "nodes.size()",
          "old_line_content": "  split_conditions->resize(n_nodes);",
          "new_line_content": "  const size_t n_nodes = nodes.size();",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": "SplitCond",
          "new_api": "SplitIndex",
          "old_text": "tree[nid].SplitCond()",
          "new_text": "tree[nid].SplitIndex()",
          "old_line_content": "    const bst_float split_pt = tree[nid].SplitCond();",
          "new_line_content": "    const bst_uint fid = tree[nid].SplitIndex();",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": "Ptrs",
          "new_api": "SplitCond",
          "old_text": "gmat.cut.Ptrs()",
          "new_text": "tree[nid].SplitCond()",
          "old_line_content": "    const uint32_t lower_bound = gmat.cut.Ptrs()[fid];",
          "new_line_content": "    const bst_float split_pt = tree[nid].SplitCond();",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": "std::numeric_limits<int32_t>::max()",
          "new_api": "CHECK_LT",
          "old_text": "std::numeric_limits<int32_t>::max()",
          "new_text": "CHECK_LT(upper_bound,\n             static_cast<uint32_t>(std::numeric_limits<int32_t>::max()))",
          "old_line_content": "             static_cast<uint32_t>(std::numeric_limits<int32_t>::max()));",
          "new_line_content": "    CHECK_LT(upper_bound,",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": "static_cast<int32_t>(bound)",
          "new_api": "Values",
          "old_text": "static_cast<int32_t>(bound)",
          "new_text": "gmat.cut.Values()",
          "old_line_content": "        split_cond = static_cast<int32_t>(bound);",
          "new_line_content": "      if (split_pt == gmat.cut.Values()[bound]) {",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": "GetNRightElems",
          "new_api": "GetNLeftElems",
          "old_text": "partition_builder_.GetNRightElems(i)",
          "new_text": "partition_builder_.GetNLeftElems(i)",
          "old_line_content": "    const size_t n_right = partition_builder_.GetNRightElems(i);",
          "new_line_content": "    const size_t n_left = partition_builder_.GetNLeftElems(i);",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": "RightChild",
          "new_api": "GetNRightElems",
          "old_text": "*p_tree)[nid].RightChild()",
          "new_text": "partition_builder_.GetNRightElems(i)",
          "old_line_content": "    CHECK_EQ((*p_tree)[nid].LeftChild() + 1, (*p_tree)[nid].RightChild());",
          "new_line_content": "    const size_t n_right = partition_builder_.GetNRightElems(i);",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "LeftChild",
          "new_api": "RightChild",
          "old_text": "*p_tree)[nid].LeftChild()",
          "new_text": "*p_tree)[nid].RightChild()",
          "old_line_content": "    row_set_collection_.AddSplit(nid, (*p_tree)[nid].LeftChild(),",
          "new_line_content": "    CHECK_EQ((*p_tree)[nid].LeftChild() + 1, (*p_tree)[nid].RightChild());",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": "RightChild",
          "new_api": "LeftChild",
          "old_text": "*p_tree)[nid].RightChild()",
          "new_text": "*p_tree)[nid].LeftChild()",
          "old_line_content": "        (*p_tree)[nid].RightChild(), n_left, n_right);",
          "new_line_content": "    row_set_collection_.AddSplit(nid, (*p_tree)[nid].LeftChild(),",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": "AllocateForTask",
          "new_api": "GetTaskIdx",
          "old_text": "partition_builder_.AllocateForTask(task_id)",
          "new_text": "partition_builder_.GetTaskIdx(node_in_set, begin)",
          "old_line_content": "    partition_builder_.AllocateForTask(task_id);",
          "new_line_content": "    const size_t task_id = partition_builder_.GetTaskIdx(node_in_set, begin);",
          "content_same": false
        },
        {
          "line": 1200,
          "old_api": "GetTypeSize",
          "new_api": "AllocateForTask",
          "old_text": "column_matrix.GetTypeSize()",
          "new_text": "partition_builder_.AllocateForTask(task_id)",
          "old_line_content": "      switch (column_matrix.GetTypeSize()) {",
          "new_line_content": "    partition_builder_.AllocateForTask(task_id);",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": "const_cast<size_t*>(row_set_collection_[nid].begin)",
          "new_api": "begin",
          "old_text": "const_cast<size_t*>(row_set_collection_[nid].begin)",
          "new_text": "r.begin()",
          "old_line_content": "        const_cast<size_t*>(row_set_collection_[nid].begin));",
          "new_line_content": "    partition_builder_.MergeToArray(node_in_set, r.begin(),",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": "Stop",
          "new_api": "AddSplitsToRowSet",
          "old_text": "builder_monitor_.Stop(\"ApplySplit\")",
          "new_text": "AddSplitsToRowSet(nodes, p_tree)",
          "old_line_content": "  builder_monitor_.Stop(\"ApplySplit\");",
          "new_line_content": "  AddSplitsToRowSet(nodes, p_tree);",
          "content_same": false
        },
        {
          "line": 1264,
          "old_api": "GetHess",
          "new_api": "Allreduce",
          "old_text": "grad_stat.GetHess()",
          "new_text": "histred_.Allreduce(&grad_stat, 1)",
          "old_line_content": "      snode_[nid].stats = tree::GradStats(grad_stat.GetGrad(), grad_stat.GetHess());",
          "new_line_content": "      histred_.Allreduce(&grad_stat, 1);",
          "content_same": false
        },
        {
          "line": 1267,
          "old_api": "IsLeftChild",
          "new_api": "Parent",
          "old_text": "tree[nid].IsLeftChild()",
          "new_text": "tree[nid].Parent()",
          "old_line_content": "      if (tree[nid].IsLeftChild()) {",
          "new_line_content": "      int parent_id = tree[nid].Parent();",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": "Parent",
          "new_api": "GetEvaluator",
          "old_text": "tree[nid].Parent()",
          "new_text": "tree_evaluator_.GetEvaluator()",
          "old_line_content": "    bst_uint parentid = tree[nid].Parent();",
          "new_line_content": "    auto evaluator = tree_evaluator_.GetEvaluator();",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": "CalcWeight",
          "new_api": "Parent",
          "old_text": "static_cast<float>(\n        evaluator.CalcWeight(parentid, param_, GradStats{snode_[nid].stats}))",
          "new_text": "tree[nid].Parent()",
          "old_line_content": "    snode_[nid].weight = static_cast<float>(",
          "new_line_content": "    bst_uint parentid = tree[nid].Parent();",
          "content_same": false
        },
        {
          "line": 1281,
          "old_api": "CalcGain",
          "new_api": "CalcWeight",
          "old_text": "static_cast<float>(\n        evaluator.CalcGain(parentid, param_, GradStats{snode_[nid].stats}))",
          "new_text": "evaluator.CalcWeight(parentid, param_, GradStats{snode_[nid].stats})",
          "old_line_content": "    snode_[nid].root_gain = static_cast<float>(",
          "new_line_content": "        evaluator.CalcWeight(parentid, param_, GradStats{snode_[nid].stats}));",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": "Values",
          "new_api": "Ptrs",
          "old_text": "gmat.cut.Values()",
          "new_text": "gmat.cut.Ptrs()",
          "old_line_content": "  const std::vector<bst_float>& cut_val = gmat.cut.Values();",
          "new_line_content": "  const std::vector<uint32_t>& cut_ptr = gmat.cut.Ptrs();",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": "std::numeric_limits<int32_t>::max()",
          "new_api": "CHECK_LE",
          "old_text": "std::numeric_limits<int32_t>::max()",
          "new_text": "CHECK_LE(cut_ptr[fid],\n           static_cast<uint32_t>(std::numeric_limits<int32_t>::max()))",
          "old_line_content": "           static_cast<uint32_t>(std::numeric_limits<int32_t>::max()));",
          "new_line_content": "  CHECK_LE(cut_ptr[fid],",
          "content_same": false
        },
        {
          "line": 1311,
          "old_api": "CHECK_LE",
          "new_api": "std::numeric_limits<int32_t>::max()",
          "old_text": "CHECK_LE(cut_ptr[fid + 1],\n           static_cast<uint32_t>(std::numeric_limits<int32_t>::max()))",
          "new_text": "std::numeric_limits<int32_t>::max()",
          "old_line_content": "  CHECK_LE(cut_ptr[fid + 1],",
          "new_line_content": "           static_cast<uint32_t>(std::numeric_limits<int32_t>::max()));",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": "std::numeric_limits<int32_t>::max()",
          "new_api": "CHECK_LE",
          "old_text": "std::numeric_limits<int32_t>::max()",
          "new_text": "CHECK_LE(cut_ptr[fid + 1],\n           static_cast<uint32_t>(std::numeric_limits<int32_t>::max()))",
          "old_line_content": "           static_cast<uint32_t>(std::numeric_limits<int32_t>::max()));",
          "new_line_content": "  CHECK_LE(cut_ptr[fid + 1],",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": "static_cast<int32_t>(cut_ptr[fid + 1])",
          "new_api": "static_cast<int32_t>(cut_ptr[fid])",
          "old_text": "static_cast<int32_t>(cut_ptr[fid + 1])",
          "new_text": "static_cast<int32_t>(cut_ptr[fid])",
          "old_line_content": "    iend = static_cast<int32_t>(cut_ptr[fid + 1]);",
          "new_line_content": "    ibegin = static_cast<int32_t>(cut_ptr[fid]);",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": "static_cast<int32_t>(cut_ptr[fid])",
          "new_api": "static_cast<int32_t>(cut_ptr[fid + 1])",
          "old_text": "static_cast<int32_t>(cut_ptr[fid])",
          "new_text": "static_cast<int32_t>(cut_ptr[fid + 1])",
          "old_line_content": "    iend = static_cast<int32_t>(cut_ptr[fid]) - 1;",
          "new_line_content": "    ibegin = static_cast<int32_t>(cut_ptr[fid + 1]) - 1;",
          "content_same": false
        },
        {
          "line": 1332,
          "old_api": "SetSubstract",
          "new_api": "GetHess",
          "old_text": "c.SetSubstract(snode.stats, e)",
          "new_text": "e.GetHess()",
          "old_line_content": "      c.SetSubstract(snode.stats, e);",
          "new_line_content": "    if (e.GetHess() >= param_.min_child_weight) {",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": "GetHess",
          "new_api": "SetSubstract",
          "old_text": "c.GetHess()",
          "new_text": "c.SetSubstract(snode.stats, e)",
          "old_line_content": "      if (c.GetHess() >= param_.min_child_weight) {",
          "new_line_content": "      c.SetSubstract(snode.stats, e);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1028,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "rid_span.size()",
          "old_line_content": "    // search first nonzero row with index >= rid_span.front()",
          "new_line_content": "  if (rid_span.size()) {  // ensure that rid_span is nonempty range",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "rid_span.front()",
          "old_line_content": "",
          "new_line_content": "                                       rid_span.front());",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "rid_span.back()",
          "old_line_content": "      size_t cursor = p - row_data;",
          "new_line_content": "    if (p != row_data + column_size && *p <= rid_span.back()) {",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "rid_span.back()",
          "old_line_content": "          ++cursor;",
          "new_line_content": "               && column.GetRowIdx(cursor) <= rid_span.back()) {",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": null,
          "new_api": "GetGlobalBinIdx",
          "old_text": null,
          "new_text": "column.GetGlobalBinIdx(cursor)",
          "old_line_content": "            p_left_part[nleft_elems++] = rid;",
          "new_line_content": "          if (static_cast<int32_t>(column.GetGlobalBinIdx(cursor)) <= split_cond) {",
          "content_same": false
        },
        {
          "line": 1061,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "rid_span.size()",
          "old_line_content": "      } else {",
          "new_line_content": "        nleft_elems = rid_span.size();",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "rid_span.size()",
          "old_line_content": "      }",
          "new_line_content": "        nright_elems = rid_span.size();",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": null,
          "new_api": "column_matrix.GetColumn<BinIdxType>(fid)",
          "old_text": null,
          "new_text": "column_matrix.GetColumn<BinIdxType>(fid)",
          "old_line_content": "",
          "new_line_content": "  const auto column_ptr = column_matrix.GetColumn<BinIdxType>(fid);",
          "content_same": false
        },
        {
          "line": 1090,
          "old_api": null,
          "new_api": "GetType",
          "old_text": null,
          "new_text": "column_ptr->GetType()",
          "old_line_content": "    const common::DenseColumn<BinIdxType>& column =",
          "new_line_content": "  if (column_ptr->GetType() == xgboost::common::kDenseColumn) {",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "column_ptr.get()",
          "old_line_content": "    if (default_left) {",
          "new_line_content": "          static_cast<const common::DenseColumn<BinIdxType>& >(*(column_ptr.get()));",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": null,
          "new_api": "PartitionDenseKernel<true, true>(column, rid_span, split_cond,\n                                                             left, right)",
          "old_text": null,
          "new_text": "PartitionDenseKernel<true, true>(column, rid_span, split_cond,\n                                                             left, right)",
          "old_line_content": "                                                             left, right);",
          "new_line_content": "        child_nodes_sizes = PartitionDenseKernel<true, true>(column, rid_span, split_cond,",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": null,
          "new_api": "PartitionDenseKernel<true, false>(column, rid_span, split_cond,\n                                                              left, right)",
          "old_text": null,
          "new_text": "PartitionDenseKernel<true, false>(column, rid_span, split_cond,\n                                                              left, right)",
          "old_line_content": "                                                              left, right);",
          "new_line_content": "        child_nodes_sizes = PartitionDenseKernel<true, false>(column, rid_span, split_cond,",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": null,
          "new_api": "PartitionDenseKernel<false, true>(column, rid_span, split_cond,\n                                                              left, right)",
          "old_text": null,
          "new_text": "PartitionDenseKernel<false, true>(column, rid_span, split_cond,\n                                                              left, right)",
          "old_line_content": "                                                              left, right);",
          "new_line_content": "        child_nodes_sizes = PartitionDenseKernel<false, true>(column, rid_span, split_cond,",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": null,
          "new_api": "PartitionDenseKernel<false, false>(column, rid_span, split_cond,\n                                                               left, right)",
          "old_text": null,
          "new_text": "PartitionDenseKernel<false, false>(column, rid_span, split_cond,\n                                                               left, right)",
          "old_line_content": "                                                               left, right);",
          "new_line_content": "        child_nodes_sizes = PartitionDenseKernel<false, false>(column, rid_span, split_cond,",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "column_ptr.get()",
          "old_line_content": "    if (default_left) {",
          "new_line_content": "      = static_cast<const common::SparseColumn<BinIdxType>& >(*(column_ptr.get()));",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": null,
          "new_api": "PartitionSparseKernel<true>(rid_span, split_cond, column, left, right)",
          "old_text": null,
          "new_text": "PartitionSparseKernel<true>(rid_span, split_cond, column, left, right)",
          "old_line_content": "    } else {",
          "new_line_content": "      child_nodes_sizes = PartitionSparseKernel<true>(rid_span, split_cond, column, left, right);",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": null,
          "new_api": "PartitionSparseKernel<false>(rid_span, split_cond, column, left, right)",
          "old_text": null,
          "new_text": "PartitionSparseKernel<false>(rid_span, split_cond, column, left, right)",
          "old_line_content": "    }",
          "new_line_content": "      child_nodes_sizes = PartitionSparseKernel<false>(rid_span, split_cond, column, left, right);",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "range.end()",
          "old_line_content": "}",
          "new_line_content": "  partition_builder_.SetNRightElems(node_in_set, range.begin(), range.end(), n_right);",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "split_conditions->resize(n_nodes)",
          "old_line_content": "",
          "new_line_content": "  split_conditions->resize(n_nodes);",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "nodes.size()",
          "old_line_content": "    const int32_t nid = nodes[i].nid;",
          "new_line_content": "  for (size_t i = 0; i < nodes.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": null,
          "new_api": "Ptrs",
          "old_text": null,
          "new_text": "gmat.cut.Ptrs()",
          "old_line_content": "    int32_t split_cond = -1;",
          "new_line_content": "    const uint32_t upper_bound = gmat.cut.Ptrs()[fid + 1];",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": null,
          "new_api": "std::numeric_limits<int32_t>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<int32_t>::max()",
          "old_line_content": "    for (uint32_t bound = lower_bound; bound < upper_bound; ++bound) {",
          "new_line_content": "             static_cast<uint32_t>(std::numeric_limits<int32_t>::max()));",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": null,
          "new_api": "static_cast<int32_t>(bound)",
          "old_text": null,
          "new_text": "static_cast<int32_t>(bound)",
          "old_line_content": "      }",
          "new_line_content": "        split_cond = static_cast<int32_t>(bound);",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "nodes.size()",
          "old_line_content": "  for (unsigned int i = 0; i < n_nodes; ++i) {",
          "new_line_content": "  const size_t n_nodes = nodes.size();",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": null,
          "new_api": "RightChild",
          "old_text": null,
          "new_text": "*p_tree)[nid].RightChild()",
          "old_line_content": "  }",
          "new_line_content": "        (*p_tree)[nid].RightChild(), n_left, n_right);",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "builder_monitor_.Start(\"ApplySplit\")",
          "old_line_content": "  // 1. Find split condition for each split",
          "new_line_content": "  builder_monitor_.Start(\"ApplySplit\");",
          "content_same": false
        },
        {
          "line": 1178,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "nodes.size()",
          "old_line_content": "  std::vector<int32_t> split_conditions;",
          "new_line_content": "  const size_t n_nodes = nodes.size();",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": null,
          "new_api": "FindSplitConditions",
          "old_text": null,
          "new_text": "FindSplitConditions(nodes, *p_tree, gmat, &split_conditions)",
          "old_line_content": "  // 2.1 Create a blocked space of size SUM(samples in each node)",
          "new_line_content": "  FindSplitConditions(nodes, *p_tree, gmat, &split_conditions);",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "row_set_collection_[nid].Size()",
          "old_line_content": "  }, kPartitionBlockSize);",
          "new_line_content": "    return row_set_collection_[nid].Size();",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "space.Size()",
          "old_line_content": "    const int32_t nid = nodes[node_in_set].nid;",
          "new_line_content": "  partition_builder_.Init(space.Size(), n_nodes, [&](size_t node_in_set) {",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "row_set_collection_[nid].Size()",
          "old_line_content": "    const size_t n_tasks = size / kPartitionBlockSize + !!(size % kPartitionBlockSize);",
          "new_line_content": "    const size_t size = row_set_collection_[nid].Size();",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "r.begin()",
          "old_line_content": "    const int32_t nid = nodes[node_in_set].nid;",
          "new_line_content": "    size_t begin = r.begin();",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": null,
          "new_api": "GetTypeSize",
          "old_text": null,
          "new_text": "column_matrix.GetTypeSize()",
          "old_line_content": "      case common::kUint8BinsTypeSize:",
          "new_line_content": "      switch (column_matrix.GetTypeSize()) {",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": null,
          "new_api": "PartitionKernel<uint8_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree)",
          "old_text": null,
          "new_text": "PartitionKernel<uint8_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree)",
          "old_line_content": "                  split_conditions[node_in_set], column_matrix, *p_tree);",
          "new_line_content": "        PartitionKernel<uint8_t>(node_in_set, nid, r,",
          "content_same": false
        },
        {
          "line": 1207,
          "old_api": null,
          "new_api": "PartitionKernel<uint16_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree)",
          "old_text": null,
          "new_text": "PartitionKernel<uint16_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree)",
          "old_line_content": "                  split_conditions[node_in_set], column_matrix, *p_tree);",
          "new_line_content": "        PartitionKernel<uint16_t>(node_in_set, nid, r,",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": null,
          "new_api": "std::numeric_limits<uint32_t>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<uint32_t>::max()",
          "old_line_content": "  #pragma omp parallel num_threads(nthread)",
          "new_line_content": "  auto upper_border = static_cast<float>(std::numeric_limits<uint32_t>::max());",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": null,
          "new_api": "static_cast<uint32_t>(upper_border * param_.subsample)",
          "old_text": null,
          "new_text": "static_cast<uint32_t>(upper_border * param_.subsample)",
          "old_line_content": "  {",
          "new_line_content": "  uint32_t coin_flip_border = static_cast<uint32_t>(upper_border * param_.subsample);",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": null,
          "new_api": "PartitionKernel<uint32_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree)",
          "old_text": null,
          "new_text": "PartitionKernel<uint32_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree)",
          "old_line_content": "                  split_conditions[node_in_set], column_matrix, *p_tree);",
          "new_line_content": "        PartitionKernel<uint32_t>(node_in_set, nid, r,",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": null,
          "new_api": "omp_get_thread_num",
          "old_text": null,
          "new_text": "omp_get_thread_num()",
          "old_line_content": "    const size_t iend = (tid == (nthread - 1)) ?",
          "new_line_content": "    const size_t tid = omp_get_thread_num();",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(false)",
          "old_line_content": "    }",
          "new_line_content": "        CHECK(false);  // no default behavior",
          "content_same": false
        },
        {
          "line": 707,
          "old_api": null,
          "new_api": "discard",
          "old_text": null,
          "new_text": "rnds[tid].discard(discard_size * tid)",
          "old_line_content": "    for (size_t i = ibegin; i < iend; ++i) {",
          "new_line_content": "    rnds[tid].discard(discard_size * tid);",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": null,
          "new_api": "CalculateRowOffsets",
          "old_text": null,
          "new_text": "partition_builder_.CalculateRowOffsets()",
          "old_line_content": "",
          "new_line_content": "  partition_builder_.CalculateRowOffsets();",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": null,
          "new_api": "rnds[tid]()",
          "old_text": null,
          "new_text": "rnds[tid]()",
          "old_line_content": "        p_row_indices[ibegin + row_offsets[tid]++] = i;",
          "new_line_content": "      if (gpair[i].GetHess() >= 0.0f && rnds[tid]() < coin_flip_border) {",
          "content_same": false
        },
        {
          "line": 1224,
          "old_api": null,
          "new_api": "MergeToArray",
          "old_text": null,
          "new_text": "common::ParallelFor2d(space, this->nthread_, [&](size_t node_in_set, common::Range1d r) {\n    const int32_t nid = nodes[node_in_set].nid;\n    partition_builder_.MergeToArray(node_in_set, r.begin(),\n        const_cast<size_t*>(row_set_collection_[nid].begin));\n  })",
          "old_line_content": "    const int32_t nid = nodes[node_in_set].nid;",
          "new_line_content": "  common::ParallelFor2d(space, this->nthread_, [&](size_t node_in_set, common::Range1d r) {",
          "content_same": false
        },
        {
          "line": 1227,
          "old_api": null,
          "new_api": "const_cast<size_t*>(row_set_collection_[nid].begin)",
          "old_text": null,
          "new_text": "const_cast<size_t*>(row_set_collection_[nid].begin)",
          "old_line_content": "  });",
          "new_line_content": "        const_cast<size_t*>(row_set_collection_[nid].begin));",
          "content_same": false
        },
        {
          "line": 1231,
          "old_api": null,
          "new_api": "Stop",
          "old_text": null,
          "new_text": "builder_monitor_.Stop(\"ApplySplit\")",
          "old_line_content": "}",
          "new_line_content": "  builder_monitor_.Stop(\"ApplySplit\");",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "row_indices_local.resize(prefix_sum)",
          "old_line_content": "#endif  // XGBOOST_CUSTOMIZE_GLOBAL_PRNG",
          "new_line_content": "  row_indices_local.resize(prefix_sum);",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "builder_monitor_.Start(\"InitNewNode\")",
          "old_line_content": "  {",
          "new_line_content": "  builder_monitor_.Start(\"InitNewNode\");",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": null,
          "new_api": "NodeEntry",
          "old_text": null,
          "new_text": "NodeEntry(param_)",
          "old_line_content": "  }",
          "new_line_content": "    snode_.resize(tree.param.num_nodes, NodeEntry(param_));",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK((param_.max_depth > 0 || param_.max_leaves > 0))",
          "old_line_content": "      << \"max_depth or max_leaves cannot be both 0 (unlimited); \"",
          "new_line_content": "  CHECK((param_.max_depth > 0 || param_.max_leaves > 0))",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": null,
          "new_api": "IsRoot",
          "old_text": null,
          "new_text": "tree[nid].IsRoot()",
          "old_line_content": "      if (data_layout_ == DataLayout::kDenseDataZeroBased",
          "new_line_content": "    if (tree[nid].IsRoot()) {",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(param_.max_depth > 0)",
          "old_line_content": "                                << \"when grow_policy is depthwise.\";",
          "new_line_content": "    CHECK(param_.max_depth > 0) << \"max_depth cannot be 0 (unlimited) \"",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": null,
          "new_api": "Ptrs",
          "old_text": null,
          "new_text": "gmat.cut.Ptrs()",
          "old_line_content": "        const uint32_t ibegin = row_ptr[fid_least_bins_];",
          "new_line_content": "        const std::vector<uint32_t>& row_ptr = gmat.cut.Ptrs();",
          "content_same": false
        },
        {
          "line": 1253,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "hist.data()",
          "old_line_content": "        for (uint32_t i = ibegin; i < iend; ++i) {",
          "new_line_content": "        auto begin = hist.data();",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": null,
          "new_api": "Info",
          "old_text": null,
          "new_text": "fmat.Info()",
          "old_line_content": "",
          "new_line_content": "  const auto& info = fmat.Info();",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": null,
          "new_api": "GetHess",
          "old_text": null,
          "new_text": "et.GetHess()",
          "old_line_content": "        }",
          "new_line_content": "          grad_stat.Add(et.GetGrad(), et.GetHess());",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": null,
          "new_api": "Clear",
          "old_text": null,
          "new_text": "row_set_collection_.Clear()",
          "old_line_content": "    // clear local prediction cache",
          "new_line_content": "    row_set_collection_.Clear();",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "leaf_value_cache_.clear()",
          "old_line_content": "    // initialize histogram collection",
          "new_line_content": "    leaf_value_cache_.clear();",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": null,
          "new_api": "GetHess",
          "old_text": null,
          "new_text": "gpair[*it].GetHess()",
          "old_line_content": "        }",
          "new_line_content": "          grad_stat.Add(gpair[*it].GetGrad(), gpair[*it].GetHess());",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": null,
          "new_api": "Init",
          "old_text": null,
          "new_text": "hist_buffer_.Init(nbins)",
          "old_line_content": "",
          "new_line_content": "    hist_buffer_.Init(nbins);",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": null,
          "new_api": "GetHess",
          "old_text": null,
          "new_text": "grad_stat.GetHess()",
          "old_line_content": "    } else {",
          "new_line_content": "      snode_[nid].stats = tree::GradStats(grad_stat.GetGrad(), grad_stat.GetHess());",
          "content_same": false
        },
        {
          "line": 1268,
          "old_api": null,
          "new_api": "IsLeftChild",
          "old_text": null,
          "new_text": "tree[nid].IsLeftChild()",
          "old_line_content": "        snode_[nid].stats = snode_[parent_id].best.left_sum;",
          "new_line_content": "      if (tree[nid].IsLeftChild()) {",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": null,
          "new_api": "omp_get_num_threads",
          "old_text": null,
          "new_text": "omp_get_num_threads()",
          "old_line_content": "    }",
          "new_line_content": "      this->nthread_ = omp_get_num_threads();",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "GHistBuilder<GradientSumT>(this->nthread_, nbins)",
          "old_text": null,
          "new_text": "GHistBuilder<GradientSumT>(this->nthread_, nbins)",
          "old_line_content": "",
          "new_line_content": "    hist_builder_ = GHistBuilder<GradientSumT>(this->nthread_, nbins);",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "row_indices.data()",
          "old_line_content": "    // mark subsample and build list of member rows",
          "new_line_content": "    size_t* p_row_indices = row_indices.data();",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": null,
          "new_api": "CHECK_EQ",
          "old_text": null,
          "new_text": "CHECK_EQ(param_.sampling_method, TrainParam::kUniform)",
          "old_line_content": "        << \"Only uniform sampling is supported, \"",
          "new_line_content": "      CHECK_EQ(param_.sampling_method, TrainParam::kUniform)",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": null,
          "new_api": "InitSampling",
          "old_text": null,
          "new_text": "InitSampling(gpair, fmat, &row_indices)",
          "old_line_content": "    } else {",
          "new_line_content": "      InitSampling(gpair, fmat, &row_indices);",
          "content_same": false
        },
        {
          "line": 1283,
          "old_api": null,
          "new_api": "CalcGain",
          "old_text": null,
          "new_text": "evaluator.CalcGain(parentid, param_, GradStats{snode_[nid].stats})",
          "old_line_content": "  }",
          "new_line_content": "        evaluator.CalcGain(parentid, param_, GradStats{snode_[nid].stats}));",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": null,
          "new_api": "Stop",
          "old_text": null,
          "new_text": "builder_monitor_.Stop(\"InitNewNode\")",
          "old_line_content": "}",
          "new_line_content": "  builder_monitor_.Stop(\"InitNewNode\");",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": null,
          "new_api": "std::fill(p_buff, p_buff + this->nthread_, false)",
          "old_text": null,
          "new_text": "std::fill(p_buff, p_buff + this->nthread_, false)",
          "old_line_content": "",
          "new_line_content": "      std::fill(p_buff, p_buff + this->nthread_, false);",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": null,
          "new_api": "omp_get_thread_num",
          "old_text": null,
          "new_text": "omp_get_thread_num()",
          "old_line_content": "        const size_t ibegin = tid * block_size;",
          "new_line_content": "        const size_t tid = omp_get_thread_num();",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": null,
          "new_api": "static_cast<size_t>(info.num_row_)",
          "old_text": null,
          "new_text": "static_cast<size_t>(info.num_row_)",
          "old_line_content": "",
          "new_line_content": "            static_cast<size_t>(info.num_row_));",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(d_step == +1 || d_step == -1)",
          "old_line_content": "",
          "new_line_content": "  CHECK(d_step == +1 || d_step == -1);",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": null,
          "new_api": "GetHess",
          "old_text": null,
          "new_text": "gpair[i].GetHess()",
          "old_line_content": "            p_buff[tid] = true;",
          "new_line_content": "          if (gpair[i].GetHess() < 0.0f) {",
          "content_same": false
        },
        {
          "line": 1301,
          "old_api": null,
          "new_api": "Values",
          "old_text": null,
          "new_text": "gmat.cut.Values()",
          "old_line_content": "",
          "new_line_content": "  const std::vector<bst_float>& cut_val = gmat.cut.Values();",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": null,
          "new_api": "std::numeric_limits<int32_t>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<int32_t>::max()",
          "old_line_content": "  // imin: index (offset) of the minimum value for feature fid",
          "new_line_content": "           static_cast<uint32_t>(std::numeric_limits<int32_t>::max()));",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": null,
          "new_api": "GetHess",
          "old_text": null,
          "new_text": "gpair[i].GetHess()",
          "old_line_content": "            p_row_indices[j++] = i;",
          "new_line_content": "          if (gpair[i].GetHess() >= 0.0f) {",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": null,
          "new_api": "static_cast<int32_t>(cut_ptr[fid])",
          "old_text": null,
          "new_text": "static_cast<int32_t>(cut_ptr[fid])",
          "old_line_content": "  // ibegin, iend: smallest/largest cut points for feature fid",
          "new_line_content": "  const auto imin = static_cast<int32_t>(cut_ptr[fid]);",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "row_indices.resize(j)",
          "old_line_content": "      } else {",
          "new_line_content": "        row_indices.resize(j);",
          "content_same": false
        },
        {
          "line": 1322,
          "old_api": null,
          "new_api": "static_cast<int32_t>(cut_ptr[fid + 1])",
          "old_text": null,
          "new_text": "static_cast<int32_t>(cut_ptr[fid + 1])",
          "old_line_content": "  } else {",
          "new_line_content": "    iend = static_cast<int32_t>(cut_ptr[fid + 1]);",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": null,
          "new_api": "omp_get_thread_num",
          "old_text": null,
          "new_text": "omp_get_thread_num()",
          "old_line_content": "          const size_t ibegin = tid * block_size;",
          "new_line_content": "          const size_t tid = omp_get_thread_num();",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": null,
          "new_api": "static_cast<int32_t>(cut_ptr[fid])",
          "old_text": null,
          "new_text": "static_cast<int32_t>(cut_ptr[fid])",
          "old_line_content": "  }",
          "new_line_content": "    iend = static_cast<int32_t>(cut_ptr[fid]) - 1;",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": null,
          "new_api": "static_cast<size_t>(info.num_row_)",
          "old_text": null,
          "new_text": "static_cast<size_t>(info.num_row_)",
          "old_line_content": "          for (size_t i = ibegin; i < iend; ++i) {",
          "new_line_content": "              static_cast<size_t>(info.num_row_));",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": null,
          "new_api": "GetHess",
          "old_text": null,
          "new_text": "c.GetHess()",
          "old_line_content": "        bst_float loss_chg;",
          "new_line_content": "      if (c.GetHess() >= param_.min_child_weight) {",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": null,
          "new_api": "Init",
          "old_text": null,
          "new_text": "row_set_collection_.Init()",
          "old_line_content": "",
          "new_line_content": "  row_set_collection_.Init();",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": null,
          "new_api": "CalcSplitGain",
          "old_text": null,
          "new_text": "evaluator.CalcSplitGain(param_, nodeID, fid, GradStats{e},\n                                      GradStats{c})",
          "old_line_content": "                                      GradStats{c}) -",
          "new_line_content": "              evaluator.CalcSplitGain(param_, nodeID, fid, GradStats{e},",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": null,
          "new_api": "Ptrs",
          "old_text": null,
          "new_text": "gmat.cut.Ptrs()",
          "old_line_content": "    if (nrow * ncol == nnz) {",
          "new_line_content": "    const uint32_t nbins_f0 = gmat.cut.Ptrs()[1] - gmat.cut.Ptrs()[0];",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": null,
          "new_api": "Update",
          "old_text": null,
          "new_text": "best.Update(loss_chg, fid, split_pt, d_step == -1, e, c)",
          "old_line_content": "        } else {",
          "new_line_content": "          best.Update(loss_chg, fid, split_pt, d_step == -1, e, c);",
          "content_same": false
        },
        {
          "line": 1348,
          "old_api": null,
          "new_api": "CalcSplitGain",
          "old_text": null,
          "new_text": "evaluator.CalcSplitGain(param_, nodeID, fid, GradStats{c},\n                                      GradStats{e})",
          "old_line_content": "                                      GradStats{e}) -",
          "new_line_content": "              evaluator.CalcSplitGain(param_, nodeID, fid, GradStats{c},",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": null,
          "new_api": "MinValues",
          "old_text": null,
          "new_text": "gmat.cut.MinValues()",
          "old_line_content": "          } else {",
          "new_line_content": "            split_pt = gmat.cut.MinValues()[fid];",
          "content_same": false
        },
        {
          "line": 1357,
          "old_api": null,
          "new_api": "Update",
          "old_text": null,
          "new_text": "best.Update(loss_chg, fid, split_pt, d_step == -1, c, e)",
          "old_line_content": "        }",
          "new_line_content": "          best.Update(loss_chg, fid, split_pt, d_step == -1, c, e);",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": null,
          "new_api": "ConstHostVector",
          "old_text": null,
          "new_text": "info.feature_weigths.ConstHostVector()",
          "old_line_content": "                         param_.colsample_bynode, param_.colsample_bylevel,",
          "new_line_content": "    column_sampler_.Init(info.num_col_, info.feature_weigths.ConstHostVector(),",
          "content_same": false
        },
        {
          "line": 1362,
          "old_api": null,
          "new_api": "Update",
          "old_text": null,
          "new_text": "p_best->Update(best)",
          "old_line_content": "",
          "new_line_content": "  p_best->Update(best);",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": null,
          "new_api": "ConstHostVector",
          "old_text": null,
          "new_text": "info.feature_weigths.ConstHostVector()",
          "old_line_content": "                         param_.colsample_bynode, param_.colsample_bylevel,",
          "new_line_content": "    column_sampler_.Init(info.num_col_, info.feature_weigths.ConstHostVector(),",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "row_ptr.size()",
          "old_line_content": "    uint32_t min_nbins_per_feature = 0;",
          "new_line_content": "    const auto nfeature = static_cast<bst_uint>(row_ptr.size() - 1);",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": null,
          "new_api": "CHECK_GT",
          "old_text": null,
          "new_text": "CHECK_GT(min_nbins_per_feature, 0U)",
          "old_line_content": "  }",
          "new_line_content": "    CHECK_GT(min_nbins_per_feature, 0U);",
          "content_same": false
        },
        {
          "line": 1388,
          "old_api": null,
          "new_api": "describe",
          "old_text": null,
          "new_text": "XGBOOST_REGISTER_TREE_UPDATER(FastHistMaker, \"grow_fast_histmaker\")\n.describe(\"(Deprecated, use grow_quantile_histmaker instead.)\"\n          \" Grow tree using quantized histogram.\")\n.set_body(\n    []() {\n      LOG(WARNING) << \"grow_fast_histmaker is deprecated, \"\n                   << \"use grow_quantile_histmaker instead.\";\n      return new QuantileHistMaker();\n    })",
          "old_line_content": ".describe(\"(Deprecated, use grow_quantile_histmaker instead.)\"",
          "new_line_content": "XGBOOST_REGISTER_TREE_UPDATER(FastHistMaker, \"grow_fast_histmaker\")",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "snode_.clear()",
          "old_line_content": "  }",
          "new_line_content": "    snode_.clear();",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "qexpand_loss_guided_.reset(new ExpandQueue(LossGuide))",
          "old_line_content": "    } else {",
          "new_line_content": "      qexpand_loss_guided_.reset(new ExpandQueue(LossGuide));",
          "content_same": false
        },
        {
          "line": 1393,
          "old_api": null,
          "new_api": "LOG",
          "old_text": null,
          "new_text": "LOG(WARNING)",
          "old_line_content": "                   << \"use grow_quantile_histmaker instead.\";",
          "new_line_content": "      LOG(WARNING) << \"grow_fast_histmaker is deprecated, \"",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "qexpand_depth_wise_.clear()",
          "old_line_content": "    }",
          "new_line_content": "      qexpand_depth_wise_.clear();",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": null,
          "new_api": "Stop",
          "old_text": null,
          "new_text": "builder_monitor_.Stop(\"InitData\")",
          "old_line_content": "}",
          "new_line_content": "  builder_monitor_.Stop(\"InitData\");",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": null,
          "new_api": "describe",
          "old_text": null,
          "new_text": "XGBOOST_REGISTER_TREE_UPDATER(QuantileHistMaker, \"grow_quantile_histmaker\")\n.describe(\"Grow tree using quantized histogram.\")\n.set_body(\n    []() {\n      return new QuantileHistMaker();\n    })",
          "old_line_content": ".describe(\"Grow tree using quantized histogram.\")",
          "new_line_content": "XGBOOST_REGISTER_TREE_UPDATER(QuantileHistMaker, \"grow_quantile_histmaker\")",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": null,
          "new_api": "GetHess",
          "old_text": null,
          "new_text": "snode.stats.GetHess()",
          "old_line_content": "    return false;",
          "new_line_content": "  if (e.GetGrad() == snode.stats.GetGrad() && e.GetHess() == snode.stats.GetHess()) {",
          "content_same": false
        },
        {
          "line": 910,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "builder_monitor_.Start(\"EvaluateSplits\")",
          "old_line_content": "",
          "new_line_content": "  builder_monitor_.Start(\"EvaluateSplits\");",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": null,
          "new_api": "std::max(1, this->nthread_)",
          "old_text": null,
          "new_text": "std::max(1, this->nthread_)",
          "old_line_content": "",
          "new_line_content": "  const size_t nthread = std::max(1, this->nthread_);",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "best_split_tloc_.resize(nthread * n_nodes_in_set)",
          "old_line_content": "",
          "new_line_content": "  best_split_tloc_.resize(nthread * n_nodes_in_set);",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": null,
          "new_api": "GetDepth",
          "old_text": null,
          "new_text": "tree.GetDepth(nid)",
          "old_line_content": "",
          "new_line_content": "    features_sets[nid_in_set] = column_sampler_.GetFeatureSet(tree.GetDepth(nid));",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "features_sets[0]->Size()",
          "old_line_content": "  common::BlockedSpace2d space(n_nodes_in_set, [&](size_t nid_in_set) {",
          "new_line_content": "  const size_t grain_size = std::max<size_t>(1, features_sets[0]->Size() / nthread);",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "features_sets[nid_in_set]->Size()",
          "old_line_content": "  }, grain_size);",
          "new_line_content": "      return features_sets[nid_in_set]->Size();",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "GetEvaluator",
          "old_text": null,
          "new_text": "tree_evaluator_.GetEvaluator()",
          "old_line_content": "  // Start parallel enumeration for all tree nodes in the set and all features",
          "new_line_content": "  auto evaluator = tree_evaluator_.GetEvaluator();",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "common::ParallelFor2d(space, this->nthread_, [&](size_t nid_in_set, common::Range1d r) {\n    const int32_t nid = nodes_set[nid_in_set].nid;\n    const auto tid = static_cast<unsigned>(omp_get_thread_num());\n    GHistRowT node_hist = hist[nid];\n\n    for (auto idx_in_feature_set = r.begin(); idx_in_feature_set < r.end(); ++idx_in_feature_set) {\n      const auto fid = features_sets[nid_in_set]->ConstHostVector()[idx_in_feature_set];\n      if (interaction_constraints_.Query(nid, fid)) {\n        auto grad_stats = this->EnumerateSplit<+1>(\n            gmat, node_hist, snode_[nid],\n            &best_split_tloc_[nthread * nid_in_set + tid], fid, nid, evaluator);\n        if (SplitContainsMissingValues(grad_stats, snode_[nid])) {\n          this->EnumerateSplit<-1>(\n              gmat, node_hist, snode_[nid],\n              &best_split_tloc_[nthread * nid_in_set + tid], fid, nid,\n              evaluator);\n        }\n      }\n    }\n  })",
          "old_line_content": "    const int32_t nid = nodes_set[nid_in_set].nid;",
          "new_line_content": "  common::ParallelFor2d(space, this->nthread_, [&](size_t nid_in_set, common::Range1d r) {",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": null,
          "new_api": "omp_get_thread_num",
          "old_text": null,
          "new_text": "omp_get_thread_num()",
          "old_line_content": "    GHistRowT node_hist = hist[nid];",
          "new_line_content": "    const auto tid = static_cast<unsigned>(omp_get_thread_num());",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": null,
          "new_api": "this->EnumerateSplit<+1>(\n            gmat, node_hist, snode_[nid],\n            &best_split_tloc_[nthread * nid_in_set + tid], fid, nid, evaluator)",
          "old_text": null,
          "new_text": "this->EnumerateSplit<+1>(\n            gmat, node_hist, snode_[nid],\n            &best_split_tloc_[nthread * nid_in_set + tid], fid, nid, evaluator)",
          "old_line_content": "            gmat, node_hist, snode_[nid],",
          "new_line_content": "        auto grad_stats = this->EnumerateSplit<+1>(",
          "content_same": false
        },
        {
          "line": 950,
          "old_api": null,
          "new_api": "this->EnumerateSplit<-1>(\n              gmat, node_hist, snode_[nid],\n              &best_split_tloc_[nthread * nid_in_set + tid], fid, nid,\n              evaluator)",
          "old_text": null,
          "new_text": "this->EnumerateSplit<-1>(\n              gmat, node_hist, snode_[nid],\n              &best_split_tloc_[nthread * nid_in_set + tid], fid, nid,\n              evaluator)",
          "old_line_content": "              gmat, node_hist, snode_[nid],",
          "new_line_content": "          this->EnumerateSplit<-1>(",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "Update",
          "old_text": null,
          "new_text": "snode_[nid].best.Update(best_split_tloc_[nthread*nid_in_set + tid])",
          "old_line_content": "    }",
          "new_line_content": "      snode_[nid].best.Update(best_split_tloc_[nthread*nid_in_set + tid]);",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": null,
          "new_api": "Stop",
          "old_text": null,
          "new_text": "builder_monitor_.Stop(\"EvaluateSplits\")",
          "old_line_content": "}",
          "new_line_content": "  builder_monitor_.Stop(\"EvaluateSplits\");",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "right_part.data()",
          "old_line_content": "  size_t nleft_elems = 0;",
          "new_line_content": "  size_t* p_right_part = right_part.data();",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": null,
          "new_api": "IsMissing",
          "old_text": null,
          "new_text": "column.IsMissing(rid)",
          "old_line_content": "        if (default_left) {",
          "new_line_content": "      if (column.IsMissing(rid)) {",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": null,
          "new_api": "static_cast<int32_t>(idx[rid])",
          "old_text": null,
          "new_text": "static_cast<int32_t>(idx[rid])",
          "old_line_content": "          p_left_part[nleft_elems++] = rid;",
          "new_line_content": "        if ((static_cast<int32_t>(idx[rid]) + offset) <= split_cond) {",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": null,
          "new_api": "static_cast<int32_t>(idx[rid])",
          "old_text": null,
          "new_text": "static_cast<int32_t>(idx[rid])",
          "old_line_content": "        p_left_part[nleft_elems++] = rid;",
          "new_line_content": "      if ((static_cast<int32_t>(idx[rid]) + offset) <= split_cond) {",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "right_part.data()",
          "old_line_content": "",
          "new_line_content": "  size_t* p_right_part = right_part.data();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1025,
          "old_api": "GetRowData",
          "new_api": null,
          "old_text": "column.GetRowData()",
          "new_text": null,
          "old_line_content": "  const size_t* row_data = column.GetRowData();",
          "new_line_content": "  size_t nright_elems = 0;",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": "front",
          "new_api": null,
          "old_text": "std::lower_bound(row_data, row_data + column_size,\n                                       rid_span.front())",
          "new_text": null,
          "old_line_content": "    const size_t* p = std::lower_bound(row_data, row_data + column_size,",
          "new_line_content": "    // search first nonzero row with index >= rid_span.front()",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": "back",
          "new_api": null,
          "old_text": "rid_span.back()",
          "new_text": null,
          "old_line_content": "    if (p != row_data + column_size && *p <= rid_span.back()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": "GetRowIdx",
          "new_api": null,
          "old_text": "column.GetRowIdx(cursor)",
          "new_text": null,
          "old_line_content": "               && column.GetRowIdx(cursor) < rid",
          "new_line_content": "        while (cursor < column_size",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "GetRowIdx",
          "new_api": null,
          "old_text": "column.GetRowIdx(cursor)",
          "new_text": null,
          "old_line_content": "        if (cursor < column_size && column.GetRowIdx(cursor) == rid) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": "end",
          "new_api": null,
          "old_text": "rid_span.end()",
          "new_text": null,
          "old_line_content": "        std::copy(rid_span.begin(), rid_span.end(), p_left_part);",
          "new_line_content": "      if (default_left) {",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": "end",
          "new_api": null,
          "old_text": "rid_span.end()",
          "new_text": null,
          "old_line_content": "        std::copy(rid_span.begin(), rid_span.end(), p_right_part);",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 1078,
          "old_api": "end",
          "new_api": null,
          "old_text": "range.end()",
          "new_text": null,
          "old_line_content": "  common::Span<const size_t> rid_span(rid + range.begin(), rid + range.end());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": "GetType",
          "new_api": null,
          "old_text": "column_ptr->GetType()",
          "new_text": null,
          "old_line_content": "  if (column_ptr->GetType() == xgboost::common::kDenseColumn) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1091,
          "old_api": "get",
          "new_api": null,
          "old_text": "column_ptr.get()",
          "new_text": null,
          "old_line_content": "          static_cast<const common::DenseColumn<BinIdxType>& >(*(column_ptr.get()));",
          "new_line_content": "    const common::DenseColumn<BinIdxType>& column =",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": "AnyMissing",
          "new_api": null,
          "old_text": "column_matrix.AnyMissing()",
          "new_text": null,
          "old_line_content": "      if (column_matrix.AnyMissing()) {",
          "new_line_content": "    if (default_left) {",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": "PartitionDenseKernel<true, false>(column, rid_span, split_cond,\n                                                              left, right)",
          "new_api": null,
          "old_text": "PartitionDenseKernel<true, false>(column, rid_span, split_cond,\n                                                              left, right)",
          "new_text": null,
          "old_line_content": "        child_nodes_sizes = PartitionDenseKernel<true, false>(column, rid_span, split_cond,",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "AnyMissing",
          "new_api": null,
          "old_text": "column_matrix.AnyMissing()",
          "new_text": null,
          "old_line_content": "      if (column_matrix.AnyMissing()) {",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": "PartitionDenseKernel<false, false>(column, rid_span, split_cond,\n                                                               left, right)",
          "new_api": null,
          "old_text": "PartitionDenseKernel<false, false>(column, rid_span, split_cond,\n                                                               left, right)",
          "new_text": null,
          "old_line_content": "        child_nodes_sizes = PartitionDenseKernel<false, false>(column, rid_span, split_cond,",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": "get",
          "new_api": null,
          "old_text": "column_ptr.get()",
          "new_text": null,
          "old_line_content": "      = static_cast<const common::SparseColumn<BinIdxType>& >(*(column_ptr.get()));",
          "new_line_content": "    const common::SparseColumn<BinIdxType>& column",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": "PartitionSparseKernel<true>(rid_span, split_cond, column, left, right)",
          "new_api": null,
          "old_text": "PartitionSparseKernel<true>(rid_span, split_cond, column, left, right)",
          "new_text": null,
          "old_line_content": "      child_nodes_sizes = PartitionSparseKernel<true>(rid_span, split_cond, column, left, right);",
          "new_line_content": "    if (default_left) {",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": "PartitionSparseKernel<false>(rid_span, split_cond, column, left, right)",
          "new_api": null,
          "old_text": "PartitionSparseKernel<false>(rid_span, split_cond, column, left, right)",
          "new_text": null,
          "old_line_content": "      child_nodes_sizes = PartitionSparseKernel<false>(rid_span, split_cond, column, left, right);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": "end",
          "new_api": null,
          "old_text": "range.end()",
          "new_text": null,
          "old_line_content": "  partition_builder_.SetNLeftElems(node_in_set, range.begin(), range.end(), n_left);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": "size",
          "new_api": null,
          "old_text": "nodes.size()",
          "new_text": null,
          "old_line_content": "  const size_t n_nodes = nodes.size();",
          "new_line_content": "                                                     std::vector<int32_t>* split_conditions) {",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": "size",
          "new_api": null,
          "old_text": "nodes.size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < nodes.size(); ++i) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1137,
          "old_api": "SplitIndex",
          "new_api": null,
          "old_text": "tree[nid].SplitIndex()",
          "new_text": null,
          "old_line_content": "    const bst_uint fid = tree[nid].SplitIndex();",
          "new_line_content": "    const int32_t nid = nodes[i].nid;",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": "CHECK_LT",
          "new_api": null,
          "old_text": "CHECK_LT(upper_bound,\n             static_cast<uint32_t>(std::numeric_limits<int32_t>::max()))",
          "new_text": null,
          "old_line_content": "    CHECK_LT(upper_bound,",
          "new_line_content": "    // split_cond = -1 indicates that split_pt is less than all known cut points",
          "content_same": false
        },
        {
          "line": 1147,
          "old_api": "Values",
          "new_api": null,
          "old_text": "gmat.cut.Values()",
          "new_text": null,
          "old_line_content": "      if (split_pt == gmat.cut.Values()[bound]) {",
          "new_line_content": "    for (uint32_t bound = lower_bound; bound < upper_bound; ++bound) {",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": "size",
          "new_api": null,
          "old_text": "nodes.size()",
          "new_text": null,
          "old_line_content": "  const size_t n_nodes = nodes.size();",
          "new_line_content": "                                               RegTree* p_tree) {",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": "GetNLeftElems",
          "new_api": null,
          "old_text": "partition_builder_.GetNLeftElems(i)",
          "new_text": null,
          "old_line_content": "    const size_t n_left = partition_builder_.GetNLeftElems(i);",
          "new_line_content": "    const int32_t nid = nodes[i].nid;",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": "Start",
          "new_api": null,
          "old_text": "builder_monitor_.Start(\"ApplySplit\")",
          "new_text": null,
          "old_line_content": "  builder_monitor_.Start(\"ApplySplit\");",
          "new_line_content": "                                            RegTree* p_tree) {",
          "content_same": false
        },
        {
          "line": 1177,
          "old_api": "size",
          "new_api": null,
          "old_text": "nodes.size()",
          "new_text": null,
          "old_line_content": "  const size_t n_nodes = nodes.size();",
          "new_line_content": "  // 1. Find split condition for each split",
          "content_same": false
        },
        {
          "line": 1179,
          "old_api": "FindSplitConditions",
          "new_api": null,
          "old_text": "FindSplitConditions(nodes, *p_tree, gmat, &split_conditions)",
          "new_text": null,
          "old_line_content": "  FindSplitConditions(nodes, *p_tree, gmat, &split_conditions);",
          "new_line_content": "  std::vector<int32_t> split_conditions;",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": "Size",
          "new_api": null,
          "old_text": "row_set_collection_[nid].Size()",
          "new_text": null,
          "old_line_content": "    return row_set_collection_[nid].Size();",
          "new_line_content": "    int32_t nid = nodes[node_in_set].nid;",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": "Size",
          "new_api": null,
          "old_text": "space.Size()",
          "new_text": null,
          "old_line_content": "  partition_builder_.Init(space.Size(), n_nodes, [&](size_t node_in_set) {",
          "new_line_content": "  // allocate buffers for storage intermediate results by each thread",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": "Size",
          "new_api": null,
          "old_text": "row_set_collection_[nid].Size()",
          "new_text": null,
          "old_line_content": "    const size_t size = row_set_collection_[nid].Size();",
          "new_line_content": "    const int32_t nid = nodes[node_in_set].nid;",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": "begin",
          "new_api": null,
          "old_text": "common::ParallelFor2d(space, this->nthread_, [&](size_t node_in_set, common::Range1d r) {\n    size_t begin = r.begin();\n    const int32_t nid = nodes[node_in_set].nid;\n    const size_t task_id = partition_builder_.GetTaskIdx(node_in_set, begin);\n    partition_builder_.AllocateForTask(task_id);\n      switch (column_matrix.GetTypeSize()) {\n      case common::kUint8BinsTypeSize:\n        PartitionKernel<uint8_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree);\n        break;\n      case common::kUint16BinsTypeSize:\n        PartitionKernel<uint16_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree);\n        break;\n      case common::kUint32BinsTypeSize:\n        PartitionKernel<uint32_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree);\n        break;\n      default:\n        CHECK(false);  // no default behavior\n    }\n    })",
          "new_text": null,
          "old_line_content": "  common::ParallelFor2d(space, this->nthread_, [&](size_t node_in_set, common::Range1d r) {",
          "new_line_content": "  // Store results in intermediate buffers from partition_builder_",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": "GetTaskIdx",
          "new_api": null,
          "old_text": "partition_builder_.GetTaskIdx(node_in_set, begin)",
          "new_text": null,
          "old_line_content": "    const size_t task_id = partition_builder_.GetTaskIdx(node_in_set, begin);",
          "new_line_content": "    const int32_t nid = nodes[node_in_set].nid;",
          "content_same": false
        },
        {
          "line": 1202,
          "old_api": "PartitionKernel<uint8_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree)",
          "new_api": null,
          "old_text": "PartitionKernel<uint8_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree)",
          "new_text": null,
          "old_line_content": "        PartitionKernel<uint8_t>(node_in_set, nid, r,",
          "new_line_content": "      case common::kUint8BinsTypeSize:",
          "content_same": false
        },
        {
          "line": 1206,
          "old_api": "PartitionKernel<uint16_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree)",
          "new_api": null,
          "old_text": "PartitionKernel<uint16_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree)",
          "new_text": null,
          "old_line_content": "        PartitionKernel<uint16_t>(node_in_set, nid, r,",
          "new_line_content": "      case common::kUint16BinsTypeSize:",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "PartitionKernel<uint32_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree)",
          "new_api": null,
          "old_text": "PartitionKernel<uint32_t>(node_in_set, nid, r,\n                  split_conditions[node_in_set], column_matrix, *p_tree)",
          "new_text": null,
          "old_line_content": "        PartitionKernel<uint32_t>(node_in_set, nid, r,",
          "new_line_content": "      case common::kUint32BinsTypeSize:",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": "omp_get_thread_num",
          "new_api": null,
          "old_text": "omp_get_thread_num()",
          "new_text": null,
          "old_line_content": "    const size_t tid = omp_get_thread_num();",
          "new_line_content": "  #pragma omp parallel num_threads(nthread)",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(false)",
          "new_text": null,
          "old_line_content": "        CHECK(false);  // no default behavior",
          "new_line_content": "      default:",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": "discard",
          "new_api": null,
          "old_text": "rnds[tid].discard(2*discard_size * tid)",
          "new_text": null,
          "old_line_content": "    rnds[tid].discard(2*discard_size * tid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": "CalculateRowOffsets",
          "new_api": null,
          "old_text": "partition_builder_.CalculateRowOffsets()",
          "new_text": null,
          "old_line_content": "  partition_builder_.CalculateRowOffsets();",
          "new_line_content": "  // from partition_builder_ to row_set_collection_",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": "coin_flip",
          "new_api": null,
          "old_text": "coin_flip(rnds[tid])",
          "new_text": null,
          "old_line_content": "      if (gpair[i].GetHess() >= 0.0f && coin_flip(rnds[tid])) {",
          "new_line_content": "    for (size_t i = ibegin; i < iend; ++i) {",
          "content_same": false
        },
        {
          "line": 1223,
          "old_api": "MergeToArray",
          "new_api": null,
          "old_text": "common::ParallelFor2d(space, this->nthread_, [&](size_t node_in_set, common::Range1d r) {\n    const int32_t nid = nodes[node_in_set].nid;\n    partition_builder_.MergeToArray(node_in_set, r.begin(),\n        const_cast<size_t*>(row_set_collection_[nid].begin));\n  })",
          "new_text": null,
          "old_line_content": "  common::ParallelFor2d(space, this->nthread_, [&](size_t node_in_set, common::Range1d r) {",
          "new_line_content": "  // with updated row-indexes for each tree-node",
          "content_same": false
        },
        {
          "line": 1225,
          "old_api": "begin",
          "new_api": null,
          "old_text": "r.begin()",
          "new_text": null,
          "old_line_content": "    partition_builder_.MergeToArray(node_in_set, r.begin(),",
          "new_line_content": "    const int32_t nid = nodes[node_in_set].nid;",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": "AddSplitsToRowSet",
          "new_api": null,
          "old_text": "AddSplitsToRowSet(nodes, p_tree)",
          "new_text": null,
          "old_line_content": "  AddSplitsToRowSet(nodes, p_tree);",
          "new_line_content": "  // 5. Add info about splits into row_set_collection_",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "resize",
          "new_api": null,
          "old_text": "row_indices_local.resize(prefix_sum)",
          "new_text": null,
          "old_line_content": "  row_indices_local.resize(prefix_sum);",
          "new_line_content": "  /* resize row_indices to reduce memory */",
          "content_same": false
        },
        {
          "line": 1238,
          "old_api": "Start",
          "new_api": null,
          "old_text": "builder_monitor_.Start(\"InitNewNode\")",
          "new_text": null,
          "old_line_content": "  builder_monitor_.Start(\"InitNewNode\");",
          "new_line_content": "                                             const RegTree& tree) {",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": "NodeEntry",
          "new_api": null,
          "old_text": "NodeEntry(param_)",
          "new_text": null,
          "old_line_content": "    snode_.resize(tree.param.num_nodes, NodeEntry(param_));",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK((param_.max_depth > 0 || param_.max_leaves > 0))",
          "new_text": null,
          "old_line_content": "  CHECK((param_.max_depth > 0 || param_.max_leaves > 0))",
          "new_line_content": "                                          const RegTree& tree) {",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": "IsRoot",
          "new_api": null,
          "old_text": "tree[nid].IsRoot()",
          "new_text": null,
          "old_line_content": "    if (tree[nid].IsRoot()) {",
          "new_line_content": "    GradientPairT grad_stat;",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(param_.max_depth > 0)",
          "new_text": null,
          "old_line_content": "    CHECK(param_.max_depth > 0) << \"max_depth cannot be 0 (unlimited) \"",
          "new_line_content": "  if (param_.grow_policy == TrainParam::kDepthWise) {",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": "Ptrs",
          "new_api": null,
          "old_text": "gmat.cut.Ptrs()",
          "new_text": null,
          "old_line_content": "        const std::vector<uint32_t>& row_ptr = gmat.cut.Ptrs();",
          "new_line_content": "          || data_layout_ == DataLayout::kDenseDataOneBased) {",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": "Start",
          "new_api": null,
          "old_text": "builder_monitor_.Start(\"InitData\")",
          "new_text": null,
          "old_line_content": "  builder_monitor_.Start(\"InitData\");",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": "data",
          "new_api": null,
          "old_text": "hist.data()",
          "new_text": null,
          "old_line_content": "        auto begin = hist.data();",
          "new_line_content": "        const uint32_t iend = row_ptr[fid_least_bins_ + 1];",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": "GetHess",
          "new_api": null,
          "old_text": "et.GetHess()",
          "new_text": null,
          "old_line_content": "          grad_stat.Add(et.GetGrad(), et.GetHess());",
          "new_line_content": "          const GradientPairT et = begin[i];",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": "Clear",
          "new_api": null,
          "old_text": "row_set_collection_.Clear()",
          "new_text": null,
          "old_line_content": "    row_set_collection_.Clear();",
          "new_line_content": "    // initialize the row set",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": "clear",
          "new_api": null,
          "old_text": "leaf_value_cache_.clear()",
          "new_text": null,
          "old_line_content": "    leaf_value_cache_.clear();",
          "new_line_content": "    // clear local prediction cache",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": "GetHess",
          "new_api": null,
          "old_text": "gpair[*it].GetHess()",
          "new_text": null,
          "old_line_content": "          grad_stat.Add(gpair[*it].GetGrad(), gpair[*it].GetHess());",
          "new_line_content": "        for (const size_t* it = e.begin; it < e.end; ++it) {",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": "Ptrs",
          "new_api": null,
          "old_text": "gmat.cut.Ptrs().back()",
          "new_text": null,
          "old_line_content": "    uint32_t nbins = gmat.cut.Ptrs().back();",
          "new_line_content": "    // initialize histogram collection",
          "content_same": false
        },
        {
          "line": 1263,
          "old_api": "Allreduce",
          "new_api": null,
          "old_text": "histred_.Allreduce(&grad_stat, 1)",
          "new_text": null,
          "old_line_content": "      histred_.Allreduce(&grad_stat, 1);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1266,
          "old_api": "Parent",
          "new_api": null,
          "old_text": "tree[nid].Parent()",
          "new_text": null,
          "old_line_content": "      int parent_id = tree[nid].Parent();",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "omp_get_num_threads",
          "new_api": null,
          "old_text": "omp_get_num_threads()",
          "new_text": null,
          "old_line_content": "      this->nthread_ = omp_get_num_threads();",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": "GHistBuilder<GradientSumT>(this->nthread_, nbins)",
          "new_api": null,
          "old_text": "GHistBuilder<GradientSumT>(this->nthread_, nbins)",
          "new_text": null,
          "old_line_content": "    hist_builder_ = GHistBuilder<GradientSumT>(this->nthread_, nbins);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "Data",
          "new_api": null,
          "old_text": "row_set_collection_.Data()",
          "new_text": null,
          "old_line_content": "    std::vector<size_t>& row_indices = *row_set_collection_.Data();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": "GetEvaluator",
          "new_api": null,
          "old_text": "tree_evaluator_.GetEvaluator()",
          "new_text": null,
          "old_line_content": "    auto evaluator = tree_evaluator_.GetEvaluator();",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": "CHECK_EQ",
          "new_api": null,
          "old_text": "CHECK_EQ(param_.sampling_method, TrainParam::kUniform)",
          "new_text": null,
          "old_line_content": "      CHECK_EQ(param_.sampling_method, TrainParam::kUniform)",
          "new_line_content": "    if (param_.subsample < 1.0f) {",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "InitSampling",
          "new_api": null,
          "old_text": "InitSampling(gpair, fmat, &row_indices)",
          "new_text": null,
          "old_line_content": "      InitSampling(gpair, fmat, &row_indices);",
          "new_line_content": "        << \"gradient-based sampling is only support by GPU Hist.\";",
          "content_same": false
        },
        {
          "line": 1284,
          "old_api": "Stop",
          "new_api": null,
          "old_text": "builder_monitor_.Stop(\"InitNewNode\")",
          "new_text": null,
          "old_line_content": "  builder_monitor_.Stop(\"InitNewNode\");",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "Get",
          "new_api": null,
          "old_text": "buff.Get()",
          "new_text": null,
          "old_line_content": "      bool* p_buff = buff.Get();",
          "new_line_content": "      MemStackAllocator<bool, 128> buff(this->nthread_);",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": "omp_get_thread_num",
          "new_api": null,
          "old_text": "omp_get_thread_num()",
          "new_text": null,
          "old_line_content": "        const size_t tid = omp_get_thread_num();",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": "static_cast<size_t>(ibegin + block_size)",
          "new_api": null,
          "old_text": "static_cast<size_t>(ibegin + block_size)",
          "new_text": null,
          "old_line_content": "        const size_t iend = std::min(static_cast<size_t>(ibegin + block_size),",
          "new_line_content": "        const size_t ibegin = tid * block_size;",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(d_step == +1 || d_step == -1)",
          "new_text": null,
          "old_line_content": "  CHECK(d_step == +1 || d_step == -1);",
          "new_line_content": "    TreeEvaluator::SplitEvaluator<TrainParam> const &evaluator) const {",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": "GetHess",
          "new_api": null,
          "old_text": "gpair[i].GetHess()",
          "new_text": null,
          "old_line_content": "          if (gpair[i].GetHess() < 0.0f) {",
          "new_line_content": "        for (size_t i = ibegin; i < iend; ++i) {",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": "Ptrs",
          "new_api": null,
          "old_text": "gmat.cut.Ptrs()",
          "new_text": null,
          "old_line_content": "  const std::vector<uint32_t>& cut_ptr = gmat.cut.Ptrs();",
          "new_line_content": "  // aliases",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": "CHECK_LE",
          "new_api": null,
          "old_text": "CHECK_LE(cut_ptr[fid],\n           static_cast<uint32_t>(std::numeric_limits<int32_t>::max()))",
          "new_text": null,
          "old_line_content": "  CHECK_LE(cut_ptr[fid],",
          "new_line_content": "  // bin boundaries",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": "GetHess",
          "new_api": null,
          "old_text": "gpair[i].GetHess()",
          "new_text": null,
          "old_line_content": "          if (gpair[i].GetHess() >= 0.0f) {",
          "new_line_content": "        for (size_t i = 0; i < info.num_row_; ++i) {",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": "static_cast<int32_t>(cut_ptr[fid])",
          "new_api": null,
          "old_text": "static_cast<int32_t>(cut_ptr[fid])",
          "new_text": null,
          "old_line_content": "  const auto imin = static_cast<int32_t>(cut_ptr[fid]);",
          "new_line_content": "  //       need this for backward enumeration",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "resize",
          "new_api": null,
          "old_text": "row_indices.resize(j)",
          "new_text": null,
          "old_line_content": "        row_indices.resize(j);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": "static_cast<int32_t>(cut_ptr[fid])",
          "new_api": null,
          "old_text": "static_cast<int32_t>(cut_ptr[fid])",
          "new_text": null,
          "old_line_content": "    ibegin = static_cast<int32_t>(cut_ptr[fid]);",
          "new_line_content": "  if (d_step > 0) {",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "omp_get_thread_num",
          "new_api": null,
          "old_text": "omp_get_thread_num()",
          "new_text": null,
          "old_line_content": "          const size_t tid = omp_get_thread_num();",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": "static_cast<int32_t>(cut_ptr[fid + 1])",
          "new_api": null,
          "old_text": "static_cast<int32_t>(cut_ptr[fid + 1])",
          "new_text": null,
          "old_line_content": "    ibegin = static_cast<int32_t>(cut_ptr[fid + 1]) - 1;",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "static_cast<size_t>(ibegin + block_size)",
          "new_api": null,
          "old_text": "static_cast<size_t>(ibegin + block_size)",
          "new_text": null,
          "old_line_content": "          const size_t iend = std::min(static_cast<size_t>(ibegin + block_size),",
          "new_line_content": "          const size_t ibegin = tid * block_size;",
          "content_same": false
        },
        {
          "line": 1330,
          "old_api": "GetHess",
          "new_api": null,
          "old_text": "hist[i].GetHess()",
          "new_text": null,
          "old_line_content": "    e.Add(hist[i].GetGrad(), hist[i].GetHess());",
          "new_line_content": "    // try to find a split",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": "Init",
          "new_api": null,
          "old_text": "row_set_collection_.Init()",
          "new_text": null,
          "old_line_content": "  row_set_collection_.Init();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": "CalcSplitGain",
          "new_api": null,
          "old_text": "static_cast<bst_float>(\n              evaluator.CalcSplitGain(param_, nodeID, fid, GradStats{e},\n                                      GradStats{c}) -\n              snode.root_gain)",
          "new_text": null,
          "old_line_content": "          loss_chg = static_cast<bst_float>(",
          "new_line_content": "          // forward enumeration: split at right bound of each bin",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": "Ptrs",
          "new_api": null,
          "old_text": "gmat.cut.Ptrs()",
          "new_text": null,
          "old_line_content": "    const uint32_t nbins_f0 = gmat.cut.Ptrs()[1] - gmat.cut.Ptrs()[0];",
          "new_line_content": "    // number of discrete bins for feature 0",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": "Update",
          "new_api": null,
          "old_text": "best.Update(loss_chg, fid, split_pt, d_step == -1, e, c)",
          "new_text": null,
          "old_line_content": "          best.Update(loss_chg, fid, split_pt, d_step == -1, e, c);",
          "new_line_content": "          split_pt = cut_val[i];",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": "CalcSplitGain",
          "new_api": null,
          "old_text": "static_cast<bst_float>(\n              evaluator.CalcSplitGain(param_, nodeID, fid, GradStats{c},\n                                      GradStats{e}) -\n              snode.root_gain)",
          "new_text": null,
          "old_line_content": "          loss_chg = static_cast<bst_float>(",
          "new_line_content": "          // backward enumeration: split at left bound of each bin",
          "content_same": false
        },
        {
          "line": 1352,
          "old_api": "MinValues",
          "new_api": null,
          "old_text": "gmat.cut.MinValues()",
          "new_text": null,
          "old_line_content": "            split_pt = gmat.cut.MinValues()[fid];",
          "new_line_content": "            // for leftmost bin, left bound is the smallest feature value",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": "Update",
          "new_api": null,
          "old_text": "best.Update(loss_chg, fid, split_pt, d_step == -1, c, e)",
          "new_text": null,
          "old_line_content": "          best.Update(loss_chg, fid, split_pt, d_step == -1, c, e);",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": "ConstHostVector",
          "new_api": null,
          "old_text": "info.feature_weigths.ConstHostVector()",
          "new_text": null,
          "old_line_content": "    column_sampler_.Init(info.num_col_, info.feature_weigths.ConstHostVector(),",
          "new_line_content": "  if (data_layout_ == DataLayout::kDenseDataOneBased) {",
          "content_same": false
        },
        {
          "line": 1361,
          "old_api": "Update",
          "new_api": null,
          "old_text": "p_best->Update(best)",
          "new_text": null,
          "old_line_content": "  p_best->Update(best);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": "ConstHostVector",
          "new_api": null,
          "old_text": "info.feature_weigths.ConstHostVector()",
          "new_text": null,
          "old_line_content": "    column_sampler_.Init(info.num_col_, info.feature_weigths.ConstHostVector(),",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": "Ptrs",
          "new_api": null,
          "old_text": "gmat.cut.Ptrs()",
          "new_text": null,
          "old_line_content": "    const std::vector<uint32_t>& row_ptr = gmat.cut.Ptrs();",
          "new_line_content": "       the sum of gradient histogram is equal to snode[nid] */",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "CHECK_GT",
          "new_api": null,
          "old_text": "CHECK_GT(min_nbins_per_feature, 0U)",
          "new_text": null,
          "old_line_content": "    CHECK_GT(min_nbins_per_feature, 0U);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "snode_.reserve(256)",
          "new_text": null,
          "old_line_content": "    snode_.reserve(256);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": "describe",
          "new_api": null,
          "old_text": "XGBOOST_REGISTER_TREE_UPDATER(FastHistMaker, \"grow_fast_histmaker\")\n.describe(\"(Deprecated, use grow_quantile_histmaker instead.)\"\n          \" Grow tree using quantized histogram.\")\n.set_body(\n    []() {\n      LOG(WARNING) << \"grow_fast_histmaker is deprecated, \"\n                   << \"use grow_quantile_histmaker instead.\";\n      return new QuantileHistMaker();\n    })",
          "new_text": null,
          "old_line_content": "XGBOOST_REGISTER_TREE_UPDATER(FastHistMaker, \"grow_fast_histmaker\")",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": "reset",
          "new_api": null,
          "old_text": "qexpand_loss_guided_.reset(new ExpandQueue(LossGuide))",
          "new_text": null,
          "old_line_content": "      qexpand_loss_guided_.reset(new ExpandQueue(LossGuide));",
          "new_line_content": "    if (param_.grow_policy == TrainParam::kLossGuide) {",
          "content_same": false
        },
        {
          "line": 1392,
          "old_api": "LOG",
          "new_api": null,
          "old_text": "LOG(WARNING)",
          "new_text": null,
          "old_line_content": "      LOG(WARNING) << \"grow_fast_histmaker is deprecated, \"",
          "new_line_content": "    []() {",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "clear",
          "new_api": null,
          "old_text": "qexpand_depth_wise_.clear()",
          "new_text": null,
          "old_line_content": "      qexpand_depth_wise_.clear();",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": "Stop",
          "new_api": null,
          "old_text": "builder_monitor_.Stop(\"InitData\")",
          "new_text": null,
          "old_line_content": "  builder_monitor_.Stop(\"InitData\");",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": "describe",
          "new_api": null,
          "old_text": "XGBOOST_REGISTER_TREE_UPDATER(QuantileHistMaker, \"grow_quantile_histmaker\")\n.describe(\"Grow tree using quantized histogram.\")\n.set_body(\n    []() {\n      return new QuantileHistMaker();\n    })",
          "new_text": null,
          "old_line_content": "XGBOOST_REGISTER_TREE_UPDATER(QuantileHistMaker, \"grow_quantile_histmaker\")",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": "GetHess",
          "new_api": null,
          "old_text": "snode.stats.GetHess()",
          "new_text": null,
          "old_line_content": "  if (e.GetGrad() == snode.stats.GetGrad() && e.GetHess() == snode.stats.GetHess()) {",
          "new_line_content": "    const GradStats e, const NodeEntry &snode) {",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": "Start",
          "new_api": null,
          "old_text": "builder_monitor_.Start(\"EvaluateSplits\")",
          "new_text": null,
          "old_line_content": "  builder_monitor_.Start(\"EvaluateSplits\");",
          "new_line_content": "                                               const RegTree& tree) {",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": "size",
          "new_api": null,
          "old_text": "nodes_set.size()",
          "new_text": null,
          "old_line_content": "  const size_t n_nodes_in_set = nodes_set.size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": "resize",
          "new_api": null,
          "old_text": "best_split_tloc_.resize(nthread * n_nodes_in_set)",
          "new_text": null,
          "old_line_content": "  best_split_tloc_.resize(nthread * n_nodes_in_set);",
          "new_line_content": "  std::vector<FeatureSetType> features_sets(n_nodes_in_set);",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": "GetDepth",
          "new_api": null,
          "old_text": "tree.GetDepth(nid)",
          "new_text": null,
          "old_line_content": "    features_sets[nid_in_set] = column_sampler_.GetFeatureSet(tree.GetDepth(nid));",
          "new_line_content": "    const int32_t nid = nodes_set[nid_in_set].nid;",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "Size",
          "new_api": null,
          "old_text": "features_sets[0]->Size()",
          "new_text": null,
          "old_line_content": "  const size_t grain_size = std::max<size_t>(1, features_sets[0]->Size() / nthread);",
          "new_line_content": "  // to process them in parallel",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "Size",
          "new_api": null,
          "old_text": "features_sets[nid_in_set]->Size()",
          "new_text": null,
          "old_line_content": "      return features_sets[nid_in_set]->Size();",
          "new_line_content": "  common::BlockedSpace2d space(n_nodes_in_set, [&](size_t nid_in_set) {",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": "GetEvaluator",
          "new_api": null,
          "old_text": "tree_evaluator_.GetEvaluator()",
          "new_text": null,
          "old_line_content": "  auto evaluator = tree_evaluator_.GetEvaluator();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": "begin",
          "new_api": null,
          "old_text": "common::ParallelFor2d(space, this->nthread_, [&](size_t nid_in_set, common::Range1d r) {\n    const int32_t nid = nodes_set[nid_in_set].nid;\n    const auto tid = static_cast<unsigned>(omp_get_thread_num());\n    GHistRowT node_hist = hist[nid];\n\n    for (auto idx_in_feature_set = r.begin(); idx_in_feature_set < r.end(); ++idx_in_feature_set) {\n      const auto fid = features_sets[nid_in_set]->ConstHostVector()[idx_in_feature_set];\n      if (interaction_constraints_.Query(nid, fid)) {\n        auto grad_stats = this->EnumerateSplit<+1>(\n            gmat, node_hist, snode_[nid],\n            &best_split_tloc_[nthread * nid_in_set + tid], fid, nid, evaluator);\n        if (SplitContainsMissingValues(grad_stats, snode_[nid])) {\n          this->EnumerateSplit<-1>(\n              gmat, node_hist, snode_[nid],\n              &best_split_tloc_[nthread * nid_in_set + tid], fid, nid,\n              evaluator);\n        }\n      }\n    }\n  })",
          "new_text": null,
          "old_line_content": "  common::ParallelFor2d(space, this->nthread_, [&](size_t nid_in_set, common::Range1d r) {",
          "new_line_content": "  // Start parallel enumeration for all tree nodes in the set and all features",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "omp_get_thread_num",
          "new_api": null,
          "old_text": "omp_get_thread_num()",
          "new_text": null,
          "old_line_content": "    const auto tid = static_cast<unsigned>(omp_get_thread_num());",
          "new_line_content": "    const int32_t nid = nodes_set[nid_in_set].nid;",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "end",
          "new_api": null,
          "old_text": "r.end()",
          "new_text": null,
          "old_line_content": "    for (auto idx_in_feature_set = r.begin(); idx_in_feature_set < r.end(); ++idx_in_feature_set) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": "SplitContainsMissingValues",
          "new_api": null,
          "old_text": "SplitContainsMissingValues(grad_stats, snode_[nid])",
          "new_text": null,
          "old_line_content": "        if (SplitContainsMissingValues(grad_stats, snode_[nid])) {",
          "new_line_content": "            &best_split_tloc_[nthread * nid_in_set + tid], fid, nid, evaluator);",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": "Update",
          "new_api": null,
          "old_text": "snode_[nid].best.Update(best_split_tloc_[nthread*nid_in_set + tid])",
          "new_text": null,
          "old_line_content": "      snode_[nid].best.Update(best_split_tloc_[nthread*nid_in_set + tid]);",
          "new_line_content": "    for (unsigned tid = 0; tid < nthread; ++tid) {",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": "Stop",
          "new_api": null,
          "old_text": "builder_monitor_.Stop(\"EvaluateSplits\")",
          "new_text": null,
          "old_line_content": "  builder_monitor_.Stop(\"EvaluateSplits\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": "GetBaseIdx",
          "new_api": null,
          "old_text": "column.GetBaseIdx()",
          "new_text": null,
          "old_line_content": "  const int32_t offset = column.GetBaseIdx();",
          "new_line_content": "      common::Span<size_t> left_part, common::Span<size_t> right_part) {",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": "IsMissing",
          "new_api": null,
          "old_text": "column.IsMissing(rid)",
          "new_text": null,
          "old_line_content": "      if (column.IsMissing(rid)) {",
          "new_line_content": "    for (auto rid : rid_span) {",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": "static_cast<int32_t>(idx[rid])",
          "new_api": null,
          "old_text": "static_cast<int32_t>(idx[rid])",
          "new_text": null,
          "old_line_content": "        if ((static_cast<int32_t>(idx[rid]) + offset) <= split_cond) {",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": "static_cast<int32_t>(idx[rid])",
          "new_api": null,
          "old_text": "static_cast<int32_t>(idx[rid])",
          "new_text": null,
          "old_line_content": "      if ((static_cast<int32_t>(idx[rid]) + offset) <= split_cond) {",
          "new_line_content": "    for (auto rid : rid_span)  {",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "data",
          "new_api": null,
          "old_text": "left_part.data()",
          "new_text": null,
          "old_line_content": "  size_t* p_left_part  = left_part.data();",
          "new_line_content": "  common::Span<size_t> right_part) {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 57,
      "total_additions": 122,
      "total_deletions": 120,
      "total_api_changes": 299
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 7,
        "api_related_lines": 299,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          704
        ]
      }
    },
    "api_calls_before": 508,
    "api_calls_after": 511,
    "diff_info": {
      "added_lines": 4,
      "removed_lines": 3,
      "total_diff_lines": 27
    }
  }
}