{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/042c976800cda56bb32b461cdc8efe1b1ac321f8",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/042c976800cda56bb32b461cdc8efe1b1ac321f8/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/042c976800cda56bb32b461cdc8efe1b1ac321f8/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/042c976800cda56bb32b461cdc8efe1b1ac321f8/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 106,
          "old_api": "FlatVector::GetData<T>(result)",
          "new_api": "GetData",
          "old_text": "FlatVector::GetData<T>(result)",
          "new_text": "current_mask.GetData()",
          "old_line_content": "\tauto result_data = FlatVector::GetData<T>(result);",
          "new_line_content": "\t\tmemcpy(result_mask.GetData(), current_mask.GetData(), ValidityMask::STANDARD_MASK_SIZE);",
          "content_same": false
        },
        {
          "line": 167,
          "old_api": "FlatVector::Validity(result)",
          "new_api": "GetVectorType",
          "old_text": "FlatVector::Validity(result)",
          "new_text": "result.GetVectorType()",
          "old_line_content": "\tauto &result_mask = FlatVector::Validity(result);",
          "new_line_content": "\tD_ASSERT(result.GetVectorType() == VectorType::FLAT_VECTOR);",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": "FlatVector::Validity(result)",
          "new_api": "GetVectorType",
          "old_text": "FlatVector::Validity(result)",
          "new_text": "result.GetVectorType()",
          "old_line_content": "\tauto &result_mask = FlatVector::Validity(result);",
          "new_line_content": "\tD_ASSERT(result.GetVectorType() == VectorType::FLAT_VECTOR);",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": "CleanupUpdateInternal",
          "new_api": "D_ASSERT",
          "old_text": "CleanupUpdateInternal(*lock_handle, info)",
          "new_text": "D_ASSERT(info->prev)",
          "old_line_content": "\tCleanupUpdateInternal(*lock_handle, info);",
          "new_line_content": "\tD_ASSERT(info->prev);",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "memcpy",
          "new_api": "RowIsValidUnsafe",
          "old_text": "memcpy(base_info_data, result_values, result_offset * sizeof(T))",
          "new_text": "base_info_mask.RowIsValidUnsafe(bidx)",
          "old_line_content": "\tmemcpy(base_info_data, result_values, result_offset * sizeof(T));",
          "new_line_content": "\t\tresult_mask.Set(result_offset, base_info_mask.RowIsValidUnsafe(bidx));",
          "content_same": false
        },
        {
          "line": 704,
          "old_api": "AllValid",
          "new_api": "NotImplementedException",
          "old_text": "mask.AllValid()",
          "new_text": "NotImplementedException(\"Unimplemented type for uncompressed segment\")",
          "old_line_content": "\tif (mask.AllValid()) {",
          "new_line_content": "\t\tthrow NotImplementedException(\"Unimplemented type for uncompressed segment\");",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": "FlatVector::Validity(update)",
          "new_api": "RowIsValid",
          "old_text": "FlatVector::Validity(update)",
          "new_text": "mask.RowIsValid(i)",
          "old_line_content": "\tauto &mask = FlatVector::Validity(update);",
          "new_line_content": "\t\t\tif (mask.RowIsValid(i)) {",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": "AllValid",
          "new_api": "NumericStatistics::Update<T>(stats, update_data[i])",
          "old_text": "mask.AllValid()",
          "new_text": "NumericStatistics::Update<T>(stats, update_data[i])",
          "old_line_content": "\tif (mask.AllValid()) {",
          "new_line_content": "\t\t\t\tNumericStatistics::Update<T>(stats, update_data[i]);",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": "RowIsValid",
          "new_api": "FlatVector::GetData<string_t>(update)",
          "old_text": "mask.RowIsValid(i)",
          "new_text": "FlatVector::GetData<string_t>(update)",
          "old_line_content": "\t\t\tif (mask.RowIsValid(i)) {",
          "new_line_content": "\tauto update_data = FlatVector::GetData<string_t>(update);",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": "Update",
          "new_api": "FlatVector::Validity(update)",
          "old_text": "(StringStatistics &) *stats.statistics).Update(update_data[i])",
          "new_text": "FlatVector::Validity(update)",
          "old_line_content": "\t\t\t\t((StringStatistics &) *stats.statistics).Update(update_data[i]);",
          "new_line_content": "\tauto &mask = FlatVector::Validity(update);",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "IsInlined",
          "new_api": "AllValid",
          "old_text": "update_data[i].IsInlined()",
          "new_text": "mask.AllValid()",
          "old_line_content": "\t\t\t\tif (!update_data[i].IsInlined()) {",
          "new_line_content": "\tif (mask.AllValid()) {",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "make_unique<UpdateNode>()",
          "new_api": "statistics_update_function",
          "old_text": "make_unique<UpdateNode>()",
          "new_text": "statistics_update_function(this, stats, update, count)",
          "old_line_content": "\t\troot = make_unique<UpdateNode>();",
          "new_line_content": "\tstatistics_update_function(this, stats, update, count);",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": "make_unique<UpdateInfo>()",
          "new_api": "Verify",
          "old_text": "make_unique<UpdateInfo>()",
          "new_text": "node->Verify()",
          "old_line_content": "\t\tresult->info = make_unique<UpdateInfo>();",
          "new_line_content": "\t\tnode->Verify();",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": "get",
          "new_api": "merge_update_function",
          "old_text": "result->tuples.get()",
          "new_text": "merge_update_function(stats, base_info, base_data, node, update, ids, count)",
          "old_line_content": "\t\tresult->info->tuples = result->tuples.get();",
          "new_line_content": "\t\tmerge_update_function(stats, base_info, base_data, node, update, ids, count);",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "CreateUpdateInfo",
          "new_api": "make_unique<UpdateInfo>()",
          "old_text": "transaction.CreateUpdateInfo(type_size, count)",
          "new_text": "make_unique<UpdateInfo>()",
          "old_line_content": "\t\tauto transaction_node = transaction.CreateUpdateInfo(type_size, count);",
          "new_line_content": "\t\tresult->info = make_unique<UpdateInfo>();",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": "InitializeUpdateInfo",
          "new_api": "unique_ptr<sel_t[]>(new sel_t[STANDARD_VECTOR_SIZE])",
          "old_text": "InitializeUpdateInfo(*transaction_node, ids, count, vector_index, vector_offset)",
          "new_text": "unique_ptr<sel_t[]>(new sel_t[STANDARD_VECTOR_SIZE])",
          "old_line_content": "\t\tInitializeUpdateInfo(*transaction_node, ids, count, vector_index, vector_offset);",
          "new_line_content": "\t\tresult->tuples = unique_ptr<sel_t[]>(new sel_t[STANDARD_VECTOR_SIZE]);",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "Verify",
          "new_api": "CreateUpdateInfo",
          "old_text": "transaction_node->Verify()",
          "new_text": "transaction.CreateUpdateInfo(type_size, count)",
          "old_line_content": "\t\ttransaction_node->Verify();",
          "new_line_content": "\t\tauto transaction_node = transaction.CreateUpdateInfo(type_size, count);",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": "Verify",
          "new_api": "InitializeUpdateInfo",
          "old_text": "result->info->Verify()",
          "new_text": "InitializeUpdateInfo(*transaction_node, ids, count, vector_index, vector_offset)",
          "old_line_content": "\t\tresult->info->Verify();",
          "new_line_content": "\t\tInitializeUpdateInfo(*transaction_node, ids, count, vector_index, vector_offset);",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": "get",
          "new_api": "GetStatistics",
          "old_text": "root->info[vector_index].get()",
          "new_text": "GetStatistics()",
          "old_line_content": "\treturn root->info[vector_index].get();",
          "new_line_content": "\tcolumn_data.MergeStatistics(*GetStatistics().statistics);",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": "HasUpdates",
          "new_api": "get",
          "old_text": "HasUpdates(vector_index)",
          "new_text": "root.get()",
          "old_line_content": "\tif (!HasUpdates(vector_index)) {",
          "new_line_content": "\treturn root.get() != nullptr;",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": "get",
          "new_api": "HasUpdates",
          "old_text": "root->info[vector_index].get()",
          "new_text": "HasUpdates()",
          "old_line_content": "\tauto entry = root->info[vector_index].get();",
          "new_line_content": "\tif (!HasUpdates()) {",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 519,
          "old_api": null,
          "new_api": "NotImplementedException",
          "old_text": null,
          "new_text": "NotImplementedException(\"Unimplemented type for update segment\")",
          "old_line_content": "\tidx_t count = 0;",
          "new_line_content": "\t\tthrow NotImplementedException(\"Unimplemented type for update segment\");",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": null,
          "new_api": "merge",
          "old_text": null,
          "new_text": "merge(a_id, aidx, bidx, count)",
          "old_line_content": "\t\t\tcount++;",
          "new_line_content": "\t\t\tmerge(a_id, aidx, bidx, count);",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": null,
          "new_api": "pick_a",
          "old_text": null,
          "new_text": "pick_a(a_id, aidx, count)",
          "old_line_content": "\t\tcount++;",
          "new_line_content": "\t\t\tpick_a(a_id, aidx, count);",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": null,
          "new_api": "pick_b",
          "old_text": null,
          "new_text": "pick_b(b_id, bidx, count)",
          "old_line_content": "\t\tcount++;",
          "new_line_content": "\t\t\tpick_b(b_id, bidx, count);",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": null,
          "new_api": "pick_a",
          "old_text": null,
          "new_text": "pick_a(a[aidx] - aoffset, aidx, count)",
          "old_line_content": "static void MergeUpdateLoop(SegmentStatistics &stats, UpdateInfo *base_info, Vector &base_data, UpdateInfo *update_info, Vector &update, row_t *ids, idx_t count) {",
          "new_line_content": "\t\tpick_a(a[aidx] - aoffset, aidx, count);",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": null,
          "new_api": "pick_b",
          "old_text": null,
          "new_text": "pick_b(b[bidx], bidx, count)",
          "old_line_content": "\tfor(idx_t i = 1; i < count; i++) {",
          "new_line_content": "\t\tpick_b(b[bidx], bidx, count);",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": null,
          "new_api": "row_t",
          "old_text": null,
          "new_text": "row_t(base_id + STANDARD_VECTOR_SIZE)",
          "old_line_content": "\tauto base_info_data = (T *)base_info->tuple_data;",
          "new_line_content": "\t\tD_ASSERT(ids[i] > ids[i - 1] && ids[i] >= row_t(base_id) && ids[i] < row_t(base_id + STANDARD_VECTOR_SIZE));",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": null,
          "new_api": "FlatVector::GetData<T>(base_data)",
          "old_text": null,
          "new_text": "FlatVector::GetData<T>(base_data)",
          "old_line_content": "\t// what we are trying to do here is update the \"update_info\" of this transaction with all the old data we require",
          "new_line_content": "\tauto base_table_data = FlatVector::GetData<T>(base_data);",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": null,
          "new_api": "FlatVector::GetData<T>(update)",
          "old_text": null,
          "new_text": "FlatVector::GetData<T>(update)",
          "old_line_content": "\t// this means we need to merge (1) any previously updated values (stored in update_info->tuples)",
          "new_line_content": "\tauto update_vector_data = FlatVector::GetData<T>(update);",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": null,
          "new_api": "FlatVector::Validity(base_data)",
          "old_text": null,
          "new_text": "FlatVector::Validity(base_data)",
          "old_line_content": "\tT result_values[STANDARD_VECTOR_SIZE];",
          "new_line_content": "\tauto &base_table_mask = FlatVector::Validity(base_data);",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": null,
          "new_api": "FlatVector::Validity(update)",
          "old_text": null,
          "new_text": "FlatVector::Validity(update)",
          "old_line_content": "\tvalidity_t result_validity[ValidityMask::STANDARD_ENTRY_COUNT];",
          "new_line_content": "\tauto &update_vector_mask = FlatVector::Validity(update);",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": null,
          "new_api": "RowIsValidUnsafe",
          "old_text": null,
          "new_text": "update_info_mask.RowIsValidUnsafe(update_info_offset)",
          "old_line_content": "\t\t\tcontinue;",
          "new_line_content": "\t\t\tresult_mask.Set(result_offset, update_info_mask.RowIsValidUnsafe(update_info_offset));",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": null,
          "new_api": "RowIsValidUnsafe",
          "old_text": null,
          "new_text": "update_info_mask.RowIsValidUnsafe(update_info_offset)",
          "old_line_content": "\t\t\t// it is! we have to move the tuple from base_info->ids[base_info_offset] to update_info",
          "new_line_content": "\t\t\tresult_mask.Set(result_offset, update_info_mask.RowIsValidUnsafe(update_info_offset));",
          "content_same": false
        },
        {
          "line": 104,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(result_data, info_data, sizeof(T) * current->N)",
          "old_line_content": "template <class T>",
          "new_line_content": "\t\tmemcpy(result_data, info_data, sizeof(T) * current->N);",
          "content_same": false
        },
        {
          "line": 105,
          "old_api": null,
          "new_api": "EnsureWritable",
          "old_text": null,
          "new_text": "result_mask.EnsureWritable()",
          "old_line_content": "static void UpdateMergeFetch(transaction_t start_time, transaction_t transaction_id, UpdateInfo *info, Vector &result) {",
          "new_line_content": "\t\tresult_mask.EnsureWritable();",
          "content_same": false
        },
        {
          "line": 110,
          "old_api": null,
          "new_api": "RowIsValidUnsafe",
          "old_text": null,
          "new_text": "current_mask.RowIsValidUnsafe(i)",
          "old_line_content": "\t});",
          "new_line_content": "\t\t\tresult_mask.Set(current->tuples[i], current_mask.RowIsValidUnsafe(i));",
          "content_same": false
        },
        {
          "line": 117,
          "old_api": null,
          "new_api": "FlatVector::GetData<T>(result)",
          "old_text": null,
          "new_text": "FlatVector::GetData<T>(result)",
          "old_line_content": "\t\treturn UpdateMergeFetch<int8_t>;",
          "new_line_content": "\tauto result_data = FlatVector::GetData<T>(result);",
          "content_same": false
        },
        {
          "line": 118,
          "old_api": null,
          "new_api": "FlatVector::Validity(result)",
          "old_text": null,
          "new_text": "FlatVector::Validity(result)",
          "old_line_content": "\tcase PhysicalType::INT16:",
          "new_line_content": "\tauto &result_mask = FlatVector::Validity(result);",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": null,
          "new_api": "RowIsValid",
          "old_text": null,
          "new_text": "base_table_mask.RowIsValid(update_id)",
          "old_line_content": "\t// now copy them back",
          "new_line_content": "\t\t\tresult_mask.Set(result_offset, base_table_mask.RowIsValid(update_id));",
          "content_same": false
        },
        {
          "line": 119,
          "old_api": null,
          "new_api": "UpdateInfo::UpdatesForTransaction(info, start_time, transaction_id, [&](UpdateInfo *current) {\n\t\tMergeUpdateInfo<T>(current, result_data, result_mask);\n\t})",
          "old_text": null,
          "new_text": "UpdateInfo::UpdatesForTransaction(info, start_time, transaction_id, [&](UpdateInfo *current) {\n\t\tMergeUpdateInfo<T>(current, result_data, result_mask);\n\t})",
          "old_line_content": "\t\treturn UpdateMergeFetch<int16_t>;",
          "new_line_content": "\tUpdateInfo::UpdatesForTransaction(info, start_time, transaction_id, [&](UpdateInfo *current) {",
          "content_same": false
        },
        {
          "line": 120,
          "old_api": null,
          "new_api": "MergeUpdateInfo<T>(current, result_data, result_mask)",
          "old_text": null,
          "new_text": "MergeUpdateInfo<T>(current, result_data, result_mask)",
          "old_line_content": "\tcase PhysicalType::INT32:",
          "new_line_content": "\t\tMergeUpdateInfo<T>(current, result_data, result_mask);",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": null,
          "new_api": "RowIsValidUnsafe",
          "old_text": null,
          "new_text": "update_info_mask.RowIsValidUnsafe(update_info_offset)",
          "old_line_content": "\tresult_offset = 0;",
          "new_line_content": "\t\tresult_mask.Set(result_offset, update_info_mask.RowIsValidUnsafe(update_info_offset));",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(update_info_data, result_values, result_offset * sizeof(T))",
          "old_line_content": "\t};",
          "new_line_content": "\tmemcpy(update_info_data, result_values, result_offset * sizeof(T));",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(update_info->validity, result_validity, ValidityMask::STANDARD_ENTRY_COUNT * sizeof(validity_t))",
          "old_line_content": "\tauto pick_old = [&](idx_t id, idx_t bidx, idx_t count) {",
          "new_line_content": "\tmemcpy(update_info->validity, result_validity, ValidityMask::STANDARD_ENTRY_COUNT * sizeof(validity_t));",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(update_info->tuples, result_ids, result_offset * sizeof(sel_t))",
          "old_line_content": "\t\tresult_values[result_offset] = base_info_data[bidx];",
          "new_line_content": "\tmemcpy(update_info->tuples, result_ids, result_offset * sizeof(sel_t));",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": null,
          "new_api": "RowIsValid",
          "old_text": null,
          "new_text": "update_vector_mask.RowIsValid(aidx)",
          "old_line_content": "\tauto merge = [&](idx_t id, idx_t aidx, idx_t bidx, idx_t count) {",
          "new_line_content": "\t\tresult_mask.Set(result_offset, update_vector_mask.RowIsValid(aidx));",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "pick_new",
          "old_text": null,
          "new_text": "pick_new(id, aidx, count)",
          "old_line_content": "\tswitch (type) {",
          "new_line_content": "\t\tpick_new(id, aidx, count);",
          "content_same": false
        },
        {
          "line": 154,
          "old_api": null,
          "new_api": "NotImplementedException",
          "old_text": null,
          "new_text": "NotImplementedException(\"Unimplemented type for update segment\")",
          "old_line_content": "\t}",
          "new_line_content": "\t\tthrow NotImplementedException(\"Unimplemented type for update segment\");",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": null,
          "new_api": "merge_loop",
          "old_text": null,
          "new_text": "merge_loop(ids, base_info->tuples, count, base_info->N, base_id, merge, pick_new, pick_old)",
          "old_line_content": "\tcase PhysicalType::INT8:",
          "new_line_content": "\tmerge_loop(ids, base_info->tuples, count, base_info->N, base_id, merge, pick_new, pick_old);",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(base_info_data, result_values, result_offset * sizeof(T))",
          "old_line_content": "\t\treturn MergeUpdateLoop<int16_t>;",
          "new_line_content": "\tmemcpy(base_info_data, result_values, result_offset * sizeof(T));",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(base_info->validity, result_validity, ValidityMask::STANDARD_ENTRY_COUNT * sizeof(validity_t))",
          "old_line_content": "\tcase PhysicalType::INT32:",
          "new_line_content": "\tmemcpy(base_info->validity, result_validity, ValidityMask::STANDARD_ENTRY_COUNT * sizeof(validity_t));",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(base_info->tuples, result_ids, result_offset * sizeof(sel_t))",
          "old_line_content": "\t\treturn MergeUpdateLoop<int32_t>;",
          "new_line_content": "\tmemcpy(base_info->tuples, result_ids, result_offset * sizeof(sel_t));",
          "content_same": false
        },
        {
          "line": 162,
          "old_api": null,
          "new_api": "GetSharedLock",
          "old_text": null,
          "new_text": "lock.GetSharedLock()",
          "old_line_content": "// Fetch Committed",
          "new_line_content": "\tauto lock_handle = lock.GetSharedLock();",
          "content_same": false
        },
        {
          "line": 169,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "root->info[vector_index]->info.get()",
          "old_line_content": "}",
          "new_line_content": "\tfetch_update_function(transaction.start_time, transaction.transaction_id, root->info[vector_index]->info.get(), result);",
          "content_same": false
        },
        {
          "line": 177,
          "old_api": null,
          "new_api": "FlatVector::GetData<T>(result)",
          "old_text": null,
          "new_text": "FlatVector::GetData<T>(result)",
          "old_line_content": "\t\treturn TemplatedFetchCommitted<int16_t>;",
          "new_line_content": "\tauto result_data = FlatVector::GetData<T>(result);",
          "content_same": false
        },
        {
          "line": 178,
          "old_api": null,
          "new_api": "FlatVector::Validity(result)",
          "old_text": null,
          "new_text": "FlatVector::Validity(result)",
          "old_line_content": "\tcase PhysicalType::INT32:",
          "new_line_content": "\tauto &result_mask = FlatVector::Validity(result);",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": null,
          "new_api": "MergeUpdateInfo<T>(info, result_data, result_mask)",
          "old_text": null,
          "new_text": "MergeUpdateInfo<T>(info, result_data, result_mask)",
          "old_line_content": "\t\treturn TemplatedFetchCommitted<int32_t>;",
          "new_line_content": "\tMergeUpdateInfo<T>(info, result_data, result_mask);",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": null,
          "new_api": "FlatVector::GetData<T>(update)",
          "old_text": null,
          "new_text": "FlatVector::GetData<T>(update)",
          "old_line_content": "\t\t\t\tstats.statistics->has_null = true;",
          "new_line_content": "\tauto update_data = FlatVector::GetData<T>(update);",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": null,
          "new_api": "FlatVector::Validity(update)",
          "old_text": null,
          "new_text": "FlatVector::Validity(update)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\tauto &mask = FlatVector::Validity(update);",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": null,
          "new_api": "AllValid",
          "old_text": null,
          "new_text": "mask.AllValid()",
          "old_line_content": "\t\t}",
          "new_line_content": "\tif (mask.AllValid()) {",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": null,
          "new_api": "NumericStatistics::Update<T>(stats, update_data[i])",
          "old_text": null,
          "new_text": "NumericStatistics::Update<T>(stats, update_data[i])",
          "old_line_content": "}",
          "new_line_content": "\t\t\tNumericStatistics::Update<T>(stats, update_data[i]);",
          "content_same": false
        },
        {
          "line": 212,
          "old_api": null,
          "new_api": "NotImplementedException",
          "old_text": null,
          "new_text": "NotImplementedException(\"Unimplemented type for update segment\")",
          "old_line_content": "\t// FIXME: normalify if this is not the case... need to pass in count?",
          "new_line_content": "\t\tthrow NotImplementedException(\"Unimplemented type for update segment\");",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": null,
          "new_api": "Update",
          "old_text": null,
          "new_text": "(StringStatistics &) *stats.statistics).Update(update_data[i])",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\t((StringStatistics &) *stats.statistics).Update(update_data[i]);",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": null,
          "new_api": "IsInlined",
          "old_text": null,
          "new_text": "update_data[i].IsInlined()",
          "old_line_content": "\t\t\t} else {",
          "new_line_content": "\t\t\tif (!update_data[i].IsInlined()) {",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": null,
          "new_api": "AddString",
          "old_text": null,
          "new_text": "segment->GetStringHeap().AddString(update_data[i])",
          "old_line_content": "\t\t\t\tstats.statistics->has_null = true;",
          "new_line_content": "\t\t\t\tupdate_data[i] = segment->GetStringHeap().AddString(update_data[i]);",
          "content_same": false
        },
        {
          "line": 226,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "root->info[vector_index]->info.get()",
          "old_line_content": "\t\tValidityMask current_mask(current->validity);",
          "new_line_content": "\tfetch_committed_function(root->info[vector_index]->info.get(), result);",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": null,
          "new_api": "RowIsValid",
          "old_text": null,
          "new_text": "mask.RowIsValid(i)",
          "old_line_content": "",
          "new_line_content": "\t\t\tif (mask.RowIsValid(i)) {",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": null,
          "new_api": "Update",
          "old_text": null,
          "new_text": "(StringStatistics &) *stats.statistics).Update(update_data[i])",
          "old_line_content": "UpdateSegment::statistics_update_function_t GetStatisticsUpdateFunction(PhysicalType type) {",
          "new_line_content": "\t\t\t\t((StringStatistics &) *stats.statistics).Update(update_data[i]);",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": null,
          "new_api": "IsInlined",
          "old_text": null,
          "new_text": "update_data[i].IsInlined()",
          "old_line_content": "\tswitch (type) {",
          "new_line_content": "\t\t\t\tif (!update_data[i].IsInlined()) {",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "AddString",
          "old_text": null,
          "new_text": "segment->GetStringHeap().AddString(update_data[i])",
          "old_line_content": "\tcase PhysicalType::BOOL:",
          "new_line_content": "\t\t\t\t\tupdate_data[i] = segment->GetStringHeap().AddString(update_data[i]);",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": null,
          "new_api": "FlatVector::GetData<T>(result)",
          "old_text": null,
          "new_text": "FlatVector::GetData<T>(result)",
          "old_line_content": "\t\t\t} else if (current->tuples[i] > row_idx) {",
          "new_line_content": "\tauto result_data = FlatVector::GetData<T>(result);",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": null,
          "new_api": "FlatVector::Validity(result)",
          "old_text": null,
          "new_text": "FlatVector::Validity(result)",
          "old_line_content": "\t\t\t\tbreak;",
          "new_line_content": "\tauto &result_mask = FlatVector::Validity(result);",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": null,
          "new_api": "Set",
          "old_text": null,
          "new_text": "UpdateInfo::UpdatesForTransaction(info, start_time, transaction_id, [&](UpdateInfo *current) {\n\t\tValidityMask current_mask(current->validity);\n\t\tauto info_data = (T *)current->tuple_data;\n\t\t// FIXME: we could do a binary search in here\n\t\tfor (idx_t i = 0; i < current->N; i++) {\n\t\t\tif (current->tuples[i] == row_idx) {\n\t\t\t\tresult_data[result_idx] = info_data[i];\n\t\t\t\tresult_mask.Set(result_idx, current_mask.RowIsValidUnsafe(i));\n\t\t\t\tbreak;\n\t\t\t} else if (current->tuples[i] > row_idx) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t})",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\tUpdateInfo::UpdatesForTransaction(info, start_time, transaction_id, [&](UpdateInfo *current) {",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": null,
          "new_api": "RowIsValidUnsafe",
          "old_text": null,
          "new_text": "current_mask.RowIsValidUnsafe(i)",
          "old_line_content": "\tcase PhysicalType::BOOL:",
          "new_line_content": "\t\t\t\tresult_mask.Set(result_idx, current_mask.RowIsValidUnsafe(i));",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": null,
          "new_api": "NotImplementedException",
          "old_text": null,
          "new_text": "NotImplementedException(\"Unimplemented type for uncompressed segment\")",
          "old_line_content": "\t// update statistics",
          "new_line_content": "\t\tthrow NotImplementedException(\"Unimplemented type for uncompressed segment\");",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": null,
          "new_api": "GetExclusiveLock",
          "old_text": null,
          "new_text": "lock.GetExclusiveLock()",
          "old_line_content": "",
          "new_line_content": "\tauto write_lock = lock.GetExclusiveLock();",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": null,
          "new_api": "NotImplementedException",
          "old_text": null,
          "new_text": "NotImplementedException(\"Unimplemented type for update segment fetch row\")",
          "old_line_content": "\t}",
          "new_line_content": "\t\tthrow NotImplementedException(\"Unimplemented type for update segment fetch row\");",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": null,
          "new_api": "D_ASSERT",
          "old_text": null,
          "new_text": "D_ASSERT(ids[i] > ids[i - 1])",
          "old_line_content": "\tauto first_id = ids[0];",
          "new_line_content": "\t\tD_ASSERT(ids[i] > ids[i - 1]);",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "root->info[vector_index]->info.get()",
          "old_line_content": "\tValidityMask rollback_mask(rollback_info->validity);",
          "new_line_content": "\tfetch_row_function(transaction.start_time, transaction.transaction_id, root->info[vector_index]->info.get(), row_in_vector, result, result_idx);",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": null,
          "new_api": "make_unique<UpdateNode>()",
          "old_text": null,
          "new_text": "make_unique<UpdateNode>()",
          "old_line_content": "",
          "new_line_content": "\t\troot = make_unique<UpdateNode>();",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "idx_t",
          "old_text": null,
          "new_text": "idx_t(first_id)",
          "old_line_content": "",
          "new_line_content": "\tD_ASSERT(idx_t(first_id) >= this->start);",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": null,
          "new_api": "D_ASSERT",
          "old_text": null,
          "new_text": "D_ASSERT(vector_index < MORSEL_VECTOR_COUNT)",
          "old_line_content": "\t\t// there are no conflicts",
          "new_line_content": "\tD_ASSERT(vector_index < MORSEL_VECTOR_COUNT);",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": null,
          "new_api": "D_ASSERT",
          "old_text": null,
          "new_text": "D_ASSERT(base_offset < base_info->N)",
          "old_line_content": "\t\treturn RollbackUpdate<int8_t>;",
          "new_line_content": "\t\t\tD_ASSERT(base_offset < base_info->N);",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "root->info[vector_index]->info.get()",
          "old_line_content": "\t\t\tnode = node->next;",
          "new_line_content": "\t\tauto base_info = root->info[vector_index]->info.get();",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": null,
          "new_api": "CheckForConflicts",
          "old_text": null,
          "new_text": "CheckForConflicts(base_info->next, transaction, ids, count, vector_offset, node)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tCheckForConflicts(base_info->next, transaction, ids, count, vector_offset, node);",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": null,
          "new_api": "RowIsValidUnsafe",
          "old_text": null,
          "new_text": "rollback_mask.RowIsValidUnsafe(i)",
          "old_line_content": "\tcase PhysicalType::INT32:",
          "new_line_content": "\t\tbase_mask.Set(base_offset, rollback_mask.RowIsValidUnsafe(i));",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": null,
          "new_api": "CreateUpdateInfo",
          "old_text": null,
          "new_text": "transaction.CreateUpdateInfo(type_size, count)",
          "old_line_content": "\t\t\tbase_info->next = node;",
          "new_line_content": "\t\t\tnode = transaction.CreateUpdateInfo(type_size, count);",
          "content_same": false
        },
        {
          "line": 853,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "base_info->Verify()",
          "old_line_content": "",
          "new_line_content": "\t\tbase_info->Verify();",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "base_info->Verify()",
          "old_line_content": "\t\tresult->info->version_number = TRANSACTION_ID_START - 1;",
          "new_line_content": "\t\tbase_info->Verify();",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "node->Verify()",
          "old_line_content": "\t\tValidityMask result_mask(result->info->validity);",
          "new_line_content": "\t\tnode->Verify();",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": null,
          "new_api": "NotImplementedException",
          "old_text": null,
          "new_text": "NotImplementedException(\"Unimplemented type for uncompressed segment\")",
          "old_line_content": "",
          "new_line_content": "\t\tthrow NotImplementedException(\"Unimplemented type for uncompressed segment\");",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": null,
          "new_api": "make_unique<UpdateNodeData>()",
          "old_text": null,
          "new_text": "make_unique<UpdateNodeData>()",
          "old_line_content": "",
          "new_line_content": "\t\tauto result = make_unique<UpdateNodeData>();",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": null,
          "new_api": "unique_ptr<data_t[]>(new data_t[STANDARD_VECTOR_SIZE * type_size])",
          "old_text": null,
          "new_text": "unique_ptr<data_t[]>(new data_t[STANDARD_VECTOR_SIZE * type_size])",
          "old_line_content": "",
          "new_line_content": "\t\tresult->tuple_data = unique_ptr<data_t[]>(new data_t[STANDARD_VECTOR_SIZE * type_size]);",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": null,
          "new_api": "GetExclusiveLock",
          "old_text": null,
          "new_text": "lock.GetExclusiveLock()",
          "old_line_content": "// Cleanup Update",
          "new_line_content": "\tauto lock_handle = lock.GetExclusiveLock();",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "result->tuples.get()",
          "old_line_content": "\t\t// we write the updates in the",
          "new_line_content": "\t\tresult->info->tuples = result->tuples.get();",
          "content_same": false
        },
        {
          "line": 360,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "root->info[info->vector_index]->info.get()",
          "old_line_content": "\tauto prev = info->prev;",
          "new_line_content": "\trollback_update_function(root->info[info->vector_index]->info.get(), info);",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": null,
          "new_api": "SetAllValid",
          "old_text": null,
          "new_text": "result_mask.SetAllValid(STANDARD_VECTOR_SIZE)",
          "old_line_content": "\t\tresult->info->prev = nullptr;",
          "new_line_content": "\t\tresult_mask.SetAllValid(STANDARD_VECTOR_SIZE);",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": null,
          "new_api": "InitializeUpdateInfo",
          "old_text": null,
          "new_text": "InitializeUpdateInfo(*result->info, ids, count, vector_index, vector_offset)",
          "old_line_content": "\t\ttransaction_node->next = nullptr;",
          "new_line_content": "\t\tInitializeUpdateInfo(*result->info, ids, count, vector_index, vector_offset);",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": null,
          "new_api": "CleanupUpdateInternal",
          "old_text": null,
          "new_text": "CleanupUpdateInternal(*lock_handle, info)",
          "old_line_content": "\t\tprev->next->prev = prev;",
          "new_line_content": "\tCleanupUpdateInternal(*lock_handle, info);",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "result->info.get()",
          "old_line_content": "\t}",
          "new_line_content": "\t\tinitialize_update_function(stats, transaction_node, base_data, result->info.get(), update);",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "transaction_node->Verify()",
          "old_line_content": "",
          "new_line_content": "\t\ttransaction_node->Verify();",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "result->info->Verify()",
          "old_line_content": "bool UpdateSegment::HasUpdates(idx_t vector_index) const {",
          "new_line_content": "\t\tresult->info->Verify();",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(result)",
          "old_line_content": "\t\treturn false;",
          "new_line_content": "\t\troot->info[vector_index] = move(result);",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": null,
          "new_api": "GetExclusiveLock",
          "old_text": null,
          "new_text": "lock.GetExclusiveLock()",
          "old_line_content": "\t}",
          "new_line_content": "\tauto lock_handle = lock.GetExclusiveLock();",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": null,
          "new_api": "CleanupUpdateInternal",
          "old_text": null,
          "new_text": "CleanupUpdateInternal(*lock_handle, info)",
          "old_line_content": "\tif (info->version_number == transaction.transaction_id) {",
          "new_line_content": "\tCleanupUpdateInternal(*lock_handle, info);",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "root->info[vector_index].get()",
          "old_line_content": "\t}",
          "new_line_content": "\treturn root->info[vector_index].get();",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": null,
          "new_api": "HasUpdates",
          "old_text": null,
          "new_text": "HasUpdates(vector_index)",
          "old_line_content": "bool UpdateSegment::HasUpdates(idx_t start_vector_index, idx_t end_vector_index) const {",
          "new_line_content": "\tif (!HasUpdates(vector_index)) {",
          "content_same": false
        },
        {
          "line": 910,
          "old_api": null,
          "new_api": "GetSharedLock",
          "old_text": null,
          "new_text": "lock.GetSharedLock()",
          "old_line_content": "\tauto segment = this;",
          "new_line_content": "\tauto read_lock = lock.GetSharedLock();",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "root->info[vector_index].get()",
          "old_line_content": "\tfor(idx_t i = start_vector_index; i <= end_vector_index; i++) {",
          "new_line_content": "\tauto entry = root->info[vector_index].get();",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": null,
          "new_api": "TransactionException",
          "old_text": null,
          "new_text": "TransactionException(\"Conflict on update!\")",
          "old_line_content": "\t\t\t\t\tbreak;",
          "new_line_content": "\t\t\t\tthrow TransactionException(\"Conflict on update!\");",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "D_ASSERT",
          "old_text": null,
          "new_text": "D_ASSERT(start_vector_index >= base_vector_index)",
          "old_line_content": "\t\t}",
          "new_line_content": "\tD_ASSERT(start_vector_index >= base_vector_index);",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "next.get()",
          "old_line_content": "UpdateSegment *UpdateSegment::FindSegment(idx_t end_vector_index) const {",
          "new_line_content": "\t\t\tsegment = (UpdateSegment*) next.get();",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": null,
          "new_api": "HasUpdates",
          "old_text": null,
          "new_text": "segment->HasUpdates(vector_index)",
          "old_line_content": "\twhile(end_vector_index >= base_vector_index + UpdateSegment::MORSEL_VECTOR_COUNT) {",
          "new_line_content": "\t\tif (segment->HasUpdates(vector_index)) {",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": null,
          "new_api": "CheckForConflicts",
          "old_text": null,
          "new_text": "CheckForConflicts(info->next, transaction, ids, count, offset, node)",
          "old_line_content": "",
          "new_line_content": "\tCheckForConflicts(info->next, transaction, ids, count, offset, node);",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "D_ASSERT",
          "old_text": null,
          "new_text": "D_ASSERT(end_vector_index >= base_vector_index)",
          "old_line_content": "",
          "new_line_content": "\tD_ASSERT(end_vector_index >= base_vector_index);",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "next.get()",
          "old_line_content": "",
          "new_line_content": "\t\tsegment = (UpdateSegment *) next.get();",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": null,
          "new_api": "D_ASSERT",
          "old_text": null,
          "new_text": "D_ASSERT((idx_t)ids[i] >= vector_offset && (idx_t)ids[i] < vector_offset + STANDARD_VECTOR_SIZE)",
          "old_line_content": "\t\ttuple_data[i] = new_data[i];",
          "new_line_content": "\t\tD_ASSERT((idx_t)ids[i] >= vector_offset && (idx_t)ids[i] < vector_offset + STANDARD_VECTOR_SIZE);",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": null,
          "new_api": "RowIsValid",
          "old_text": null,
          "new_text": "tuple_mask.RowIsValid(i)",
          "old_line_content": "}",
          "new_line_content": "\t\tbool is_valid = tuple_mask.RowIsValid(i);",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": null,
          "new_api": "Set",
          "old_text": null,
          "new_text": "tuple_mask.Set(i, is_valid)",
          "old_line_content": "",
          "new_line_content": "\t\ttuple_mask.Set(i, is_valid);",
          "content_same": false
        },
        {
          "line": 457,
          "old_api": null,
          "new_api": "FlatVector::GetData<T>(update)",
          "old_text": null,
          "new_text": "FlatVector::GetData<T>(update)",
          "old_line_content": "\t\tfor (idx_t i = 0; i < update_info->N; i++) {",
          "new_line_content": "\tauto update_data = FlatVector::GetData<T>(update);",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": null,
          "new_api": "FlatVector::Validity(update)",
          "old_text": null,
          "new_text": "FlatVector::Validity(update)",
          "old_line_content": "\t\t\ttuple_data[i] = update_data[i];",
          "new_line_content": "\tauto &update_mask = FlatVector::Validity(update);",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": null,
          "new_api": "AllValid",
          "old_text": null,
          "new_text": "update_mask.AllValid()",
          "old_line_content": "",
          "new_line_content": "\tif (!update_mask.AllValid()) {",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": null,
          "new_api": "RowIsValidUnsafe",
          "old_text": null,
          "new_text": "update_mask.RowIsValidUnsafe(i)",
          "old_line_content": "\tValidityMask base_tuple_mask(base_info->validity);",
          "new_line_content": "\t\t\tinfo_mask.Set(i, update_mask.RowIsValidUnsafe(i));",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": null,
          "new_api": "FlatVector::GetData<T>(base_data)",
          "old_text": null,
          "new_text": "FlatVector::GetData<T>(base_data)",
          "old_line_content": "\t\t\tbase_tuple_data[i] = base_array_data[base_info->tuples[i]];",
          "new_line_content": "\tauto base_array_data = FlatVector::GetData<T>(base_data);",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": null,
          "new_api": "FlatVector::Validity(base_data)",
          "old_text": null,
          "new_text": "FlatVector::Validity(base_data)",
          "old_line_content": "\t\t}",
          "new_line_content": "\tauto &base_mask = FlatVector::Validity(base_data);",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": null,
          "new_api": "AllValid",
          "old_text": null,
          "new_text": "base_mask.AllValid()",
          "old_line_content": "",
          "new_line_content": "\tif (!base_mask.AllValid()) {",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": null,
          "new_api": "RowIsValidUnsafe",
          "old_text": null,
          "new_text": "base_mask.RowIsValidUnsafe(base_info->tuples[i])",
          "old_line_content": "\tcase PhysicalType::BOOL:",
          "new_line_content": "\t\t\tbase_tuple_mask.Set(i, base_mask.RowIsValidUnsafe(base_info->tuples[i]));",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 524,
          "old_api": "merge",
          "new_api": null,
          "old_text": "merge(a_id, aidx, bidx, count)",
          "new_text": null,
          "old_line_content": "\t\t\tmerge(a_id, aidx, bidx, count);",
          "new_line_content": "// Merge update info",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": "pick_a",
          "new_api": null,
          "old_text": "pick_a(a_id, aidx, count)",
          "new_text": null,
          "old_line_content": "\t\t\tpick_a(a_id, aidx, count);",
          "new_line_content": "\tidx_t aidx = 0, bidx = 0;",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": "pick_b",
          "new_api": null,
          "old_text": "pick_b(b_id, bidx, count)",
          "new_text": null,
          "old_line_content": "\t\t\tpick_b(b_id, bidx, count);",
          "new_line_content": "\t\tauto b_id = b[bidx];",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "pick_a",
          "new_api": null,
          "old_text": "pick_a(a[aidx] - aoffset, aidx, count)",
          "new_text": null,
          "old_line_content": "\t\tpick_a(a[aidx] - aoffset, aidx, count);",
          "new_line_content": "\t\t} else if (a_id < b_id) {",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": "pick_b",
          "new_api": null,
          "old_text": "pick_b(b[bidx], bidx, count)",
          "new_text": null,
          "old_line_content": "\t\tpick_b(b[bidx], bidx, count);",
          "new_line_content": "\t\t} else {",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": "row_t",
          "new_api": null,
          "old_text": "row_t(base_id + STANDARD_VECTOR_SIZE)",
          "new_text": null,
          "old_line_content": "\t\tD_ASSERT(ids[i] > ids[i - 1] && ids[i] >= row_t(base_id) && ids[i] < row_t(base_id + STANDARD_VECTOR_SIZE));",
          "new_line_content": "\t\tcount++;",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "FlatVector::GetData<T>(base_data)",
          "new_api": null,
          "old_text": "FlatVector::GetData<T>(base_data)",
          "new_text": null,
          "old_line_content": "\tauto base_table_data = FlatVector::GetData<T>(base_data);",
          "new_line_content": "\t// all of these should be sorted, otherwise the below algorithm does not work",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": "FlatVector::GetData<T>(update)",
          "new_api": null,
          "old_text": "FlatVector::GetData<T>(update)",
          "new_text": null,
          "old_line_content": "\tauto update_vector_data = FlatVector::GetData<T>(update);",
          "new_line_content": "\tfor(idx_t i = 1; i < count; i++) {",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": "FlatVector::Validity(base_data)",
          "new_api": null,
          "old_text": "FlatVector::Validity(base_data)",
          "new_text": null,
          "old_line_content": "\tauto &base_table_mask = FlatVector::Validity(base_data);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": "FlatVector::Validity(update)",
          "new_api": null,
          "old_text": "FlatVector::Validity(update)",
          "new_text": null,
          "old_line_content": "\tauto &update_vector_mask = FlatVector::Validity(update);",
          "new_line_content": "\t// we have a new batch of updates (update, ids, count)",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "RowIsValidUnsafe",
          "new_api": null,
          "old_text": "update_info_mask.RowIsValidUnsafe(update_info_offset)",
          "new_text": null,
          "old_line_content": "\t\t\tresult_mask.Set(result_offset, update_info_mask.RowIsValidUnsafe(update_info_offset));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "RowIsValidUnsafe",
          "new_api": null,
          "old_text": "update_info_mask.RowIsValidUnsafe(update_info_offset)",
          "new_text": null,
          "old_line_content": "\t\t\tresult_mask.Set(result_offset, update_info_mask.RowIsValidUnsafe(update_info_offset));",
          "new_line_content": "\t\twhile(update_info_offset < update_info->N && update_info->tuples[update_info_offset] < update_id) {",
          "content_same": false
        },
        {
          "line": 100,
          "old_api": "RowIsValidUnsafe",
          "new_api": null,
          "old_text": "current_mask.RowIsValidUnsafe(i)",
          "new_text": null,
          "old_line_content": "\t\tresult_mask.Set(current->tuples[i], current_mask.RowIsValidUnsafe(i));",
          "new_line_content": "\tif (current->N == STANDARD_VECTOR_SIZE) {",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": "RowIsValidUnsafe",
          "new_api": null,
          "old_text": "base_info_mask.RowIsValidUnsafe(base_info_offset)",
          "new_text": null,
          "old_line_content": "\t\t\tresult_mask.Set(result_offset, base_info_mask.RowIsValidUnsafe(base_info_offset));",
          "new_line_content": "\t\t\tupdate_info_offset++;",
          "content_same": false
        },
        {
          "line": 107,
          "old_api": "FlatVector::Validity(result)",
          "new_api": null,
          "old_text": "FlatVector::Validity(result)",
          "new_text": null,
          "old_line_content": "\tauto &result_mask = FlatVector::Validity(result);",
          "new_line_content": "\t} else {",
          "content_same": false
        },
        {
          "line": 108,
          "old_api": "UpdateInfo::UpdatesForTransaction(info, start_time, transaction_id, [&](UpdateInfo *current) {\n\t\tMergeUpdateInfo<T>(current, result_data, result_mask);\n\t})",
          "new_api": null,
          "old_text": "UpdateInfo::UpdatesForTransaction(info, start_time, transaction_id, [&](UpdateInfo *current) {\n\t\tMergeUpdateInfo<T>(current, result_data, result_mask);\n\t})",
          "new_text": null,
          "old_line_content": "\tUpdateInfo::UpdatesForTransaction(info, start_time, transaction_id, [&](UpdateInfo *current) {",
          "new_line_content": "\t\tfor (idx_t i = 0; i < current->N; i++) {",
          "content_same": false
        },
        {
          "line": 109,
          "old_api": "MergeUpdateInfo<T>(current, result_data, result_mask)",
          "new_api": null,
          "old_text": "MergeUpdateInfo<T>(current, result_data, result_mask)",
          "new_text": null,
          "old_line_content": "\t\tMergeUpdateInfo<T>(current, result_data, result_mask);",
          "new_line_content": "\t\t\tresult_data[current->tuples[i]] = info_data[i];",
          "content_same": false
        },
        {
          "line": 620,
          "old_api": "RowIsValid",
          "new_api": null,
          "old_text": "base_table_mask.RowIsValid(update_id)",
          "new_text": null,
          "old_line_content": "\t\t\tresult_mask.Set(result_offset, base_table_mask.RowIsValid(update_id));",
          "new_line_content": "\t\t/// now check if we have the current update_id in the base_info, or if we should fetch it from the base data",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(update_info_data, result_values, result_offset * sizeof(T))",
          "new_text": null,
          "old_line_content": "\tmemcpy(update_info_data, result_values, result_offset * sizeof(T));",
          "new_line_content": "\t\tresult_ids[result_offset++] = update_id;",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(update_info->validity, result_validity, ValidityMask::STANDARD_ENTRY_COUNT * sizeof(validity_t))",
          "new_text": null,
          "old_line_content": "\tmemcpy(update_info->validity, result_validity, ValidityMask::STANDARD_ENTRY_COUNT * sizeof(validity_t));",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(update_info->tuples, result_ids, result_offset * sizeof(sel_t))",
          "new_text": null,
          "old_line_content": "\tmemcpy(update_info->tuples, result_ids, result_offset * sizeof(sel_t));",
          "new_line_content": "\t// write any remaining entries from the old updates",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": "RowIsValid",
          "new_api": null,
          "old_text": "update_vector_mask.RowIsValid(aidx)",
          "new_text": null,
          "old_line_content": "\t\tresult_mask.Set(result_offset, update_vector_mask.RowIsValid(aidx));",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "RowIsValidUnsafe",
          "new_api": null,
          "old_text": "base_info_mask.RowIsValidUnsafe(bidx)",
          "new_text": null,
          "old_line_content": "\t\tresult_mask.Set(result_offset, base_info_mask.RowIsValidUnsafe(bidx));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": "pick_new",
          "new_api": null,
          "old_text": "pick_new(id, aidx, count)",
          "new_text": null,
          "old_line_content": "\t\tpick_new(id, aidx, count);",
          "new_line_content": "\t\tresult_ids[result_offset] = id;",
          "content_same": false
        },
        {
          "line": 143,
          "old_api": "NotImplementedException",
          "new_api": null,
          "old_text": "NotImplementedException(\"Unimplemented type for update segment\")",
          "new_text": null,
          "old_line_content": "\t\tthrow NotImplementedException(\"Unimplemented type for update segment\");",
          "new_line_content": "\tcase PhysicalType::INT128:",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": "merge_loop",
          "new_api": null,
          "old_text": "merge_loop(ids, base_info->tuples, count, base_info->N, base_id, merge, pick_new, pick_old)",
          "new_text": null,
          "old_line_content": "\tmerge_loop(ids, base_info->tuples, count, base_info->N, base_id, merge, pick_new, pick_old);",
          "new_line_content": "\t};",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(base_info->validity, result_validity, ValidityMask::STANDARD_ENTRY_COUNT * sizeof(validity_t))",
          "new_text": null,
          "old_line_content": "\tmemcpy(base_info->validity, result_validity, ValidityMask::STANDARD_ENTRY_COUNT * sizeof(validity_t));",
          "new_line_content": "\t\tresult_ids[result_offset] = id;",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(base_info->tuples, result_ids, result_offset * sizeof(sel_t))",
          "new_text": null,
          "old_line_content": "\tmemcpy(base_info->tuples, result_ids, result_offset * sizeof(sel_t));",
          "new_line_content": "\t\tresult_offset++;",
          "content_same": false
        },
        {
          "line": 151,
          "old_api": "GetSharedLock",
          "new_api": null,
          "old_text": "lock.GetSharedLock()",
          "new_text": null,
          "old_line_content": "\tauto lock_handle = lock.GetSharedLock();",
          "new_line_content": "\tcase PhysicalType::VARCHAR:",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": "GetVectorType",
          "new_api": null,
          "old_text": "result.GetVectorType()",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(result.GetVectorType() == VectorType::FLAT_VECTOR);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": "get",
          "new_api": null,
          "old_text": "root->info[vector_index]->info.get()",
          "new_text": null,
          "old_line_content": "\tfetch_update_function(transaction.start_time, transaction.transaction_id, root->info[vector_index]->info.get(), result);",
          "new_line_content": "void UpdateSegment::FetchUpdates(Transaction &transaction, idx_t vector_index, Vector &result) {",
          "content_same": false
        },
        {
          "line": 166,
          "old_api": "FlatVector::GetData<T>(result)",
          "new_api": null,
          "old_text": "FlatVector::GetData<T>(result)",
          "new_text": null,
          "old_line_content": "\tauto result_data = FlatVector::GetData<T>(result);",
          "new_line_content": "\t// FIXME: normalify if this is not the case... need to pass in count?",
          "content_same": false
        },
        {
          "line": 168,
          "old_api": "MergeUpdateInfo<T>(info, result_data, result_mask)",
          "new_api": null,
          "old_text": "MergeUpdateInfo<T>(info, result_data, result_mask)",
          "new_text": null,
          "old_line_content": "\tMergeUpdateInfo<T>(info, result_data, result_mask);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": "NotImplementedException",
          "new_api": null,
          "old_text": "NotImplementedException(\"Unimplemented type for uncompressed segment\")",
          "new_text": null,
          "old_line_content": "\t\tthrow NotImplementedException(\"Unimplemented type for uncompressed segment\");",
          "new_line_content": "\tcase PhysicalType::INT128:",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": "FlatVector::GetData<T>(update)",
          "new_api": null,
          "old_text": "FlatVector::GetData<T>(update)",
          "new_text": null,
          "old_line_content": "\tauto update_data = FlatVector::GetData<T>(update);",
          "new_line_content": "\t\treturn MergeUpdateLoop<string_t>;",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": "FlatVector::Validity(update)",
          "new_api": null,
          "old_text": "FlatVector::Validity(update)",
          "new_text": null,
          "old_line_content": "\tauto &mask = FlatVector::Validity(update);",
          "new_line_content": "\tdefault:",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": "NumericStatistics::Update<T>(stats, update_data[i])",
          "new_api": null,
          "old_text": "NumericStatistics::Update<T>(stats, update_data[i])",
          "new_text": null,
          "old_line_content": "\t\t\tNumericStatistics::Update<T>(stats, update_data[i]);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": "RowIsValid",
          "new_api": null,
          "old_text": "mask.RowIsValid(i)",
          "new_text": null,
          "old_line_content": "\t\t\tif (mask.RowIsValid(i)) {",
          "new_line_content": "//===--------------------------------------------------------------------===//",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "NumericStatistics::Update<T>(stats, update_data[i])",
          "new_api": null,
          "old_text": "NumericStatistics::Update<T>(stats, update_data[i])",
          "new_text": null,
          "old_line_content": "\t\t\t\tNumericStatistics::Update<T>(stats, update_data[i]);",
          "new_line_content": "template<class T>",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": "NotImplementedException",
          "new_api": null,
          "old_text": "NotImplementedException(\"Unimplemented type for update segment\")",
          "new_text": null,
          "old_line_content": "\t\tthrow NotImplementedException(\"Unimplemented type for update segment\");",
          "new_line_content": "\tcase PhysicalType::INT128:",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": "FlatVector::GetData<string_t>(update)",
          "new_api": null,
          "old_text": "FlatVector::GetData<string_t>(update)",
          "new_text": null,
          "old_line_content": "\tauto update_data = FlatVector::GetData<string_t>(update);",
          "new_line_content": "\t\tfor (idx_t i = 0; i < count; i++) {",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "Update",
          "new_api": null,
          "old_text": "(StringStatistics &) *stats.statistics).Update(update_data[i])",
          "new_text": null,
          "old_line_content": "\t\t\t((StringStatistics &) *stats.statistics).Update(update_data[i]);",
          "new_line_content": "\t\t\t\tstats.statistics->has_null = true;",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": "GetVectorType",
          "new_api": null,
          "old_text": "result.GetVectorType()",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(result.GetVectorType() == VectorType::FLAT_VECTOR);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "IsInlined",
          "new_api": null,
          "old_text": "update_data[i].IsInlined()",
          "new_text": null,
          "old_line_content": "\t\t\tif (!update_data[i].IsInlined()) {",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": "get",
          "new_api": null,
          "old_text": "root->info[vector_index]->info.get()",
          "new_text": null,
          "old_line_content": "\tfetch_committed_function(root->info[vector_index]->info.get(), result);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": "AddString",
          "new_api": null,
          "old_text": "segment->GetStringHeap().AddString(update_data[i])",
          "new_text": null,
          "old_line_content": "\t\t\t\tupdate_data[i] = segment->GetStringHeap().AddString(update_data[i]);",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": "AddString",
          "new_api": null,
          "old_text": "segment->GetStringHeap().AddString(update_data[i])",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tupdate_data[i] = segment->GetStringHeap().AddString(update_data[i]);",
          "new_line_content": "\t\tfor (idx_t i = 0; i < count; i++) {",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": "FlatVector::GetData<T>(result)",
          "new_api": null,
          "old_text": "FlatVector::GetData<T>(result)",
          "new_text": null,
          "old_line_content": "\tauto result_data = FlatVector::GetData<T>(result);",
          "new_line_content": "\t// FIXME: normalify if this is not the case... need to pass in count?",
          "content_same": false
        },
        {
          "line": 225,
          "old_api": "Set",
          "new_api": null,
          "old_text": "UpdateInfo::UpdatesForTransaction(info, start_time, transaction_id, [&](UpdateInfo *current) {\n\t\tValidityMask current_mask(current->validity);\n\t\tauto info_data = (T *)current->tuple_data;\n\t\t// FIXME: we could do a binary search in here\n\t\tfor (idx_t i = 0; i < current->N; i++) {\n\t\t\tif (current->tuples[i] == row_idx) {\n\t\t\t\tresult_data[result_idx] = info_data[i];\n\t\t\t\tresult_mask.Set(result_idx, current_mask.RowIsValidUnsafe(i));\n\t\t\t\tbreak;\n\t\t\t} else if (current->tuples[i] > row_idx) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t})",
          "new_text": null,
          "old_line_content": "\tUpdateInfo::UpdatesForTransaction(info, start_time, transaction_id, [&](UpdateInfo *current) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": "RowIsValidUnsafe",
          "new_api": null,
          "old_text": "current_mask.RowIsValidUnsafe(i)",
          "new_text": null,
          "old_line_content": "\t\t\t\tresult_mask.Set(result_idx, current_mask.RowIsValidUnsafe(i));",
          "new_line_content": "template <class T>",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "NotImplementedException",
          "new_api": null,
          "old_text": "NotImplementedException(\"Unimplemented type for uncompressed segment\")",
          "new_text": null,
          "old_line_content": "\t\tthrow NotImplementedException(\"Unimplemented type for uncompressed segment\");",
          "new_line_content": "\tcase PhysicalType::INT128:",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": "GetExclusiveLock",
          "new_api": null,
          "old_text": "lock.GetExclusiveLock()",
          "new_text": null,
          "old_line_content": "\tauto write_lock = lock.GetExclusiveLock();",
          "new_line_content": "\t\treturn UpdateStringStatistics;",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "NotImplementedException",
          "new_api": null,
          "old_text": "NotImplementedException(\"Unimplemented type for update segment fetch row\")",
          "new_text": null,
          "old_line_content": "\t\tthrow NotImplementedException(\"Unimplemented type for update segment fetch row\");",
          "new_line_content": "\tcase PhysicalType::INT128:",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "statistics_update_function",
          "new_api": null,
          "old_text": "statistics_update_function(this, stats, update, count)",
          "new_text": null,
          "old_line_content": "\tstatistics_update_function(this, stats, update, count);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "D_ASSERT",
          "new_api": null,
          "old_text": "D_ASSERT(ids[i] > ids[i - 1])",
          "new_text": null,
          "old_line_content": "\t\tD_ASSERT(ids[i] > ids[i - 1]);",
          "new_line_content": "//===--------------------------------------------------------------------===//",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "get",
          "new_api": null,
          "old_text": "root->info[vector_index]->info.get()",
          "new_text": null,
          "old_line_content": "\tfetch_row_function(transaction.start_time, transaction.transaction_id, root->info[vector_index]->info.get(), row_in_vector, result, result_idx);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": "idx_t",
          "new_api": null,
          "old_text": "idx_t(first_id)",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(idx_t(first_id) >= this->start);",
          "new_line_content": "\t// create the versions for this segment, if there are none yet",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "D_ASSERT",
          "new_api": null,
          "old_text": "D_ASSERT(vector_index < MORSEL_VECTOR_COUNT)",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(vector_index < MORSEL_VECTOR_COUNT);",
          "new_line_content": "\tif (!root) {",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": "D_ASSERT",
          "new_api": null,
          "old_text": "D_ASSERT(base_offset < base_info->N)",
          "new_text": null,
          "old_line_content": "\t\t\tD_ASSERT(base_offset < base_info->N);",
          "new_line_content": "static void RollbackUpdate(UpdateInfo *base_info, UpdateInfo *rollback_info) {",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": "get",
          "new_api": null,
          "old_text": "root->info[vector_index]->info.get()",
          "new_text": null,
          "old_line_content": "\t\tauto base_info = root->info[vector_index]->info.get();",
          "new_line_content": "\tidx_t vector_offset = this->start + vector_index * STANDARD_VECTOR_SIZE;",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "CheckForConflicts",
          "new_api": null,
          "old_text": "CheckForConflicts(base_info->next, transaction, ids, count, vector_offset, node)",
          "new_text": null,
          "old_line_content": "\t\tCheckForConflicts(base_info->next, transaction, ids, count, vector_offset, node);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": "RowIsValidUnsafe",
          "new_api": null,
          "old_text": "rollback_mask.RowIsValidUnsafe(i)",
          "new_text": null,
          "old_line_content": "\t\tbase_mask.Set(base_offset, rollback_mask.RowIsValidUnsafe(i));",
          "new_line_content": "\tValidityMask base_mask(base_info->validity);",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "CreateUpdateInfo",
          "new_api": null,
          "old_text": "transaction.CreateUpdateInfo(type_size, count)",
          "new_text": null,
          "old_line_content": "\t\t\tnode = transaction.CreateUpdateInfo(type_size, count);",
          "new_line_content": "\t\t// first, check if this thread has already done any updates",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "Verify",
          "new_api": null,
          "old_text": "base_info->Verify()",
          "new_text": null,
          "old_line_content": "\t\tbase_info->Verify();",
          "new_line_content": "\t\t\tnode->vector_index = vector_index;",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": "Verify",
          "new_api": null,
          "old_text": "node->Verify()",
          "new_text": null,
          "old_line_content": "\t\tnode->Verify();",
          "new_line_content": "\t\t\tnode->N = 0;",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": "merge_update_function",
          "new_api": null,
          "old_text": "merge_update_function(stats, base_info, base_data, node, update, ids, count)",
          "new_text": null,
          "old_line_content": "\t\tmerge_update_function(stats, base_info, base_data, node, update, ids, count);",
          "new_line_content": "\t\t\tnode->next = base_info->next;",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": "Verify",
          "new_api": null,
          "old_text": "base_info->Verify()",
          "new_text": null,
          "old_line_content": "\t\tbase_info->Verify();",
          "new_line_content": "\t\t\t\tnode->next->prev = node;",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": "Verify",
          "new_api": null,
          "old_text": "node->Verify()",
          "new_text": null,
          "old_line_content": "\t\tnode->Verify();",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": "NotImplementedException",
          "new_api": null,
          "old_text": "NotImplementedException(\"Unimplemented type for uncompressed segment\")",
          "new_text": null,
          "old_line_content": "\t\tthrow NotImplementedException(\"Unimplemented type for uncompressed segment\");",
          "new_line_content": "\tcase PhysicalType::INT128:",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": "make_unique<UpdateNodeData>()",
          "new_api": null,
          "old_text": "make_unique<UpdateNodeData>()",
          "new_text": null,
          "old_line_content": "\t\tauto result = make_unique<UpdateNodeData>();",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": "unique_ptr<sel_t[]>(new sel_t[STANDARD_VECTOR_SIZE])",
          "new_api": null,
          "old_text": "unique_ptr<sel_t[]>(new sel_t[STANDARD_VECTOR_SIZE])",
          "new_text": null,
          "old_line_content": "\t\tresult->tuples = unique_ptr<sel_t[]>(new sel_t[STANDARD_VECTOR_SIZE]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": "unique_ptr<data_t[]>(new data_t[STANDARD_VECTOR_SIZE * type_size])",
          "new_api": null,
          "old_text": "unique_ptr<data_t[]>(new data_t[STANDARD_VECTOR_SIZE * type_size])",
          "new_text": null,
          "old_line_content": "\t\tresult->tuple_data = unique_ptr<data_t[]>(new data_t[STANDARD_VECTOR_SIZE * type_size]);",
          "new_line_content": "\t\t// now we are going to perform the merge",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": "GetExclusiveLock",
          "new_api": null,
          "old_text": "lock.GetExclusiveLock()",
          "new_text": null,
          "old_line_content": "\tauto lock_handle = lock.GetExclusiveLock();",
          "new_line_content": "\tcase PhysicalType::INTERVAL:",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "get",
          "new_api": null,
          "old_text": "result->tuple_data.get()",
          "new_text": null,
          "old_line_content": "\t\tresult->info->tuple_data = result->tuple_data.get();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": "D_ASSERT",
          "new_api": null,
          "old_text": "D_ASSERT(root->info[info->vector_index])",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(root->info[info->vector_index]);",
          "new_line_content": "\t\treturn RollbackUpdate<string_t>;",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": "get",
          "new_api": null,
          "old_text": "root->info[info->vector_index]->info.get()",
          "new_text": null,
          "old_line_content": "\trollback_update_function(root->info[info->vector_index]->info.get(), info);",
          "new_line_content": "\tdefault:",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": "SetAllValid",
          "new_api": null,
          "old_text": "result_mask.SetAllValid(STANDARD_VECTOR_SIZE)",
          "new_text": null,
          "old_line_content": "\t\tresult_mask.SetAllValid(STANDARD_VECTOR_SIZE);",
          "new_line_content": "\t} else {",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": "InitializeUpdateInfo",
          "new_api": null,
          "old_text": "InitializeUpdateInfo(*result->info, ids, count, vector_index, vector_offset)",
          "new_text": null,
          "old_line_content": "\t\tInitializeUpdateInfo(*result->info, ids, count, vector_index, vector_offset);",
          "new_line_content": "\t\t// there is no version info yet: create the top level update info and fill it with the updates",
          "content_same": false
        },
        {
          "line": 352,
          "old_api": "CleanupUpdateInternal",
          "new_api": null,
          "old_text": "CleanupUpdateInternal(*lock_handle, info)",
          "new_text": null,
          "old_line_content": "\tCleanupUpdateInternal(*lock_handle, info);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "get",
          "new_api": null,
          "old_text": "result->info.get()",
          "new_text": null,
          "old_line_content": "\t\ttransaction_node->prev = result->info.get();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": "move",
          "new_api": null,
          "old_text": "move(result)",
          "new_text": null,
          "old_line_content": "\t\troot->info[vector_index] = move(result);",
          "new_line_content": "\t\t// we write the updates in the",
          "content_same": false
        },
        {
          "line": 369,
          "old_api": "GetExclusiveLock",
          "new_api": null,
          "old_text": "lock.GetExclusiveLock()",
          "new_text": null,
          "old_line_content": "\tauto lock_handle = lock.GetExclusiveLock();",
          "new_line_content": "void UpdateSegment::CleanupUpdateInternal(const StorageLockKey &lock, UpdateInfo *info) {",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": "GetStatistics",
          "new_api": null,
          "old_text": "GetStatistics()",
          "new_text": null,
          "old_line_content": "\tcolumn_data.MergeStatistics(*GetStatistics().statistics);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": "HasUpdates",
          "new_api": null,
          "old_text": "HasUpdates()",
          "new_text": null,
          "old_line_content": "\tif (!HasUpdates()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": "GetSharedLock",
          "new_api": null,
          "old_text": "lock.GetSharedLock()",
          "new_text": null,
          "old_line_content": "\tauto read_lock = lock.GetSharedLock();",
          "new_line_content": "bool UpdateSegment::HasUpdates(idx_t vector_index) const {",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": "TransactionException",
          "new_api": null,
          "old_text": "TransactionException(\"Conflict on update!\")",
          "new_text": null,
          "old_line_content": "\t\t\t\tthrow TransactionException(\"Conflict on update!\");",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": "D_ASSERT",
          "new_api": null,
          "old_text": "D_ASSERT(start_vector_index >= base_vector_index)",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(start_vector_index >= base_vector_index);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": "get",
          "new_api": null,
          "old_text": "next.get()",
          "new_text": null,
          "old_line_content": "\t\t\tsegment = (UpdateSegment*) next.get();",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": "HasUpdates",
          "new_api": null,
          "old_text": "segment->HasUpdates(vector_index)",
          "new_text": null,
          "old_line_content": "\t\tif (segment->HasUpdates(vector_index)) {",
          "new_line_content": "bool UpdateSegment::HasUpdates(idx_t start_vector_index, idx_t end_vector_index) const {",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": "CheckForConflicts",
          "new_api": null,
          "old_text": "CheckForConflicts(info->next, transaction, ids, count, offset, node)",
          "new_text": null,
          "old_line_content": "\tCheckForConflicts(info->next, transaction, ids, count, offset, node);",
          "new_line_content": "\t\t\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": "D_ASSERT",
          "new_api": null,
          "old_text": "D_ASSERT(end_vector_index >= base_vector_index)",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(end_vector_index >= base_vector_index);",
          "new_line_content": "\t\t\tvector_index -= UpdateSegment::MORSEL_VECTOR_COUNT;",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "get",
          "new_api": null,
          "old_text": "next.get()",
          "new_text": null,
          "old_line_content": "\t\tsegment = (UpdateSegment *) next.get();",
          "new_line_content": "\t\t\treturn true;",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "D_ASSERT",
          "new_api": null,
          "old_text": "D_ASSERT((idx_t)ids[i] >= vector_offset && (idx_t)ids[i] < vector_offset + STANDARD_VECTOR_SIZE)",
          "new_text": null,
          "old_line_content": "\t\tD_ASSERT((idx_t)ids[i] >= vector_offset && (idx_t)ids[i] < vector_offset + STANDARD_VECTOR_SIZE);",
          "new_line_content": "// Initialize update info",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": "RowIsValid",
          "new_api": null,
          "old_text": "tuple_mask.RowIsValid(i)",
          "new_text": null,
          "old_line_content": "\t\tbool is_valid = tuple_mask.RowIsValid(i);",
          "new_line_content": "\tinfo.N = count;",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": "Set",
          "new_api": null,
          "old_text": "tuple_mask.Set(i, is_valid)",
          "new_text": null,
          "old_line_content": "\t\ttuple_mask.Set(i, is_valid);",
          "new_line_content": "\tfor (idx_t i = 0; i < count; i++) {",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": "FlatVector::GetData<T>(update)",
          "new_api": null,
          "old_text": "FlatVector::GetData<T>(update)",
          "new_text": null,
          "old_line_content": "\tauto update_data = FlatVector::GetData<T>(update);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": "FlatVector::Validity(update)",
          "new_api": null,
          "old_text": "FlatVector::Validity(update)",
          "new_text": null,
          "old_line_content": "\tauto &update_mask = FlatVector::Validity(update);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": "AllValid",
          "new_api": null,
          "old_text": "update_mask.AllValid()",
          "new_text": null,
          "old_line_content": "\tif (!update_mask.AllValid()) {",
          "new_line_content": "\tfor (idx_t i = 0; i < count; i++) {",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": "RowIsValidUnsafe",
          "new_api": null,
          "old_text": "update_mask.RowIsValidUnsafe(i)",
          "new_text": null,
          "old_line_content": "\t\t\tinfo_mask.Set(i, update_mask.RowIsValidUnsafe(i));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": "FlatVector::GetData<T>(base_data)",
          "new_api": null,
          "old_text": "FlatVector::GetData<T>(base_data)",
          "new_text": null,
          "old_line_content": "\tauto base_array_data = FlatVector::GetData<T>(base_data);",
          "new_line_content": "\t\tValidityMask info_mask(update_info->validity);",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": "FlatVector::Validity(base_data)",
          "new_api": null,
          "old_text": "FlatVector::Validity(base_data)",
          "new_text": null,
          "old_line_content": "\tauto &base_mask = FlatVector::Validity(base_data);",
          "new_line_content": "\t\tfor (idx_t i = 0; i < update_info->N; i++) {",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "AllValid",
          "new_api": null,
          "old_text": "base_mask.AllValid()",
          "new_text": null,
          "old_line_content": "\tif (!base_mask.AllValid()) {",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "RowIsValidUnsafe",
          "new_api": null,
          "old_text": "base_mask.RowIsValidUnsafe(base_info->tuples[i])",
          "new_text": null,
          "old_line_content": "\t\t\tbase_tuple_mask.Set(i, base_mask.RowIsValidUnsafe(base_info->tuples[i]));",
          "new_line_content": "\t\t\ttuple_data[i] = update_data[i];",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": "NotImplementedException",
          "new_api": null,
          "old_text": "NotImplementedException(\"Unimplemented type for update segment\")",
          "new_text": null,
          "old_line_content": "\t\tthrow NotImplementedException(\"Unimplemented type for update segment\");",
          "new_line_content": "\tcase PhysicalType::INT128:",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 21,
      "total_additions": 107,
      "total_deletions": 104,
      "total_api_changes": 232
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 14,
        "api_related_lines": 232,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          98,
          99,
          101,
          102,
          103,
          111
        ]
      }
    },
    "api_calls_before": 187,
    "api_calls_after": 192,
    "diff_info": {
      "added_lines": 14,
      "removed_lines": 3,
      "total_diff_lines": 29
    }
  }
}