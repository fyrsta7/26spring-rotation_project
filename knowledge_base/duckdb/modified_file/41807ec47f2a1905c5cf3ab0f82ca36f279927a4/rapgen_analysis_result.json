{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/41807ec47f2a1905c5cf3ab0f82ca36f279927a4",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/41807ec47f2a1905c5cf3ab0f82ca36f279927a4/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/41807ec47f2a1905c5cf3ab0f82ca36f279927a4/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/41807ec47f2a1905c5cf3ab0f82ca36f279927a4/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 235,
          "old_api": "GetHeapSizeOffset",
          "new_api": "AllConstant",
          "old_text": "layout.GetHeapSizeOffset()",
          "new_text": "layout.AllConstant()",
          "old_line_content": "\t\tconst auto heap_size_offset = layout.GetHeapSizeOffset();",
          "new_line_content": "\tif (!layout.AllConstant()) {",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": "Store<uint32_t>(heap_sizes[i], row_locations[i] + heap_size_offset)",
          "new_api": "FlatVector::GetData<idx_t>(chunk_state.heap_sizes)",
          "old_text": "Store<uint32_t>(heap_sizes[i], row_locations[i] + heap_size_offset)",
          "new_text": "FlatVector::GetData<idx_t>(chunk_state.heap_sizes)",
          "old_line_content": "\t\t\tStore<uint32_t>(heap_sizes[i], row_locations[i] + heap_size_offset);",
          "new_line_content": "\t\tconst auto heap_sizes = FlatVector::GetData<idx_t>(chunk_state.heap_sizes);",
          "content_same": false
        },
        {
          "line": 263,
          "old_api": "D_ASSERT",
          "new_api": "get_index",
          "old_text": "D_ASSERT(stored_heap_size == heap_sizes[idx])",
          "new_text": "append_sel.get_index(i)",
          "old_line_content": "\t\tD_ASSERT(stored_heap_size == heap_sizes[idx]);",
          "new_line_content": "\t\tauto idx = append_sel.get_index(i);",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": "get_index",
          "new_api": "GetRowWidth",
          "old_text": "append_sel.get_index(i)",
          "new_text": "layout.GetRowWidth()",
          "old_line_content": "\t\tauto idx = append_sel.get_index(i);",
          "new_line_content": "\tconst auto row_width = layout.GetRowWidth();",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": "FlatVector::GetData<data_ptr_t>(chunk_state.heap_locations)",
          "new_api": "AllConstant",
          "old_text": "FlatVector::GetData<data_ptr_t>(chunk_state.heap_locations)",
          "new_text": "layout.AllConstant()",
          "old_line_content": "\t\tconst auto target_heap_locations = FlatVector::GetData<data_ptr_t>(chunk_state.heap_locations);",
          "new_line_content": "\tif (!layout.AllConstant()) {",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "FlatVector::GetData<idx_t>(input.heap_sizes)",
          "new_api": "FlatVector::GetData<data_ptr_t>(input.heap_locations)",
          "old_text": "FlatVector::GetData<idx_t>(input.heap_sizes)",
          "new_text": "FlatVector::GetData<data_ptr_t>(input.heap_locations)",
          "old_line_content": "\t\tconst auto heap_sizes = FlatVector::GetData<idx_t>(input.heap_sizes);",
          "new_line_content": "\t\tconst auto source_heap_locations = FlatVector::GetData<data_ptr_t>(input.heap_locations);",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": "GetHeapSizeOffset",
          "new_api": "FlatVector::GetData<data_ptr_t>(chunk_state.heap_locations)",
          "old_text": "layout.GetHeapSizeOffset()",
          "new_text": "FlatVector::GetData<data_ptr_t>(chunk_state.heap_locations)",
          "old_line_content": "\t\tVerifyHeapSizes(source_locations, heap_sizes, append_sel, append_count, layout.GetHeapSizeOffset());",
          "new_line_content": "\t\tconst auto target_heap_locations = FlatVector::GetData<data_ptr_t>(chunk_state.heap_locations);",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": "size",
          "new_api": "InternalException",
          "old_text": "other.segments.size()",
          "new_text": "InternalException(\"Attempting to combine TupleDataCollection with mismatching types\")",
          "old_line_content": "\tif (this->segments.size() == 1 && other.segments.size() == 1 &&",
          "new_line_content": "\t\tthrow InternalException(\"Attempting to combine TupleDataCollection with mismatching types\");",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": "Combine",
          "new_api": "get",
          "old_text": "this->segments[0].Combine(other.segments[0])",
          "new_text": "other.segments[0].allocator.get()",
          "old_line_content": "\t\tthis->segments[0].Combine(other.segments[0]);",
          "new_line_content": "\t    this->segments[0].allocator.get() == other.segments[0].allocator.get()) {",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": "size",
          "new_api": "empty",
          "old_text": "column_ids.size()",
          "new_text": "column_ids.empty()",
          "old_line_content": "\tchunk_types.reserve(column_ids.size());",
          "new_line_content": "\tD_ASSERT(!column_ids.empty());",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": "ColumnCount",
          "new_api": "size",
          "old_text": "layout.ColumnCount()",
          "new_text": "column_ids.size()",
          "old_line_content": "\t\tD_ASSERT(column_idx < layout.ColumnCount());",
          "new_line_content": "\tfor (idx_t i = 0; i < column_ids.size(); i++) {",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": "GetAllocator",
          "new_api": "GetTypes",
          "old_text": "allocator->GetAllocator()",
          "new_text": "layout.GetTypes()",
          "old_line_content": "\tchunk.Initialize(allocator->GetAllocator(), chunk_types);",
          "new_line_content": "\t\tchunk_types.push_back(layout.GetTypes()[column_idx]);",
          "content_same": false
        },
        {
          "line": 360,
          "old_api": "push_back",
          "new_api": "ColumnCount",
          "old_text": "column_ids.push_back(i)",
          "new_text": "layout.ColumnCount()",
          "old_line_content": "\t\tcolumn_ids.push_back(i);",
          "new_line_content": "\tcolumn_ids.reserve(layout.ColumnCount());",
          "content_same": false
        },
        {
          "line": 362,
          "old_api": "std::move(column_ids)",
          "new_api": "push_back",
          "old_text": "std::move(column_ids)",
          "new_text": "column_ids.push_back(i)",
          "old_line_content": "\tInitializeScan(state, std::move(column_ids), properties);",
          "new_line_content": "\t\tcolumn_ids.push_back(i);",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": "ScanAtIndex",
          "new_api": "clear",
          "old_text": "ScanAtIndex(state.pin_state, state.chunk_state, state.chunk_state.column_ids, segment_index, chunk_index, result)",
          "new_text": "state.pin_state.heap_handles.clear()",
          "old_line_content": "\tScanAtIndex(state.pin_state, state.chunk_state, state.chunk_state.column_ids, segment_index, chunk_index, result);",
          "new_line_content": "\t\tstate.pin_state.heap_handles.clear();",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "ScanAtIndex",
          "new_api": "clear",
          "old_text": "ScanAtIndex(scan_state.pin_state, scan_state.chunk_state, gstate.scan_state.chunk_state.column_ids,\n\t            scan_state.segment_index, scan_state.chunk_index, result)",
          "new_text": "scan_state.pin_state.heap_handles.clear()",
          "old_line_content": "\tScanAtIndex(scan_state.pin_state, scan_state.chunk_state, gstate.scan_state.chunk_state.column_ids,",
          "new_line_content": "\t\tscan_state.pin_state.heap_handles.clear();",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": "emplace_back",
          "new_api": "ColumnCount",
          "old_text": "column_ids.emplace_back(col_idx)",
          "new_text": "layout.ColumnCount()",
          "old_line_content": "\t\tcolumn_ids.emplace_back(col_idx);",
          "new_line_content": "\tcolumn_ids.reserve(layout.ColumnCount());",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": "Gather",
          "new_api": "emplace_back",
          "old_text": "Gather(row_locations, scan_sel, scan_count, column_ids, result, target_sel)",
          "new_text": "column_ids.emplace_back(col_idx)",
          "old_line_content": "\tGather(row_locations, scan_sel, scan_count, column_ids, result, target_sel);",
          "new_line_content": "\t\tcolumn_ids.emplace_back(col_idx);",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": "Gather",
          "new_api": "ColumnCount",
          "old_text": "Gather(row_locations, scan_sel, scan_count, column_ids[col_idx], result.data[col_idx], target_sel)",
          "new_text": "result.ColumnCount()",
          "old_line_content": "\t\tGather(row_locations, scan_sel, scan_count, column_ids[col_idx], result.data[col_idx], target_sel);",
          "new_line_content": "\tD_ASSERT(column_ids.size() == result.ColumnCount());",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": "ColumnCount",
          "new_api": "size",
          "old_text": "new_chunk.ColumnCount()",
          "new_text": "new_chunk.size()",
          "old_line_content": "\tfor (idx_t col_idx = 0; col_idx < new_chunk.ColumnCount(); col_idx++) {",
          "new_line_content": "\tstd::fill_n(heap_sizes, new_chunk.size(), 0);",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "GetSize",
          "new_api": "Store<string_t>(source, row_location + offset_in_row)",
          "old_text": "source.GetSize()",
          "new_text": "Store<string_t>(source, row_location + offset_in_row)",
          "old_line_content": "\t\tmemcpy(heap_location, source.GetDataUnsafe(), source.GetSize());",
          "new_line_content": "\t\tStore<string_t>(source, row_location + offset_in_row);",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": "GetOffsets",
          "new_api": "FlatVector::GetData<data_ptr_t>(heap_locations)",
          "old_text": "layout.GetOffsets()",
          "new_text": "FlatVector::GetData<data_ptr_t>(heap_locations)",
          "old_line_content": "\tconst auto offset_in_row = layout.GetOffsets()[col_idx];",
          "new_line_content": "\tauto target_heap_locations = FlatVector::GetData<data_ptr_t>(heap_locations);",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": "get_index",
          "new_api": "AllValid",
          "old_text": "append_sel.get_index(i)",
          "new_text": "validity.AllValid()",
          "old_line_content": "\t\t\tauto source_idx = source_sel.get_index(append_sel.get_index(i));",
          "new_line_content": "\tif (validity.AllValid()) {",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "TupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row,\n\t\t\t\t                         target_heap_locations[i])",
          "new_api": "get_index",
          "old_text": "TupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row,\n\t\t\t\t                         target_heap_locations[i])",
          "new_text": "append_sel.get_index(i)",
          "old_line_content": "\t\t\t\tTupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row,",
          "new_line_content": "\t\t\tauto source_idx = source_sel.get_index(append_sel.get_index(i));",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": "SetValidUnsafe",
          "new_api": "TupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row,\n\t\t\t\t                         target_heap_locations[i])",
          "old_text": "ValidityBytes(target_locations[i]).SetValidUnsafe(col_idx)",
          "new_text": "TupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row,\n\t\t\t\t                         target_heap_locations[i])",
          "old_line_content": "\t\t\t\tValidityBytes(target_locations[i]).SetValidUnsafe(col_idx);",
          "new_line_content": "\t\t\t\tTupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row,",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": "SetValidUnsafe",
          "new_api": "get_index",
          "old_text": "ValidityBytes(target_locations[i]).SetValidUnsafe(col_idx)",
          "new_text": "append_sel.get_index(i)",
          "old_line_content": "\t\t\tValidityBytes(target_locations[i]).SetValidUnsafe(col_idx);",
          "new_line_content": "\t\tauto source_idx = source_sel.get_index(append_sel.get_index(i));",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": "StructVector::GetEntries(source)",
          "new_api": "GetStructLayouts",
          "old_text": "StructVector::GetEntries(source)",
          "new_text": "layout.GetStructLayouts().end()",
          "old_line_content": "\tauto &struct_sources = StructVector::GetEntries(source);",
          "new_line_content": "\tD_ASSERT(layout.GetStructLayouts().find(col_idx) != layout.GetStructLayouts().end());",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": "size",
          "new_api": "GetStructLayouts",
          "old_text": "struct_sources.size()",
          "new_text": "layout.GetStructLayouts().find(col_idx)",
          "old_line_content": "\tD_ASSERT(struct_layout.ColumnCount() == struct_sources.size());",
          "new_line_content": "\tconst auto &struct_layout = layout.GetStructLayouts().find(col_idx)->second;",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": "Store<data_ptr_t>(target_heap_locations[i], target_locations[i] + offset_in_row)",
          "new_api": "GetOffsets",
          "old_text": "Store<data_ptr_t>(target_heap_locations[i], target_locations[i] + offset_in_row)",
          "new_text": "layout.GetOffsets()",
          "old_line_content": "\t\tStore<data_ptr_t>(target_heap_locations[i], target_locations[i] + offset_in_row);",
          "new_line_content": "\tconst auto offset_in_row = layout.GetOffsets()[col_idx];",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "ColumnCount",
          "new_api": "GetStructLayouts",
          "old_text": "struct_layout.ColumnCount()",
          "new_text": "layout.GetStructLayouts().end()",
          "old_line_content": "\t\tfor (idx_t struct_col_idx = 0; struct_col_idx < struct_layout.ColumnCount(); struct_col_idx++) {",
          "new_line_content": "\t\tD_ASSERT(layout.GetStructLayouts().find(col_idx) != layout.GetStructLayouts().end());",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": "GetScatterFunction",
          "new_api": "GetStructLayouts",
          "old_text": "GetScatterFunction(struct_layout, struct_col_idx)",
          "new_text": "layout.GetStructLayouts().find(col_idx)",
          "old_line_content": "\t\t\tresult.child_functions.push_back(GetScatterFunction(struct_layout, struct_col_idx));",
          "new_line_content": "\t\tconst auto &struct_layout = layout.GetStructLayouts().find(col_idx)->second;",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": "FinalizePinState",
          "new_api": "ChunkCount",
          "old_text": "FinalizePinState(state.pin_state, segments[state.segment_index])",
          "new_text": "segments[state.segment_index].ChunkCount()",
          "old_line_content": "\t\tFinalizePinState(state.pin_state, segments[state.segment_index]);",
          "new_line_content": "\twhile (state.chunk_index >= segments[state.segment_index].ChunkCount()) {",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": "FlatVector::IncrementalSelectionVector()",
          "new_api": "InitializeChunkState",
          "old_text": "FlatVector::IncrementalSelectionVector()",
          "new_text": "segment.allocator->InitializeChunkState(segment, pin_state, chunk_state, chunk_index, false)",
          "old_line_content": "\tGather(chunk_state.row_locations, *FlatVector::IncrementalSelectionVector(), chunk.count, column_ids, result,",
          "new_line_content": "\tsegment.allocator->InitializeChunkState(segment, pin_state, chunk_state, chunk_index, false);",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": "FlatVector::IncrementalSelectionVector()",
          "new_api": "Reset",
          "old_text": "FlatVector::IncrementalSelectionVector()",
          "new_text": "result.Reset()",
          "old_line_content": "\t       *FlatVector::IncrementalSelectionVector());",
          "new_line_content": "\tresult.Reset();",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": "SetCardinality",
          "new_api": "FlatVector::IncrementalSelectionVector()",
          "old_text": "result.SetCardinality(chunk.count)",
          "new_text": "FlatVector::IncrementalSelectionVector()",
          "old_line_content": "\tresult.SetCardinality(chunk.count);",
          "new_line_content": "\tGather(chunk_state.row_locations, *FlatVector::IncrementalSelectionVector(), chunk.count, column_ids, result,",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": "GetOffsets",
          "new_api": "ValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry)",
          "old_text": "layout.GetOffsets()",
          "new_text": "ValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry)",
          "old_line_content": "\tconst auto offset_in_row = layout.GetOffsets()[col_idx];",
          "new_line_content": "\tValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry);",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": "get_index",
          "new_api": "GetOffsets",
          "old_text": "scan_sel.get_index(i)",
          "new_text": "layout.GetOffsets()",
          "old_line_content": "\t\tconst auto &source_row = source_locations[scan_sel.get_index(i)];",
          "new_line_content": "\tconst auto offset_in_row = layout.GetOffsets()[col_idx];",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": "GetValidityEntry",
          "new_api": "get_index",
          "old_text": "row_mask.GetValidityEntry(entry_idx)",
          "new_text": "target_sel.get_index(i)",
          "old_line_content": "\t\tif (row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry)) {",
          "new_line_content": "\t\tconst auto target_idx = target_sel.get_index(i);",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "SetInvalid",
          "new_api": "Load<T>(source_row + offset_in_row)",
          "old_text": "target_validity.SetInvalid(target_idx)",
          "new_text": "Load<T>(source_row + offset_in_row)",
          "old_line_content": "\t\t\ttarget_validity.SetInvalid(target_idx);",
          "new_line_content": "\t\t\ttarget_data[target_idx] = Load<T>(source_row + offset_in_row);",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": "get_index",
          "new_api": "GetOffsets",
          "old_text": "scan_sel.get_index(i)",
          "new_text": "layout.GetOffsets()",
          "old_line_content": "\t\tconst auto source_idx = scan_sel.get_index(i);",
          "new_line_content": "\tconst auto offset_in_row = layout.GetOffsets()[col_idx];",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "SetInvalid",
          "new_api": "GetValidityEntry",
          "old_text": "target_validity.SetInvalid(target_idx)",
          "new_text": "row_mask.GetValidityEntry(entry_idx)",
          "old_line_content": "\t\t\ttarget_validity.SetInvalid(target_idx);",
          "new_line_content": "\t\tif (!row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry)) {",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "StructVector::GetEntries(target)",
          "new_api": "GetStructLayouts",
          "old_text": "StructVector::GetEntries(target)",
          "new_text": "layout.GetStructLayouts().end()",
          "old_line_content": "\tauto &struct_targets = StructVector::GetEntries(target);",
          "new_line_content": "\tD_ASSERT(layout.GetStructLayouts().find(col_idx) != layout.GetStructLayouts().end());",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": "size",
          "new_api": "GetStructLayouts",
          "old_text": "struct_targets.size()",
          "new_text": "layout.GetStructLayouts().find(col_idx)",
          "old_line_content": "\tD_ASSERT(struct_layout.ColumnCount() == struct_targets.size());",
          "new_line_content": "\tconst auto &struct_layout = layout.GetStructLayouts().find(col_idx)->second;",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": "get_index",
          "new_api": "GetOffsets",
          "old_text": "scan_sel.get_index(i)",
          "new_text": "layout.GetOffsets()",
          "old_line_content": "\t\tconst auto &source_row = source_locations[scan_sel.get_index(i)];",
          "new_line_content": "\tconst auto offset_in_row = layout.GetOffsets()[col_idx];",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": "ColumnCount",
          "new_api": "GetStructLayouts",
          "old_text": "struct_layout.ColumnCount()",
          "new_text": "layout.GetStructLayouts().end()",
          "old_line_content": "\t\tfor (idx_t struct_col_idx = 0; struct_col_idx < struct_layout.ColumnCount(); struct_col_idx++) {",
          "new_line_content": "\t\tD_ASSERT(layout.GetStructLayouts().find(col_idx) != layout.GetStructLayouts().end());",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": "GetGatherFunction",
          "new_api": "GetStructLayouts",
          "old_text": "GetGatherFunction(struct_layout, struct_col_idx)",
          "new_text": "layout.GetStructLayouts().find(col_idx)",
          "old_line_content": "\t\t\tresult.child_functions.push_back(GetGatherFunction(struct_layout, struct_col_idx));",
          "new_line_content": "\t\tconst auto &struct_layout = layout.GetStructLayouts().find(col_idx)->second;",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": "Count",
          "new_api": "InitializeScan",
          "old_text": "Count()",
          "new_text": "InitializeScan(scan_state)",
          "old_line_content": "\tstring result = StringUtil::Format(\"TupleDataCollection - [%llu Chunks, %llu Rows]\\n\", ChunkCount(), Count());",
          "new_line_content": "\tInitializeScan(scan_state);",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": "size",
          "new_api": "Scan",
          "old_text": "chunk.size()",
          "new_text": "Scan(scan_state, chunk)",
          "old_line_content": "\t\t    StringUtil::Format(\"Chunk %llu - [Rows %llu - %llu]\\n\", chunk_idx, row_count, row_count + chunk.size()) +",
          "new_line_content": "\twhile (Scan(scan_state, chunk)) {",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": "size",
          "new_api": "ToString",
          "old_text": "chunk.size()",
          "new_text": "chunk.ToString()",
          "old_line_content": "\t\trow_count += chunk.size();",
          "new_line_content": "\t\t    chunk.ToString();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 523,
          "old_api": null,
          "new_api": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "old_text": null,
          "new_text": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "old_line_content": "\t// Set validity of the STRUCT in this layout",
          "new_line_content": "\tauto target_locations = FlatVector::GetData<data_ptr_t>(row_locations);",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": null,
          "new_api": "RowIsValid",
          "old_text": null,
          "new_text": "validity.RowIsValid(source_idx)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tif (!validity.RowIsValid(source_idx)) {",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": null,
          "new_api": "SetValidUnsafe",
          "old_text": null,
          "new_text": "ValidityBytes(target_locations[i]).SetValidUnsafe(col_idx)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\tValidityBytes(target_locations[i]).SetValidUnsafe(col_idx);",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": null,
          "new_api": "FlatVector::GetData<data_ptr_t>(struct_row_locations)",
          "old_text": null,
          "new_text": "FlatVector::GetData<data_ptr_t>(struct_row_locations)",
          "old_line_content": "\tfor (idx_t i = 0; i < append_count; i++) {",
          "new_line_content": "\tauto struct_target_locations = FlatVector::GetData<data_ptr_t>(struct_row_locations);",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": null,
          "new_api": "GetOffsets",
          "old_text": null,
          "new_text": "layout.GetOffsets()",
          "old_line_content": "\t\tstruct_target_locations[i] = target_locations[i] + offset_in_row;",
          "new_line_content": "\tconst auto offset_in_row = layout.GetOffsets()[col_idx];",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": null,
          "new_api": "StructVector::GetEntries(source)",
          "old_text": null,
          "new_text": "StructVector::GetEntries(source)",
          "old_line_content": "",
          "new_line_content": "\tauto &struct_sources = StructVector::GetEntries(source);",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "struct_sources.size()",
          "old_line_content": "\t// Recurse through the struct children",
          "new_line_content": "\tD_ASSERT(struct_layout.ColumnCount() == struct_sources.size());",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": null,
          "new_api": "ColumnCount",
          "old_text": null,
          "new_text": "struct_layout.ColumnCount()",
          "old_line_content": "\t\tUnifiedVectorFormat struct_source_data;",
          "new_line_content": "\tfor (idx_t struct_col_idx = 0; struct_col_idx < struct_layout.ColumnCount(); struct_col_idx++) {",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": null,
          "new_api": "ToUnifiedFormat",
          "old_text": null,
          "new_text": "struct_source->ToUnifiedFormat(original_count, struct_source_data)",
          "old_line_content": "\t\tconst auto &struct_scatter_function = child_functions[col_idx];",
          "new_line_content": "\t\tstruct_source->ToUnifiedFormat(original_count, struct_source_data);",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": null,
          "new_api": "function",
          "old_text": null,
          "new_text": "struct_scatter_function.function(*struct_sources[struct_col_idx], struct_source_data, append_sel, append_count,\n\t\t                                 original_count, struct_layout, struct_row_locations, heap_locations,\n\t\t                                 struct_col_idx, struct_scatter_function.child_functions)",
          "old_line_content": "\t\t                                 struct_col_idx, struct_scatter_function.child_functions);",
          "new_line_content": "\t\tstruct_scatter_function.function(*struct_sources[struct_col_idx], struct_source_data, append_sel, append_count,",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": null,
          "new_api": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "old_text": null,
          "new_text": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "old_line_content": "",
          "new_line_content": "\tauto target_locations = FlatVector::GetData<data_ptr_t>(row_locations);",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": null,
          "new_api": "FlatVector::GetData<data_ptr_t>(heap_locations)",
          "old_text": null,
          "new_text": "FlatVector::GetData<data_ptr_t>(heap_locations)",
          "old_line_content": "\t// Store pointers to the data in the rows",
          "new_line_content": "\tauto target_heap_locations = FlatVector::GetData<data_ptr_t>(heap_locations);",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": null,
          "new_api": "Store<data_ptr_t>(target_heap_locations[i], target_locations[i] + offset_in_row)",
          "old_text": null,
          "new_text": "Store<data_ptr_t>(target_heap_locations[i], target_locations[i] + offset_in_row)",
          "old_line_content": "",
          "new_line_content": "\t\tStore<data_ptr_t>(target_heap_locations[i], target_locations[i] + offset_in_row);",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": null,
          "new_api": "RowOperations::HeapScatter(source, original_count, append_sel, append_count, col_idx, target_heap_locations,\n\t                           target_locations)",
          "old_text": null,
          "new_text": "RowOperations::HeapScatter(source, original_count, append_sel, append_count, col_idx, target_heap_locations,\n\t                           target_locations)",
          "old_line_content": "}",
          "new_line_content": "\tRowOperations::HeapScatter(source, original_count, append_sel, append_count, col_idx, target_heap_locations,",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": null,
          "new_api": "GetTypes",
          "old_text": null,
          "new_text": "layout.GetTypes()",
          "old_line_content": "\tTupleDataScatterFunction result;",
          "new_line_content": "\tconst auto &type = layout.GetTypes()[col_idx];",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": null,
          "new_api": "InternalType",
          "old_text": null,
          "new_text": "type.InternalType()",
          "old_line_content": "\t\tfunction = TemplatedTupleDataScatter<bool>;",
          "new_line_content": "\tswitch (type.InternalType()) {",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": null,
          "new_api": "ColumnCount",
          "old_text": null,
          "new_text": "struct_layout.ColumnCount()",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tfor (idx_t struct_col_idx = 0; struct_col_idx < struct_layout.ColumnCount(); struct_col_idx++) {",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": null,
          "new_api": "GetScatterFunction",
          "old_text": null,
          "new_text": "GetScatterFunction(struct_layout, struct_col_idx)",
          "old_line_content": "\t\tbreak;",
          "new_line_content": "\t\t\tresult.child_functions.push_back(GetScatterFunction(struct_layout, struct_col_idx));",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": null,
          "new_api": "InternalException",
          "old_text": null,
          "new_text": "InternalException(\"Unsupported type for TupleDataCollection::GetScatterFunction\")",
          "old_line_content": "\tresult.function = function;",
          "new_line_content": "\t\tthrow InternalException(\"Unsupported type for TupleDataCollection::GetScatterFunction\");",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": null,
          "new_api": "ReleaseOrStoreHandles",
          "old_text": null,
          "new_text": "segment.allocator->ReleaseOrStoreHandles(pin_state, segment)",
          "old_line_content": "",
          "new_line_content": "\tsegment.allocator->ReleaseOrStoreHandles(pin_state, segment);",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "segments.size()",
          "old_line_content": "}",
          "new_line_content": "\tD_ASSERT(segments.size() == 1);",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "segments.back()",
          "old_line_content": "",
          "new_line_content": "\tallocator->ReleaseOrStoreHandles(pin_state, segments.back());",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "segments.size()",
          "old_line_content": "\t\treturn false;",
          "new_line_content": "\tif (state.segment_index >= segments.size()) {",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "FinalizePinState",
          "old_text": null,
          "new_text": "FinalizePinState(state.pin_state, segments[state.segment_index])",
          "old_line_content": "\t\tstate.chunk_index = 0;",
          "new_line_content": "\t\tFinalizePinState(state.pin_state, segments[state.segment_index]);",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "segments.size()",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tif (state.segment_index >= segments.size()) {",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "FlatVector::IncrementalSelectionVector()",
          "old_text": null,
          "new_text": "FlatVector::IncrementalSelectionVector()",
          "old_line_content": "}",
          "new_line_content": "\t       *FlatVector::IncrementalSelectionVector());",
          "content_same": false
        },
        {
          "line": 685,
          "old_api": null,
          "new_api": "SetCardinality",
          "old_text": null,
          "new_text": "result.SetCardinality(chunk.count)",
          "old_line_content": "",
          "new_line_content": "\tresult.SetCardinality(chunk.count);",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": null,
          "new_api": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "old_text": null,
          "new_text": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "old_line_content": "\t// Target",
          "new_line_content": "\tauto source_locations = FlatVector::GetData<data_ptr_t>(row_locations);",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": null,
          "new_api": "FlatVector::GetData<T>(target)",
          "old_text": null,
          "new_text": "FlatVector::GetData<T>(target)",
          "old_line_content": "",
          "new_line_content": "\tauto target_data = FlatVector::GetData<T>(target);",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": null,
          "new_api": "FlatVector::Validity(target)",
          "old_text": null,
          "new_text": "FlatVector::Validity(target)",
          "old_line_content": "\t// Precompute mask indexes",
          "new_line_content": "\tauto &target_validity = FlatVector::Validity(target);",
          "content_same": false
        },
        {
          "line": 707,
          "old_api": null,
          "new_api": "get_index",
          "old_text": null,
          "new_text": "scan_sel.get_index(i)",
          "old_line_content": "\t\tValidityBytes row_mask(source_row);",
          "new_line_content": "\t\tconst auto &source_row = source_locations[scan_sel.get_index(i)];",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": null,
          "new_api": "GetValidityEntry",
          "old_text": null,
          "new_text": "row_mask.GetValidityEntry(entry_idx)",
          "old_line_content": "\t\t} else {",
          "new_line_content": "\t\tif (row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry)) {",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": null,
          "new_api": "SetInvalid",
          "old_text": null,
          "new_text": "target_validity.SetInvalid(target_idx)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\ttarget_validity.SetInvalid(target_idx);",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": null,
          "new_api": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "old_text": null,
          "new_text": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "old_line_content": "\t// Target",
          "new_line_content": "\tauto source_locations = FlatVector::GetData<data_ptr_t>(row_locations);",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": null,
          "new_api": "FlatVector::Validity(target)",
          "old_text": null,
          "new_text": "FlatVector::Validity(target)",
          "old_line_content": "\t// Precompute mask indexes",
          "new_line_content": "\tauto &target_validity = FlatVector::Validity(target);",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "ValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry)",
          "old_text": null,
          "new_text": "ValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry)",
          "old_line_content": "\t// Get validity of the struct and create a Vector of pointers to the start of the TupleDataLayout of the STRUCT",
          "new_line_content": "\tValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry);",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": null,
          "new_api": "FlatVector::GetData<data_ptr_t>(struct_row_locations)",
          "old_text": null,
          "new_text": "FlatVector::GetData<data_ptr_t>(struct_row_locations)",
          "old_line_content": "\tfor (idx_t i = 0; i < scan_count; i++) {",
          "new_line_content": "\tauto struct_source_locations = FlatVector::GetData<data_ptr_t>(struct_row_locations);",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": null,
          "new_api": "get_index",
          "old_text": null,
          "new_text": "scan_sel.get_index(i)",
          "old_line_content": "",
          "new_line_content": "\t\tconst auto source_idx = scan_sel.get_index(i);",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": null,
          "new_api": "FlatVector::GetData<data_ptr_t>(chunk_state.row_locations)",
          "old_text": null,
          "new_text": "FlatVector::GetData<data_ptr_t>(chunk_state.row_locations)",
          "old_line_content": "\t// Set the validity mask for each row before inserting data",
          "new_line_content": "\tconst auto row_locations = FlatVector::GetData<data_ptr_t>(chunk_state.row_locations);",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(row_locations[i], ~0, validity_bytes)",
          "old_line_content": "",
          "new_line_content": "\t\tmemset(row_locations[i], ~0, validity_bytes);",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": null,
          "new_api": "get_index",
          "old_text": null,
          "new_text": "target_sel.get_index(i)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tconst auto target_idx = target_sel.get_index(i);",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "SetInvalid",
          "old_text": null,
          "new_text": "target_validity.SetInvalid(target_idx)",
          "old_line_content": "",
          "new_line_content": "\t\t\ttarget_validity.SetInvalid(target_idx);",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": null,
          "new_api": "GetHeapSizeOffset",
          "old_text": null,
          "new_text": "layout.GetHeapSizeOffset()",
          "old_line_content": "\t\tfor (idx_t i = 0; i < append_count; i++) {",
          "new_line_content": "\t\tconst auto heap_size_offset = layout.GetHeapSizeOffset();",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": null,
          "new_api": "Store<uint32_t>(heap_sizes[i], row_locations[i] + heap_size_offset)",
          "old_text": null,
          "new_text": "Store<uint32_t>(heap_sizes[i], row_locations[i] + heap_size_offset)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\tStore<uint32_t>(heap_sizes[i], row_locations[i] + heap_size_offset);",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": null,
          "new_api": "StructVector::GetEntries(target)",
          "old_text": null,
          "new_text": "StructVector::GetEntries(target)",
          "old_line_content": "",
          "new_line_content": "\tauto &struct_targets = StructVector::GetEntries(target);",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "struct_targets.size()",
          "old_line_content": "\t// Recurse through the struct children",
          "new_line_content": "\tD_ASSERT(struct_layout.ColumnCount() == struct_targets.size());",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "new_chunk.size()",
          "old_line_content": "}",
          "new_line_content": "\t\tScatter(chunk_state, new_chunk.data[col_idx], col_idx, append_sel, append_count, new_chunk.size());",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": null,
          "new_api": "ColumnCount",
          "old_text": null,
          "new_text": "struct_layout.ColumnCount()",
          "old_line_content": "\t\tconst auto &struct_gather_function = child_functions[col_idx];",
          "new_line_content": "\tfor (idx_t struct_col_idx = 0; struct_col_idx < struct_layout.ColumnCount(); struct_col_idx++) {",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": null,
          "new_api": "function",
          "old_text": null,
          "new_text": "struct_gather_function.function(struct_layout, struct_row_locations, struct_col_idx, scan_sel, scan_count,\n\t\t                                *struct_target, target_sel, struct_gather_function.child_functions)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tstruct_gather_function.function(struct_layout, struct_row_locations, struct_col_idx, scan_sel, scan_count,",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": null,
          "new_api": "function",
          "old_text": null,
          "new_text": "scatter_function.function(source, chunk_state.vector_data[column_id], append_sel, append_count, original_count,\n\t                          layout, chunk_state.row_locations, chunk_state.heap_locations, column_id,\n\t                          scatter_function.child_functions)",
          "old_line_content": "\t                          scatter_function.child_functions);",
          "new_line_content": "\tscatter_function.function(source, chunk_state.vector_data[column_id], append_sel, append_count, original_count,",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": null,
          "new_api": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "old_text": null,
          "new_text": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "old_line_content": "\t// Load pointers to the data from the row",
          "new_line_content": "\tauto source_locations = FlatVector::GetData<data_ptr_t>(row_locations);",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": null,
          "new_api": "Load<uint32_t>(source_locations[idx] + heap_size_offset)",
          "old_text": null,
          "new_text": "Load<uint32_t>(source_locations[idx] + heap_size_offset)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tconst auto stored_heap_size = Load<uint32_t>(source_locations[idx] + heap_size_offset);",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": null,
          "new_api": "D_ASSERT",
          "old_text": null,
          "new_text": "D_ASSERT(stored_heap_size == heap_sizes[idx])",
          "old_line_content": "#endif",
          "new_line_content": "\t\tD_ASSERT(stored_heap_size == heap_sizes[idx]);",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": null,
          "new_api": "FlatVector::GetData<data_ptr_t>(list_locations)",
          "old_text": null,
          "new_text": "FlatVector::GetData<data_ptr_t>(list_locations)",
          "old_line_content": "\tfor (idx_t i = 0; i < scan_count; i++) {",
          "new_line_content": "\tauto source_heap_locations = FlatVector::GetData<data_ptr_t>(list_locations);",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": null,
          "new_api": "get_index",
          "old_text": null,
          "new_text": "scan_sel.get_index(i)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tconst auto &source_row = source_locations[scan_sel.get_index(i)];",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": null,
          "new_api": "Load<data_ptr_t>(source_row + offset_in_row)",
          "old_text": null,
          "new_text": "Load<data_ptr_t>(source_row + offset_in_row)",
          "old_line_content": "",
          "new_line_content": "\t\tsource_heap_locations[i] = Load<data_ptr_t>(source_row + offset_in_row);",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": null,
          "new_api": "FlatVector::GetData<data_ptr_t>(input.row_locations)",
          "old_text": null,
          "new_text": "FlatVector::GetData<data_ptr_t>(input.row_locations)",
          "old_line_content": "",
          "new_line_content": "\tconst auto source_locations = FlatVector::GetData<data_ptr_t>(input.row_locations);",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": null,
          "new_api": "FlatVector::GetData<data_ptr_t>(chunk_state.row_locations)",
          "old_text": null,
          "new_text": "FlatVector::GetData<data_ptr_t>(chunk_state.row_locations)",
          "old_line_content": "\t// Copy rows",
          "new_line_content": "\tconst auto target_locations = FlatVector::GetData<data_ptr_t>(chunk_state.row_locations);",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": null,
          "new_api": "RowOperations::HeapGather(target, scan_count, target_sel, col_idx, source_heap_locations, source_locations)",
          "old_text": null,
          "new_text": "RowOperations::HeapGather(target, scan_count, target_sel, col_idx, source_heap_locations, source_locations)",
          "old_line_content": "",
          "new_line_content": "\tRowOperations::HeapGather(target, scan_count, target_sel, col_idx, source_heap_locations, source_locations);",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": null,
          "new_api": "GetTypes",
          "old_text": null,
          "new_text": "layout.GetTypes()",
          "old_line_content": "\tTupleDataGatherFunction result;",
          "new_line_content": "\tconst auto &type = layout.GetTypes()[col_idx];",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": null,
          "new_api": "get_index",
          "old_text": null,
          "new_text": "append_sel.get_index(i)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tauto idx = append_sel.get_index(i);",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "FastMemcpy",
          "old_text": null,
          "new_text": "FastMemcpy(target_locations[i], source_locations[idx], row_width)",
          "old_line_content": "",
          "new_line_content": "\t\tFastMemcpy(target_locations[i], source_locations[idx], row_width);",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": null,
          "new_api": "InternalType",
          "old_text": null,
          "new_text": "type.InternalType()",
          "old_line_content": "\t\tfunction = TemplatedTupleDataGather<bool>;",
          "new_line_content": "\tswitch (type.InternalType()) {",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": null,
          "new_api": "FlatVector::GetData<idx_t>(input.heap_sizes)",
          "old_text": null,
          "new_text": "FlatVector::GetData<idx_t>(input.heap_sizes)",
          "old_line_content": "",
          "new_line_content": "\t\tconst auto heap_sizes = FlatVector::GetData<idx_t>(input.heap_sizes);",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": null,
          "new_api": "GetHeapSizeOffset",
          "old_text": null,
          "new_text": "layout.GetHeapSizeOffset()",
          "old_line_content": "\t\t// Check if we need to copy anything at all",
          "new_line_content": "\t\tVerifyHeapSizes(source_locations, heap_sizes, append_sel, append_count, layout.GetHeapSizeOffset());",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": null,
          "new_api": "get_index",
          "old_text": null,
          "new_text": "append_sel.get_index(i)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tauto idx = append_sel.get_index(i);",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": null,
          "new_api": "get_index",
          "old_text": null,
          "new_text": "append_sel.get_index(i)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tauto idx = append_sel.get_index(i);",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": null,
          "new_api": "FastMemcpy",
          "old_text": null,
          "new_text": "FastMemcpy(target_heap_locations[i], source_heap_locations[idx], heap_sizes[idx])",
          "old_line_content": "",
          "new_line_content": "\t\t\tFastMemcpy(target_heap_locations[i], source_heap_locations[idx], heap_sizes[idx]);",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": null,
          "new_api": "TupleDataAllocator::RecomputeHeapPointers(input.heap_locations, append_sel, target_locations,\n\t\t                                          chunk_state.heap_locations, 0, append_count, layout, 0)",
          "old_text": null,
          "new_text": "TupleDataAllocator::RecomputeHeapPointers(input.heap_locations, append_sel, target_locations,\n\t\t                                          chunk_state.heap_locations, 0, append_count, layout, 0)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tTupleDataAllocator::RecomputeHeapPointers(input.heap_locations, append_sel, target_locations,",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": null,
          "new_api": "GetLayout",
          "old_text": null,
          "new_text": "other.GetLayout().GetTypes()",
          "old_line_content": "\t}",
          "new_line_content": "\tif (this->layout.GetTypes() != other.GetLayout().GetTypes()) {",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "other.segments.size()",
          "old_line_content": "\t\t// Same allocator - combine segments",
          "new_line_content": "\tif (this->segments.size() == 1 && other.segments.size() == 1 &&",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": null,
          "new_api": "Combine",
          "old_text": null,
          "new_text": "this->segments[0].Combine(other.segments[0])",
          "old_line_content": "\t\t// Different allocator - append segments",
          "new_line_content": "\t\tthis->segments[0].Combine(other.segments[0]);",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": null,
          "new_api": "std::move(other_seg)",
          "old_text": null,
          "new_text": "std::move(other_seg)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\tthis->segments.emplace_back(std::move(other_seg));",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": null,
          "new_api": "ColumnCount",
          "old_text": null,
          "new_text": "struct_layout.ColumnCount()",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tfor (idx_t struct_col_idx = 0; struct_col_idx < struct_layout.ColumnCount(); struct_col_idx++) {",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": null,
          "new_api": "GetGatherFunction",
          "old_text": null,
          "new_text": "GetGatherFunction(struct_layout, struct_col_idx)",
          "old_line_content": "\t\tbreak;",
          "new_line_content": "\t\t\tresult.child_functions.push_back(GetGatherFunction(struct_layout, struct_col_idx));",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": null,
          "new_api": "Reset",
          "old_text": null,
          "new_text": "other.Reset()",
          "old_line_content": "}",
          "new_line_content": "\tother.Reset();",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "Verify()",
          "old_line_content": "",
          "new_line_content": "\tVerify();",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "segments.clear()",
          "old_line_content": "\t// Refreshes the TupleDataAllocator to prevent holding on to allocated data unnecessarily",
          "new_line_content": "\tsegments.clear();",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": null,
          "new_api": "InternalException",
          "old_text": null,
          "new_text": "InternalException(\"Unsupported type for TupleDataCollection::GetGatherFunction\")",
          "old_line_content": "\tresult.function = function;",
          "new_line_content": "\t\tthrow InternalException(\"Unsupported type for TupleDataCollection::GetGatherFunction\");",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": null,
          "new_api": "make_shared<TupleDataAllocator>(*allocator)",
          "old_text": null,
          "new_text": "make_shared<TupleDataAllocator>(*allocator)",
          "old_line_content": "",
          "new_line_content": "\tallocator = make_shared<TupleDataAllocator>(*allocator);",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": null,
          "new_api": "GetTypes",
          "old_text": null,
          "new_text": "layout.GetTypes()",
          "old_line_content": "",
          "new_line_content": "\tchunk.Initialize(allocator->GetAllocator(), layout.GetTypes());",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": null,
          "new_api": "NotImplementedException",
          "old_text": null,
          "new_text": "NotImplementedException(\"TupleDataCollection::Pin\")",
          "old_line_content": "",
          "new_line_content": "\tthrow NotImplementedException(\"TupleDataCollection::Pin\");",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "column_ids.size()",
          "old_line_content": "\t\tauto column_idx = column_ids[i];",
          "new_line_content": "\tchunk_types.reserve(column_ids.size());",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "segment.pinned_handles.clear()",
          "old_line_content": "}",
          "new_line_content": "\t\tsegment.pinned_handles.clear();",
          "content_same": false
        },
        {
          "line": 352,
          "old_api": null,
          "new_api": "ColumnCount",
          "old_text": null,
          "new_text": "layout.ColumnCount()",
          "old_line_content": "\t}",
          "new_line_content": "\t\tD_ASSERT(column_idx < layout.ColumnCount());",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": null,
          "new_api": "GetAllocator",
          "old_text": null,
          "new_text": "allocator->GetAllocator()",
          "old_line_content": "",
          "new_line_content": "\tchunk.Initialize(allocator->GetAllocator(), chunk_types);",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": null,
          "new_api": "InitializeChunk",
          "old_text": null,
          "new_text": "InitializeChunk(chunk)",
          "old_line_content": "\tTupleDataScanState scan_state;",
          "new_line_content": "\tInitializeChunk(chunk);",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": null,
          "new_api": "Count",
          "old_text": null,
          "new_text": "Count()",
          "old_line_content": "\tidx_t row_count = 0;",
          "new_line_content": "\tstring result = StringUtil::Format(\"TupleDataCollection - [%llu Chunks, %llu Rows]\\n\", ChunkCount(), Count());",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": null,
          "new_api": "ColumnCount",
          "old_text": null,
          "new_text": "layout.ColumnCount()",
          "old_line_content": "\t}",
          "new_line_content": "\tfor (idx_t i = 0; i < layout.ColumnCount(); i++) {",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": null,
          "new_api": "std::move(column_ids)",
          "old_text": null,
          "new_text": "std::move(column_ids)",
          "old_line_content": "",
          "new_line_content": "\tInitializeScan(state, std::move(column_ids), properties);",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "chunk.size()",
          "old_line_content": "\t\tchunk_idx++;",
          "new_line_content": "\t\t    StringUtil::Format(\"Chunk %llu - [Rows %llu - %llu]\\n\", chunk_idx, row_count, row_count + chunk.size()) +",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "chunk.size()",
          "old_line_content": "",
          "new_line_content": "\t\trow_count += chunk.size();",
          "content_same": false
        },
        {
          "line": 369,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "state.pin_state.row_handles.clear()",
          "old_line_content": "\tstate.pin_state.properties = TupleDataPinProperties::UNPIN_AFTER_DONE;",
          "new_line_content": "\tstate.pin_state.row_handles.clear();",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "state.pin_state.heap_handles.clear()",
          "old_line_content": "\tstate.segment_index = 0;",
          "new_line_content": "\tstate.pin_state.heap_handles.clear();",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": null,
          "new_api": "std::move(column_ids)",
          "old_text": null,
          "new_text": "std::move(column_ids)",
          "old_line_content": "",
          "new_line_content": "\tstate.chunk_state.column_ids = std::move(column_ids);",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "ToString()",
          "old_line_content": "",
          "new_line_content": "\tPrinter::Print(ToString());",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": null,
          "new_api": "InitializeScan",
          "old_text": null,
          "new_text": "InitializeScan(gstate.scan_state, properties)",
          "old_line_content": "",
          "new_line_content": "\tInitializeScan(gstate.scan_state, properties);",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "segment.Verify()",
          "old_line_content": "\t}",
          "new_line_content": "\t\tsegment.Verify();",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": null,
          "new_api": "std::move(column_ids)",
          "old_text": null,
          "new_text": "std::move(column_ids)",
          "old_line_content": "",
          "new_line_content": "\tInitializeScan(state.scan_state, std::move(column_ids), properties);",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": null,
          "new_api": "D_ASSERT",
          "old_text": null,
          "new_text": "D_ASSERT(total_segment_count == this->count)",
          "old_line_content": "}",
          "new_line_content": "\tD_ASSERT(total_segment_count == this->count);",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": null,
          "new_api": "NextScanIndex",
          "old_text": null,
          "new_text": "NextScanIndex(state, segment_index, chunk_index)",
          "old_line_content": "\t}",
          "new_line_content": "\tif (!NextScanIndex(state, segment_index, chunk_index)) {",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "state.pin_state.row_handles.clear()",
          "old_line_content": "\t}",
          "new_line_content": "\t\tstate.pin_state.row_handles.clear();",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": null,
          "new_api": "ScanAtIndex",
          "old_text": null,
          "new_text": "ScanAtIndex(state.pin_state, state.chunk_state, state.chunk_state.column_ids, segment_index, chunk_index, result)",
          "old_line_content": "}",
          "new_line_content": "\tScanAtIndex(state.pin_state, state.chunk_state, state.chunk_state.column_ids, segment_index, chunk_index, result);",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": null,
          "new_api": "NextScanIndex",
          "old_text": null,
          "new_text": "NextScanIndex(gstate.scan_state, scan_state.segment_index, scan_state.chunk_index)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tif (!NextScanIndex(gstate.scan_state, scan_state.segment_index, scan_state.chunk_index)) {",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "scan_state.pin_state.row_handles.clear()",
          "old_line_content": "\t}",
          "new_line_content": "\t\tscan_state.pin_state.row_handles.clear();",
          "content_same": false
        },
        {
          "line": 415,
          "old_api": null,
          "new_api": "ScanAtIndex",
          "old_text": null,
          "new_text": "ScanAtIndex(scan_state.pin_state, scan_state.chunk_state, gstate.scan_state.chunk_state.column_ids,\n\t            scan_state.segment_index, scan_state.chunk_index, result)",
          "old_line_content": "\treturn true;",
          "new_line_content": "\tScanAtIndex(scan_state.pin_state, scan_state.chunk_state, gstate.scan_state.chunk_state.column_ids,",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": null,
          "new_api": "ColumnCount",
          "old_text": null,
          "new_text": "layout.ColumnCount()",
          "old_line_content": "\t}",
          "new_line_content": "\tfor (idx_t col_idx = 0; col_idx < layout.ColumnCount(); col_idx++) {",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": null,
          "new_api": "Gather",
          "old_text": null,
          "new_text": "Gather(row_locations, scan_sel, scan_count, column_ids, result, target_sel)",
          "old_line_content": "",
          "new_line_content": "\tGather(row_locations, scan_sel, scan_count, column_ids, result, target_sel);",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "column_ids.size()",
          "old_line_content": "\t}",
          "new_line_content": "\tfor (idx_t col_idx = 0; col_idx < column_ids.size(); col_idx++) {",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": null,
          "new_api": "Gather",
          "old_text": null,
          "new_text": "Gather(row_locations, scan_sel, scan_count, column_ids[col_idx], result.data[col_idx], target_sel)",
          "old_line_content": "}",
          "new_line_content": "\t\tGather(row_locations, scan_sel, scan_count, column_ids[col_idx], result.data[col_idx], target_sel);",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": null,
          "new_api": "function",
          "old_text": null,
          "new_text": "gather_function.function(layout, row_locations, column_id, scan_sel, scan_count, result, target_sel,\n\t                         gather_function.child_functions)",
          "old_line_content": "}",
          "new_line_content": "\tgather_function.function(layout, row_locations, column_id, scan_sel, scan_count, result, target_sel,",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": null,
          "new_api": "FlatVector::GetData<idx_t>(chunk_state.heap_sizes)",
          "old_text": null,
          "new_text": "FlatVector::GetData<idx_t>(chunk_state.heap_sizes)",
          "old_line_content": "",
          "new_line_content": "\tauto heap_sizes = FlatVector::GetData<idx_t>(chunk_state.heap_sizes);",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": null,
          "new_api": "ColumnCount",
          "old_text": null,
          "new_text": "new_chunk.ColumnCount()",
          "old_line_content": "\t\t                                      chunk_state.vector_data[col_idx], append_sel, append_count,",
          "new_line_content": "\tfor (idx_t col_idx = 0; col_idx < new_chunk.ColumnCount(); col_idx++) {",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "new_chunk.size()",
          "old_line_content": "}",
          "new_line_content": "\t\t                                      new_chunk.size());",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": null,
          "new_api": "Store<T>(source, row_location + offset_in_row)",
          "old_text": null,
          "new_text": "Store<T>(source, row_location + offset_in_row)",
          "old_line_content": "",
          "new_line_content": "\tStore<T>(source, row_location + offset_in_row);",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": null,
          "new_api": "IsInlined",
          "old_text": null,
          "new_text": "source.IsInlined()",
          "old_line_content": "\t} else {",
          "new_line_content": "\tif (source.IsInlined()) {",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": null,
          "new_api": "GetSize",
          "old_text": null,
          "new_text": "source.GetSize()",
          "old_line_content": "\t}",
          "new_line_content": "\t\tStore<string_t>(string_t((const char *)heap_location, source.GetSize()), row_location + offset_in_row);",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": null,
          "new_api": "GetSize",
          "old_text": null,
          "new_text": "source.GetSize()",
          "old_line_content": "}",
          "new_line_content": "\t\theap_location += source.GetSize();",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": null,
          "new_api": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "old_text": null,
          "new_text": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "old_line_content": "",
          "new_line_content": "\tauto target_locations = FlatVector::GetData<data_ptr_t>(row_locations);",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": null,
          "new_api": "GetOffsets",
          "old_text": null,
          "new_text": "layout.GetOffsets()",
          "old_line_content": "\t\tfor (idx_t i = 0; i < append_count; i++) {",
          "new_line_content": "\tconst auto offset_in_row = layout.GetOffsets()[col_idx];",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": null,
          "new_api": "get_index",
          "old_text": null,
          "new_text": "append_sel.get_index(i)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tauto source_idx = source_sel.get_index(append_sel.get_index(i));",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": null,
          "new_api": "TupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row, target_heap_locations[i])",
          "old_text": null,
          "new_text": "TupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row, target_heap_locations[i])",
          "old_line_content": "\t} else {",
          "new_line_content": "\t\t\tTupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row, target_heap_locations[i]);",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": null,
          "new_api": "RowIsValid",
          "old_text": null,
          "new_text": "validity.RowIsValid(source_idx)",
          "old_line_content": "\t\t\t\t                         target_heap_locations[i]);",
          "new_line_content": "\t\t\tif (validity.RowIsValid(source_idx)) {",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": null,
          "new_api": "TupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row,\n\t\t\t\t                         target_heap_locations[i])",
          "old_text": null,
          "new_text": "TupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row,\n\t\t\t\t                         target_heap_locations[i])",
          "old_line_content": "\t\t\t} else {",
          "new_line_content": "\t\t\t\tTupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row,",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": null,
          "new_api": "SetValidUnsafe",
          "old_text": null,
          "new_text": "ValidityBytes(target_locations[i]).SetValidUnsafe(col_idx)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\t\tValidityBytes(target_locations[i]).SetValidUnsafe(col_idx);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 521,
          "old_api": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "new_text": null,
          "old_line_content": "\tauto target_locations = FlatVector::GetData<data_ptr_t>(row_locations);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": "get_index",
          "new_api": null,
          "old_text": "append_sel.get_index(i)",
          "new_text": null,
          "old_line_content": "\t\tauto source_idx = source_sel.get_index(append_sel.get_index(i));",
          "new_line_content": "\t// Set validity of the STRUCT in this layout",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": "RowIsValid",
          "new_api": null,
          "old_text": "validity.RowIsValid(source_idx)",
          "new_text": null,
          "old_line_content": "\t\tif (!validity.RowIsValid(source_idx)) {",
          "new_line_content": "\tfor (idx_t i = 0; i < append_count; i++) {",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": "FlatVector::GetData<data_ptr_t>(struct_row_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(struct_row_locations)",
          "new_text": null,
          "old_line_content": "\tauto struct_target_locations = FlatVector::GetData<data_ptr_t>(struct_row_locations);",
          "new_line_content": "\t// Create a Vector of pointers to the TupleDataLayout of the STRUCT",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "GetOffsets",
          "new_api": null,
          "old_text": "layout.GetOffsets()",
          "new_text": null,
          "old_line_content": "\tconst auto offset_in_row = layout.GetOffsets()[col_idx];",
          "new_line_content": "\tVector struct_row_locations(LogicalType::POINTER, append_count);",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "GetStructLayouts",
          "new_api": null,
          "old_text": "layout.GetStructLayouts().end()",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(layout.GetStructLayouts().find(col_idx) != layout.GetStructLayouts().end());",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": "GetStructLayouts",
          "new_api": null,
          "old_text": "layout.GetStructLayouts().find(col_idx)",
          "new_text": null,
          "old_line_content": "\tconst auto &struct_layout = layout.GetStructLayouts().find(col_idx)->second;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "ColumnCount",
          "new_api": null,
          "old_text": "struct_layout.ColumnCount()",
          "new_text": null,
          "old_line_content": "\tfor (idx_t struct_col_idx = 0; struct_col_idx < struct_layout.ColumnCount(); struct_col_idx++) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": "ToUnifiedFormat",
          "new_api": null,
          "old_text": "struct_source->ToUnifiedFormat(original_count, struct_source_data)",
          "new_text": null,
          "old_line_content": "\t\tstruct_source->ToUnifiedFormat(original_count, struct_source_data);",
          "new_line_content": "\t\tconst auto &struct_source = struct_sources[struct_col_idx];",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "function",
          "new_api": null,
          "old_text": "struct_scatter_function.function(*struct_sources[struct_col_idx], struct_source_data, append_sel, append_count,\n\t\t                                 original_count, struct_layout, struct_row_locations, heap_locations,\n\t\t                                 struct_col_idx, struct_scatter_function.child_functions)",
          "new_text": null,
          "old_line_content": "\t\tstruct_scatter_function.function(*struct_sources[struct_col_idx], struct_source_data, append_sel, append_count,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "new_text": null,
          "old_line_content": "\tauto target_locations = FlatVector::GetData<data_ptr_t>(row_locations);",
          "new_line_content": "                                 const vector<TupleDataScatterFunction> &child_functions) {",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "FlatVector::GetData<data_ptr_t>(heap_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(heap_locations)",
          "new_text": null,
          "old_line_content": "\tauto target_heap_locations = FlatVector::GetData<data_ptr_t>(heap_locations);",
          "new_line_content": "\t// Target",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "GetOffsets",
          "new_api": null,
          "old_text": "layout.GetOffsets()",
          "new_text": null,
          "old_line_content": "\tconst auto offset_in_row = layout.GetOffsets()[col_idx];",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "RowOperations::HeapScatter(source, original_count, append_sel, append_count, col_idx, target_heap_locations,\n\t                           target_locations)",
          "new_api": null,
          "old_text": "RowOperations::HeapScatter(source, original_count, append_sel, append_count, col_idx, target_heap_locations,\n\t                           target_locations)",
          "new_text": null,
          "old_line_content": "\tRowOperations::HeapScatter(source, original_count, append_sel, append_count, col_idx, target_heap_locations,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "GetTypes",
          "new_api": null,
          "old_text": "layout.GetTypes()",
          "new_text": null,
          "old_line_content": "\tconst auto &type = layout.GetTypes()[col_idx];",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": "InternalType",
          "new_api": null,
          "old_text": "type.InternalType()",
          "new_text": null,
          "old_line_content": "\tswitch (type.InternalType()) {",
          "new_line_content": "\tTupleDataScatterFunction result;",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": "GetStructLayouts",
          "new_api": null,
          "old_text": "layout.GetStructLayouts().end()",
          "new_text": null,
          "old_line_content": "\t\tD_ASSERT(layout.GetStructLayouts().find(col_idx) != layout.GetStructLayouts().end());",
          "new_line_content": "\tcase PhysicalType::STRUCT: {",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "GetStructLayouts",
          "new_api": null,
          "old_text": "layout.GetStructLayouts().find(col_idx)",
          "new_text": null,
          "old_line_content": "\t\tconst auto &struct_layout = layout.GetStructLayouts().find(col_idx)->second;",
          "new_line_content": "\t\tfunction = StructTupleDataScatter;",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": "InternalException",
          "new_api": null,
          "old_text": "InternalException(\"Unsupported type for TupleDataCollection::GetScatterFunction\")",
          "new_text": null,
          "old_line_content": "\t\tthrow InternalException(\"Unsupported type for TupleDataCollection::GetScatterFunction\");",
          "new_line_content": "\t\tbreak;",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": "ReleaseOrStoreHandles",
          "new_api": null,
          "old_text": "segment.allocator->ReleaseOrStoreHandles(pin_state, segment)",
          "new_text": null,
          "old_line_content": "\tsegment.allocator->ReleaseOrStoreHandles(pin_state, segment);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": "size",
          "new_api": null,
          "old_text": "segments.size()",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(segments.size() == 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "back",
          "new_api": null,
          "old_text": "segments.back()",
          "new_text": null,
          "old_line_content": "\tallocator->ReleaseOrStoreHandles(pin_state, segments.back());",
          "new_line_content": "void TupleDataCollection::FinalizePinState(TupleDataPinState &pin_state) {",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": "size",
          "new_api": null,
          "old_text": "segments.size()",
          "new_text": null,
          "old_line_content": "\tif (state.segment_index >= segments.size()) {",
          "new_line_content": "bool TupleDataCollection::NextScanIndex(TupleDataScanState &state, idx_t &segment_index, idx_t &chunk_index) {",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": "ChunkCount",
          "new_api": null,
          "old_text": "segments[state.segment_index].ChunkCount()",
          "new_text": null,
          "old_line_content": "\twhile (state.chunk_index >= segments[state.segment_index].ChunkCount()) {",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": "size",
          "new_api": null,
          "old_text": "segments.size()",
          "new_text": null,
          "old_line_content": "\t\tif (state.segment_index >= segments.size()) {",
          "new_line_content": "\t\tstate.segment_index++;",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "InitializeChunkState",
          "new_api": null,
          "old_text": "segment.allocator->InitializeChunkState(segment, pin_state, chunk_state, chunk_index, false)",
          "new_text": null,
          "old_line_content": "\tsegment.allocator->InitializeChunkState(segment, pin_state, chunk_state, chunk_index, false);",
          "new_line_content": "\tauto &segment = segments[segment_index];",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": "Reset",
          "new_api": null,
          "old_text": "result.Reset()",
          "new_text": null,
          "old_line_content": "\tresult.Reset();",
          "new_line_content": "\tauto &chunk = segment.chunks[chunk_index];",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "new_text": null,
          "old_line_content": "\tauto source_locations = FlatVector::GetData<data_ptr_t>(row_locations);",
          "new_line_content": "                                     const vector<TupleDataGatherFunction> &child_functions) {",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": "FlatVector::GetData<T>(target)",
          "new_api": null,
          "old_text": "FlatVector::GetData<T>(target)",
          "new_text": null,
          "old_line_content": "\tauto target_data = FlatVector::GetData<T>(target);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": "FlatVector::Validity(target)",
          "new_api": null,
          "old_text": "FlatVector::Validity(target)",
          "new_text": null,
          "old_line_content": "\tauto &target_validity = FlatVector::Validity(target);",
          "new_line_content": "\t// Target",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": "ValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry)",
          "new_api": null,
          "old_text": "ValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry)",
          "new_text": null,
          "old_line_content": "\tValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry);",
          "new_line_content": "\tidx_t entry_idx;",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": "get_index",
          "new_api": null,
          "old_text": "target_sel.get_index(i)",
          "new_text": null,
          "old_line_content": "\t\tconst auto target_idx = target_sel.get_index(i);",
          "new_line_content": "\tfor (idx_t i = 0; i < scan_count; i++) {",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": "Load<T>(source_row + offset_in_row)",
          "new_api": null,
          "old_text": "Load<T>(source_row + offset_in_row)",
          "new_text": null,
          "old_line_content": "\t\t\ttarget_data[target_idx] = Load<T>(source_row + offset_in_row);",
          "new_line_content": "\t\tValidityBytes row_mask(source_row);",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "new_text": null,
          "old_line_content": "\tauto source_locations = FlatVector::GetData<data_ptr_t>(row_locations);",
          "new_line_content": "                                  const vector<TupleDataGatherFunction> &child_functions) {",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "FlatVector::Validity(target)",
          "new_api": null,
          "old_text": "FlatVector::Validity(target)",
          "new_text": null,
          "old_line_content": "\tauto &target_validity = FlatVector::Validity(target);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "ValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry)",
          "new_api": null,
          "old_text": "ValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry)",
          "new_text": null,
          "old_line_content": "\tValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry);",
          "new_line_content": "\tidx_t entry_idx;",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "FlatVector::GetData<data_ptr_t>(struct_row_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(struct_row_locations)",
          "new_text": null,
          "old_line_content": "\tauto struct_source_locations = FlatVector::GetData<data_ptr_t>(struct_row_locations);",
          "new_line_content": "\t// Get validity of the struct and create a Vector of pointers to the start of the TupleDataLayout of the STRUCT",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": "GetOffsets",
          "new_api": null,
          "old_text": "layout.GetOffsets()",
          "new_text": null,
          "old_line_content": "\tconst auto offset_in_row = layout.GetOffsets()[col_idx];",
          "new_line_content": "\tVector struct_row_locations(LogicalType::POINTER);",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": "FlatVector::GetData<data_ptr_t>(chunk_state.row_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(chunk_state.row_locations)",
          "new_text": null,
          "old_line_content": "\tauto row_locations = FlatVector::GetData<data_ptr_t>(chunk_state.row_locations);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "GetValidityEntry",
          "new_api": null,
          "old_text": "row_mask.GetValidityEntry(entry_idx)",
          "new_text": null,
          "old_line_content": "\t\tif (!row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry)) {",
          "new_line_content": "\t\t// Set the validity",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "get_index",
          "new_api": null,
          "old_text": "target_sel.get_index(i)",
          "new_text": null,
          "old_line_content": "\t\t\tconst auto target_idx = target_sel.get_index(i);",
          "new_line_content": "\t\tValidityBytes row_mask(source_row);",
          "content_same": false
        },
        {
          "line": 233,
          "old_api": "AllConstant",
          "new_api": null,
          "old_text": "layout.AllConstant()",
          "new_text": null,
          "old_line_content": "\tif (!layout.AllConstant()) {",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": "FlatVector::GetData<idx_t>(chunk_state.heap_sizes)",
          "new_api": null,
          "old_text": "FlatVector::GetData<idx_t>(chunk_state.heap_sizes)",
          "new_text": null,
          "old_line_content": "\t\tconst auto heap_sizes = FlatVector::GetData<idx_t>(chunk_state.heap_sizes);",
          "new_line_content": "\t\t// Set the heap size for each row",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": "GetStructLayouts",
          "new_api": null,
          "old_text": "layout.GetStructLayouts().end()",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(layout.GetStructLayouts().find(col_idx) != layout.GetStructLayouts().end());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": "GetStructLayouts",
          "new_api": null,
          "old_text": "layout.GetStructLayouts().find(col_idx)",
          "new_text": null,
          "old_line_content": "\tconst auto &struct_layout = layout.GetStructLayouts().find(col_idx)->second;",
          "new_line_content": "\t// Get the struct layout and struct entries",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": "size",
          "new_api": null,
          "old_text": "new_chunk.size()",
          "new_text": null,
          "old_line_content": "\t\tScatter(chunk_state, new_chunk.data[col_idx], col_idx, append_sel, append_count, new_chunk.size());",
          "new_line_content": "\t// Write the data",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "ColumnCount",
          "new_api": null,
          "old_text": "struct_layout.ColumnCount()",
          "new_text": null,
          "old_line_content": "\tfor (idx_t struct_col_idx = 0; struct_col_idx < struct_layout.ColumnCount(); struct_col_idx++) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": "function",
          "new_api": null,
          "old_text": "struct_gather_function.function(struct_layout, struct_row_locations, struct_col_idx, scan_sel, scan_count,\n\t\t                                *struct_target, target_sel, struct_gather_function.child_functions)",
          "new_text": null,
          "old_line_content": "\t\tstruct_gather_function.function(struct_layout, struct_row_locations, struct_col_idx, scan_sel, scan_count,",
          "new_line_content": "\t\tconst auto &struct_target = struct_targets[struct_col_idx];",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": "function",
          "new_api": null,
          "old_text": "scatter_function.function(source, chunk_state.vector_data[column_id], append_sel, append_count, original_count,\n\t                          layout, chunk_state.row_locations, chunk_state.heap_locations, column_id,\n\t                          scatter_function.child_functions)",
          "new_text": null,
          "old_line_content": "\tscatter_function.function(source, chunk_state.vector_data[column_id], append_sel, append_count, original_count,",
          "new_line_content": "                                  const idx_t original_count) const {",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "new_text": null,
          "old_line_content": "\tauto source_locations = FlatVector::GetData<data_ptr_t>(row_locations);",
          "new_line_content": "                                const vector<TupleDataGatherFunction> &child_functions) {",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": "get_index",
          "new_api": null,
          "old_text": "append_sel.get_index(i)",
          "new_text": null,
          "old_line_content": "\t\tauto idx = append_sel.get_index(i);",
          "new_line_content": "#ifdef DEBUG",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": "Load<uint32_t>(source_locations[idx] + heap_size_offset)",
          "new_api": null,
          "old_text": "Load<uint32_t>(source_locations[idx] + heap_size_offset)",
          "new_text": null,
          "old_line_content": "\t\tconst auto stored_heap_size = Load<uint32_t>(source_locations[idx] + heap_size_offset);",
          "new_line_content": "\tfor (idx_t i = 0; i < append_count; i++) {",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": "FlatVector::GetData<data_ptr_t>(list_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(list_locations)",
          "new_text": null,
          "old_line_content": "\tauto source_heap_locations = FlatVector::GetData<data_ptr_t>(list_locations);",
          "new_line_content": "\t// Load pointers to the data from the row",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "GetOffsets",
          "new_api": null,
          "old_text": "layout.GetOffsets()",
          "new_text": null,
          "old_line_content": "\tconst auto offset_in_row = layout.GetOffsets()[col_idx];",
          "new_line_content": "\tVector list_locations(LogicalType::POINTER);",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": "Load<data_ptr_t>(source_row + offset_in_row)",
          "new_api": null,
          "old_text": "Load<data_ptr_t>(source_row + offset_in_row)",
          "new_text": null,
          "old_line_content": "\t\tsource_heap_locations[i] = Load<data_ptr_t>(source_row + offset_in_row);",
          "new_line_content": "\tfor (idx_t i = 0; i < scan_count; i++) {",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": "FlatVector::GetData<data_ptr_t>(input.row_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(input.row_locations)",
          "new_text": null,
          "old_line_content": "\tconst auto source_locations = FlatVector::GetData<data_ptr_t>(input.row_locations);",
          "new_line_content": "void TupleDataCollection::CopyRows(TupleDataChunkState &chunk_state, TupleDataChunkState &input,",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "FlatVector::GetData<data_ptr_t>(chunk_state.row_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(chunk_state.row_locations)",
          "new_text": null,
          "old_line_content": "\tconst auto target_locations = FlatVector::GetData<data_ptr_t>(chunk_state.row_locations);",
          "new_line_content": "                                   const SelectionVector &append_sel, const idx_t append_count) const {",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": "RowOperations::HeapGather(target, scan_count, target_sel, col_idx, source_heap_locations, source_locations)",
          "new_api": null,
          "old_text": "RowOperations::HeapGather(target, scan_count, target_sel, col_idx, source_heap_locations, source_locations)",
          "new_text": null,
          "old_line_content": "\tRowOperations::HeapGather(target, scan_count, target_sel, col_idx, source_heap_locations, source_locations);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": "GetRowWidth",
          "new_api": null,
          "old_text": "layout.GetRowWidth()",
          "new_text": null,
          "old_line_content": "\tconst auto row_width = layout.GetRowWidth();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": "GetTypes",
          "new_api": null,
          "old_text": "layout.GetTypes()",
          "new_text": null,
          "old_line_content": "\tconst auto &type = layout.GetTypes()[col_idx];",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": "FastMemcpy",
          "new_api": null,
          "old_text": "FastMemcpy(target_locations[i], source_locations[idx], row_width)",
          "new_text": null,
          "old_line_content": "\t\tFastMemcpy(target_locations[i], source_locations[idx], row_width);",
          "new_line_content": "\tfor (idx_t i = 0; i < append_count; i++) {",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "InternalType",
          "new_api": null,
          "old_text": "type.InternalType()",
          "new_text": null,
          "old_line_content": "\tswitch (type.InternalType()) {",
          "new_line_content": "\tTupleDataGatherFunction result;",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": "AllConstant",
          "new_api": null,
          "old_text": "layout.AllConstant()",
          "new_text": null,
          "old_line_content": "\tif (!layout.AllConstant()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": "FlatVector::GetData<data_ptr_t>(input.heap_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(input.heap_locations)",
          "new_text": null,
          "old_line_content": "\t\tconst auto source_heap_locations = FlatVector::GetData<data_ptr_t>(input.heap_locations);",
          "new_line_content": "\t// Copy heap if we need to",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": "get_index",
          "new_api": null,
          "old_text": "append_sel.get_index(i)",
          "new_text": null,
          "old_line_content": "\t\t\tauto idx = append_sel.get_index(i);",
          "new_line_content": "\t\tidx_t total_heap_size = 0;",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": "get_index",
          "new_api": null,
          "old_text": "append_sel.get_index(i)",
          "new_text": null,
          "old_line_content": "\t\t\tauto idx = append_sel.get_index(i);",
          "new_line_content": "\t\t// Copy heap",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": "FastMemcpy",
          "new_api": null,
          "old_text": "FastMemcpy(target_heap_locations[i], source_heap_locations[idx], heap_sizes[idx])",
          "new_text": null,
          "old_line_content": "\t\t\tFastMemcpy(target_heap_locations[i], source_heap_locations[idx], heap_sizes[idx]);",
          "new_line_content": "\t\tfor (idx_t i = 0; i < append_count; i++) {",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "TupleDataAllocator::RecomputeHeapPointers(input.heap_locations, append_sel, target_locations,\n\t\t                                          chunk_state.heap_locations, 0, append_count, layout, 0)",
          "new_api": null,
          "old_text": "TupleDataAllocator::RecomputeHeapPointers(input.heap_locations, append_sel, target_locations,\n\t\t                                          chunk_state.heap_locations, 0, append_count, layout, 0)",
          "new_text": null,
          "old_line_content": "\t\tTupleDataAllocator::RecomputeHeapPointers(input.heap_locations, append_sel, target_locations,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": "GetLayout",
          "new_api": null,
          "old_text": "other.GetLayout().GetTypes()",
          "new_text": null,
          "old_line_content": "\tif (this->layout.GetTypes() != other.GetLayout().GetTypes()) {",
          "new_line_content": "\t\treturn;",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": "InternalException",
          "new_api": null,
          "old_text": "InternalException(\"Attempting to combine TupleDataCollection with mismatching types\")",
          "new_text": null,
          "old_line_content": "\t\tthrow InternalException(\"Attempting to combine TupleDataCollection with mismatching types\");",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": "get",
          "new_api": null,
          "old_text": "other.segments[0].allocator.get()",
          "new_text": null,
          "old_line_content": "\t    this->segments[0].allocator.get() == other.segments[0].allocator.get()) {",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": "std::move(other_seg)",
          "new_api": null,
          "old_text": "std::move(other_seg)",
          "new_text": null,
          "old_line_content": "\t\t\tthis->segments.emplace_back(std::move(other_seg));",
          "new_line_content": "\t\t// Different allocator - append segments",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": "GetStructLayouts",
          "new_api": null,
          "old_text": "layout.GetStructLayouts().end()",
          "new_text": null,
          "old_line_content": "\t\tD_ASSERT(layout.GetStructLayouts().find(col_idx) != layout.GetStructLayouts().end());",
          "new_line_content": "\tcase PhysicalType::STRUCT: {",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": "GetStructLayouts",
          "new_api": null,
          "old_text": "layout.GetStructLayouts().find(col_idx)",
          "new_text": null,
          "old_line_content": "\t\tconst auto &struct_layout = layout.GetStructLayouts().find(col_idx)->second;",
          "new_line_content": "\t\tfunction = StructTupleDataGather;",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": "Reset",
          "new_api": null,
          "old_text": "other.Reset()",
          "new_text": null,
          "old_line_content": "\tother.Reset();",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 328,
          "old_api": "Verify",
          "new_api": null,
          "old_text": "Verify()",
          "new_text": null,
          "old_line_content": "\tVerify();",
          "new_line_content": "\tthis->count += other.count;",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": "clear",
          "new_api": null,
          "old_text": "segments.clear()",
          "new_text": null,
          "old_line_content": "\tsegments.clear();",
          "new_line_content": "void TupleDataCollection::Reset() {",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": "InternalException",
          "new_api": null,
          "old_text": "InternalException(\"Unsupported type for TupleDataCollection::GetGatherFunction\")",
          "new_text": null,
          "old_line_content": "\t\tthrow InternalException(\"Unsupported type for TupleDataCollection::GetGatherFunction\");",
          "new_line_content": "\t\tbreak;",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": "make_shared<TupleDataAllocator>(*allocator)",
          "new_api": null,
          "old_text": "make_shared<TupleDataAllocator>(*allocator)",
          "new_text": null,
          "old_line_content": "\tallocator = make_shared<TupleDataAllocator>(*allocator);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": "GetTypes",
          "new_api": null,
          "old_text": "layout.GetTypes()",
          "new_text": null,
          "old_line_content": "\tchunk.Initialize(allocator->GetAllocator(), layout.GetTypes());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": "NotImplementedException",
          "new_api": null,
          "old_text": "NotImplementedException(\"TupleDataCollection::Pin\")",
          "new_text": null,
          "old_line_content": "\tthrow NotImplementedException(\"TupleDataCollection::Pin\");",
          "new_line_content": "void TupleDataCollection::Pin() {",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": "empty",
          "new_api": null,
          "old_text": "column_ids.empty()",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(!column_ids.empty());",
          "new_line_content": "void TupleDataCollection::InitializeScanChunk(TupleDataScanState &state, DataChunk &chunk) const {",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": "clear",
          "new_api": null,
          "old_text": "segment.pinned_handles.clear()",
          "new_text": null,
          "old_line_content": "\t\tsegment.pinned_handles.clear();",
          "new_line_content": "void TupleDataCollection::Unpin() {",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": "size",
          "new_api": null,
          "old_text": "column_ids.size()",
          "new_text": null,
          "old_line_content": "\tfor (idx_t i = 0; i < column_ids.size(); i++) {",
          "new_line_content": "\tvector<LogicalType> chunk_types;",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": "GetTypes",
          "new_api": null,
          "old_text": "layout.GetTypes()",
          "new_text": null,
          "old_line_content": "\t\tchunk_types.push_back(layout.GetTypes()[column_idx]);",
          "new_line_content": "\t\tauto column_idx = column_ids[i];",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "InitializeChunk",
          "new_api": null,
          "old_text": "InitializeChunk(chunk)",
          "new_text": null,
          "old_line_content": "\tInitializeChunk(chunk);",
          "new_line_content": "string TupleDataCollection::ToString() {",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": "InitializeScan",
          "new_api": null,
          "old_text": "InitializeScan(scan_state)",
          "new_text": null,
          "old_line_content": "\tInitializeScan(scan_state);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": "ColumnCount",
          "new_api": null,
          "old_text": "layout.ColumnCount()",
          "new_text": null,
          "old_line_content": "\tcolumn_ids.reserve(layout.ColumnCount());",
          "new_line_content": "void TupleDataCollection::InitializeScan(TupleDataScanState &state, TupleDataScanProperties properties) const {",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": "ColumnCount",
          "new_api": null,
          "old_text": "layout.ColumnCount()",
          "new_text": null,
          "old_line_content": "\tfor (idx_t i = 0; i < layout.ColumnCount(); i++) {",
          "new_line_content": "\tvector<column_t> column_ids;",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": "Scan",
          "new_api": null,
          "old_text": "Scan(scan_state, chunk)",
          "new_text": null,
          "old_line_content": "\twhile (Scan(scan_state, chunk)) {",
          "new_line_content": "\tidx_t chunk_idx = 0;",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "chunk.ToString()",
          "new_text": null,
          "old_line_content": "\t\t    chunk.ToString();",
          "new_line_content": "\t\tresult +=",
          "content_same": false
        },
        {
          "line": 367,
          "old_api": "clear",
          "new_api": null,
          "old_text": "state.pin_state.row_handles.clear()",
          "new_text": null,
          "old_line_content": "\tstate.pin_state.row_handles.clear();",
          "new_line_content": "void TupleDataCollection::InitializeScan(TupleDataScanState &state, vector<column_t> column_ids,",
          "content_same": false
        },
        {
          "line": 368,
          "old_api": "clear",
          "new_api": null,
          "old_text": "state.pin_state.heap_handles.clear()",
          "new_text": null,
          "old_line_content": "\tstate.pin_state.heap_handles.clear();",
          "new_line_content": "                                         TupleDataScanProperties properties) const {",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": "std::move(column_ids)",
          "new_api": null,
          "old_text": "std::move(column_ids)",
          "new_text": null,
          "old_line_content": "\tstate.chunk_state.column_ids = std::move(column_ids);",
          "new_line_content": "\tstate.chunk_index = 0;",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "ToString()",
          "new_text": null,
          "old_line_content": "\tPrinter::Print(ToString());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": "InitializeScan",
          "new_api": null,
          "old_text": "InitializeScan(gstate.scan_state, properties)",
          "new_text": null,
          "old_line_content": "\tInitializeScan(gstate.scan_state, properties);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": "Verify",
          "new_api": null,
          "old_text": "segment.Verify()",
          "new_text": null,
          "old_line_content": "\t\tsegment.Verify();",
          "new_line_content": "\tidx_t total_segment_count = 0;",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": "std::move(column_ids)",
          "new_api": null,
          "old_text": "std::move(column_ids)",
          "new_text": null,
          "old_line_content": "\tInitializeScan(state.scan_state, std::move(column_ids), properties);",
          "new_line_content": "void TupleDataCollection::InitializeScan(TupleDataParallelScanState &state, vector<column_t> column_ids,",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": "D_ASSERT",
          "new_api": null,
          "old_text": "D_ASSERT(total_segment_count == this->count)",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(total_segment_count == this->count);",
          "new_line_content": "\t\ttotal_segment_count += segment.count;",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": "NextScanIndex",
          "new_api": null,
          "old_text": "NextScanIndex(state, segment_index, chunk_index)",
          "new_text": null,
          "old_line_content": "\tif (!NextScanIndex(state, segment_index, chunk_index)) {",
          "new_line_content": "\tidx_t segment_index;",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": "clear",
          "new_api": null,
          "old_text": "state.pin_state.row_handles.clear()",
          "new_text": null,
          "old_line_content": "\t\tstate.pin_state.row_handles.clear();",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": "clear",
          "new_api": null,
          "old_text": "state.pin_state.heap_handles.clear()",
          "new_text": null,
          "old_line_content": "\t\tstate.pin_state.heap_handles.clear();",
          "new_line_content": "\tif (segment_index != segment_index_before) {",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": "NextScanIndex",
          "new_api": null,
          "old_text": "NextScanIndex(gstate.scan_state, scan_state.segment_index, scan_state.chunk_index)",
          "new_text": null,
          "old_line_content": "\t\tif (!NextScanIndex(gstate.scan_state, scan_state.segment_index, scan_state.chunk_index)) {",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "clear",
          "new_api": null,
          "old_text": "scan_state.pin_state.row_handles.clear()",
          "new_text": null,
          "old_line_content": "\t\tscan_state.pin_state.row_handles.clear();",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": "clear",
          "new_api": null,
          "old_text": "scan_state.pin_state.heap_handles.clear()",
          "new_text": null,
          "old_line_content": "\t\tscan_state.pin_state.heap_handles.clear();",
          "new_line_content": "\tif (scan_state.segment_index != segment_index_before) {",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": "ColumnCount",
          "new_api": null,
          "old_text": "layout.ColumnCount()",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(result.ColumnCount() == layout.ColumnCount());",
          "new_line_content": "void TupleDataCollection::Gather(Vector &row_locations, const SelectionVector &scan_sel, const idx_t scan_count,",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": "ColumnCount",
          "new_api": null,
          "old_text": "layout.ColumnCount()",
          "new_text": null,
          "old_line_content": "\tfor (idx_t col_idx = 0; col_idx < layout.ColumnCount(); col_idx++) {",
          "new_line_content": "\tvector<column_t> column_ids;",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": "ColumnCount",
          "new_api": null,
          "old_text": "result.ColumnCount()",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(column_ids.size() == result.ColumnCount());",
          "new_line_content": "                                 const vector<column_t> &column_ids, DataChunk &result,",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": "size",
          "new_api": null,
          "old_text": "column_ids.size()",
          "new_text": null,
          "old_line_content": "\tfor (idx_t col_idx = 0; col_idx < column_ids.size(); col_idx++) {",
          "new_line_content": "                                 const SelectionVector &target_sel) const {",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": "function",
          "new_api": null,
          "old_text": "gather_function.function(layout, row_locations, column_id, scan_sel, scan_count, result, target_sel,\n\t                         gather_function.child_functions)",
          "new_text": null,
          "old_line_content": "\tgather_function.function(layout, row_locations, column_id, scan_sel, scan_count, result, target_sel,",
          "new_line_content": "                                 const column_t column_id, Vector &result, const SelectionVector &target_sel) const {",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": "FlatVector::GetData<idx_t>(chunk_state.heap_sizes)",
          "new_api": null,
          "old_text": "FlatVector::GetData<idx_t>(chunk_state.heap_sizes)",
          "new_text": null,
          "old_line_content": "\tauto heap_sizes = FlatVector::GetData<idx_t>(chunk_state.heap_sizes);",
          "new_line_content": "void TupleDataCollection::ComputeHeapSizes(TupleDataChunkState &chunk_state, DataChunk &new_chunk,",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": "size",
          "new_api": null,
          "old_text": "new_chunk.size()",
          "new_text": null,
          "old_line_content": "\tstd::fill_n(heap_sizes, new_chunk.size(), 0);",
          "new_line_content": "                                           const SelectionVector &append_sel, const idx_t append_count) {",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": "size",
          "new_api": null,
          "old_text": "TupleDataCollection::ComputeHeapSizes(chunk_state.heap_sizes, new_chunk.data[col_idx],\n\t\t                                      chunk_state.vector_data[col_idx], append_sel, append_count,\n\t\t                                      new_chunk.size())",
          "new_text": null,
          "old_line_content": "\t\tTupleDataCollection::ComputeHeapSizes(chunk_state.heap_sizes, new_chunk.data[col_idx],",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": "Store<T>(source, row_location + offset_in_row)",
          "new_api": null,
          "old_text": "Store<T>(source, row_location + offset_in_row)",
          "new_text": null,
          "old_line_content": "\tStore<T>(source, row_location + offset_in_row);",
          "new_line_content": "static inline void TupleDataValueScatter(const T &source, const data_ptr_t &row_location, const idx_t offset_in_row,",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "IsInlined",
          "new_api": null,
          "old_text": "source.IsInlined()",
          "new_text": null,
          "old_line_content": "\tif (source.IsInlined()) {",
          "new_line_content": "inline void TupleDataValueScatter(const string_t &source, const data_ptr_t &row_location, const idx_t offset_in_row,",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "Store<string_t>(source, row_location + offset_in_row)",
          "new_api": null,
          "old_text": "Store<string_t>(source, row_location + offset_in_row)",
          "new_text": null,
          "old_line_content": "\t\tStore<string_t>(source, row_location + offset_in_row);",
          "new_line_content": "                                  data_ptr_t &heap_location) {",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": "GetSize",
          "new_api": null,
          "old_text": "source.GetSize()",
          "new_text": null,
          "old_line_content": "\t\tStore<string_t>(string_t((const char *)heap_location, source.GetSize()), row_location + offset_in_row);",
          "new_line_content": "\t} else {",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(row_locations)",
          "new_text": null,
          "old_line_content": "\tauto target_locations = FlatVector::GetData<data_ptr_t>(row_locations);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": "FlatVector::GetData<data_ptr_t>(heap_locations)",
          "new_api": null,
          "old_text": "FlatVector::GetData<data_ptr_t>(heap_locations)",
          "new_text": null,
          "old_line_content": "\tauto target_heap_locations = FlatVector::GetData<data_ptr_t>(heap_locations);",
          "new_line_content": "\t// Target",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": "AllValid",
          "new_api": null,
          "old_text": "validity.AllValid()",
          "new_text": null,
          "old_line_content": "\tif (validity.AllValid()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "TupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row, target_heap_locations[i])",
          "new_api": null,
          "old_text": "TupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row, target_heap_locations[i])",
          "new_text": null,
          "old_line_content": "\t\t\tTupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row, target_heap_locations[i]);",
          "new_line_content": "\t\tfor (idx_t i = 0; i < append_count; i++) {",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "get_index",
          "new_api": null,
          "old_text": "append_sel.get_index(i)",
          "new_text": null,
          "old_line_content": "\t\t\tauto source_idx = source_sel.get_index(append_sel.get_index(i));",
          "new_line_content": "\t} else {",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": "RowIsValid",
          "new_api": null,
          "old_text": "validity.RowIsValid(source_idx)",
          "new_text": null,
          "old_line_content": "\t\t\tif (validity.RowIsValid(source_idx)) {",
          "new_line_content": "\t\tfor (idx_t i = 0; i < append_count; i++) {",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": "TupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row,\n\t\t\t\t                         target_heap_locations[i])",
          "new_api": null,
          "old_text": "TupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row,\n\t\t\t\t                         target_heap_locations[i])",
          "new_text": null,
          "old_line_content": "\t\t\t\tTupleDataValueScatter<T>(data[source_idx], target_locations[i], offset_in_row,",
          "new_line_content": "\t\t\t\t                         target_heap_locations[i]);",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 49,
      "total_additions": 125,
      "total_deletions": 124,
      "total_api_changes": 298
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 4,
        "api_related_lines": 298,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          230
        ]
      }
    },
    "api_calls_before": 330,
    "api_calls_after": 329,
    "diff_info": {
      "added_lines": 4,
      "removed_lines": 2,
      "total_diff_lines": 20
    }
  }
}