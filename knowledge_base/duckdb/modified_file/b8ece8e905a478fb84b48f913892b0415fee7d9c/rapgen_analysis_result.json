{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/b8ece8e905a478fb84b48f913892b0415fee7d9c",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/b8ece8e905a478fb84b48f913892b0415fee7d9c/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/b8ece8e905a478fb84b48f913892b0415fee7d9c/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/b8ece8e905a478fb84b48f913892b0415fee7d9c/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 407,
          "old_api": "unlock",
          "new_api": "clear",
          "old_text": "io_lock.unlock()",
          "new_text": "handles_to_unload.clear()",
          "old_line_content": "\tio_lock.unlock();",
          "new_line_content": "\t\t\thandles_to_unload.clear();",
          "content_same": false
        },
        {
          "line": 439,
          "old_api": "lock",
          "new_api": "TryGetBlockHandle",
          "old_text": "map_entry.second.lock()",
          "new_text": "node->TryGetBlockHandle()",
          "old_line_content": "\t\tauto &block = *map_entry.second.lock();",
          "new_line_content": "\t\tauto handle = node->TryGetBlockHandle();",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": "OutOfMemoryException",
          "new_api": "erase",
          "old_text": "OutOfMemoryException(\n\t\t    \"Failed to change memory limit to %lld: could not free up enough memory for the new limit\", limit)",
          "new_text": "temp_blocks.erase(block_id)",
          "old_line_content": "\t\tthrow OutOfMemoryException(",
          "new_line_content": "\t\ttemp_blocks.erase(block_id);",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": "Exception",
          "new_api": "EvictBlocks",
          "old_text": "Exception(\n\t\t    \"Out-of-memory: cannot write buffer because no temporary directory is specified!\\nTo enable \"\n\t\t    \"temporary buffer eviction set a temporary directory using PRAGMA temp_directory='/path/to/tmp.tmp'\")",
          "new_text": "EvictBlocks(0, limit)",
          "old_line_content": "\t\tthrow Exception(",
          "new_line_content": "\tif (!EvictBlocks(0, limit)) {",
          "content_same": false
        },
        {
          "line": 513,
          "old_api": "D_ASSERT",
          "new_api": "empty",
          "old_text": "D_ASSERT(buffer.size >= Storage::BLOCK_SIZE)",
          "new_text": "temp_directory.empty()",
          "old_line_content": "\tD_ASSERT(buffer.size >= Storage::BLOCK_SIZE);",
          "new_line_content": "\tif (temp_directory.empty()) {",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": "GetTemporaryPath",
          "new_api": "D_ASSERT",
          "old_text": "GetTemporaryPath(id)",
          "new_text": "D_ASSERT(buffer.size >= Storage::BLOCK_SIZE)",
          "old_line_content": "\tauto path = GetTemporaryPath(id);",
          "new_line_content": "\tD_ASSERT(buffer.size >= Storage::BLOCK_SIZE);",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": "OpenFile",
          "new_api": "GetTemporaryPath",
          "old_text": "fs.OpenFile(path, FileFlags::FILE_FLAGS_READ)",
          "new_text": "GetTemporaryPath(buffer.id)",
          "old_line_content": "\tauto handle = fs.OpenFile(path, FileFlags::FILE_FLAGS_READ);",
          "new_line_content": "\tauto path = GetTemporaryPath(buffer.id);",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "make_unique<ManagedBuffer>(db, block_size, false, id)",
          "new_api": "Write",
          "old_text": "make_unique<ManagedBuffer>(db, block_size, false, id)",
          "new_text": "handle->Write(&buffer.size, sizeof(idx_t), 0)",
          "old_line_content": "\tauto buffer = make_unique<ManagedBuffer>(db, block_size, false, id);",
          "new_line_content": "\thandle->Write(&buffer.size, sizeof(idx_t), 0);",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": "Read",
          "new_api": "Write",
          "old_text": "buffer->Read(*handle, sizeof(idx_t))",
          "new_text": "buffer.Write(*handle, sizeof(idx_t))",
          "old_line_content": "\tbuffer->Read(*handle, sizeof(idx_t));",
          "new_line_content": "\tbuffer.Write(*handle, sizeof(idx_t));",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "move",
          "new_api": "empty",
          "old_text": "move(buffer)",
          "new_text": "temp_directory.empty()",
          "old_line_content": "\treturn move(buffer);",
          "new_line_content": "\tD_ASSERT(!temp_directory.empty());",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": "empty",
          "new_api": "GetTemporaryPath",
          "old_text": "temp_directory.empty()",
          "new_text": "GetTemporaryPath(id)",
          "old_line_content": "\tif (temp_directory.empty() || !temp_directory_handle) {",
          "new_line_content": "\tauto path = GetTemporaryPath(id);",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": "FileSystem::GetFileSystem(db)",
          "new_api": "Read",
          "old_text": "FileSystem::GetFileSystem(db)",
          "new_text": "handle->Read(&block_size, sizeof(idx_t), 0)",
          "old_line_content": "\tauto &fs = FileSystem::GetFileSystem(db);",
          "new_line_content": "\thandle->Read(&block_size, sizeof(idx_t), 0);",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": "RemoveFile",
          "new_api": "make_unique<ManagedBuffer>(db, block_size, false, id)",
          "old_text": "fs.RemoveFile(path)",
          "new_text": "make_unique<ManagedBuffer>(db, block_size, false, id)",
          "old_line_content": "\t\tfs.RemoveFile(path);",
          "new_line_content": "\tauto buffer = make_unique<ManagedBuffer>(db, block_size, false, id);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 514,
          "old_api": null,
          "new_api": "Exception",
          "old_text": null,
          "new_text": "Exception(\n\t\t    \"Out-of-memory: cannot write buffer because no temporary directory is specified!\\nTo enable \"\n\t\t    \"temporary buffer eviction set a temporary directory using PRAGMA temp_directory='/path/to/tmp.tmp'\")",
          "old_line_content": "\t// get the path to write to",
          "new_line_content": "\t\tthrow Exception(",
          "content_same": false
        },
        {
          "line": 521,
          "old_api": null,
          "new_api": "make_unique<TemporaryDirectoryHandle>(db, temp_directory)",
          "old_text": null,
          "new_text": "make_unique<TemporaryDirectoryHandle>(db, temp_directory)",
          "old_line_content": "}",
          "new_line_content": "\t\ttemp_directory_handle = make_unique<TemporaryDirectoryHandle>(db, temp_directory);",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": null,
          "new_api": "RequireTemporaryDirectory",
          "old_text": null,
          "new_text": "RequireTemporaryDirectory()",
          "old_line_content": "\tidx_t block_size;",
          "new_line_content": "\tRequireTemporaryDirectory();",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": null,
          "new_api": "Unload",
          "old_text": null,
          "new_text": "h->Unload()",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t\th->Unload();",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": null,
          "new_api": "FileSystem::GetFileSystem(db)",
          "old_text": null,
          "new_text": "FileSystem::GetFileSystem(db)",
          "old_line_content": "",
          "new_line_content": "\tauto &fs = FileSystem::GetFileSystem(db);",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": null,
          "new_api": "OpenFile",
          "old_text": null,
          "new_text": "fs.OpenFile(path, FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE)",
          "old_line_content": "\t// now allocate a buffer of this size and read the data into that buffer",
          "new_line_content": "\tauto handle = fs.OpenFile(path, FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE);",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": null,
          "new_api": "unlock",
          "old_text": null,
          "new_text": "h->lock.unlock()",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t\th->lock.unlock();",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": null,
          "new_api": "unlock",
          "old_text": null,
          "new_text": "memory_full_lock.unlock()",
          "old_line_content": "\t\t// we could not free up enough space",
          "new_line_content": "\t\t\t\tmemory_full_lock.unlock();",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "temp_directory_handle.get()",
          "old_line_content": "}",
          "new_line_content": "\tD_ASSERT(temp_directory_handle.get());",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": null,
          "new_api": "FileSystem::GetFileSystem(db)",
          "old_text": null,
          "new_text": "FileSystem::GetFileSystem(db)",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\tauto &fs = FileSystem::GetFileSystem(db);",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": null,
          "new_api": "OpenFile",
          "old_text": null,
          "new_text": "fs.OpenFile(path, FileFlags::FILE_FLAGS_READ)",
          "old_line_content": "\t}",
          "new_line_content": "\tauto handle = fs.OpenFile(path, FileFlags::FILE_FLAGS_READ);",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": null,
          "new_api": "Unload",
          "old_text": null,
          "new_text": "h->Unload()",
          "old_line_content": "}",
          "new_line_content": "\t\th->Unload();",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": null,
          "new_api": "unlock",
          "old_text": null,
          "new_text": "h->lock.unlock()",
          "old_line_content": "\tunique_ptr<BufferEvictionNode> node;",
          "new_line_content": "\t\th->lock.unlock();",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": null,
          "new_api": "Read",
          "old_text": null,
          "new_text": "buffer->Read(*handle, sizeof(idx_t))",
          "old_line_content": "\t}",
          "new_line_content": "\tbuffer->Read(*handle, sizeof(idx_t));",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": null,
          "new_api": "unlock",
          "old_text": null,
          "new_text": "io_lock.unlock()",
          "old_line_content": "\t\t\tbreak;",
          "new_line_content": "\tio_lock.unlock();",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "handle.reset()",
          "old_line_content": "",
          "new_line_content": "\thandle.reset();",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": null,
          "new_api": "DeleteTemporaryFile",
          "old_text": null,
          "new_text": "DeleteTemporaryFile(id)",
          "old_line_content": "} // namespace duckdb",
          "new_line_content": "\tDeleteTemporaryFile(id);",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(buffer)",
          "old_line_content": "",
          "new_line_content": "\treturn move(buffer);",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": null,
          "new_api": "unlock",
          "old_text": null,
          "new_text": "memory_full_lock.unlock()",
          "old_line_content": "\t\tif (!handle) {",
          "new_line_content": "\t\tmemory_full_lock.unlock();",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "temp_directory.empty()",
          "old_line_content": "",
          "new_line_content": "\tif (temp_directory.empty() || !temp_directory_handle) {",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "FileSystem::GetFileSystem(db)",
          "old_text": null,
          "new_text": "FileSystem::GetFileSystem(db)",
          "old_line_content": "",
          "new_line_content": "\tauto &fs = FileSystem::GetFileSystem(db);",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": null,
          "new_api": "GetTemporaryPath",
          "old_text": null,
          "new_text": "GetTemporaryPath(id)",
          "old_line_content": "",
          "new_line_content": "\tauto path = GetTemporaryPath(id);",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": null,
          "new_api": "FileExists",
          "old_text": null,
          "new_text": "fs.FileExists(path)",
          "old_line_content": "",
          "new_line_content": "\tif (fs.FileExists(path)) {",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": null,
          "new_api": "RemoveFile",
          "old_text": null,
          "new_text": "fs.RemoveFile(path)",
          "old_line_content": "",
          "new_line_content": "\t\tfs.RemoveFile(path);",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": null,
          "new_api": "try_dequeue",
          "old_text": null,
          "new_text": "queue->q.try_dequeue(node)",
          "old_line_content": "\tlock_guard<mutex> tb_lock(temp_blocks_lock);",
          "new_line_content": "\t\tif (!queue->q.try_dequeue(node)) {",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": null,
          "new_api": "move",
          "old_text": null,
          "new_text": "move(node)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\tqueue->q.enqueue(move(node));",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": null,
          "new_api": "lock",
          "old_text": null,
          "new_text": "map_entry.second.lock()",
          "old_line_content": "\tif (block_id >= MAXIMUM_BLOCK) {",
          "new_line_content": "\t\tauto &block = *map_entry.second.lock();",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": null,
          "new_api": "D_ASSERT",
          "old_text": null,
          "new_text": "D_ASSERT(summed_memory == current_memory)",
          "old_line_content": "\t\tlock_guard<mutex> lock(blocks_lock);",
          "new_line_content": "\tD_ASSERT(summed_memory == current_memory);",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": null,
          "new_api": "DeleteTemporaryFile",
          "old_text": null,
          "new_text": "DeleteTemporaryFile(block_id)",
          "old_line_content": "\tlock_guard<mutex> cm_lock(current_memory_lock);",
          "new_line_content": "\t\t\tDeleteTemporaryFile(block_id);",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "blocks.erase(block_id)",
          "old_line_content": "\tmaximum_memory = limit;",
          "new_line_content": "\t\tblocks.erase(block_id);",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": null,
          "new_api": "EvictBlocks",
          "old_text": null,
          "new_text": "EvictBlocks(0, limit)",
          "old_line_content": "",
          "new_line_content": "\tif (!EvictBlocks(0, limit)) {",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": null,
          "new_api": "OutOfMemoryException",
          "old_text": null,
          "new_text": "OutOfMemoryException(\n\t\t    \"Failed to change memory limit to %lld: could not free up enough memory for the new limit\", limit)",
          "old_line_content": "string BufferManager::GetTemporaryPath(block_id_t id) {",
          "new_line_content": "\t\tthrow OutOfMemoryException(",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": null,
          "new_api": "OutOfMemoryException",
          "old_text": null,
          "new_text": "OutOfMemoryException(\n\t\t    \"Failed to change memory limit to %lld: could not free up enough memory for the new limit\", limit)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tthrow OutOfMemoryException(",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": null,
          "new_api": "FileSystem::GetFileSystem(db)",
          "old_text": null,
          "new_text": "FileSystem::GetFileSystem(db)",
          "old_line_content": "}",
          "new_line_content": "\tauto &fs = FileSystem::GetFileSystem(db);",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": null,
          "new_api": "to_string",
          "old_text": null,
          "new_text": "to_string(id)",
          "old_line_content": "",
          "new_line_content": "\treturn fs.JoinPath(temp_directory, to_string(id) + \".block\");",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 515,
          "old_api": "GetTemporaryPath",
          "new_api": null,
          "old_text": "GetTemporaryPath(buffer.id)",
          "new_text": null,
          "old_line_content": "\tauto path = GetTemporaryPath(buffer.id);",
          "new_line_content": "\t\t    \"Out-of-memory: cannot write buffer because no temporary directory is specified!\\nTo enable \"",
          "content_same": false
        },
        {
          "line": 517,
          "old_api": "FileSystem::GetFileSystem(db)",
          "new_api": null,
          "old_text": "FileSystem::GetFileSystem(db)",
          "new_text": null,
          "old_line_content": "\tauto &fs = FileSystem::GetFileSystem(db);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": "OpenFile",
          "new_api": null,
          "old_text": "fs.OpenFile(path, FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE)",
          "new_text": null,
          "old_line_content": "\tauto handle = fs.OpenFile(path, FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE);",
          "new_line_content": "\tlock_guard<mutex> temp_handle_guard(temp_handle_lock);",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": "Write",
          "new_api": null,
          "old_text": "handle->Write(&buffer.size, sizeof(idx_t), 0)",
          "new_text": null,
          "old_line_content": "\thandle->Write(&buffer.size, sizeof(idx_t), 0);",
          "new_line_content": "\tif (!temp_directory_handle) {",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": "Write",
          "new_api": null,
          "old_text": "buffer.Write(*handle, sizeof(idx_t))",
          "new_text": null,
          "old_line_content": "\tbuffer.Write(*handle, sizeof(idx_t));",
          "new_line_content": "\t\t// temp directory has not been created yet: initialize it",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": "empty",
          "new_api": null,
          "old_text": "temp_directory.empty()",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(!temp_directory.empty());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": "get",
          "new_api": null,
          "old_text": "temp_directory_handle.get()",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(temp_directory_handle.get());",
          "new_line_content": "void BufferManager::WriteTemporaryBuffer(ManagedBuffer &buffer) {",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": "FileSystem::GetFileSystem(db)",
          "new_api": null,
          "old_text": "FileSystem::GetFileSystem(db)",
          "new_text": null,
          "old_line_content": "\tauto &fs = FileSystem::GetFileSystem(db);",
          "new_line_content": "\t// get the path to write to",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": "Unload",
          "new_api": null,
          "old_text": "h->Unload()",
          "new_text": null,
          "old_line_content": "\t\th->Unload();",
          "new_line_content": "\t\t\tfor (auto &h : handles_to_unload) {",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "Read",
          "new_api": null,
          "old_text": "handle->Read(&block_size, sizeof(idx_t), 0)",
          "new_text": null,
          "old_line_content": "\thandle->Read(&block_size, sizeof(idx_t), 0);",
          "new_line_content": "\t// create the file and write the size followed by the buffer contents",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": "unlock",
          "new_api": null,
          "old_text": "h->lock.unlock()",
          "new_text": null,
          "old_line_content": "\t\th->lock.unlock();",
          "new_line_content": "\t\t\tfor (auto &h : handles_to_unload) {",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "reset",
          "new_api": null,
          "old_text": "handle.reset()",
          "new_text": null,
          "old_line_content": "\thandle.reset();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "unlock",
          "new_api": null,
          "old_text": "memory_full_lock.unlock()",
          "new_text": null,
          "old_line_content": "\t\tmemory_full_lock.unlock();",
          "new_line_content": "\t\t\t\tmf_locked = false;",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "DeleteTemporaryFile",
          "new_api": null,
          "old_text": "DeleteTemporaryFile(id)",
          "new_text": null,
          "old_line_content": "\tDeleteTemporaryFile(id);",
          "new_line_content": "unique_ptr<FileBuffer> BufferManager::ReadTemporaryBuffer(block_id_t id) {",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": "GetTemporaryPath",
          "new_api": null,
          "old_text": "GetTemporaryPath(id)",
          "new_text": null,
          "old_line_content": "\tauto path = GetTemporaryPath(id);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": "FileExists",
          "new_api": null,
          "old_text": "fs.FileExists(path)",
          "new_text": null,
          "old_line_content": "\tif (fs.FileExists(path)) {",
          "new_line_content": "\t// now allocate a buffer of this size and read the data into that buffer",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": "try_dequeue",
          "new_api": null,
          "old_text": "queue->q.try_dequeue(node)",
          "new_text": null,
          "old_line_content": "\t\tif (!queue->q.try_dequeue(node)) {",
          "new_line_content": "\t// unlock io lock again",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": "TryGetBlockHandle",
          "new_api": null,
          "old_text": "node->TryGetBlockHandle()",
          "new_text": null,
          "old_line_content": "\t\tauto handle = node->TryGetBlockHandle();",
          "new_line_content": "\t\t// we could not free up enough space",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": "move",
          "new_api": null,
          "old_text": "move(node)",
          "new_text": null,
          "old_line_content": "\t\t\tqueue->q.enqueue(move(node));",
          "new_line_content": "\t\t// we freed up enough space!",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": "D_ASSERT",
          "new_api": null,
          "old_text": "D_ASSERT(summed_memory == current_memory)",
          "new_text": null,
          "old_line_content": "\tD_ASSERT(summed_memory == current_memory);",
          "new_line_content": "\tlock_guard<mutex> b_lock(blocks_lock);",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": "DeleteTemporaryFile",
          "new_api": null,
          "old_text": "DeleteTemporaryFile(block_id)",
          "new_text": null,
          "old_line_content": "\t\t\tDeleteTemporaryFile(block_id);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": "erase",
          "new_api": null,
          "old_text": "temp_blocks.erase(block_id)",
          "new_text": null,
          "old_line_content": "\t\ttemp_blocks.erase(block_id);",
          "new_line_content": "\t\t\tsummed_memory += block.memory_usage;",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "erase",
          "new_api": null,
          "old_text": "blocks.erase(block_id)",
          "new_text": null,
          "old_line_content": "\t\tblocks.erase(block_id);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": "EvictBlocks",
          "new_api": null,
          "old_text": "EvictBlocks(0, limit)",
          "new_text": null,
          "old_line_content": "\tif (!EvictBlocks(0, limit)) {",
          "new_line_content": "\t\tlock_guard<mutex> tb_lock(temp_blocks_lock);",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "EvictBlocks",
          "new_api": null,
          "old_text": "EvictBlocks(0, limit)",
          "new_text": null,
          "old_line_content": "\tif (!EvictBlocks(0, limit)) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "OutOfMemoryException",
          "new_api": null,
          "old_text": "OutOfMemoryException(\n\t\t    \"Failed to change memory limit to %lld: could not free up enough memory for the new limit\", limit)",
          "new_text": null,
          "old_line_content": "\t\tthrow OutOfMemoryException(",
          "new_line_content": "#ifdef DEBUG",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": "FileSystem::GetFileSystem(db)",
          "new_api": null,
          "old_text": "FileSystem::GetFileSystem(db)",
          "new_text": null,
          "old_line_content": "\tauto &fs = FileSystem::GetFileSystem(db);",
          "new_line_content": "\t\t    \"Failed to change memory limit to %lld: could not free up enough memory for the new limit\", limit);",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "to_string",
          "new_api": null,
          "old_text": "to_string(id)",
          "new_text": null,
          "old_line_content": "\treturn fs.JoinPath(temp_directory, to_string(id) + \".block\");",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "empty",
          "new_api": null,
          "old_text": "temp_directory.empty()",
          "new_text": null,
          "old_line_content": "\tif (temp_directory.empty()) {",
          "new_line_content": "\t// evict again",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "make_unique<TemporaryDirectoryHandle>(db, temp_directory)",
          "new_api": null,
          "old_text": "make_unique<TemporaryDirectoryHandle>(db, temp_directory)",
          "new_text": null,
          "old_line_content": "\t\ttemp_directory_handle = make_unique<TemporaryDirectoryHandle>(db, temp_directory);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": "RequireTemporaryDirectory",
          "new_api": null,
          "old_text": "RequireTemporaryDirectory()",
          "new_text": null,
          "old_line_content": "\tRequireTemporaryDirectory();",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 13,
      "total_additions": 35,
      "total_deletions": 31,
      "total_api_changes": 79
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 16,
        "api_related_lines": 79,
        "non_api_lines": 9,
        "non_api_line_numbers": [
          396,
          399,
          400,
          403,
          406,
          408,
          411,
          412,
          414
        ]
      }
    },
    "api_calls_before": 144,
    "api_calls_after": 148,
    "diff_info": {
      "added_lines": 16,
      "removed_lines": 1,
      "total_diff_lines": 32
    }
  }
}