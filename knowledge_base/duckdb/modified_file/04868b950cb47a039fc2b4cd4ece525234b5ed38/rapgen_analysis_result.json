{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/04868b950cb47a039fc2b4cd4ece525234b5ed38",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/04868b950cb47a039fc2b4cd4ece525234b5ed38/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/04868b950cb47a039fc2b4cd4ece525234b5ed38/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/duckdb/modified_file/04868b950cb47a039fc2b4cd4ece525234b5ed38/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 51,
          "old_api": "std::move(top_n)",
          "new_api": "empty",
          "old_text": "std::move(top_n)",
          "new_text": "order_by.projections.empty()",
          "old_line_content": "\t\t\treturn std::move(top_n);",
          "new_line_content": "\t\tif (order_by.projections.empty() || omit_projection)",
          "content_same": false
        },
        {
          "line": 59,
          "old_api": "std::move(op.offset_val)",
          "new_api": "std::move(order_by.children[0])",
          "old_text": "std::move(op.offset_val)",
          "new_text": "std::move(order_by.children[0])",
          "old_line_content": "\t\tlimit = make_uniq<PhysicalLimitPercent>(op.types, std::move(op.limit_val), std::move(op.offset_val),",
          "new_line_content": "\t\t\ttop_n->children.push_back(std::move(order_by.children[0]));",
          "content_same": false
        },
        {
          "line": 65,
          "old_api": "std::move(op.offset_val)",
          "new_api": "Type",
          "old_text": "std::move(op.offset_val)",
          "new_text": "op.limit_val.Type()",
          "old_line_content": "\t\t\tlimit = make_uniq<PhysicalStreamingLimit>(op.types, std::move(op.limit_val), std::move(op.offset_val),",
          "new_line_content": "\tswitch (op.limit_val.Type()) {",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 68,
          "old_api": null,
          "new_api": "std::move(op.offset_val)",
          "old_text": null,
          "new_text": "std::move(op.offset_val)",
          "old_line_content": "\t\t\t// maintaining insertion order is important",
          "new_line_content": "\t\tlimit = make_uniq<PhysicalLimitPercent>(op.types, std::move(op.limit_val), std::move(op.offset_val),",
          "content_same": false
        },
        {
          "line": 72,
          "old_api": null,
          "new_api": "PreserveInsertionOrder",
          "old_text": null,
          "new_text": "PreserveInsertionOrder(*plan)",
          "old_line_content": "\t\t\t\t                                 op.estimated_cardinality);",
          "new_line_content": "\t\tif (!PreserveInsertionOrder(*plan)) {",
          "content_same": false
        },
        {
          "line": 74,
          "old_api": null,
          "new_api": "std::move(op.offset_val)",
          "old_text": null,
          "new_text": "std::move(op.offset_val)",
          "old_line_content": "\t\t\t\t// source does not support batch index: use a non-parallel streaming limit",
          "new_line_content": "\t\t\tlimit = make_uniq<PhysicalStreamingLimit>(op.types, std::move(op.limit_val), std::move(op.offset_val),",
          "content_same": false
        },
        {
          "line": 44,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "order_by.projections.size()",
          "old_line_content": "\t\t\tidx_t offset_val = 0;",
          "new_line_content": "\t\tfor (idx_t i = 0; i < order_by.projections.size(); i++) {",
          "content_same": false
        },
        {
          "line": 78,
          "old_api": null,
          "new_api": "UseBatchLimit",
          "old_text": null,
          "new_text": "UseBatchLimit(op.limit_val, op.offset_val)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tif (UseBatchIndex(*plan) && UseBatchLimit(op.limit_val, op.offset_val)) {",
          "content_same": false
        },
        {
          "line": 80,
          "old_api": null,
          "new_api": "std::move(op.offset_val)",
          "old_text": null,
          "new_text": "std::move(op.offset_val)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t\tlimit = make_uniq<PhysicalLimit>(op.types, std::move(op.limit_val), std::move(op.offset_val),",
          "content_same": false
        },
        {
          "line": 84,
          "old_api": null,
          "new_api": "std::move(op.offset_val)",
          "old_text": null,
          "new_text": "std::move(op.offset_val)",
          "old_line_content": "}",
          "new_line_content": "\t\t\t\tlimit = make_uniq<PhysicalStreamingLimit>(op.types, std::move(op.limit_val), std::move(op.offset_val),",
          "content_same": false
        },
        {
          "line": 54,
          "old_api": null,
          "new_api": "Type",
          "old_text": null,
          "new_text": "op.offset_val.Type()",
          "old_line_content": "",
          "new_line_content": "\t\t\tif (op.offset_val.Type() == LimitNodeType::CONSTANT_VALUE) {",
          "content_same": false
        },
        {
          "line": 55,
          "old_api": null,
          "new_api": "GetConstantValue",
          "old_text": null,
          "new_text": "op.offset_val.GetConstantValue()",
          "old_line_content": "\tunique_ptr<PhysicalOperator> limit;",
          "new_line_content": "\t\t\t\toffset_val = op.offset_val.GetConstantValue();",
          "content_same": false
        },
        {
          "line": 57,
          "old_api": null,
          "new_api": "GetConstantValue",
          "old_text": null,
          "new_text": "op.limit_val.GetConstantValue()",
          "old_line_content": "\tcase LimitNodeType::EXPRESSION_PERCENTAGE:",
          "new_line_content": "\t\t\tauto top_n = make_uniq<PhysicalTopN>(order_by.children[0]->types, std::move(order_by.orders), op.limit_val.GetConstantValue(),",
          "content_same": false
        },
        {
          "line": 91,
          "old_api": null,
          "new_api": "std::move(plan)",
          "old_text": null,
          "new_text": "std::move(plan)",
          "old_line_content": "",
          "new_line_content": "\tlimit->children.push_back(std::move(plan));",
          "content_same": false
        },
        {
          "line": 60,
          "old_api": null,
          "new_api": "std::move(top_n)",
          "old_text": null,
          "new_text": "std::move(top_n)",
          "old_line_content": "\t\t                                        op.estimated_cardinality);",
          "new_line_content": "\t\t\treturn std::move(top_n);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 69,
          "old_api": "UseBatchLimit",
          "new_api": null,
          "old_text": "UseBatchLimit(op.limit_val, op.offset_val)",
          "new_text": null,
          "old_line_content": "\t\t\tif (UseBatchIndex(*plan) && UseBatchLimit(op.limit_val, op.offset_val)) {",
          "new_line_content": "\t\t                                        op.estimated_cardinality);",
          "content_same": false
        },
        {
          "line": 71,
          "old_api": "std::move(op.offset_val)",
          "new_api": null,
          "old_text": "std::move(op.offset_val)",
          "new_text": null,
          "old_line_content": "\t\t\t\tlimit = make_uniq<PhysicalLimit>(op.types, std::move(op.limit_val), std::move(op.offset_val),",
          "new_line_content": "\tdefault:",
          "content_same": false
        },
        {
          "line": 43,
          "old_api": "empty",
          "new_api": null,
          "old_text": "order_by.projections.empty()",
          "new_text": null,
          "old_line_content": "\t\tif (order_by.projections.empty()) {",
          "new_line_content": "\t\tbool omit_projection = true;",
          "content_same": false
        },
        {
          "line": 75,
          "old_api": "std::move(op.offset_val)",
          "new_api": null,
          "old_text": "std::move(op.offset_val)",
          "new_text": null,
          "old_line_content": "\t\t\t\tlimit = make_uniq<PhysicalStreamingLimit>(op.types, std::move(op.limit_val), std::move(op.offset_val),",
          "new_line_content": "\t\t\t                                          op.estimated_cardinality, true);",
          "content_same": false
        },
        {
          "line": 45,
          "old_api": "Type",
          "new_api": null,
          "old_text": "op.offset_val.Type()",
          "new_text": null,
          "old_line_content": "\t\t\tif (op.offset_val.Type() == LimitNodeType::CONSTANT_VALUE) {",
          "new_line_content": "\t\t\tif (order_by.projections[i] == i) {",
          "content_same": false
        },
        {
          "line": 46,
          "old_api": "GetConstantValue",
          "new_api": null,
          "old_text": "op.offset_val.GetConstantValue()",
          "new_text": null,
          "old_line_content": "\t\t\t\toffset_val = op.offset_val.GetConstantValue();",
          "new_line_content": "\t\t\t\tcontinue;",
          "content_same": false
        },
        {
          "line": 48,
          "old_api": "GetConstantValue",
          "new_api": null,
          "old_text": "op.limit_val.GetConstantValue()",
          "new_text": null,
          "old_line_content": "\t\t\tauto top_n = make_uniq<PhysicalTopN>(op.types, std::move(order_by.orders), op.limit_val.GetConstantValue(),",
          "new_line_content": "\t\t\tomit_projection = false;",
          "content_same": false
        },
        {
          "line": 50,
          "old_api": "std::move(order_by.children[0])",
          "new_api": null,
          "old_text": "std::move(order_by.children[0])",
          "new_text": null,
          "old_line_content": "\t\t\ttop_n->children.push_back(std::move(order_by.children[0]));",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 82,
          "old_api": "std::move(plan)",
          "new_api": null,
          "old_text": "std::move(plan)",
          "new_text": null,
          "old_line_content": "\tlimit->children.push_back(std::move(plan));",
          "new_line_content": "\t\t\t} else {",
          "content_same": false
        },
        {
          "line": 56,
          "old_api": "Type",
          "new_api": null,
          "old_text": "op.limit_val.Type()",
          "new_text": null,
          "old_line_content": "\tswitch (op.limit_val.Type()) {",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 63,
          "old_api": "PreserveInsertionOrder",
          "new_api": null,
          "old_text": "PreserveInsertionOrder(*plan)",
          "new_text": null,
          "old_line_content": "\t\tif (!PreserveInsertionOrder(*plan)) {",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 3,
      "total_additions": 12,
      "total_deletions": 11,
      "total_api_changes": 26
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 11,
        "api_related_lines": 26,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          49,
          52,
          47
        ]
      }
    },
    "api_calls_before": 39,
    "api_calls_after": 40,
    "diff_info": {
      "added_lines": 11,
      "removed_lines": 2,
      "total_diff_lines": 29
    }
  }
}