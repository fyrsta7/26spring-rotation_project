{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/grpc/modified_file/3b23fe62cac979a4120bc5f8909414c45805230e",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/grpc/modified_file/3b23fe62cac979a4120bc5f8909414c45805230e/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/grpc/modified_file/3b23fe62cac979a4120bc5f8909414c45805230e/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/grpc/modified_file/3b23fe62cac979a4120bc5f8909414c45805230e/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 182,
          "old_api": "l::WorkStealingThreadPoolIm",
          "new_api": "ded to a local queue. This",
          "old_text": "l::WorkStealingThreadPoolIm",
          "new_text": "ded to a local queue. This\n",
          "old_line_content": null,
          "new_line_content": "    g_local_queue->Add(closure);",
          "content_same": true
        },
        {
          "line": 193,
          "old_api": "set_tracked",
          "new_api": "\"event_engine\",\n      [](void* arg) {\n        ThreadState*",
          "old_text": ");\n        worker->ThreadBody();\n        delete worker;\n      },\n      new ThreadState(shared_from_this()), nullptr,\n      grpc_core::Thread::Options().set_tracked(false).set_joinable(false))\n      .Start();\n}\n\nvoid WorkStealingThreadPool::WorkStealingThreadPoolImpl::Quiesce() {\n  SetShutdown(true);\n  // Wait until all threads",
          "new_text": "   \"event_engine\",\n      [](void* arg) {\n        ThreadState* ",
          "old_line_content": "  grpc_core::Thread(",
          "new_line_content": "      grpc_core::Timestamp::Now().milliseconds_after_process_epoch(),",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": "rkStealingThre",
          "new_api": "Empty",
          "old_text": "rkStealingThre",
          "new_text": "tting down\");\n  GPR_ASSERT(queue_.Empty());\n  quiesced_.store(true, std::memory_order_relaxed);\n  lifeguard_.BlockUntilShutdownAndRese",
          "old_line_content": "  GPR_ASSERT(queue_.Empty());",
          "new_line_content": "  living_thread_count_.BlockUntilThreadCount(is_threadpool_thread ? 1 : 0,",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": "l throttled) {\n  return throttled_.exch",
          "new_api": "rkStealingThre",
          "old_text": "l throttled) {\n  return throttled_.exch",
          "new_text": "rkStealingThre",
          "old_line_content": "  lifeguard_.BlockUntilShutdownAndReset();",
          "new_line_content": "  GPR_ASSERT(queue_.Empty());",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": "auto was_forking = fork",
          "new_api": "ngThreadPool::WorkStealingThrea",
          "old_text": " auto was_forking = fork",
          "new_text": "ngThreadPool::WorkStealingThrea",
          "old_line_content": "  work_signal_.SignalAll();",
          "new_line_content": "  auto was_shutdown = shutdown_.exchange(is_shutdown);",
          "content_same": false
        },
        {
          "line": 253,
          "old_api": "hreadPool::WorkStealingThreadPoolImpl::Postfork() {\n  Se",
          "new_api": "ckUntilShutdownA",
          "old_text": "hreadPool::WorkStealingThreadPoolImpl::Postfork() {\n  Se",
          "new_text": "ckUntilShutdownA",
          "old_line_content": "  living_thread_count_.BlockUntilThreadCount(0, \"forking\");",
          "new_line_content": "  SetForking(true);",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": "king",
          "new_api": "set",
          "old_text": "king(false);\n  Start();\n}\n\n// -------- ",
          "new_text": "set();\n}\n\nvoid WorkSteal",
          "old_line_content": "  lifeguard_.BlockUntilShutdownAndReset();",
          "new_line_content": "  work_signal_.SignalAll();",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": "millis",
          "new_api": "::Milliseconds(",
          "old_text": "emptTime() - grpc_core::Timestamp::Now())\n                  .millis()));\n    }\n    MaybeStartNewThread();\n  }\n  lifeguard_running_.store(false, std::memory_order_relaxed);\n  lifeguard_is_shut_d",
          "new_text": "::Milliseconds(\n   ",
          "old_line_content": "      lifeguard_should_shut_down_->WaitForNotificationWithTimeout(",
          "new_line_content": "      if (pool_->IsQuiesced()) break;",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": "e",
          "new_api": "millis",
          "old_text": "e(false, std::memory_order_",
          "new_text": "emptTime() - grpc_core::Timestamp::Now())\n                  .millis()));\n    }\n    MaybeStartNewThread();\n  }\n  lifeguard_running_.store(false, std::memory_order_relaxed);\n  lifeguard_is_shut_d",
          "old_line_content": "              (backoff_.NextAttemptTime() - grpc_core::Timestamp::Now())",
          "new_line_content": "      lifeguard_should_shut_down_->WaitForNotificationWithTimeout(",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": "dPool::WorkStealingThreadPoolImpl::Lifeguard::\n    BlockUn",
          "new_api": "();\n}\n\nvoid WorkSteal",
          "old_text": "dPool::WorkStealingThreadPoolImpl::Lifeguard::\n    BlockUn",
          "new_text": "();\n}\n\nvoid WorkSteal",
          "old_line_content": "  lifeguard_running_.store(false, std::memory_order_relaxed);",
          "new_line_content": "    MaybeStartNewThread();",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": "WaitForNotification",
          "new_api": "_SEC_DELAYED",
          "old_text": "                      \"Waiting for lifeguard thread to shut down\");\n    lifeguard_is_shut_down_->WaitForNotification();\n  }\n  // Do an additional wait in case this method races with Lifegu",
          "new_text": "_SEC_DELAYED(kBlockingQuiesceLogRateS",
          "old_line_content": "    GRPC_LOG_EVERY_N_SEC_DELAYED(kBlockingQuiesceLogRateSeconds, GPR_DEBUG,",
          "new_line_content": "  lifeguard_should_shut_down_->Notify();",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": "oid WorkStealingThreadPool::WorkStealingThr",
          "new_api": "core::Notification>();\n  lifeguard_is_shut_dow",
          "old_text": "oid WorkStealingThreadPool::WorkStealingThr",
          "new_text": "core::Notification>();\n  lifeguard_is_shut_dow",
          "old_line_content": "  lifeguard_should_shut_down_ = std::make_unique<grpc_core::Notification>();",
          "new_line_content": "  lifeguard_is_shut_down_->WaitForNotification();",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": "aybeStartNewThread",
          "new_api": "std::make_uniqu",
          "old_text": "aybeStartNewThread() {\n  // No new threads ",
          "new_text": " std::make_uniqu",
          "old_line_content": "  lifeguard_is_shut_down_ = std::make_unique<grpc_core::Notification>();",
          "new_line_content": "  backoff_.Reset();",
          "content_same": false
        },
        {
          "line": 334,
          "old_api": "Reset",
          "new_api": "count",
          "old_text": ">Signal();\n      backoff_.Reset();\n",
          "new_text": "_thread_count()->count() < living_thr",
          "old_line_content": "  if (pool_->busy_thread_count()->count() < living_thread_count) {",
          "new_line_content": "  const auto living_thread_count = pool_->living_thread_count()->count();",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": "t work stealing.\n    return;",
          "new_api": "Reset",
          "old_text": "t work stealing.\n    return;\n ",
          "new_text": ">Signal();\n      backoff_.Reset();\n",
          "old_line_content": "      pool_->work_signal()->Signal();",
          "new_line_content": "  if (pool_->busy_thread_count()->count() < living_thread_count) {",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": "No new threads i",
          "new_api": "tually wake up for an",
          "old_text": "No new threads i",
          "new_text": "tually wake up for an",
          "old_line_content": "      backoff_.Reset();",
          "new_line_content": "    if (!pool_->queue_.Empty()) {",
          "content_same": false
        },
        {
          "line": 362,
          "old_api": "State",
          "new_api": "alingThreadPool::Thr",
          "old_text": "State(\n    std::",
          "new_text": "alingThreadPool::Thr",
          "old_line_content": "  backoff_.Reset();",
          "new_line_content": "  pool_->StartThread();",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": "et_initial_backoff",
          "new_api": "off_",
          "old_text": "et_initial_backoff(kWorkerThreadMinSleepBetweenChecks",
          "new_text": "off_(grpc_core:",
          "old_line_content": "          pool_->living_thread_count()->MakeAutoThreadCounter()),",
          "new_line_content": "    : pool_(std::move(pool)),",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": ": cons",
          "new_api": "p until the thread should no longer run\n  }",
          "old_text": ": cons",
          "new_text": "p until the thread should no longer run\n  }\n  ",
          "old_line_content": "  while (Step()) {",
          "new_line_content": "  pool_->theft_registry()->Enroll(g_local_queue);",
          "content_same": false
        },
        {
          "line": 392,
          "old_api": "Empty",
          "new_api": "IsShutdown",
          "old_text": "ocal_queue->Empty());\n  pool",
          "new_text": "se if (pool_->IsShutdown()) {\n",
          "old_line_content": "        pool_->queue()->Add(closure);",
          "new_line_content": "      closure = g_local_queue->PopMostRecent();",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": "hreadPool::ThreadState",
          "new_api": "_local_queue;\n}",
          "old_text": "hreadPool::ThreadState",
          "new_text": "_local_queue;\n}\n",
          "old_line_content": "  GPR_ASSERT(g_local_queue->Empty());",
          "new_line_content": "    FinishDraining();",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": "()) return false;\n  auto* closure = g_loca",
          "new_api": "ol WorkStealingThr",
          "old_text": "()) return false;\n  auto* closure = g_loca",
          "new_text": "ol WorkStealingThr",
          "old_line_content": "      absl::Milliseconds(kTimeBetweenThrottledThreadStarts.millis()));",
          "new_line_content": "  if (pool_->IsForking()) return;",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": "ns. Depends on the",
          "new_api": "Pull from the global queue",
          "old_text": "ns. Depends on the",
          "new_text": " Pull from the global queue",
          "old_line_content": "  while (!pool_->IsForking()) {",
          "new_line_content": "  grpc_core::Timestamp start_time{grpc_core::Timestamp::Now()};",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": "as more than it requires, a",
          "new_api": "- grpc_core::Times",
          "old_text": "as more than it requires, a",
          "new_text": " - grpc_core::Times",
          "old_line_content": "        backoff_.NextAttemptTime() - grpc_core::Timestamp::Now());",
          "new_line_content": "    if (pool_->IsShutdown()) break;",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": "le long enough.",
          "new_api": "IsShutdown",
          "old_text": "le long enough.\n   ",
          "new_text": "sForking() || pool_->IsShutdown()) break;\n    // Quit a thread if the pool has more than it requires, an",
          "old_line_content": "    if (pool_->IsForking() || pool_->IsShutdown()) break;",
          "new_line_content": "    bool timed_out = pool_->work_signal()->WaitWithTimeout(",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "count",
          "new_api": "Add",
          "old_text": "count()->MakeAutoThreadCoun",
          "new_text": "ue->Add(closure);\n",
          "old_line_content": "    if (closure != nullptr) g_local_queue->Add(closure);",
          "new_line_content": "  if (pool_->IsForking()) {",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "ad is definition",
          "new_api": "ning",
          "old_text": "ad is definition",
          "new_text": "ning() {\n  // ",
          "old_line_content": "  backoff_.Reset();",
          "new_line_content": "    closure->Run();",
          "content_same": false
        },
        {
          "line": 479,
          "old_api": "queue",
          "new_api": "losure != nullptr)",
          "old_text": "if (!pool_->queue()->Empty()) ",
          "new_text": "losure != nullptr)",
          "old_line_content": "      auto* closure = g_local_queue->PopMostRecent();",
          "new_line_content": "  while (!pool_->IsForking()) {",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": "pMostRecent",
          "new_api": "queue",
          "old_text": "pMostRecent();",
          "new_text": "if (!pool_->queue()->Empty()) ",
          "old_line_content": "        closure->Run();",
          "new_line_content": "      auto* closure = g_local_queue->PopMostRecent();",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": "oid WorkSteali",
          "new_api": "break;\n  }\n}\n\n// -------- Work",
          "old_text": "oid WorkSteali",
          "new_text": " break;\n  }\n}\n\n// -------- Work",
          "old_line_content": "        closure->Run();",
          "new_line_content": "      auto* closure = pool_->queue()->PopMostRecent();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 513,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "  return cv_.WaitWithTimeout(&mu_, absl::Milliseconds(time.millis()));",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": null,
          "new_api": "formance on 32-core",
          "old_text": null,
          "new_text": "formance on 32-core",
          "old_line_content": "  }",
          "new_line_content": "    queue_.Add(closure);",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": null,
          "new_api": "store",
          "old_text": null,
          "new_text": "store(\n      grpc_cor",
          "old_line_content": "",
          "new_line_content": "  work_signal_.Signal();",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": null,
          "new_api": "relaxed);\n  grpc_core::Thread(\n      \"event_engine\",\n      [](void* arg) {\n        ThreadState* worker = static_cast<ThreadState*>",
          "old_text": null,
          "new_text": "relaxed);\n  grpc_core::Thread(\n      \"event_engine\",\n      [](void* arg) {\n        ThreadState* worker = static_cast<ThreadState*>",
          "old_line_content": "      std::memory_order_relaxed);",
          "new_line_content": "  last_started_thread_.store(",
          "content_same": false
        },
        {
          "line": 195,
          "old_api": null,
          "new_api": "set_tracked",
          "old_text": null,
          "new_text": ");\n        worker->ThreadBody();\n        delete worker;\n      },\n      new ThreadState(shared_from_this()), nullptr,\n      grpc_core::Thread::Options().set_tracked(false).set_joinable(false))\n      .Start();\n}\n\nvoid WorkStealingThreadPool::WorkStealingThreadPoolImpl::Quiesce() {\n  SetShutdown(true);\n  // Wait until all threads",
          "old_line_content": "      [](void* arg) {",
          "new_line_content": "  grpc_core::Thread(",
          "content_same": false
        },
        {
          "line": 198,
          "old_api": null,
          "new_api": "_from_this",
          "old_text": null,
          "new_text": "_from_this()), nullptr,\n      ",
          "old_line_content": "        delete worker;",
          "new_line_content": "        ThreadState* worker = static_cast<ThreadState*>(arg);",
          "content_same": false
        },
        {
          "line": 199,
          "old_api": null,
          "new_api": ":Thread::Options().s",
          "old_text": null,
          "new_text": ":Thread::Options().s",
          "old_line_content": "      },",
          "new_line_content": "        worker->ThreadBody();",
          "content_same": false
        },
        {
          "line": 202,
          "old_api": null,
          "new_api": "void WorkStealin",
          "old_text": null,
          "new_text": "\n\nvoid WorkStealin",
          "old_line_content": "      .Start();",
          "new_line_content": "      new ThreadState(shared_from_this()), nullptr,",
          "content_same": false
        },
        {
          "line": 203,
          "old_api": null,
          "new_api": "tealingThreadPoolImpl::Quiesce() {\n  SetShutdown(true);\n  // Wait u",
          "old_text": null,
          "new_text": "tealingThreadPoolImpl::Quiesce() {\n  SetShutdown(true);\n  // Wait u",
          "old_line_content": "}",
          "new_line_content": "      grpc_core::Thread::Options().set_tracked(false).set_joinable(false))",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": null,
          "new_api": "it this thread",
          "old_text": null,
          "new_text": "it this thread\n  ",
          "old_line_content": "  // Note that if this is a threadpool thread then we won't exit this thread",
          "new_line_content": "  SetShutdown(true);",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "                          ",
          "old_line_content": "                                             \"shutting down\");",
          "new_line_content": "  work_signal()->SignalAll();",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": null,
          "new_api": "l::WorkStealingThreadPoolImpl::SetThrottled(",
          "old_text": null,
          "new_text": "l::WorkStealingThreadPoolImpl::SetThrottled(\n   ",
          "old_line_content": "}",
          "new_line_content": "  quiesced_.store(true, std::memory_order_relaxed);",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": null,
          "new_api": "l throttled) {\n  return throttled_.exch",
          "old_text": null,
          "new_text": "l throttled) {\n  return throttled_.exch",
          "old_line_content": "",
          "new_line_content": "  lifeguard_.BlockUntilShutdownAndReset();",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": null,
          "new_api": "Shutdown",
          "old_text": null,
          "new_text": "Shutdown(\n    bool is_shutdown) {\n  auto was_shutdown = s",
          "old_line_content": "",
          "new_line_content": "  return throttled_.exchange(throttled, std::memory_order_relaxed);",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": null,
          "new_api": "lImpl::SetForking(\n    bool is_forking)",
          "old_text": null,
          "new_text": "lImpl::SetForking(\n    bool is_forking)",
          "old_line_content": "}",
          "new_line_content": "  GPR_ASSERT(is_shutdown != was_shutdown);",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": null,
          "new_api": "auto was_forking = fork",
          "old_text": null,
          "new_text": " auto was_forking = fork",
          "old_line_content": "",
          "new_line_content": "  work_signal_.SignalAll();",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": null,
          "new_api": "PoolImpl::IsForking() {\n  ret",
          "old_text": null,
          "new_text": "PoolImpl::IsForking() {\n  ret",
          "old_line_content": "}",
          "new_line_content": "  auto was_forking = forking_.exchange(is_forking);",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "forking_.load(std::memory_order_relax",
          "old_line_content": "",
          "new_line_content": "  GPR_ASSERT(is_forking != was_forking);",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "urn shutdown_.load(std::memory_order_rel",
          "old_line_content": "",
          "new_line_content": "  return forking_.load(std::memory_order_relaxed);",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "turn quiesced_.load(std::memory_order_rel",
          "old_line_content": "",
          "new_line_content": "  return shutdown_.load(std::memory_order_relaxed);",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": null,
          "new_api": "etForking",
          "old_text": null,
          "new_text": "etForking(true);\n  work_signal_.SignalAll",
          "old_line_content": "",
          "new_line_content": "  return quiesced_.load(std::memory_order_relaxed);",
          "content_same": false
        },
        {
          "line": 255,
          "old_api": null,
          "new_api": "hreadPool::WorkStealingThreadPoolImpl::Postfork() {\n  Se",
          "old_text": null,
          "new_text": "hreadPool::WorkStealingThreadPoolImpl::Postfork() {\n  Se",
          "old_line_content": "}",
          "new_line_content": "  living_thread_count_.BlockUntilThreadCount(0, \"forking\");",
          "content_same": false
        },
        {
          "line": 256,
          "old_api": null,
          "new_api": "king",
          "old_text": null,
          "new_text": "king(false);\n  Start();\n}\n\n// -------- ",
          "old_line_content": "",
          "new_line_content": "  lifeguard_.BlockUntilShutdownAndReset();",
          "content_same": false
        },
        {
          "line": 260,
          "old_api": null,
          "new_api": "lingThreadPool::W",
          "old_text": null,
          "new_text": "lingThreadPool::W",
          "old_line_content": "}",
          "new_line_content": "  SetForking(false);",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": null,
          "new_api": "tealing",
          "old_text": null,
          "new_text": "tealing",
          "old_line_content": "",
          "new_line_content": "  Start();",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": null,
          "new_api": "set_max_backoff",
          "old_text": null,
          "new_text": ".set_max_backoff(kLifeguardMaxSleepBetweenChecks)\n                   .set_multiplier(1.3)),\n      lifeguard_should_shut_down_(std::make_unique<grpc_core::Notification>()),\n      lifeguard_is_shut_down_(std::make",
          "old_line_content": "                   .set_max_backoff(kLifeguardMaxSleepBetweenChecks)",
          "new_line_content": "      backoff_(grpc_core::BackOff::Options()",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": null,
          "new_api": "}\n\nvoid WorkStealingThreadPool::WorkStealin",
          "old_text": null,
          "new_text": "}\n\nvoid WorkStealingThreadPool::WorkStealin",
          "old_line_content": "",
          "new_line_content": "      lifeguard_should_shut_down_(std::make_unique<grpc_core::Notification>()),",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": null,
          "new_api": "() {\n  // lifeguard_running_ is set early t",
          "old_text": null,
          "new_text": "() {\n  // lifeguard_running_ is set early t",
          "old_line_content": "void WorkStealingThreadPool::WorkStealingThreadPoolImpl::Lifeguard::Start() {",
          "new_line_content": "      lifeguard_is_shut_down_(std::make_unique<grpc_core::Notification>()) {}",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "atic_cast<Lifeguard*>(arg);",
          "old_text": null,
          "new_text": "atic_cast<Lifeguard*>(arg);\n  ",
          "old_line_content": "      \"lifeguard\",",
          "new_line_content": "  lifeguard_running_.store(true);",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": null,
          "new_api": "set_tracked",
          "old_text": null,
          "new_text": "  lifeguard->LifeguardMain();\n      },\n      this, nullptr,\n      grpc_core::Thread::Options().set_tracked(false).set_joinable(false))\n      .Start();\n}\n\nvoid WorkStealingThreadPool::WorkStealingThreadPoolImpl::Lifeguard::\n    LifeguardMain() {\n  while (true) {\n    if (p",
          "old_line_content": "      [](void* arg) {",
          "new_line_content": "  grpc_core::Thread(",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": null,
          "new_api": "set_tracked",
          "old_text": null,
          "new_text": "ptions().set_tracked(false).",
          "old_line_content": "      },",
          "new_line_content": "        auto* lifeguard = static_cast<Lifeguard*>(arg);",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "le(false))\n      .Start();",
          "old_line_content": "      this, nullptr,",
          "new_line_content": "        lifeguard->LifeguardMain();",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": null,
          "new_api": "tealingThreadPoolImpl::Lifeguard::\n    LifeguardMain() {\n  while (t",
          "old_text": null,
          "new_text": "tealingThreadPoolImpl::Lifeguard::\n    LifeguardMain() {\n  while (t",
          "old_line_content": "}",
          "new_line_content": "      grpc_core::Thread::Options().set_tracked(false).set_joinable(false))",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": null,
          "new_api": "k rate if the pool",
          "old_text": null,
          "new_text": "k rate if the pool",
          "old_line_content": "    // reduce the check rate if the pool is idle.",
          "new_line_content": "    if (pool_->IsForking()) break;",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": null,
          "new_api": "cationWithTimeout",
          "old_text": null,
          "new_text": "cationWithTimeout(\n",
          "old_line_content": "    } else {",
          "new_line_content": "    if (pool_->IsShutdown()) {",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": null,
          "new_api": "store",
          "old_text": null,
          "new_text": ";\n    }\n    MaybeStartNewThread();\n  }\n  lifeguard_running_.store(false, std::memory_order_relaxed);\n  lifeguard_is_shut_",
          "old_line_content": "                  .millis()));",
          "new_line_content": "          absl::Milliseconds(",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": null,
          "new_api": "e",
          "old_text": null,
          "new_text": "e(false, std::memory_order_",
          "old_line_content": "    }",
          "new_line_content": "              (backoff_.NextAttemptTime() - grpc_core::Timestamp::Now())",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": null,
          "new_api": "dPool::WorkStealingThreadPoolImpl::Lifeguard::\n    BlockUn",
          "old_text": null,
          "new_text": "dPool::WorkStealingThreadPoolImpl::Lifeguard::\n    BlockUn",
          "old_line_content": "}",
          "new_line_content": "  lifeguard_running_.store(false, std::memory_order_relaxed);",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": null,
          "new_api": "hutdownAndReset",
          "old_text": null,
          "new_text": "hutdownAndReset() {\n  lifeguard_s",
          "old_line_content": "",
          "new_line_content": "  lifeguard_is_shut_down_->Notify();",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": null,
          "new_api": "_DEBUG,\n                                 \"%s\",",
          "old_text": null,
          "new_text": "_DEBUG,\n                                 \"%s\",\n   ",
          "old_line_content": "                                 \"%s\",",
          "new_line_content": "  while (lifeguard_running_.load(std::memory_order_relaxed)) {",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": null,
          "new_api": "WaitForNotification",
          "old_text": null,
          "new_text": "                      \"Waiting for lifeguard thread to shut down\");\n    lifeguard_is_shut_down_->WaitForNotification();\n  }\n  // Do an additional wait in case this method races with Lifegu",
          "old_line_content": "                                 \"Waiting for lifeguard thread to shut down\");",
          "new_line_content": "    GRPC_LOG_EVERY_N_SEC_DELAYED(kBlockingQuiesceLogRateSeconds, GPR_DEBUG,",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": null,
          "new_api": "n's\n  // shutdown. This should return immediat",
          "old_text": null,
          "new_text": "n's\n  // shutdown. This should return immediat",
          "old_line_content": "  // Do an additional wait in case this method races with LifeguardMain's",
          "new_line_content": "    lifeguard_is_shut_down_->WaitForNotification();",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": null,
          "new_api": "oid WorkStealingThreadPool::WorkStealingThr",
          "old_text": null,
          "new_text": "oid WorkStealingThreadPool::WorkStealingThr",
          "old_line_content": "}",
          "new_line_content": "  lifeguard_should_shut_down_ = std::make_unique<grpc_core::Notification>();",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": null,
          "new_api": "aybeStartNewThread",
          "old_text": null,
          "new_text": "aybeStartNewThread() {\n  // No new threads ",
          "old_line_content": "",
          "new_line_content": "  lifeguard_is_shut_down_ = std::make_unique<grpc_core::Notification>();",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": null,
          "new_api": "e worker thread if the",
          "old_text": null,
          "new_text": "e worker thread if the",
          "old_line_content": "  // Wake an idle worker thread if there's global work to be had.",
          "new_line_content": "  if (pool_->forking_.load()) return;",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": null,
          "new_api": "t work stealing.\n    return;",
          "old_text": null,
          "new_text": "t work stealing.\n    return;\n ",
          "old_line_content": "    }",
          "new_line_content": "      pool_->work_signal()->Signal();",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": null,
          "new_api": "No new threads i",
          "old_text": null,
          "new_text": "No new threads i",
          "old_line_content": "    // Idle threads will eventually wake up for an attempt at work stealing.",
          "new_line_content": "      backoff_.Reset();",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": null,
          "new_api": "_started_thread_) <\n      k",
          "old_text": null,
          "new_text": "_started_thread_) <\n      k",
          "old_line_content": "              pool_->last_started_thread_) <",
          "new_line_content": "  if (grpc_core::Timestamp::Now() -",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": null,
          "new_api": "Reset",
          "old_text": null,
          "new_text": "rottledThreadStarts) {\n    backoff_.Reset();\n    return;\n  }\n  // All workers are busy and the pool",
          "old_line_content": "      kTimeBetweenThrottledThreadStarts) {",
          "new_line_content": "          grpc_core::Timestamp::FromMillisecondsAfterProcessEpoch(",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": null,
          "new_api": "ork): new thread",
          "old_text": null,
          "new_text": "ork): new thread",
          "old_line_content": "  }",
          "new_line_content": "    backoff_.Reset();",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": null,
          "new_api": "Reset",
          "old_text": null,
          "new_text": "living_thread_count + 1);\n  pool_->StartThread();\n  // Tell the lifeguard to monitor the pool more closely.\n  backoff_.Reset();\n}\n\n// -------- Wor",
          "old_line_content": "      \")\",",
          "new_line_content": "  GRPC_EVENT_ENGINE_TRACE(",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": null,
          "new_api": "State",
          "old_text": null,
          "new_text": "State(\n    std::",
          "old_line_content": "",
          "new_line_content": "  backoff_.Reset();",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": null,
          "new_api": "et_initial_backoff",
          "old_text": null,
          "new_text": "et_initial_backoff(kWorkerThreadMinSleepBetweenChecks",
          "old_line_content": "                   .set_initial_backoff(kWorkerThreadMinSleepBetweenChecks)",
          "new_line_content": "          pool_->living_thread_count()->MakeAutoThreadCounter()),",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": null,
          "new_api": "set_max_backoff",
          "old_text": null,
          "new_text": "   .set_max_backoff(kWorkerThreadMaxSleepBetweenChecks)\n                   .set_multiplier(1.3)),\n      busy_count_idx_(pool_->busy_thread_count()->NextIndex()) {}\n\nvoid WorkStealingThreadPool::ThreadState::ThreadBody",
          "old_line_content": "                   .set_max_backoff(kWorkerThreadMaxSleepBetweenChecks)",
          "new_line_content": "      backoff_(grpc_core::BackOff::Options()",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": null,
          "new_api": "w BasicWorkQueue();\n  pool_->theft_regi",
          "old_text": null,
          "new_text": "w BasicWorkQueue();\n  pool_->theft_regi",
          "old_line_content": "void WorkStealingThreadPool::ThreadState::ThreadBody() {",
          "new_line_content": "      busy_count_idx_(pool_->busy_thread_count()->NextIndex()) {}",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": null,
          "new_api": "IsForking",
          "old_text": null,
          "new_text": "leanup\n  if (pool_->IsForking()) {\n    //",
          "old_line_content": "    // loop until the thread should no longer run",
          "new_line_content": "  ThreadLocal::SetIsEventEngineThread(true);",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": null,
          "new_api": ": cons",
          "old_text": null,
          "new_text": ": cons",
          "old_line_content": "  }",
          "new_line_content": "  while (Step()) {",
          "content_same": false
        },
        {
          "line": 388,
          "old_api": null,
          "new_api": "le (!g_local_queue",
          "old_text": null,
          "new_text": "le (!g_local_queue",
          "old_line_content": "    EventEngine::Closure* closure;",
          "new_line_content": "  if (pool_->IsForking()) {",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "ueue()->Add(closure);\n",
          "old_line_content": "      if (closure != nullptr) {",
          "new_line_content": "    while (!g_local_queue->Empty()) {",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": null,
          "new_api": "Empty",
          "old_text": null,
          "new_text": "ocal_queue->Empty());\n  pool",
          "old_line_content": "    }",
          "new_line_content": "        pool_->queue()->Add(closure);",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": null,
          "new_api": "(g_local_queue);",
          "old_text": null,
          "new_text": "(g_local_queue);\n  ",
          "old_line_content": "  }",
          "new_line_content": "  } else if (pool_->IsShutdown()) {",
          "content_same": false
        },
        {
          "line": 400,
          "old_api": null,
          "new_api": "hreadPool::ThreadState",
          "old_text": null,
          "new_text": "hreadPool::ThreadState",
          "old_line_content": "  delete g_local_queue;",
          "new_line_content": "  GPR_ASSERT(g_local_queue->Empty());",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": null,
          "new_api": "IsForking",
          "old_text": null,
          "new_text": "epIfRunning() {\n  if (pool_->IsForking()) return",
          "old_line_content": "}",
          "new_line_content": "  pool_->theft_registry()->Unenroll(g_local_queue);",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": null,
          "new_api": "IsForking",
          "old_text": null,
          "new_text": "eadState::Step() {\n  if (pool_->IsForking()) return false;\n  auto* closure = g_local_",
          "old_line_content": "}",
          "new_line_content": "  absl::SleepFor(",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": null,
          "new_api": "()) return false;\n  auto* closure = g_loca",
          "old_text": null,
          "new_text": "()) return false;\n  auto* closure = g_loca",
          "old_line_content": "",
          "new_line_content": "      absl::Milliseconds(kTimeBetweenThrottledThreadStarts.millis()));",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": null,
          "new_api": "t.\n  if (closure !",
          "old_text": null,
          "new_text": "t.\n  if (closure !",
          "old_line_content": "  // If local work is available, run it.",
          "new_line_content": "  if (pool_->IsForking()) return false;",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": null,
          "new_api": "busy_thread_count",
          "old_text": null,
          "new_text": "   pool_->busy_thread_count()-",
          "old_line_content": "  if (closure != nullptr) {",
          "new_line_content": "  auto* closure = g_local_queue->PopMostRecent();",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": null,
          "new_api": "hutdown exit condition (ignoring fork). All must be true:\n  // * s",
          "old_text": null,
          "new_text": "hutdown exit condition (ignoring fork). All must be true:\n  // * s",
          "old_line_content": "    return true;",
          "new_line_content": "        pool_->busy_thread_count()->MakeAutoThreadCounter(busy_count_idx_);",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": null,
          "new_api": "n was called",
          "old_text": null,
          "new_text": "n was called\n ",
          "old_line_content": "  }",
          "new_line_content": "    closure->Run();",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": null,
          "new_api": "ns. Depends on the",
          "old_text": null,
          "new_text": "ns. Depends on the",
          "old_line_content": "    // TODO(hork): consider an empty check for performance wins. Depends on the",
          "new_line_content": "  while (!pool_->IsForking()) {",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": null,
          "new_api": "ry stealing if the queue is emp",
          "old_text": null,
          "new_text": "ry stealing if the queue is emp",
          "old_line_content": "      should_run_again = true;",
          "new_line_content": "    closure = pool_->queue()->PopMostRecent();",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": null,
          "new_api": "/ No closures were retrieved from a",
          "old_text": null,
          "new_text": "/ No closures were retrieved from a",
          "old_line_content": "      should_run_again = true;",
          "new_line_content": "    closure = pool_->theft_registry()->StealOne();",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": null,
          "new_api": "as more than it requires, a",
          "old_text": null,
          "new_text": "as more than it requires, a",
          "old_line_content": "    // Quit a thread if the pool has more than it requires, and this thread",
          "new_line_content": "        backoff_.NextAttemptTime() - grpc_core::Timestamp::Now());",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": null,
          "new_api": "le long enough.",
          "old_text": null,
          "new_text": "le long enough.\n   ",
          "old_line_content": "    // has been idle long enough.",
          "new_line_content": "    if (pool_->IsForking() || pool_->IsShutdown()) break;",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": null,
          "new_api": "}\n  }\n  if (pool_->IsFo",
          "old_text": null,
          "new_text": " }\n  }\n  if (pool_->IsFo",
          "old_line_content": "      return false;",
          "new_line_content": "        pool_->living_thread_count()->count() > pool_->reserve_threads() &&",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": null,
          "new_api": "// save the closure sinc",
          "old_text": null,
          "new_text": "   // save the closure sinc",
          "old_line_content": "    }",
          "new_line_content": "        grpc_core::Timestamp::Now() - start_time > kIdleThreadLimit) {",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "count()->MakeAutoThreadCoun",
          "old_line_content": "  }",
          "new_line_content": "    if (closure != nullptr) g_local_queue->Add(closure);",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": null,
          "new_api": "hould_run_again;\n}\n\nvoid WorkStealingThreadPool::ThreadState::Fini",
          "old_text": null,
          "new_text": "hould_run_again;\n}\n\nvoid WorkStealingThreadPool::ThreadState::Fini",
          "old_line_content": "  }",
          "new_line_content": "        pool_->busy_thread_count()->MakeAutoThreadCounter(busy_count_idx_);",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": null,
          "new_api": "ad is definition",
          "old_text": null,
          "new_text": "ad is definition",
          "old_line_content": "}",
          "new_line_content": "  backoff_.Reset();",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": null,
          "new_api": "it draining. The post-fork\n  // threads will finish draining the g",
          "old_text": null,
          "new_text": "it draining. The post-fork\n  // threads will finish draining the g",
          "old_line_content": "  // threads will finish draining the global queue.",
          "new_line_content": "      pool_->busy_thread_count()->MakeAutoThreadCounter(busy_count_idx_);",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": null,
          "new_api": "Run",
          "old_text": null,
          "new_text": "osure->Run();\n      }\n",
          "old_line_content": "      if (closure != nullptr) {",
          "new_line_content": "    if (!g_local_queue->Empty()) {",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": null,
          "new_api": "pMostRecent",
          "old_text": null,
          "new_text": "pMostRecent();",
          "old_line_content": "      continue;",
          "new_line_content": "        closure->Run();",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": null,
          "new_api": "Run",
          "old_text": null,
          "new_text": "closure->Run();\n      }",
          "old_line_content": "      if (closure != nullptr) {",
          "new_line_content": "    if (!pool_->queue()->Empty()) {",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": null,
          "new_api": "oid WorkSteali",
          "old_text": null,
          "new_text": "oid WorkSteali",
          "old_line_content": "      continue;",
          "new_line_content": "        closure->Run();",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": null,
          "new_api": "();\n}\n\nbool",
          "old_text": null,
          "new_text": "();\n}\n\nbool ",
          "old_line_content": "",
          "new_line_content": "  cv_.Signal();",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": null,
          "new_api": ":MutexLock lock",
          "old_text": null,
          "new_text": ":MutexLock lock",
          "old_line_content": "",
          "new_line_content": "  cv_.SignalAll();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 185,
          "old_api": "last_started_thre",
          "new_api": null,
          "old_text": "  last_started_thre",
          "new_text": null,
          "old_line_content": "  queue_.Add(closure);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": "store",
          "new_api": null,
          "old_text": "store(\n      grpc_cor",
          "new_text": null,
          "old_line_content": "  work_signal_.Signal();",
          "new_line_content": "  // Signal a worker in any case, even if work was added to a local queue. This",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": "relaxed);\n  grpc_core::Thread(\n      \"event_engine\",\n      [](void* arg) {\n        ThreadState* worker = static_cast<ThreadState*>",
          "new_api": null,
          "old_text": "relaxed);\n  grpc_core::Thread(\n      \"event_engine\",\n      [](void* arg) {\n        ThreadState* worker = static_cast<ThreadState*>",
          "new_text": null,
          "old_line_content": "  last_started_thread_.store(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 191,
          "old_api": "\"event_engine\",\n      [](void* arg) {\n        ThreadState*",
          "new_api": null,
          "old_text": "   \"event_engine\",\n      [](void* arg) {\n        ThreadState* ",
          "new_text": null,
          "old_line_content": "      grpc_core::Timestamp::Now().milliseconds_after_process_epoch(),",
          "new_line_content": "void WorkStealingThreadPool::WorkStealingThreadPoolImpl::StartThread() {",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": "_from_this",
          "new_api": null,
          "old_text": "_from_this()), nullptr,\n      ",
          "new_text": null,
          "old_line_content": "        ThreadState* worker = static_cast<ThreadState*>(arg);",
          "new_line_content": "      \"event_engine\",",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": ":Thread::Options().s",
          "new_api": null,
          "old_text": ":Thread::Options().s",
          "new_text": null,
          "old_line_content": "        worker->ThreadBody();",
          "new_line_content": "      [](void* arg) {",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": "void WorkStealin",
          "new_api": null,
          "old_text": "\n\nvoid WorkStealin",
          "new_text": null,
          "old_line_content": "      new ThreadState(shared_from_this()), nullptr,",
          "new_line_content": "        delete worker;",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": "tealingThreadPoolImpl::Quiesce() {\n  SetShutdown(true);\n  // Wait u",
          "new_api": null,
          "old_text": "tealingThreadPoolImpl::Quiesce() {\n  SetShutdown(true);\n  // Wait u",
          "new_text": null,
          "old_line_content": "      grpc_core::Thread::Options().set_tracked(false).set_joinable(false))",
          "new_line_content": "      },",
          "content_same": false
        },
        {
          "line": 206,
          "old_api": "it this thread",
          "new_api": null,
          "old_text": "it this thread\n  ",
          "new_text": null,
          "old_line_content": "  SetShutdown(true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 212,
          "old_api": "",
          "new_api": null,
          "old_text": "                          ",
          "new_text": null,
          "old_line_content": "  work_signal()->SignalAll();",
          "new_line_content": "  // running instead of zero.",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": "Empty",
          "new_api": null,
          "old_text": "tting down\");\n  GPR_ASSERT(queue_.Empty());\n  quiesced_.store(true, std::memory_order_relaxed);\n  lifeguard_.BlockUntilShutdownAndRese",
          "new_text": null,
          "old_line_content": "  living_thread_count_.BlockUntilThreadCount(is_threadpool_thread ? 1 : 0,",
          "new_line_content": "  bool is_threadpool_thread = g_local_queue != nullptr;",
          "content_same": false
        },
        {
          "line": 216,
          "old_api": "l::WorkStealingThreadPoolImpl::SetThrottled(",
          "new_api": null,
          "old_text": "l::WorkStealingThreadPoolImpl::SetThrottled(\n   ",
          "new_text": null,
          "old_line_content": "  quiesced_.store(true, std::memory_order_relaxed);",
          "new_line_content": "                                             \"shutting down\");",
          "content_same": false
        },
        {
          "line": 222,
          "old_api": "Shutdown",
          "new_api": null,
          "old_text": "Shutdown(\n    bool is_shutdown) {\n  auto was_shutdown = s",
          "new_text": null,
          "old_line_content": "  return throttled_.exchange(throttled, std::memory_order_relaxed);",
          "new_line_content": "bool WorkStealingThreadPool::WorkStealingThreadPoolImpl::SetThrottled(",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": "ngThreadPool::WorkStealingThrea",
          "new_api": null,
          "old_text": "ngThreadPool::WorkStealingThrea",
          "new_text": null,
          "old_line_content": "  auto was_shutdown = shutdown_.exchange(is_shutdown);",
          "new_line_content": "void WorkStealingThreadPool::WorkStealingThreadPoolImpl::SetShutdown(",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": "lImpl::SetForking(\n    bool is_forking)",
          "new_api": null,
          "old_text": "lImpl::SetForking(\n    bool is_forking)",
          "new_text": null,
          "old_line_content": "  GPR_ASSERT(is_shutdown != was_shutdown);",
          "new_line_content": "    bool is_shutdown) {",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": "PoolImpl::IsForking() {\n  ret",
          "new_api": null,
          "old_text": "PoolImpl::IsForking() {\n  ret",
          "new_text": null,
          "old_line_content": "  auto was_forking = forking_.exchange(is_forking);",
          "new_line_content": "void WorkStealingThreadPool::WorkStealingThreadPoolImpl::SetForking(",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": "load",
          "new_api": null,
          "old_text": "forking_.load(std::memory_order_relax",
          "new_text": null,
          "old_line_content": "  GPR_ASSERT(is_forking != was_forking);",
          "new_line_content": "    bool is_forking) {",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": "load",
          "new_api": null,
          "old_text": "urn shutdown_.load(std::memory_order_rel",
          "new_text": null,
          "old_line_content": "  return forking_.load(std::memory_order_relaxed);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": "load",
          "new_api": null,
          "old_text": "turn quiesced_.load(std::memory_order_rel",
          "new_text": null,
          "old_line_content": "  return shutdown_.load(std::memory_order_relaxed);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": "etForking",
          "new_api": null,
          "old_text": "etForking(true);\n  work_signal_.SignalAll",
          "new_text": null,
          "old_line_content": "  return quiesced_.load(std::memory_order_relaxed);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": "ckUntilShutdownA",
          "new_api": null,
          "old_text": "ckUntilShutdownA",
          "new_text": null,
          "old_line_content": "  SetForking(true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": "set",
          "new_api": null,
          "old_text": "set();\n}\n\nvoid WorkSteal",
          "new_text": null,
          "old_line_content": "  work_signal_.SignalAll();",
          "new_line_content": "void WorkStealingThreadPool::WorkStealingThreadPoolImpl::PrepareFork() {",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": "lingThreadPool::W",
          "new_api": null,
          "old_text": "lingThreadPool::W",
          "new_text": null,
          "old_line_content": "  SetForking(false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": "tealing",
          "new_api": null,
          "old_text": "tealing",
          "new_text": null,
          "old_line_content": "  Start();",
          "new_line_content": "void WorkStealingThreadPool::WorkStealingThreadPoolImpl::Postfork() {",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "set_max_backoff",
          "new_api": null,
          "old_text": ".set_max_backoff(kLifeguardMaxSleepBetweenChecks)\n                   .set_multiplier(1.3)),\n      lifeguard_should_shut_down_(std::make_unique<grpc_core::Notification>()),\n      lifeguard_is_shut_down_(std::make",
          "new_text": null,
          "old_line_content": "      backoff_(grpc_core::BackOff::Options()",
          "new_line_content": "    WorkStealingThreadPoolImpl* pool)",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "}\n\nvoid WorkStealingThreadPool::WorkStealin",
          "new_api": null,
          "old_text": "}\n\nvoid WorkStealingThreadPool::WorkStealin",
          "new_text": null,
          "old_line_content": "      lifeguard_should_shut_down_(std::make_unique<grpc_core::Notification>()),",
          "new_line_content": "                   .set_max_backoff(kLifeguardMaxSleepBetweenChecks)",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "() {\n  // lifeguard_running_ is set early t",
          "new_api": null,
          "old_text": "() {\n  // lifeguard_running_ is set early t",
          "new_text": null,
          "old_line_content": "      lifeguard_is_shut_down_(std::make_unique<grpc_core::Notification>()) {}",
          "new_line_content": "                   .set_multiplier(1.3)),",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": "atic_cast<Lifeguard*>(arg);",
          "new_api": null,
          "old_text": "atic_cast<Lifeguard*>(arg);\n  ",
          "new_text": null,
          "old_line_content": "  lifeguard_running_.store(true);",
          "new_line_content": "  // lifeguard_running_ is set early to avoid a quiesce race while the",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": "set_tracked",
          "new_api": null,
          "old_text": "  lifeguard->LifeguardMain();\n      },\n      this, nullptr,\n      grpc_core::Thread::Options().set_tracked(false).set_joinable(false))\n      .Start();\n}\n\nvoid WorkStealingThreadPool::WorkStealingThreadPoolImpl::Lifeguard::\n    LifeguardMain() {\n  while (true) {\n    if (p",
          "new_text": null,
          "old_line_content": "  grpc_core::Thread(",
          "new_line_content": "  // lifeguard is still starting up.",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": "set_tracked",
          "new_api": null,
          "old_text": "ptions().set_tracked(false).",
          "new_text": null,
          "old_line_content": "        auto* lifeguard = static_cast<Lifeguard*>(arg);",
          "new_line_content": "      \"lifeguard\",",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": "Start",
          "new_api": null,
          "old_text": "le(false))\n      .Start();",
          "new_text": null,
          "old_line_content": "        lifeguard->LifeguardMain();",
          "new_line_content": "      [](void* arg) {",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": "tealingThreadPoolImpl::Lifeguard::\n    LifeguardMain() {\n  while (t",
          "new_api": null,
          "old_text": "tealingThreadPoolImpl::Lifeguard::\n    LifeguardMain() {\n  while (t",
          "new_text": null,
          "old_line_content": "      grpc_core::Thread::Options().set_tracked(false).set_joinable(false))",
          "new_line_content": "      },",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": "k rate if the pool",
          "new_api": null,
          "old_text": "k rate if the pool",
          "new_text": null,
          "old_line_content": "    if (pool_->IsForking()) break;",
          "new_line_content": "    LifeguardMain() {",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": "cationWithTimeout",
          "new_api": null,
          "old_text": "cationWithTimeout(\n",
          "new_text": null,
          "old_line_content": "    if (pool_->IsShutdown()) {",
          "new_line_content": "    // If the pool is shut down, loop quickly until quiesced. Otherwise,",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": "::Milliseconds(",
          "new_api": null,
          "old_text": "::Milliseconds(\n   ",
          "new_text": null,
          "old_line_content": "      if (pool_->IsQuiesced()) break;",
          "new_line_content": "    // reduce the check rate if the pool is idle.",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": "store",
          "new_api": null,
          "old_text": ";\n    }\n    MaybeStartNewThread();\n  }\n  lifeguard_running_.store(false, std::memory_order_relaxed);\n  lifeguard_is_shut_",
          "new_text": null,
          "old_line_content": "          absl::Milliseconds(",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": "();\n}\n\nvoid WorkSteal",
          "new_api": null,
          "old_text": "();\n}\n\nvoid WorkSteal",
          "new_text": null,
          "old_line_content": "    MaybeStartNewThread();",
          "new_line_content": "                  .millis()));",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": "hutdownAndReset",
          "new_api": null,
          "old_text": "hutdownAndReset() {\n  lifeguard_s",
          "new_text": null,
          "old_line_content": "  lifeguard_is_shut_down_->Notify();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": "_SEC_DELAYED",
          "new_api": null,
          "old_text": "_SEC_DELAYED(kBlockingQuiesceLogRateS",
          "new_text": null,
          "old_line_content": "  lifeguard_should_shut_down_->Notify();",
          "new_line_content": "void WorkStealingThreadPool::WorkStealingThreadPoolImpl::Lifeguard::",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "_DEBUG,\n                                 \"%s\",",
          "new_api": null,
          "old_text": "_DEBUG,\n                                 \"%s\",\n   ",
          "new_text": null,
          "old_line_content": "  while (lifeguard_running_.load(std::memory_order_relaxed)) {",
          "new_line_content": "    BlockUntilShutdownAndReset() {",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": "n's\n  // shutdown. This should return immediat",
          "new_api": null,
          "old_text": "n's\n  // shutdown. This should return immediat",
          "new_text": null,
          "old_line_content": "    lifeguard_is_shut_down_->WaitForNotification();",
          "new_line_content": "                                 \"%s\",",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": "core::Notification>();\n  lifeguard_is_shut_dow",
          "new_api": null,
          "old_text": "core::Notification>();\n  lifeguard_is_shut_dow",
          "new_text": null,
          "old_line_content": "  lifeguard_is_shut_down_->WaitForNotification();",
          "new_line_content": "  // shutdown. This should return immediately if the lifeguard is already shut",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "std::make_uniqu",
          "new_api": null,
          "old_text": " std::make_uniqu",
          "new_text": null,
          "old_line_content": "  backoff_.Reset();",
          "new_line_content": "  // down.",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": "e worker thread if the",
          "new_api": null,
          "old_text": "e worker thread if the",
          "new_text": null,
          "old_line_content": "  if (pool_->forking_.load()) return;",
          "new_line_content": "  // No new threads are started when forking.",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": "count",
          "new_api": null,
          "old_text": "_thread_count()->count() < living_thr",
          "new_text": null,
          "old_line_content": "  const auto living_thread_count = pool_->living_thread_count()->count();",
          "new_line_content": "  // No new work is done when forking needs to begin.",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": "tually wake up for an",
          "new_api": null,
          "old_text": "tually wake up for an",
          "new_text": null,
          "old_line_content": "    if (!pool_->queue_.Empty()) {",
          "new_line_content": "  // Wake an idle worker thread if there's global work to be had.",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": "_started_thread_) <\n      k",
          "new_api": null,
          "old_text": "_started_thread_) <\n      k",
          "new_text": null,
          "old_line_content": "  if (grpc_core::Timestamp::Now() -",
          "new_line_content": "  // However, all workers are busy, so the Lifeguard should be more",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": "Reset",
          "new_api": null,
          "old_text": "rottledThreadStarts) {\n    backoff_.Reset();\n    return;\n  }\n  // All workers are busy and the pool",
          "new_text": null,
          "old_line_content": "          grpc_core::Timestamp::FromMillisecondsAfterProcessEpoch(",
          "new_line_content": "  // vigilant about checking whether a new thread must be started.",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": "ork): new thread",
          "new_api": null,
          "old_text": "ork): new thread",
          "new_text": null,
          "old_line_content": "    backoff_.Reset();",
          "new_line_content": "              pool_->last_started_thread_) <",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": "Reset",
          "new_api": null,
          "old_text": "living_thread_count + 1);\n  pool_->StartThread();\n  // Tell the lifeguard to monitor the pool more closely.\n  backoff_.Reset();\n}\n\n// -------- Wor",
          "new_text": null,
          "old_line_content": "  GRPC_EVENT_ENGINE_TRACE(",
          "new_line_content": "  // queue, nor any work to steal. Add more sophisticated logic about when to",
          "content_same": false
        },
        {
          "line": 360,
          "old_api": "alingThreadPool::Thr",
          "new_api": null,
          "old_text": "alingThreadPool::Thr",
          "new_text": null,
          "old_line_content": "  pool_->StartThread();",
          "new_line_content": "      \")\",",
          "content_same": false
        },
        {
          "line": 369,
          "old_api": "off_",
          "new_api": null,
          "old_text": "off_(grpc_core:",
          "new_text": null,
          "old_line_content": "    : pool_(std::move(pool)),",
          "new_line_content": "WorkStealingThreadPool::ThreadState::ThreadState(",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "set_max_backoff",
          "new_api": null,
          "old_text": "   .set_max_backoff(kWorkerThreadMaxSleepBetweenChecks)\n                   .set_multiplier(1.3)),\n      busy_count_idx_(pool_->busy_thread_count()->NextIndex()) {}\n\nvoid WorkStealingThreadPool::ThreadState::ThreadBody",
          "new_text": null,
          "old_line_content": "      backoff_(grpc_core::BackOff::Options()",
          "new_line_content": "      auto_thread_counter_(",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": "w BasicWorkQueue();\n  pool_->theft_regi",
          "new_api": null,
          "old_text": "w BasicWorkQueue();\n  pool_->theft_regi",
          "new_text": null,
          "old_line_content": "      busy_count_idx_(pool_->busy_thread_count()->NextIndex()) {}",
          "new_line_content": "                   .set_max_backoff(kWorkerThreadMaxSleepBetweenChecks)",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "p until the thread should no longer run\n  }",
          "new_api": null,
          "old_text": "p until the thread should no longer run\n  }\n  ",
          "new_text": null,
          "old_line_content": "  pool_->theft_registry()->Enroll(g_local_queue);",
          "new_line_content": "void WorkStealingThreadPool::ThreadState::ThreadBody() {",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": "IsForking",
          "new_api": null,
          "old_text": "leanup\n  if (pool_->IsForking()) {\n    //",
          "new_text": null,
          "old_line_content": "  ThreadLocal::SetIsEventEngineThread(true);",
          "new_line_content": "  g_local_queue = new BasicWorkQueue();",
          "content_same": false
        },
        {
          "line": 386,
          "old_api": "le (!g_local_queue",
          "new_api": null,
          "old_text": "le (!g_local_queue",
          "new_text": null,
          "old_line_content": "  if (pool_->IsForking()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": "Add",
          "new_api": null,
          "old_text": "ueue()->Add(closure);\n",
          "new_text": null,
          "old_line_content": "    while (!g_local_queue->Empty()) {",
          "new_line_content": "    // TODO(hork): consider WorkQueue::AddAll(WorkQueue*)",
          "content_same": false
        },
        {
          "line": 390,
          "old_api": "IsShutdown",
          "new_api": null,
          "old_text": "se if (pool_->IsShutdown()) {\n",
          "new_text": null,
          "old_line_content": "      closure = g_local_queue->PopMostRecent();",
          "new_line_content": "    EventEngine::Closure* closure;",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": "(g_local_queue);",
          "new_api": null,
          "old_text": "(g_local_queue);\n  ",
          "new_text": null,
          "old_line_content": "  } else if (pool_->IsShutdown()) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": "_local_queue;\n}",
          "new_api": null,
          "old_text": "_local_queue;\n}\n",
          "new_text": null,
          "old_line_content": "    FinishDraining();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 399,
          "old_api": "IsForking",
          "new_api": null,
          "old_text": "epIfRunning() {\n  if (pool_->IsForking()) return",
          "new_text": null,
          "old_line_content": "  pool_->theft_registry()->Unenroll(g_local_queue);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": "ol WorkStealingThr",
          "new_api": null,
          "old_text": "ol WorkStealingThr",
          "new_text": null,
          "old_line_content": "  if (pool_->IsForking()) return;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": "IsForking",
          "new_api": null,
          "old_text": "eadState::Step() {\n  if (pool_->IsForking()) return false;\n  auto* closure = g_local_",
          "new_text": null,
          "old_line_content": "  absl::SleepFor(",
          "new_line_content": "void WorkStealingThreadPool::ThreadState::SleepIfRunning() {",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "t.\n  if (closure !",
          "new_api": null,
          "old_text": "t.\n  if (closure !",
          "new_text": null,
          "old_line_content": "  if (pool_->IsForking()) return false;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": "busy_thread_count",
          "new_api": null,
          "old_text": "   pool_->busy_thread_count()-",
          "new_text": null,
          "old_line_content": "  auto* closure = g_local_queue->PopMostRecent();",
          "new_line_content": "bool WorkStealingThreadPool::ThreadState::Step() {",
          "content_same": false
        },
        {
          "line": 415,
          "old_api": "hutdown exit condition (ignoring fork). All must be true:\n  // * s",
          "new_api": null,
          "old_text": "hutdown exit condition (ignoring fork). All must be true:\n  // * s",
          "new_text": null,
          "old_line_content": "        pool_->busy_thread_count()->MakeAutoThreadCounter(busy_count_idx_);",
          "new_line_content": "  if (closure != nullptr) {",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": "n was called",
          "new_api": null,
          "old_text": "n was called\n ",
          "new_text": null,
          "old_line_content": "    closure->Run();",
          "new_line_content": "    auto busy =",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": "Pull from the global queue",
          "new_api": null,
          "old_text": " Pull from the global queue",
          "new_text": null,
          "old_line_content": "  grpc_core::Timestamp start_time{grpc_core::Timestamp::Now()};",
          "new_line_content": "  // * the steal pool returns nullptr",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": "ry stealing if the queue is emp",
          "new_api": null,
          "old_text": "ry stealing if the queue is emp",
          "new_text": null,
          "old_line_content": "    closure = pool_->queue()->PopMostRecent();",
          "new_line_content": "    // queue implementation, the BasicWorkQueue takes two locks when you do an",
          "content_same": false
        },
        {
          "line": 438,
          "old_api": "/ No closures were retrieved from a",
          "new_api": null,
          "old_text": "/ No closures were retrieved from a",
          "new_text": null,
          "old_line_content": "    closure = pool_->theft_registry()->StealOne();",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": "- grpc_core::Times",
          "new_api": null,
          "old_text": " - grpc_core::Times",
          "new_text": null,
          "old_line_content": "    if (pool_->IsShutdown()) break;",
          "new_line_content": "    // No closures were retrieved from anywhere.",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": "IsShutdown",
          "new_api": null,
          "old_text": "sForking() || pool_->IsShutdown()) break;\n    // Quit a thread if the pool has more than it requires, an",
          "new_text": null,
          "old_line_content": "    bool timed_out = pool_->work_signal()->WaitWithTimeout(",
          "new_line_content": "    // Quit the thread if the pool has been shut down.",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": "}\n  }\n  if (pool_->IsFo",
          "new_api": null,
          "old_text": " }\n  }\n  if (pool_->IsFo",
          "new_text": null,
          "old_line_content": "        pool_->living_thread_count()->count() > pool_->reserve_threads() &&",
          "new_line_content": "    // has been idle long enough.",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": "// save the closure sinc",
          "new_api": null,
          "old_text": "   // save the closure sinc",
          "new_text": null,
          "old_line_content": "        grpc_core::Timestamp::Now() - start_time > kIdleThreadLimit) {",
          "new_line_content": "    if (timed_out &&",
          "content_same": false
        },
        {
          "line": 457,
          "old_api": "Add",
          "new_api": null,
          "old_text": "ue->Add(closure);\n",
          "new_text": null,
          "old_line_content": "  if (pool_->IsForking()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": "hould_run_again;\n}\n\nvoid WorkStealingThreadPool::ThreadState::Fini",
          "new_api": null,
          "old_text": "hould_run_again;\n}\n\nvoid WorkStealingThreadPool::ThreadState::Fini",
          "new_text": null,
          "old_line_content": "        pool_->busy_thread_count()->MakeAutoThreadCounter(busy_count_idx_);",
          "new_line_content": "  if (closure != nullptr) {",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": "ning",
          "new_api": null,
          "old_text": "ning() {\n  // ",
          "new_text": null,
          "old_line_content": "    closure->Run();",
          "new_line_content": "    auto busy =",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": "it draining. The post-fork\n  // threads will finish draining the g",
          "new_api": null,
          "old_text": "it draining. The post-fork\n  // threads will finish draining the g",
          "new_text": null,
          "old_line_content": "      pool_->busy_thread_count()->MakeAutoThreadCounter(busy_count_idx_);",
          "new_line_content": "  // The thread is definitionally busy while draining",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": "losure != nullptr)",
          "new_api": null,
          "old_text": "losure != nullptr)",
          "new_text": null,
          "old_line_content": "  while (!pool_->IsForking()) {",
          "new_line_content": "  // If a fork occurs at any point during shutdown, quit draining. The post-fork",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": "Run",
          "new_api": null,
          "old_text": "osure->Run();\n      }\n",
          "new_text": null,
          "old_line_content": "    if (!g_local_queue->Empty()) {",
          "new_line_content": "  // threads will finish draining the global queue.",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": "Run",
          "new_api": null,
          "old_text": "closure->Run();\n      }",
          "new_text": null,
          "old_line_content": "    if (!pool_->queue()->Empty()) {",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 486,
          "old_api": "break;\n  }\n}\n\n// -------- Work",
          "new_api": null,
          "old_text": " break;\n  }\n}\n\n// -------- Work",
          "new_text": null,
          "old_line_content": "      auto* closure = pool_->queue()->PopMostRecent();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "();\n}\n\nbool",
          "new_api": null,
          "old_text": "();\n}\n\nbool ",
          "new_text": null,
          "old_line_content": "  cv_.Signal();",
          "new_line_content": "void WorkStealingThreadPool::WorkSignal::Signal() {",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": ":MutexLock lock",
          "new_api": null,
          "old_text": ":MutexLock lock",
          "new_text": null,
          "old_line_content": "  cv_.SignalAll();",
          "new_line_content": "void WorkStealingThreadPool::WorkSignal::SignalAll() {",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "  return cv_.WaitWithTimeout(&mu_, absl::Milliseconds(time.millis()));",
          "new_line_content": "    grpc_core::Duration time) {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 30,
      "total_additions": 86,
      "total_deletions": 86,
      "total_api_changes": 202
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 5,
        "api_related_lines": 202,
        "non_api_lines": 2,
        "non_api_line_numbers": [
          187,
          183
        ]
      }
    },
    "api_calls_before": 190,
    "api_calls_after": 190,
    "diff_info": {
      "added_lines": 4,
      "removed_lines": 2,
      "total_diff_lines": 19
    }
  }
}