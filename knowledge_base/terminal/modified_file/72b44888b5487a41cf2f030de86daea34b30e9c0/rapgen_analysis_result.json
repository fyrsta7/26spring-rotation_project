{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/terminal/modified_file/72b44888b5487a41cf2f030de86daea34b30e9c0",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/terminal/modified_file/72b44888b5487a41cf2f030de86daea34b30e9c0/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/terminal/modified_file/72b44888b5487a41cf2f030de86daea34b30e9c0/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/terminal/modified_file/72b44888b5487a41cf2f030de86daea34b30e9c0/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 160,
          "old_api": "{\n        WaitForS",
          "new_api": "{\n        // Betwe",
          "old_text": "\n    {\n        WaitForS",
          "new_text": "\n    {\n        // Betwe",
          "old_line_content": null,
          "new_line_content": "        return pContext->_ThreadProc();",
          "content_same": true
        },
        {
          "line": 213,
          "old_api": "load",
          "new_api": "otifyPaint",
          "old_text": "g.load(std::memory_order_acquire",
          "new_text": "otifyPaint() noexce",
          "old_line_content": "        _pRenderer->WaitUntilCanRender();",
          "new_line_content": "            ResetEvent(_hEvent);",
          "content_same": false
        },
        {
          "line": 216,
          "old_api": "store",
          "new_api": "oad",
          "old_text": "  _fNextFrameRequested.store(tr",
          "new_text": "oad(std::memory_order_acquire))\n ",
          "old_line_content": "        SetEvent(_hPaintCompletedEvent);",
          "new_line_content": "        ResetEvent(_hPaintCompletedEvent);",
          "content_same": false
        },
        {
          "line": 226,
          "old_api": "ablePainting",
          "new_api": "SetEvent(_hPaintEnabledEvent);\n}\n\nvoid R",
          "old_text": "ablePainting() no",
          "new_text": " SetEvent(_hPaintEnabledEvent);\n}\n\nvoid R",
          "old_line_content": "        SetEvent(_hEvent);",
          "new_line_content": "    if (_fWaiting.load(std::memory_order_acquire))",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 192,
          "old_api": null,
          "new_api": "ng` is `true`, but we're not waiting",
          "old_text": null,
          "new_text": "ng` is `true`, but we're not waiting\n ",
          "old_line_content": "            // the event because `_fWaiting` is `true`, but we're not waiting",
          "new_line_content": "                WaitForSingleObject(_hEvent, INFINITE);",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": null,
          "new_api": "lePainting",
          "old_text": null,
          "new_text": "lePainting() noex",
          "old_line_content": "    else",
          "new_line_content": "        SetEvent(_hEvent);",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": null,
          "new_api": "dEvent);\n}\n\nvoid RenderThread::WaitForPaintCompletionAndDis",
          "old_text": null,
          "new_text": "dEvent);\n}\n\nvoid RenderThread::WaitForPaintCompletionAndDis",
          "old_line_content": "}",
          "new_line_content": "        _fNextFrameRequested.store(true, std::memory_order_release);",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": null,
          "new_api": "store",
          "old_text": null,
          "new_text": "_fNextFrameRequested.store(true",
          "old_line_content": "",
          "new_line_content": "        SetEvent(_hPaintCompletedEvent);",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "}",
          "new_line_content": "    ResetEvent(_hPaintEnabledEvent);",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "    WaitForSingleObject(_hPaintCompletedEvent, dwTimeoutMs);",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": null,
          "new_api": "place via DirectX, and a con",
          "old_text": null,
          "new_text": " place via DirectX, and a con",
          "old_line_content": "",
          "new_line_content": "    SetEvent(_hPaintEnabledEvent);",
          "content_same": false
        },
        {
          "line": 175,
          "old_api": null,
          "new_api": "{\n            // <--",
          "old_text": null,
          "new_text": "        {\n            // <--\n   ",
          "old_line_content": "        {",
          "new_line_content": "        _pRenderer->WaitUntilCanRender();",
          "content_same": false
        },
        {
          "line": 177,
          "old_api": null,
          "new_api": "f `NotifyPaint` is called at this point, then it w",
          "old_text": null,
          "new_text": "f `NotifyPaint` is called at this point, then it w",
          "old_line_content": "            // If `NotifyPaint` is called at this point, then it will not",
          "new_line_content": "        WaitForSingleObject(_hPaintEnabledEvent, INFINITE);",
          "content_same": false
        },
        {
          "line": 210,
          "old_api": null,
          "new_api": "ntFrame",
          "old_text": null,
          "new_text": "ntFrame());\n        SetEvent(_hPaintCompletedEven",
          "old_line_content": "",
          "new_line_content": "            _fWaiting.store(false, std::memory_order_release);",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": null,
          "new_api": "// set the event because `_fWaiting` is not `true` yet so we",
          "old_text": null,
          "new_text": "  // set the event because `_fWaiting` is not `true` yet so we ",
          "old_line_content": "            // to check again below.",
          "new_line_content": "        if (!_fNextFrameRequested.exchange(false, std::memory_order_acq_rel))",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": null,
          "new_api": "onsole application is launched",
          "old_text": null,
          "new_text": "onsole application is launched ",
          "old_line_content": "",
          "new_line_content": "    ResetEvent(_hPaintEnabledEvent);",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": null,
          "new_api": "vent);\n    }\n    else",
          "old_text": null,
          "new_text": "vent);\n    }\n    else\n  ",
          "old_line_content": "    }",
          "new_line_content": "        LOG_IF_FAILED(_pRenderer->PaintFrame());",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": null,
          "new_api": "{\n                // Wait until a nex",
          "old_text": null,
          "new_text": "           {\n                // Wait until a nex",
          "old_line_content": "                // Wait until a next frame is requested.",
          "new_line_content": "            _fWaiting.store(true, std::memory_order_release);",
          "content_same": false
        },
        {
          "line": 189,
          "old_api": null,
          "new_api": "E);\n            }\n\n            // <--\n            // If `Notify",
          "old_text": null,
          "new_text": "E);\n            }\n\n            // <--\n            // If `Notify",
          "old_line_content": "",
          "new_line_content": "            if (!_fNextFrameRequested.exchange(false, std::memory_order_acq_rel))",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 224,
          "old_api": "SetEvent(_hPaintEnabledEvent);\n}\n\nvoid",
          "new_api": null,
          "old_text": "   SetEvent(_hPaintEnabledEvent);\n}\n\nvoid",
          "new_text": null,
          "old_line_content": "    if (_fWaiting.load(std::memory_order_acquire))",
          "new_line_content": "void RenderThread::NotifyPaint() noexcept",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": "ledEvent);\n}\n\nvoid RenderThread::WaitForPaintCompletionAndD",
          "new_api": null,
          "old_text": "ledEvent);\n}\n\nvoid RenderThread::WaitForPaintCompletionAndD",
          "new_text": null,
          "old_line_content": "        _fNextFrameRequested.store(true, std::memory_order_release);",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "    ResetEvent(_hPaintEnabledEvent);",
          "new_line_content": "    //       applications.",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "    WaitForSingleObject(_hPaintCompletedEvent, dwTimeoutMs);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 172,
          "old_api": "// If `NotifyPaint` is called at this point, then",
          "new_api": null,
          "old_text": " // If `NotifyPaint` is called at this point, then",
          "new_text": null,
          "old_line_content": "        WaitForSingleObject(_hPaintEnabledEvent, INFINITE);",
          "new_line_content": "        // Between waiting on _hEvent and calling PaintFrame() there should be a minimal delay,",
          "content_same": false
        },
        {
          "line": 205,
          "old_api": "nRender",
          "new_api": null,
          "old_text": "nRender();\n        LOG_IF_FAILED(_pRenderer->Pain",
          "new_text": null,
          "old_line_content": "            _fWaiting.store(false, std::memory_order_release);",
          "new_line_content": "            // already be set and we won't actually wait.",
          "content_same": false
        },
        {
          "line": 174,
          "old_api": "// set the event because `_fWaiting` is not `true` yet s",
          "new_api": null,
          "old_text": "       // set the event because `_fWaiting` is not `true` yet s",
          "new_text": null,
          "old_line_content": "        if (!_fNextFrameRequested.exchange(false, std::memory_order_acq_rel))",
          "new_line_content": "        // As such, we wait for the renderer to complete _before_ waiting on _hEvent.",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": "es place via DirectX, and a c",
          "new_api": null,
          "old_text": "es place via DirectX, and a c",
          "new_text": null,
          "old_line_content": "    SetEvent(_hPaintEnabledEvent);",
          "new_line_content": "void RenderThread::EnablePainting() noexcept",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": ";\n    }\n\n    return",
          "new_api": null,
          "old_text": ";\n    }\n\n    return",
          "new_text": null,
          "old_line_content": "            ResetEvent(_hEvent);",
          "new_line_content": "            // again if nothing changed.",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": "console application is launche",
          "new_api": null,
          "old_text": " console application is launche",
          "new_text": null,
          "old_line_content": "    ResetEvent(_hPaintEnabledEvent);",
          "new_line_content": "void RenderThread::DisablePainting() noexcept",
          "content_same": false
        },
        {
          "line": 211,
          "old_api": "ead::NotifyPaint() noexcept\n{",
          "new_api": null,
          "old_text": "ead::NotifyPaint() noexcept\n{\n   ",
          "new_text": null,
          "old_line_content": "        ResetEvent(_hPaintCompletedEvent);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": "l))\n            {\n                // Wait until",
          "new_api": null,
          "old_text": "l))\n            {\n                // Wait until ",
          "new_text": null,
          "old_line_content": "            _fWaiting.store(true, std::memory_order_release);",
          "new_line_content": "            // <--",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": "(_hEvent);\n    }\n    els",
          "new_api": null,
          "old_text": "(_hEvent);\n    }\n    els",
          "new_text": null,
          "old_line_content": "        LOG_IF_FAILED(_pRenderer->PaintFrame());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": "FINITE);\n            }\n\n            // <--\n            // If `N",
          "new_api": null,
          "old_text": "FINITE);\n            }\n\n            // <--\n            // If `N",
          "new_text": null,
          "old_line_content": "            if (!_fNextFrameRequested.exchange(false, std::memory_order_acq_rel))",
          "new_line_content": "            // to check again below.",
          "content_same": false
        },
        {
          "line": 187,
          "old_api": "Waiting` is `true`, but we're not wait",
          "new_api": null,
          "old_text": "Waiting` is `true`, but we're not wait",
          "new_text": null,
          "old_line_content": "                WaitForSingleObject(_hEvent, INFINITE);",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 4,
      "total_additions": 15,
      "total_deletions": 15,
      "total_api_changes": 34
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 34,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          176,
          212,
          173,
          215
        ]
      }
    },
    "api_calls_before": 48,
    "api_calls_after": 48,
    "diff_info": {
      "added_lines": 5,
      "removed_lines": 3,
      "total_diff_lines": 28
    }
  }
}