{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/290de647595051034d8f021f24bb4610b2f39943",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/290de647595051034d8f021f24bb4610b2f39943/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/290de647595051034d8f021f24bb4610b2f39943/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/290de647595051034d8f021f24bb4610b2f39943/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 6197,
          "old_api": "AVERROR",
          "new_api": "ff_mov_write_packet",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "ff_mov_write_packet(s, &pkt)",
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "    return ff_mov_write_packet(s, &pkt);",
          "content_same": false
        },
        {
          "line": 6266,
          "old_api": "avcodec_parameters_free",
          "new_api": "MKTAG",
          "old_text": "avcodec_parameters_free(&mov->tracks[mov->chapter_track].par)",
          "new_text": "MKTAG('r','t','p',' ')",
          "old_line_content": "        avcodec_parameters_free(&mov->tracks[mov->chapter_track].par);",
          "new_line_content": "        if (mov->tracks[i].tag == MKTAG('r','t','p',' '))",
          "content_same": false
        },
        {
          "line": 6270,
          "old_api": "MKTAG",
          "new_api": "av_freep",
          "old_text": "MKTAG('r','t','p',' ')",
          "new_text": "av_freep(&mov->tracks[i].cluster)",
          "old_line_content": "        if (mov->tracks[i].tag == MKTAG('r','t','p',' '))",
          "new_line_content": "        av_freep(&mov->tracks[i].cluster);",
          "content_same": false
        },
        {
          "line": 6271,
          "old_api": "ff_mov_close_hinting",
          "new_api": "av_freep",
          "old_text": "ff_mov_close_hinting(&mov->tracks[i])",
          "new_text": "av_freep(&mov->tracks[i].frag_info)",
          "old_line_content": "            ff_mov_close_hinting(&mov->tracks[i]);",
          "new_line_content": "        av_freep(&mov->tracks[i].frag_info);",
          "content_same": false
        },
        {
          "line": 6272,
          "old_api": "MKTAG",
          "new_api": "av_packet_unref",
          "old_text": "MKTAG('t','m','c','d')",
          "new_text": "av_packet_unref(&mov->tracks[i].cover_image)",
          "old_line_content": "        else if (mov->tracks[i].tag == MKTAG('t','m','c','d') && mov->nb_meta_tmcd)",
          "new_line_content": "        av_packet_unref(&mov->tracks[i].cover_image);",
          "content_same": false
        },
        {
          "line": 6280,
          "old_api": "av_packet_unref",
          "new_api": "av_freep",
          "old_text": "av_packet_unref(&info->pkt)",
          "new_text": "av_freep(&mov->tracks[i].vos_data)",
          "old_line_content": "            av_packet_unref(&info->pkt);",
          "new_line_content": "            av_freep(&mov->tracks[i].vos_data);",
          "content_same": false
        },
        {
          "line": 6286,
          "old_api": "ff_mov_cenc_free",
          "new_api": "av_freep",
          "old_text": "ff_mov_cenc_free(&mov->tracks[i].cenc)",
          "new_text": "av_freep(&mov->tracks)",
          "old_line_content": "        ff_mov_cenc_free(&mov->tracks[i].cenc);",
          "new_line_content": "    av_freep(&mov->tracks);",
          "content_same": false
        },
        {
          "line": 6332,
          "old_api": "rgb_to_yuv",
          "new_api": "sscanf",
          "old_text": "rgb_to_yuv(palette[i])",
          "new_text": "sscanf(cur + 5, \"%dx%d\", &width, &height)",
          "old_line_content": "                palette[i] = rgb_to_yuv(palette[i]);",
          "new_line_content": "            sscanf(cur + 5, \"%dx%d\", &width, &height);",
          "content_same": false
        },
        {
          "line": 6341,
          "old_api": "strcspn",
          "new_api": "av_malloc",
          "old_text": "strcspn(cur, \"\\n\\r\")",
          "new_text": "av_malloc(16*4 + AV_INPUT_BUFFER_PADDING_SIZE)",
          "old_line_content": "        cur += strcspn(cur, \"\\n\\r\");",
          "new_line_content": "        track->vos_data = av_malloc(16*4 + AV_INPUT_BUFFER_PADDING_SIZE);",
          "content_same": false
        },
        {
          "line": 6345,
          "old_api": "av_malloc",
          "new_api": "AV_WB32",
          "old_text": "av_malloc(16*4 + AV_INPUT_BUFFER_PADDING_SIZE)",
          "new_text": "AV_WB32(track->vos_data + i * 4, palette[i])",
          "old_line_content": "        track->vos_data = av_malloc(16*4 + AV_INPUT_BUFFER_PADDING_SIZE);",
          "new_line_content": "            AV_WB32(track->vos_data + i * 4, palette[i]);",
          "content_same": false
        },
        {
          "line": 6347,
          "old_api": "AVERROR",
          "new_api": "memset",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "memset(track->vos_data + 16*4, 0, AV_INPUT_BUFFER_PADDING_SIZE)",
          "old_line_content": "            return AVERROR(ENOMEM);",
          "new_line_content": "        memset(track->vos_data + 16*4, 0, AV_INPUT_BUFFER_PADDING_SIZE);",
          "content_same": false
        },
        {
          "line": 6511,
          "old_api": "av_mallocz_array",
          "new_api": "strcmp",
          "old_text": "av_mallocz_array((mov->nb_streams + 1), sizeof(*mov->tracks))",
          "new_text": "strcmp(mov->encryption_scheme_str, \"none\")",
          "old_line_content": "    mov->tracks = av_mallocz_array((mov->nb_streams + 1), sizeof(*mov->tracks));",
          "new_line_content": "    if (mov->encryption_scheme_str != NULL && strcmp(mov->encryption_scheme_str, \"none\") != 0) {",
          "content_same": false
        },
        {
          "line": 6516,
          "old_api": "strcmp",
          "new_api": "av_log",
          "old_text": "strcmp(mov->encryption_scheme_str, \"cenc-aes-ctr\")",
          "new_text": "av_log(s, AV_LOG_ERROR, \"Invalid encryption key len %d expected %d\\n\",\n                    mov->encryption_key_len, AES_CTR_KEY_SIZE)",
          "old_line_content": "        if (strcmp(mov->encryption_scheme_str, \"cenc-aes-ctr\") == 0) {",
          "new_line_content": "                av_log(s, AV_LOG_ERROR, \"Invalid encryption key len %d expected %d\\n\",",
          "content_same": false
        },
        {
          "line": 6522,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(s, AV_LOG_ERROR, \"Invalid encryption kid len %d expected %d\\n\",\n                    mov->encryption_kid_len, CENC_KID_SIZE)",
          "old_line_content": "                return AVERROR(EINVAL);",
          "new_line_content": "                av_log(s, AV_LOG_ERROR, \"Invalid encryption kid len %d expected %d\\n\",",
          "content_same": false
        },
        {
          "line": 6540,
          "old_api": "av_dict_get",
          "new_api": "ff_mov_iso639_to_lang",
          "old_text": "av_dict_get(st->metadata, \"language\", NULL,0)",
          "new_text": "ff_mov_iso639_to_lang(lang?lang->value:\"und\", mov->mode!=MODE_MOV)",
          "old_line_content": "        AVDictionaryEntry *lang = av_dict_get(st->metadata, \"language\", NULL,0);",
          "new_line_content": "        track->language = ff_mov_iso639_to_lang(lang?lang->value:\"und\", mov->mode!=MODE_MOV);",
          "content_same": false
        },
        {
          "line": 6544,
          "old_api": "ff_mov_iso639_to_lang",
          "new_api": "mov_find_codec_tag",
          "old_text": "ff_mov_iso639_to_lang(lang?lang->value:\"und\", mov->mode!=MODE_MOV)",
          "new_text": "mov_find_codec_tag(s, track)",
          "old_line_content": "        track->language = ff_mov_iso639_to_lang(lang?lang->value:\"und\", mov->mode!=MODE_MOV);",
          "new_line_content": "        track->tag  = mov_find_codec_tag(s, track);",
          "content_same": false
        },
        {
          "line": 6548,
          "old_api": "mov_find_codec_tag",
          "new_api": "avcodec_get_name",
          "old_text": "mov_find_codec_tag(s, track)",
          "new_text": "avcodec_get_name(st->codecpar->codec_id)",
          "old_line_content": "        track->tag  = mov_find_codec_tag(s, track);",
          "new_line_content": "                   avcodec_get_name(st->codecpar->codec_id), i);",
          "content_same": false
        },
        {
          "line": 6563,
          "old_api": "MKTAG",
          "new_api": "av_log",
          "old_text": "MKTAG('m','x','3','n')",
          "new_text": "av_log(s, AV_LOG_ERROR, \"D-10/IMX must use 720x608 or 720x512 video resolution\\n\")",
          "old_line_content": "            if (track->tag == MKTAG('m','x','3','p') || track->tag == MKTAG('m','x','3','n') ||",
          "new_line_content": "                    av_log(s, AV_LOG_ERROR, \"D-10/IMX must use 720x608 or 720x512 video resolution\\n\");",
          "content_same": false
        },
        {
          "line": 6564,
          "old_api": "MKTAG",
          "new_api": "AVERROR",
          "old_text": "MKTAG('m','x','4','n')",
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "                track->tag == MKTAG('m','x','4','p') || track->tag == MKTAG('m','x','4','n') ||",
          "new_line_content": "                    return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 6654,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(s, AV_LOG_ERROR,\n                           \"%s in MP4 support is experimental, add \"\n                           \"'-strict %d' if you want to use it.\\n\",\n                           avcodec_get_name(track->par->codec_id), FF_COMPLIANCE_EXPERIMENTAL)",
          "old_line_content": "                    return AVERROR(EINVAL);",
          "new_line_content": "                    av_log(s, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 6726,
          "old_api": "TAG_IS_AVCI",
          "new_api": "AVERROR",
          "old_text": "TAG_IS_AVCI(track->tag)",
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "            else if (!TAG_IS_AVCI(track->tag) && st->codecpar->codec_id != AV_CODEC_ID_DNXHD) {",
          "new_line_content": "                    return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 6728,
          "old_api": "av_malloc",
          "new_api": "memcpy",
          "old_text": "av_malloc(track->vos_len + AV_INPUT_BUFFER_PADDING_SIZE)",
          "new_text": "memcpy(track->vos_data, st->codecpar->extradata, track->vos_len)",
          "old_line_content": "                track->vos_data = av_malloc(track->vos_len + AV_INPUT_BUFFER_PADDING_SIZE);",
          "new_line_content": "                memcpy(track->vos_data, st->codecpar->extradata, track->vos_len);",
          "content_same": false
        },
        {
          "line": 6777,
          "old_api": "avio_tell",
          "new_api": "ff_parse_creation_time_metadata",
          "old_text": "avio_tell(pb)",
          "new_text": "ff_parse_creation_time_metadata(s, &mov->time, 1)",
          "old_line_content": "            mov->reserved_header_pos = avio_tell(pb);",
          "new_line_content": "    ff_parse_creation_time_metadata(s, &mov->time, 1);",
          "content_same": false
        },
        {
          "line": 6823,
          "old_api": "mov_write_isml_manifest",
          "new_api": "mov_write_moov_tag",
          "old_text": "mov_write_isml_manifest(pb, mov, s)",
          "new_text": "mov_write_moov_tag(pb, mov, s)",
          "old_line_content": "        mov_write_isml_manifest(pb, mov, s);",
          "new_line_content": "        if ((ret = mov_write_moov_tag(pb, mov, s)) < 0)",
          "content_same": false
        },
        {
          "line": 6827,
          "old_api": "mov_write_moov_tag",
          "new_api": "avio_tell",
          "old_text": "mov_write_moov_tag(pb, mov, s)",
          "new_text": "avio_tell(pb)",
          "old_line_content": "        if ((ret = mov_write_moov_tag(pb, mov, s)) < 0)",
          "new_line_content": "            mov->reserved_header_pos = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 6843,
          "old_api": "ffio_open_null_buf",
          "new_api": "ffio_close_null_buf",
          "old_text": "ffio_open_null_buf(&moov_buf)",
          "new_text": "ffio_close_null_buf(moov_buf)",
          "old_line_content": "    if ((ret = ffio_open_null_buf(&moov_buf)) < 0)",
          "new_line_content": "    return ffio_close_null_buf(moov_buf);",
          "content_same": false
        },
        {
          "line": 6921,
          "old_api": "compute_moov_size",
          "new_api": "av_malloc",
          "old_text": "compute_moov_size(s)",
          "new_text": "av_malloc(moov_size * 2)",
          "old_line_content": "        moov_size = compute_moov_size(s);",
          "new_line_content": "    buf = av_malloc(moov_size * 2);",
          "content_same": false
        },
        {
          "line": 6944,
          "old_api": "avio_tell",
          "new_api": "avio_seek",
          "old_text": "avio_tell(s->pb)",
          "new_text": "avio_seek(read_pb, mov->reserved_header_pos, SEEK_SET)",
          "old_line_content": "    pos_end = avio_tell(s->pb);",
          "new_line_content": "    avio_seek(read_pb, mov->reserved_header_pos, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 6945,
          "old_api": "avio_seek",
          "new_api": "avio_tell",
          "old_text": "avio_seek(s->pb, mov->reserved_header_pos + moov_size, SEEK_SET)",
          "new_text": "avio_tell(read_pb)",
          "old_line_content": "    avio_seek(s->pb, mov->reserved_header_pos + moov_size, SEEK_SET);",
          "new_line_content": "    pos = avio_tell(read_pb);",
          "content_same": false
        },
        {
          "line": 6988,
          "old_api": "av_freep",
          "new_api": "memcpy",
          "old_text": "av_freep(&track->vos_data)",
          "new_text": "memcpy(track->vos_data, par->extradata, track->vos_len)",
          "old_line_content": "            av_freep(&track->vos_data);",
          "new_line_content": "            memcpy(track->vos_data, par->extradata, track->vos_len);",
          "content_same": false
        },
        {
          "line": 6989,
          "old_api": "av_malloc",
          "new_api": "memset",
          "old_text": "av_malloc(track->vos_len + AV_INPUT_BUFFER_PADDING_SIZE)",
          "new_text": "memset(track->vos_data + track->vos_len, 0, AV_INPUT_BUFFER_PADDING_SIZE)",
          "old_line_content": "            track->vos_data = av_malloc(track->vos_len + AV_INPUT_BUFFER_PADDING_SIZE);",
          "new_line_content": "            memset(track->vos_data + track->vos_len, 0, AV_INPUT_BUFFER_PADDING_SIZE);",
          "content_same": false
        },
        {
          "line": 7023,
          "old_api": "avio_tell",
          "new_api": "avio_seek",
          "old_text": "avio_tell(pb)",
          "new_text": "avio_seek(pb, mov->mdat_pos, SEEK_SET)",
          "old_line_content": "        moov_pos = avio_tell(pb);",
          "new_line_content": "            avio_seek(pb, mov->mdat_pos, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 7031,
          "old_api": "avio_seek",
          "new_api": "ffio_wfourcc",
          "old_text": "avio_seek(pb, mov->mdat_pos - 8, SEEK_SET)",
          "new_text": "ffio_wfourcc(pb, \"mdat\")",
          "old_line_content": "            avio_seek(pb, mov->mdat_pos - 8, SEEK_SET);",
          "new_line_content": "            ffio_wfourcc(pb, \"mdat\");",
          "content_same": false
        },
        {
          "line": 7034,
          "old_api": "avio_wb32",
          "new_api": "avio_seek",
          "old_text": "avio_wb32(pb, 1)",
          "new_text": "avio_seek(pb, mov->reserved_moov_size > 0 ? mov->reserved_header_pos : moov_pos, SEEK_SET)",
          "old_line_content": "            avio_wb32(pb, 1);",
          "new_line_content": "        avio_seek(pb, mov->reserved_moov_size > 0 ? mov->reserved_header_pos : moov_pos, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 7038,
          "old_api": "avio_seek",
          "new_api": "shift_data",
          "old_text": "avio_seek(pb, mov->reserved_moov_size > 0 ? mov->reserved_header_pos : moov_pos, SEEK_SET)",
          "new_text": "shift_data(s)",
          "old_line_content": "        avio_seek(pb, mov->reserved_moov_size > 0 ? mov->reserved_header_pos : moov_pos, SEEK_SET);",
          "new_line_content": "            res = shift_data(s);",
          "content_same": false
        },
        {
          "line": 7041,
          "old_api": "av_log",
          "new_api": "avio_seek",
          "old_text": "av_log(s, AV_LOG_INFO, \"Starting second pass: moving the moov atom to the beginning of the file\\n\")",
          "new_text": "avio_seek(pb, mov->reserved_header_pos, SEEK_SET)",
          "old_line_content": "            av_log(s, AV_LOG_INFO, \"Starting second pass: moving the moov atom to the beginning of the file\\n\");",
          "new_line_content": "            avio_seek(pb, mov->reserved_header_pos, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 7042,
          "old_api": "shift_data",
          "new_api": "mov_write_moov_tag",
          "old_text": "shift_data(s)",
          "new_text": "mov_write_moov_tag(pb, mov, s)",
          "old_line_content": "            res = shift_data(s);",
          "new_line_content": "            if ((res = mov_write_moov_tag(pb, mov, s)) < 0)",
          "content_same": false
        },
        {
          "line": 7050,
          "old_api": "mov_write_moov_tag",
          "new_api": "av_log",
          "old_text": "mov_write_moov_tag(pb, mov, s)",
          "new_text": "av_log(s, AV_LOG_ERROR, \"reserved_moov_size is too small, needed %\"PRId64\" additional\\n\", 8-size)",
          "old_line_content": "            if ((res = mov_write_moov_tag(pb, mov, s)) < 0)",
          "new_line_content": "                av_log(s, AV_LOG_ERROR, \"reserved_moov_size is too small, needed %\"PRId64\" additional\\n\", 8-size);",
          "content_same": false
        },
        {
          "line": 7054,
          "old_api": "av_log",
          "new_api": "ffio_wfourcc",
          "old_text": "av_log(s, AV_LOG_ERROR, \"reserved_moov_size is too small, needed %\"PRId64\" additional\\n\", 8-size)",
          "new_text": "ffio_wfourcc(pb, \"free\")",
          "old_line_content": "                av_log(s, AV_LOG_ERROR, \"reserved_moov_size is too small, needed %\"PRId64\" additional\\n\", 8-size);",
          "new_line_content": "            ffio_wfourcc(pb, \"free\");",
          "content_same": false
        },
        {
          "line": 7055,
          "old_api": "AVERROR",
          "new_api": "ffio_fill",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "ffio_fill(pb, 0, size - 8)",
          "old_line_content": "                return AVERROR(EINVAL);",
          "new_line_content": "            ffio_fill(pb, 0, size - 8);",
          "content_same": false
        },
        {
          "line": 7058,
          "old_api": "ffio_wfourcc",
          "new_api": "mov_write_moov_tag",
          "old_text": "ffio_wfourcc(pb, \"free\")",
          "new_text": "mov_write_moov_tag(pb, mov, s)",
          "old_line_content": "            ffio_wfourcc(pb, \"free\");",
          "new_line_content": "            if ((res = mov_write_moov_tag(pb, mov, s)) < 0)",
          "content_same": false
        },
        {
          "line": 7072,
          "old_api": "av_log",
          "new_api": "avio_tell",
          "old_text": "av_log(s, AV_LOG_INFO, \"Starting second pass: inserting sidx atoms\\n\")",
          "new_text": "avio_tell(pb)",
          "old_line_content": "            av_log(s, AV_LOG_INFO, \"Starting second pass: inserting sidx atoms\\n\");",
          "new_line_content": "            end = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 7073,
          "old_api": "shift_data",
          "new_api": "avio_seek",
          "old_text": "shift_data(s)",
          "new_text": "avio_seek(pb, mov->reserved_header_pos, SEEK_SET)",
          "old_line_content": "            res = shift_data(s);",
          "new_line_content": "            avio_seek(pb, mov->reserved_header_pos, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 7078,
          "old_api": "mov_write_sidx_tags",
          "new_api": "avio_write_marker",
          "old_text": "mov_write_sidx_tags(pb, mov, -1, 0)",
          "new_text": "avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_TRAILER)",
          "old_line_content": "            mov_write_sidx_tags(pb, mov, -1, 0);",
          "new_line_content": "            avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_TRAILER);",
          "content_same": false
        },
        {
          "line": 7079,
          "old_api": "avio_seek",
          "new_api": "mov_write_mfra_tag",
          "old_text": "avio_seek(pb, end, SEEK_SET)",
          "new_text": "mov_write_mfra_tag(pb, mov)",
          "old_line_content": "            avio_seek(pb, end, SEEK_SET);",
          "new_line_content": "            res = mov_write_mfra_tag(pb, mov);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 7168,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('m','p','4','a')",
          "old_line_content": "};",
          "new_line_content": "    { AV_CODEC_ID_AAC,    MKTAG('m','p','4','a') },",
          "content_same": false
        },
        {
          "line": 6657,
          "old_api": null,
          "new_api": "avcodec_get_name",
          "old_text": null,
          "new_text": "avcodec_get_name(track->par->codec_id)",
          "old_line_content": "                    s->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {",
          "new_line_content": "                           avcodec_get_name(track->par->codec_id), FF_COMPLIANCE_EXPERIMENTAL);",
          "content_same": false
        },
        {
          "line": 7169,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('a','v','c','1')",
          "old_line_content": "",
          "new_line_content": "    { AV_CODEC_ID_H264,   MKTAG('a','v','c','1') },",
          "content_same": false
        },
        {
          "line": 7170,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('V','P','6','A')",
          "old_line_content": "static const AVCodecTag codec_f4v_tags[] = {",
          "new_line_content": "    { AV_CODEC_ID_VP6A,   MKTAG('V','P','6','A') },",
          "content_same": false
        },
        {
          "line": 7176,
          "old_api": null,
          "new_api": "MOV_CLASS",
          "old_text": null,
          "new_text": "MOV_CLASS(mov)",
          "old_line_content": "    { AV_CODEC_ID_NONE, 0 },",
          "new_line_content": "MOV_CLASS(mov)",
          "content_same": false
        },
        {
          "line": 7179,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"QuickTime / MOV\")",
          "old_line_content": "#if CONFIG_MOV_MUXER",
          "new_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"QuickTime / MOV\"),",
          "content_same": false
        },
        {
          "line": 6679,
          "old_api": null,
          "new_api": "avpriv_set_pts_info",
          "old_text": null,
          "new_text": "avpriv_set_pts_info(st, 64, 1, track->timescale)",
          "old_line_content": "            (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && !mov->video_track_timescale))) {",
          "new_line_content": "        avpriv_set_pts_info(st, 64, 1, track->timescale);",
          "content_same": false
        },
        {
          "line": 6682,
          "old_api": null,
          "new_api": "ff_mov_cenc_init",
          "old_text": null,
          "new_text": "ff_mov_cenc_init(&track->cenc, mov->encryption_key,\n                track->par->codec_id == AV_CODEC_ID_H264, s->flags & AVFMT_FLAG_BITEXACT)",
          "old_line_content": "",
          "new_line_content": "            ret = ff_mov_cenc_init(&track->cenc, mov->encryption_key,",
          "content_same": false
        },
        {
          "line": 6174,
          "old_api": null,
          "new_api": "find_fps",
          "old_text": null,
          "new_text": "find_fps(s, src_st)",
          "old_line_content": "",
          "new_line_content": "    AVRational rate = find_fps(s, src_st);",
          "content_same": false
        },
        {
          "line": 7199,
          "old_api": null,
          "new_api": "MOV_CLASS",
          "old_text": null,
          "new_text": "MOV_CLASS(tgp)",
          "old_line_content": "    .priv_class        = &mov_muxer_class,",
          "new_line_content": "MOV_CLASS(tgp)",
          "content_same": false
        },
        {
          "line": 6689,
          "old_api": null,
          "new_api": "enable_tracks",
          "old_text": null,
          "new_text": "enable_tracks(s)",
          "old_line_content": "                return ret;",
          "new_line_content": "    enable_tracks(s);",
          "content_same": false
        },
        {
          "line": 6178,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('t','m','c','d')",
          "old_line_content": "    track->src_track = src_index;",
          "new_line_content": "    track->tag       = MKTAG('t','m','c','d');",
          "content_same": false
        },
        {
          "line": 7202,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"3GP (3GPP file format)\")",
          "old_line_content": "#if CONFIG_TGP_MUXER",
          "new_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"3GP (3GPP file format)\"),",
          "content_same": false
        },
        {
          "line": 6697,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(s->metadata, \"timecode\", NULL, 0)",
          "old_line_content": "static int mov_write_header(AVFormatContext *s)",
          "new_line_content": "    AVDictionaryEntry *t, *global_tcr = av_dict_get(s->metadata, \"timecode\", NULL, 0);",
          "content_same": false
        },
        {
          "line": 6188,
          "old_api": null,
          "new_api": "avcodec_parameters_alloc",
          "old_text": null,
          "new_text": "avcodec_parameters_alloc()",
          "old_line_content": "    if (!track->par)",
          "new_line_content": "    track->par = avcodec_parameters_alloc();",
          "content_same": false
        },
        {
          "line": 6190,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    track->par->codec_type = AVMEDIA_TYPE_DATA;",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 6193,
          "old_api": null,
          "new_api": "av_inv_q",
          "old_text": null,
          "new_text": "av_inv_q(rate)",
          "old_line_content": "",
          "new_line_content": "    track->st->avg_frame_rate = av_inv_q(rate);",
          "content_same": false
        },
        {
          "line": 6706,
          "old_api": null,
          "new_api": "rtp_hinting_needed",
          "old_text": null,
          "new_text": "rtp_hinting_needed(s->streams[i])",
          "old_line_content": "",
          "new_line_content": "            if (rtp_hinting_needed(s->streams[i]))",
          "content_same": false
        },
        {
          "line": 7219,
          "old_api": null,
          "new_api": "MOV_CLASS",
          "old_text": null,
          "new_text": "MOV_CLASS(mp4)",
          "old_line_content": "    .priv_class        = &tgp_muxer_class,",
          "new_line_content": "MOV_CLASS(mp4)",
          "content_same": false
        },
        {
          "line": 6196,
          "old_api": null,
          "new_api": "AV_WB32",
          "old_text": null,
          "new_text": "AV_WB32(pkt.data, tc.start)",
          "old_line_content": "    if (!pkt.data)",
          "new_line_content": "    AV_WB32(pkt.data, tc.start);",
          "content_same": false
        },
        {
          "line": 7222,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"MP4 (MPEG-4 Part 14)\")",
          "old_line_content": "#if CONFIG_MP4_MUXER",
          "new_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"MP4 (MPEG-4 Part 14)\"),",
          "content_same": false
        },
        {
          "line": 6721,
          "old_api": null,
          "new_api": "mov_create_dvd_sub_decoder_specific_info",
          "old_text": null,
          "new_text": "mov_create_dvd_sub_decoder_specific_info(track, st)",
          "old_line_content": "",
          "new_line_content": "                mov_create_dvd_sub_decoder_specific_info(track, st);",
          "content_same": false
        },
        {
          "line": 6722,
          "old_api": null,
          "new_api": "TAG_IS_AVCI",
          "old_text": null,
          "new_text": "TAG_IS_AVCI(track->tag)",
          "old_line_content": "        /* copy extradata if it exists */",
          "new_line_content": "            else if (!TAG_IS_AVCI(track->tag) && st->codecpar->codec_id != AV_CODEC_ID_DNXHD) {",
          "content_same": false
        },
        {
          "line": 6724,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(track->vos_len + AV_INPUT_BUFFER_PADDING_SIZE)",
          "old_line_content": "            if (st->codecpar->codec_id == AV_CODEC_ID_DVD_SUBTITLE)",
          "new_line_content": "                track->vos_data = av_malloc(track->vos_len + AV_INPUT_BUFFER_PADDING_SIZE);",
          "content_same": false
        },
        {
          "line": 6729,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(track->vos_data + track->vos_len, 0, AV_INPUT_BUFFER_PADDING_SIZE)",
          "old_line_content": "                if (!track->vos_data) {",
          "new_line_content": "                memset(track->vos_data + track->vos_len, 0, AV_INPUT_BUFFER_PADDING_SIZE);",
          "content_same": false
        },
        {
          "line": 7241,
          "old_api": null,
          "new_api": "MOV_CLASS",
          "old_text": null,
          "new_text": "MOV_CLASS(psp)",
          "old_line_content": "    .priv_class        = &mp4_muxer_class,",
          "new_line_content": "MOV_CLASS(psp)",
          "content_same": false
        },
        {
          "line": 7244,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"PSP MP4 (MPEG-4 Part 14)\")",
          "old_line_content": "#if CONFIG_PSP_MUXER",
          "new_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"PSP MP4 (MPEG-4 Part 14)\"),",
          "content_same": false
        },
        {
          "line": 6228,
          "old_api": null,
          "new_api": "is_cover_image",
          "old_text": null,
          "new_text": "is_cover_image(st)",
          "old_line_content": "        AVStream *st = s->streams[i];",
          "new_line_content": "            is_cover_image(st))",
          "content_same": false
        },
        {
          "line": 7262,
          "old_api": null,
          "new_api": "MOV_CLASS",
          "old_text": null,
          "new_text": "MOV_CLASS(tg2)",
          "old_line_content": "    .priv_class        = &psp_muxer_class,",
          "new_line_content": "MOV_CLASS(tg2)",
          "content_same": false
        },
        {
          "line": 7265,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"3GP2 (3GPP2 file format)\")",
          "old_line_content": "#if CONFIG_TG2_MUXER",
          "new_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"3GP2 (3GPP2 file format)\"),",
          "content_same": false
        },
        {
          "line": 6754,
          "old_api": null,
          "new_api": "mov_write_identification",
          "old_text": null,
          "new_text": "mov_write_identification(pb, s)",
          "old_line_content": "        }",
          "new_line_content": "        if ((ret = mov_write_identification(pb, s)) < 0)",
          "content_same": false
        },
        {
          "line": 6759,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "            return ret;",
          "new_line_content": "        mov->reserved_header_pos = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 6761,
          "old_api": null,
          "new_api": "avio_skip",
          "old_text": null,
          "new_text": "avio_skip(pb, mov->reserved_moov_size)",
          "old_line_content": "",
          "new_line_content": "            avio_skip(pb, mov->reserved_moov_size);",
          "content_same": false
        },
        {
          "line": 7282,
          "old_api": null,
          "new_api": "MOV_CLASS",
          "old_text": null,
          "new_text": "MOV_CLASS(ipod)",
          "old_line_content": "    .priv_class        = &tg2_muxer_class,",
          "new_line_content": "MOV_CLASS(ipod)",
          "content_same": false
        },
        {
          "line": 6773,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "            !mov->max_fragment_duration && !mov->max_fragment_size)",
          "new_line_content": "            mov->reserved_header_pos = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 6262,
          "old_api": null,
          "new_api": "avcodec_parameters_free",
          "old_text": null,
          "new_text": "avcodec_parameters_free(&mov->tracks[mov->chapter_track].par)",
          "old_line_content": "    if (!mov->tracks)",
          "new_line_content": "        avcodec_parameters_free(&mov->tracks[mov->chapter_track].par);",
          "content_same": false
        },
        {
          "line": 6774,
          "old_api": null,
          "new_api": "mov_write_mdat_tag",
          "old_text": null,
          "new_text": "mov_write_mdat_tag(pb, mov)",
          "old_line_content": "            mov->flags |= FF_MOV_FLAG_FRAG_KEYFRAME;",
          "new_line_content": "        mov_write_mdat_tag(pb, mov);",
          "content_same": false
        },
        {
          "line": 7285,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"iPod H.264 MP4 (MPEG-4 Part 14)\")",
          "old_line_content": "#if CONFIG_IPOD_MUXER",
          "new_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"iPod H.264 MP4 (MPEG-4 Part 14)\"),",
          "content_same": false
        },
        {
          "line": 6267,
          "old_api": null,
          "new_api": "ff_mov_close_hinting",
          "old_text": null,
          "new_text": "ff_mov_close_hinting(&mov->tracks[i])",
          "old_line_content": "    }",
          "new_line_content": "            ff_mov_close_hinting(&mov->tracks[i]);",
          "content_same": false
        },
        {
          "line": 6268,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('t','m','c','d')",
          "old_line_content": "",
          "new_line_content": "        else if (mov->tracks[i].tag == MKTAG('t','m','c','d') && mov->nb_meta_tmcd)",
          "content_same": false
        },
        {
          "line": 6269,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&mov->tracks[i].par)",
          "old_line_content": "    for (i = 0; i < mov->nb_streams; i++) {",
          "new_line_content": "            av_freep(&mov->tracks[i].par);",
          "content_same": false
        },
        {
          "line": 6782,
          "old_api": null,
          "new_api": "mov_create_chapter_track",
          "old_text": null,
          "new_text": "mov_create_chapter_track(s, mov->chapter_track)",
          "old_line_content": "    if (mov->time)",
          "new_line_content": "        if ((ret = mov_create_chapter_track(s, mov->chapter_track)) < 0)",
          "content_same": false
        },
        {
          "line": 6787,
          "old_api": null,
          "new_api": "rtp_hinting_needed",
          "old_text": null,
          "new_text": "rtp_hinting_needed(s->streams[i])",
          "old_line_content": "            return ret;",
          "new_line_content": "            if (rtp_hinting_needed(s->streams[i])) {",
          "content_same": false
        },
        {
          "line": 6788,
          "old_api": null,
          "new_api": "ff_mov_init_hinting",
          "old_text": null,
          "new_text": "ff_mov_init_hinting(s, hint_track, i)",
          "old_line_content": "",
          "new_line_content": "                if ((ret = ff_mov_init_hinting(s, hint_track, i)) < 0)",
          "content_same": false
        },
        {
          "line": 6277,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&mov->tracks[i].eac3_priv)",
          "old_line_content": "",
          "new_line_content": "            av_freep(&mov->tracks[i].eac3_priv);",
          "content_same": false
        },
        {
          "line": 7303,
          "old_api": null,
          "new_api": "MOV_CLASS",
          "old_text": null,
          "new_text": "MOV_CLASS(ismv)",
          "old_line_content": "    .priv_class        = &ipod_muxer_class,",
          "new_line_content": "MOV_CLASS(ismv)",
          "content_same": false
        },
        {
          "line": 6282,
          "old_api": null,
          "new_api": "ff_mov_cenc_free",
          "old_text": null,
          "new_text": "ff_mov_cenc_free(&mov->tracks[i].cenc)",
          "old_line_content": "        }",
          "new_line_content": "        ff_mov_cenc_free(&mov->tracks[i].cenc);",
          "content_same": false
        },
        {
          "line": 6283,
          "old_api": null,
          "new_api": "ffio_free_dyn_buf",
          "old_text": null,
          "new_text": "ffio_free_dyn_buf(&mov->tracks[i].mdat_buf)",
          "old_line_content": "        if (mov->tracks[i].vos_len)",
          "new_line_content": "        ffio_free_dyn_buf(&mov->tracks[i].mdat_buf);",
          "content_same": false
        },
        {
          "line": 7306,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"ISMV/ISMA (Smooth Streaming)\")",
          "old_line_content": "#if CONFIG_ISMV_MUXER",
          "new_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"ISMV/ISMA (Smooth Streaming)\"),",
          "content_same": false
        },
        {
          "line": 6804,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(st->metadata, \"timecode\", NULL, 0)",
          "old_line_content": "",
          "new_line_content": "                    t = av_dict_get(st->metadata, \"timecode\", NULL, 0);",
          "content_same": false
        },
        {
          "line": 6807,
          "old_api": null,
          "new_api": "mov_check_timecode_track",
          "old_text": null,
          "new_text": "mov_check_timecode_track(s, &tc, i, t->value)",
          "old_line_content": "                if (!t)",
          "new_line_content": "                if (mov_check_timecode_track(s, &tc, i, t->value) < 0)",
          "content_same": false
        },
        {
          "line": 6809,
          "old_api": null,
          "new_api": "mov_create_timecode_track",
          "old_text": null,
          "new_text": "mov_create_timecode_track(s, tmcd_track, i, tc)",
          "old_line_content": "                if (!t)",
          "new_line_content": "                if ((ret = mov_create_timecode_track(s, tmcd_track, i, tc)) < 0)",
          "content_same": false
        },
        {
          "line": 6299,
          "old_api": null,
          "new_api": "av_clip_uint8",
          "old_text": null,
          "new_text": "av_clip_uint8(( 16000 +  257 * r + 504 * g +  98 * b)/1000)",
          "old_line_content": "    r = (rgb >> 16) & 0xFF;",
          "new_line_content": "    y  = av_clip_uint8(( 16000 +  257 * r + 504 * g +  98 * b)/1000);",
          "content_same": false
        },
        {
          "line": 6300,
          "old_api": null,
          "new_api": "av_clip_uint8",
          "old_text": null,
          "new_text": "av_clip_uint8((128000 -  148 * r - 291 * g + 439 * b)/1000)",
          "old_line_content": "    g = (rgb >>  8) & 0xFF;",
          "new_line_content": "    cb = av_clip_uint8((128000 -  148 * r - 291 * g + 439 * b)/1000);",
          "content_same": false
        },
        {
          "line": 6301,
          "old_api": null,
          "new_api": "av_clip_uint8",
          "old_text": null,
          "new_text": "av_clip_uint8((128000 +  439 * r - 368 * g -  71 * b)/1000)",
          "old_line_content": "    b = (rgb      ) & 0xFF;",
          "new_line_content": "    cr = av_clip_uint8((128000 +  439 * r - 368 * g -  71 * b)/1000);",
          "content_same": false
        },
        {
          "line": 7325,
          "old_api": null,
          "new_api": "MOV_CLASS",
          "old_text": null,
          "new_text": "MOV_CLASS(f4v)",
          "old_line_content": "    .priv_class        = &ismv_muxer_class,",
          "new_line_content": "MOV_CLASS(f4v)",
          "content_same": false
        },
        {
          "line": 6816,
          "old_api": null,
          "new_api": "avio_flush",
          "old_text": null,
          "new_text": "avio_flush(pb)",
          "old_line_content": "            }",
          "new_line_content": "    avio_flush(pb);",
          "content_same": false
        },
        {
          "line": 7328,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"F4V Adobe Flash Video\")",
          "old_line_content": "#if CONFIG_F4V_MUXER",
          "new_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"F4V Adobe Flash Video\"),",
          "content_same": false
        },
        {
          "line": 6819,
          "old_api": null,
          "new_api": "mov_write_isml_manifest",
          "old_text": null,
          "new_text": "mov_write_isml_manifest(pb, mov, s)",
          "old_line_content": "",
          "new_line_content": "        mov_write_isml_manifest(pb, mov, s);",
          "content_same": false
        },
        {
          "line": 6315,
          "old_api": null,
          "new_api": "strncmp",
          "old_text": null,
          "new_text": "strncmp(\"palette:\", cur, 8)",
          "old_line_content": "    uint32_t palette[16];",
          "new_line_content": "        if (strncmp(\"palette:\", cur, 8) == 0) {",
          "content_same": false
        },
        {
          "line": 6317,
          "old_api": null,
          "new_api": "sscanf",
          "old_text": null,
          "new_text": "sscanf(cur + 8,\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", \"\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", \"\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", \"\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\"\",\n                &palette[ 0], &palette[ 1], &palette[ 2], &palette[ 3],\n                &palette[ 4], &palette[ 5], &palette[ 6], &palette[ 7],\n                &palette[ 8], &palette[ 9], &palette[10], &palette[11],\n                &palette[12], &palette[13], &palette[14], &palette[15])",
          "old_line_content": "",
          "new_line_content": "            count = sscanf(cur + 8,",
          "content_same": false
        },
        {
          "line": 6839,
          "old_api": null,
          "new_api": "ffio_open_null_buf",
          "old_text": null,
          "new_text": "ffio_open_null_buf(&moov_buf)",
          "old_line_content": "    int ret;",
          "new_line_content": "    if ((ret = ffio_open_null_buf(&moov_buf)) < 0)",
          "content_same": false
        },
        {
          "line": 6328,
          "old_api": null,
          "new_api": "rgb_to_yuv",
          "old_text": null,
          "new_text": "rgb_to_yuv(palette[i])",
          "old_line_content": "                &palette[ 8], &palette[ 9], &palette[10], &palette[11],",
          "new_line_content": "                palette[i] = rgb_to_yuv(palette[i]);",
          "content_same": false
        },
        {
          "line": 6841,
          "old_api": null,
          "new_api": "mov_write_moov_tag",
          "old_text": null,
          "new_text": "mov_write_moov_tag(moov_buf, mov, s)",
          "old_line_content": "    MOVMuxContext *mov = s->priv_data;",
          "new_line_content": "    if ((ret = mov_write_moov_tag(moov_buf, mov, s)) < 0)",
          "content_same": false
        },
        {
          "line": 6331,
          "old_api": null,
          "new_api": "strncmp",
          "old_text": null,
          "new_text": "strncmp(\"size:\", cur, 5)",
          "old_line_content": "            for (i = 0; i < count; i++) {",
          "new_line_content": "        } else if (!strncmp(\"size:\", cur, 5)) {",
          "content_same": false
        },
        {
          "line": 6337,
          "old_api": null,
          "new_api": "strcspn",
          "old_text": null,
          "new_text": "strcspn(cur, \"\\n\\r\")",
          "old_line_content": "            have_size = 1;",
          "new_line_content": "        cur += strcspn(cur, \"\\n\\r\");",
          "content_same": false
        },
        {
          "line": 6338,
          "old_api": null,
          "new_api": "strspn",
          "old_text": null,
          "new_text": "strspn(cur, \"\\n\\r\")",
          "old_line_content": "        }",
          "new_line_content": "        cur += strspn(cur, \"\\n\\r\");",
          "content_same": false
        },
        {
          "line": 6852,
          "old_api": null,
          "new_api": "ffio_open_null_buf",
          "old_text": null,
          "new_text": "ffio_open_null_buf(&buf)",
          "old_line_content": "    int ret;",
          "new_line_content": "    if ((ret = ffio_open_null_buf(&buf)) < 0)",
          "content_same": false
        },
        {
          "line": 6854,
          "old_api": null,
          "new_api": "mov_write_sidx_tags",
          "old_text": null,
          "new_text": "mov_write_sidx_tags(buf, mov, -1, 0)",
          "old_line_content": "    MOVMuxContext *mov = s->priv_data;",
          "new_line_content": "    mov_write_sidx_tags(buf, mov, -1, 0);",
          "content_same": false
        },
        {
          "line": 6343,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    }",
          "new_line_content": "            return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 6855,
          "old_api": null,
          "new_api": "ffio_close_null_buf",
          "old_text": null,
          "new_text": "ffio_close_null_buf(buf)",
          "old_line_content": "",
          "new_line_content": "    return ffio_close_null_buf(buf);",
          "content_same": false
        },
        {
          "line": 6869,
          "old_api": null,
          "new_api": "get_moov_size",
          "old_text": null,
          "new_text": "get_moov_size(s)",
          "old_line_content": "{",
          "new_line_content": "    moov_size = get_moov_size(s);",
          "content_same": false
        },
        {
          "line": 6359,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(s->metadata, \"timecode\", NULL, 0)",
          "old_line_content": "",
          "new_line_content": "    AVDictionaryEntry *global_tcr = av_dict_get(s->metadata, \"timecode\", NULL, 0);",
          "content_same": false
        },
        {
          "line": 6876,
          "old_api": null,
          "new_api": "get_moov_size",
          "old_text": null,
          "new_text": "get_moov_size(s)",
          "old_line_content": "",
          "new_line_content": "    moov_size2 = get_moov_size(s);",
          "content_same": false
        },
        {
          "line": 6368,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(\"3gp\", s->oformat->name)",
          "old_line_content": "    /* Default mode == MP4 */",
          "new_line_content": "        if (!strcmp(\"3gp\", s->oformat->name)) mov->mode = MODE_3GP;",
          "content_same": false
        },
        {
          "line": 6369,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(\"3g2\", s->oformat->name)",
          "old_line_content": "    mov->mode = MODE_MP4;",
          "new_line_content": "        else if (!strcmp(\"3g2\", s->oformat->name)) mov->mode = MODE_3GP|MODE_3G2;",
          "content_same": false
        },
        {
          "line": 6370,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(\"mov\", s->oformat->name)",
          "old_line_content": "",
          "new_line_content": "        else if (!strcmp(\"mov\", s->oformat->name)) mov->mode = MODE_MOV;",
          "content_same": false
        },
        {
          "line": 6371,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(\"psp\", s->oformat->name)",
          "old_line_content": "    if (s->oformat) {",
          "new_line_content": "        else if (!strcmp(\"psp\", s->oformat->name)) mov->mode = MODE_PSP;",
          "content_same": false
        },
        {
          "line": 6894,
          "old_api": null,
          "new_api": "get_sidx_size",
          "old_text": null,
          "new_text": "get_sidx_size(s)",
          "old_line_content": "{",
          "new_line_content": "    sidx_size = get_sidx_size(s);",
          "content_same": false
        },
        {
          "line": 6401,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_VERBOSE, \"Empty MOOV enabled; disabling automatic bitstream filtering\\n\")",
          "old_line_content": "        mov->flags |= FF_MOV_FLAG_FRAGMENT | FF_MOV_FLAG_EMPTY_MOOV |",
          "new_line_content": "        av_log(s, AV_LOG_VERBOSE, \"Empty MOOV enabled; disabling automatic bitstream filtering\\n\");",
          "content_same": false
        },
        {
          "line": 6915,
          "old_api": null,
          "new_api": "compute_sidx_size",
          "old_text": null,
          "new_text": "compute_sidx_size(s)",
          "old_line_content": "    int read_size[2];",
          "new_line_content": "        moov_size = compute_sidx_size(s);",
          "content_same": false
        },
        {
          "line": 6917,
          "old_api": null,
          "new_api": "compute_moov_size",
          "old_text": null,
          "new_text": "compute_moov_size(s)",
          "old_line_content": "",
          "new_line_content": "        moov_size = compute_moov_size(s);",
          "content_same": false
        },
        {
          "line": 6406,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_WARNING, \"Global SIDX enabled; Ignoring skip_sidx option\\n\")",
          "old_line_content": "        s->flags &= ~AVFMT_FLAG_AUTO_BSF;",
          "new_line_content": "        av_log(s, AV_LOG_WARNING, \"Global SIDX enabled; Ignoring skip_sidx option\\n\");",
          "content_same": false
        },
        {
          "line": 6923,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "        return moov_size;",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 6930,
          "old_api": null,
          "new_api": "avio_flush",
          "old_text": null,
          "new_text": "avio_flush(s->pb)",
          "old_line_content": "",
          "new_line_content": "    avio_flush(s->pb);",
          "content_same": false
        },
        {
          "line": 6931,
          "old_api": null,
          "new_api": "io_open",
          "old_text": null,
          "new_text": "s->io_open(s, &read_pb, s->url, AVIO_FLAG_READ, NULL)",
          "old_line_content": "    /* Shift the data: the AVIO context of the output can only be used for",
          "new_line_content": "    ret = s->io_open(s, &read_pb, s->url, AVIO_FLAG_READ, NULL);",
          "content_same": false
        },
        {
          "line": 6933,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Unable to re-open %s output file for \"\n               \"the second pass (faststart)\\n\", s->url)",
          "old_line_content": "     * a read/seek/write/seek back and forth. */",
          "new_line_content": "        av_log(s, AV_LOG_ERROR, \"Unable to re-open %s output file for \"",
          "content_same": false
        },
        {
          "line": 6940,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(s->pb)",
          "old_line_content": "    }",
          "new_line_content": "    pos_end = avio_tell(s->pb);",
          "content_same": false
        },
        {
          "line": 6941,
          "old_api": null,
          "new_api": "avio_seek",
          "old_text": null,
          "new_text": "avio_seek(s->pb, mov->reserved_header_pos + moov_size, SEEK_SET)",
          "old_line_content": "",
          "new_line_content": "    avio_seek(s->pb, mov->reserved_header_pos + moov_size, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 6432,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_WARNING, \"No meaningful edit list will be written when using empty_moov without delay_moov\\n\")",
          "old_line_content": "        }",
          "new_line_content": "        av_log(s, AV_LOG_WARNING, \"No meaningful edit list will be written when using empty_moov without delay_moov\\n\");",
          "content_same": false
        },
        {
          "line": 6435,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_WARNING, \"Edit list enabled; Assuming writing CMAF Track File\\n\")",
          "old_line_content": "        !(mov->flags & FF_MOV_FLAG_DELAY_MOOV) && mov->use_editlist)",
          "new_line_content": "        av_log(s, AV_LOG_WARNING, \"Edit list enabled; Assuming writing CMAF Track File\\n\");",
          "content_same": false
        },
        {
          "line": 6960,
          "old_api": null,
          "new_api": "avio_write",
          "old_text": null,
          "new_text": "avio_write(s->pb, read_buf[read_buf_id], n)",
          "old_line_content": "        READ_BLOCK;",
          "new_line_content": "        avio_write(s->pb, read_buf[read_buf_id], n);",
          "content_same": false
        },
        {
          "line": 6451,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR,\n               \"Sample interleaving in fragments is mutually exclusive with \"\n               \"omit_tfhd_offset and separate_moof\\n\")",
          "old_line_content": "        mov->flags &= ~FF_MOV_FLAG_OMIT_TFHD_OFFSET;",
          "new_line_content": "        av_log(s, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 6963,
          "old_api": null,
          "new_api": "ff_format_io_close",
          "old_text": null,
          "new_text": "ff_format_io_close(s, &read_pb)",
          "old_line_content": "            break;",
          "new_line_content": "    ff_format_io_close(s, &read_pb);",
          "content_same": false
        },
        {
          "line": 6454,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "        mov->flags & (FF_MOV_FLAG_OMIT_TFHD_OFFSET | FF_MOV_FLAG_SEPARATE_MOOF)) {",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 6966,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(buf)",
          "old_line_content": "    } while (pos < pos_end);",
          "new_line_content": "    av_free(buf);",
          "content_same": false
        },
        {
          "line": 6461,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"muxer does not support non seekable output\\n\")",
          "old_line_content": "    /* Non-seekable output is ok if using fragmentation. If ism_lookahead",
          "new_line_content": "        av_log(s, AV_LOG_ERROR, \"muxer does not support non seekable output\\n\");",
          "content_same": false
        },
        {
          "line": 6462,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "     * is enabled, we don't support non-seekable output at all. */",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 6471,
          "old_api": null,
          "new_api": "rtp_hinting_needed",
          "old_text": null,
          "new_text": "rtp_hinting_needed(s->streams[i])",
          "old_line_content": "        mov->chapter_track = mov->nb_streams++;",
          "new_line_content": "            if (rtp_hinting_needed(s->streams[i]))",
          "content_same": false
        },
        {
          "line": 6984,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&track->vos_data)",
          "old_line_content": "            MOVTrack *track = &mov->tracks[i];",
          "new_line_content": "            av_freep(&track->vos_data);",
          "content_same": false
        },
        {
          "line": 6985,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(track->vos_len + AV_INPUT_BUFFER_PADDING_SIZE)",
          "old_line_content": "            AVCodecParameters *par = track->par;",
          "new_line_content": "            track->vos_data = av_malloc(track->vos_len + AV_INPUT_BUFFER_PADDING_SIZE);",
          "content_same": false
        },
        {
          "line": 6987,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "            track->vos_len  = par->extradata_size;",
          "new_line_content": "                return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 6482,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(st->metadata, \"timecode\", NULL, 0)",
          "old_line_content": "        for (i = 0; i < s->nb_streams; i++) {",
          "new_line_content": "                (t || (t=av_dict_get(st->metadata, \"timecode\", NULL, 0)))) {",
          "content_same": false
        },
        {
          "line": 6484,
          "old_api": null,
          "new_api": "mov_check_timecode_track",
          "old_text": null,
          "new_text": "mov_check_timecode_track(s, &tc, i, t->value)",
          "old_line_content": "            AVDictionaryEntry *t = global_tcr;",
          "new_line_content": "                ret = mov_check_timecode_track(s, &tc, i, t->value);",
          "content_same": false
        },
        {
          "line": 7002,
          "old_api": null,
          "new_api": "mov_write_subtitle_end_packet",
          "old_text": null,
          "new_text": "mov_write_subtitle_end_packet(s, i, trk->track_duration)",
          "old_line_content": "    for (i = 0; i < mov->nb_streams; i++) {",
          "new_line_content": "            mov_write_subtitle_end_packet(s, i, trk->track_duration);",
          "content_same": false
        },
        {
          "line": 6494,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('t','m','c','d')",
          "old_line_content": "        /* check if there is already a tmcd track to remux */",
          "new_line_content": "                if (st->codecpar->codec_tag == MKTAG('t','m','c','d')) {",
          "content_same": false
        },
        {
          "line": 6495,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_WARNING, \"You requested a copy of the original timecode track \"\n                           \"so timecode metadata are now ignored\\n\")",
          "old_line_content": "        if (mov->nb_meta_tmcd) {",
          "new_line_content": "                    av_log(s, AV_LOG_WARNING, \"You requested a copy of the original timecode track \"",
          "content_same": false
        },
        {
          "line": 7013,
          "old_api": null,
          "new_api": "mov_create_chapter_track",
          "old_text": null,
          "new_text": "mov_create_chapter_track(s, mov->chapter_track)",
          "old_line_content": "    // when we are not doing fragments.",
          "new_line_content": "            if ((res = mov_create_chapter_track(s, mov->chapter_track)) < 0)",
          "content_same": false
        },
        {
          "line": 6507,
          "old_api": null,
          "new_api": "av_mallocz_array",
          "old_text": null,
          "new_text": "av_mallocz_array((mov->nb_streams + 1), sizeof(*mov->tracks))",
          "old_line_content": "    }",
          "new_line_content": "    mov->tracks = av_mallocz_array((mov->nb_streams + 1), sizeof(*mov->tracks));",
          "content_same": false
        },
        {
          "line": 7019,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "        }",
          "new_line_content": "        moov_pos = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 6509,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    // Reserve an extra stream for chapters for the case where chapters",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 6512,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(mov->encryption_scheme_str, \"cenc-aes-ctr\")",
          "old_line_content": "    if (!mov->tracks)",
          "new_line_content": "        if (strcmp(mov->encryption_scheme_str, \"cenc-aes-ctr\") == 0) {",
          "content_same": false
        },
        {
          "line": 7024,
          "old_api": null,
          "new_api": "avio_wb32",
          "old_text": null,
          "new_text": "avio_wb32(pb, mov->mdat_size + 8)",
          "old_line_content": "",
          "new_line_content": "            avio_wb32(pb, mov->mdat_size + 8);",
          "content_same": false
        },
        {
          "line": 6518,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "",
          "new_line_content": "                return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 7030,
          "old_api": null,
          "new_api": "avio_wb32",
          "old_text": null,
          "new_text": "avio_wb32(pb, 1)",
          "old_line_content": "            /* overwrite 'wide' placeholder atom */",
          "new_line_content": "            avio_wb32(pb, 1);",
          "content_same": false
        },
        {
          "line": 7032,
          "old_api": null,
          "new_api": "avio_wb64",
          "old_text": null,
          "new_text": "avio_wb64(pb, mov->mdat_size + 16)",
          "old_line_content": "            /* special value: real atom size will be 64 bit value after",
          "new_line_content": "            avio_wb64(pb, mov->mdat_size + 16);",
          "content_same": false
        },
        {
          "line": 6524,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "",
          "new_line_content": "                return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 7037,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_INFO, \"Starting second pass: moving the moov atom to the beginning of the file\\n\")",
          "old_line_content": "        }",
          "new_line_content": "            av_log(s, AV_LOG_INFO, \"Starting second pass: moving the moov atom to the beginning of the file\\n\");",
          "content_same": false
        },
        {
          "line": 6527,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"unsupported encryption scheme %s\\n\",\n                mov->encryption_scheme_str)",
          "old_line_content": "                    mov->encryption_kid_len, CENC_KID_SIZE);",
          "new_line_content": "            av_log(s, AV_LOG_ERROR, \"unsupported encryption scheme %s\\n\",",
          "content_same": false
        },
        {
          "line": 6529,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "            }",
          "new_line_content": "            return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 6536,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(st->metadata, \"language\", NULL,0)",
          "old_line_content": "",
          "new_line_content": "        AVDictionaryEntry *lang = av_dict_get(st->metadata, \"language\", NULL,0);",
          "content_same": false
        },
        {
          "line": 7048,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "        } else if (mov->reserved_moov_size > 0) {",
          "new_line_content": "            size = mov->reserved_moov_size - (avio_tell(pb) - mov->reserved_header_pos);",
          "content_same": false
        },
        {
          "line": 7051,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "                return res;",
          "new_line_content": "                return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 7053,
          "old_api": null,
          "new_api": "avio_wb32",
          "old_text": null,
          "new_text": "avio_wb32(pb, size)",
          "old_line_content": "            if (size < 8){",
          "new_line_content": "            avio_wb32(pb, size);",
          "content_same": false
        },
        {
          "line": 7056,
          "old_api": null,
          "new_api": "avio_seek",
          "old_text": null,
          "new_text": "avio_seek(pb, moov_pos, SEEK_SET)",
          "old_line_content": "            }",
          "new_line_content": "            avio_seek(pb, moov_pos, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 6546,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Could not find tag for codec %s in stream #%d, \"\n                   \"codec not currently supported in container\\n\",\n                   avcodec_get_name(st->codecpar->codec_id), i)",
          "old_line_content": "            track->language = 32767;  // Unspecified Macintosh language code",
          "new_line_content": "            av_log(s, AV_LOG_ERROR, \"Could not find tag for codec %s in stream #%d, \"",
          "content_same": false
        },
        {
          "line": 6549,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "        if (!track->tag) {",
          "new_line_content": "            return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 7063,
          "old_api": null,
          "new_api": "mov_auto_flush_fragment",
          "old_text": null,
          "new_text": "mov_auto_flush_fragment(s, 1)",
          "old_line_content": "                return res;",
          "new_line_content": "        mov_auto_flush_fragment(s, 1);",
          "content_same": false
        },
        {
          "line": 7068,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_INFO, \"Starting second pass: inserting sidx atoms\\n\")",
          "old_line_content": "        for (i = 0; i < mov->nb_streams; i++)",
          "new_line_content": "            av_log(s, AV_LOG_INFO, \"Starting second pass: inserting sidx atoms\\n\");",
          "content_same": false
        },
        {
          "line": 7069,
          "old_api": null,
          "new_api": "shift_data",
          "old_text": null,
          "new_text": "shift_data(s)",
          "old_line_content": "           mov->tracks[i].data_offset = 0;",
          "new_line_content": "            res = shift_data(s);",
          "content_same": false
        },
        {
          "line": 6559,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('m','x','3','n')",
          "old_line_content": "        track->start_cts  = AV_NOPTS_VALUE;",
          "new_line_content": "            if (track->tag == MKTAG('m','x','3','p') || track->tag == MKTAG('m','x','3','n') ||",
          "content_same": false
        },
        {
          "line": 6560,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('m','x','4','n')",
          "old_line_content": "        track->end_pts    = AV_NOPTS_VALUE;",
          "new_line_content": "                track->tag == MKTAG('m','x','4','p') || track->tag == MKTAG('m','x','4','n') ||",
          "content_same": false
        },
        {
          "line": 6561,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('m','x','5','n')",
          "old_line_content": "        track->dts_shift  = AV_NOPTS_VALUE;",
          "new_line_content": "                track->tag == MKTAG('m','x','5','p') || track->tag == MKTAG('m','x','5','n')) {",
          "content_same": false
        },
        {
          "line": 7074,
          "old_api": null,
          "new_api": "mov_write_sidx_tags",
          "old_text": null,
          "new_text": "mov_write_sidx_tags(pb, mov, -1, 0)",
          "old_line_content": "            if (res < 0)",
          "new_line_content": "            mov_write_sidx_tags(pb, mov, -1, 0);",
          "content_same": false
        },
        {
          "line": 7075,
          "old_api": null,
          "new_api": "avio_seek",
          "old_text": null,
          "new_text": "avio_seek(pb, end, SEEK_SET)",
          "old_line_content": "                return res;",
          "new_line_content": "            avio_seek(pb, end, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 6571,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_WARNING, \"Warning: some tools, like mp4split, assume a timescale of 10000000 for ISMV.\\n\")",
          "old_line_content": "            }",
          "new_line_content": "                    av_log(s, AV_LOG_WARNING, \"Warning: some tools, like mp4split, assume a timescale of 10000000 for ISMV.\\n\");",
          "content_same": false
        },
        {
          "line": 6578,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Resolution %dx%d too large for mov/mp4\\n\", st->codecpar->width, st->codecpar->height)",
          "old_line_content": "                while(track->timescale < 10000)",
          "new_line_content": "                av_log(s, AV_LOG_ERROR, \"Resolution %dx%d too large for mov/mp4\\n\", st->codecpar->width, st->codecpar->height);",
          "content_same": false
        },
        {
          "line": 6579,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "                    track->timescale *= 2;",
          "new_line_content": "                return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 7094,
          "old_api": null,
          "new_api": "AV_RB16",
          "old_text": null,
          "new_text": "AV_RB16(pkt->data)",
          "old_line_content": "    int ret = 1;",
          "new_line_content": "        if (pkt->size > 2 && (AV_RB16(pkt->data) & 0xfff0) == 0xfff0)",
          "content_same": false
        },
        {
          "line": 7095,
          "old_api": null,
          "new_api": "ff_stream_add_bitstream_filter",
          "old_text": null,
          "new_text": "ff_stream_add_bitstream_filter(st, \"aac_adtstoasc\", NULL)",
          "old_line_content": "    AVStream *st = s->streams[pkt->stream_index];",
          "new_line_content": "            ret = ff_stream_add_bitstream_filter(st, \"aac_adtstoasc\", NULL);",
          "content_same": false
        },
        {
          "line": 7097,
          "old_api": null,
          "new_api": "ff_stream_add_bitstream_filter",
          "old_text": null,
          "new_text": "ff_stream_add_bitstream_filter(st, \"vp9_superframe\", NULL)",
          "old_line_content": "    if (st->codecpar->codec_id == AV_CODEC_ID_AAC) {",
          "new_line_content": "        ret = ff_stream_add_bitstream_filter(st, \"vp9_superframe\", NULL);",
          "content_same": false
        },
        {
          "line": 6588,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('r','a','w',' ')",
          "old_line_content": "                       \"file may not be playable by quicktime. Specify a shorter timebase\\n\"",
          "new_line_content": "                track->tag == MKTAG('r','a','w',' ')) {",
          "content_same": false
        },
        {
          "line": 7104,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('s','2','6','3')",
          "old_line_content": "    return ret;",
          "new_line_content": "    { AV_CODEC_ID_H263,     MKTAG('s','2','6','3') },",
          "content_same": false
        },
        {
          "line": 7105,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('a','v','c','1')",
          "old_line_content": "}",
          "new_line_content": "    { AV_CODEC_ID_H264,     MKTAG('a','v','c','1') },",
          "content_same": false
        },
        {
          "line": 7106,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('m','p','4','v')",
          "old_line_content": "",
          "new_line_content": "    { AV_CODEC_ID_MPEG4,    MKTAG('m','p','4','v') },",
          "content_same": false
        },
        {
          "line": 7107,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('m','p','4','a')",
          "old_line_content": "static const AVCodecTag codec_3gp_tags[] = {",
          "new_line_content": "    { AV_CODEC_ID_AAC,      MKTAG('m','p','4','a') },",
          "content_same": false
        },
        {
          "line": 6603,
          "old_api": null,
          "new_api": "avcodec_get_name",
          "old_text": null,
          "new_text": "avcodec_get_name(track->par->codec_id)",
          "old_line_content": "            }",
          "new_line_content": "                    av_log(s, AV_LOG_ERROR, \"%s only supported in MP4.\\n\", avcodec_get_name(track->par->codec_id));",
          "content_same": false
        },
        {
          "line": 6604,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "            if (track->par->codec_id == AV_CODEC_ID_VP9 ||",
          "new_line_content": "                    return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 7115,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('m', 'p', '4', 'v')",
          "old_line_content": "    { AV_CODEC_ID_NONE, 0 },",
          "new_line_content": "    { AV_CODEC_ID_MPEG4,           MKTAG('m', 'p', '4', 'v') },",
          "content_same": false
        },
        {
          "line": 7116,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('a', 'v', 'c', '1')",
          "old_line_content": "};",
          "new_line_content": "    { AV_CODEC_ID_H264,            MKTAG('a', 'v', 'c', '1') },",
          "content_same": false
        },
        {
          "line": 7117,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('a', 'v', 'c', '3')",
          "old_line_content": "",
          "new_line_content": "    { AV_CODEC_ID_H264,            MKTAG('a', 'v', 'c', '3') },",
          "content_same": false
        },
        {
          "line": 7118,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('h', 'e', 'v', '1')",
          "old_line_content": "static const AVCodecTag codec_mp4_tags[] = {",
          "new_line_content": "    { AV_CODEC_ID_HEVC,            MKTAG('h', 'e', 'v', '1') },",
          "content_same": false
        },
        {
          "line": 6609,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"VP8 muxing is currently not supported.\\n\")",
          "old_line_content": "                }",
          "new_line_content": "                av_log(s, AV_LOG_ERROR, \"VP8 muxing is currently not supported.\\n\");",
          "content_same": false
        },
        {
          "line": 6614,
          "old_api": null,
          "new_api": "av_get_bits_per_sample",
          "old_text": null,
          "new_text": "av_get_bits_per_sample(st->codecpar->codec_id)",
          "old_line_content": "                return AVERROR_PATCHWELCOME;",
          "new_line_content": "            if (!st->codecpar->frame_size && !av_get_bits_per_sample(st->codecpar->codec_id)) {",
          "content_same": false
        },
        {
          "line": 6615,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_WARNING, \"track %d: codec frame size is not set\\n\", i)",
          "old_line_content": "            }",
          "new_line_content": "                av_log(s, AV_LOG_WARNING, \"track %d: codec frame size is not set\\n\", i);",
          "content_same": false
        },
        {
          "line": 6621,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"track %d: codec block align is not set for adpcm\\n\", i)",
          "old_line_content": "            }else if (st->codecpar->codec_id == AV_CODEC_ID_ADPCM_MS ||",
          "new_line_content": "                    av_log(s, AV_LOG_ERROR, \"track %d: codec block align is not set for adpcm\\n\", i);",
          "content_same": false
        },
        {
          "line": 6622,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "                     st->codecpar->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||",
          "new_line_content": "                    return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 6628,
          "old_api": null,
          "new_api": "av_get_bits_per_sample",
          "old_text": null,
          "new_text": "av_get_bits_per_sample(st->codecpar->codec_id)",
          "old_line_content": "                track->sample_size = st->codecpar->block_align;",
          "new_line_content": "                track->sample_size = (av_get_bits_per_sample(st->codecpar->codec_id) >> 3) * st->codecpar->channels;",
          "content_same": false
        },
        {
          "line": 6637,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"track %d: muxing mp3 at %dhz is not standard, to mux anyway set strict to -1\\n\",\n                        i, track->par->sample_rate)",
          "old_line_content": "            }",
          "new_line_content": "                    av_log(s, AV_LOG_ERROR, \"track %d: muxing mp3 at %dhz is not standard, to mux anyway set strict to -1\\n\",",
          "content_same": false
        },
        {
          "line": 6639,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "                track->par->codec_id == AV_CODEC_ID_MP3 && track->timescale < 16000) {",
          "new_line_content": "                    return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 7151,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('w', 'm', 'a', ' ')",
          "old_line_content": "    { AV_CODEC_ID_NONE,               0 },",
          "new_line_content": "    { AV_CODEC_ID_WMAPRO      , MKTAG('w', 'm', 'a', ' ') },",
          "content_same": false
        },
        {
          "line": 7156,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('a','v','c','1')",
          "old_line_content": "    { AV_CODEC_ID_NONE        ,    0 },",
          "new_line_content": "    { AV_CODEC_ID_H264,     MKTAG('a','v','c','1') },",
          "content_same": false
        },
        {
          "line": 7157,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('m','p','4','v')",
          "old_line_content": "};",
          "new_line_content": "    { AV_CODEC_ID_MPEG4,    MKTAG('m','p','4','v') },",
          "content_same": false
        },
        {
          "line": 7158,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('m','p','4','a')",
          "old_line_content": "",
          "new_line_content": "    { AV_CODEC_ID_AAC,      MKTAG('m','p','4','a') },",
          "content_same": false
        },
        {
          "line": 7159,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('a','l','a','c')",
          "old_line_content": "static const AVCodecTag codec_ipod_tags[] = {",
          "new_line_content": "    { AV_CODEC_ID_ALAC,     MKTAG('a','l','a','c') },",
          "content_same": false
        },
        {
          "line": 6649,
          "old_api": null,
          "new_api": "avcodec_get_name",
          "old_text": null,
          "new_text": "avcodec_get_name(track->par->codec_id)",
          "old_line_content": "            if (track->par->codec_id == AV_CODEC_ID_FLAC ||",
          "new_line_content": "                    av_log(s, AV_LOG_ERROR, \"%s only supported in MP4.\\n\", avcodec_get_name(track->par->codec_id));",
          "content_same": false
        },
        {
          "line": 6650,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "                track->par->codec_id == AV_CODEC_ID_TRUEHD ||",
          "new_line_content": "                    return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 7167,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('.','m','p','3')",
          "old_line_content": "    { AV_CODEC_ID_NONE, 0 },",
          "new_line_content": "    { AV_CODEC_ID_MP3,    MKTAG('.','m','p','3') },",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 6658,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR,\n                           \"%s in MP4 support is experimental, add \"\n                           \"'-strict %d' if you want to use it.\\n\",\n                           avcodec_get_name(track->par->codec_id), FF_COMPLIANCE_EXPERIMENTAL)",
          "new_text": null,
          "old_line_content": "                    av_log(s, AV_LOG_ERROR,",
          "new_line_content": "                    return AVERROR_EXPERIMENTAL;",
          "content_same": false
        },
        {
          "line": 7172,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('m','p','4','a')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_AAC,    MKTAG('m','p','4','a') },",
          "new_line_content": "    { AV_CODEC_ID_NONE, 0 },",
          "content_same": false
        },
        {
          "line": 6661,
          "old_api": "avcodec_get_name",
          "new_api": null,
          "old_text": "avcodec_get_name(track->par->codec_id)",
          "new_text": null,
          "old_line_content": "                           avcodec_get_name(track->par->codec_id), FF_COMPLIANCE_EXPERIMENTAL);",
          "new_line_content": "        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE) {",
          "content_same": false
        },
        {
          "line": 7173,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('a','v','c','1')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_H264,   MKTAG('a','v','c','1') },",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 7174,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('V','P','6','A')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_VP6A,   MKTAG('V','P','6','A') },",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7175,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('V','P','6','F')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_VP6F,   MKTAG('V','P','6','F') },",
          "new_line_content": "#if CONFIG_MOV_MUXER",
          "content_same": false
        },
        {
          "line": 7180,
          "old_api": "MOV_CLASS",
          "new_api": null,
          "old_text": "MOV_CLASS(mov)",
          "new_text": null,
          "old_line_content": "MOV_CLASS(mov)",
          "new_line_content": "    .extensions        = \"mov\",",
          "content_same": false
        },
        {
          "line": 7183,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"QuickTime / MOV\")",
          "new_text": null,
          "old_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"QuickTime / MOV\"),",
          "new_line_content": "    .video_codec       = CONFIG_LIBX264_ENCODER ?",
          "content_same": false
        },
        {
          "line": 6683,
          "old_api": "avpriv_set_pts_info",
          "new_api": null,
          "old_text": "avpriv_set_pts_info(st, 64, 1, track->timescale)",
          "new_text": null,
          "old_line_content": "        avpriv_set_pts_info(st, 64, 1, track->timescale);",
          "new_line_content": "                track->par->codec_id == AV_CODEC_ID_H264, s->flags & AVFMT_FLAG_BITEXACT);",
          "content_same": false
        },
        {
          "line": 6173,
          "old_api": "find_fps",
          "new_api": null,
          "old_text": "find_fps(s, src_st)",
          "new_text": null,
          "old_line_content": "    AVRational rate = find_fps(s, src_st);",
          "new_line_content": "                        .flags = AV_PKT_FLAG_KEY, .size = 4 };",
          "content_same": false
        },
        {
          "line": 6686,
          "old_api": "ff_mov_cenc_init",
          "new_api": null,
          "old_text": "ff_mov_cenc_init(&track->cenc, mov->encryption_key,\n                track->par->codec_id == AV_CODEC_ID_H264, s->flags & AVFMT_FLAG_BITEXACT)",
          "new_text": null,
          "old_line_content": "            ret = ff_mov_cenc_init(&track->cenc, mov->encryption_key,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 6177,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('t','m','c','d')",
          "new_text": null,
          "old_line_content": "    track->tag       = MKTAG('t','m','c','d');",
          "new_line_content": "    track->mode      = mov->mode;",
          "content_same": false
        },
        {
          "line": 7203,
          "old_api": "MOV_CLASS",
          "new_api": null,
          "old_text": "MOV_CLASS(tgp)",
          "new_text": null,
          "old_line_content": "MOV_CLASS(tgp)",
          "new_line_content": "    .extensions        = \"3gp\",",
          "content_same": false
        },
        {
          "line": 6693,
          "old_api": "enable_tracks",
          "new_api": null,
          "old_text": "enable_tracks(s)",
          "new_text": null,
          "old_line_content": "    enable_tracks(s);",
          "new_line_content": "static int mov_write_header(AVFormatContext *s)",
          "content_same": false
        },
        {
          "line": 7206,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"3GP (3GPP file format)\")",
          "new_text": null,
          "old_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"3GP (3GPP file format)\"),",
          "new_line_content": "    .video_codec       = AV_CODEC_ID_H263,",
          "content_same": false
        },
        {
          "line": 6187,
          "old_api": "avcodec_parameters_alloc",
          "new_api": null,
          "old_text": "avcodec_parameters_alloc()",
          "new_text": null,
          "old_line_content": "    track->par = avcodec_parameters_alloc();",
          "new_line_content": "    /* encode context: tmcd data stream */",
          "content_same": false
        },
        {
          "line": 6189,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "    if (!track->par)",
          "content_same": false
        },
        {
          "line": 6701,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(s->metadata, \"timecode\", NULL, 0)",
          "new_text": null,
          "old_line_content": "    AVDictionaryEntry *t, *global_tcr = av_dict_get(s->metadata, \"timecode\", NULL, 0);",
          "new_line_content": "        nb_tracks++;",
          "content_same": false
        },
        {
          "line": 6192,
          "old_api": "av_inv_q",
          "new_api": null,
          "old_text": "av_inv_q(rate)",
          "new_text": null,
          "old_line_content": "    track->st->avg_frame_rate = av_inv_q(rate);",
          "new_line_content": "    track->par->codec_tag  = track->tag;",
          "content_same": false
        },
        {
          "line": 6195,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(pkt.size)",
          "new_text": null,
          "old_line_content": "    pkt.data = av_malloc(pkt.size);",
          "new_line_content": "    /* the tmcd track just contains one packet with the frame number */",
          "content_same": false
        },
        {
          "line": 6198,
          "old_api": "AV_WB32",
          "new_api": null,
          "old_text": "AV_WB32(pkt.data, tc.start)",
          "new_text": null,
          "old_line_content": "    AV_WB32(pkt.data, tc.start);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 6199,
          "old_api": "ff_mov_write_packet",
          "new_api": null,
          "old_text": "ff_mov_write_packet(s, &pkt)",
          "new_text": null,
          "old_line_content": "    ret = ff_mov_write_packet(s, &pkt);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6200,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(pkt.data)",
          "new_text": null,
          "old_line_content": "    av_free(pkt.data);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 6710,
          "old_api": "rtp_hinting_needed",
          "new_api": null,
          "old_text": "rtp_hinting_needed(s->streams[i])",
          "new_text": null,
          "old_line_content": "            if (rtp_hinting_needed(s->streams[i]))",
          "new_line_content": "    if (mov->nb_meta_tmcd)",
          "content_same": false
        },
        {
          "line": 7223,
          "old_api": "MOV_CLASS",
          "new_api": null,
          "old_text": "MOV_CLASS(mp4)",
          "new_text": null,
          "old_line_content": "MOV_CLASS(mp4)",
          "new_line_content": "    .mime_type         = \"video/mp4\",",
          "content_same": false
        },
        {
          "line": 7226,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"MP4 (MPEG-4 Part 14)\")",
          "new_text": null,
          "old_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"MP4 (MPEG-4 Part 14)\"),",
          "new_line_content": "    .audio_codec       = AV_CODEC_ID_AAC,",
          "content_same": false
        },
        {
          "line": 6725,
          "old_api": "mov_create_dvd_sub_decoder_specific_info",
          "new_api": null,
          "old_text": "mov_create_dvd_sub_decoder_specific_info(track, st)",
          "new_text": null,
          "old_line_content": "                mov_create_dvd_sub_decoder_specific_info(track, st);",
          "new_line_content": "                if (!track->vos_data) {",
          "content_same": false
        },
        {
          "line": 6730,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "                    return AVERROR(ENOMEM);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 6732,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(track->vos_data, st->codecpar->extradata, track->vos_len)",
          "new_text": null,
          "old_line_content": "                memcpy(track->vos_data, st->codecpar->extradata, track->vos_len);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6733,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(track->vos_data + track->vos_len, 0, AV_INPUT_BUFFER_PADDING_SIZE)",
          "new_text": null,
          "old_line_content": "                memset(track->vos_data + track->vos_len, 0, AV_INPUT_BUFFER_PADDING_SIZE);",
          "new_line_content": "        if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO ||",
          "content_same": false
        },
        {
          "line": 7245,
          "old_api": "MOV_CLASS",
          "new_api": null,
          "old_text": "MOV_CLASS(psp)",
          "new_text": null,
          "old_line_content": "MOV_CLASS(psp)",
          "new_line_content": "    .extensions        = \"mp4,psp\",",
          "content_same": false
        },
        {
          "line": 7248,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"PSP MP4 (MPEG-4 Part 14)\")",
          "new_text": null,
          "old_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"PSP MP4 (MPEG-4 Part 14)\"),",
          "new_line_content": "    .video_codec       = CONFIG_LIBX264_ENCODER ?",
          "content_same": false
        },
        {
          "line": 6232,
          "old_api": "is_cover_image",
          "new_api": null,
          "old_text": "is_cover_image(st)",
          "new_text": null,
          "old_line_content": "            is_cover_image(st))",
          "new_line_content": "            first[st->codecpar->codec_type] = i;",
          "content_same": false
        },
        {
          "line": 7266,
          "old_api": "MOV_CLASS",
          "new_api": null,
          "old_text": "MOV_CLASS(tg2)",
          "new_text": null,
          "old_line_content": "MOV_CLASS(tg2)",
          "new_line_content": "    .extensions        = \"3g2\",",
          "content_same": false
        },
        {
          "line": 7269,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"3GP2 (3GPP2 file format)\")",
          "new_text": null,
          "old_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"3GP2 (3GPP2 file format)\"),",
          "new_line_content": "    .video_codec       = AV_CODEC_ID_H263,",
          "content_same": false
        },
        {
          "line": 6758,
          "old_api": "mov_write_identification",
          "new_api": null,
          "old_text": "mov_write_identification(pb, s)",
          "new_text": null,
          "old_line_content": "        if ((ret = mov_write_identification(pb, s)) < 0)",
          "new_line_content": "    if (mov->reserved_moov_size){",
          "content_same": false
        },
        {
          "line": 6763,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "        mov->reserved_header_pos = avio_tell(pb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6765,
          "old_api": "avio_skip",
          "new_api": null,
          "old_text": "avio_skip(pb, mov->reserved_moov_size)",
          "new_text": null,
          "old_line_content": "            avio_skip(pb, mov->reserved_moov_size);",
          "new_line_content": "        /* If no fragmentation options have been set, set a default. */",
          "content_same": false
        },
        {
          "line": 7286,
          "old_api": "MOV_CLASS",
          "new_api": null,
          "old_text": "MOV_CLASS(ipod)",
          "new_text": null,
          "old_line_content": "MOV_CLASS(ipod)",
          "new_line_content": "    .mime_type         = \"video/mp4\",",
          "content_same": false
        },
        {
          "line": 7289,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"iPod H.264 MP4 (MPEG-4 Part 14)\")",
          "new_text": null,
          "old_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"iPod H.264 MP4 (MPEG-4 Part 14)\"),",
          "new_line_content": "    .audio_codec       = AV_CODEC_ID_AAC,",
          "content_same": false
        },
        {
          "line": 6778,
          "old_api": "mov_write_mdat_tag",
          "new_api": null,
          "old_text": "mov_write_mdat_tag(pb, mov)",
          "new_text": null,
          "old_line_content": "        mov_write_mdat_tag(pb, mov);",
          "new_line_content": "    if (mov->time)",
          "content_same": false
        },
        {
          "line": 6781,
          "old_api": "ff_parse_creation_time_metadata",
          "new_api": null,
          "old_text": "ff_parse_creation_time_metadata(s, &mov->time, 1)",
          "new_text": null,
          "old_line_content": "    ff_parse_creation_time_metadata(s, &mov->time, 1);",
          "new_line_content": "    if (mov->chapter_track)",
          "content_same": false
        },
        {
          "line": 6273,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&mov->tracks[i].par)",
          "new_text": null,
          "old_line_content": "            av_freep(&mov->tracks[i].par);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6274,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&mov->tracks[i].cluster)",
          "new_text": null,
          "old_line_content": "        av_freep(&mov->tracks[i].cluster);",
          "new_line_content": "        if (mov->tracks[i].eac3_priv) {",
          "content_same": false
        },
        {
          "line": 6275,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&mov->tracks[i].frag_info)",
          "new_text": null,
          "old_line_content": "        av_freep(&mov->tracks[i].frag_info);",
          "new_line_content": "            struct eac3_info *info = mov->tracks[i].eac3_priv;",
          "content_same": false
        },
        {
          "line": 6786,
          "old_api": "mov_create_chapter_track",
          "new_api": null,
          "old_text": "mov_create_chapter_track(s, mov->chapter_track)",
          "new_text": null,
          "old_line_content": "        if ((ret = mov_create_chapter_track(s, mov->chapter_track)) < 0)",
          "new_line_content": "        for (i = 0; i < s->nb_streams; i++) {",
          "content_same": false
        },
        {
          "line": 6791,
          "old_api": "rtp_hinting_needed",
          "new_api": null,
          "old_text": "rtp_hinting_needed(s->streams[i])",
          "new_text": null,
          "old_line_content": "            if (rtp_hinting_needed(s->streams[i])) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 6792,
          "old_api": "ff_mov_init_hinting",
          "new_api": null,
          "old_text": "ff_mov_init_hinting(s, hint_track, i)",
          "new_text": null,
          "old_line_content": "                if ((ret = ff_mov_init_hinting(s, hint_track, i)) < 0)",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 6281,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&mov->tracks[i].eac3_priv)",
          "new_text": null,
          "old_line_content": "            av_freep(&mov->tracks[i].eac3_priv);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7307,
          "old_api": "MOV_CLASS",
          "new_api": null,
          "old_text": "MOV_CLASS(ismv)",
          "new_text": null,
          "old_line_content": "MOV_CLASS(ismv)",
          "new_line_content": "    .mime_type         = \"video/mp4\",",
          "content_same": false
        },
        {
          "line": 6284,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&mov->tracks[i].vos_data)",
          "new_text": null,
          "old_line_content": "            av_freep(&mov->tracks[i].vos_data);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 7310,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"ISMV/ISMA (Smooth Streaming)\")",
          "new_text": null,
          "old_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"ISMV/ISMA (Smooth Streaming)\"),",
          "new_line_content": "    .audio_codec       = AV_CODEC_ID_AAC,",
          "content_same": false
        },
        {
          "line": 6290,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&mov->tracks)",
          "new_text": null,
          "old_line_content": "    av_freep(&mov->tracks);",
          "new_line_content": "static uint32_t rgb_to_yuv(uint32_t rgb)",
          "content_same": false
        },
        {
          "line": 6291,
          "old_api": "ffio_free_dyn_buf",
          "new_api": null,
          "old_text": "ffio_free_dyn_buf(&mov->mdat_buf)",
          "new_text": null,
          "old_line_content": "    ffio_free_dyn_buf(&mov->mdat_buf);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 6808,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(st->metadata, \"timecode\", NULL, 0)",
          "new_text": null,
          "old_line_content": "                    t = av_dict_get(st->metadata, \"timecode\", NULL, 0);",
          "new_line_content": "                    continue;",
          "content_same": false
        },
        {
          "line": 6811,
          "old_api": "mov_check_timecode_track",
          "new_api": null,
          "old_text": "mov_check_timecode_track(s, &tc, i, t->value)",
          "new_text": null,
          "old_line_content": "                if (mov_check_timecode_track(s, &tc, i, t->value) < 0)",
          "new_line_content": "                tmcd_track++;",
          "content_same": false
        },
        {
          "line": 6813,
          "old_api": "mov_create_timecode_track",
          "new_api": null,
          "old_text": "mov_create_timecode_track(s, tmcd_track, i, tc)",
          "new_text": null,
          "old_line_content": "                if ((ret = mov_create_timecode_track(s, tmcd_track, i, tc)) < 0)",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 6303,
          "old_api": "av_clip_uint8",
          "new_api": null,
          "old_text": "av_clip_uint8(( 16000 +  257 * r + 504 * g +  98 * b)/1000)",
          "new_text": null,
          "old_line_content": "    y  = av_clip_uint8(( 16000 +  257 * r + 504 * g +  98 * b)/1000);",
          "new_line_content": "    return (y << 16) | (cr << 8) | cb;",
          "content_same": false
        },
        {
          "line": 6304,
          "old_api": "av_clip_uint8",
          "new_api": null,
          "old_text": "av_clip_uint8((128000 -  148 * r - 291 * g + 439 * b)/1000)",
          "new_text": null,
          "old_line_content": "    cb = av_clip_uint8((128000 -  148 * r - 291 * g + 439 * b)/1000);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 6305,
          "old_api": "av_clip_uint8",
          "new_api": null,
          "old_text": "av_clip_uint8((128000 +  439 * r - 368 * g -  71 * b)/1000)",
          "new_text": null,
          "old_line_content": "    cr = av_clip_uint8((128000 +  439 * r - 368 * g -  71 * b)/1000);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7329,
          "old_api": "MOV_CLASS",
          "new_api": null,
          "old_text": "MOV_CLASS(f4v)",
          "new_text": null,
          "old_line_content": "MOV_CLASS(f4v)",
          "new_line_content": "    .mime_type         = \"application/f4v\",",
          "content_same": false
        },
        {
          "line": 6820,
          "old_api": "avio_flush",
          "new_api": null,
          "old_text": "avio_flush(pb)",
          "new_text": null,
          "old_line_content": "    avio_flush(pb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7332,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"F4V Adobe Flash Video\")",
          "new_text": null,
          "old_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"F4V Adobe Flash Video\"),",
          "new_line_content": "    .audio_codec       = AV_CODEC_ID_AAC,",
          "content_same": false
        },
        {
          "line": 6319,
          "old_api": "strncmp",
          "new_api": null,
          "old_text": "strncmp(\"palette:\", cur, 8)",
          "new_text": null,
          "old_line_content": "        if (strncmp(\"palette:\", cur, 8) == 0) {",
          "new_line_content": "                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", \"",
          "content_same": false
        },
        {
          "line": 6831,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "            mov->reserved_header_pos = avio_tell(pb);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 6321,
          "old_api": "sscanf",
          "new_api": null,
          "old_text": "sscanf(cur + 8,\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", \"\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", \"\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", \"\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\"\",\n                &palette[ 0], &palette[ 1], &palette[ 2], &palette[ 3],\n                &palette[ 4], &palette[ 5], &palette[ 6], &palette[ 7],\n                &palette[ 8], &palette[ 9], &palette[10], &palette[11],\n                &palette[12], &palette[13], &palette[14], &palette[15])",
          "new_text": null,
          "old_line_content": "            count = sscanf(cur + 8,",
          "new_line_content": "                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\"\",",
          "content_same": false
        },
        {
          "line": 6845,
          "old_api": "mov_write_moov_tag",
          "new_api": null,
          "old_text": "mov_write_moov_tag(moov_buf, mov, s)",
          "new_text": null,
          "old_line_content": "    if ((ret = mov_write_moov_tag(moov_buf, mov, s)) < 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6335,
          "old_api": "strncmp",
          "new_api": null,
          "old_text": "strncmp(\"size:\", cur, 5)",
          "new_text": null,
          "old_line_content": "        } else if (!strncmp(\"size:\", cur, 5)) {",
          "new_line_content": "        if (have_palette && have_size)",
          "content_same": false
        },
        {
          "line": 6336,
          "old_api": "sscanf",
          "new_api": null,
          "old_text": "sscanf(cur + 5, \"%dx%d\", &width, &height)",
          "new_text": null,
          "old_line_content": "            sscanf(cur + 5, \"%dx%d\", &width, &height);",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 6847,
          "old_api": "ffio_close_null_buf",
          "new_api": null,
          "old_text": "ffio_close_null_buf(moov_buf)",
          "new_text": null,
          "old_line_content": "    return ffio_close_null_buf(moov_buf);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 6342,
          "old_api": "strspn",
          "new_api": null,
          "old_text": "strspn(cur, \"\\n\\r\")",
          "new_text": null,
          "old_line_content": "        cur += strspn(cur, \"\\n\\r\");",
          "new_line_content": "        if (!track->vos_data)",
          "content_same": false
        },
        {
          "line": 6856,
          "old_api": "ffio_open_null_buf",
          "new_api": null,
          "old_text": "ffio_open_null_buf(&buf)",
          "new_text": null,
          "old_line_content": "    if ((ret = ffio_open_null_buf(&buf)) < 0)",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 6858,
          "old_api": "mov_write_sidx_tags",
          "new_api": null,
          "old_text": "mov_write_sidx_tags(buf, mov, -1, 0)",
          "new_text": null,
          "old_line_content": "    mov_write_sidx_tags(buf, mov, -1, 0);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 6859,
          "old_api": "ffio_close_null_buf",
          "new_api": null,
          "old_text": "ffio_close_null_buf(buf)",
          "new_text": null,
          "old_line_content": "    return ffio_close_null_buf(buf);",
          "new_line_content": " * This function gets the moov size if moved to the top of the file: the chunk",
          "content_same": false
        },
        {
          "line": 6349,
          "old_api": "AV_WB32",
          "new_api": null,
          "old_text": "AV_WB32(track->vos_data + i * 4, palette[i])",
          "new_text": null,
          "old_line_content": "            AV_WB32(track->vos_data + i * 4, palette[i]);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 6351,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(track->vos_data + 16*4, 0, AV_INPUT_BUFFER_PADDING_SIZE)",
          "new_text": null,
          "old_line_content": "        memset(track->vos_data + 16*4, 0, AV_INPUT_BUFFER_PADDING_SIZE);",
          "new_line_content": "    st->codecpar->height = track->height = height;",
          "content_same": false
        },
        {
          "line": 7165,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('t','x','3','g')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_MOV_TEXT, MKTAG('t','x','3','g') },",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6873,
          "old_api": "get_moov_size",
          "new_api": null,
          "old_text": "get_moov_size(s)",
          "new_text": null,
          "old_line_content": "    moov_size = get_moov_size(s);",
          "new_line_content": "    for (i = 0; i < mov->nb_streams; i++)",
          "content_same": false
        },
        {
          "line": 6363,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(s->metadata, \"timecode\", NULL, 0)",
          "new_text": null,
          "old_line_content": "    AVDictionaryEntry *global_tcr = av_dict_get(s->metadata, \"timecode\", NULL, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6880,
          "old_api": "get_moov_size",
          "new_api": null,
          "old_text": "get_moov_size(s)",
          "new_text": null,
          "old_line_content": "    moov_size2 = get_moov_size(s);",
          "new_line_content": "    /* if the size changed, we just switched from stco to co64 and need to",
          "content_same": false
        },
        {
          "line": 6375,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(\"psp\", s->oformat->name)",
          "new_text": null,
          "old_line_content": "        else if (!strcmp(\"psp\", s->oformat->name)) mov->mode = MODE_PSP;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 6376,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(\"ipod\",s->oformat->name)",
          "new_text": null,
          "old_line_content": "        else if (!strcmp(\"ipod\",s->oformat->name)) mov->mode = MODE_IPOD;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6377,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(\"ismv\",s->oformat->name)",
          "new_text": null,
          "old_line_content": "        else if (!strcmp(\"ismv\",s->oformat->name)) mov->mode = MODE_ISM;",
          "new_line_content": "    if (mov->flags & FF_MOV_FLAG_DELAY_MOOV)",
          "content_same": false
        },
        {
          "line": 6378,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(\"f4v\", s->oformat->name)",
          "new_text": null,
          "old_line_content": "        else if (!strcmp(\"f4v\", s->oformat->name)) mov->mode = MODE_F4V;",
          "new_line_content": "        mov->flags |= FF_MOV_FLAG_EMPTY_MOOV;",
          "content_same": false
        },
        {
          "line": 6898,
          "old_api": "get_sidx_size",
          "new_api": null,
          "old_text": "get_sidx_size(s)",
          "new_text": null,
          "old_line_content": "    sidx_size = get_sidx_size(s);",
          "new_line_content": "    for (i = 0; i < mov->nb_streams; i++)",
          "content_same": false
        },
        {
          "line": 6405,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_VERBOSE, \"Empty MOOV enabled; disabling automatic bitstream filtering\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_VERBOSE, \"Empty MOOV enabled; disabling automatic bitstream filtering\\n\");",
          "new_line_content": "    if (mov->flags & FF_MOV_FLAG_GLOBAL_SIDX && mov->flags & FF_MOV_FLAG_SKIP_SIDX) {",
          "content_same": false
        },
        {
          "line": 6919,
          "old_api": "compute_sidx_size",
          "new_api": null,
          "old_text": "compute_sidx_size(s)",
          "new_text": null,
          "old_line_content": "        moov_size = compute_sidx_size(s);",
          "new_line_content": "        return moov_size;",
          "content_same": false
        },
        {
          "line": 6410,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_WARNING, \"Global SIDX enabled; Ignoring skip_sidx option\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_WARNING, \"Global SIDX enabled; Ignoring skip_sidx option\\n\");",
          "new_line_content": "    if (mov->flags & FF_MOV_FLAG_FASTSTART) {",
          "content_same": false
        },
        {
          "line": 6925,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(moov_size * 2)",
          "new_text": null,
          "old_line_content": "    buf = av_malloc(moov_size * 2);",
          "new_line_content": "    read_buf[1] = buf + moov_size;",
          "content_same": false
        },
        {
          "line": 6927,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "    /* Shift the data: the AVIO context of the output can only be used for",
          "content_same": false
        },
        {
          "line": 6934,
          "old_api": "avio_flush",
          "new_api": null,
          "old_text": "avio_flush(s->pb)",
          "new_text": null,
          "old_line_content": "    avio_flush(s->pb);",
          "new_line_content": "               \"the second pass (faststart)\\n\", s->url);",
          "content_same": false
        },
        {
          "line": 6935,
          "old_api": "io_open",
          "new_api": null,
          "old_text": "s->io_open(s, &read_pb, s->url, AVIO_FLAG_READ, NULL)",
          "new_text": null,
          "old_line_content": "    ret = s->io_open(s, &read_pb, s->url, AVIO_FLAG_READ, NULL);",
          "new_line_content": "        goto end;",
          "content_same": false
        },
        {
          "line": 6937,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Unable to re-open %s output file for \"\n               \"the second pass (faststart)\\n\", s->url)",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR, \"Unable to re-open %s output file for \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6436,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_WARNING, \"No meaningful edit list will be written when using empty_moov without delay_moov\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_WARNING, \"No meaningful edit list will be written when using empty_moov without delay_moov\\n\");",
          "new_line_content": "        mov->flags &= ~FF_MOV_FLAG_NEGATIVE_CTS_OFFSETS;",
          "content_same": false
        },
        {
          "line": 6948,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(read_pb, mov->reserved_header_pos, SEEK_SET)",
          "new_text": null,
          "old_line_content": "    avio_seek(read_pb, mov->reserved_header_pos, SEEK_SET);",
          "new_line_content": "    read_size[read_buf_id] = avio_read(read_pb, read_buf[read_buf_id], moov_size);  \\",
          "content_same": false
        },
        {
          "line": 6949,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(read_pb)",
          "new_text": null,
          "old_line_content": "    pos = avio_tell(read_pb);",
          "new_line_content": "    read_buf_id ^= 1;                                                               \\",
          "content_same": false
        },
        {
          "line": 6439,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_WARNING, \"Edit list enabled; Assuming writing CMAF Track File\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_WARNING, \"Edit list enabled; Assuming writing CMAF Track File\\n\");",
          "new_line_content": "        !(mov->flags & FF_MOV_FLAG_NEGATIVE_CTS_OFFSETS))",
          "content_same": false
        },
        {
          "line": 6964,
          "old_api": "avio_write",
          "new_api": null,
          "old_text": "avio_write(s->pb, read_buf[read_buf_id], n)",
          "new_text": null,
          "old_line_content": "        avio_write(s->pb, read_buf[read_buf_id], n);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6455,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR,\n               \"Sample interleaving in fragments is mutually exclusive with \"\n               \"omit_tfhd_offset and separate_moof\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 6967,
          "old_api": "ff_format_io_close",
          "new_api": null,
          "old_text": "ff_format_io_close(s, &read_pb)",
          "new_text": null,
          "old_line_content": "    ff_format_io_close(s, &read_pb);",
          "new_line_content": "    return ret;",
          "content_same": false
        },
        {
          "line": 6458,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "     * is enabled, we don't support non-seekable output at all. */",
          "content_same": false
        },
        {
          "line": 6970,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(buf)",
          "new_text": null,
          "old_line_content": "    av_free(buf);",
          "new_line_content": "static int mov_write_trailer(AVFormatContext *s)",
          "content_same": false
        },
        {
          "line": 6465,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"muxer does not support non seekable output\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR, \"muxer does not support non seekable output\\n\");",
          "new_line_content": "    mov->nb_streams = s->nb_streams;",
          "content_same": false
        },
        {
          "line": 6466,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "    if (mov->mode & (MODE_MP4|MODE_MOV|MODE_IPOD) && s->nb_chapters)",
          "content_same": false
        },
        {
          "line": 6475,
          "old_api": "rtp_hinting_needed",
          "new_api": null,
          "old_text": "rtp_hinting_needed(s->streams[i])",
          "new_text": null,
          "old_line_content": "            if (rtp_hinting_needed(s->streams[i]))",
          "new_line_content": "    if (   mov->write_tmcd == -1 && (mov->mode == MODE_MOV || mov->mode == MODE_MP4)",
          "content_same": false
        },
        {
          "line": 6991,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "                return AVERROR(ENOMEM);",
          "new_line_content": "        mov->need_rewrite_extradata = 0;",
          "content_same": false
        },
        {
          "line": 6992,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(track->vos_data, par->extradata, track->vos_len)",
          "new_text": null,
          "old_line_content": "            memcpy(track->vos_data, par->extradata, track->vos_len);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 6993,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(track->vos_data + track->vos_len, 0, AV_INPUT_BUFFER_PADDING_SIZE)",
          "new_text": null,
          "old_line_content": "            memset(track->vos_data + track->vos_len, 0, AV_INPUT_BUFFER_PADDING_SIZE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6486,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(st->metadata, \"timecode\", NULL, 0)",
          "new_text": null,
          "old_line_content": "                (t || (t=av_dict_get(st->metadata, \"timecode\", NULL, 0)))) {",
          "new_line_content": "                    mov->nb_meta_tmcd++;",
          "content_same": false
        },
        {
          "line": 6488,
          "old_api": "mov_check_timecode_track",
          "new_api": null,
          "old_text": "mov_check_timecode_track(s, &tc, i, t->value)",
          "new_text": null,
          "old_line_content": "                ret = mov_check_timecode_track(s, &tc, i, t->value);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 7006,
          "old_api": "mov_write_subtitle_end_packet",
          "new_api": null,
          "old_text": "mov_write_subtitle_end_packet(s, i, trk->track_duration)",
          "new_text": null,
          "old_line_content": "            mov_write_subtitle_end_packet(s, i, trk->track_duration);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6498,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('t','m','c','d')",
          "new_text": null,
          "old_line_content": "                if (st->codecpar->codec_tag == MKTAG('t','m','c','d')) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 6499,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_WARNING, \"You requested a copy of the original timecode track \"\n                           \"so timecode metadata are now ignored\\n\")",
          "new_text": null,
          "old_line_content": "                    av_log(s, AV_LOG_WARNING, \"You requested a copy of the original timecode track \"",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 7017,
          "old_api": "mov_create_chapter_track",
          "new_api": null,
          "old_text": "mov_create_chapter_track(s, mov->chapter_track)",
          "new_text": null,
          "old_line_content": "            if ((res = mov_create_chapter_track(s, mov->chapter_track)) < 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6513,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "            mov->encryption_scheme = MOV_ENC_CENC_AES_CTR;",
          "content_same": false
        },
        {
          "line": 6515,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(mov->encryption_scheme_str, \"none\")",
          "new_text": null,
          "old_line_content": "    if (mov->encryption_scheme_str != NULL && strcmp(mov->encryption_scheme_str, \"none\") != 0) {",
          "new_line_content": "            if (mov->encryption_key_len != AES_CTR_KEY_SIZE) {",
          "content_same": false
        },
        {
          "line": 7028,
          "old_api": "avio_wb32",
          "new_api": null,
          "old_text": "avio_wb32(pb, mov->mdat_size + 8)",
          "new_text": null,
          "old_line_content": "            avio_wb32(pb, mov->mdat_size + 8);",
          "new_line_content": "            /* special value: real atom size will be 64 bit value after",
          "content_same": false
        },
        {
          "line": 6520,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Invalid encryption key len %d expected %d\\n\",\n                    mov->encryption_key_len, AES_CTR_KEY_SIZE)",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_ERROR, \"Invalid encryption key len %d expected %d\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7035,
          "old_api": "ffio_wfourcc",
          "new_api": null,
          "old_text": "ffio_wfourcc(pb, \"mdat\")",
          "new_text": null,
          "old_line_content": "            ffio_wfourcc(pb, \"mdat\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7036,
          "old_api": "avio_wb64",
          "new_api": null,
          "old_text": "avio_wb64(pb, mov->mdat_size + 16)",
          "new_text": null,
          "old_line_content": "            avio_wb64(pb, mov->mdat_size + 16);",
          "new_line_content": "        if (mov->flags & FF_MOV_FLAG_FASTSTART) {",
          "content_same": false
        },
        {
          "line": 6526,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Invalid encryption kid len %d expected %d\\n\",\n                    mov->encryption_kid_len, CENC_KID_SIZE)",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_ERROR, \"Invalid encryption kid len %d expected %d\\n\",",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 6528,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "                return AVERROR(EINVAL);",
          "new_line_content": "                mov->encryption_scheme_str);",
          "content_same": false
        },
        {
          "line": 6531,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"unsupported encryption scheme %s\\n\",\n                mov->encryption_scheme_str)",
          "new_text": null,
          "old_line_content": "            av_log(s, AV_LOG_ERROR, \"unsupported encryption scheme %s\\n\",",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 6533,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "            return AVERROR(EINVAL);",
          "new_line_content": "    for (i = 0; i < s->nb_streams; i++) {",
          "content_same": false
        },
        {
          "line": 7045,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(pb, mov->reserved_header_pos, SEEK_SET)",
          "new_text": null,
          "old_line_content": "            avio_seek(pb, mov->reserved_header_pos, SEEK_SET);",
          "new_line_content": "            int64_t size;",
          "content_same": false
        },
        {
          "line": 7052,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "            size = mov->reserved_moov_size - (avio_tell(pb) - mov->reserved_header_pos);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 7057,
          "old_api": "avio_wb32",
          "new_api": null,
          "old_text": "avio_wb32(pb, size)",
          "new_text": null,
          "old_line_content": "            avio_wb32(pb, size);",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 7059,
          "old_api": "ffio_fill",
          "new_api": null,
          "old_text": "ffio_fill(pb, 0, size - 8)",
          "new_text": null,
          "old_line_content": "            ffio_fill(pb, 0, size - 8);",
          "new_line_content": "                return res;",
          "content_same": false
        },
        {
          "line": 7060,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(pb, moov_pos, SEEK_SET)",
          "new_text": null,
          "old_line_content": "            avio_seek(pb, moov_pos, SEEK_SET);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 6550,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Could not find tag for codec %s in stream #%d, \"\n                   \"codec not currently supported in container\\n\",\n                   avcodec_get_name(st->codecpar->codec_id), i)",
          "new_text": null,
          "old_line_content": "            av_log(s, AV_LOG_ERROR, \"Could not find tag for codec %s in stream #%d, \"",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 7062,
          "old_api": "mov_write_moov_tag",
          "new_api": null,
          "old_text": "mov_write_moov_tag(pb, mov, s)",
          "new_text": null,
          "old_line_content": "            if ((res = mov_write_moov_tag(pb, mov, s)) < 0)",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 6552,
          "old_api": "avcodec_get_name",
          "new_api": null,
          "old_text": "avcodec_get_name(st->codecpar->codec_id)",
          "new_text": null,
          "old_line_content": "                   avcodec_get_name(st->codecpar->codec_id), i);",
          "new_line_content": "         * this is updated. */",
          "content_same": false
        },
        {
          "line": 6553,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "            return AVERROR(EINVAL);",
          "new_line_content": "        track->hint_track = -1;",
          "content_same": false
        },
        {
          "line": 7067,
          "old_api": "mov_auto_flush_fragment",
          "new_api": null,
          "old_text": "mov_auto_flush_fragment(s, 1)",
          "new_text": null,
          "old_line_content": "        mov_auto_flush_fragment(s, 1);",
          "new_line_content": "            int64_t end;",
          "content_same": false
        },
        {
          "line": 7076,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "            end = avio_tell(pb);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 6565,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('m','x','5','n')",
          "new_text": null,
          "old_line_content": "                track->tag == MKTAG('m','x','5','p') || track->tag == MKTAG('m','x','5','n')) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 7077,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(pb, mov->reserved_header_pos, SEEK_SET)",
          "new_text": null,
          "old_line_content": "            avio_seek(pb, mov->reserved_header_pos, SEEK_SET);",
          "new_line_content": "        if (!(mov->flags & FF_MOV_FLAG_SKIP_TRAILER)) {",
          "content_same": false
        },
        {
          "line": 6567,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"D-10/IMX must use 720x608 or 720x512 video resolution\\n\")",
          "new_text": null,
          "old_line_content": "                    av_log(s, AV_LOG_ERROR, \"D-10/IMX must use 720x608 or 720x512 video resolution\\n\");",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 6568,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "                    return AVERROR(EINVAL);",
          "new_line_content": "            if (mov->video_track_timescale) {",
          "content_same": false
        },
        {
          "line": 7082,
          "old_api": "avio_write_marker",
          "new_api": null,
          "old_text": "avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_TRAILER)",
          "new_text": null,
          "old_line_content": "            avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_TRAILER);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 7083,
          "old_api": "mov_write_mfra_tag",
          "new_api": null,
          "old_text": "mov_write_mfra_tag(pb, mov)",
          "new_text": null,
          "old_line_content": "            res = mov_write_mfra_tag(pb, mov);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 6575,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_WARNING, \"Warning: some tools, like mp4split, assume a timescale of 10000000 for ISMV.\\n\")",
          "new_text": null,
          "old_line_content": "                    av_log(s, AV_LOG_WARNING, \"Warning: some tools, like mp4split, assume a timescale of 10000000 for ISMV.\\n\");",
          "new_line_content": "                    track->timescale *= 2;",
          "content_same": false
        },
        {
          "line": 6583,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "                return AVERROR(EINVAL);",
          "new_line_content": "                       \"WARNING codec timebase is very high. If duration is too long,\\n\"",
          "content_same": false
        },
        {
          "line": 6586,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_WARNING,\n                       \"WARNING codec timebase is very high. If duration is too long,\\n\"\n                       \"file may not be playable by quicktime. Specify a shorter timebase\\n\"\n                       \"or choose different container.\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_WARNING,",
          "new_line_content": "            if (track->mode == MODE_MOV &&",
          "content_same": false
        },
        {
          "line": 7098,
          "old_api": "AV_RB16",
          "new_api": null,
          "old_text": "AV_RB16(pkt->data)",
          "new_text": null,
          "old_line_content": "        if (pkt->size > 2 && (AV_RB16(pkt->data) & 0xfff0) == 0xfff0)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 7099,
          "old_api": "ff_stream_add_bitstream_filter",
          "new_api": null,
          "old_text": "ff_stream_add_bitstream_filter(st, \"aac_adtstoasc\", NULL)",
          "new_text": null,
          "old_line_content": "            ret = ff_stream_add_bitstream_filter(st, \"aac_adtstoasc\", NULL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7101,
          "old_api": "ff_stream_add_bitstream_filter",
          "new_api": null,
          "old_text": "ff_stream_add_bitstream_filter(st, \"vp9_superframe\", NULL)",
          "new_text": null,
          "old_line_content": "        ret = ff_stream_add_bitstream_filter(st, \"vp9_superframe\", NULL);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 6592,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('r','a','w',' ')",
          "new_text": null,
          "old_line_content": "                track->tag == MKTAG('r','a','w',' ')) {",
          "new_line_content": "                track->is_unaligned_qt_rgb =",
          "content_same": false
        },
        {
          "line": 7111,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('m','p','4','a')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_AAC,      MKTAG('m','p','4','a') },",
          "new_line_content": "    { AV_CODEC_ID_NONE, 0 },",
          "content_same": false
        },
        {
          "line": 7112,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('s','a','m','r')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_AMR_NB,   MKTAG('s','a','m','r') },",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 7113,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('s','a','w','b')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_AMR_WB,   MKTAG('s','a','w','b') },",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7114,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('t','x','3','g')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_MOV_TEXT, MKTAG('t','x','3','g') },",
          "new_line_content": "static const AVCodecTag codec_mp4_tags[] = {",
          "content_same": false
        },
        {
          "line": 6607,
          "old_api": "avcodec_get_name",
          "new_api": null,
          "old_text": "avcodec_get_name(track->par->codec_id)",
          "new_text": null,
          "old_line_content": "                    av_log(s, AV_LOG_ERROR, \"%s only supported in MP4.\\n\", avcodec_get_name(track->par->codec_id));",
          "new_line_content": "                /* altref frames handling is not defined in the spec as of version v1.0,",
          "content_same": false
        },
        {
          "line": 6608,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "                    return AVERROR(EINVAL);",
          "new_line_content": "                 * so just forbid muxing VP8 streams altogether until a new version does */",
          "content_same": false
        },
        {
          "line": 6613,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"VP8 muxing is currently not supported.\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_ERROR, \"VP8 muxing is currently not supported.\\n\");",
          "new_line_content": "            track->timescale = st->codecpar->sample_rate;",
          "content_same": false
        },
        {
          "line": 6618,
          "old_api": "av_get_bits_per_sample",
          "new_api": null,
          "old_text": "av_get_bits_per_sample(st->codecpar->codec_id)",
          "new_text": null,
          "old_line_content": "            if (!st->codecpar->frame_size && !av_get_bits_per_sample(st->codecpar->codec_id)) {",
          "new_line_content": "                     st->codecpar->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||",
          "content_same": false
        },
        {
          "line": 6619,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_WARNING, \"track %d: codec frame size is not set\\n\", i)",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_WARNING, \"track %d: codec frame size is not set\\n\", i);",
          "new_line_content": "                     st->codecpar->codec_id == AV_CODEC_ID_ILBC){",
          "content_same": false
        },
        {
          "line": 6625,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"track %d: codec block align is not set for adpcm\\n\", i)",
          "new_text": null,
          "old_line_content": "                    av_log(s, AV_LOG_ERROR, \"track %d: codec block align is not set for adpcm\\n\", i);",
          "new_line_content": "            }else if (st->codecpar->frame_size > 1){ /* assume compressed audio */",
          "content_same": false
        },
        {
          "line": 6626,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "                    return AVERROR(EINVAL);",
          "new_line_content": "                track->audio_vbr = 1;",
          "content_same": false
        },
        {
          "line": 6632,
          "old_api": "av_get_bits_per_sample",
          "new_api": null,
          "old_text": "av_get_bits_per_sample(st->codecpar->codec_id)",
          "new_text": null,
          "old_line_content": "                track->sample_size = (av_get_bits_per_sample(st->codecpar->codec_id) >> 3) * st->codecpar->channels;",
          "new_line_content": "                track->audio_vbr = 1;",
          "content_same": false
        },
        {
          "line": 7147,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('m', 'p', '4', 's')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_DVD_SUBTITLE,    MKTAG('m', 'p', '4', 's') },",
          "new_line_content": "    { AV_CODEC_ID_NONE,               0 },",
          "content_same": false
        },
        {
          "line": 7148,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('t', 'x', '3', 'g')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_MOV_TEXT,        MKTAG('t', 'x', '3', 'g') },",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 7149,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('g', 'p', 'm', 'd')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_BIN_DATA,        MKTAG('g', 'p', 'm', 'd') },",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7150,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('m', 'h', 'm', '1')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_MPEGH_3D_AUDIO,  MKTAG('m', 'h', 'm', '1') },",
          "new_line_content": "static const AVCodecTag codec_ism_tags[] = {",
          "content_same": false
        },
        {
          "line": 6643,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "                    return AVERROR(EINVAL);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 7155,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('w', 'm', 'a', ' ')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_WMAPRO      , MKTAG('w', 'm', 'a', ' ') },",
          "new_line_content": "static const AVCodecTag codec_ipod_tags[] = {",
          "content_same": false
        },
        {
          "line": 6645,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_WARNING, \"track %d: muxing mp3 at %dhz is not standard in MP4\\n\",\n                           i, track->par->sample_rate)",
          "new_text": null,
          "old_line_content": "                    av_log(s, AV_LOG_WARNING, \"track %d: muxing mp3 at %dhz is not standard in MP4\\n\",",
          "new_line_content": "            if (track->par->codec_id == AV_CODEC_ID_FLAC ||",
          "content_same": false
        },
        {
          "line": 7163,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('a','l','a','c')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_ALAC,     MKTAG('a','l','a','c') },",
          "new_line_content": "    { AV_CODEC_ID_NONE, 0 },",
          "content_same": false
        },
        {
          "line": 7164,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('a','c','-','3')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_AC3,      MKTAG('a','c','-','3') },",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 6653,
          "old_api": "avcodec_get_name",
          "new_api": null,
          "old_text": "avcodec_get_name(track->par->codec_id)",
          "new_text": null,
          "old_line_content": "                    av_log(s, AV_LOG_ERROR, \"%s only supported in MP4.\\n\", avcodec_get_name(track->par->codec_id));",
          "new_line_content": "                    s->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {",
          "content_same": false
        },
        {
          "line": 7166,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('t','e','x','t')",
          "new_text": null,
          "old_line_content": "    { AV_CODEC_ID_MOV_TEXT, MKTAG('t','e','x','t') },",
          "new_line_content": "static const AVCodecTag codec_f4v_tags[] = {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 45,
      "total_additions": 168,
      "total_deletions": 171,
      "total_api_changes": 384
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 10,
        "api_related_lines": 384,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          6168,
          6201,
          6171,
          6172
        ]
      }
    },
    "api_calls_before": 2396,
    "api_calls_after": 2393,
    "diff_info": {
      "added_lines": 4,
      "removed_lines": 8,
      "total_diff_lines": 35
    }
  }
}