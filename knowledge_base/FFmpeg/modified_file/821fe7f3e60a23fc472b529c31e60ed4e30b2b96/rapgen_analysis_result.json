{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/821fe7f3e60a23fc472b529c31e60ed4e30b2b96",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/821fe7f3e60a23fc472b529c31e60ed4e30b2b96/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/821fe7f3e60a23fc472b529c31e60ed4e30b2b96/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/821fe7f3e60a23fc472b529c31e60ed4e30b2b96/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1188,
          "old_api": "decode_cabac_residual_nondc",
          "new_api": "decode_cabac_residual_dc",
          "old_text": "decode_cabac_residual_nondc(h, block, cat, n, scantable, qmul, max_coeff)",
          "new_text": "decode_cabac_residual_dc(h, block, cat, n, scantable, qmul, max_coeff)",
          "old_line_content": "    else decode_cabac_residual_nondc(h, block, cat, n, scantable, qmul, max_coeff);",
          "new_line_content": "    if( cat == 0 || cat == 3 ) decode_cabac_residual_dc(h, block, cat, n, scantable, qmul, max_coeff);",
          "content_same": false
        },
        {
          "line": 1350,
          "old_api": "get_cabac_noinline",
          "new_api": "IS_INTRA4x4",
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[399 + h->neighbor_transform_size] )",
          "new_text": "IS_INTRA4x4( mb_type )",
          "old_line_content": "            if( dct8x8_allowed && get_cabac_noinline( &h->cabac, &h->cabac_state[399 + h->neighbor_transform_size] ) ) {",
          "new_line_content": "        if( IS_INTRA4x4( mb_type ) ) {",
          "content_same": false
        },
        {
          "line": 1354,
          "old_api": "decode_cabac_mb_intra4x4_pred_mode",
          "new_api": "pred_intra_mode",
          "old_text": "decode_cabac_mb_intra4x4_pred_mode( h, pred )",
          "new_text": "pred_intra_mode( h, i )",
          "old_line_content": "                    int mode = decode_cabac_mb_intra4x4_pred_mode( h, pred );",
          "new_line_content": "                    int pred = pred_intra_mode( h, i );",
          "content_same": false
        },
        {
          "line": 1355,
          "old_api": "fill_rectangle",
          "new_api": "decode_cabac_mb_intra4x4_pred_mode",
          "old_text": "fill_rectangle( &h->intra4x4_pred_mode_cache[ scan8[i] ], 2, 2, 8, mode, 1 )",
          "new_text": "decode_cabac_mb_intra4x4_pred_mode( h, pred )",
          "old_line_content": "                    fill_rectangle( &h->intra4x4_pred_mode_cache[ scan8[i] ], 2, 2, 8, mode, 1 );",
          "new_line_content": "                    int mode = decode_cabac_mb_intra4x4_pred_mode( h, pred );",
          "content_same": false
        },
        {
          "line": 1360,
          "old_api": "decode_cabac_mb_intra4x4_pred_mode",
          "new_api": "pred_intra_mode",
          "old_text": "decode_cabac_mb_intra4x4_pred_mode( h, pred )",
          "new_text": "pred_intra_mode( h, i )",
          "old_line_content": "                    h->intra4x4_pred_mode_cache[ scan8[i] ] = decode_cabac_mb_intra4x4_pred_mode( h, pred );",
          "new_line_content": "                    int pred = pred_intra_mode( h, i );",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": "ff_h264_check_intra4x4_pred_mode",
          "new_api": "ff_h264_write_back_intra_pred_mode",
          "old_text": "ff_h264_check_intra4x4_pred_mode(h)",
          "new_text": "ff_h264_write_back_intra_pred_mode(h)",
          "old_line_content": "            if( ff_h264_check_intra4x4_pred_mode(h) < 0 ) return -1;",
          "new_line_content": "            ff_h264_write_back_intra_pred_mode(h);",
          "content_same": false
        },
        {
          "line": 1409,
          "old_api": "IS_DIR",
          "new_api": "IS_DIRECT",
          "old_text": "IS_DIR(h->sub_mb_type[i], 0, list)",
          "new_text": "IS_DIRECT(h->sub_mb_type[i])",
          "old_line_content": "                    if(IS_DIR(h->sub_mb_type[i], 0, list)){",
          "new_line_content": "                    if(IS_DIRECT(h->sub_mb_type[i])) continue;",
          "content_same": false
        },
        {
          "line": 1433,
          "old_api": "fill_rectangle",
          "new_api": "IS_DIRECT",
          "old_text": "fill_rectangle(h->mvd_cache[list][scan8[4*i]], 2, 2, 8, 0, 2)",
          "new_text": "IS_DIRECT(h->sub_mb_type[i])",
          "old_line_content": "                    fill_rectangle(h->mvd_cache[list][scan8[4*i]], 2, 2, 8, 0, 2);",
          "new_line_content": "                if(IS_DIRECT(h->sub_mb_type[i])){",
          "content_same": false
        },
        {
          "line": 1447,
          "old_api": "DECODE_CABAC_MB_MVD",
          "new_api": "pred_motion",
          "old_text": "DECODE_CABAC_MB_MVD( h, list, index)",
          "new_text": "pred_motion(h, index, block_width, list, h->ref_cache[list][ scan8[index] ], &mx, &my)",
          "old_line_content": "                        DECODE_CABAC_MB_MVD( h, list, index)",
          "new_line_content": "                        pred_motion(h, index, block_width, list, h->ref_cache[list][ scan8[index] ], &mx, &my);",
          "content_same": false
        },
        {
          "line": 1448,
          "old_api": "tprintf",
          "new_api": "DECODE_CABAC_MB_MVD",
          "old_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "new_text": "DECODE_CABAC_MB_MVD( h, list, index)",
          "old_line_content": "                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "new_line_content": "                        DECODE_CABAC_MB_MVD( h, list, index)",
          "content_same": false
        },
        {
          "line": 1486,
          "old_api": "ff_h264_pred_direct_motion",
          "new_api": "IS_DIRECT",
          "old_text": "ff_h264_pred_direct_motion(h, &mb_type)",
          "new_text": "IS_DIRECT(mb_type)",
          "old_line_content": "        ff_h264_pred_direct_motion(h, &mb_type);",
          "new_line_content": "    } else if( IS_DIRECT(mb_type) ) {",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": "fill_rectangle",
          "new_api": "ff_h264_pred_direct_motion",
          "old_text": "fill_rectangle(h->mvd_cache[0][scan8[0]], 4, 4, 8, 0, 2)",
          "new_text": "ff_h264_pred_direct_motion(h, &mb_type)",
          "old_line_content": "        fill_rectangle(h->mvd_cache[0][scan8[0]], 4, 4, 8, 0, 2);",
          "new_line_content": "        ff_h264_pred_direct_motion(h, &mb_type);",
          "content_same": false
        },
        {
          "line": 1512,
          "old_api": "DECODE_CABAC_MB_MVD",
          "new_api": "pred_motion",
          "old_text": "DECODE_CABAC_MB_MVD( h, list, 0)",
          "new_text": "pred_motion(h, 0, 4, list, h->ref_cache[list][ scan8[0] ], &mx, &my)",
          "old_line_content": "                    DECODE_CABAC_MB_MVD( h, list, 0)",
          "new_line_content": "                    pred_motion(h, 0, 4, list, h->ref_cache[list][ scan8[0] ], &mx, &my);",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": "tprintf",
          "new_api": "DECODE_CABAC_MB_MVD",
          "old_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "new_text": "DECODE_CABAC_MB_MVD( h, list, 0)",
          "old_line_content": "                    tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "new_line_content": "                    DECODE_CABAC_MB_MVD( h, list, 0)",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": "pack16to32",
          "new_api": "pack8to16",
          "old_text": "pack16to32(mx,my)",
          "new_text": "pack8to16(mpx,mpy)",
          "old_line_content": "                    fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, pack16to32(mx,my), 4);",
          "new_line_content": "                    fill_rectangle(h->mvd_cache[list][ scan8[0] ], 4, 4, 8, pack8to16(mpx,mpy), 2);",
          "content_same": false
        },
        {
          "line": 1544,
          "old_api": "DECODE_CABAC_MB_MVD",
          "new_api": "pred_16x8_motion",
          "old_text": "DECODE_CABAC_MB_MVD( h, list, 8*i)",
          "new_text": "pred_16x8_motion(h, 8*i, list, h->ref_cache[list][scan8[0] + 16*i], &mx, &my)",
          "old_line_content": "                        DECODE_CABAC_MB_MVD( h, list, 8*i)",
          "new_line_content": "                        pred_16x8_motion(h, 8*i, list, h->ref_cache[list][scan8[0] + 16*i], &mx, &my);",
          "content_same": false
        },
        {
          "line": 1545,
          "old_api": "tprintf",
          "new_api": "DECODE_CABAC_MB_MVD",
          "old_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "new_text": "DECODE_CABAC_MB_MVD( h, list, 8*i)",
          "old_line_content": "                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "new_line_content": "                        DECODE_CABAC_MB_MVD( h, list, 8*i)",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": "pack16to32",
          "new_api": "pack8to16",
          "old_text": "pack16to32(mx,my)",
          "new_text": "pack8to16(mpx,mpy)",
          "old_line_content": "                        fill_rectangle(h->mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack16to32(mx,my), 4);",
          "new_line_content": "                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack8to16(mpx,mpy), 2);",
          "content_same": false
        },
        {
          "line": 1579,
          "old_api": "DECODE_CABAC_MB_MVD",
          "new_api": "pred_8x16_motion",
          "old_text": "DECODE_CABAC_MB_MVD( h, list, 4*i)",
          "new_text": "pred_8x16_motion(h, i*4, list, h->ref_cache[list][ scan8[0] + 2*i ], &mx, &my)",
          "old_line_content": "                        DECODE_CABAC_MB_MVD( h, list, 4*i)",
          "new_line_content": "                        pred_8x16_motion(h, i*4, list, h->ref_cache[list][ scan8[0] + 2*i ], &mx, &my);",
          "content_same": false
        },
        {
          "line": 1582,
          "old_api": "pack8to16",
          "new_api": "tprintf",
          "old_text": "pack8to16(mpx,mpy)",
          "new_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "old_line_content": "                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack8to16(mpx,mpy), 2);",
          "new_line_content": "                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": "pack16to32",
          "new_api": "pack8to16",
          "old_text": "pack16to32(mx,my)",
          "new_text": "pack8to16(mpx,mpy)",
          "old_line_content": "                        fill_rectangle(h->mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack16to32(mx,my), 4);",
          "new_line_content": "                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack8to16(mpx,mpy), 2);",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": "decode_cabac_mb_cbp_luma",
          "new_api": "IS_INTRA16x16",
          "old_text": "decode_cabac_mb_cbp_luma( h )",
          "new_text": "IS_INTRA16x16( mb_type )",
          "old_line_content": "        cbp  = decode_cabac_mb_cbp_luma( h );",
          "new_line_content": "    if( !IS_INTRA16x16( mb_type ) ) {",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": "get_cabac_noinline",
          "new_api": "IS_INTRA",
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[399 + h->neighbor_transform_size] )",
          "new_text": "IS_INTRA( mb_type )",
          "old_line_content": "        mb_type |= MB_TYPE_8x8DCT * get_cabac_noinline( &h->cabac, &h->cabac_state[399 + h->neighbor_transform_size] );",
          "new_line_content": "    if( dct8x8_allowed && (cbp&15) && !IS_INTRA( mb_type ) ) {",
          "content_same": false
        },
        {
          "line": 1673,
          "old_api": "decode_cabac_residual",
          "new_api": "IS_8x8DCT",
          "old_text": "decode_cabac_residual(h, h->mb + 64*i8x8, 5, 4*i8x8,\n                            scan8x8, h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 64)",
          "new_text": "IS_8x8DCT(mb_type)",
          "old_line_content": "                        decode_cabac_residual(h, h->mb + 64*i8x8, 5, 4*i8x8,",
          "new_line_content": "                    if( IS_8x8DCT(mb_type) ) {",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": "IS_INTRA",
          "new_api": "decode_cabac_residual",
          "old_text": "IS_INTRA( mb_type )",
          "new_text": "decode_cabac_residual(h, h->mb + 64*i8x8, 5, 4*i8x8,\n                            scan8x8, h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 64)",
          "old_line_content": "                            scan8x8, h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 64);",
          "new_line_content": "                        decode_cabac_residual(h, h->mb + 64*i8x8, 5, 4*i8x8,",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1537,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, (LIST_NOT_USED&0xFF), 1)",
          "old_line_content": "                    }",
          "new_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, (LIST_NOT_USED&0xFF), 1);",
          "content_same": false
        },
        {
          "line": 1542,
          "old_api": null,
          "new_api": "IS_DIR",
          "old_text": null,
          "new_text": "IS_DIR(mb_type, i, list)",
          "old_line_content": "                        int mx,my,mpx,mpy;",
          "new_line_content": "                    if(IS_DIR(mb_type, i, list)){",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": null,
          "new_api": "tprintf",
          "old_text": null,
          "new_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "old_line_content": "",
          "new_line_content": "                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": null,
          "new_api": "pack16to32",
          "old_text": null,
          "new_text": "pack16to32(mx,my)",
          "old_line_content": "                    }else{",
          "new_line_content": "                        fill_rectangle(h->mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack16to32(mx,my), 4);",
          "content_same": false
        },
        {
          "line": 1552,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(h-> mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 4)",
          "old_line_content": "                    }",
          "new_line_content": "                        fill_rectangle(h-> mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 4);",
          "content_same": false
        },
        {
          "line": 1557,
          "old_api": null,
          "new_api": "IS_8X16",
          "old_text": null,
          "new_text": "IS_8X16(mb_type)",
          "old_line_content": "            for(list=0; list<h->list_count; list++){",
          "new_line_content": "            assert(IS_8X16(mb_type));",
          "content_same": false
        },
        {
          "line": 1560,
          "old_api": null,
          "new_api": "IS_DIR",
          "old_text": null,
          "new_text": "IS_DIR(mb_type, i, list)",
          "old_line_content": "                            int ref;",
          "new_line_content": "                        if(IS_DIR(mb_type, i, list)){ //FIXME optimize",
          "content_same": false
        },
        {
          "line": 1563,
          "old_api": null,
          "new_api": "decode_cabac_mb_ref",
          "old_text": null,
          "new_text": "decode_cabac_mb_ref( h, list, 4*i )",
          "old_line_content": "                                if(ref >= (unsigned)h->ref_count[list]){",
          "new_line_content": "                                ref= decode_cabac_mb_ref( h, list, 4*i );",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list])",
          "old_line_content": "                                    return -1;",
          "new_line_content": "                                    av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);",
          "content_same": false
        },
        {
          "line": 1570,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, ref, 1)",
          "old_line_content": "                        }else",
          "new_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, ref, 1);",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, (LIST_NOT_USED&0xFF), 1)",
          "old_line_content": "                    }",
          "new_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, (LIST_NOT_USED&0xFF), 1);",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": null,
          "new_api": "get_cabac_cbf_ctx",
          "old_text": null,
          "new_text": "get_cabac_cbf_ctx( h, cat, n, is_dc )",
          "old_line_content": "            if( !is_dc )",
          "new_line_content": "        if( get_cabac( CC, &h->cabac_state[85 + get_cabac_cbf_ctx( h, cat, n, is_dc ) ] ) == 0 ) {",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": null,
          "new_api": "IS_DIR",
          "old_text": null,
          "new_text": "IS_DIR(mb_type, i, list)",
          "old_line_content": "                        int mx,my,mpx,mpy;",
          "new_line_content": "                    if(IS_DIR(mb_type, i, list)){",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": null,
          "new_api": "DECODE_CABAC_MB_MVD",
          "old_text": null,
          "new_text": "DECODE_CABAC_MB_MVD( h, list, 4*i)",
          "old_line_content": "",
          "new_line_content": "                        DECODE_CABAC_MB_MVD( h, list, 4*i)",
          "content_same": false
        },
        {
          "line": 1584,
          "old_api": null,
          "new_api": "pack16to32",
          "old_text": null,
          "new_text": "pack16to32(mx,my)",
          "old_line_content": "                    }else{",
          "new_line_content": "                        fill_rectangle(h->mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack16to32(mx,my), 4);",
          "content_same": false
        },
        {
          "line": 1587,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(h-> mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 4)",
          "old_line_content": "                    }",
          "new_line_content": "                        fill_rectangle(h-> mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 4);",
          "content_same": false
        },
        {
          "line": 1594,
          "old_api": null,
          "new_api": "IS_INTER",
          "old_text": null,
          "new_text": "IS_INTER( mb_type )",
          "old_line_content": "        h->chroma_pred_mode_table[mb_xy] = 0;",
          "new_line_content": "   if( IS_INTER( mb_type ) ) {",
          "content_same": false
        },
        {
          "line": 1596,
          "old_api": null,
          "new_api": "write_back_motion",
          "old_text": null,
          "new_text": "write_back_motion( h, mb_type )",
          "old_line_content": "   }",
          "new_line_content": "        write_back_motion( h, mb_type );",
          "content_same": false
        },
        {
          "line": 1600,
          "old_api": null,
          "new_api": "decode_cabac_mb_cbp_luma",
          "old_text": null,
          "new_text": "decode_cabac_mb_cbp_luma( h )",
          "old_line_content": "        if(CHROMA)",
          "new_line_content": "        cbp  = decode_cabac_mb_cbp_luma( h );",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": null,
          "new_api": "decode_cabac_mb_cbp_chroma",
          "old_text": null,
          "new_text": "decode_cabac_mb_cbp_chroma( h )",
          "old_line_content": "    }",
          "new_line_content": "            cbp |= decode_cabac_mb_cbp_chroma( h ) << 4;",
          "content_same": false
        },
        {
          "line": 1608,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[399 + h->neighbor_transform_size] )",
          "old_line_content": "    }",
          "new_line_content": "        mb_type |= MB_TYPE_8x8DCT * get_cabac_noinline( &h->cabac, &h->cabac_state[399 + h->neighbor_transform_size] );",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": null,
          "new_api": "decode_significance_8x8_x86",
          "old_text": null,
          "new_text": "decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index, sig_off)",
          "old_line_content": "    } else {",
          "new_line_content": "        coeff_count= decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index, sig_off);",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": null,
          "new_api": "IS_INTRA16x16",
          "old_text": null,
          "new_text": "IS_INTRA16x16( mb_type )",
          "old_line_content": "        const uint8_t *scan, *scan8x8, *dc_scan;",
          "new_line_content": "    if( cbp || IS_INTRA16x16( mb_type ) ) {",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": null,
          "new_api": "decode_significance_x86",
          "old_text": null,
          "new_text": "decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index)",
          "old_line_content": "#else",
          "new_line_content": "        coeff_count= decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index);",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": null,
          "new_api": "DECODE_SIGNIFICANCE",
          "old_text": null,
          "new_text": "DECODE_SIGNIFICANCE( 63, sig_off[last], last_coeff_flag_offset_8x8[last] )",
          "old_line_content": "    } else {",
          "new_line_content": "        DECODE_SIGNIFICANCE( 63, sig_off[last], last_coeff_flag_offset_8x8[last] );",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": null,
          "new_api": "IS_INTERLACED",
          "old_text": null,
          "new_text": "IS_INTERLACED(mb_type)",
          "old_line_content": "            scan8x8= s->qscale ? h->field_scan8x8 : h->field_scan8x8_q0;",
          "new_line_content": "        if(IS_INTERLACED(mb_type)){",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": null,
          "new_api": "DECODE_SIGNIFICANCE",
          "old_text": null,
          "new_text": "DECODE_SIGNIFICANCE( max_coeff - 1, last, last )",
          "old_line_content": "#endif",
          "new_line_content": "        DECODE_SIGNIFICANCE( max_coeff - 1, last, last );",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(coeff_count > 0)",
          "old_line_content": "",
          "new_line_content": "    assert(coeff_count > 0);",
          "content_same": false
        },
        {
          "line": 1627,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[60 + (h->last_qscale_diff != 0)])",
          "old_line_content": "            int val = 1;",
          "new_line_content": "        if(get_cabac_noinline( &h->cabac, &h->cabac_state[60 + (h->last_qscale_diff != 0)])){",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1)",
          "old_line_content": "        else {",
          "new_line_content": "            fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1);",
          "content_same": false
        },
        {
          "line": 1631,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[60 + ctx] )",
          "old_line_content": "                ctx= 3;",
          "new_line_content": "            while( get_cabac_noinline( &h->cabac, &h->cabac_state[60 + ctx] ) ) {",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert( cat == 1 || cat == 2 || cat == 4 )",
          "old_line_content": "            h->non_zero_count_cache[scan8[n]] = coeff_count;",
          "new_line_content": "            assert( cat == 1 || cat == 2 || cat == 4 );",
          "content_same": false
        },
        {
          "line": 1635,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(h->s.avctx, AV_LOG_ERROR, \"cabac decode of qscale diff failed at %d %d\\n\", s->mb_x, s->mb_y)",
          "old_line_content": "                    return -1;",
          "new_line_content": "                    av_log(h->s.avctx, AV_LOG_ERROR, \"cabac decode of qscale diff failed at %d %d\\n\", s->mb_x, s->mb_y);",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( CC, ctx )",
          "old_line_content": "            node_ctx = coeff_abs_level_transition[0][node_ctx];",
          "new_line_content": "        if( get_cabac( CC, ctx ) == 0 ) {",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": null,
          "new_api": "get_cabac_bypass_sign",
          "old_text": null,
          "new_text": "get_cabac_bypass_sign( CC, -1)",
          "old_line_content": "            }else{",
          "new_line_content": "                block[j] = get_cabac_bypass_sign( CC, -1);",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": null,
          "new_api": "get_cabac_bypass_sign",
          "old_text": null,
          "new_text": "get_cabac_bypass_sign( CC, -qmul[j])",
          "old_line_content": "            }",
          "new_line_content": "                block[j] = (get_cabac_bypass_sign( CC, -qmul[j]) + 32) >> 6;",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": null,
          "new_api": "get_chroma_qp",
          "old_text": null,
          "new_text": "get_chroma_qp(h, 1, s->qscale)",
          "old_line_content": "        }else",
          "new_line_content": "            h->chroma_qp[1] = get_chroma_qp(h, 1, s->qscale);",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( CC, ctx )",
          "old_line_content": "                coeff_abs++;",
          "new_line_content": "            while( coeff_abs < 15 && get_cabac( CC, ctx ) ) {",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": null,
          "new_api": "IS_INTRA16x16",
          "old_text": null,
          "new_text": "IS_INTRA16x16( mb_type )",
          "old_line_content": "            int i;",
          "new_line_content": "        if( IS_INTRA16x16( mb_type ) ) {",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": null,
          "new_api": "decode_cabac_residual",
          "old_text": null,
          "new_text": "decode_cabac_residual( h, h->mb, 0, 0, dc_scan, NULL, 16)",
          "old_line_content": "",
          "new_line_content": "            decode_cabac_residual( h, h->mb, 0, 0, dc_scan, NULL, 16);",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": null,
          "new_api": "get_cabac_bypass",
          "old_text": null,
          "new_text": "get_cabac_bypass( CC )",
          "old_line_content": "                    j++;",
          "new_line_content": "                while( get_cabac_bypass( CC ) ) {",
          "content_same": false
        },
        {
          "line": 1664,
          "old_api": null,
          "new_api": "decode_cabac_residual",
          "old_text": null,
          "new_text": "decode_cabac_residual(h, h->mb + 16*i, 1, i, scan + 1, qmul, 15)",
          "old_line_content": "                }",
          "new_line_content": "                    decode_cabac_residual(h, h->mb + 16*i, 1, i, scan + 1, qmul, 15);",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": null,
          "new_api": "get_cabac_bypass",
          "old_text": null,
          "new_text": "get_cabac_bypass( CC )",
          "old_line_content": "                }",
          "new_line_content": "                    coeff_abs += coeff_abs + get_cabac_bypass( CC );",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1)",
          "old_line_content": "            }",
          "new_line_content": "                fill_rectangle(&h->non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1);",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": null,
          "new_api": "get_cabac_bypass_sign",
          "old_text": null,
          "new_text": "get_cabac_bypass_sign( CC, -coeff_abs )",
          "old_line_content": "            }else{",
          "new_line_content": "                block[j] = get_cabac_bypass_sign( CC, -coeff_abs );",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": null,
          "new_api": "get_cabac_bypass_sign",
          "old_text": null,
          "new_text": "get_cabac_bypass_sign( CC, -coeff_abs )",
          "old_line_content": "            }",
          "new_line_content": "                block[j] = (get_cabac_bypass_sign( CC, -coeff_abs ) * qmul[j] + 32) >> 6;",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": null,
          "new_api": "IS_INTRA",
          "old_text": null,
          "new_text": "IS_INTRA( mb_type )",
          "old_line_content": "                    } else {",
          "new_line_content": "                            scan8x8, h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 64);",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": null,
          "new_api": "IS_INTRA",
          "old_text": null,
          "new_text": "IS_INTRA( mb_type )",
          "old_line_content": "                        for( i4x4 = 0; i4x4 < 4; i4x4++ ) {",
          "new_line_content": "                        qmul = h->dequant4_coeff[IS_INTRA( mb_type ) ? 0:3][s->qscale];",
          "content_same": false
        },
        {
          "line": 1682,
          "old_api": null,
          "new_api": "decode_cabac_residual",
          "old_text": null,
          "new_text": "decode_cabac_residual(h, h->mb + 16*index, 2, index, scan, qmul, 16)",
          "old_line_content": "//STOP_TIMER(\"decode_residual\")",
          "new_line_content": "                            decode_cabac_residual(h, h->mb + 16*index, 2, index, scan, qmul, 16);",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "decode_cabac_residual_internal",
          "old_text": null,
          "new_text": "decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 1)",
          "old_line_content": "}",
          "new_line_content": "    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 1);",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": null,
          "new_api": "decode_cabac_residual_internal",
          "old_text": null,
          "new_text": "decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 0)",
          "old_line_content": "}",
          "new_line_content": "    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 0);",
          "content_same": false
        },
        {
          "line": 1697,
          "old_api": null,
          "new_api": "decode_cabac_residual",
          "old_text": null,
          "new_text": "decode_cabac_residual(h, h->mb + 256 + 16*4*c, 3, c, chroma_dc_scan, NULL, 4)",
          "old_line_content": "            }",
          "new_line_content": "                decode_cabac_residual(h, h->mb + 256 + 16*4*c, 3, c, chroma_dc_scan, NULL, 4);",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": null,
          "new_api": "decode_cabac_residual_internal",
          "old_text": null,
          "new_text": "decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, cat == 0 || cat == 3)",
          "old_line_content": "#else",
          "new_line_content": "    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, cat == 0 || cat == 3);",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": null,
          "new_api": "decode_cabac_residual_nondc",
          "old_text": null,
          "new_text": "decode_cabac_residual_nondc(h, block, cat, n, scantable, qmul, max_coeff)",
          "old_line_content": "#endif",
          "new_line_content": "    else decode_cabac_residual_nondc(h, block, cat, n, scantable, qmul, max_coeff);",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": null,
          "new_api": "IS_INTRA",
          "old_text": null,
          "new_text": "IS_INTRA( mb_type )",
          "old_line_content": "                for( i = 0; i < 4; i++ ) {",
          "new_line_content": "                qmul = h->dequant4_coeff[c+1+(IS_INTRA( mb_type ) ? 0:3)][h->chroma_qp[c]];",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": null,
          "new_api": "decode_cabac_residual",
          "old_text": null,
          "new_text": "decode_cabac_residual(h, h->mb + 16*index, 4, index, scan + 1, qmul, 15)",
          "old_line_content": "                }",
          "new_line_content": "                    decode_cabac_residual(h, h->mb + 16*index, 4, index, scan + 1, qmul, 15);",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": null,
          "new_api": "tprintf",
          "old_text": null,
          "new_text": "tprintf(s->avctx, \"pic:%d mb:%d/%d\\n\", h->frame_num, s->mb_x, s->mb_y)",
          "old_line_content": "    if( h->slice_type_nos != FF_I_TYPE ) {",
          "new_line_content": "    tprintf(s->avctx, \"pic:%d mb:%d/%d\\n\", h->frame_num, s->mb_x, s->mb_y);",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1)",
          "old_line_content": "        nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] =",
          "new_line_content": "        fill_rectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1);",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": null,
          "new_api": "decode_cabac_mb_skip",
          "old_text": null,
          "new_text": "decode_cabac_mb_skip( h, s->mb_x, s->mb_y )",
          "old_line_content": "        /* read skip flags */",
          "new_line_content": "            skip = decode_cabac_mb_skip( h, s->mb_x, s->mb_y );",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": null,
          "new_api": "write_back_non_zero_count",
          "old_text": null,
          "new_text": "write_back_non_zero_count(h)",
          "old_line_content": "",
          "new_line_content": "    write_back_non_zero_count(h);",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": null,
          "new_api": "decode_cabac_mb_skip",
          "old_text": null,
          "new_text": "decode_cabac_mb_skip( h, s->mb_x, s->mb_y+1 )",
          "old_line_content": "                if(!h->next_mb_skipped)",
          "new_line_content": "                h->next_mb_skipped = decode_cabac_mb_skip( h, s->mb_x, s->mb_y+1 );",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": null,
          "new_api": "decode_cabac_field_decoding_flag",
          "old_text": null,
          "new_text": "decode_cabac_field_decoding_flag(h)",
          "old_line_content": "            }",
          "new_line_content": "                    h->mb_mbaff = h->mb_field_decoding_flag = decode_cabac_field_decoding_flag(h);",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": null,
          "new_api": "decode_mb_skip",
          "old_text": null,
          "new_text": "decode_mb_skip(h)",
          "old_line_content": "",
          "new_line_content": "            decode_mb_skip(h);",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": null,
          "new_api": "decode_cabac_field_decoding_flag",
          "old_text": null,
          "new_text": "decode_cabac_field_decoding_flag(h)",
          "old_line_content": "    }",
          "new_line_content": "            h->mb_field_decoding_flag = decode_cabac_field_decoding_flag(h);",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": null,
          "new_api": "fill_decode_neighbors",
          "old_text": null,
          "new_text": "fill_decode_neighbors(h, -(MB_FIELD))",
          "old_line_content": "",
          "new_line_content": "    fill_decode_neighbors(h, -(MB_FIELD));",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(h->slice_type_nos == FF_B_TYPE)",
          "old_line_content": "",
          "new_line_content": "        assert(h->slice_type_nos == FF_B_TYPE);",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": null,
          "new_api": "IS_DIRECT",
          "old_text": null,
          "new_text": "IS_DIRECT( h->left_type[0]-1 )",
          "old_line_content": "            ctx++;",
          "new_line_content": "        if( !IS_DIRECT( h->left_type[0]-1 ) )",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": null,
          "new_api": "IS_DIRECT",
          "old_text": null,
          "new_text": "IS_DIRECT( h->top_type-1 )",
          "old_line_content": "            ctx++;",
          "new_line_content": "        if( !IS_DIRECT( h->top_type-1 ) )",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+ctx] )",
          "old_line_content": "            mb_type= 0; /* B_Direct_16x16 */",
          "new_line_content": "        if( !get_cabac_noinline( &h->cabac, &h->cabac_state[27+ctx] ) ){",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] )",
          "old_line_content": "        }else{",
          "new_line_content": "            mb_type= 1 + get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] ); /* B_L[01]_16x16 */",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] )",
          "old_line_content": "            if( bits < 8 ){",
          "new_line_content": "            bits|= get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] );",
          "content_same": false
        },
        {
          "line": 1264,
          "old_api": null,
          "new_api": "decode_cabac_intra_mb_type",
          "old_text": null,
          "new_text": "decode_cabac_intra_mb_type(h, 32, 0)",
          "old_line_content": "                goto decode_intra_mb;",
          "new_line_content": "                mb_type= decode_cabac_intra_mb_type(h, 32, 0);",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] )",
          "old_line_content": "                mb_type= bits - 4; /* B_L0_Bi_* through B_Bi_Bi_* */",
          "new_line_content": "                bits= ( bits<<1 ) | get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] );",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[14] )",
          "old_line_content": "            /* P-type */",
          "new_line_content": "        if( get_cabac_noinline( &h->cabac, &h->cabac_state[14] ) == 0 ) {",
          "content_same": false
        },
        {
          "line": 1280,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[15] )",
          "old_line_content": "                /* P_L0_D16x16, P_8x8 */",
          "new_line_content": "            if( get_cabac_noinline( &h->cabac, &h->cabac_state[15] ) == 0 ) {",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[16] )",
          "old_line_content": "            } else {",
          "new_line_content": "                mb_type= 3 * get_cabac_noinline( &h->cabac, &h->cabac_state[16] );",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[17] )",
          "old_line_content": "            }",
          "new_line_content": "                mb_type= 2 - get_cabac_noinline( &h->cabac, &h->cabac_state[17] );",
          "content_same": false
        },
        {
          "line": 1290,
          "old_api": null,
          "new_api": "decode_cabac_intra_mb_type",
          "old_text": null,
          "new_text": "decode_cabac_intra_mb_type(h, 17, 0)",
          "old_line_content": "            goto decode_intra_mb;",
          "new_line_content": "            mb_type= decode_cabac_intra_mb_type(h, 17, 0);",
          "content_same": false
        },
        {
          "line": 1294,
          "old_api": null,
          "new_api": "decode_cabac_intra_mb_type",
          "old_text": null,
          "new_text": "decode_cabac_intra_mb_type(h, 3, 1)",
          "old_line_content": "        if(h->slice_type == FF_SI_TYPE && mb_type)",
          "new_line_content": "        mb_type= decode_cabac_intra_mb_type(h, 3, 1);",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(h->slice_type_nos == FF_I_TYPE)",
          "old_line_content": "decode_intra_mb:",
          "new_line_content": "        assert(h->slice_type_nos == FF_I_TYPE);",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": null,
          "new_api": "IS_INTRA_PCM",
          "old_text": null,
          "new_text": "IS_INTRA_PCM(mb_type)",
          "old_line_content": "        const uint8_t *ptr;",
          "new_line_content": "    if(IS_INTRA_PCM(mb_type)) {",
          "content_same": false
        },
        {
          "line": 1322,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(h->mb, ptr, 256)",
          "old_line_content": "        if(CHROMA){",
          "new_line_content": "        memcpy(h->mb, ptr, 256); ptr+=256;",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(h->mb+128, ptr, 128)",
          "old_line_content": "        }",
          "new_line_content": "            memcpy(h->mb+128, ptr, 128); ptr+=128;",
          "content_same": false
        },
        {
          "line": 1327,
          "old_api": null,
          "new_api": "ff_init_cabac_decoder",
          "old_text": null,
          "new_text": "ff_init_cabac_decoder(&h->cabac, ptr, h->cabac.bytestream_end - ptr)",
          "old_line_content": "",
          "new_line_content": "        ff_init_cabac_decoder(&h->cabac, ptr, h->cabac.bytestream_end - ptr);",
          "content_same": false
        },
        {
          "line": 1335,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(h->non_zero_count[mb_xy], 16, 32)",
          "old_line_content": "        s->current_picture.mb_type[mb_xy]= mb_type;",
          "new_line_content": "        memset(h->non_zero_count[mb_xy], 16, 32);",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": null,
          "new_api": "fill_decode_caches",
          "old_text": null,
          "new_text": "fill_decode_caches(h, mb_type)",
          "old_line_content": "",
          "new_line_content": "    fill_decode_caches(h, mb_type);",
          "content_same": false
        },
        {
          "line": 1348,
          "old_api": null,
          "new_api": "IS_INTRA",
          "old_text": null,
          "new_text": "IS_INTRA( mb_type )",
          "old_line_content": "        int i, pred_mode;",
          "new_line_content": "    if( IS_INTRA( mb_type ) ) {",
          "content_same": false
        },
        {
          "line": 1351,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[399 + h->neighbor_transform_size] )",
          "old_line_content": "                mb_type |= MB_TYPE_8x8DCT;",
          "new_line_content": "            if( dct8x8_allowed && get_cabac_noinline( &h->cabac, &h->cabac_state[399 + h->neighbor_transform_size] ) ) {",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle( &h->intra4x4_pred_mode_cache[ scan8[i] ], 2, 2, 8, mode, 1 )",
          "old_line_content": "                }",
          "new_line_content": "                    fill_rectangle( &h->intra4x4_pred_mode_cache[ scan8[i] ], 2, 2, 8, mode, 1 );",
          "content_same": false
        },
        {
          "line": 1361,
          "old_api": null,
          "new_api": "decode_cabac_mb_intra4x4_pred_mode",
          "old_text": null,
          "new_text": "decode_cabac_mb_intra4x4_pred_mode( h, pred )",
          "old_line_content": "",
          "new_line_content": "                    h->intra4x4_pred_mode_cache[ scan8[i] ] = decode_cabac_mb_intra4x4_pred_mode( h, pred );",
          "content_same": false
        },
        {
          "line": 1367,
          "old_api": null,
          "new_api": "ff_h264_check_intra4x4_pred_mode",
          "old_text": null,
          "new_text": "ff_h264_check_intra4x4_pred_mode(h)",
          "old_line_content": "        } else {",
          "new_line_content": "            if( ff_h264_check_intra4x4_pred_mode(h) < 0 ) return -1;",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": null,
          "new_api": "ff_h264_check_intra_pred_mode",
          "old_text": null,
          "new_text": "ff_h264_check_intra_pred_mode( h, h->intra16x16_pred_mode )",
          "old_line_content": "            if( h->intra16x16_pred_mode < 0 ) return -1;",
          "new_line_content": "            h->intra16x16_pred_mode= ff_h264_check_intra_pred_mode( h, h->intra16x16_pred_mode );",
          "content_same": false
        },
        {
          "line": 1374,
          "old_api": null,
          "new_api": "decode_cabac_mb_chroma_pre_mode",
          "old_text": null,
          "new_text": "decode_cabac_mb_chroma_pre_mode( h )",
          "old_line_content": "",
          "new_line_content": "            pred_mode                        = decode_cabac_mb_chroma_pre_mode( h );",
          "content_same": false
        },
        {
          "line": 1376,
          "old_api": null,
          "new_api": "ff_h264_check_intra_pred_mode",
          "old_text": null,
          "new_text": "ff_h264_check_intra_pred_mode( h, pred_mode )",
          "old_line_content": "            if( pred_mode < 0 ) return -1;",
          "new_line_content": "            pred_mode= ff_h264_check_intra_pred_mode( h, pred_mode );",
          "content_same": false
        },
        {
          "line": 1385,
          "old_api": null,
          "new_api": "decode_cabac_b_mb_sub_type",
          "old_text": null,
          "new_text": "decode_cabac_b_mb_sub_type( h )",
          "old_line_content": "                sub_partition_count[i]= b_sub_mb_type_info[ h->sub_mb_type[i] ].partition_count;",
          "new_line_content": "                h->sub_mb_type[i] = decode_cabac_b_mb_sub_type( h );",
          "content_same": false
        },
        {
          "line": 1389,
          "old_api": null,
          "new_api": "IS_DIRECT",
          "old_text": null,
          "new_text": "IS_DIRECT(h->sub_mb_type[0] | h->sub_mb_type[1] |\n                          h->sub_mb_type[2] | h->sub_mb_type[3])",
          "old_line_content": "                          h->sub_mb_type[2] | h->sub_mb_type[3]) ) {",
          "new_line_content": "            if( IS_DIRECT(h->sub_mb_type[0] | h->sub_mb_type[1] |",
          "content_same": false
        },
        {
          "line": 1391,
          "old_api": null,
          "new_api": "ff_h264_pred_direct_motion",
          "old_text": null,
          "new_text": "ff_h264_pred_direct_motion(h, &mb_type)",
          "old_line_content": "                h->ref_cache[0][scan8[4]] =",
          "new_line_content": "                ff_h264_pred_direct_motion(h, &mb_type);",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle( &h->direct_cache[scan8[4*i]], 2, 2, 8, (h->sub_mb_type[i]>>1)&0xFF, 1 )",
          "old_line_content": "            }",
          "new_line_content": "                        fill_rectangle( &h->direct_cache[scan8[4*i]], 2, 2, 8, (h->sub_mb_type[i]>>1)&0xFF, 1 );",
          "content_same": false
        },
        {
          "line": 1401,
          "old_api": null,
          "new_api": "decode_cabac_p_mb_sub_type",
          "old_text": null,
          "new_text": "decode_cabac_p_mb_sub_type( h )",
          "old_line_content": "                sub_partition_count[i]= p_sub_mb_type_info[ h->sub_mb_type[i] ].partition_count;",
          "new_line_content": "                h->sub_mb_type[i] = decode_cabac_p_mb_sub_type( h );",
          "content_same": false
        },
        {
          "line": 1410,
          "old_api": null,
          "new_api": "IS_DIR",
          "old_text": null,
          "new_text": "IS_DIR(h->sub_mb_type[i], 0, list)",
          "old_line_content": "                        if( h->ref_count[list] > 1 ){",
          "new_line_content": "                    if(IS_DIR(h->sub_mb_type[i], 0, list)){",
          "content_same": false
        },
        {
          "line": 1412,
          "old_api": null,
          "new_api": "decode_cabac_mb_ref",
          "old_text": null,
          "new_text": "decode_cabac_mb_ref( h, list, 4*i )",
          "old_line_content": "                            if(ref[list][i] >= (unsigned)h->ref_count[list]){",
          "new_line_content": "                            ref[list][i] = decode_cabac_mb_ref( h, list, 4*i );",
          "content_same": false
        },
        {
          "line": 1414,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref[list][i], h->ref_count[list])",
          "old_line_content": "                                return -1;",
          "new_line_content": "                                av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref[list][i], h->ref_count[list]);",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": null,
          "new_api": "get_dct8x8_allowed",
          "old_text": null,
          "new_text": "get_dct8x8_allowed(h)",
          "old_line_content": "",
          "new_line_content": "            dct8x8_allowed = get_dct8x8_allowed(h);",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(h->mvd_cache[list][scan8[4*i]], 2, 2, 8, 0, 2)",
          "old_line_content": "                    continue;",
          "new_line_content": "                    fill_rectangle(h->mvd_cache[list][scan8[4*i]], 2, 2, 8, 0, 2);",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[ctxbase] )",
          "old_line_content": "        if( mvd < 4 )",
          "new_line_content": "    while( mvd < 9 && get_cabac( &h->cabac, &h->cabac_state[ctxbase] ) ) {",
          "content_same": false
        },
        {
          "line": 1438,
          "old_api": null,
          "new_api": "IS_DIRECT",
          "old_text": null,
          "new_text": "IS_DIRECT(h->sub_mb_type[i])",
          "old_line_content": "                    const int sub_mb_type= h->sub_mb_type[i];",
          "new_line_content": "                if(IS_DIR(h->sub_mb_type[i], 0, list) && !IS_DIRECT(h->sub_mb_type[i])){",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": null,
          "new_api": "get_cabac_bypass",
          "old_text": null,
          "new_text": "get_cabac_bypass( &h->cabac )",
          "old_line_content": "            mvd += 1 << k;",
          "new_line_content": "        while( get_cabac_bypass( &h->cabac ) ) {",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(h->s.avctx, AV_LOG_ERROR, \"overflow in decode_cabac_mb_mvd\\n\")",
          "old_line_content": "                return INT_MIN;",
          "new_line_content": "                av_log(h->s.avctx, AV_LOG_ERROR, \"overflow in decode_cabac_mb_mvd\\n\");",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": null,
          "new_api": "tprintf",
          "old_text": null,
          "new_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "old_line_content": "",
          "new_line_content": "                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "content_same": false
        },
        {
          "line": 1451,
          "old_api": null,
          "new_api": "IS_SUB_8X8",
          "old_text": null,
          "new_text": "IS_SUB_8X8(sub_mb_type)",
          "old_line_content": "                            mv_cache[ 1 ][0]=",
          "new_line_content": "                        if(IS_SUB_8X8(sub_mb_type)){",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": null,
          "new_api": "get_cabac_bypass",
          "old_text": null,
          "new_text": "get_cabac_bypass( &h->cabac )",
          "old_line_content": "        }",
          "new_line_content": "            mvd += get_cabac_bypass( &h->cabac )<<k;",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": null,
          "new_api": "get_cabac_bypass_sign",
          "old_text": null,
          "new_text": "get_cabac_bypass_sign( &h->cabac, -mvd )",
          "old_line_content": "}",
          "new_line_content": "    return get_cabac_bypass_sign( &h->cabac, -mvd );",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": null,
          "new_api": "IS_SUB_8X4",
          "old_text": null,
          "new_text": "IS_SUB_8X4(sub_mb_type)",
          "old_line_content": "                            mv_cache[ 1 ][0]= mx;",
          "new_line_content": "                        }else if(IS_SUB_8X4(sub_mb_type)){",
          "content_same": false
        },
        {
          "line": 1467,
          "old_api": null,
          "new_api": "IS_SUB_4X8",
          "old_text": null,
          "new_text": "IS_SUB_4X8(sub_mb_type)",
          "old_line_content": "                            mv_cache[ 8 ][0]= mx;",
          "new_line_content": "                        }else if(IS_SUB_4X8(sub_mb_type)){",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(h->mvd_cache[list][ scan8[4*i] ], 2, 2, 8, 0, 2)",
          "old_line_content": "                }",
          "new_line_content": "                    fill_rectangle(h->mvd_cache[list][ scan8[4*i] ], 2, 2, 8, 0, 2);",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(cat == 1 || cat == 2 || cat == 4)",
          "old_line_content": "        nza = h->non_zero_count_cache[scan8[idx] - 1];",
          "new_line_content": "        assert(cat == 1 || cat == 2 || cat == 4);",
          "content_same": false
        },
        {
          "line": 1489,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(h->mvd_cache[1][scan8[0]], 4, 4, 8, 0, 2)",
          "old_line_content": "        dct8x8_allowed &= h->sps.direct_8x8_inference_flag;",
          "new_line_content": "        fill_rectangle(h->mvd_cache[1][scan8[0]], 4, 4, 8, 0, 2);",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": null,
          "new_api": "IS_16X16",
          "old_text": null,
          "new_text": "IS_16X16(mb_type)",
          "old_line_content": "            for(list=0; list<h->list_count; list++){",
          "new_line_content": "        if(IS_16X16(mb_type)){",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": null,
          "new_api": "IS_DIR",
          "old_text": null,
          "new_text": "IS_DIR(mb_type, 0, list)",
          "old_line_content": "                    int ref;",
          "new_line_content": "                if(IS_DIR(mb_type, 0, list)){",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": null,
          "new_api": "DECLARE_ASM_CONST",
          "old_text": null,
          "new_text": "DECLARE_ASM_CONST(1, uint8_t, last_coeff_flag_offset_8x8)",
          "old_line_content": "    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,",
          "new_line_content": "DECLARE_ASM_CONST(1, uint8_t, last_coeff_flag_offset_8x8)[63] = {",
          "content_same": false
        },
        {
          "line": 1498,
          "old_api": null,
          "new_api": "decode_cabac_mb_ref",
          "old_text": null,
          "new_text": "decode_cabac_mb_ref(h, list, 0)",
          "old_line_content": "                        if(ref >= (unsigned)h->ref_count[list]){",
          "new_line_content": "                        ref= decode_cabac_mb_ref(h, list, 0);",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list])",
          "old_line_content": "                            return -1;",
          "new_line_content": "                            av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);",
          "content_same": false
        },
        {
          "line": 1505,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, ref, 1)",
          "old_line_content": "                }else",
          "new_line_content": "                        fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, ref, 1);",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, (uint8_t)LIST_NOT_USED, 1)",
          "old_line_content": "            }",
          "new_line_content": "                    fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, (uint8_t)LIST_NOT_USED, 1); //FIXME factorize and the other fill_rect below too",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": null,
          "new_api": "IS_DIR",
          "old_text": null,
          "new_text": "IS_DIR(mb_type, 0, list)",
          "old_line_content": "                    int mx,my,mpx,mpy;",
          "new_line_content": "                if(IS_DIR(mb_type, 0, list)){",
          "content_same": false
        },
        {
          "line": 1514,
          "old_api": null,
          "new_api": "tprintf",
          "old_text": null,
          "new_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "old_line_content": "",
          "new_line_content": "                    tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "content_same": false
        },
        {
          "line": 1517,
          "old_api": null,
          "new_api": "pack16to32",
          "old_text": null,
          "new_text": "pack16to32(mx,my)",
          "old_line_content": "                }else",
          "new_line_content": "                    fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, pack16to32(mx,my), 4);",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, 0, 4)",
          "old_line_content": "            }",
          "new_line_content": "                    fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, 0, 4);",
          "content_same": false
        },
        {
          "line": 1522,
          "old_api": null,
          "new_api": "IS_16X8",
          "old_text": null,
          "new_text": "IS_16X8(mb_type)",
          "old_line_content": "            for(list=0; list<h->list_count; list++){",
          "new_line_content": "        else if(IS_16X8(mb_type)){",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": null,
          "new_api": "IS_DIR",
          "old_text": null,
          "new_text": "IS_DIR(mb_type, i, list)",
          "old_line_content": "                            int ref;",
          "new_line_content": "                        if(IS_DIR(mb_type, i, list)){",
          "content_same": false
        },
        {
          "line": 1528,
          "old_api": null,
          "new_api": "decode_cabac_mb_ref",
          "old_text": null,
          "new_text": "decode_cabac_mb_ref( h, list, 8*i )",
          "old_line_content": "                                if(ref >= (unsigned)h->ref_count[list]){",
          "new_line_content": "                                ref= decode_cabac_mb_ref( h, list, 8*i );",
          "content_same": false
        },
        {
          "line": 1530,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list])",
          "old_line_content": "                                    return -1;",
          "new_line_content": "                                    av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);",
          "content_same": false
        },
        {
          "line": 1535,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, ref, 1)",
          "old_line_content": "                        }else",
          "new_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, ref, 1);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1536,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, (LIST_NOT_USED&0xFF), 1)",
          "new_text": null,
          "old_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, (LIST_NOT_USED&0xFF), 1);",
          "new_line_content": "                        }else",
          "content_same": false
        },
        {
          "line": 1541,
          "old_api": "IS_DIR",
          "new_api": null,
          "old_text": "IS_DIR(mb_type, i, list)",
          "new_text": null,
          "old_line_content": "                    if(IS_DIR(mb_type, i, list)){",
          "new_line_content": "                for(i=0; i<2; i++){",
          "content_same": false
        },
        {
          "line": 1543,
          "old_api": "pred_16x8_motion",
          "new_api": null,
          "old_text": "pred_16x8_motion(h, 8*i, list, h->ref_cache[list][scan8[0] + 16*i], &mx, &my)",
          "new_text": null,
          "old_line_content": "                        pred_16x8_motion(h, 8*i, list, h->ref_cache[list][scan8[0] + 16*i], &mx, &my);",
          "new_line_content": "                        int mx,my,mpx,mpy;",
          "content_same": false
        },
        {
          "line": 1547,
          "old_api": "pack8to16",
          "new_api": null,
          "old_text": "pack8to16(mpx,mpy)",
          "new_text": null,
          "old_line_content": "                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack8to16(mpx,mpy), 2);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(h->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 2)",
          "new_text": null,
          "old_line_content": "                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 2);",
          "new_line_content": "                    }else{",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": "IS_8X16",
          "new_api": null,
          "old_text": "IS_8X16(mb_type)",
          "new_text": null,
          "old_line_content": "            assert(IS_8X16(mb_type));",
          "new_line_content": "        }else{",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": "IS_DIR",
          "new_api": null,
          "old_text": "IS_DIR(mb_type, i, list)",
          "new_text": null,
          "old_line_content": "                        if(IS_DIR(mb_type, i, list)){ //FIXME optimize",
          "new_line_content": "                    for(i=0; i<2; i++){",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": "decode_cabac_mb_ref",
          "new_api": null,
          "old_text": "decode_cabac_mb_ref( h, list, 4*i )",
          "new_text": null,
          "old_line_content": "                                ref= decode_cabac_mb_ref( h, list, 4*i );",
          "new_line_content": "                            if(h->ref_count[list] > 1){",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list])",
          "new_text": null,
          "old_line_content": "                                    av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);",
          "new_line_content": "                                if(ref >= (unsigned)h->ref_count[list]){",
          "content_same": false
        },
        {
          "line": 1569,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, ref, 1)",
          "new_text": null,
          "old_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, ref, 1);",
          "new_line_content": "                                ref=0;",
          "content_same": false
        },
        {
          "line": 1571,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, (LIST_NOT_USED&0xFF), 1)",
          "new_text": null,
          "old_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, (LIST_NOT_USED&0xFF), 1);",
          "new_line_content": "                        }else",
          "content_same": false
        },
        {
          "line": 1061,
          "old_api": "get_cabac_cbf_ctx",
          "new_api": null,
          "old_text": "get_cabac_cbf_ctx( h, cat, n, is_dc )",
          "new_text": null,
          "old_line_content": "        if( get_cabac( CC, &h->cabac_state[85 + get_cabac_cbf_ctx( h, cat, n, is_dc ) ] ) == 0 ) {",
          "new_line_content": "    if( is_dc || cat != 5 ) {",
          "content_same": false
        },
        {
          "line": 1576,
          "old_api": "IS_DIR",
          "new_api": null,
          "old_text": "IS_DIR(mb_type, i, list)",
          "new_text": null,
          "old_line_content": "                    if(IS_DIR(mb_type, i, list)){",
          "new_line_content": "                for(i=0; i<2; i++){",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": "pred_8x16_motion",
          "new_api": null,
          "old_text": "pred_8x16_motion(h, i*4, list, h->ref_cache[list][ scan8[0] + 2*i ], &mx, &my)",
          "new_text": null,
          "old_line_content": "                        pred_8x16_motion(h, i*4, list, h->ref_cache[list][ scan8[0] + 2*i ], &mx, &my);",
          "new_line_content": "                        int mx,my,mpx,mpy;",
          "content_same": false
        },
        {
          "line": 1581,
          "old_api": "tprintf",
          "new_api": null,
          "old_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "new_text": null,
          "old_line_content": "                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1585,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(h->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 2)",
          "new_text": null,
          "old_line_content": "                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 2);",
          "new_line_content": "                    }else{",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": "IS_INTER",
          "new_api": null,
          "old_text": "IS_INTER( mb_type )",
          "new_text": null,
          "old_line_content": "   if( IS_INTER( mb_type ) ) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1595,
          "old_api": "write_back_motion",
          "new_api": null,
          "old_text": "write_back_motion( h, mb_type )",
          "new_text": null,
          "old_line_content": "        write_back_motion( h, mb_type );",
          "new_line_content": "        h->chroma_pred_mode_table[mb_xy] = 0;",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": "IS_INTRA16x16",
          "new_api": null,
          "old_text": "IS_INTRA16x16( mb_type )",
          "new_text": null,
          "old_line_content": "    if( !IS_INTRA16x16( mb_type ) ) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": "decode_cabac_mb_cbp_chroma",
          "new_api": null,
          "old_text": "decode_cabac_mb_cbp_chroma( h )",
          "new_text": null,
          "old_line_content": "            cbp |= decode_cabac_mb_cbp_chroma( h ) << 4;",
          "new_line_content": "        if(CHROMA)",
          "content_same": false
        },
        {
          "line": 1606,
          "old_api": "IS_INTRA",
          "new_api": null,
          "old_text": "IS_INTRA( mb_type )",
          "new_text": null,
          "old_line_content": "    if( dct8x8_allowed && (cbp&15) && !IS_INTRA( mb_type ) ) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": "decode_significance_8x8_x86",
          "new_api": null,
          "old_text": "decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index, sig_off)",
          "new_text": null,
          "old_line_content": "        coeff_count= decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index, sig_off);",
          "new_line_content": "#if ARCH_X86 && HAVE_7REGS && HAVE_EBX_AVAILABLE && !defined(BROKEN_RELOCATIONS)",
          "content_same": false
        },
        {
          "line": 1611,
          "old_api": "IS_INTRA16x16",
          "new_api": null,
          "old_text": "IS_INTRA16x16( mb_type )",
          "new_text": null,
          "old_line_content": "    if( cbp || IS_INTRA16x16( mb_type ) ) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "decode_significance_x86",
          "new_api": null,
          "old_text": "decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index)",
          "new_text": null,
          "old_line_content": "        coeff_count= decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": "DECODE_SIGNIFICANCE",
          "new_api": null,
          "old_text": "DECODE_SIGNIFICANCE( 63, sig_off[last], last_coeff_flag_offset_8x8[last] )",
          "new_text": null,
          "old_line_content": "        DECODE_SIGNIFICANCE( 63, sig_off[last], last_coeff_flag_offset_8x8[last] );",
          "new_line_content": "#else",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": "IS_INTERLACED",
          "new_api": null,
          "old_text": "IS_INTERLACED(mb_type)",
          "new_text": null,
          "old_line_content": "        if(IS_INTERLACED(mb_type)){",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": "DECODE_SIGNIFICANCE",
          "new_api": null,
          "old_text": "DECODE_SIGNIFICANCE( max_coeff - 1, last, last )",
          "new_text": null,
          "old_line_content": "        DECODE_SIGNIFICANCE( max_coeff - 1, last, last );",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(coeff_count > 0)",
          "new_text": null,
          "old_line_content": "    assert(coeff_count > 0);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1626,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[60 + (h->last_qscale_diff != 0)])",
          "new_text": null,
          "old_line_content": "        if(get_cabac_noinline( &h->cabac, &h->cabac_state[60 + (h->last_qscale_diff != 0)])){",
          "new_line_content": "        // decode_cabac_mb_dqp",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1)",
          "new_text": null,
          "old_line_content": "            fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1);",
          "new_line_content": "        if( cat == 5 )",
          "content_same": false
        },
        {
          "line": 1630,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[60 + ctx] )",
          "new_text": null,
          "old_line_content": "            while( get_cabac_noinline( &h->cabac, &h->cabac_state[60 + ctx] ) ) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert( cat == 1 || cat == 2 || cat == 4 )",
          "new_text": null,
          "old_line_content": "            assert( cat == 1 || cat == 2 || cat == 4 );",
          "new_line_content": "        else {",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(h->s.avctx, AV_LOG_ERROR, \"cabac decode of qscale diff failed at %d %d\\n\", s->mb_x, s->mb_y)",
          "new_text": null,
          "old_line_content": "                    av_log(h->s.avctx, AV_LOG_ERROR, \"cabac decode of qscale diff failed at %d %d\\n\", s->mb_x, s->mb_y);",
          "new_line_content": "                if(val > 102){ //prevent infinite loop",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( CC, ctx )",
          "new_text": null,
          "old_line_content": "        if( get_cabac( CC, ctx ) == 0 ) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": "get_cabac_bypass_sign",
          "new_api": null,
          "old_text": "get_cabac_bypass_sign( CC, -1)",
          "new_text": null,
          "old_line_content": "                block[j] = get_cabac_bypass_sign( CC, -1);",
          "new_line_content": "            if( is_dc ) {",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": "get_cabac_bypass_sign",
          "new_api": null,
          "old_text": "get_cabac_bypass_sign( CC, -qmul[j])",
          "new_text": null,
          "old_line_content": "                block[j] = (get_cabac_bypass_sign( CC, -qmul[j]) + 32) >> 6;",
          "new_line_content": "            }else{",
          "content_same": false
        },
        {
          "line": 1649,
          "old_api": "get_chroma_qp",
          "new_api": null,
          "old_text": "get_chroma_qp(h, 0, s->qscale)",
          "new_text": null,
          "old_line_content": "            h->chroma_qp[0] = get_chroma_qp(h, 0, s->qscale);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( CC, ctx )",
          "new_text": null,
          "old_line_content": "            while( coeff_abs < 15 && get_cabac( CC, ctx ) ) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1654,
          "old_api": "IS_INTRA16x16",
          "new_api": null,
          "old_text": "IS_INTRA16x16( mb_type )",
          "new_text": null,
          "old_line_content": "        if( IS_INTRA16x16( mb_type ) ) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": "decode_cabac_residual",
          "new_api": null,
          "old_text": "decode_cabac_residual( h, h->mb, 0, 0, dc_scan, NULL, 16)",
          "new_text": null,
          "old_line_content": "            decode_cabac_residual( h, h->mb, 0, 0, dc_scan, NULL, 16);",
          "new_line_content": "            //av_log( s->avctx, AV_LOG_ERROR, \"INTRA16x16 DC\\n\" );",
          "content_same": false
        },
        {
          "line": 1147,
          "old_api": "get_cabac_bypass",
          "new_api": null,
          "old_text": "get_cabac_bypass( CC )",
          "new_text": null,
          "old_line_content": "                while( get_cabac_bypass( CC ) ) {",
          "new_line_content": "                int j = 0;",
          "content_same": false
        },
        {
          "line": 1663,
          "old_api": "decode_cabac_residual",
          "new_api": null,
          "old_text": "decode_cabac_residual(h, h->mb + 16*i, 1, i, scan + 1, qmul, 15)",
          "new_text": null,
          "old_line_content": "                    decode_cabac_residual(h, h->mb + 16*i, 1, i, scan + 1, qmul, 15);",
          "new_line_content": "                    //av_log( s->avctx, AV_LOG_ERROR, \"INTRA16x16 AC:%d\\n\", i );",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": "get_cabac_bypass",
          "new_api": null,
          "old_text": "get_cabac_bypass( CC )",
          "new_text": null,
          "old_line_content": "                    coeff_abs += coeff_abs + get_cabac_bypass( CC );",
          "new_line_content": "                while( j-- ) {",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(&h->non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1)",
          "new_text": null,
          "old_line_content": "                fill_rectangle(&h->non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1);",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "get_cabac_bypass_sign",
          "new_api": null,
          "old_text": "get_cabac_bypass_sign( CC, -coeff_abs )",
          "new_text": null,
          "old_line_content": "                block[j] = get_cabac_bypass_sign( CC, -coeff_abs );",
          "new_line_content": "            if( is_dc ) {",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": "IS_8x8DCT",
          "new_api": null,
          "old_text": "IS_8x8DCT(mb_type)",
          "new_text": null,
          "old_line_content": "                    if( IS_8x8DCT(mb_type) ) {",
          "new_line_content": "                if( cbp & (1<<i8x8) ) {",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": "get_cabac_bypass_sign",
          "new_api": null,
          "old_text": "get_cabac_bypass_sign( CC, -coeff_abs )",
          "new_text": null,
          "old_line_content": "                block[j] = (get_cabac_bypass_sign( CC, -coeff_abs ) * qmul[j] + 32) >> 6;",
          "new_line_content": "            }else{",
          "content_same": false
        },
        {
          "line": 1676,
          "old_api": "IS_INTRA",
          "new_api": null,
          "old_text": "IS_INTRA( mb_type )",
          "new_text": null,
          "old_line_content": "                        qmul = h->dequant4_coeff[IS_INTRA( mb_type ) ? 0:3][s->qscale];",
          "new_line_content": "                    } else {",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": "decode_cabac_residual",
          "new_api": null,
          "old_text": "decode_cabac_residual(h, h->mb + 16*index, 2, index, scan, qmul, 16)",
          "new_text": null,
          "old_line_content": "                            decode_cabac_residual(h, h->mb + 16*index, 2, index, scan, qmul, 16);",
          "new_line_content": "//START_TIMER",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": "decode_cabac_residual_internal",
          "new_api": null,
          "old_text": "decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 1)",
          "new_text": null,
          "old_line_content": "    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 1);",
          "new_line_content": "static void decode_cabac_residual_dc( H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff ) {",
          "content_same": false
        },
        {
          "line": 1179,
          "old_api": "decode_cabac_residual_internal",
          "new_api": null,
          "old_text": "decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 0)",
          "new_text": null,
          "old_line_content": "    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 0);",
          "new_line_content": "static void decode_cabac_residual_nondc( H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff ) {",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": "decode_cabac_residual",
          "new_api": null,
          "old_text": "decode_cabac_residual(h, h->mb + 256 + 16*4*c, 3, c, chroma_dc_scan, NULL, 4)",
          "new_text": null,
          "old_line_content": "                decode_cabac_residual(h, h->mb + 256 + 16*4*c, 3, c, chroma_dc_scan, NULL, 4);",
          "new_line_content": "                //av_log( s->avctx, AV_LOG_ERROR, \"INTRA C%d-DC\\n\",c );",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": "decode_cabac_residual_internal",
          "new_api": null,
          "old_text": "decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, cat == 0 || cat == 3)",
          "new_text": null,
          "old_line_content": "    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, cat == 0 || cat == 3);",
          "new_line_content": "#if CONFIG_SMALL",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": "decode_cabac_residual_dc",
          "new_api": null,
          "old_text": "decode_cabac_residual_dc(h, block, cat, n, scantable, qmul, max_coeff)",
          "new_text": null,
          "old_line_content": "    if( cat == 0 || cat == 3 ) decode_cabac_residual_dc(h, block, cat, n, scantable, qmul, max_coeff);",
          "new_line_content": "#else",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": "IS_INTRA",
          "new_api": null,
          "old_text": "IS_INTRA( mb_type )",
          "new_text": null,
          "old_line_content": "                qmul = h->dequant4_coeff[c+1+(IS_INTRA( mb_type ) ? 0:3)][h->chroma_qp[c]];",
          "new_line_content": "            for( c = 0; c < 2; c++ ) {",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": "decode_cabac_residual",
          "new_api": null,
          "old_text": "decode_cabac_residual(h, h->mb + 16*index, 4, index, scan + 1, qmul, 15)",
          "new_text": null,
          "old_line_content": "                    decode_cabac_residual(h, h->mb + 16*index, 4, index, scan + 1, qmul, 15);",
          "new_line_content": "                    //av_log( s->avctx, AV_LOG_ERROR, \"INTRA C%d-AC %d\\n\",c, index - 16 );",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": "tprintf",
          "new_api": null,
          "old_text": "tprintf(s->avctx, \"pic:%d mb:%d/%d\\n\", h->frame_num, s->mb_x, s->mb_y)",
          "new_text": null,
          "old_line_content": "    tprintf(s->avctx, \"pic:%d mb:%d/%d\\n\", h->frame_num, s->mb_x, s->mb_y);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1717,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1)",
          "new_text": null,
          "old_line_content": "        fill_rectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1);",
          "new_line_content": "        uint8_t * const nnz= &h->non_zero_count_cache[0];",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": "decode_cabac_mb_skip",
          "new_api": null,
          "old_text": "decode_cabac_mb_skip( h, s->mb_x, s->mb_y )",
          "new_text": null,
          "old_line_content": "            skip = decode_cabac_mb_skip( h, s->mb_x, s->mb_y );",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": "write_back_non_zero_count",
          "new_api": null,
          "old_text": "write_back_non_zero_count(h)",
          "new_text": null,
          "old_line_content": "    write_back_non_zero_count(h);",
          "new_line_content": "    s->current_picture.qscale_table[mb_xy]= s->qscale;",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": "decode_cabac_mb_skip",
          "new_api": null,
          "old_text": "decode_cabac_mb_skip( h, s->mb_x, s->mb_y+1 )",
          "new_text": null,
          "old_line_content": "                h->next_mb_skipped = decode_cabac_mb_skip( h, s->mb_x, s->mb_y+1 );",
          "new_line_content": "                s->current_picture.mb_type[mb_xy] = MB_TYPE_SKIP;",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": "decode_cabac_field_decoding_flag",
          "new_api": null,
          "old_text": "decode_cabac_field_decoding_flag(h)",
          "new_text": null,
          "old_line_content": "                    h->mb_mbaff = h->mb_field_decoding_flag = decode_cabac_field_decoding_flag(h);",
          "new_line_content": "                if(!h->next_mb_skipped)",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": "decode_mb_skip",
          "new_api": null,
          "old_text": "decode_mb_skip(h)",
          "new_text": null,
          "old_line_content": "            decode_mb_skip(h);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": "decode_cabac_field_decoding_flag",
          "new_api": null,
          "old_text": "decode_cabac_field_decoding_flag(h)",
          "new_text": null,
          "old_line_content": "            h->mb_field_decoding_flag = decode_cabac_field_decoding_flag(h);",
          "new_line_content": "            h->mb_mbaff =",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": "fill_decode_neighbors",
          "new_api": null,
          "old_text": "fill_decode_neighbors(h, -(MB_FIELD))",
          "new_text": null,
          "old_line_content": "    fill_decode_neighbors(h, -(MB_FIELD));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(h->slice_type_nos == FF_B_TYPE)",
          "new_text": null,
          "old_line_content": "        assert(h->slice_type_nos == FF_B_TYPE);",
          "new_line_content": "        int ctx = 0;",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "IS_DIRECT",
          "new_api": null,
          "old_text": "IS_DIRECT( h->left_type[0]-1 )",
          "new_text": null,
          "old_line_content": "        if( !IS_DIRECT( h->left_type[0]-1 ) )",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": "IS_DIRECT",
          "new_api": null,
          "old_text": "IS_DIRECT( h->top_type-1 )",
          "new_text": null,
          "old_line_content": "        if( !IS_DIRECT( h->top_type-1 ) )",
          "new_line_content": "            ctx++;",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+ctx] )",
          "new_text": null,
          "old_line_content": "        if( !get_cabac_noinline( &h->cabac, &h->cabac_state[27+ctx] ) ){",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+3] )",
          "new_text": null,
          "old_line_content": "        }else if( !get_cabac_noinline( &h->cabac, &h->cabac_state[27+3] ) ) {",
          "new_line_content": "            mb_type= 0; /* B_Direct_16x16 */",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+4] )",
          "new_text": null,
          "old_line_content": "            bits = get_cabac_noinline( &h->cabac, &h->cabac_state[27+4] ) << 3;",
          "new_line_content": "            int bits;",
          "content_same": false
        },
        {
          "line": 1263,
          "old_api": "decode_cabac_intra_mb_type",
          "new_api": null,
          "old_text": "decode_cabac_intra_mb_type(h, 32, 0)",
          "new_text": null,
          "old_line_content": "                mb_type= decode_cabac_intra_mb_type(h, 32, 0);",
          "new_line_content": "            }else if( bits == 13 ){",
          "content_same": false
        },
        {
          "line": 1270,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] )",
          "new_text": null,
          "old_line_content": "                bits= ( bits<<1 ) | get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] );",
          "new_line_content": "            }else{",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[14] )",
          "new_text": null,
          "old_line_content": "        if( get_cabac_noinline( &h->cabac, &h->cabac_state[14] ) == 0 ) {",
          "new_line_content": "    } else if( h->slice_type_nos == FF_P_TYPE ) {",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[15] )",
          "new_text": null,
          "old_line_content": "            if( get_cabac_noinline( &h->cabac, &h->cabac_state[15] ) == 0 ) {",
          "new_line_content": "            /* P-type */",
          "content_same": false
        },
        {
          "line": 1281,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[16] )",
          "new_text": null,
          "old_line_content": "                mb_type= 3 * get_cabac_noinline( &h->cabac, &h->cabac_state[16] );",
          "new_line_content": "                /* P_L0_D16x16, P_8x8 */",
          "content_same": false
        },
        {
          "line": 1284,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[17] )",
          "new_text": null,
          "old_line_content": "                mb_type= 2 - get_cabac_noinline( &h->cabac, &h->cabac_state[17] );",
          "new_line_content": "                /* P_L0_D8x16, P_L0_D16x8 */",
          "content_same": false
        },
        {
          "line": 1289,
          "old_api": "decode_cabac_intra_mb_type",
          "new_api": null,
          "old_text": "decode_cabac_intra_mb_type(h, 17, 0)",
          "new_text": null,
          "old_line_content": "            mb_type= decode_cabac_intra_mb_type(h, 17, 0);",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 1293,
          "old_api": "decode_cabac_intra_mb_type",
          "new_api": null,
          "old_text": "decode_cabac_intra_mb_type(h, 3, 1)",
          "new_text": null,
          "old_line_content": "        mb_type= decode_cabac_intra_mb_type(h, 3, 1);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(h->slice_type_nos == FF_I_TYPE)",
          "new_text": null,
          "old_line_content": "        assert(h->slice_type_nos == FF_I_TYPE);",
          "new_line_content": "            mb_type--;",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": "IS_INTRA_PCM",
          "new_api": null,
          "old_text": "IS_INTRA_PCM(mb_type)",
          "new_text": null,
          "old_line_content": "    if(IS_INTRA_PCM(mb_type)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(h->mb, ptr, 256)",
          "new_text": null,
          "old_line_content": "        memcpy(h->mb, ptr, 256); ptr+=256;",
          "new_line_content": "        // The pixels are stored in the same order as levels in h->mb array.",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(h->mb+128, ptr, 128)",
          "new_text": null,
          "old_line_content": "            memcpy(h->mb+128, ptr, 128); ptr+=128;",
          "new_line_content": "        if(CHROMA){",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": "ff_init_cabac_decoder",
          "new_api": null,
          "old_text": "ff_init_cabac_decoder(&h->cabac, ptr, h->cabac.bytestream_end - ptr)",
          "new_text": null,
          "old_line_content": "        ff_init_cabac_decoder(&h->cabac, ptr, h->cabac.bytestream_end - ptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(h->non_zero_count[mb_xy], 16, 32)",
          "new_text": null,
          "old_line_content": "        memset(h->non_zero_count[mb_xy], 16, 32);",
          "new_line_content": "        // All coeffs are present",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": "fill_decode_caches",
          "new_api": null,
          "old_text": "fill_decode_caches(h, mb_type)",
          "new_text": null,
          "old_line_content": "    fill_decode_caches(h, mb_type);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1347,
          "old_api": "IS_INTRA",
          "new_api": null,
          "old_text": "IS_INTRA( mb_type )",
          "new_text": null,
          "old_line_content": "    if( IS_INTRA( mb_type ) ) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": "IS_INTRA4x4",
          "new_api": null,
          "old_text": "IS_INTRA4x4( mb_type )",
          "new_text": null,
          "old_line_content": "        if( IS_INTRA4x4( mb_type ) ) {",
          "new_line_content": "        int i, pred_mode;",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": "pred_intra_mode",
          "new_api": null,
          "old_text": "pred_intra_mode( h, i )",
          "new_text": null,
          "old_line_content": "                    int pred = pred_intra_mode( h, i );",
          "new_line_content": "                for( i = 0; i < 16; i+=4 ) {",
          "content_same": false
        },
        {
          "line": 1359,
          "old_api": "pred_intra_mode",
          "new_api": null,
          "old_text": "pred_intra_mode( h, i )",
          "new_text": null,
          "old_line_content": "                    int pred = pred_intra_mode( h, i );",
          "new_line_content": "                for( i = 0; i < 16; i++ ) {",
          "content_same": false
        },
        {
          "line": 1365,
          "old_api": "ff_h264_write_back_intra_pred_mode",
          "new_api": null,
          "old_text": "ff_h264_write_back_intra_pred_mode(h)",
          "new_text": null,
          "old_line_content": "            ff_h264_write_back_intra_pred_mode(h);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": "ff_h264_check_intra_pred_mode",
          "new_api": null,
          "old_text": "ff_h264_check_intra_pred_mode( h, h->intra16x16_pred_mode )",
          "new_text": null,
          "old_line_content": "            h->intra16x16_pred_mode= ff_h264_check_intra_pred_mode( h, h->intra16x16_pred_mode );",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 1373,
          "old_api": "decode_cabac_mb_chroma_pre_mode",
          "new_api": null,
          "old_text": "decode_cabac_mb_chroma_pre_mode( h )",
          "new_text": null,
          "old_line_content": "            pred_mode                        = decode_cabac_mb_chroma_pre_mode( h );",
          "new_line_content": "            h->chroma_pred_mode_table[mb_xy] =",
          "content_same": false
        },
        {
          "line": 1375,
          "old_api": "ff_h264_check_intra_pred_mode",
          "new_api": null,
          "old_text": "ff_h264_check_intra_pred_mode( h, pred_mode )",
          "new_text": null,
          "old_line_content": "            pred_mode= ff_h264_check_intra_pred_mode( h, pred_mode );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1384,
          "old_api": "decode_cabac_b_mb_sub_type",
          "new_api": null,
          "old_text": "decode_cabac_b_mb_sub_type( h )",
          "new_text": null,
          "old_line_content": "                h->sub_mb_type[i] = decode_cabac_b_mb_sub_type( h );",
          "new_line_content": "            for( i = 0; i < 4; i++ ) {",
          "content_same": false
        },
        {
          "line": 1388,
          "old_api": "IS_DIRECT",
          "new_api": null,
          "old_text": "IS_DIRECT(h->sub_mb_type[0] | h->sub_mb_type[1] |\n                          h->sub_mb_type[2] | h->sub_mb_type[3])",
          "new_text": null,
          "old_line_content": "            if( IS_DIRECT(h->sub_mb_type[0] | h->sub_mb_type[1] |",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": "ff_h264_pred_direct_motion",
          "new_api": null,
          "old_text": "ff_h264_pred_direct_motion(h, &mb_type)",
          "new_text": null,
          "old_line_content": "                ff_h264_pred_direct_motion(h, &mb_type);",
          "new_line_content": "                          h->sub_mb_type[2] | h->sub_mb_type[3]) ) {",
          "content_same": false
        },
        {
          "line": 1396,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle( &h->direct_cache[scan8[4*i]], 2, 2, 8, (h->sub_mb_type[i]>>1)&0xFF, 1 )",
          "new_text": null,
          "old_line_content": "                        fill_rectangle( &h->direct_cache[scan8[4*i]], 2, 2, 8, (h->sub_mb_type[i]>>1)&0xFF, 1 );",
          "new_line_content": "                    for( i = 0; i < 4; i++ )",
          "content_same": false
        },
        {
          "line": 1400,
          "old_api": "decode_cabac_p_mb_sub_type",
          "new_api": null,
          "old_text": "decode_cabac_p_mb_sub_type( h )",
          "new_text": null,
          "old_line_content": "                h->sub_mb_type[i] = decode_cabac_p_mb_sub_type( h );",
          "new_line_content": "            for( i = 0; i < 4; i++ ) {",
          "content_same": false
        },
        {
          "line": 1408,
          "old_api": "IS_DIRECT",
          "new_api": null,
          "old_text": "IS_DIRECT(h->sub_mb_type[i])",
          "new_text": null,
          "old_line_content": "                    if(IS_DIRECT(h->sub_mb_type[i])) continue;",
          "new_line_content": "                for( i = 0; i < 4; i++ ) {",
          "content_same": false
        },
        {
          "line": 1411,
          "old_api": "decode_cabac_mb_ref",
          "new_api": null,
          "old_text": "decode_cabac_mb_ref( h, list, 4*i )",
          "new_text": null,
          "old_line_content": "                            ref[list][i] = decode_cabac_mb_ref( h, list, 4*i );",
          "new_line_content": "                        if( h->ref_count[list] > 1 ){",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref[list][i], h->ref_count[list])",
          "new_text": null,
          "old_line_content": "                                av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref[list][i], h->ref_count[list]);",
          "new_line_content": "                            if(ref[list][i] >= (unsigned)h->ref_count[list]){",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": "get_dct8x8_allowed",
          "new_api": null,
          "old_text": "get_dct8x8_allowed(h)",
          "new_text": null,
          "old_line_content": "            dct8x8_allowed = get_dct8x8_allowed(h);",
          "new_line_content": "        if(dct8x8_allowed)",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": "IS_DIRECT",
          "new_api": null,
          "old_text": "IS_DIRECT(h->sub_mb_type[i])",
          "new_text": null,
          "old_line_content": "                if(IS_DIRECT(h->sub_mb_type[i])){",
          "new_line_content": "                h->ref_cache[list][ scan8[4*i]   ]=h->ref_cache[list][ scan8[4*i]+1 ];",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[ctxbase] )",
          "new_text": null,
          "old_line_content": "    while( mvd < 9 && get_cabac( &h->cabac, &h->cabac_state[ctxbase] ) ) {",
          "new_line_content": "    ctxbase+= 3;",
          "content_same": false
        },
        {
          "line": 1437,
          "old_api": "IS_DIRECT",
          "new_api": null,
          "old_text": "IS_DIRECT(h->sub_mb_type[i])",
          "new_text": null,
          "old_line_content": "                if(IS_DIR(h->sub_mb_type[i], 0, list) && !IS_DIRECT(h->sub_mb_type[i])){",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "get_cabac_bypass",
          "new_api": null,
          "old_text": "get_cabac_bypass( &h->cabac )",
          "new_text": null,
          "old_line_content": "        while( get_cabac_bypass( &h->cabac ) ) {",
          "new_line_content": "        int k = 3;",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(h->s.avctx, AV_LOG_ERROR, \"overflow in decode_cabac_mb_mvd\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(h->s.avctx, AV_LOG_ERROR, \"overflow in decode_cabac_mb_mvd\\n\");",
          "new_line_content": "            if(k>24){",
          "content_same": false
        },
        {
          "line": 1446,
          "old_api": "pred_motion",
          "new_api": null,
          "old_text": "pred_motion(h, index, block_width, list, h->ref_cache[list][ scan8[index] ], &mx, &my)",
          "new_text": null,
          "old_line_content": "                        pred_motion(h, index, block_width, list, h->ref_cache[list][ scan8[index] ], &mx, &my);",
          "new_line_content": "                        uint8_t (* mvd_cache)[2]= &h->mvd_cache[list][ scan8[index] ];",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": "IS_SUB_8X8",
          "new_api": null,
          "old_text": "IS_SUB_8X8(sub_mb_type)",
          "new_text": null,
          "old_line_content": "                        if(IS_SUB_8X8(sub_mb_type)){",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "get_cabac_bypass",
          "new_api": null,
          "old_text": "get_cabac_bypass( &h->cabac )",
          "new_text": null,
          "old_line_content": "            mvd += get_cabac_bypass( &h->cabac )<<k;",
          "new_line_content": "        while( k-- ) {",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "get_cabac_bypass_sign",
          "new_api": null,
          "old_text": "get_cabac_bypass_sign( &h->cabac, -mvd )",
          "new_text": null,
          "old_line_content": "    return get_cabac_bypass_sign( &h->cabac, -mvd );",
          "new_line_content": "        *mvda=mvd;",
          "content_same": false
        },
        {
          "line": 1460,
          "old_api": "IS_SUB_8X4",
          "new_api": null,
          "old_text": "IS_SUB_8X4(sub_mb_type)",
          "new_text": null,
          "old_line_content": "                        }else if(IS_SUB_8X4(sub_mb_type)){",
          "new_line_content": "                            mvd_cache[ 8 ][1]= mvd_cache[ 9 ][1]= mpy;",
          "content_same": false
        },
        {
          "line": 1466,
          "old_api": "IS_SUB_4X8",
          "new_api": null,
          "old_text": "IS_SUB_4X8(sub_mb_type)",
          "new_text": null,
          "old_line_content": "                        }else if(IS_SUB_4X8(sub_mb_type)){",
          "new_line_content": "                            mvd_cache[ 1 ][1]= mpy;",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(h->mv_cache [list][ scan8[4*i] ], 2, 2, 8, 0, 4)",
          "new_text": null,
          "old_line_content": "                    fill_rectangle(h->mv_cache [list][ scan8[4*i] ], 2, 2, 8, 0, 4);",
          "new_line_content": "                }else{",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(cat == 1 || cat == 2 || cat == 4)",
          "new_text": null,
          "old_line_content": "        assert(cat == 1 || cat == 2 || cat == 4);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1485,
          "old_api": "IS_DIRECT",
          "new_api": null,
          "old_text": "IS_DIRECT(mb_type)",
          "new_text": null,
          "old_line_content": "    } else if( IS_DIRECT(mb_type) ) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": "IS_16X16",
          "new_api": null,
          "old_text": "IS_16X16(mb_type)",
          "new_text": null,
          "old_line_content": "        if(IS_16X16(mb_type)){",
          "new_line_content": "        int list, i;",
          "content_same": false
        },
        {
          "line": 1494,
          "old_api": "IS_DIR",
          "new_api": null,
          "old_text": "IS_DIR(mb_type, 0, list)",
          "new_text": null,
          "old_line_content": "                if(IS_DIR(mb_type, 0, list)){",
          "new_line_content": "            for(list=0; list<h->list_count; list++){",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": "DECLARE_ASM_CONST",
          "new_api": null,
          "old_text": "DECLARE_ASM_CONST(1, uint8_t, last_coeff_flag_offset_8x8)",
          "new_text": null,
          "old_line_content": "DECLARE_ASM_CONST(1, uint8_t, last_coeff_flag_offset_8x8)[63] = {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": "decode_cabac_mb_ref",
          "new_api": null,
          "old_text": "decode_cabac_mb_ref(h, list, 0)",
          "new_text": null,
          "old_line_content": "                        ref= decode_cabac_mb_ref(h, list, 0);",
          "new_line_content": "                    if(h->ref_count[list] > 1){",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list])",
          "new_text": null,
          "old_line_content": "                            av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);",
          "new_line_content": "                        if(ref >= (unsigned)h->ref_count[list]){",
          "content_same": false
        },
        {
          "line": 1504,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, ref, 1)",
          "new_text": null,
          "old_line_content": "                        fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, ref, 1);",
          "new_line_content": "                        ref=0;",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, (uint8_t)LIST_NOT_USED, 1)",
          "new_text": null,
          "old_line_content": "                    fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, (uint8_t)LIST_NOT_USED, 1); //FIXME factorize and the other fill_rect below too",
          "new_line_content": "                }else",
          "content_same": false
        },
        {
          "line": 1509,
          "old_api": "IS_DIR",
          "new_api": null,
          "old_text": "IS_DIR(mb_type, 0, list)",
          "new_text": null,
          "old_line_content": "                if(IS_DIR(mb_type, 0, list)){",
          "new_line_content": "            for(list=0; list<h->list_count; list++){",
          "content_same": false
        },
        {
          "line": 1511,
          "old_api": "pred_motion",
          "new_api": null,
          "old_text": "pred_motion(h, 0, 4, list, h->ref_cache[list][ scan8[0] ], &mx, &my)",
          "new_text": null,
          "old_line_content": "                    pred_motion(h, 0, 4, list, h->ref_cache[list][ scan8[0] ], &mx, &my);",
          "new_line_content": "                    int mx,my,mpx,mpy;",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": "pack8to16",
          "new_api": null,
          "old_text": "pack8to16(mpx,mpy)",
          "new_text": null,
          "old_line_content": "                    fill_rectangle(h->mvd_cache[list][ scan8[0] ], 4, 4, 8, pack8to16(mpx,mpy), 2);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1518,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, 0, 4)",
          "new_text": null,
          "old_line_content": "                    fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, 0, 4);",
          "new_line_content": "                }else",
          "content_same": false
        },
        {
          "line": 1521,
          "old_api": "IS_16X8",
          "new_api": null,
          "old_text": "IS_16X8(mb_type)",
          "new_text": null,
          "old_line_content": "        else if(IS_16X8(mb_type)){",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1524,
          "old_api": "IS_DIR",
          "new_api": null,
          "old_text": "IS_DIR(mb_type, i, list)",
          "new_text": null,
          "old_line_content": "                        if(IS_DIR(mb_type, i, list)){",
          "new_line_content": "                    for(i=0; i<2; i++){",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": "decode_cabac_mb_ref",
          "new_api": null,
          "old_text": "decode_cabac_mb_ref( h, list, 8*i )",
          "new_text": null,
          "old_line_content": "                                ref= decode_cabac_mb_ref( h, list, 8*i );",
          "new_line_content": "                            if(h->ref_count[list] > 1){",
          "content_same": false
        },
        {
          "line": 1529,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list])",
          "new_text": null,
          "old_line_content": "                                    av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);",
          "new_line_content": "                                if(ref >= (unsigned)h->ref_count[list]){",
          "content_same": false
        },
        {
          "line": 1534,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, ref, 1)",
          "new_text": null,
          "old_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, ref, 1);",
          "new_line_content": "                                ref=0;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 25,
      "total_additions": 133,
      "total_deletions": 133,
      "total_api_changes": 291
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 2,
        "api_related_lines": 291,
        "non_api_lines": 2,
        "non_api_line_numbers": [
          915,
          916
        ]
      }
    },
    "api_calls_before": 216,
    "api_calls_after": 216,
    "diff_info": {
      "added_lines": 2,
      "removed_lines": 1,
      "total_diff_lines": 15
    }
  }
}