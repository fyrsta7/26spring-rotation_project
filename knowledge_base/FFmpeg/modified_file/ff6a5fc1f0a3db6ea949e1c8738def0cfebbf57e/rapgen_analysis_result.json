{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/ff6a5fc1f0a3db6ea949e1c8738def0cfebbf57e",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/ff6a5fc1f0a3db6ea949e1c8738def0cfebbf57e/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/ff6a5fc1f0a3db6ea949e1c8738def0cfebbf57e/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/ff6a5fc1f0a3db6ea949e1c8738def0cfebbf57e/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 622,
          "old_api": "av_free",
          "new_api": "av_malloc",
          "old_text": "av_free(*str)",
          "new_text": "av_malloc(size + 1)",
          "old_line_content": "    av_free(*str);",
          "new_line_content": "    if (!(*str = av_malloc(size + 1)))",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": "av_malloc",
          "new_api": "av_freep",
          "old_text": "av_malloc(size + 1)",
          "new_text": "av_freep(str)",
          "old_line_content": "    if (!(*str = av_malloc(size + 1)))",
          "new_line_content": "        av_freep(str);",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": "AVERROR",
          "new_api": "url_ftell",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "url_ftell(pb)",
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "    bin->pos  = url_ftell(pb);",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "url_ftell",
          "new_api": "AVERROR",
          "old_text": "url_ftell(pb)",
          "new_text": "AVERROR(EIO)",
          "old_line_content": "    bin->pos  = url_ftell(pb);",
          "new_line_content": "        return AVERROR(EIO);",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": "ebml_read_uint  (pb, length, data)",
          "new_api": "ebml_read_ascii (pb, length, data)",
          "old_text": "ebml_read_uint  (pb, length, data)",
          "new_text": "ebml_read_ascii (pb, length, data)",
          "old_line_content": "    case EBML_UINT:  res = ebml_read_uint  (pb, length, data);  break;",
          "new_line_content": "    case EBML_UTF8:  res = ebml_read_ascii (pb, length, data);  break;",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": "ebml_read_float (pb, length, data)",
          "new_api": "ebml_read_binary",
          "old_text": "ebml_read_float (pb, length, data)",
          "new_text": "ebml_read_binary(pb, length, data)",
          "old_line_content": "    case EBML_FLOAT: res = ebml_read_float (pb, length, data);  break;",
          "new_line_content": "    case EBML_BIN:   res = ebml_read_binary(pb, length, data);  break;",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "ebml_read_master",
          "new_api": "url_ftell",
          "old_text": "ebml_read_master(matroska, length)",
          "new_text": "url_ftell(matroska->ctx->pb)",
          "old_line_content": "    case EBML_NEST:  if ((res=ebml_read_master(matroska, length)) < 0)",
          "new_line_content": "                         matroska->segment_start = url_ftell(matroska->ctx->pb);",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": "ebml_parse_nest",
          "new_api": "AVERROR",
          "old_text": "ebml_parse_nest(matroska, syntax->def.n, data)",
          "new_text": "AVERROR(EIO)",
          "old_line_content": "                     return ebml_parse_nest(matroska, syntax->def.n, data);",
          "new_line_content": "    default:         return url_fseek(pb,length,SEEK_CUR)<0 ? AVERROR(EIO) : 0;",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EIO)",
          "new_text": "av_log(matroska->ctx, AV_LOG_ERROR, \"Invalid element\\n\")",
          "old_line_content": "    default:         return url_fseek(pb,length,SEEK_CUR)<0 ? AVERROR(EIO) : 0;",
          "new_line_content": "        av_log(matroska->ctx, AV_LOG_ERROR, \"Invalid element\\n\");",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": "FF_ARRAY_ELEMS",
          "new_api": "memcmp",
          "old_text": "FF_ARRAY_ELEMS(matroska_doctypes)",
          "new_text": "memcmp(p->buf+n, matroska_doctypes[i], probelen)",
          "old_line_content": "    for (i = 0; i < FF_ARRAY_ELEMS(matroska_doctypes); i++) {",
          "new_line_content": "            if (!memcmp(p->buf+n, matroska_doctypes[i], probelen))",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": "av_realloc",
          "new_api": "inflate",
          "old_text": "av_realloc(pkt_data, pkt_size)",
          "new_text": "inflate(&zstream, Z_NO_FLUSH)",
          "old_line_content": "            pkt_data = av_realloc(pkt_data, pkt_size);",
          "new_line_content": "            result = inflate(&zstream, Z_NO_FLUSH);",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "inflate",
          "new_api": "inflateEnd",
          "old_text": "inflate(&zstream, Z_NO_FLUSH)",
          "new_text": "inflateEnd(&zstream)",
          "old_line_content": "            result = inflate(&zstream, Z_NO_FLUSH);",
          "new_line_content": "        inflateEnd(&zstream);",
          "content_same": false
        },
        {
          "line": 950,
          "old_api": "av_realloc",
          "new_api": "BZ2_bzDecompress",
          "old_text": "av_realloc(pkt_data, pkt_size)",
          "new_text": "BZ2_bzDecompress(&bzstream)",
          "old_line_content": "            pkt_data = av_realloc(pkt_data, pkt_size);",
          "new_line_content": "            result = BZ2_bzDecompress(&bzstream);",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "BZ2_bzDecompress",
          "new_api": "BZ2_bzDecompressEnd",
          "old_text": "BZ2_bzDecompress(&bzstream)",
          "new_text": "BZ2_bzDecompressEnd(&bzstream)",
          "old_line_content": "            result = BZ2_bzDecompress(&bzstream);",
          "new_line_content": "        BZ2_bzDecompressEnd(&bzstream);",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": "av_realloc",
          "new_api": "av_destruct_packet",
          "old_text": "av_realloc(out->data, out->size+in->size)",
          "new_text": "av_destruct_packet(in)",
          "old_line_content": "    out->data = av_realloc(out->data, out->size+in->size);",
          "new_line_content": "    av_destruct_packet(in);",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": "memcpy",
          "new_api": "av_free",
          "old_text": "memcpy(out->data+out->size, in->data, in->size)",
          "new_text": "av_free(in)",
          "old_line_content": "    memcpy(out->data+out->size, in->data, in->size);",
          "new_line_content": "    av_free(in);",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": "snprintf",
          "new_api": "av_metadata_set2",
          "old_text": "snprintf(key, sizeof(key), \"%s/%s\", prefix, tags[i].name)",
          "new_text": "av_metadata_set2(metadata, key, tags[i].string, 0)",
          "old_line_content": "        if (prefix)  snprintf(key, sizeof(key), \"%s/%s\", prefix, tags[i].name);",
          "new_line_content": "        av_metadata_set2(metadata, key, tags[i].string, 0);",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": "matroska_convert_tag",
          "new_api": "av_strlcat",
          "old_text": "matroska_convert_tag(s, &tags[i].sub, metadata, key)",
          "new_text": "av_strlcat(key, \"-\", sizeof(key))",
          "old_line_content": "            matroska_convert_tag(s, &tags[i].sub, metadata, key);",
          "new_line_content": "            av_strlcat(key, \"-\", sizeof(key));",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": "av_strlcat",
          "new_api": "matroska_convert_tag",
          "old_text": "av_strlcat(key, lang, sizeof(key))",
          "new_text": "matroska_convert_tag(s, &tags[i].sub, metadata, key)",
          "old_line_content": "            av_strlcat(key, lang, sizeof(key));",
          "new_line_content": "                matroska_convert_tag(s, &tags[i].sub, metadata, key);",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": "ebml_parse",
          "new_api": "av_log",
          "old_text": "ebml_parse(matroska, ebml_syntax, &ebml)",
          "new_text": "av_log(matroska->ctx, AV_LOG_ERROR,\n               \"EBML header using unsupported features\\n\"\n               \"(EBML version %\"PRIu64\", doctype %s, doc version %\"PRIu64\")\\n\",\n               ebml.version, ebml.doctype, ebml.doctype_version)",
          "old_line_content": "    if (ebml_parse(matroska, ebml_syntax, &ebml)",
          "new_line_content": "        av_log(matroska->ctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 1177,
          "old_api": "ebml_free",
          "new_api": "FF_ARRAY_ELEMS",
          "old_text": "ebml_free(ebml_syntax, &ebml)",
          "new_text": "FF_ARRAY_ELEMS(matroska_doctypes)",
          "old_line_content": "        ebml_free(ebml_syntax, &ebml);",
          "new_line_content": "    for (i = 0; i < FF_ARRAY_ELEMS(matroska_doctypes); i++)",
          "content_same": false
        },
        {
          "line": 1181,
          "old_api": "strcmp",
          "new_api": "av_log",
          "old_text": "strcmp(ebml.doctype, matroska_doctypes[i])",
          "new_text": "av_log(s, AV_LOG_WARNING, \"Unknown EBML doctype '%s'\\n\", ebml.doctype)",
          "old_line_content": "        if (!strcmp(ebml.doctype, matroska_doctypes[i]))",
          "new_line_content": "        av_log(s, AV_LOG_WARNING, \"Unknown EBML doctype '%s'\\n\", ebml.doctype);",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": "FF_ARRAY_ELEMS",
          "new_api": "ebml_free",
          "old_text": "FF_ARRAY_ELEMS(matroska_doctypes)",
          "new_text": "ebml_free(ebml_syntax, &ebml)",
          "old_line_content": "    if (i >= FF_ARRAY_ELEMS(matroska_doctypes)) {",
          "new_line_content": "    ebml_free(ebml_syntax, &ebml);",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": "ebml_free",
          "new_api": "ebml_parse",
          "old_text": "ebml_free(ebml_syntax, &ebml)",
          "new_text": "ebml_parse(matroska, matroska_segments, matroska)",
          "old_line_content": "    ebml_free(ebml_syntax, &ebml);",
          "new_line_content": "    if ((res = ebml_parse(matroska, matroska_segments, matroska)) < 0)",
          "content_same": false
        },
        {
          "line": 1258,
          "old_api": "av_log",
          "new_api": "av_malloc",
          "old_text": "av_log(matroska->ctx, AV_LOG_ERROR,\n                           \"Failed to decode codec private data\\n\")",
          "new_text": "av_malloc(track->codec_priv.size + offset)",
          "old_line_content": "                    av_log(matroska->ctx, AV_LOG_ERROR,",
          "new_line_content": "                    track->codec_priv.data = av_malloc(track->codec_priv.size + offset);",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": "av_malloc",
          "new_api": "memcpy",
          "old_text": "av_malloc(track->codec_priv.size + offset)",
          "new_text": "memcpy(track->codec_priv.data+offset, codec_priv,\n                           track->codec_priv.size)",
          "old_line_content": "                    track->codec_priv.data = av_malloc(track->codec_priv.size + offset);",
          "new_line_content": "                    memcpy(track->codec_priv.data+offset, codec_priv,",
          "content_same": false
        },
        {
          "line": 1289,
          "old_api": "AV_RL32",
          "new_api": "strcmp",
          "old_text": "AV_RL32(track->codec_priv.data + 16)",
          "new_text": "strcmp(track->codec_id, \"A_MS/ACM\")",
          "old_line_content": "            track->video.fourcc = AV_RL32(track->codec_priv.data + 16);",
          "new_line_content": "        } else if (!strcmp(track->codec_id, \"A_MS/ACM\")",
          "content_same": false
        },
        {
          "line": 1292,
          "old_api": "strcmp",
          "new_api": "init_put_byte",
          "old_text": "strcmp(track->codec_id, \"A_MS/ACM\")",
          "new_text": "init_put_byte(&b, track->codec_priv.data, track->codec_priv.size,\n                          URL_RDONLY, NULL, NULL, NULL, NULL)",
          "old_line_content": "        } else if (!strcmp(track->codec_id, \"A_MS/ACM\")",
          "new_line_content": "            init_put_byte(&b, track->codec_priv.data, track->codec_priv.size,",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": "ff_get_wav_header",
          "new_api": "strcmp",
          "old_text": "ff_get_wav_header(&b, st->codec, track->codec_priv.size)",
          "new_text": "strcmp(track->codec_id, \"V_QUICKTIME\")",
          "old_line_content": "            ff_get_wav_header(&b, st->codec, track->codec_priv.size);",
          "new_line_content": "        } else if (!strcmp(track->codec_id, \"V_QUICKTIME\")",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": "strcmp",
          "new_api": "AV_RL32",
          "old_text": "strcmp(track->codec_id, \"V_QUICKTIME\")",
          "new_text": "AV_RL32(track->codec_priv.data)",
          "old_line_content": "        } else if (!strcmp(track->codec_id, \"V_QUICKTIME\")",
          "new_line_content": "            track->video.fourcc = AV_RL32(track->codec_priv.data);",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": "matroska_aac_sri",
          "new_api": "AVERROR",
          "old_text": "matroska_aac_sri(track->audio.samplerate)",
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "            int sri = matroska_aac_sri(track->audio.samplerate);",
          "new_line_content": "                return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": "AVERROR",
          "new_api": "strstr",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "strstr(track->codec_id, \"SBR\")",
          "old_line_content": "                return AVERROR(ENOMEM);",
          "new_line_content": "            if (strstr(track->codec_id, \"SBR\")) {",
          "content_same": false
        },
        {
          "line": 1337,
          "old_api": "av_mallocz",
          "new_api": "init_put_byte",
          "old_text": "av_mallocz(extradata_size)",
          "new_text": "init_put_byte(&b, extradata, extradata_size, 1,\n                          NULL, NULL, NULL, NULL)",
          "old_line_content": "            extradata = av_mallocz(extradata_size);",
          "new_line_content": "            init_put_byte(&b, extradata, extradata_size, 1,",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": "AVERROR",
          "new_api": "put_buffer",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "put_buffer(&b, \"TTA1\", 4)",
          "old_line_content": "                return AVERROR(ENOMEM);",
          "new_line_content": "            put_buffer(&b, \"TTA1\", 4);",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": "init_put_byte",
          "new_api": "put_le16",
          "old_text": "init_put_byte(&b, extradata, extradata_size, 1,\n                          NULL, NULL, NULL, NULL)",
          "new_text": "put_le16(&b, 1)",
          "old_line_content": "            init_put_byte(&b, extradata, extradata_size, 1,",
          "new_line_content": "            put_le16(&b, 1);",
          "content_same": false
        },
        {
          "line": 1342,
          "old_api": "put_buffer",
          "new_api": "put_le16",
          "old_text": "put_buffer(&b, \"TTA1\", 4)",
          "new_text": "put_le16(&b, track->audio.bitdepth)",
          "old_line_content": "            put_buffer(&b, \"TTA1\", 4);",
          "new_line_content": "            put_le16(&b, track->audio.bitdepth);",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": "put_le16",
          "new_api": "put_le32",
          "old_text": "put_le16(&b, 1)",
          "new_text": "put_le32(&b, track->audio.out_samplerate)",
          "old_line_content": "            put_le16(&b, 1);",
          "new_line_content": "            put_le32(&b, track->audio.out_samplerate);",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": "put_le16",
          "new_api": "put_le32",
          "old_text": "put_le16(&b, track->audio.channels)",
          "new_text": "put_le32(&b, matroska->ctx->duration * track->audio.out_samplerate)",
          "old_line_content": "            put_le16(&b, track->audio.channels);",
          "new_line_content": "            put_le32(&b, matroska->ctx->duration * track->audio.out_samplerate);",
          "content_same": false
        },
        {
          "line": 1357,
          "old_api": "init_put_byte",
          "new_api": "get_be16",
          "old_text": "init_put_byte(&b, track->codec_priv.data,track->codec_priv.size,\n                          0, NULL, NULL, NULL, NULL)",
          "new_text": "get_be16(&b)",
          "old_line_content": "            init_put_byte(&b, track->codec_priv.data,track->codec_priv.size,",
          "new_line_content": "            flavor                       = get_be16(&b);",
          "content_same": false
        },
        {
          "line": 1361,
          "old_api": "get_be32",
          "new_api": "get_be16",
          "old_text": "get_be32(&b)",
          "new_text": "get_be16(&b)",
          "old_line_content": "            track->audio.coded_framesize = get_be32(&b);",
          "new_line_content": "            track->audio.frame_size      = get_be16(&b);",
          "content_same": false
        },
        {
          "line": 1362,
          "old_api": "url_fskip",
          "new_api": "get_be16",
          "old_text": "url_fskip(&b, 12)",
          "new_text": "get_be16(&b)",
          "old_line_content": "            url_fskip(&b, 12);",
          "new_line_content": "            track->audio.sub_packet_size = get_be16(&b);",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": "get_be16",
          "new_api": "av_malloc",
          "old_text": "get_be16(&b)",
          "new_text": "av_malloc(track->audio.frame_size * track->audio.sub_packet_h)",
          "old_line_content": "            track->audio.sub_packet_h    = get_be16(&b);",
          "new_line_content": "            track->audio.buf = av_malloc(track->audio.frame_size * track->audio.sub_packet_h);",
          "content_same": false
        },
        {
          "line": 1410,
          "old_api": "av_mallocz",
          "new_api": "AVERROR",
          "old_text": "av_mallocz(track->codec_priv.size +\n                                                  FF_INPUT_BUFFER_PADDING_SIZE)",
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "                st->codec->extradata = av_mallocz(track->codec_priv.size +",
          "new_line_content": "                    return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": "av_new_stream",
          "new_api": "av_metadata_set2",
          "old_text": "av_new_stream(s, 0)",
          "new_text": "av_metadata_set2(&st->metadata, \"filename\",attachements[j].filename, 0)",
          "old_line_content": "            AVStream *st = av_new_stream(s, 0);",
          "new_line_content": "            av_metadata_set2(&st->metadata, \"filename\",attachements[j].filename, 0);",
          "content_same": false
        },
        {
          "line": 1455,
          "old_api": "av_metadata_set2",
          "new_api": "av_malloc",
          "old_text": "av_metadata_set2(&st->metadata, \"filename\",attachements[j].filename, 0)",
          "new_text": "av_malloc(attachements[j].bin.size)",
          "old_line_content": "            av_metadata_set2(&st->metadata, \"filename\",attachements[j].filename, 0);",
          "new_line_content": "            st->codec->extradata  = av_malloc(attachements[j].bin.size);",
          "content_same": false
        },
        {
          "line": 1462,
          "old_api": "memcpy",
          "new_api": "strncmp",
          "old_text": "memcpy(st->codec->extradata, attachements[j].bin.data, attachements[j].bin.size)",
          "new_text": "strncmp(ff_mkv_mime_tags[i].str, attachements[j].mime,\n                             strlen(ff_mkv_mime_tags[i].str))",
          "old_line_content": "            memcpy(st->codec->extradata, attachements[j].bin.data, attachements[j].bin.size);",
          "new_line_content": "                if (!strncmp(ff_mkv_mime_tags[i].str, attachements[j].mime,",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": "ff_new_chapter",
          "new_api": "av_metadata_set2",
          "old_text": "ff_new_chapter(s, chapters[i].uid, (AVRational){1, 1000000000},\n                           chapters[i].start, chapters[i].end,\n                           chapters[i].title)",
          "new_text": "av_metadata_set2(&chapters[i].chapter->metadata,\n                             \"title\", chapters[i].title, 0)",
          "old_line_content": "            ff_new_chapter(s, chapters[i].uid, (AVRational){1, 1000000000},",
          "new_line_content": "            av_metadata_set2(&chapters[i].chapter->metadata,",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": "matroska_find_track_by_num",
          "new_api": "av_add_index_entry",
          "old_text": "matroska_find_track_by_num(matroska,\n                                                              pos[j].track)",
          "new_text": "av_add_index_entry(track->stream,\n                                   pos[j].pos + matroska->segment_start,\n                                   index[i].time/index_scale, 0, 0,\n                                   AVINDEX_KEYFRAME)",
          "old_line_content": "            MatroskaTrack *track = matroska_find_track_by_num(matroska,",
          "new_line_content": "                av_add_index_entry(track->stream,",
          "content_same": false
        },
        {
          "line": 1522,
          "old_api": "memcpy",
          "new_api": "memmove",
          "old_text": "memcpy(pkt, matroska->packets[0], sizeof(AVPacket))",
          "new_text": "memmove(&matroska->packets[0], &matroska->packets[1],\n                    (matroska->num_packets - 1) * sizeof(AVPacket *))",
          "old_line_content": "        memcpy(pkt, matroska->packets[0], sizeof(AVPacket));",
          "new_line_content": "            memmove(&matroska->packets[0], &matroska->packets[1],",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": "memmove",
          "new_api": "av_realloc",
          "old_text": "memmove(&matroska->packets[0], &matroska->packets[1],\n                    (matroska->num_packets - 1) * sizeof(AVPacket *))",
          "new_text": "av_realloc(matroska->packets, (matroska->num_packets - 1) *\n                           sizeof(AVPacket *))",
          "old_line_content": "            memmove(&matroska->packets[0], &matroska->packets[1],",
          "new_line_content": "                av_realloc(matroska->packets, (matroska->num_packets - 1) *",
          "content_same": false
        },
        {
          "line": 1528,
          "old_api": "av_realloc",
          "new_api": "av_freep",
          "old_text": "av_realloc(matroska->packets, (matroska->num_packets - 1) *\n                           sizeof(AVPacket *))",
          "new_text": "av_freep(&matroska->packets)",
          "old_line_content": "                av_realloc(matroska->packets, (matroska->num_packets - 1) *",
          "new_line_content": "            av_freep(&matroska->packets);",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": "av_free_packet",
          "new_api": "av_freep",
          "old_text": "av_free_packet(matroska->packets[n])",
          "new_text": "av_freep(&matroska->packets)",
          "old_line_content": "            av_free_packet(matroska->packets[n]);",
          "new_line_content": "        av_freep(&matroska->packets);",
          "content_same": false
        },
        {
          "line": 1748,
          "old_api": "av_mallocz",
          "new_api": "av_free",
          "old_text": "av_mallocz(sizeof(AVPacket))",
          "new_text": "av_free(pkt)",
          "old_line_content": "                pkt = av_mallocz(sizeof(AVPacket));",
          "new_line_content": "                    av_free(pkt);",
          "content_same": false
        },
        {
          "line": 1757,
          "old_api": "memcpy (pkt->data+offset, pkt_data, pkt_size)",
          "new_api": "av_free",
          "old_text": "memcpy (pkt->data+offset, pkt_data, pkt_size)",
          "new_text": "av_free(pkt_data)",
          "old_line_content": "                memcpy (pkt->data+offset, pkt_data, pkt_size);",
          "new_line_content": "                    av_free(pkt_data);",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": "matroska_deliver_packet",
          "new_api": "matroska_parse_cluster",
          "old_text": "matroska_deliver_packet(matroska, pkt)",
          "new_text": "matroska_parse_cluster(matroska)",
          "old_line_content": "    while (matroska_deliver_packet(matroska, pkt)) {",
          "new_line_content": "        matroska_parse_cluster(matroska);",
          "content_same": false
        },
        {
          "line": 1852,
          "old_api": "FFMAX",
          "new_api": "url_fseek",
          "old_text": "FFMAX(timestamp, st->index_entries[0].timestamp)",
          "new_text": "url_fseek(s->pb, st->index_entries[st->nb_index_entries-1].pos, SEEK_SET)",
          "old_line_content": "    timestamp = FFMAX(timestamp, st->index_entries[0].timestamp);",
          "new_line_content": "        url_fseek(s->pb, st->index_entries[st->nb_index_entries-1].pos, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 1854,
          "old_api": "av_index_search_timestamp",
          "new_api": "matroska_clear_queue",
          "old_text": "av_index_search_timestamp(st, timestamp, flags)",
          "new_text": "matroska_clear_queue(matroska)",
          "old_line_content": "    if ((index = av_index_search_timestamp(st, timestamp, flags)) < 0) {",
          "new_line_content": "            matroska_clear_queue(matroska);",
          "content_same": false
        },
        {
          "line": 1855,
          "old_api": "url_fseek",
          "new_api": "matroska_parse_cluster",
          "old_text": "url_fseek(s->pb, st->index_entries[st->nb_index_entries-1].pos, SEEK_SET)",
          "new_text": "matroska_parse_cluster(matroska)",
          "old_line_content": "        url_fseek(s->pb, st->index_entries[st->nb_index_entries-1].pos, SEEK_SET);",
          "new_line_content": "            if (matroska_parse_cluster(matroska) < 0)",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1025,
          "old_api": null,
          "new_api": "matroska_convert_tag",
          "old_text": null,
          "new_text": "matroska_convert_tag(s, &tags[i].sub, metadata, key)",
          "old_line_content": "        if (tags[i].def || !lang) {",
          "new_line_content": "            matroska_convert_tag(s, &tags[i].sub, metadata, key);",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": null,
          "new_api": "av_strlcat",
          "old_text": null,
          "new_text": "av_strlcat(key, lang, sizeof(key))",
          "old_line_content": "        }",
          "new_line_content": "            av_strlcat(key, lang, sizeof(key));",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": null,
          "new_api": "av_metadata_set2",
          "old_text": null,
          "new_text": "av_metadata_set2(metadata, key, tags[i].string, 0)",
          "old_line_content": "        if (lang) {",
          "new_line_content": "            av_metadata_set2(metadata, key, tags[i].string, 0);",
          "content_same": false
        },
        {
          "line": 1545,
          "old_api": null,
          "new_api": "av_free_packet",
          "old_text": null,
          "new_text": "av_free_packet(matroska->packets[n])",
          "old_line_content": "    if (matroska->packets) {",
          "new_line_content": "            av_free_packet(matroska->packets[n]);",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(matroska->packets[n])",
          "old_line_content": "        int n;",
          "new_line_content": "            av_free(matroska->packets[n]);",
          "content_same": false
        },
        {
          "line": 1048,
          "old_api": null,
          "new_api": "matroska_convert_tag",
          "old_text": null,
          "new_text": "matroska_convert_tag(s, &tags[i].tag,\n                                         &attachment[j].stream->metadata, NULL)",
          "old_line_content": "            MatroskaAttachement *attachment = matroska->attachments.elem;",
          "new_line_content": "                    matroska_convert_tag(s, &tags[i].tag,",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": null,
          "new_api": "matroska_convert_tag",
          "old_text": null,
          "new_text": "matroska_convert_tag(s, &tags[i].tag,\n                                         &chapter[j].chapter->metadata, NULL)",
          "old_line_content": "            MatroskaChapter *chapter = matroska->chapters.elem;",
          "new_line_content": "                    matroska_convert_tag(s, &tags[i].tag,",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": null,
          "new_api": "matroska_ebmlnum_uint",
          "old_text": null,
          "new_text": "matroska_ebmlnum_uint(matroska, data, size, &num)",
          "old_line_content": "    int n, flags, laces = 0;",
          "new_line_content": "    if ((n = matroska_ebmlnum_uint(matroska, data, size, &num)) < 0) {",
          "content_same": false
        },
        {
          "line": 1569,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_ERROR, \"EBML block data error\\n\")",
          "old_line_content": "    uint64_t num;",
          "new_line_content": "        av_log(matroska->ctx, AV_LOG_ERROR, \"EBML block data error\\n\");",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": null,
          "new_api": "matroska_convert_tag",
          "old_text": null,
          "new_text": "matroska_convert_tag(s, &tags[i].tag,\n                                         &track[j].stream->metadata, NULL)",
          "old_line_content": "            MatroskaTrack *track = matroska->tracks.elem;",
          "new_line_content": "                    matroska_convert_tag(s, &tags[i].tag,",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": null,
          "new_api": "matroska_find_track_by_num",
          "old_text": null,
          "new_text": "matroska_find_track_by_num(matroska, num)",
          "old_line_content": "    data += n;",
          "new_line_content": "    track = matroska_find_track_by_num(matroska, num);",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_INFO,\n               \"Invalid stream %\"PRIu64\" or size %u\\n\", num, size)",
          "old_line_content": "",
          "new_line_content": "        av_log(matroska->ctx, AV_LOG_INFO,",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "url_ftell",
          "old_text": null,
          "new_text": "url_ftell(pb)",
          "old_line_content": "        len_mask >>= 1;",
          "new_line_content": "        int64_t pos = url_ftell(pb) - 1;",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_ERROR,\n               \"Invalid EBML number size tag 0x%02x at pos %\"PRIu64\" (0x%\"PRIx64\")\\n\",\n               (uint8_t) total, pos, pos)",
          "old_line_content": "    }",
          "new_line_content": "        av_log(matroska->ctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": null,
          "new_api": "url_ftell",
          "old_text": null,
          "new_text": "url_ftell(matroska->ctx->pb)",
          "old_line_content": "    EbmlList *seekhead_list = &matroska->seekhead;",
          "new_line_content": "    int64_t before_pos = url_ftell(matroska->ctx->pb);",
          "content_same": false
        },
        {
          "line": 1587,
          "old_api": null,
          "new_api": "AV_RB16",
          "old_text": null,
          "new_text": "AV_RB16(data)",
          "old_line_content": "    if (duration == AV_NOPTS_VALUE)",
          "new_line_content": "    block_time = AV_RB16(data);",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": null,
          "new_api": "url_is_streamed",
          "old_text": null,
          "new_text": "url_is_streamed(matroska->ctx->pb)",
          "old_line_content": "    int i;",
          "new_line_content": "    if (url_is_streamed(matroska->ctx->pb) ||",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": null,
          "new_api": "get_byte",
          "old_text": null,
          "new_text": "get_byte(pb)",
          "old_line_content": "    /* read out length */",
          "new_line_content": "        total = (total << 8) | get_byte(pb);",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": null,
          "new_api": "av_add_index_entry",
          "old_text": null,
          "new_text": "av_add_index_entry(st, cluster_pos, timecode, 0,0,AVINDEX_KEYFRAME)",
          "old_line_content": "            && timecode < track->end_timecode)",
          "new_line_content": "            av_add_index_entry(st, cluster_pos, timecode, 0,0,AVINDEX_KEYFRAME);",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(track->end_timecode, timecode+duration)",
          "old_line_content": "            is_keyframe = 0;  /* overlapping subtitles are not key frame */",
          "new_line_content": "        track->end_timecode = FFMAX(track->end_timecode, timecode+duration);",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": null,
          "new_api": "url_fseek",
          "old_text": null,
          "new_text": "url_fseek(matroska->ctx->pb, offset, SEEK_SET)",
          "old_line_content": "            continue;",
          "new_line_content": "        if (url_fseek(matroska->ctx->pb, offset, SEEK_SET) != offset)",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_INFO,\n                   \"Max EBML element depth (%d) reached, \"\n                   \"cannot parse further.\\n\", EBML_MAX_DEPTH)",
          "old_line_content": "        /* We don't want to lose our seekhead level, so we add",
          "new_line_content": "            av_log(matroska->ctx, AV_LOG_INFO,",
          "content_same": false
        },
        {
          "line": 1614,
          "old_api": null,
          "new_api": "av_mallocz",
          "old_text": null,
          "new_text": "av_mallocz(sizeof(int))",
          "old_line_content": "    switch ((flags & 0x06) >> 1) {",
          "new_line_content": "            lace_size = av_mallocz(sizeof(int));",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": null,
          "new_api": "get_byte",
          "old_text": null,
          "new_text": "get_byte(pb)",
          "old_line_content": "    /* big-endian ordering; build up number */",
          "new_line_content": "        *num = (*num << 8) | get_byte(pb);",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(size>0)",
          "old_line_content": "        case 0x1: /* Xiph lacing */",
          "new_line_content": "            assert(size>0); // size <=3 is checked before size-=3 above",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": null,
          "new_api": "ebml_parse",
          "old_text": null,
          "new_text": "ebml_parse(matroska, matroska_segment, matroska)",
          "old_line_content": "        matroska->num_levels++;",
          "new_line_content": "        ebml_parse(matroska, matroska_segment, matroska);",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": null,
          "new_api": "av_mallocz",
          "old_text": null,
          "new_text": "av_mallocz(laces * sizeof(int))",
          "old_line_content": "            laces = (*data) + 1;",
          "new_line_content": "            lace_size = av_mallocz(laces * sizeof(int));",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": null,
          "new_api": "get_be32",
          "old_text": null,
          "new_text": "get_be32(pb)",
          "old_line_content": "static int ebml_read_float(ByteIOContext *pb, int size, double *num)",
          "new_line_content": "        *num= av_int2flt(get_be32(pb));",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": null,
          "new_api": "get_be64",
          "old_text": null,
          "new_text": "get_be64(pb)",
          "old_line_content": "    if (size == 4) {",
          "new_line_content": "        *num= av_int2dbl(get_be64(pb));",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": null,
          "new_api": "url_fseek",
          "old_text": null,
          "new_text": "url_fseek(matroska->ctx->pb, before_pos, SEEK_SET)",
          "old_line_content": "    }",
          "new_line_content": "    url_fseek(matroska->ctx->pb, before_pos, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(*str)",
          "old_line_content": " */",
          "new_line_content": "    av_free(*str);",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": null,
          "new_api": "FF_ARRAY_ELEMS",
          "old_text": null,
          "new_text": "FF_ARRAY_ELEMS(aac_profiles)",
          "old_line_content": "    static const char * const aac_profiles[] = { \"MAIN\", \"LC\", \"SSR\" };",
          "new_line_content": "    for (profile=0; profile<FF_ARRAY_ELEMS(aac_profiles); profile++)",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": null,
          "new_api": "strstr",
          "old_text": null,
          "new_text": "strstr(codec_id, aac_profiles[profile])",
          "old_line_content": "    int profile;",
          "new_line_content": "        if (strstr(codec_id, aac_profiles[profile]))",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    /* EBML strings are usually not 0-terminated, so we allocate one",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": null,
          "new_api": "get_buffer",
          "old_text": null,
          "new_text": "get_buffer(pb, (uint8_t *) *str, size)",
          "old_line_content": "     * byte more, read the string and NULL-terminate it ourselves. */",
          "new_line_content": "    if (get_buffer(pb, (uint8_t *) *str, size) != size) {",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": null,
          "new_api": "FF_ARRAY_ELEMS",
          "old_text": null,
          "new_text": "FF_ARRAY_ELEMS(ff_mpeg4audio_sample_rates)",
          "old_line_content": "{",
          "new_line_content": "    for (sri=0; sri<FF_ARRAY_ELEMS(ff_mpeg4audio_sample_rates); sri++)",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": null,
          "new_api": "matroska_ebmlnum_uint",
          "old_text": null,
          "new_text": "matroska_ebmlnum_uint(matroska, data, size, &num)",
          "old_line_content": "",
          "new_line_content": "                    n = matroska_ebmlnum_uint(matroska, data, size, &num);",
          "content_same": false
        },
        {
          "line": 1659,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_INFO,\n                               \"EBML block data error\\n\")",
          "old_line_content": "                    uint32_t total;",
          "new_line_content": "                        av_log(matroska->ctx, AV_LOG_INFO,",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(bin->data)",
          "old_line_content": " */",
          "new_line_content": "    av_free(bin->data);",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(length)",
          "old_line_content": "static int ebml_read_binary(ByteIOContext *pb, int length, EbmlBin *bin)",
          "new_line_content": "    if (!(bin->data = av_malloc(length)))",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "{",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": null,
          "new_api": "get_buffer",
          "old_text": null,
          "new_text": "get_buffer(pb, bin->data, length)",
          "old_line_content": "",
          "new_line_content": "    if (get_buffer(pb, bin->data, length) != length) {",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&bin->data)",
          "old_line_content": "    bin->size = length;",
          "new_line_content": "        av_freep(&bin->data);",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": null,
          "new_api": "matroska_ebmlnum_sint",
          "old_text": null,
          "new_text": "matroska_ebmlnum_sint(matroska, data, size, &snum)",
          "old_line_content": "                    for (n = 1; res == 0 && n < laces - 1; n++) {",
          "new_line_content": "                        r = matroska_ebmlnum_sint(matroska, data, size, &snum);",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_INFO,\n                                   \"EBML block data error\\n\")",
          "old_line_content": "                        int r;",
          "new_line_content": "                            av_log(matroska->ctx, AV_LOG_INFO,",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": null,
          "new_api": "ebml_parse",
          "old_text": null,
          "new_text": "ebml_parse(matroska, ebml_syntax, &ebml)",
          "old_line_content": "    matroska->ctx = s;",
          "new_line_content": "    if (ebml_parse(matroska, ebml_syntax, &ebml)",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": null,
          "new_api": "ebml_free",
          "old_text": null,
          "new_text": "ebml_free(ebml_syntax, &ebml)",
          "old_line_content": "               \"EBML header using unsupported features\\n\"",
          "new_line_content": "        ebml_free(ebml_syntax, &ebml);",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_ERROR,\n               \"File moves beyond max. allowed depth (%d)\\n\", EBML_MAX_DEPTH)",
          "old_line_content": "    MatroskaLevel *level;",
          "new_line_content": "        av_log(matroska->ctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOSYS)",
          "old_line_content": "    if (matroska->num_levels >= EBML_MAX_DEPTH) {",
          "new_line_content": "        return AVERROR(ENOSYS);",
          "content_same": false
        },
        {
          "line": 1178,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(ebml.doctype, matroska_doctypes[i])",
          "old_line_content": "        return AVERROR_PATCHWELCOME;",
          "new_line_content": "        if (!strcmp(ebml.doctype, matroska_doctypes[i]))",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": null,
          "new_api": "url_ftell",
          "old_text": null,
          "new_text": "url_ftell(pb)",
          "old_line_content": "    }",
          "new_line_content": "    level->start = url_ftell(pb);",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": null,
          "new_api": "matroska_execute_seekhead",
          "old_text": null,
          "new_text": "matroska_execute_seekhead(matroska)",
          "old_line_content": "    /* The next thing is a segment. */",
          "new_line_content": "    matroska_execute_seekhead(matroska);",
          "content_same": false
        },
        {
          "line": 1705,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(track->audio.buf+x*2*w+y*cfs,\n                                   data+x*cfs, cfs)",
          "old_line_content": "                if (!track->audio.pkt_cnt) {",
          "new_line_content": "                            memcpy(track->audio.buf+x*2*w+y*cfs,",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": null,
          "new_api": "av_metadata_set2",
          "old_text": null,
          "new_text": "av_metadata_set2(&s->metadata, \"title\", matroska->title, 0)",
          "old_line_content": "    if (matroska->duration)",
          "new_line_content": "    av_metadata_set2(&s->metadata, \"title\", matroska->title, 0);",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "init_put_byte",
          "old_text": null,
          "new_text": "init_put_byte(&pb, data, size, 0, NULL, NULL, NULL, NULL)",
          "old_line_content": "                                 uint8_t *data, uint32_t size, uint64_t *num)",
          "new_line_content": "    init_put_byte(&pb, data, size, 0, NULL, NULL, NULL, NULL);",
          "content_same": false
        },
        {
          "line": 685,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(size, 8)",
          "old_line_content": "{",
          "new_line_content": "    return ebml_read_num(matroska, &pb, FFMIN(size, 8), num);",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": null,
          "new_api": "ff_rm_reorder_sipr_data",
          "old_text": null,
          "new_text": "ff_rm_reorder_sipr_data(track->audio.buf, h, w)",
          "old_line_content": "",
          "new_line_content": "                            ff_rm_reorder_sipr_data(track->audio.buf, h, w);",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": null,
          "new_api": "av_mallocz",
          "old_text": null,
          "new_text": "av_mallocz(sizeof(AVPacket))",
          "old_line_content": "                    }",
          "new_line_content": "                    pkt = av_mallocz(sizeof(AVPacket));",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": null,
          "new_api": "matroska_ebmlnum_uint",
          "old_text": null,
          "new_text": "matroska_ebmlnum_uint(matroska, data, size, &unum)",
          "old_line_content": "    int res;",
          "new_line_content": "    if ((res = matroska_ebmlnum_uint(matroska, data, size, &unum)) < 0)",
          "content_same": false
        },
        {
          "line": 1722,
          "old_api": null,
          "new_api": "av_new_packet",
          "old_text": null,
          "new_text": "av_new_packet(pkt, a)",
          "old_line_content": "                }",
          "new_line_content": "                    av_new_packet(pkt, a);",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_INFO,\n                   \"Unknown or unsupported track type %\"PRIu64\"\\n\",\n                   track->type)",
          "old_line_content": "        if (track->type != MATROSKA_TRACK_TYPE_VIDEO &&",
          "new_line_content": "            av_log(matroska->ctx, AV_LOG_INFO,",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(pkt->data, track->audio.buf\n                           + a * (h*w / a - track->audio.pkt_cnt--), a)",
          "old_line_content": "                while (track->audio.pkt_cnt) {",
          "new_line_content": "                    memcpy(pkt->data, track->audio.buf",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": null,
          "new_api": "dynarray_add",
          "old_text": null,
          "new_text": "dynarray_add(&matroska->packets,&matroska->num_packets,pkt)",
          "old_line_content": "                           + a * (h*w / a - track->audio.pkt_cnt--), a);",
          "new_line_content": "                    dynarray_add(&matroska->packets,&matroska->num_packets,pkt);",
          "content_same": false
        },
        {
          "line": 1735,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_ERROR, \"Invalid packet size\\n\")",
          "old_line_content": "                uint8_t *pkt_data = data;",
          "new_line_content": "                    av_log(matroska->ctx, AV_LOG_ERROR, \"Invalid packet size\\n\");",
          "content_same": false
        },
        {
          "line": 1740,
          "old_api": null,
          "new_api": "matroska_decode_buffer",
          "old_text": null,
          "new_text": "matroska_decode_buffer(&pkt_data,&pkt_size, track)",
          "old_line_content": "                }",
          "new_line_content": "                    offset = matroska_decode_buffer(&pkt_data,&pkt_size, track);",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_ERROR,\n                   \"Multiple combined encodings no supported\")",
          "old_line_content": "                track->audio.out_samplerate = track->audio.samplerate;",
          "new_line_content": "            av_log(matroska->ctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 1745,
          "old_api": null,
          "new_api": "av_mallocz",
          "old_text": null,
          "new_text": "av_mallocz(sizeof(AVPacket))",
          "old_line_content": "                        continue;",
          "new_line_content": "                pkt = av_mallocz(sizeof(AVPacket));",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_INFO, \"Unknown entry 0x%X\\n\", id)",
          "old_line_content": "        matroska->levels[matroska->num_levels-1].length == 0xffffffffffffff)",
          "new_line_content": "        av_log(matroska->ctx, AV_LOG_INFO, \"Unknown entry 0x%X\\n\", id);",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": null,
          "new_api": "ebml_parse_elem",
          "old_text": null,
          "new_text": "ebml_parse_elem(matroska, &syntax[i], data)",
          "old_line_content": "        return 0;  // we reached the end of an unknown size cluster",
          "new_line_content": "    return ebml_parse_elem(matroska, &syntax[i], data);",
          "content_same": false
        },
        {
          "line": 1747,
          "old_api": null,
          "new_api": "av_new_packet",
          "old_text": null,
          "new_text": "av_new_packet(pkt, pkt_size+offset)",
          "old_line_content": "",
          "new_line_content": "                if (av_new_packet(pkt, pkt_size+offset) < 0) {",
          "content_same": false
        },
        {
          "line": 1749,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "                /* XXX: prevent data copy... */",
          "new_line_content": "                    res = AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": null,
          "new_api": "memcpy (pkt->data, encodings->compression.settings.data, offset)",
          "old_text": null,
          "new_text": "memcpy (pkt->data, encodings->compression.settings.data, offset)",
          "old_line_content": "                    break;",
          "new_line_content": "                    memcpy (pkt->data, encodings->compression.settings.data, offset);",
          "content_same": false
        },
        {
          "line": 1754,
          "old_api": null,
          "new_api": "memcpy (pkt->data+offset, pkt_data, pkt_size)",
          "old_text": null,
          "new_text": "memcpy (pkt->data+offset, pkt_data, pkt_size)",
          "old_line_content": "                }",
          "new_line_content": "                memcpy (pkt->data+offset, pkt_data, pkt_size);",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "ebml_read_num",
          "old_text": null,
          "new_text": "ebml_read_num(matroska, matroska->ctx->pb, 4, &id)",
          "old_line_content": "{",
          "new_line_content": "        int res = ebml_read_num(matroska, matroska->ctx->pb, 4, &id);",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_ERROR,\n                       \"Unsupported encoding type\")",
          "old_line_content": "#endif",
          "new_line_content": "                av_log(matroska->ctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": null,
          "new_api": "ebml_parse_id",
          "old_text": null,
          "new_text": "ebml_parse_id(matroska, syntax, matroska->current_id, data)",
          "old_line_content": "            return res;",
          "new_line_content": "    return ebml_parse_id(matroska, syntax, matroska->current_id, data);",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": null,
          "new_api": "matroska_decode_buffer",
          "old_text": null,
          "new_text": "matroska_decode_buffer(&track->codec_priv.data,\n                                                    &track->codec_priv.size,\n                                                    track)",
          "old_line_content": "                       \"Unsupported encoding type\");",
          "new_line_content": "                int offset = matroska_decode_buffer(&track->codec_priv.data,",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_ERROR,\n                           \"Failed to decode codec private data\\n\")",
          "old_line_content": "                if (offset < 0) {",
          "new_line_content": "                    av_log(matroska->ctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 1259,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(track->codec_priv.data,\n                           encodings[0].compression.settings.data, offset)",
          "old_line_content": "                           \"Failed to decode codec private data\\n\");",
          "new_line_content": "                    memcpy(track->codec_priv.data,",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": null,
          "new_api": "matroska_fix_ass_packet",
          "old_text": null,
          "new_text": "matroska_fix_ass_packet(matroska, pkt, duration)",
          "old_line_content": "                    pkt->duration = duration;",
          "new_line_content": "                    matroska_fix_ass_packet(matroska, pkt, duration);",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": null,
          "new_api": "av_strdup",
          "old_text": null,
          "new_text": "av_strdup(syntax[i].def.s)",
          "old_line_content": "            break;",
          "new_line_content": "            *(char    **)((char *)data+syntax[i].data_offset) = av_strdup(syntax[i].def.s);",
          "content_same": false
        },
        {
          "line": 1266,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(codec_priv)",
          "old_line_content": "                    track->codec_priv.size += offset;",
          "new_line_content": "                    av_free(codec_priv);",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": null,
          "new_api": "matroska_merge_packets",
          "old_text": null,
          "new_text": "matroska_merge_packets(matroska->prev_pkt, pkt)",
          "old_line_content": "                    matroska->prev_pkt->pts == timecode &&",
          "new_line_content": "                    matroska_merge_packets(matroska->prev_pkt, pkt);",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": null,
          "new_api": "ebml_level_end",
          "old_text": null,
          "new_text": "ebml_level_end(matroska)",
          "old_line_content": "            break;",
          "new_line_content": "    while (!res && !ebml_level_end(matroska))",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": null,
          "new_api": "ebml_parse",
          "old_text": null,
          "new_text": "ebml_parse(matroska, syntax, data)",
          "old_line_content": "        }",
          "new_line_content": "        res = ebml_parse(matroska, syntax, data);",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": null,
          "new_api": "strncmp",
          "old_text": null,
          "new_text": "strncmp(ff_mkv_codec_tags[j].str, track->codec_id,\n                        strlen(ff_mkv_codec_tags[j].str))",
          "old_line_content": "        }",
          "new_line_content": "            if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": null,
          "new_api": "strlen",
          "old_text": null,
          "new_text": "strlen(ff_mkv_codec_tags[j].str)",
          "old_line_content": "",
          "new_line_content": "                        strlen(ff_mkv_codec_tags[j].str))){",
          "content_same": false
        },
        {
          "line": 1783,
          "old_api": null,
          "new_api": "dynarray_add",
          "old_text": null,
          "new_text": "dynarray_add(&matroska->packets,&matroska->num_packets,pkt)",
          "old_line_content": "                    st->codec->codec_id == CODEC_ID_SSA)",
          "new_line_content": "                    dynarray_add(&matroska->packets,&matroska->num_packets,pkt);",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": null,
          "new_api": "av_new_stream",
          "old_text": null,
          "new_text": "av_new_stream(s, 0)",
          "old_line_content": "            }",
          "new_line_content": "        st = track->stream = av_new_stream(s, 0);",
          "content_same": false
        },
        {
          "line": 1280,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "",
          "new_line_content": "            return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(track->codec_id, \"V_MS/VFW/FOURCC\")",
          "old_line_content": "        if (st == NULL)",
          "new_line_content": "        if (!strcmp(track->codec_id, \"V_MS/VFW/FOURCC\")",
          "content_same": false
        },
        {
          "line": 1795,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(lace_size)",
          "old_line_content": "        }",
          "new_line_content": "    av_free(lace_size);",
          "content_same": false
        },
        {
          "line": 1286,
          "old_api": null,
          "new_api": "AV_RL32",
          "old_text": null,
          "new_text": "AV_RL32(track->codec_priv.data + 16)",
          "old_line_content": "            && track->codec_priv.size >= 40",
          "new_line_content": "            track->video.fourcc = AV_RL32(track->codec_priv.data + 16);",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": null,
          "new_api": "av_realloc",
          "old_text": null,
          "new_text": "av_realloc(list->elem, (list->nb_elem+1)*syntax->list_elem_size)",
          "old_line_content": "    data = (char *)data + syntax->data_offset;",
          "new_line_content": "        list->elem = av_realloc(list->elem, (list->nb_elem+1)*syntax->list_elem_size);",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": null,
          "new_api": "ff_codec_get_id",
          "old_text": null,
          "new_text": "ff_codec_get_id(ff_codec_bmp_tags, track->video.fourcc)",
          "old_line_content": "            && track->codec_priv.data != NULL) {",
          "new_line_content": "            codec_id = ff_codec_get_id(ff_codec_bmp_tags, track->video.fourcc);",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(data, 0, syntax->list_elem_size)",
          "old_line_content": "        EbmlList *list = data;",
          "new_line_content": "        memset(data, 0, syntax->list_elem_size);",
          "content_same": false
        },
        {
          "line": 1805,
          "old_api": null,
          "new_api": "url_ftell",
          "old_text": null,
          "new_text": "url_ftell(matroska->ctx->pb)",
          "old_line_content": "    EbmlList *blocks_list;",
          "new_line_content": "    int64_t pos = url_ftell(matroska->ctx->pb);",
          "content_same": false
        },
        {
          "line": 1294,
          "old_api": null,
          "new_api": "ff_get_wav_header",
          "old_text": null,
          "new_text": "ff_get_wav_header(&b, st->codec, track->codec_priv.size)",
          "old_line_content": "                   && track->codec_priv.data != NULL) {",
          "new_line_content": "            ff_get_wav_header(&b, st->codec, track->codec_priv.size);",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": null,
          "new_api": "ebml_read_num",
          "old_text": null,
          "new_text": "ebml_read_num(matroska, pb, 8, &length)",
          "old_line_content": "",
          "new_line_content": "        if ((res = ebml_read_num(matroska, pb, 8, &length)) < 0)",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(track->codec_priv.size, 18)",
          "old_line_content": "                          URL_RDONLY, NULL, NULL, NULL, NULL);",
          "new_line_content": "            extradata_offset = FFMIN(track->codec_priv.size, 18);",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": null,
          "new_api": "ebml_parse",
          "old_text": null,
          "new_text": "ebml_parse(matroska, matroska_clusters, &cluster)",
          "old_line_content": "    matroska->prev_pkt = NULL;",
          "new_line_content": "    res = ebml_parse(matroska, matroska_clusters, &cluster);",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": null,
          "new_api": "ebml_read_uint  (pb, length, data)",
          "old_text": null,
          "new_text": "ebml_read_uint  (pb, length, data)",
          "old_line_content": "    }",
          "new_line_content": "    case EBML_UINT:  res = ebml_read_uint  (pb, length, data);  break;",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": null,
          "new_api": "ebml_read_float (pb, length, data)",
          "old_text": null,
          "new_text": "ebml_read_float (pb, length, data)",
          "old_line_content": "",
          "new_line_content": "    case EBML_FLOAT: res = ebml_read_float (pb, length, data);  break;",
          "content_same": false
        },
        {
          "line": 1301,
          "old_api": null,
          "new_api": "ff_codec_get_id",
          "old_text": null,
          "new_text": "ff_codec_get_id(codec_movvideo_tags, track->video.fourcc)",
          "old_line_content": "                   && (track->codec_priv.size >= 86)",
          "new_line_content": "            codec_id=ff_codec_get_id(codec_movvideo_tags, track->video.fourcc);",
          "content_same": false
        },
        {
          "line": 1815,
          "old_api": null,
          "new_api": "matroska_parse_block",
          "old_text": null,
          "new_text": "matroska_parse_block(matroska,\n                                     blocks[i].bin.data, blocks[i].bin.size,\n                                     blocks[i].bin.pos,  cluster.timecode,\n                                     blocks[i].duration, is_keyframe,\n                                     pos)",
          "old_line_content": "    for (i=0; i<blocks_list->nb_elem; i++)",
          "new_line_content": "            res=matroska_parse_block(matroska,",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": null,
          "new_api": "ebml_read_master",
          "old_text": null,
          "new_text": "ebml_read_master(matroska, length)",
          "old_line_content": "    case EBML_STR:",
          "new_line_content": "    case EBML_NEST:  if ((res=ebml_read_master(matroska, length)) < 0)",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": null,
          "new_api": "ebml_parse_nest",
          "old_text": null,
          "new_text": "ebml_parse_nest(matroska, syntax->def.n, data)",
          "old_line_content": "                         return res;",
          "new_line_content": "                     return ebml_parse_nest(matroska, syntax->def.n, data);",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": null,
          "new_api": "ebml_parse_id",
          "old_text": null,
          "new_text": "ebml_parse_id(matroska, syntax->def.n, id, data)",
          "old_line_content": "                     if (id == MATROSKA_ID_SEGMENT)",
          "new_line_content": "    case EBML_PASS:  return ebml_parse_id(matroska, syntax->def.n, id, data);",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": null,
          "new_api": "ebml_free",
          "old_text": null,
          "new_text": "ebml_free(matroska_cluster, &cluster)",
          "old_line_content": "                                     blocks[i].duration, is_keyframe,",
          "new_line_content": "    ebml_free(matroska_cluster, &cluster);",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EIO)",
          "old_line_content": "    }",
          "new_line_content": "    else if (res == AVERROR(EIO))",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_ERROR, \"Read error\\n\")",
          "old_line_content": "    if (res == AVERROR_INVALIDDATA)",
          "new_line_content": "        av_log(matroska->ctx, AV_LOG_ERROR, \"Read error\\n\");",
          "content_same": false
        },
        {
          "line": 1317,
          "old_api": null,
          "new_api": "matroska_aac_profile",
          "old_text": null,
          "new_text": "matroska_aac_profile(track->codec_id)",
          "old_line_content": "        } else if (codec_id==CODEC_ID_PCM_F32LE && track->audio.bitdepth==64) {",
          "new_line_content": "            int profile = matroska_aac_profile(track->codec_id);",
          "content_same": false
        },
        {
          "line": 1318,
          "old_api": null,
          "new_api": "matroska_aac_sri",
          "old_text": null,
          "new_text": "matroska_aac_sri(track->audio.samplerate)",
          "old_line_content": "            codec_id = CODEC_ID_PCM_F64LE;",
          "new_line_content": "            int sri = matroska_aac_sri(track->audio.samplerate);",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(5)",
          "old_line_content": "        } else if (codec_id == CODEC_ID_AAC && !track->codec_priv.size) {",
          "new_line_content": "            extradata = av_malloc(5);",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": null,
          "new_api": "matroska_deliver_packet",
          "old_text": null,
          "new_text": "matroska_deliver_packet(matroska, pkt)",
          "old_line_content": "{",
          "new_line_content": "    while (matroska_deliver_packet(matroska, pkt)) {",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": null,
          "new_api": "matroska_aac_sri",
          "old_text": null,
          "new_text": "matroska_aac_sri(track->audio.out_samplerate)",
          "old_line_content": "            extradata[0] = (profile << 3) | ((sri&0x0E) >> 1);",
          "new_line_content": "                sri = matroska_aac_sri(track->audio.out_samplerate);",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(data_off)",
          "old_line_content": "        void *data_off = (char *)data + syntax[i].data_offset;",
          "new_line_content": "        case EBML_UTF8:  av_freep(data_off);                      break;",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&((EbmlBin *)data_off)->data)",
          "old_line_content": "        switch (syntax[i].type) {",
          "new_line_content": "        case EBML_BIN:   av_freep(&((EbmlBin *)data_off)->data);  break;",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": null,
          "new_api": "av_mallocz",
          "old_text": null,
          "new_text": "av_mallocz(extradata_size)",
          "old_line_content": "                extradata_size = 2;",
          "new_line_content": "            extradata = av_mallocz(extradata_size);",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": null,
          "new_api": "ebml_free",
          "old_text": null,
          "new_text": "ebml_free(syntax[i].def.n, ptr)",
          "old_line_content": "                EbmlList *list = data_off;",
          "new_line_content": "                    ebml_free(syntax[i].def.n, ptr);",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(list->elem)",
          "old_line_content": "                char *ptr = list->elem;",
          "new_line_content": "                av_free(list->elem);",
          "content_same": false
        },
        {
          "line": 1336,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "            extradata_size = 30;",
          "new_line_content": "                return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 1849,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(timestamp, st->index_entries[0].timestamp)",
          "old_line_content": "",
          "new_line_content": "    timestamp = FFMAX(timestamp, st->index_entries[0].timestamp);",
          "content_same": false
        },
        {
          "line": 1851,
          "old_api": null,
          "new_api": "av_index_search_timestamp",
          "old_text": null,
          "new_text": "av_index_search_timestamp(st, timestamp, flags)",
          "old_line_content": "        return 0;",
          "new_line_content": "    if ((index = av_index_search_timestamp(st, timestamp, flags)) < 0) {",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": null,
          "new_api": "put_le16",
          "old_text": null,
          "new_text": "put_le16(&b, track->audio.channels)",
          "old_line_content": "                          NULL, NULL, NULL, NULL);",
          "new_line_content": "            put_le16(&b, track->audio.channels);",
          "content_same": false
        },
        {
          "line": 1853,
          "old_api": null,
          "new_api": "av_index_search_timestamp",
          "old_text": null,
          "new_text": "av_index_search_timestamp(st, timestamp, flags)",
          "old_line_content": "",
          "new_line_content": "        while ((index = av_index_search_timestamp(st, timestamp, flags)) < 0) {",
          "content_same": false
        },
        {
          "line": 1860,
          "old_api": null,
          "new_api": "matroska_clear_queue",
          "old_text": null,
          "new_text": "matroska_clear_queue(matroska)",
          "old_line_content": "        }",
          "new_line_content": "    matroska_clear_queue(matroska);",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": null,
          "new_api": "AV_RB32",
          "old_text": null,
          "new_text": "AV_RB32(p->buf)",
          "old_line_content": "    int len_mask = 0x80, size = 1, n = 1, i;",
          "new_line_content": "    if (AV_RB32(p->buf) != EBML_ID_HEADER)",
          "content_same": false
        },
        {
          "line": 1354,
          "old_api": null,
          "new_api": "init_put_byte",
          "old_text": null,
          "new_text": "init_put_byte(&b, track->codec_priv.data,track->codec_priv.size,\n                          0, NULL, NULL, NULL, NULL)",
          "old_line_content": "        } else if (codec_id == CODEC_ID_RA_288 || codec_id == CODEC_ID_COOK ||",
          "new_line_content": "            init_put_byte(&b, track->codec_priv.data,track->codec_priv.size,",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": null,
          "new_api": "url_fskip",
          "old_text": null,
          "new_text": "url_fskip(&b, 22)",
          "old_line_content": "            int flavor;",
          "new_line_content": "            url_fskip(&b, 22);",
          "content_same": false
        },
        {
          "line": 1869,
          "old_api": null,
          "new_api": "av_index_search_timestamp",
          "old_text": null,
          "new_text": "av_index_search_timestamp(tracks[i].stream, st->index_entries[index].timestamp, AVSEEK_FLAG_BACKWARD)",
          "old_line_content": "        tracks[i].end_timecode = 0;",
          "new_line_content": "            index_sub = av_index_search_timestamp(tracks[i].stream, st->index_entries[index].timestamp, AVSEEK_FLAG_BACKWARD);",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": null,
          "new_api": "get_be32",
          "old_text": null,
          "new_text": "get_be32(&b)",
          "old_line_content": "                          0, NULL, NULL, NULL, NULL);",
          "new_line_content": "            track->audio.coded_framesize = get_be32(&b);",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": null,
          "new_api": "url_fseek",
          "old_text": null,
          "new_text": "url_fseek(s->pb, st->index_entries[index_min].pos, SEEK_SET)",
          "old_line_content": "        }",
          "new_line_content": "    url_fseek(s->pb, st->index_entries[index_min].pos, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 1881,
          "old_api": null,
          "new_api": "av_update_cur_dts",
          "old_text": null,
          "new_text": "av_update_cur_dts(s, st, st->index_entries[index].timestamp)",
          "old_line_content": "    matroska->skip_to_keyframe = !(flags & AVSEEK_FLAG_ANY);",
          "new_line_content": "    av_update_cur_dts(s, st, st->index_entries[index].timestamp);",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": null,
          "new_api": "FF_ARRAY_ELEMS",
          "old_text": null,
          "new_text": "FF_ARRAY_ELEMS(matroska_doctypes)",
          "old_line_content": "     * we don't parse the whole header but simply check for the",
          "new_line_content": "    for (i = 0; i < FF_ARRAY_ELEMS(matroska_doctypes); i++) {",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": null,
          "new_api": "strlen",
          "old_text": null,
          "new_text": "strlen(matroska_doctypes[i])",
          "old_line_content": "     * availability of that array of characters inside the header.",
          "new_line_content": "        int probelen = strlen(matroska_doctypes[i]);",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": null,
          "new_api": "matroska_clear_queue",
          "old_text": null,
          "new_text": "matroska_clear_queue(matroska)",
          "old_line_content": "    MatroskaTrack *tracks = matroska->tracks.elem;",
          "new_line_content": "    matroska_clear_queue(matroska);",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_INFO,\n                   \"Unknown/unsupported CodecID %s.\\n\", track->codec_id)",
          "old_line_content": "        track->codec_priv.size -= extradata_offset;",
          "new_line_content": "            av_log(matroska->ctx, AV_LOG_INFO,",
          "content_same": false
        },
        {
          "line": 1895,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(tracks[n].audio.buf)",
          "old_line_content": "",
          "new_line_content": "            av_free(tracks[n].audio.buf);",
          "content_same": false
        },
        {
          "line": 1896,
          "old_api": null,
          "new_api": "ebml_free",
          "old_text": null,
          "new_text": "ebml_free(matroska_segment, matroska)",
          "old_line_content": "    for (n=0; n < matroska->tracks.nb_elem; n++)",
          "new_line_content": "    ebml_free(matroska_segment, matroska);",
          "content_same": false
        },
        {
          "line": 1385,
          "old_api": null,
          "new_api": "av_set_pts_info",
          "old_text": null,
          "new_text": "av_set_pts_info(st, 64, matroska->time_scale*track->time_scale, 1000*1000*1000)",
          "old_line_content": "",
          "new_line_content": "        av_set_pts_info(st, 64, matroska->time_scale*track->time_scale, 1000*1000*1000); /* 64 bit pts in ns */",
          "content_same": false
        },
        {
          "line": 1389,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(track->language, \"und\")",
          "old_line_content": "",
          "new_line_content": "        if (strcmp(track->language, \"und\"))",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": null,
          "new_api": "av_metadata_set2",
          "old_text": null,
          "new_text": "av_metadata_set2(&st->metadata, \"language\", track->language, 0)",
          "old_line_content": "        st->codec->codec_id = codec_id;",
          "new_line_content": "            av_metadata_set2(&st->metadata, \"language\", track->language, 0);",
          "content_same": false
        },
        {
          "line": 1391,
          "old_api": null,
          "new_api": "av_metadata_set2",
          "old_text": null,
          "new_text": "av_metadata_set2(&st->metadata, \"title\", track->name, 0)",
          "old_line_content": "        st->start_time = 0;",
          "new_line_content": "        av_metadata_set2(&st->metadata, \"title\", track->name, 0);",
          "content_same": false
        },
        {
          "line": 1903,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"Matroska/WebM file format\")",
          "old_line_content": "",
          "new_line_content": "    NULL_IF_CONFIG_SMALL(\"Matroska/WebM file format\"),",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_ERROR, \"Invalid track number %d\\n\", num)",
          "old_line_content": "        if (tracks[i].num == num)",
          "new_line_content": "    av_log(matroska->ctx, AV_LOG_ERROR, \"Invalid track number %d\\n\", num);",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": null,
          "new_api": "av_reduce",
          "old_text": null,
          "new_text": "av_reduce(&st->codec->time_base.num, &st->codec->time_base.den,\n                      track->default_duration, 1000000000, 30000)",
          "old_line_content": "            st->disposition |= AV_DISPOSITION_FORCED;",
          "new_line_content": "            av_reduce(&st->codec->time_base.num, &st->codec->time_base.den,",
          "content_same": false
        },
        {
          "line": 1407,
          "old_api": null,
          "new_api": "av_mallocz",
          "old_text": null,
          "new_text": "av_mallocz(track->codec_priv.size +\n                                                  FF_INPUT_BUFFER_PADDING_SIZE)",
          "old_line_content": "                st->codec->extradata = extradata;",
          "new_line_content": "                st->codec->extradata = av_mallocz(track->codec_priv.size +",
          "content_same": false
        },
        {
          "line": 1412,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(st->codec->extradata,\n                       track->codec_priv.data + extradata_offset,\n                       track->codec_priv.size)",
          "old_line_content": "                if(st->codec->extradata == NULL)",
          "new_line_content": "                memcpy(st->codec->extradata,",
          "content_same": false
        },
        {
          "line": 910,
          "old_api": null,
          "new_api": "av_realloc",
          "old_text": null,
          "new_text": "av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING)",
          "old_line_content": "    case MATROSKA_TRACK_ENCODING_COMP_LZO:",
          "new_line_content": "            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": null,
          "new_api": "av_lzo1x_decode",
          "old_text": null,
          "new_text": "av_lzo1x_decode(pkt_data, &olen, data, &isize)",
          "old_line_content": "        do {",
          "new_line_content": "            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);",
          "content_same": false
        },
        {
          "line": 1423,
          "old_api": null,
          "new_api": "av_reduce",
          "old_text": null,
          "new_text": "av_reduce(&st->sample_aspect_ratio.num,\n                      &st->sample_aspect_ratio.den,\n                      st->codec->height * track->video.display_width,\n                      st->codec-> width * track->video.display_height,\n                      255)",
          "old_line_content": "            st->codec->codec_tag  = track->video.fourcc;",
          "new_line_content": "            av_reduce(&st->sample_aspect_ratio.num,",
          "content_same": false
        },
        {
          "line": 1431,
          "old_api": null,
          "new_api": "av_d2q",
          "old_text": null,
          "new_text": "av_d2q(1000000000.0/track->default_duration, INT_MAX)",
          "old_line_content": "            if (st->codec->codec_id != CODEC_ID_H264)",
          "new_line_content": "                st->avg_frame_rate = av_d2q(1000000000.0/track->default_duration, INT_MAX);",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "inflateInit",
          "old_text": null,
          "new_text": "inflateInit(&zstream)",
          "old_line_content": "#if CONFIG_ZLIB",
          "new_line_content": "        if (inflateInit(&zstream) != Z_OK)",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": null,
          "new_api": "av_realloc",
          "old_text": null,
          "new_text": "av_realloc(pkt_data, pkt_size)",
          "old_line_content": "        zstream.avail_in = isize;",
          "new_line_content": "            pkt_data = av_realloc(pkt_data, pkt_size);",
          "content_same": false
        },
        {
          "line": 1447,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_ERROR, \"incomplete attachment\\n\")",
          "old_line_content": "    for (j=0; j<attachements_list->nb_elem; j++) {",
          "new_line_content": "            av_log(matroska->ctx, AV_LOG_ERROR, \"incomplete attachment\\n\");",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": null,
          "new_api": "av_new_stream",
          "old_text": null,
          "new_text": "av_new_stream(s, 0)",
          "old_line_content": "              attachements[j].bin.data && attachements[j].bin.size > 0)) {",
          "new_line_content": "            AVStream *st = av_new_stream(s, 0);",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": null,
          "new_api": "BZ2_bzDecompressInit",
          "old_text": null,
          "new_text": "BZ2_bzDecompressInit(&bzstream, 0, 0)",
          "old_line_content": "#if CONFIG_BZLIB",
          "new_line_content": "        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": null,
          "new_api": "av_realloc",
          "old_text": null,
          "new_text": "av_realloc(pkt_data, pkt_size)",
          "old_line_content": "        bzstream.avail_in = isize;",
          "new_line_content": "            pkt_data = av_realloc(pkt_data, pkt_size);",
          "content_same": false
        },
        {
          "line": 1459,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(st->codec->extradata, attachements[j].bin.data, attachements[j].bin.size)",
          "old_line_content": "            if(st->codec->extradata == NULL)",
          "new_line_content": "            memcpy(st->codec->extradata, attachements[j].bin.data, attachements[j].bin.size);",
          "content_same": false
        },
        {
          "line": 1463,
          "old_api": null,
          "new_api": "strlen",
          "old_text": null,
          "new_text": "strlen(ff_mkv_mime_tags[i].str)",
          "old_line_content": "",
          "new_line_content": "                             strlen(ff_mkv_mime_tags[i].str))) {",
          "content_same": false
        },
        {
          "line": 1477,
          "old_api": null,
          "new_api": "ff_new_chapter",
          "old_text": null,
          "new_text": "ff_new_chapter(s, chapters[i].uid, (AVRational){1, 1000000000},\n                           chapters[i].start, chapters[i].end,\n                           chapters[i].title)",
          "old_line_content": "        if (chapters[i].start != AV_NOPTS_VALUE && chapters[i].uid",
          "new_line_content": "            ff_new_chapter(s, chapters[i].uid, (AVRational){1, 1000000000},",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(pkt_data)",
          "old_line_content": "    *buf_size = pkt_size;",
          "new_line_content": "    av_free(pkt_data);",
          "content_same": false
        },
        {
          "line": 1489,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\")",
          "old_line_content": "    index = index_list->elem;",
          "new_line_content": "        av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\");",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": null,
          "new_api": "matroska_find_track_by_num",
          "old_text": null,
          "new_text": "matroska_find_track_by_num(matroska,\n                                                              pos[j].track)",
          "old_line_content": "        EbmlList *pos_list = &index[i].pos;",
          "new_line_content": "            MatroskaTrack *track = matroska_find_track_by_num(matroska,",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(len)",
          "old_line_content": "        es = ec/   100;  ec -=    100*es;",
          "new_line_content": "        if (!(line = av_malloc(len)))",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": null,
          "new_api": "snprintf",
          "old_text": null,
          "new_text": "snprintf(line,len,\"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s\\r\\n\",\n                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr)",
          "old_line_content": "        len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE;",
          "new_line_content": "        snprintf(line,len,\"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s\\r\\n\",",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": null,
          "new_api": "matroska_convert_tags",
          "old_text": null,
          "new_text": "matroska_convert_tags(s)",
          "old_line_content": "        }",
          "new_line_content": "    matroska_convert_tags(s);",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(pkt->data)",
          "old_line_content": "            return;",
          "new_line_content": "        av_free(pkt->data);",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": null,
          "new_api": "strlen",
          "old_text": null,
          "new_text": "strlen(line)",
          "old_line_content": "                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr);",
          "new_line_content": "        pkt->size = strlen(line);",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": null,
          "new_api": "av_realloc",
          "old_text": null,
          "new_text": "av_realloc(out->data, out->size+in->size)",
          "old_line_content": "",
          "new_line_content": "    out->data = av_realloc(out->data, out->size+in->size);",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(out->data+out->size, in->data, in->size)",
          "old_line_content": "static void matroska_merge_packets(AVPacket *out, AVPacket *in)",
          "new_line_content": "    memcpy(out->data+out->size, in->data, in->size);",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(pkt, matroska->packets[0], sizeof(AVPacket))",
          "old_line_content": "                                   AVPacket *pkt)",
          "new_line_content": "        memcpy(pkt, matroska->packets[0], sizeof(AVPacket));",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(matroska->packets[0])",
          "old_line_content": "{",
          "new_line_content": "        av_free(matroska->packets[0]);",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(tags[i].lang, \"und\")",
          "old_line_content": "    int i;",
          "new_line_content": "        const char *lang = strcmp(tags[i].lang, \"und\") ? tags[i].lang : NULL;",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": null,
          "new_api": "snprintf",
          "old_text": null,
          "new_text": "snprintf(key, sizeof(key), \"%s/%s\", prefix, tags[i].name)",
          "old_line_content": "",
          "new_line_content": "        if (prefix)  snprintf(key, sizeof(key), \"%s/%s\", prefix, tags[i].name);",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": null,
          "new_api": "av_strlcpy",
          "old_text": null,
          "new_text": "av_strlcpy(key, tags[i].name, sizeof(key))",
          "old_line_content": "    for (i=0; i < list->nb_elem; i++) {",
          "new_line_content": "        else         av_strlcpy(key, tags[i].name, sizeof(key));",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1024,
          "old_api": "av_strlcpy",
          "new_api": null,
          "old_text": "av_strlcpy(key, tags[i].name, sizeof(key))",
          "new_text": null,
          "old_line_content": "        else         av_strlcpy(key, tags[i].name, sizeof(key));",
          "new_line_content": "        if (tags[i].sub.nb_elem)",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": "av_metadata_set2",
          "new_api": null,
          "old_text": "av_metadata_set2(metadata, key, tags[i].string, 0)",
          "new_text": null,
          "old_line_content": "        av_metadata_set2(metadata, key, tags[i].string, 0);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": "av_strlcat",
          "new_api": null,
          "old_text": "av_strlcat(key, \"-\", sizeof(key))",
          "new_text": null,
          "old_line_content": "            av_strlcat(key, \"-\", sizeof(key));",
          "new_line_content": "            if (tags[i].sub.nb_elem)",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": "av_metadata_set2",
          "new_api": null,
          "old_text": "av_metadata_set2(metadata, key, tags[i].string, 0)",
          "new_text": null,
          "old_line_content": "            av_metadata_set2(metadata, key, tags[i].string, 0);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": "matroska_convert_tag",
          "new_api": null,
          "old_text": "matroska_convert_tag(s, &tags[i].sub, metadata, key)",
          "new_text": null,
          "old_line_content": "                matroska_convert_tag(s, &tags[i].sub, metadata, key);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(matroska->packets[n])",
          "new_text": null,
          "old_line_content": "            av_free(matroska->packets[n]);",
          "new_line_content": "        matroska->num_packets = 0;",
          "content_same": false
        },
        {
          "line": 1551,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&matroska->packets)",
          "new_text": null,
          "old_line_content": "        av_freep(&matroska->packets);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "matroska_convert_tag",
          "new_api": null,
          "old_text": "matroska_convert_tag(s, &tags[i].tag,\n                                         &attachment[j].stream->metadata, NULL)",
          "new_text": null,
          "old_line_content": "                    matroska_convert_tag(s, &tags[i].tag,",
          "new_line_content": "            MatroskaChapter *chapter = matroska->chapters.elem;",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": "matroska_convert_tag",
          "new_api": null,
          "old_text": "matroska_convert_tag(s, &tags[i].tag,\n                                         &chapter[j].chapter->metadata, NULL)",
          "new_text": null,
          "old_line_content": "                    matroska_convert_tag(s, &tags[i].tag,",
          "new_line_content": "            MatroskaTrack *track = matroska->tracks.elem;",
          "content_same": false
        },
        {
          "line": 1571,
          "old_api": "matroska_ebmlnum_uint",
          "new_api": null,
          "old_text": "matroska_ebmlnum_uint(matroska, data, size, &num)",
          "new_text": null,
          "old_line_content": "    if ((n = matroska_ebmlnum_uint(matroska, data, size, &num)) < 0) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_ERROR, \"EBML block data error\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(matroska->ctx, AV_LOG_ERROR, \"EBML block data error\\n\");",
          "new_line_content": "    data += n;",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": "matroska_convert_tag",
          "new_api": null,
          "old_text": "matroska_convert_tag(s, &tags[i].tag, &s->metadata,\n                                 tags[i].target.type)",
          "new_text": null,
          "old_line_content": "            matroska_convert_tag(s, &tags[i].tag, &s->metadata,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": "matroska_find_track_by_num",
          "new_api": null,
          "old_text": "matroska_find_track_by_num(matroska, num)",
          "new_text": null,
          "old_line_content": "    track = matroska_find_track_by_num(matroska, num);",
          "new_line_content": "               \"Invalid stream %\"PRIu64\" or size %u\\n\", num, size);",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_INFO,\n               \"Invalid stream %\"PRIu64\" or size %u\\n\", num, size)",
          "new_text": null,
          "old_line_content": "        av_log(matroska->ctx, AV_LOG_INFO,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "url_ftell",
          "new_api": null,
          "old_text": "url_ftell(pb)",
          "new_text": null,
          "old_line_content": "        int64_t pos = url_ftell(pb) - 1;",
          "new_line_content": "               (uint8_t) total, pos, pos);",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_ERROR,\n               \"Invalid EBML number size tag 0x%02x at pos %\"PRIu64\" (0x%\"PRIx64\")\\n\",\n               (uint8_t) total, pos, pos)",
          "new_text": null,
          "old_line_content": "        av_log(matroska->ctx, AV_LOG_ERROR,",
          "new_line_content": "        return AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": "url_ftell",
          "new_api": null,
          "old_text": "url_ftell(matroska->ctx->pb)",
          "new_text": null,
          "old_line_content": "    int64_t before_pos = url_ftell(matroska->ctx->pb);",
          "new_line_content": "    int i;",
          "content_same": false
        },
        {
          "line": 1590,
          "old_api": "AV_RB16",
          "new_api": null,
          "old_text": "AV_RB16(data)",
          "new_text": null,
          "old_line_content": "    block_time = AV_RB16(data);",
          "new_line_content": "    size -= 3;",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": "url_is_streamed",
          "new_api": null,
          "old_text": "url_is_streamed(matroska->ctx->pb)",
          "new_text": null,
          "old_line_content": "    if (url_is_streamed(matroska->ctx->pb) ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": "get_byte",
          "new_api": null,
          "old_text": "get_byte(pb)",
          "new_text": null,
          "old_line_content": "        total = (total << 8) | get_byte(pb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1604,
          "old_api": "av_add_index_entry",
          "new_api": null,
          "old_text": "av_add_index_entry(st, cluster_pos, timecode, 0,0,AVINDEX_KEYFRAME)",
          "new_text": null,
          "old_line_content": "            av_add_index_entry(st, cluster_pos, timecode, 0,0,AVINDEX_KEYFRAME);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(track->end_timecode, timecode+duration)",
          "new_text": null,
          "old_line_content": "        track->end_timecode = FFMAX(track->end_timecode, timecode+duration);",
          "new_line_content": "    if (matroska->skip_to_keyframe && track->type != MATROSKA_TRACK_TYPE_SUBTITLE) {",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": "url_fseek",
          "new_api": null,
          "old_text": "url_fseek(matroska->ctx->pb, offset, SEEK_SET)",
          "new_text": null,
          "old_line_content": "        if (url_fseek(matroska->ctx->pb, offset, SEEK_SET) != offset)",
          "new_line_content": "        /* We don't want to lose our seekhead level, so we add",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_INFO,\n                   \"Max EBML element depth (%d) reached, \"\n                   \"cannot parse further.\\n\", EBML_MAX_DEPTH)",
          "new_text": null,
          "old_line_content": "            av_log(matroska->ctx, AV_LOG_INFO,",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 1617,
          "old_api": "av_mallocz",
          "new_api": null,
          "old_text": "av_mallocz(sizeof(int))",
          "new_text": null,
          "old_line_content": "            lace_size = av_mallocz(sizeof(int));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "get_byte",
          "new_api": null,
          "old_text": "get_byte(pb)",
          "new_text": null,
          "old_line_content": "        *num = (*num << 8) | get_byte(pb);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1624,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(size>0)",
          "new_text": null,
          "old_line_content": "            assert(size>0); // size <=3 is checked before size-=3 above",
          "new_line_content": "            size -= 1;",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": "ebml_parse",
          "new_api": null,
          "old_text": "ebml_parse(matroska, matroska_segment, matroska)",
          "new_text": null,
          "old_line_content": "        ebml_parse(matroska, matroska_segment, matroska);",
          "new_line_content": "        while (matroska->num_levels) {",
          "content_same": false
        },
        {
          "line": 1628,
          "old_api": "av_mallocz",
          "new_api": null,
          "old_text": "av_mallocz(laces * sizeof(int))",
          "new_text": null,
          "old_line_content": "            lace_size = av_mallocz(laces * sizeof(int));",
          "new_line_content": "                case 0x1: /* Xiph lacing */ {",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": "get_be32",
          "new_api": null,
          "old_text": "get_be32(pb)",
          "new_text": null,
          "old_line_content": "        *num= av_int2flt(get_be32(pb));",
          "new_line_content": "    } else",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": "get_be64",
          "new_api": null,
          "old_text": "get_be64(pb)",
          "new_text": null,
          "old_line_content": "        *num= av_int2dbl(get_be64(pb));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": "url_fseek",
          "new_api": null,
          "old_text": "url_fseek(matroska->ctx->pb, before_pos, SEEK_SET)",
          "new_text": null,
          "old_line_content": "    url_fseek(matroska->ctx->pb, before_pos, SEEK_SET);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": "FF_ARRAY_ELEMS",
          "new_api": null,
          "old_text": "FF_ARRAY_ELEMS(aac_profiles)",
          "new_text": null,
          "old_line_content": "    for (profile=0; profile<FF_ARRAY_ELEMS(aac_profiles); profile++)",
          "new_line_content": "    return profile + 1;",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": "strstr",
          "new_api": null,
          "old_text": "strstr(codec_id, aac_profiles[profile])",
          "new_text": null,
          "old_line_content": "        if (strstr(codec_id, aac_profiles[profile]))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": "get_buffer",
          "new_api": null,
          "old_text": "get_buffer(pb, (uint8_t *) *str, size)",
          "new_text": null,
          "old_line_content": "    if (get_buffer(pb, (uint8_t *) *str, size) != size) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(str)",
          "new_text": null,
          "old_line_content": "        av_freep(str);",
          "new_line_content": "    (*str)[size] = '\\0';",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EIO)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EIO);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": "FF_ARRAY_ELEMS",
          "new_api": null,
          "old_text": "FF_ARRAY_ELEMS(ff_mpeg4audio_sample_rates)",
          "new_text": null,
          "old_line_content": "    for (sri=0; sri<FF_ARRAY_ELEMS(ff_mpeg4audio_sample_rates); sri++)",
          "new_line_content": "    return sri;",
          "content_same": false
        },
        {
          "line": 1660,
          "old_api": "matroska_ebmlnum_uint",
          "new_api": null,
          "old_text": "matroska_ebmlnum_uint(matroska, data, size, &num)",
          "new_text": null,
          "old_line_content": "                    n = matroska_ebmlnum_uint(matroska, data, size, &num);",
          "new_line_content": "                               \"EBML block data error\\n\");",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_INFO,\n                               \"EBML block data error\\n\")",
          "new_text": null,
          "old_line_content": "                        av_log(matroska->ctx, AV_LOG_INFO,",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(bin->data)",
          "new_text": null,
          "old_line_content": "    av_free(bin->data);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(length)",
          "new_text": null,
          "old_line_content": "    if (!(bin->data = av_malloc(length)))",
          "new_line_content": "    bin->size = length;",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "get_buffer",
          "new_api": null,
          "old_text": "get_buffer(pb, bin->data, length)",
          "new_text": null,
          "old_line_content": "    if (get_buffer(pb, bin->data, length) != length) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&bin->data)",
          "new_text": null,
          "old_line_content": "        av_freep(&bin->data);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EIO)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EIO);",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": "matroska_ebmlnum_sint",
          "new_api": null,
          "old_text": "matroska_ebmlnum_sint(matroska, data, size, &snum)",
          "new_text": null,
          "old_line_content": "                        r = matroska_ebmlnum_sint(matroska, data, size, &snum);",
          "new_line_content": "                                   \"EBML block data error\\n\");",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_INFO,\n                                   \"EBML block data error\\n\")",
          "new_text": null,
          "old_line_content": "                            av_log(matroska->ctx, AV_LOG_INFO,",
          "new_line_content": "                        }",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_ERROR,\n               \"EBML header using unsupported features\\n\"\n               \"(EBML version %\"PRIu64\", doctype %s, doc version %\"PRIu64\")\\n\",\n               ebml.version, ebml.doctype, ebml.doctype_version)",
          "new_text": null,
          "old_line_content": "        av_log(matroska->ctx, AV_LOG_ERROR,",
          "new_line_content": "               ebml.version, ebml.doctype, ebml.doctype_version);",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_ERROR,\n               \"File moves beyond max. allowed depth (%d)\\n\", EBML_MAX_DEPTH)",
          "new_text": null,
          "old_line_content": "        av_log(matroska->ctx, AV_LOG_ERROR,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOSYS)",
          "new_text": null,
          "old_line_content": "        return AVERROR(ENOSYS);",
          "new_line_content": "    level = &matroska->levels[matroska->num_levels++];",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_WARNING, \"Unknown EBML doctype '%s'\\n\", ebml.doctype)",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_WARNING, \"Unknown EBML doctype '%s'\\n\", ebml.doctype);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": "url_ftell",
          "new_api": null,
          "old_text": "url_ftell(pb)",
          "new_text": null,
          "old_line_content": "    level->start = url_ftell(pb);",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": "ebml_parse",
          "new_api": null,
          "old_text": "ebml_parse(matroska, matroska_segments, matroska)",
          "new_text": null,
          "old_line_content": "    if ((res = ebml_parse(matroska, matroska_segments, matroska)) < 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "matroska_execute_seekhead",
          "new_api": null,
          "old_text": "matroska_execute_seekhead(matroska)",
          "new_text": null,
          "old_line_content": "    matroska_execute_seekhead(matroska);",
          "new_line_content": "        matroska->time_scale = 1000000;",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": "av_metadata_set2",
          "new_api": null,
          "old_text": "av_metadata_set2(&s->metadata, \"title\", matroska->title, 0)",
          "new_text": null,
          "old_line_content": "    av_metadata_set2(&s->metadata, \"title\", matroska->title, 0);",
          "new_line_content": "    for (i=0; i < matroska->tracks.nb_elem; i++) {",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "init_put_byte",
          "new_api": null,
          "old_text": "init_put_byte(&pb, data, size, 0, NULL, NULL, NULL, NULL)",
          "new_text": null,
          "old_line_content": "    init_put_byte(&pb, data, size, 0, NULL, NULL, NULL, NULL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(size, 8)",
          "new_text": null,
          "old_line_content": "    return ebml_read_num(matroska, &pb, FFMIN(size, 8), num);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 1714,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(track->audio.buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps)",
          "new_text": null,
          "old_line_content": "                            memcpy(track->audio.buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);",
          "new_line_content": "                        if (st->codec->codec_id == CODEC_ID_SIPR)",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": "ff_rm_reorder_sipr_data",
          "new_api": null,
          "old_text": "ff_rm_reorder_sipr_data(track->audio.buf, h, w)",
          "new_text": null,
          "old_line_content": "                            ff_rm_reorder_sipr_data(track->audio.buf, h, w);",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": "av_mallocz",
          "new_api": null,
          "old_text": "av_mallocz(sizeof(AVPacket))",
          "new_text": null,
          "old_line_content": "                    pkt = av_mallocz(sizeof(AVPacket));",
          "new_line_content": "                           + a * (h*w / a - track->audio.pkt_cnt--), a);",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": "matroska_ebmlnum_uint",
          "new_api": null,
          "old_text": "matroska_ebmlnum_uint(matroska, data, size, &unum)",
          "new_text": null,
          "old_line_content": "    if ((res = matroska_ebmlnum_uint(matroska, data, size, &unum)) < 0)",
          "new_line_content": "    /* make signed (weird way) */",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": "av_new_packet",
          "new_api": null,
          "old_text": "av_new_packet(pkt, a)",
          "new_text": null,
          "old_line_content": "                    av_new_packet(pkt, a);",
          "new_line_content": "                    pkt->pos = pos;",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_INFO,\n                   \"Unknown or unsupported track type %\"PRIu64\"\\n\",\n                   track->type)",
          "new_text": null,
          "old_line_content": "            av_log(matroska->ctx, AV_LOG_INFO,",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 1726,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(pkt->data, track->audio.buf\n                           + a * (h*w / a - track->audio.pkt_cnt--), a)",
          "new_text": null,
          "old_line_content": "                    memcpy(pkt->data, track->audio.buf",
          "new_line_content": "                    pkt->stream_index = st->index;",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": "dynarray_add",
          "new_api": null,
          "old_text": "dynarray_add(&matroska->packets,&matroska->num_packets,pkt)",
          "new_text": null,
          "old_line_content": "                    dynarray_add(&matroska->packets,&matroska->num_packets,pkt);",
          "new_line_content": "                MatroskaTrackEncoding *encodings = track->encodings.elem;",
          "content_same": false
        },
        {
          "line": 1738,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_ERROR, \"Invalid packet size\\n\")",
          "new_text": null,
          "old_line_content": "                    av_log(matroska->ctx, AV_LOG_ERROR, \"Invalid packet size\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": "matroska_decode_buffer",
          "new_api": null,
          "old_text": "matroska_decode_buffer(&pkt_data,&pkt_size, track)",
          "new_text": null,
          "old_line_content": "                    offset = matroska_decode_buffer(&pkt_data,&pkt_size, track);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_ERROR,\n                   \"Multiple combined encodings no supported\")",
          "new_text": null,
          "old_line_content": "            av_log(matroska->ctx, AV_LOG_ERROR,",
          "new_line_content": "            if (encodings[0].type ||",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_INFO, \"Unknown entry 0x%X\\n\", id)",
          "new_text": null,
          "old_line_content": "        av_log(matroska->ctx, AV_LOG_INFO, \"Unknown entry 0x%X\\n\", id);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": "ebml_parse_elem",
          "new_api": null,
          "old_text": "ebml_parse_elem(matroska, &syntax[i], data)",
          "new_text": null,
          "old_line_content": "    return ebml_parse_elem(matroska, &syntax[i], data);",
          "new_line_content": "static int ebml_parse(MatroskaDemuxContext *matroska, EbmlSyntax *syntax,",
          "content_same": false
        },
        {
          "line": 1750,
          "old_api": "av_new_packet",
          "new_api": null,
          "old_text": "av_new_packet(pkt, pkt_size+offset)",
          "new_text": null,
          "old_line_content": "                if (av_new_packet(pkt, pkt_size+offset) < 0) {",
          "new_line_content": "                    break;",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(pkt)",
          "new_text": null,
          "old_line_content": "                    av_free(pkt);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1752,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "                    res = AVERROR(ENOMEM);",
          "new_line_content": "                if (offset)",
          "content_same": false
        },
        {
          "line": 1756,
          "old_api": "memcpy (pkt->data, encodings->compression.settings.data, offset)",
          "new_api": null,
          "old_text": "memcpy (pkt->data, encodings->compression.settings.data, offset)",
          "new_text": null,
          "old_line_content": "                    memcpy (pkt->data, encodings->compression.settings.data, offset);",
          "new_line_content": "                if (pkt_data != data)",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": "ebml_read_num",
          "new_api": null,
          "old_text": "ebml_read_num(matroska, matroska->ctx->pb, 4, &id)",
          "new_text": null,
          "old_line_content": "        int res = ebml_read_num(matroska, matroska->ctx->pb, 4, &id);",
          "new_line_content": "        matroska->current_id = id | 1 << 7*res;",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_ERROR,\n                       \"Unsupported encoding type\")",
          "new_text": null,
          "old_line_content": "                av_log(matroska->ctx, AV_LOG_ERROR,",
          "new_line_content": "                uint8_t *codec_priv = track->codec_priv.data;",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(pkt_data)",
          "new_text": null,
          "old_line_content": "                    av_free(pkt_data);",
          "new_line_content": "                    pkt->flags = is_keyframe;",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "ebml_parse_id",
          "new_api": null,
          "old_text": "ebml_parse_id(matroska, syntax, matroska->current_id, data)",
          "new_text": null,
          "old_line_content": "    return ebml_parse_id(matroska, syntax, matroska->current_id, data);",
          "new_line_content": "static int ebml_parse_nest(MatroskaDemuxContext *matroska, EbmlSyntax *syntax,",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": "matroska_decode_buffer",
          "new_api": null,
          "old_text": "matroska_decode_buffer(&track->codec_priv.data,\n                                                    &track->codec_priv.size,\n                                                    track)",
          "new_text": null,
          "old_line_content": "                int offset = matroska_decode_buffer(&track->codec_priv.data,",
          "new_line_content": "                if (offset < 0) {",
          "content_same": false
        },
        {
          "line": 1262,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(track->codec_priv.data,\n                           encodings[0].compression.settings.data, offset)",
          "new_text": null,
          "old_line_content": "                    memcpy(track->codec_priv.data,",
          "new_line_content": "                           track->codec_priv.size);",
          "content_same": false
        },
        {
          "line": 1264,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(track->codec_priv.data+offset, codec_priv,\n                           track->codec_priv.size)",
          "new_text": null,
          "old_line_content": "                    memcpy(track->codec_priv.data+offset, codec_priv,",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": "matroska_fix_ass_packet",
          "new_api": null,
          "old_text": "matroska_fix_ass_packet(matroska, pkt, duration)",
          "new_text": null,
          "old_line_content": "                    matroska_fix_ass_packet(matroska, pkt, duration);",
          "new_line_content": "                    timecode != AV_NOPTS_VALUE &&",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "av_strdup",
          "new_api": null,
          "old_text": "av_strdup(syntax[i].def.s)",
          "new_text": null,
          "old_line_content": "            *(char    **)((char *)data+syntax[i].data_offset) = av_strdup(syntax[i].def.s);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1269,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(codec_priv)",
          "new_text": null,
          "old_line_content": "                    av_free(codec_priv);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1784,
          "old_api": "matroska_merge_packets",
          "new_api": null,
          "old_text": "matroska_merge_packets(matroska->prev_pkt, pkt)",
          "new_text": null,
          "old_line_content": "                    matroska_merge_packets(matroska->prev_pkt, pkt);",
          "new_line_content": "                    matroska->prev_pkt = pkt;",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "ebml_level_end",
          "new_api": null,
          "old_text": "ebml_level_end(matroska)",
          "new_text": null,
          "old_line_content": "    while (!res && !ebml_level_end(matroska))",
          "new_line_content": "    return res;",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "ebml_parse",
          "new_api": null,
          "old_text": "ebml_parse(matroska, syntax, data)",
          "new_text": null,
          "old_line_content": "        res = ebml_parse(matroska, syntax, data);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": "strncmp",
          "new_api": null,
          "old_text": "strncmp(ff_mkv_codec_tags[j].str, track->codec_id,\n                        strlen(ff_mkv_codec_tags[j].str))",
          "new_text": null,
          "old_line_content": "            if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,",
          "new_line_content": "                break;",
          "content_same": false
        },
        {
          "line": 1275,
          "old_api": "strlen",
          "new_api": null,
          "old_text": "strlen(ff_mkv_codec_tags[j].str)",
          "new_text": null,
          "old_line_content": "                        strlen(ff_mkv_codec_tags[j].str))){",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1786,
          "old_api": "dynarray_add",
          "new_api": null,
          "old_text": "dynarray_add(&matroska->packets,&matroska->num_packets,pkt)",
          "new_text": null,
          "old_line_content": "                    dynarray_add(&matroska->packets,&matroska->num_packets,pkt);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1281,
          "old_api": "av_new_stream",
          "new_api": null,
          "old_text": "av_new_stream(s, 0)",
          "new_text": null,
          "old_line_content": "        st = track->stream = av_new_stream(s, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1283,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "            return AVERROR(ENOMEM);",
          "new_line_content": "            && track->codec_priv.size >= 40",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(track->codec_id, \"V_MS/VFW/FOURCC\")",
          "new_text": null,
          "old_line_content": "        if (!strcmp(track->codec_id, \"V_MS/VFW/FOURCC\")",
          "new_line_content": "            track->ms_compat = 1;",
          "content_same": false
        },
        {
          "line": 1798,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(lace_size)",
          "new_text": null,
          "old_line_content": "    av_free(lace_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": "av_realloc",
          "new_api": null,
          "old_text": "av_realloc(list->elem, (list->nb_elem+1)*syntax->list_elem_size)",
          "new_text": null,
          "old_line_content": "        list->elem = av_realloc(list->elem, (list->nb_elem+1)*syntax->list_elem_size);",
          "new_line_content": "        list->nb_elem++;",
          "content_same": false
        },
        {
          "line": 1290,
          "old_api": "ff_codec_get_id",
          "new_api": null,
          "old_text": "ff_codec_get_id(ff_codec_bmp_tags, track->video.fourcc)",
          "new_text": null,
          "old_line_content": "            codec_id = ff_codec_get_id(ff_codec_bmp_tags, track->video.fourcc);",
          "new_line_content": "                   && track->codec_priv.size >= 14",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(data, 0, syntax->list_elem_size)",
          "new_text": null,
          "old_line_content": "        memset(data, 0, syntax->list_elem_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": "init_put_byte",
          "new_api": null,
          "old_text": "init_put_byte(&b, track->codec_priv.data, track->codec_priv.size,\n                          URL_RDONLY, NULL, NULL, NULL, NULL)",
          "new_text": null,
          "old_line_content": "            init_put_byte(&b, track->codec_priv.data, track->codec_priv.size,",
          "new_line_content": "            codec_id = st->codec->codec_id;",
          "content_same": false
        },
        {
          "line": 1808,
          "old_api": "url_ftell",
          "new_api": null,
          "old_text": "url_ftell(matroska->ctx->pb)",
          "new_text": null,
          "old_line_content": "    int64_t pos = url_ftell(matroska->ctx->pb);",
          "new_line_content": "        pos -= 4;  /* sizeof the ID which was already read */",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": "ebml_read_num",
          "new_api": null,
          "old_text": "ebml_read_num(matroska, pb, 8, &length)",
          "new_text": null,
          "old_line_content": "        if ((res = ebml_read_num(matroska, pb, 8, &length)) < 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(track->codec_priv.size, 18)",
          "new_text": null,
          "old_line_content": "            extradata_offset = FFMIN(track->codec_priv.size, 18);",
          "new_line_content": "                   && (track->codec_priv.data != NULL)) {",
          "content_same": false
        },
        {
          "line": 1812,
          "old_api": "ebml_parse",
          "new_api": null,
          "old_text": "ebml_parse(matroska, matroska_clusters, &cluster)",
          "new_text": null,
          "old_line_content": "    res = ebml_parse(matroska, matroska_clusters, &cluster);",
          "new_line_content": "    for (i=0; i<blocks_list->nb_elem; i++)",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": "AV_RL32",
          "new_api": null,
          "old_text": "AV_RL32(track->codec_priv.data)",
          "new_text": null,
          "old_line_content": "            track->video.fourcc = AV_RL32(track->codec_priv.data);",
          "new_line_content": "            switch (track->audio.bitdepth) {",
          "content_same": false
        },
        {
          "line": 1304,
          "old_api": "ff_codec_get_id",
          "new_api": null,
          "old_text": "ff_codec_get_id(codec_movvideo_tags, track->video.fourcc)",
          "new_text": null,
          "old_line_content": "            codec_id=ff_codec_get_id(codec_movvideo_tags, track->video.fourcc);",
          "new_line_content": "            case  8:  codec_id = CODEC_ID_PCM_U8;     break;",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": "ebml_read_ascii (pb, length, data)",
          "new_api": null,
          "old_text": "ebml_read_ascii (pb, length, data)",
          "new_text": null,
          "old_line_content": "    case EBML_UTF8:  res = ebml_read_ascii (pb, length, data);  break;",
          "new_line_content": "                         return res;",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": "ebml_read_binary",
          "new_api": null,
          "old_text": "ebml_read_binary(pb, length, data)",
          "new_text": null,
          "old_line_content": "    case EBML_BIN:   res = ebml_read_binary(pb, length, data);  break;",
          "new_line_content": "                     if (id == MATROSKA_ID_SEGMENT)",
          "content_same": false
        },
        {
          "line": 1818,
          "old_api": "matroska_parse_block",
          "new_api": null,
          "old_text": "matroska_parse_block(matroska,\n                                     blocks[i].bin.data, blocks[i].bin.size,\n                                     blocks[i].bin.pos,  cluster.timecode,\n                                     blocks[i].duration, is_keyframe,\n                                     pos)",
          "new_text": null,
          "old_line_content": "            res=matroska_parse_block(matroska,",
          "new_line_content": "                                     blocks[i].duration, is_keyframe,",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": "url_ftell",
          "new_api": null,
          "old_text": "url_ftell(matroska->ctx->pb)",
          "new_text": null,
          "old_line_content": "                         matroska->segment_start = url_ftell(matroska->ctx->pb);",
          "new_line_content": "    case EBML_STOP:  return 1;",
          "content_same": false
        },
        {
          "line": 1824,
          "old_api": "ebml_free",
          "new_api": null,
          "old_text": "ebml_free(matroska_cluster, &cluster)",
          "new_text": null,
          "old_line_content": "    ebml_free(matroska_cluster, &cluster);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "ebml_parse_id",
          "new_api": null,
          "old_text": "ebml_parse_id(matroska, syntax->def.n, id, data)",
          "new_text": null,
          "old_line_content": "    case EBML_PASS:  return ebml_parse_id(matroska, syntax->def.n, id, data);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_ERROR, \"Invalid element\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(matroska->ctx, AV_LOG_ERROR, \"Invalid element\\n\");",
          "new_line_content": "    return res;",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EIO)",
          "new_text": null,
          "old_line_content": "    else if (res == AVERROR(EIO))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_ERROR, \"Read error\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(matroska->ctx, AV_LOG_ERROR, \"Read error\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": "matroska_aac_profile",
          "new_api": null,
          "old_text": "matroska_aac_profile(track->codec_id)",
          "new_text": null,
          "old_line_content": "            int profile = matroska_aac_profile(track->codec_id);",
          "new_line_content": "            if (extradata == NULL)",
          "content_same": false
        },
        {
          "line": 1322,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(5)",
          "new_text": null,
          "old_line_content": "            extradata = av_malloc(5);",
          "new_line_content": "            extradata[0] = (profile << 3) | ((sri&0x0E) >> 1);",
          "content_same": false
        },
        {
          "line": 1836,
          "old_api": "matroska_parse_cluster",
          "new_api": null,
          "old_text": "matroska_parse_cluster(matroska)",
          "new_text": null,
          "old_line_content": "        matroska_parse_cluster(matroska);",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 1327,
          "old_api": "strstr",
          "new_api": null,
          "old_text": "strstr(track->codec_id, \"SBR\")",
          "new_text": null,
          "old_line_content": "            if (strstr(track->codec_id, \"SBR\")) {",
          "new_line_content": "                extradata[3] = 0xE5;",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": "matroska_aac_sri",
          "new_api": null,
          "old_text": "matroska_aac_sri(track->audio.out_samplerate)",
          "new_text": null,
          "old_line_content": "                sri = matroska_aac_sri(track->audio.out_samplerate);",
          "new_line_content": "                extradata[4] = 0x80 | (sri<<3);",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(data_off)",
          "new_text": null,
          "old_line_content": "        case EBML_UTF8:  av_freep(data_off);                      break;",
          "new_line_content": "            if (syntax[i].list_elem_size) {",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&((EbmlBin *)data_off)->data)",
          "new_text": null,
          "old_line_content": "        case EBML_BIN:   av_freep(&((EbmlBin *)data_off)->data);  break;",
          "new_line_content": "                EbmlList *list = data_off;",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(list->elem)",
          "new_text": null,
          "old_line_content": "                av_free(list->elem);",
          "new_line_content": "        default:  break;",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "ebml_free",
          "new_api": null,
          "old_text": "ebml_free(syntax[i].def.n, data_off)",
          "new_text": null,
          "old_line_content": "                ebml_free(syntax[i].def.n, data_off);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1856,
          "old_api": "av_index_search_timestamp",
          "new_api": null,
          "old_text": "av_index_search_timestamp(st, timestamp, flags)",
          "new_text": null,
          "old_line_content": "        while ((index = av_index_search_timestamp(st, timestamp, flags)) < 0) {",
          "new_line_content": "                break;",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": "put_le16",
          "new_api": null,
          "old_text": "put_le16(&b, track->audio.bitdepth)",
          "new_text": null,
          "old_line_content": "            put_le16(&b, track->audio.bitdepth);",
          "new_line_content": "        } else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 ||",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": "put_le32",
          "new_api": null,
          "old_text": "put_le32(&b, track->audio.out_samplerate)",
          "new_text": null,
          "old_line_content": "            put_le32(&b, track->audio.out_samplerate);",
          "new_line_content": "                   codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) {",
          "content_same": false
        },
        {
          "line": 1347,
          "old_api": "put_le32",
          "new_api": null,
          "old_text": "put_le32(&b, matroska->ctx->duration * track->audio.out_samplerate)",
          "new_text": null,
          "old_line_content": "            put_le32(&b, matroska->ctx->duration * track->audio.out_samplerate);",
          "new_line_content": "            extradata_offset = 26;",
          "content_same": false
        },
        {
          "line": 1857,
          "old_api": "matroska_clear_queue",
          "new_api": null,
          "old_text": "matroska_clear_queue(matroska)",
          "new_text": null,
          "old_line_content": "            matroska_clear_queue(matroska);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": "matroska_parse_cluster",
          "new_api": null,
          "old_text": "matroska_parse_cluster(matroska)",
          "new_text": null,
          "old_line_content": "            if (matroska_parse_cluster(matroska) < 0)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1863,
          "old_api": "matroska_clear_queue",
          "new_api": null,
          "old_text": "matroska_clear_queue(matroska)",
          "new_text": null,
          "old_line_content": "    matroska_clear_queue(matroska);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": "AV_RB32",
          "new_api": null,
          "old_text": "AV_RB32(p->buf)",
          "new_text": null,
          "old_line_content": "    if (AV_RB32(p->buf) != EBML_ID_HEADER)",
          "new_line_content": "    /* length of header */",
          "content_same": false
        },
        {
          "line": 1872,
          "old_api": "av_index_search_timestamp",
          "new_api": null,
          "old_text": "av_index_search_timestamp(tracks[i].stream, st->index_entries[index].timestamp, AVSEEK_FLAG_BACKWARD)",
          "new_text": null,
          "old_line_content": "            index_sub = av_index_search_timestamp(tracks[i].stream, st->index_entries[index].timestamp, AVSEEK_FLAG_BACKWARD);",
          "new_line_content": "                && st->index_entries[index].timestamp - st->index_entries[index_sub].timestamp < 30000000000/matroska->time_scale)",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": "get_be16",
          "new_api": null,
          "old_text": "get_be16(&b)",
          "new_text": null,
          "old_line_content": "            track->audio.frame_size      = get_be16(&b);",
          "new_line_content": "            if (codec_id == CODEC_ID_RA_288) {",
          "content_same": false
        },
        {
          "line": 1365,
          "old_api": "get_be16",
          "new_api": null,
          "old_text": "get_be16(&b)",
          "new_text": null,
          "old_line_content": "            track->audio.sub_packet_size = get_be16(&b);",
          "new_line_content": "                st->codec->block_align = track->audio.coded_framesize;",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(track->audio.frame_size * track->audio.sub_packet_h)",
          "new_text": null,
          "old_line_content": "            track->audio.buf = av_malloc(track->audio.frame_size * track->audio.sub_packet_h);",
          "new_line_content": "                track->codec_priv.size = 0;",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": "url_fseek",
          "new_api": null,
          "old_text": "url_fseek(s->pb, st->index_entries[index_min].pos, SEEK_SET)",
          "new_text": null,
          "old_line_content": "    url_fseek(s->pb, st->index_entries[index_min].pos, SEEK_SET);",
          "new_line_content": "    matroska->done = 0;",
          "content_same": false
        },
        {
          "line": 1884,
          "old_api": "av_update_cur_dts",
          "new_api": null,
          "old_text": "av_update_cur_dts(s, st, st->index_entries[index].timestamp)",
          "new_text": null,
          "old_line_content": "    av_update_cur_dts(s, st, st->index_entries[index].timestamp);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": "strlen",
          "new_api": null,
          "old_text": "strlen(matroska_doctypes[i])",
          "new_text": null,
          "old_line_content": "        int probelen = strlen(matroska_doctypes[i]);",
          "new_line_content": "                return AVPROBE_SCORE_MAX;",
          "content_same": false
        },
        {
          "line": 1894,
          "old_api": "matroska_clear_queue",
          "new_api": null,
          "old_text": "matroska_clear_queue(matroska)",
          "new_text": null,
          "old_line_content": "    matroska_clear_queue(matroska);",
          "new_line_content": "        if (tracks[n].type == MATROSKA_TRACK_TYPE_AUDIO)",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": "memcmp",
          "new_api": null,
          "old_text": "memcmp(p->buf+n, matroska_doctypes[i], probelen)",
          "new_text": null,
          "old_line_content": "            if (!memcmp(p->buf+n, matroska_doctypes[i], probelen))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1383,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_INFO,\n                   \"Unknown/unsupported CodecID %s.\\n\", track->codec_id)",
          "new_text": null,
          "old_line_content": "            av_log(matroska->ctx, AV_LOG_INFO,",
          "new_line_content": "        if (track->time_scale < 0.01)",
          "content_same": false
        },
        {
          "line": 1898,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(tracks[n].audio.buf)",
          "new_text": null,
          "old_line_content": "            av_free(tracks[n].audio.buf);",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 1899,
          "old_api": "ebml_free",
          "new_api": null,
          "old_text": "ebml_free(matroska_segment, matroska)",
          "new_text": null,
          "old_line_content": "    ebml_free(matroska_segment, matroska);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1388,
          "old_api": "av_set_pts_info",
          "new_api": null,
          "old_text": "av_set_pts_info(st, 64, matroska->time_scale*track->time_scale, 1000*1000*1000)",
          "new_text": null,
          "old_line_content": "        av_set_pts_info(st, 64, matroska->time_scale*track->time_scale, 1000*1000*1000); /* 64 bit pts in ns */",
          "new_line_content": "        st->start_time = 0;",
          "content_same": false
        },
        {
          "line": 1392,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(track->language, \"und\")",
          "new_text": null,
          "old_line_content": "        if (strcmp(track->language, \"und\"))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1393,
          "old_api": "av_metadata_set2",
          "new_api": null,
          "old_text": "av_metadata_set2(&st->metadata, \"language\", track->language, 0)",
          "new_text": null,
          "old_line_content": "            av_metadata_set2(&st->metadata, \"language\", track->language, 0);",
          "new_line_content": "        if (track->flag_default)",
          "content_same": false
        },
        {
          "line": 1394,
          "old_api": "av_metadata_set2",
          "new_api": null,
          "old_text": "av_metadata_set2(&st->metadata, \"title\", track->name, 0)",
          "new_text": null,
          "old_line_content": "        av_metadata_set2(&st->metadata, \"title\", track->name, 0);",
          "new_line_content": "            st->disposition |= AV_DISPOSITION_DEFAULT;",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"Matroska/WebM file format\")",
          "new_text": null,
          "old_line_content": "    NULL_IF_CONFIG_SMALL(\"Matroska/WebM file format\"),",
          "new_line_content": "    matroska_read_header,",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_ERROR, \"Invalid track number %d\\n\", num)",
          "new_text": null,
          "old_line_content": "    av_log(matroska->ctx, AV_LOG_ERROR, \"Invalid track number %d\\n\", num);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1402,
          "old_api": "av_reduce",
          "new_api": null,
          "old_text": "av_reduce(&st->codec->time_base.num, &st->codec->time_base.den,\n                      track->default_duration, 1000000000, 30000)",
          "new_text": null,
          "old_line_content": "            av_reduce(&st->codec->time_base.num, &st->codec->time_base.den,",
          "new_line_content": "        if (!st->codec->extradata) {",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "                    return AVERROR(ENOMEM);",
          "new_line_content": "                       track->codec_priv.data + extradata_offset,",
          "content_same": false
        },
        {
          "line": 1415,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(st->codec->extradata,\n                       track->codec_priv.data + extradata_offset,\n                       track->codec_priv.size)",
          "new_text": null,
          "old_line_content": "                memcpy(st->codec->extradata,",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": "av_realloc",
          "new_api": null,
          "old_text": "av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING)",
          "new_text": null,
          "old_line_content": "            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);",
          "new_line_content": "        if (result)",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": "av_lzo1x_decode",
          "new_api": null,
          "old_text": "av_lzo1x_decode(pkt_data, &olen, data, &isize)",
          "new_text": null,
          "old_line_content": "            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);",
          "new_line_content": "            goto failed;",
          "content_same": false
        },
        {
          "line": 1426,
          "old_api": "av_reduce",
          "new_api": null,
          "old_text": "av_reduce(&st->sample_aspect_ratio.num,\n                      &st->sample_aspect_ratio.den,\n                      st->codec->height * track->video.display_width,\n                      st->codec-> width * track->video.display_height,\n                      255)",
          "new_text": null,
          "old_line_content": "            av_reduce(&st->sample_aspect_ratio.num,",
          "new_line_content": "                      st->codec-> width * track->video.display_height,",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": "av_d2q",
          "new_api": null,
          "old_text": "av_d2q(1000000000.0/track->default_duration, INT_MAX)",
          "new_text": null,
          "old_line_content": "                st->avg_frame_rate = av_d2q(1000000000.0/track->default_duration, INT_MAX);",
          "new_line_content": "            st->codec->sample_rate = track->audio.out_samplerate;",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": "inflateInit",
          "new_api": null,
          "old_text": "inflateInit(&zstream)",
          "new_text": null,
          "old_line_content": "        if (inflateInit(&zstream) != Z_OK)",
          "new_line_content": "        zstream.avail_in = isize;",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": "inflateEnd",
          "new_api": null,
          "old_text": "inflateEnd(&zstream)",
          "new_text": null,
          "old_line_content": "        inflateEnd(&zstream);",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_ERROR, \"incomplete attachment\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(matroska->ctx, AV_LOG_ERROR, \"incomplete attachment\\n\");",
          "new_line_content": "            if (st == NULL)",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "BZ2_bzDecompressInit",
          "new_api": null,
          "old_text": "BZ2_bzDecompressInit(&bzstream, 0, 0)",
          "new_text": null,
          "old_line_content": "        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)",
          "new_line_content": "        bzstream.avail_in = isize;",
          "content_same": false
        },
        {
          "line": 1458,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(attachements[j].bin.size)",
          "new_text": null,
          "old_line_content": "            st->codec->extradata  = av_malloc(attachements[j].bin.size);",
          "new_line_content": "            st->codec->extradata_size = attachements[j].bin.size;",
          "content_same": false
        },
        {
          "line": 1465,
          "old_api": "strncmp",
          "new_api": null,
          "old_text": "strncmp(ff_mkv_mime_tags[i].str, attachements[j].mime,\n                             strlen(ff_mkv_mime_tags[i].str))",
          "new_text": null,
          "old_line_content": "                if (!strncmp(ff_mkv_mime_tags[i].str, attachements[j].mime,",
          "new_line_content": "                    break;",
          "content_same": false
        },
        {
          "line": 1466,
          "old_api": "strlen",
          "new_api": null,
          "old_text": "strlen(ff_mkv_mime_tags[i].str)",
          "new_text": null,
          "old_line_content": "                             strlen(ff_mkv_mime_tags[i].str))) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "BZ2_bzDecompressEnd",
          "new_api": null,
          "old_text": "BZ2_bzDecompressEnd(&bzstream)",
          "new_text": null,
          "old_line_content": "        BZ2_bzDecompressEnd(&bzstream);",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(pkt_data)",
          "new_text": null,
          "old_line_content": "    av_free(pkt_data);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1483,
          "old_api": "av_metadata_set2",
          "new_api": null,
          "old_text": "av_metadata_set2(&chapters[i].chapter->metadata,\n                             \"title\", chapters[i].title, 0)",
          "new_text": null,
          "old_line_content": "            av_metadata_set2(&chapters[i].chapter->metadata,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\");",
          "new_line_content": "    for (i=0; i<index_list->nb_elem; i++) {",
          "content_same": false
        },
        {
          "line": 1502,
          "old_api": "av_add_index_entry",
          "new_api": null,
          "old_text": "av_add_index_entry(track->stream,\n                                   pos[j].pos + matroska->segment_start,\n                                   index[i].time/index_scale, 0, 0,\n                                   AVINDEX_KEYFRAME)",
          "new_text": null,
          "old_line_content": "                av_add_index_entry(track->stream,",
          "new_line_content": "                                   AVINDEX_KEYFRAME);",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(len)",
          "new_text": null,
          "old_line_content": "        if (!(line = av_malloc(len)))",
          "new_line_content": "                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr);",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": "snprintf",
          "new_api": null,
          "old_text": "snprintf(line,len,\"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s\\r\\n\",\n                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr)",
          "new_text": null,
          "old_line_content": "        snprintf(line,len,\"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s\\r\\n\",",
          "new_line_content": "        pkt->data = line;",
          "content_same": false
        },
        {
          "line": 1509,
          "old_api": "matroska_convert_tags",
          "new_api": null,
          "old_text": "matroska_convert_tags(s)",
          "new_text": null,
          "old_line_content": "    matroska_convert_tags(s);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(pkt->data)",
          "new_text": null,
          "old_line_content": "        av_free(pkt->data);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "strlen",
          "new_api": null,
          "old_text": "strlen(line)",
          "new_text": null,
          "old_line_content": "        pkt->size = strlen(line);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": "av_destruct_packet",
          "new_api": null,
          "old_text": "av_destruct_packet(in)",
          "new_text": null,
          "old_line_content": "    av_destruct_packet(in);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(in)",
          "new_text": null,
          "old_line_content": "    av_free(in);",
          "new_line_content": "static void matroska_convert_tag(AVFormatContext *s, EbmlList *list,",
          "content_same": false
        },
        {
          "line": 1523,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(matroska->packets[0])",
          "new_text": null,
          "old_line_content": "        av_free(matroska->packets[0]);",
          "new_line_content": "                    (matroska->num_packets - 1) * sizeof(AVPacket *));",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&matroska->packets)",
          "new_text": null,
          "old_line_content": "            av_freep(&matroska->packets);",
          "new_line_content": "        return 0;",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(tags[i].lang, \"und\")",
          "new_text": null,
          "old_line_content": "        const char *lang = strcmp(tags[i].lang, \"und\") ? tags[i].lang : NULL;",
          "new_line_content": "        if (tags[i].def || !lang) {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 58,
      "total_additions": 177,
      "total_deletions": 177,
      "total_api_changes": 412
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 412,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          559,
          560,
          569,
          572,
          541,
          542
        ]
      }
    },
    "api_calls_before": 331,
    "api_calls_after": 331,
    "diff_info": {
      "added_lines": 4,
      "removed_lines": 7,
      "total_diff_lines": 37
    }
  }
}