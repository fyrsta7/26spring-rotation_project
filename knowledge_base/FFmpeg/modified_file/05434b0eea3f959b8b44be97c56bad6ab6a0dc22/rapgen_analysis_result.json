{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/05434b0eea3f959b8b44be97c56bad6ab6a0dc22",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/05434b0eea3f959b8b44be97c56bad6ab6a0dc22/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/05434b0eea3f959b8b44be97c56bad6ab6a0dc22/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/05434b0eea3f959b8b44be97c56bad6ab6a0dc22/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 172,
          "old_api": "pow",
          "new_api": "powf",
          "old_text": "pow(2, i)",
          "new_text": "powf(2, -63)",
          "old_line_content": "        rootpow2tab[63 + i] = sqrt(pow(2, i));",
          "new_line_content": "    float exp2_val = powf(2, -63);",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": "av_log",
          "new_api": "sqrt",
          "old_text": "av_log(q->avctx, AV_LOG_DEBUG, \"MDCT initialized, order = %d.\\n\",\n           av_log2(mlt_size) + 1)",
          "new_text": "sqrt(2.0 / q->samples_per_channel)",
          "old_line_content": "    av_log(q->avctx, AV_LOG_DEBUG, \"MDCT initialized, order = %d.\\n\",",
          "new_line_content": "        q->mlt_window[j] *= sqrt(2.0 / q->samples_per_channel);",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": "ff_mdct_end",
          "new_api": "av_log",
          "old_text": "ff_mdct_end(&q->mdct_ctx)",
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Deallocating memory.\\n\")",
          "old_line_content": "    ff_mdct_end(&q->mdct_ctx);",
          "new_line_content": "    av_log(avctx, AV_LOG_DEBUG, \"Deallocating memory.\\n\");",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": "ff_free_vlc",
          "new_api": "av_freep",
          "old_text": "ff_free_vlc(&q->envelope_quant_index[i])",
          "new_text": "av_freep(&q->decoded_bytes_buffer)",
          "old_line_content": "        ff_free_vlc(&q->envelope_quant_index[i]);",
          "new_line_content": "    av_freep(&q->decoded_bytes_buffer);",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "memset",
          "new_api": "unpack_SQVH",
          "old_text": "memset(subband_coef_index, 0, sizeof(subband_coef_index))",
          "new_text": "unpack_SQVH(q, p, category[band], subband_coef_index, subband_coef_sign)",
          "old_line_content": "            memset(subband_coef_index, 0, sizeof(subband_coef_index));",
          "new_line_content": "            if (unpack_SQVH(q, p, category[band], subband_coef_index, subband_coef_sign)) {",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": "decode_vectors",
          "new_api": "get_bits",
          "old_text": "decode_vectors(q, p, category, quant_index_table, mlt_buffer)",
          "new_text": "get_bits(&q->gb, p->log2_numvector_size)",
          "old_line_content": "    decode_vectors(q, p, category, quant_index_table, mlt_buffer);",
          "new_line_content": "    q->num_vectors = get_bits(&q->gb, p->log2_numvector_size);",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "interpolate",
          "new_api": "imdct_calc",
          "old_text": "q->interpolate(q, &buffer1[q->gain_size_factor * i],\n                           gains_ptr->now[i], gains_ptr->now[i + 1])",
          "new_text": "q->mdct_ctx.imdct_calc(&q->mdct_ctx, q->mono_mdct_output, inbuffer)",
          "old_line_content": "            q->interpolate(q, &buffer1[q->gain_size_factor * i],",
          "new_line_content": "    q->mdct_ctx.imdct_calc(&q->mdct_ctx, q->mono_mdct_output, inbuffer);",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": "av_log",
          "new_api": "get_vlc2",
          "old_text": "av_log(q->avctx, AV_LOG_ERROR, \"decouple value too large\\n\")",
          "new_text": "get_vlc2(&q->gb,\n                                               p->channel_coupling.table,\n                                               p->channel_coupling.bits, 2)",
          "old_line_content": "                av_log(q->avctx, AV_LOG_ERROR, \"decouple value too large\\n\");",
          "new_line_content": "            decouple_tab[start + i] = get_vlc2(&q->gb,",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": "mono_decode",
          "new_api": "memset",
          "old_text": "mono_decode(q, p, decode_buffer)",
          "new_text": "memset(decode_buffer, 0, sizeof(q->decode_buffer_0))",
          "old_line_content": "    if ((res = mono_decode(q, p, decode_buffer)) < 0)",
          "new_line_content": "    memset(decode_buffer, 0, sizeof(q->decode_buffer_0));",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": "mono_decode",
          "new_api": "memset",
          "old_text": "mono_decode(q, p, q->decode_buffer_1)",
          "new_text": "memset(q->decode_buffer_1, 0, sizeof(q->decode_buffer_1))",
          "old_line_content": "        if ((res = mono_decode(q, p, q->decode_buffer_1)) < 0)",
          "new_line_content": "    memset(q->decode_buffer_1, 0, sizeof(q->decode_buffer_1));",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": "decode_bytes_and_gain",
          "new_api": "joint_decode",
          "old_text": "decode_bytes_and_gain(q, p, inbuffer + sub_packet_size / 2, &p->gains2)",
          "new_text": "joint_decode(q, p, q->decode_buffer_1, q->decode_buffer_2)",
          "old_line_content": "            decode_bytes_and_gain(q, p, inbuffer + sub_packet_size / 2, &p->gains2);",
          "new_line_content": "        if ((res = joint_decode(q, p, q->decode_buffer_1, q->decode_buffer_2)) < 0)",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": "PRINT",
          "new_api": "ff_dlog",
          "old_text": "PRINT(\"nb_channels\", q->avctx->channels)",
          "new_text": "ff_dlog(q->avctx, \"COOKextradata\\n\")",
          "old_line_content": "    PRINT(\"nb_channels\", q->avctx->channels);",
          "new_line_content": "    ff_dlog(q->avctx, \"COOKextradata\\n\");",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": "PRINT",
          "new_api": "ff_dlog",
          "old_text": "PRINT(\"bit_rate\", (int)q->avctx->bit_rate)",
          "new_text": "ff_dlog(q->avctx, \"cookversion=%x\\n\", q->subpacket[0].cookversion)",
          "old_line_content": "    PRINT(\"bit_rate\", (int)q->avctx->bit_rate);",
          "new_line_content": "    ff_dlog(q->avctx, \"cookversion=%x\\n\", q->subpacket[0].cookversion);",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": "PRINT",
          "new_api": "ff_dlog",
          "old_text": "PRINT(\"log2_numvector_size\", q->subpacket[0].log2_numvector_size)",
          "new_text": "ff_dlog(q->avctx, \"COOKContext\\n\")",
          "old_line_content": "    PRINT(\"log2_numvector_size\", q->subpacket[0].log2_numvector_size);",
          "new_line_content": "    ff_dlog(q->avctx, \"COOKContext\\n\");",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": "ff_audiodsp_init",
          "new_api": "av_log",
          "old_text": "ff_audiodsp_init(&q->adsp)",
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Invalid number of channels\\n\")",
          "old_line_content": "    ff_audiodsp_init(&q->adsp);",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Invalid number of channels\\n\");",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "bytestream_get_be16",
          "new_api": "ff_audiodsp_init",
          "old_text": "bytestream_get_be16(&edata_ptr)",
          "new_text": "ff_audiodsp_init(&q->adsp)",
          "old_line_content": "            samples_per_frame           = bytestream_get_be16(&edata_ptr);",
          "new_line_content": "    ff_audiodsp_init(&q->adsp);",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": "bytestream_get_be16",
          "new_api": "bytestream_get_be32",
          "old_text": "bytestream_get_be16(&edata_ptr)",
          "new_text": "bytestream_get_be32(&edata_ptr)",
          "old_line_content": "            q->subpacket[s].js_subband_start = bytestream_get_be16(&edata_ptr);",
          "new_line_content": "            q->subpacket[s].cookversion = bytestream_get_be32(&edata_ptr);",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": "av_log",
          "new_api": "bytestream_get_be16",
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"js_subband_start %d is too large\\n\", q->subpacket[s].js_subband_start)",
          "new_text": "bytestream_get_be16(&edata_ptr)",
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"js_subband_start %d is too large\\n\", q->subpacket[s].js_subband_start);",
          "new_line_content": "            q->subpacket[s].subbands = bytestream_get_be16(&edata_ptr);",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": "bytestream_get_be16",
          "new_api": "bytestream_get_be32",
          "old_text": "bytestream_get_be16(&edata_ptr)",
          "new_text": "bytestream_get_be32(&edata_ptr)",
          "old_line_content": "            q->subpacket[s].js_vlc_bits = bytestream_get_be16(&edata_ptr);",
          "new_line_content": "            bytestream_get_be32(&edata_ptr);    // Unknown unused",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": "FFMIN",
          "new_api": "av_log",
          "old_text": "FFMIN(MAX_SUBPACKETS, avctx->block_align)",
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Too many subpackets %d for channels %d\\n\", q->num_subpackets, q->avctx->channels)",
          "old_line_content": "            avpriv_request_sample(avctx, \"subpackets > %d\", FFMIN(MAX_SUBPACKETS, avctx->block_align));",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"Too many subpackets %d for channels %d\\n\", q->num_subpackets, q->avctx->channels);",
          "content_same": false
        },
        {
          "line": 1223,
          "old_api": "init_gain_table",
          "new_api": "FFMIN",
          "old_text": "init_gain_table(q)",
          "new_text": "FFMIN(MAX_SUBPACKETS, avctx->block_align)",
          "old_line_content": "    init_gain_table(q);",
          "new_line_content": "        if (s > FFMIN(MAX_SUBPACKETS, avctx->block_align)) {",
          "content_same": false
        },
        {
          "line": 1224,
          "old_api": "init_cplscales_table",
          "new_api": "FFMIN",
          "old_text": "init_cplscales_table(q)",
          "new_text": "FFMIN(MAX_SUBPACKETS, avctx->block_align)",
          "old_line_content": "    init_cplscales_table(q);",
          "new_line_content": "            avpriv_request_sample(avctx, \"subpackets > %d\", FFMIN(MAX_SUBPACKETS, avctx->block_align));",
          "content_same": false
        },
        {
          "line": 1231,
          "old_api": "AVERROR",
          "new_api": "init_cplscales_table",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "init_cplscales_table(q)",
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "    init_cplscales_table(q);",
          "content_same": false
        },
        {
          "line": 1238,
          "old_api": "DECODE_BYTES_PAD1",
          "new_api": "AVERROR",
          "old_text": "DECODE_BYTES_PAD1(avctx->block_align)",
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "                   + DECODE_BYTES_PAD1(avctx->block_align)",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": "init_cook_mlt",
          "new_api": "av_mallocz",
          "old_text": "init_cook_mlt(q)",
          "new_text": "av_mallocz(avctx->block_align\n                   + DECODE_BYTES_PAD1(avctx->block_align)\n                   + AV_INPUT_BUFFER_PADDING_SIZE)",
          "old_line_content": "    if ((ret = init_cook_mlt(q)))",
          "new_line_content": "        av_mallocz(avctx->block_align",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": "dump_cook_context",
          "old_text": "NULL_IF_CONFIG_SMALL(\"Cook / Cooker / Gecko (RealAudio G2)\")",
          "new_text": "dump_cook_context(q)",
          "old_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"Cook / Cooker / Gecko (RealAudio G2)\"),",
          "new_line_content": "    dump_cook_context(q);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1039,
          "old_api": null,
          "new_api": "PRINT",
          "old_text": null,
          "new_text": "PRINT(\"sample_rate\", q->avctx->sample_rate)",
          "old_line_content": "}",
          "new_line_content": "    PRINT(\"sample_rate\", q->avctx->sample_rate);",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": null,
          "new_api": "PRINT",
          "old_text": null,
          "new_text": "PRINT(\"samples_per_channel\", q->subpacket[0].samples_per_channel)",
          "old_line_content": "",
          "new_line_content": "    PRINT(\"samples_per_channel\", q->subpacket[0].samples_per_channel);",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": null,
          "new_api": "PRINT",
          "old_text": null,
          "new_text": "PRINT(\"subbands\", q->subpacket[0].subbands)",
          "old_line_content": "/**",
          "new_line_content": "    PRINT(\"subbands\", q->subpacket[0].subbands);",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": null,
          "new_api": "PRINT",
          "old_text": null,
          "new_text": "PRINT(\"js_subband_start\", q->subpacket[0].js_subband_start)",
          "old_line_content": " * Cook initialization",
          "new_line_content": "    PRINT(\"js_subband_start\", q->subpacket[0].js_subband_start);",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": null,
          "new_api": "PRINT",
          "old_text": null,
          "new_text": "PRINT(\"log2_numvector_size\", q->subpacket[0].log2_numvector_size)",
          "old_line_content": " *",
          "new_line_content": "    PRINT(\"log2_numvector_size\", q->subpacket[0].log2_numvector_size);",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": null,
          "new_api": "PRINT",
          "old_text": null,
          "new_text": "PRINT(\"numvector_size\", q->subpacket[0].numvector_size)",
          "old_line_content": " * @param avctx     pointer to the AVCodecContext",
          "new_line_content": "    PRINT(\"numvector_size\", q->subpacket[0].numvector_size);",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": null,
          "new_api": "PRINT",
          "old_text": null,
          "new_text": "PRINT(\"total_subbands\", q->subpacket[0].total_subbands)",
          "old_line_content": " */",
          "new_line_content": "    PRINT(\"total_subbands\", q->subpacket[0].total_subbands);",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": null,
          "new_api": "av_lfg_get",
          "old_text": null,
          "new_text": "av_lfg_get(&q->random_state)",
          "old_line_content": " * Unpack the subband_coef_index and subband_coef_sign vectors.",
          "new_line_content": "            if (av_lfg_get(&q->random_state) < 0x80000000)",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"codecdata_length=%d\\n\", avctx->extradata_size)",
          "old_line_content": "",
          "new_line_content": "    av_log(avctx, AV_LOG_DEBUG, \"codecdata_length=%d\\n\", avctx->extradata_size);",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "get_vlc2",
          "old_text": null,
          "new_text": "get_vlc2(&q->gb, q->sqvh[category].table, q->sqvh[category].bits, 3)",
          "old_line_content": "            subband_coef_index[vd * i + j] = vlc - tmp * (kmax_tab[category] + 1);",
          "new_line_content": "        vlc = get_vlc2(&q->gb, q->sqvh[category].table, q->sqvh[category].bits, 3);",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": null,
          "new_api": "get_bits_count",
          "old_text": null,
          "new_text": "get_bits_count(&q->gb)",
          "old_line_content": "            vlc = tmp;",
          "new_line_content": "        if (p->bits_per_subpacket < get_bits_count(&q->gb)) {",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": null,
          "new_api": "av_lfg_init",
          "old_text": null,
          "new_text": "av_lfg_init(&q->random_state, 0)",
          "old_line_content": "        if (extradata_size >= 8) {",
          "new_line_content": "    av_lfg_init(&q->random_state, 0);",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": null,
          "new_api": "get_bits_count",
          "old_text": null,
          "new_text": "get_bits_count(&q->gb)",
          "old_line_content": "                subband_coef_sign[i * vd + j] = 0;",
          "new_line_content": "                if (get_bits_count(&q->gb) < p->bits_per_subpacket) {",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(&q->gb)",
          "old_line_content": "            }",
          "new_line_content": "                    subband_coef_sign[i * vd + j] = get_bits1(&q->gb);",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": null,
          "new_api": "bytestream_get_be16",
          "old_text": null,
          "new_text": "bytestream_get_be16(&edata_ptr)",
          "old_line_content": "            if (q->subpacket[s].js_subband_start >= 51) {",
          "new_line_content": "            samples_per_frame           = bytestream_get_be16(&edata_ptr);",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": null,
          "new_api": "bytestream_get_be16",
          "old_text": null,
          "new_text": "bytestream_get_be16(&edata_ptr)",
          "old_line_content": "            extradata_size -= 8;",
          "new_line_content": "            q->subpacket[s].js_subband_start = bytestream_get_be16(&edata_ptr);",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"js_subband_start %d is too large\\n\", q->subpacket[s].js_subband_start)",
          "old_line_content": "",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"js_subband_start %d is too large\\n\", q->subpacket[s].js_subband_start);",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": null,
          "new_api": "bytestream_get_be16",
          "old_text": null,
          "new_text": "bytestream_get_be16(&edata_ptr)",
          "old_line_content": "",
          "new_line_content": "            q->subpacket[s].js_vlc_bits = bytestream_get_be16(&edata_ptr);",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"subpacket[%i].cookversion=%x\\n\", s,\n               q->subpacket[s].cookversion)",
          "old_line_content": "                return AVERROR_PATCHWELCOME;",
          "new_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"subpacket[%i].cookversion=%x\\n\", s,",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": null,
          "new_api": "avpriv_request_sample",
          "old_text": null,
          "new_text": "avpriv_request_sample(avctx, \"Container channels != 1\")",
          "old_line_content": "                q->subpacket[s].bits_per_subpdiv = 1;",
          "new_line_content": "                avpriv_request_sample(avctx, \"Container channels != 1\");",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(subband_coef_index, 0, sizeof(subband_coef_index))",
          "old_line_content": "",
          "new_line_content": "            memset(subband_coef_index, 0, sizeof(subband_coef_index));",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(subband_coef_sign,  0, sizeof(subband_coef_sign))",
          "old_line_content": "    /* FIXME: should this be removed, or moved into loop above? */",
          "new_line_content": "            memset(subband_coef_sign,  0, sizeof(subband_coef_sign));",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": null,
          "new_api": "scalar_dequant",
          "old_text": null,
          "new_text": "q->scalar_dequant(q, index, quant_index_table[band],\n                          subband_coef_index, subband_coef_sign,\n                          &mlt_buffer[band * SUBBAND_SIZE])",
          "old_line_content": "        return;",
          "new_line_content": "        q->scalar_dequant(q, index, quant_index_table[band],",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": null,
          "new_api": "avpriv_request_sample",
          "old_text": null,
          "new_text": "avpriv_request_sample(avctx, \"Container channels != 2\")",
          "old_line_content": "                q->subpacket[s].joint_stereo = 1;",
          "new_line_content": "                avpriv_request_sample(avctx, \"Container channels != 2\");",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"JOINT_STEREO\\n\")",
          "old_line_content": "            if (q->subpacket[s].samples_per_channel > 256) {",
          "new_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"JOINT_STEREO\\n\");",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": null,
          "new_api": "decode_envelope",
          "old_text": null,
          "new_text": "decode_envelope(q, p, quant_index_table)",
          "old_line_content": "            return AVERROR_INVALIDDATA;",
          "new_line_content": "    if ((res = decode_envelope(q, p, quant_index_table)) < 0)",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"MULTI_CHANNEL\\n\")",
          "old_line_content": "                q->subpacket[s].joint_stereo = 1;",
          "new_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"MULTI_CHANNEL\\n\");",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": null,
          "new_api": "categorize",
          "old_text": null,
          "new_text": "categorize(q, p, quant_index_table, category, category_index)",
          "old_line_content": "",
          "new_line_content": "    categorize(q, p, quant_index_table, category, category_index);",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": null,
          "new_api": "expand_category",
          "old_text": null,
          "new_text": "expand_category(q, category, category_index)",
          "old_line_content": "    return 0;",
          "new_line_content": "    expand_category(q, category, category_index);",
          "content_same": false
        },
        {
          "line": 1155,
          "old_api": null,
          "new_api": "bytestream_get_be32",
          "old_text": null,
          "new_text": "bytestream_get_be32(&edata_ptr)",
          "old_line_content": "                q->subpacket[s].samples_per_channel = samples_per_frame >> 1;",
          "new_line_content": "                channel_mask |= q->subpacket[s].channel_mask = bytestream_get_be32(&edata_ptr);",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": null,
          "new_api": "av_get_channel_layout_nb_channels",
          "old_text": null,
          "new_text": "av_get_channel_layout_nb_channels(q->subpacket[s].channel_mask)",
          "old_line_content": "                if (q->subpacket[s].samples_per_channel > 256) {",
          "new_line_content": "            if (av_get_channel_layout_nb_channels(q->subpacket[s].channel_mask) > 1) {",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": null,
          "new_api": "decode_vectors",
          "old_text": null,
          "new_text": "decode_vectors(q, p, category, quant_index_table, mlt_buffer)",
          "old_line_content": " * the actual requantization of the timedomain samples",
          "new_line_content": "    decode_vectors(q, p, category, quant_index_table, mlt_buffer);",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": null,
          "new_api": "avpriv_request_sample",
          "old_text": null,
          "new_text": "avpriv_request_sample(avctx, \"Cook version %d\",\n                                  q->subpacket[s].cookversion)",
          "old_line_content": "            return AVERROR_INVALIDDATA;",
          "new_line_content": "            avpriv_request_sample(avctx, \"Cook version %d\",",
          "content_same": false
        },
        {
          "line": 1181,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"different number of samples per channel!\\n\")",
          "old_line_content": "        q->subpacket[s].numvector_size = (1 << q->subpacket[s].log2_numvector_size);",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"different number of samples per channel!\\n\");",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": null,
          "new_api": "avpriv_request_sample",
          "old_text": null,
          "new_text": "avpriv_request_sample(avctx, \"total_subbands > 53\")",
          "old_line_content": "                   q->subpacket[s].js_vlc_bits, 2 * q->subpacket[s].joint_stereo);",
          "new_line_content": "            avpriv_request_sample(avctx, \"total_subbands > 53\");",
          "content_same": false
        },
        {
          "line": 173,
          "old_api": null,
          "new_api": "powf",
          "old_text": null,
          "new_text": "powf(2, -32)",
          "old_line_content": "    }",
          "new_line_content": "    float root_val = powf(2, -32);",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"js_vlc_bits = %d, only >= %d and <= 6 allowed!\\n\",\n                   q->subpacket[s].js_vlc_bits, 2 * q->subpacket[s].joint_stereo)",
          "old_line_content": "            return AVERROR_PATCHWELCOME;",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"js_vlc_bits = %d, only >= %d and <= 6 allowed!\\n\",",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": null,
          "new_api": "avpriv_request_sample",
          "old_text": null,
          "new_text": "avpriv_request_sample(avctx, \"subbands > 50\")",
          "old_line_content": "        q->subpacket[s].gains1.now      = q->subpacket[s].gain_1;",
          "new_line_content": "            avpriv_request_sample(avctx, \"subbands > 50\");",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": null,
          "new_api": "avpriv_request_sample",
          "old_text": null,
          "new_text": "avpriv_request_sample(avctx, \"subbands = 0\")",
          "old_line_content": "",
          "new_line_content": "            avpriv_request_sample(avctx, \"subbands = 0\");",
          "content_same": false
        },
        {
          "line": 189,
          "old_api": null,
          "new_api": "pow",
          "old_text": null,
          "new_text": "pow(pow2tab[i + 52],\n                               (1.0 / (double) q->gain_size_factor))",
          "old_line_content": "    int i, result;",
          "new_line_content": "        q->gain_table[i] = pow(pow2tab[i + 52],",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": null,
          "new_api": "init_vlc",
          "old_text": null,
          "new_text": "init_vlc(&q->envelope_quant_index[i], 9, 24,\n                           envelope_quant_index_huffbits[i], 1, 1,\n                           envelope_quant_index_huffcodes[i], 2, 2, 0)",
          "old_line_content": "                           cvh_huffbits[i], 1, 1,",
          "new_line_content": "        result |= init_vlc(&q->envelope_quant_index[i], 9, 24,",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(q->avctx, AV_LOG_DEBUG, \"sqvh VLC init\\n\")",
          "old_line_content": "    for (i = 0; i < q->num_subpackets; i++) {",
          "new_line_content": "    av_log(q->avctx, AV_LOG_DEBUG, \"sqvh VLC init\\n\");",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": null,
          "new_api": "init_pow2table",
          "old_text": null,
          "new_text": "init_pow2table()",
          "old_line_content": "",
          "new_line_content": "    init_pow2table();",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": null,
          "new_api": "init_gain_table",
          "old_text": null,
          "new_text": "init_gain_table(q)",
          "old_line_content": "    if (avctx->block_align >= UINT_MAX / 2)",
          "new_line_content": "    init_gain_table(q);",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": null,
          "new_api": "init_cook_vlc_tables",
          "old_text": null,
          "new_text": "init_cook_vlc_tables(q)",
          "old_line_content": "    /* Pad the databuffer with:",
          "new_line_content": "    if ((ret = init_cook_vlc_tables(q)))",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": null,
          "new_api": "init_vlc",
          "old_text": null,
          "new_text": "init_vlc(&q->subpacket[i].channel_coupling, 6,\n                               (1 << q->subpacket[i].js_vlc_bits) - 1,\n                               ccpl_huffbits[q->subpacket[i].js_vlc_bits - 2], 1, 1,\n                               ccpl_huffcodes[q->subpacket[i].js_vlc_bits - 2], 2, 2, 0)",
          "old_line_content": "",
          "new_line_content": "            result |= init_vlc(&q->subpacket[i].channel_coupling, 6,",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": null,
          "new_api": "imlt_window",
          "old_text": null,
          "new_text": "q->imlt_window(q, buffer1, gains_ptr, previous_buffer)",
          "old_line_content": "",
          "new_line_content": "    q->imlt_window(q, buffer1, gains_ptr, previous_buffer);",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(q->avctx, AV_LOG_DEBUG, \"subpacket %i Joint-stereo VLC used.\\n\", i)",
          "old_line_content": "",
          "new_line_content": "            av_log(q->avctx, AV_LOG_DEBUG, \"subpacket %i Joint-stereo VLC used.\\n\", i);",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": null,
          "new_api": "interpolate",
          "old_text": null,
          "new_text": "q->interpolate(q, &buffer1[q->gain_size_factor * i],\n                           gains_ptr->now[i], gains_ptr->now[i + 1])",
          "old_line_content": "",
          "new_line_content": "            q->interpolate(q, &buffer1[q->gain_size_factor * i],",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(q->avctx, AV_LOG_DEBUG, \"VLC tables initialized.\\n\")",
          "old_line_content": "    int mlt_size = q->samples_per_channel;",
          "new_line_content": "    av_log(q->avctx, AV_LOG_DEBUG, \"VLC tables initialized.\\n\");",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": null,
          "new_api": "DECODE_BYTES_PAD1",
          "old_text": null,
          "new_text": "DECODE_BYTES_PAD1(avctx->block_align)",
          "old_line_content": "        return ret;",
          "new_line_content": "                   + DECODE_BYTES_PAD1(avctx->block_align)",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(previous_buffer, buffer0,\n           q->samples_per_channel * sizeof(*previous_buffer))",
          "old_line_content": " *",
          "new_line_content": "    memcpy(previous_buffer, buffer0,",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    if (1) {",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": null,
          "new_api": "init_cook_mlt",
          "old_text": null,
          "new_text": "init_cook_mlt(q)",
          "old_line_content": "        q->imlt_window     = imlt_window_float;",
          "new_line_content": "    if ((ret = init_cook_mlt(q)))",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": null,
          "new_api": "av_malloc_array",
          "old_text": null,
          "new_text": "av_malloc_array(mlt_size, sizeof(*q->mlt_window))",
          "old_line_content": "",
          "new_line_content": "    if ((q->mlt_window = av_malloc_array(mlt_size, sizeof(*q->mlt_window))) == 0)",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    /* Initialize the MDCT. */",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": null,
          "new_api": "ff_sine_window_init",
          "old_text": null,
          "new_text": "ff_sine_window_init(q->mlt_window, mlt_size)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ff_sine_window_init(q->mlt_window, mlt_size);",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(&q->gb)",
          "old_line_content": "",
          "new_line_content": "    int vlc    = get_bits1(&q->gb);",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": null,
          "new_api": "av_log2",
          "old_text": null,
          "new_text": "av_log2(mlt_size)",
          "old_line_content": "    return 0;",
          "new_line_content": "    if ((ret = ff_mdct_init(&q->mdct_ctx, av_log2(mlt_size) + 1, 1, 1.0 / 32768.0))) {",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&q->mlt_window)",
          "old_line_content": "}",
          "new_line_content": "        av_freep(&q->mlt_window);",
          "content_same": false
        },
        {
          "line": 1266,
          "old_api": null,
          "new_api": "avpriv_request_sample",
          "old_text": null,
          "new_text": "avpriv_request_sample(avctx, \"samples_per_channel = %d\",\n                              q->samples_per_channel)",
          "old_line_content": "        avctx->channel_layout = channel_mask;",
          "new_line_content": "        avpriv_request_sample(avctx, \"samples_per_channel = %d\",",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(q->avctx, AV_LOG_DEBUG, \"MDCT initialized, order = %d.\\n\",\n           av_log2(mlt_size) + 1)",
          "old_line_content": "{",
          "new_line_content": "    av_log(q->avctx, AV_LOG_DEBUG, \"MDCT initialized, order = %d.\\n\",",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": null,
          "new_api": "av_log2",
          "old_text": null,
          "new_text": "av_log2(mlt_size)",
          "old_line_content": "    int i;",
          "new_line_content": "           av_log2(mlt_size) + 1);",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(&q->gb, p->js_vlc_bits)",
          "old_line_content": "    return 0;",
          "new_line_content": "            int v = get_bits(&q->gb, p->js_vlc_bits);",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(q->avctx, AV_LOG_ERROR, \"decouple value too large\\n\")",
          "old_line_content": "",
          "new_line_content": "                av_log(q->avctx, AV_LOG_ERROR, \"decouple value too large\\n\");",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"Cook / Cooker / Gecko (RealAudio G2)\")",
          "old_line_content": "    .capabilities   = AV_CODEC_CAP_DR1,",
          "new_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"Cook / Cooker / Gecko (RealAudio G2)\"),",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": null,
          "new_api": "AV_BE2NE32C",
          "old_text": null,
          "new_text": "AV_BE2NE32C(0xf237c511u)",
          "old_line_content": "    /* FIXME: 64 bit platforms would be able to do 64 bits at a time.",
          "new_line_content": "        AV_BE2NE32C(0x37c511f2u), AV_BE2NE32C(0xf237c511u),",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": null,
          "new_api": "AV_BE2NE32C",
          "old_text": null,
          "new_text": "AV_BE2NE32C(0xc511f237u)",
          "old_line_content": "     * I'm too lazy though, should be something like",
          "new_line_content": "        AV_BE2NE32C(0x11f237c5u), AV_BE2NE32C(0xc511f237u),",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(mlt_buffer_left,  0, 1024 * sizeof(*mlt_buffer_left))",
          "old_line_content": "    for (i = 0; i < p->js_subband_start; i++) {",
          "new_line_content": "    memset(mlt_buffer_left,  0, 1024 * sizeof(*mlt_buffer_left));",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(mlt_buffer_right, 0, 1024 * sizeof(*mlt_buffer_right))",
          "old_line_content": "        for (j = 0; j < SUBBAND_SIZE; j++) {",
          "new_line_content": "    memset(mlt_buffer_right, 0, 1024 * sizeof(*mlt_buffer_right));",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": null,
          "new_api": "decouple_info",
          "old_text": null,
          "new_text": "decouple_info(q, p, decouple_tab)",
          "old_line_content": "            mlt_buffer_left[i  * 20 + j] = decode_buffer[i * 40 + j];",
          "new_line_content": "    if ((res = decouple_info(q, p, decouple_tab)) < 0)",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": null,
          "new_api": "mono_decode",
          "old_text": null,
          "new_text": "mono_decode(q, p, decode_buffer)",
          "old_line_content": "        }",
          "new_line_content": "    if ((res = mono_decode(q, p, decode_buffer)) < 0)",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&q->mlt_window)",
          "old_line_content": "    for (i = 0; i < 13; i++)",
          "new_line_content": "    av_freep(&q->mlt_window);",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": null,
          "new_api": "ff_mdct_end",
          "old_text": null,
          "new_text": "ff_mdct_end(&q->mdct_ctx)",
          "old_line_content": "    for (i = 0; i < q->num_subpackets; i++)",
          "new_line_content": "    ff_mdct_end(&q->mdct_ctx);",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": null,
          "new_api": "ff_free_vlc",
          "old_text": null,
          "new_text": "ff_free_vlc(&q->envelope_quant_index[i])",
          "old_line_content": "",
          "new_line_content": "        ff_free_vlc(&q->envelope_quant_index[i]);",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": null,
          "new_api": "ff_free_vlc",
          "old_text": null,
          "new_text": "ff_free_vlc(&q->sqvh[i])",
          "old_line_content": "}",
          "new_line_content": "        ff_free_vlc(&q->sqvh[i]);",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": null,
          "new_api": "ff_free_vlc",
          "old_text": null,
          "new_text": "ff_free_vlc(&q->subpacket[i].channel_coupling)",
          "old_line_content": "/**",
          "new_line_content": "        ff_free_vlc(&q->subpacket[i].channel_coupling);",
          "content_same": false
        },
        {
          "line": 328,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Memory deallocated.\\n\")",
          "old_line_content": " *",
          "new_line_content": "    av_log(avctx, AV_LOG_DEBUG, \"Memory deallocated.\\n\");",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": null,
          "new_api": "decouple",
          "old_text": null,
          "new_text": "q->decouple(q, p, i, f1, f2, decode_buffer,\n                    mlt_buffer_left, mlt_buffer_right)",
          "old_line_content": "",
          "new_line_content": "        q->decouple(q, p, i, f1, f2, decode_buffer,",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": null,
          "new_api": "get_bits_left",
          "old_text": null,
          "new_text": "get_bits_left(gb)",
          "old_line_content": "        while (i <= index)",
          "new_line_content": "    n = get_unary(gb, 0, get_bits_left(gb));     // amount of elements*2 to update",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gb, 3)",
          "old_line_content": "        gaininfo[i++] = 0;",
          "new_line_content": "        int index = get_bits(gb, 3);",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gb, 4)",
          "old_line_content": "}",
          "new_line_content": "        int gain = get_bits1(gb) ? get_bits(gb, 4) - 7 : -1;",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": null,
          "new_api": "decode_bytes",
          "old_text": null,
          "new_text": "decode_bytes(inbuffer, q->decoded_bytes_buffer,\n                          p->bits_per_subpacket / 8)",
          "old_line_content": "    FFSWAP(int *, gains_ptr->now, gains_ptr->previous);",
          "new_line_content": "    offset = decode_bytes(inbuffer, q->decoded_bytes_buffer,",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": null,
          "new_api": "init_get_bits",
          "old_text": null,
          "new_text": "init_get_bits(&q->gb, q->decoded_bytes_buffer + offset,\n                  p->bits_per_subpacket)",
          "old_line_content": "",
          "new_line_content": "    init_get_bits(&q->gb, q->decoded_bytes_buffer + offset,",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": null,
          "new_api": "decode_gain_info",
          "old_text": null,
          "new_text": "decode_gain_info(&q->gb, gains_ptr->now)",
          "old_line_content": " * Saturate the output signal and interleave.",
          "new_line_content": "    decode_gain_info(&q->gb, gains_ptr->now);",
          "content_same": false
        },
        {
          "line": 368,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(&q->gb, 6)",
          "old_line_content": "            vlc_index /= 2;",
          "new_line_content": "    quant_index_table[0] = get_bits(&q->gb, 6) - 6; // This is used later in categorize",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": null,
          "new_api": "vector_clipf",
          "old_text": null,
          "new_text": "q->adsp.vector_clipf(out, q->mono_mdct_output + q->samples_per_channel,\n                         -1.0f, 1.0f, FFALIGN(q->samples_per_channel, 8))",
          "old_line_content": " *  Apply modulated lapped transform, gain compensation,",
          "new_line_content": "    q->adsp.vector_clipf(out, q->mono_mdct_output + q->samples_per_channel,",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": null,
          "new_api": "FFALIGN",
          "old_text": null,
          "new_text": "FFALIGN(q->samples_per_channel, 8)",
          "old_line_content": " *  clip and convert to integer.",
          "new_line_content": "                         -1.0f, 1.0f, FFALIGN(q->samples_per_channel, 8));",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": null,
          "new_api": "get_vlc2",
          "old_text": null,
          "new_text": "get_vlc2(&q->gb, q->envelope_quant_index[vlc_index - 1].table,\n                     q->envelope_quant_index[vlc_index - 1].bits, 2)",
          "old_line_content": "            return AVERROR_INVALIDDATA;",
          "new_line_content": "        j = get_vlc2(&q->gb, q->envelope_quant_index[vlc_index - 1].table,",
          "content_same": false
        },
        {
          "line": 386,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(q->avctx, AV_LOG_ERROR,\n                   \"Invalid quantizer %d at position %d, outside [-63, 63] range\\n\",\n                   quant_index_table[i], i)",
          "old_line_content": "    return 0;",
          "new_line_content": "            av_log(q->avctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": null,
          "new_api": "imlt_gain",
          "old_text": null,
          "new_text": "imlt_gain(q, decode_buffer, gains_ptr, previous_buffer)",
          "old_line_content": " * Cook subpacket decoding. This function returns one decoded subpacket,",
          "new_line_content": "    imlt_gain(q, decode_buffer, gains_ptr, previous_buffer);",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": null,
          "new_api": "saturate_output",
          "old_text": null,
          "new_text": "q->saturate_output(q, out)",
          "old_line_content": " *",
          "new_line_content": "        q->saturate_output(q, out);",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": null,
          "new_api": "decode_bytes_and_gain",
          "old_text": null,
          "new_text": "decode_bytes_and_gain(q, p, inbuffer, &p->gains1)",
          "old_line_content": "            return res;",
          "new_line_content": "    decode_bytes_and_gain(q, p, inbuffer, &p->gains1);",
          "content_same": false
        },
        {
          "line": 415,
          "old_api": null,
          "new_api": "get_bits_count",
          "old_text": null,
          "new_text": "get_bits_count(&q->gb)",
          "old_line_content": "",
          "new_line_content": "    bits_left = p->bits_per_subpacket - get_bits_count(&q->gb);",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": null,
          "new_api": "mono_decode",
          "old_text": null,
          "new_text": "mono_decode(q, p, q->decode_buffer_1)",
          "old_line_content": "        }",
          "new_line_content": "        if ((res = mono_decode(q, p, q->decode_buffer_1)) < 0)",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": null,
          "new_api": "decode_bytes_and_gain",
          "old_text": null,
          "new_text": "decode_bytes_and_gain(q, p, inbuffer + sub_packet_size / 2, &p->gains2)",
          "old_line_content": "                          p->mono_previous_buffer1,",
          "new_line_content": "            decode_bytes_and_gain(q, p, inbuffer + sub_packet_size / 2, &p->gains2);",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "mono_decode",
          "old_text": null,
          "new_text": "mono_decode(q, p, q->decode_buffer_2)",
          "old_line_content": "                          outbuffer ? outbuffer[p->ch_idx] : NULL);",
          "new_line_content": "            if ((res = mono_decode(q, p, q->decode_buffer_2)) < 0)",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": null,
          "new_api": "av_clip_uintp2",
          "old_text": null,
          "new_text": "av_clip_uintp2((i - quant_index_table[index] + bias) / 2, 3)",
          "old_line_content": "",
          "new_line_content": "            exp_idx = av_clip_uintp2((i - quant_index_table[index] + bias) / 2, 3);",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": null,
          "new_api": "mlt_compensate_output",
          "old_text": null,
          "new_text": "mlt_compensate_output(q, q->decode_buffer_1, &p->gains1,\n                          p->mono_previous_buffer1,\n                          outbuffer ? outbuffer[p->ch_idx] : NULL)",
          "old_line_content": "                                  p->mono_previous_buffer2,",
          "new_line_content": "    mlt_compensate_output(q, q->decode_buffer_1, &p->gains1,",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": null,
          "new_api": "mlt_compensate_output",
          "old_text": null,
          "new_text": "mlt_compensate_output(q, q->decode_buffer_2, &p->gains1,\n                                  p->mono_previous_buffer2,\n                                  outbuffer ? outbuffer[p->ch_idx + 1] : NULL)",
          "old_line_content": "    }",
          "new_line_content": "            mlt_compensate_output(q, q->decode_buffer_2, &p->gains1,",
          "content_same": false
        },
        {
          "line": 439,
          "old_api": null,
          "new_api": "av_clip_uintp2",
          "old_text": null,
          "new_text": "av_clip_uintp2((bias - quant_index_table[i]) / 2, 3)",
          "old_line_content": "    for (j = 1; j < p->numvector_size; j++) {",
          "new_line_content": "        exp_idx = av_clip_uintp2((bias - quant_index_table[i]) / 2, 3);",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": null,
          "new_api": "mlt_compensate_output",
          "old_text": null,
          "new_text": "mlt_compensate_output(q, q->decode_buffer_2, &p->gains2,\n                                  p->mono_previous_buffer2,\n                                  outbuffer ? outbuffer[p->ch_idx + 1] : NULL)",
          "old_line_content": "",
          "new_line_content": "            mlt_compensate_output(q, q->decode_buffer_2, &p->gains2,",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": null,
          "new_api": "ff_get_buffer",
          "old_text": null,
          "new_text": "ff_get_buffer(avctx, frame, 0)",
          "old_line_content": "",
          "new_line_content": "        if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG,\n                   \"frame subpacket size total > avctx->block_align!\\n\")",
          "old_line_content": "    for (i = 0; i < q->num_subpackets; i++) {",
          "new_line_content": "            av_log(avctx, AV_LOG_DEBUG,",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG,\n               \"subpacket[%i] size %i js %i %i block_align %i\\n\",\n               i, q->subpacket[i].size, q->subpacket[i].joint_stereo, offset,\n               avctx->block_align)",
          "old_line_content": "        offset += q->subpacket[i].size;",
          "new_line_content": "        av_log(avctx, AV_LOG_DEBUG,",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": null,
          "new_api": "decode_subpacket",
          "old_text": null,
          "new_text": "decode_subpacket(q, &q->subpacket[i], buf + offset, samples)",
          "old_line_content": "",
          "new_line_content": "        if ((ret = decode_subpacket(q, &q->subpacket[i], buf + offset, samples)) < 0)",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"subpacket[%i] %i %i\\n\",\n               i, q->subpacket[i].size * 8, get_bits_count(&q->gb))",
          "old_line_content": "        *got_frame_ptr = 0;",
          "new_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"subpacket[%i] %i %i\\n\",",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": null,
          "new_api": "get_bits_count",
          "old_text": null,
          "new_text": "get_bits_count(&q->gb)",
          "old_line_content": "        return avctx->block_align;",
          "new_line_content": "               i, q->subpacket[i].size * 8, get_bits_count(&q->gb));",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": null,
          "new_api": "FF_ARRAY_ELEMS",
          "old_text": null,
          "new_text": "FF_ARRAY_ELEMS(dither_tab)",
          "old_line_content": " *",
          "new_line_content": "        if (++category[idx] >= FF_ARRAY_ELEMS(dither_tab))",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1024,
          "old_api": "ff_dlog",
          "new_api": null,
          "old_text": "ff_dlog(q->avctx, \"cookversion=%x\\n\", q->subpacket[0].cookversion)",
          "new_text": null,
          "old_line_content": "    ff_dlog(q->avctx, \"cookversion=%x\\n\", q->subpacket[0].cookversion);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": "PRINT",
          "new_api": null,
          "old_text": "PRINT(\"js_subband_start\", q->subpacket[0].js_subband_start)",
          "new_text": null,
          "old_line_content": "        PRINT(\"js_subband_start\", q->subpacket[0].js_subband_start);",
          "new_line_content": "static void dump_cook_context(COOKContext *q)",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": "PRINT",
          "new_api": null,
          "old_text": "PRINT(\"js_vlc_bits\", q->subpacket[0].js_vlc_bits)",
          "new_text": null,
          "old_line_content": "        PRINT(\"js_vlc_bits\", q->subpacket[0].js_vlc_bits);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": "ff_dlog",
          "new_api": null,
          "old_text": "ff_dlog(q->avctx, \"COOKContext\\n\")",
          "new_text": null,
          "old_line_content": "    ff_dlog(q->avctx, \"COOKContext\\n\");",
          "new_line_content": "#define PRINT(a, b) ff_dlog(q->avctx, \" %s = %d\\n\", a, b);",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": "PRINT",
          "new_api": null,
          "old_text": "PRINT(\"sample_rate\", q->avctx->sample_rate)",
          "new_text": null,
          "old_line_content": "    PRINT(\"sample_rate\", q->avctx->sample_rate);",
          "new_line_content": "    if (q->subpacket[0].cookversion > STEREO) {",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": "PRINT",
          "new_api": null,
          "old_text": "PRINT(\"js_subband_start\", q->subpacket[0].js_subband_start)",
          "new_text": null,
          "old_line_content": "    PRINT(\"js_subband_start\", q->subpacket[0].js_subband_start);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "av_lfg_get",
          "new_api": null,
          "old_text": "av_lfg_get(&q->random_state)",
          "new_text": null,
          "old_line_content": "            if (av_lfg_get(&q->random_state) < 0x80000000)",
          "new_line_content": "        if (subband_coef_index[i]) {",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Necessary extradata missing!\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Necessary extradata missing!\\n\");",
          "new_line_content": "    unsigned int channel_mask = 0;",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"codecdata_length=%d\\n\", avctx->extradata_size)",
          "new_text": null,
          "old_line_content": "    av_log(avctx, AV_LOG_DEBUG, \"codecdata_length=%d\\n\", avctx->extradata_size);",
          "new_line_content": "    q->avctx = avctx;",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": "get_vlc2",
          "new_api": null,
          "old_text": "get_vlc2(&q->gb, q->sqvh[category].table, q->sqvh[category].bits, 3)",
          "new_text": null,
          "old_line_content": "        vlc = get_vlc2(&q->gb, q->sqvh[category].table, q->sqvh[category].bits, 3);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": "get_bits_count",
          "new_api": null,
          "old_text": "get_bits_count(&q->gb)",
          "new_text": null,
          "old_line_content": "        if (p->bits_per_subpacket < get_bits_count(&q->gb)) {",
          "new_line_content": "    int i, j;",
          "content_same": false
        },
        {
          "line": 1072,
          "old_api": "av_lfg_init",
          "new_api": null,
          "old_text": "av_lfg_init(&q->random_state, 0)",
          "new_text": null,
          "old_line_content": "    av_lfg_init(&q->random_state, 0);",
          "new_line_content": "    /* Take data from the AVCodecContext (RM container). */",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": "get_bits_count",
          "new_api": null,
          "old_text": "get_bits_count(&q->gb)",
          "new_text": null,
          "old_line_content": "                if (get_bits_count(&q->gb) < p->bits_per_subpacket) {",
          "new_line_content": "        for (j = vd - 1; j >= 0; j--) {",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(&q->gb)",
          "new_text": null,
          "old_line_content": "                    subband_coef_sign[i * vd + j] = get_bits1(&q->gb);",
          "new_line_content": "            tmp = (vlc * invradix_tab[category]) / 0x100000;",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "bytestream_get_be32",
          "new_api": null,
          "old_text": "bytestream_get_be32(&edata_ptr)",
          "new_text": null,
          "old_line_content": "            q->subpacket[s].cookversion = bytestream_get_be32(&edata_ptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "bytestream_get_be16",
          "new_api": null,
          "old_text": "bytestream_get_be16(&edata_ptr)",
          "new_text": null,
          "old_line_content": "            q->subpacket[s].subbands = bytestream_get_be16(&edata_ptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": "bytestream_get_be32",
          "new_api": null,
          "old_text": "bytestream_get_be32(&edata_ptr)",
          "new_text": null,
          "old_line_content": "            bytestream_get_be32(&edata_ptr);    // Unknown unused",
          "new_line_content": "        if (extradata_size >= 8) {",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"subpacket[%i].cookversion=%x\\n\", s,\n               q->subpacket[s].cookversion)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"subpacket[%i].cookversion=%x\\n\", s,",
          "new_line_content": "        /* Initialize default data states. */",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": "avpriv_request_sample",
          "new_api": null,
          "old_text": "avpriv_request_sample(avctx, \"Container channels != 1\")",
          "new_text": null,
          "old_line_content": "                avpriv_request_sample(avctx, \"Container channels != 1\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": "unpack_SQVH",
          "new_api": null,
          "old_text": "unpack_SQVH(q, p, category[band], subband_coef_index, subband_coef_sign)",
          "new_text": null,
          "old_line_content": "            if (unpack_SQVH(q, p, category[band], subband_coef_index, subband_coef_sign)) {",
          "new_line_content": "    int subband_coef_sign[SUBBAND_SIZE];",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"MONO\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"MONO\\n\");",
          "new_line_content": "        q->subpacket[s].joint_stereo = 0;",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(subband_coef_sign,  0, sizeof(subband_coef_sign))",
          "new_text": null,
          "old_line_content": "            memset(subband_coef_sign,  0, sizeof(subband_coef_sign));",
          "new_line_content": "                index = 7;",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": "scalar_dequant",
          "new_api": null,
          "old_text": "q->scalar_dequant(q, index, quant_index_table[band],\n                          subband_coef_index, subband_coef_sign,\n                          &mlt_buffer[band * SUBBAND_SIZE])",
          "new_text": null,
          "old_line_content": "        q->scalar_dequant(q, index, quant_index_table[band],",
          "new_line_content": "                    category[band + j] = 7;",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": "avpriv_request_sample",
          "new_api": null,
          "old_text": "avpriv_request_sample(avctx, \"Container channels != 2\")",
          "new_text": null,
          "old_line_content": "                avpriv_request_sample(avctx, \"Container channels != 2\");",
          "new_line_content": "                q->subpacket[s].bits_per_subpdiv = 1;",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": "decode_envelope",
          "new_api": null,
          "old_text": "decode_envelope(q, p, quant_index_table)",
          "new_text": null,
          "old_line_content": "    if ((res = decode_envelope(q, p, quant_index_table)) < 0)",
          "new_line_content": "static int mono_decode(COOKContext *q, COOKSubpacket *p, float *mlt_buffer)",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"MULTI_CHANNEL\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"MULTI_CHANNEL\\n\");",
          "new_line_content": "                q->subpacket[s].log2_numvector_size = 6;",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(&q->gb, p->log2_numvector_size)",
          "new_text": null,
          "old_line_content": "    q->num_vectors = get_bits(&q->gb, p->log2_numvector_size);",
          "new_line_content": "    int category_index[128] = { 0 };",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": "bytestream_get_be32",
          "new_api": null,
          "old_text": "bytestream_get_be32(&edata_ptr)",
          "new_text": null,
          "old_line_content": "                channel_mask |= q->subpacket[s].channel_mask = bytestream_get_be32(&edata_ptr);",
          "new_line_content": "            if (q->subpacket[s].samples_per_channel > 512) {",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": "categorize",
          "new_api": null,
          "old_text": "categorize(q, p, quant_index_table, category, category_index)",
          "new_text": null,
          "old_line_content": "    categorize(q, p, quant_index_table, category, category_index);",
          "new_line_content": "    int category[128]       = { 0 };",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": "expand_category",
          "new_api": null,
          "old_text": "expand_category(q, category, category_index)",
          "new_text": null,
          "old_line_content": "    expand_category(q, category, category_index);",
          "new_line_content": "    int quant_index_table[102];",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": "av_get_channel_layout_nb_channels",
          "new_api": null,
          "old_text": "av_get_channel_layout_nb_channels(q->subpacket[s].channel_mask)",
          "new_text": null,
          "old_line_content": "            if (av_get_channel_layout_nb_channels(q->subpacket[s].channel_mask) > 1) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": "avpriv_request_sample",
          "new_api": null,
          "old_text": "avpriv_request_sample(avctx, \"Cook version %d\",\n                                  q->subpacket[s].cookversion)",
          "new_text": null,
          "old_line_content": "            avpriv_request_sample(avctx, \"Cook version %d\",",
          "new_line_content": "                    q->subpacket[s].log2_numvector_size = 7;",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"different number of samples per channel!\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"different number of samples per channel!\\n\");",
          "new_line_content": "        default:",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": "avpriv_request_sample",
          "new_api": null,
          "old_text": "avpriv_request_sample(avctx, \"total_subbands > 53\")",
          "new_text": null,
          "old_line_content": "            avpriv_request_sample(avctx, \"total_subbands > 53\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"js_vlc_bits = %d, only >= %d and <= 6 allowed!\\n\",\n                   q->subpacket[s].js_vlc_bits, 2 * q->subpacket[s].joint_stereo)",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"js_vlc_bits = %d, only >= %d and <= 6 allowed!\\n\",",
          "new_line_content": "        if (q->subpacket[s].total_subbands > 53) {",
          "content_same": false
        },
        {
          "line": 171,
          "old_api": "pow",
          "new_api": null,
          "old_text": "pow(2, i)",
          "new_text": null,
          "old_line_content": "        pow2tab[63 + i] = pow(2, i);",
          "new_line_content": "    static const float exp2_tab[2] = {1, M_SQRT2};",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": "avpriv_request_sample",
          "new_api": null,
          "old_text": "avpriv_request_sample(avctx, \"subbands > 50\")",
          "new_text": null,
          "old_line_content": "            avpriv_request_sample(avctx, \"subbands > 50\");",
          "new_line_content": "            (q->subpacket[s].js_vlc_bits < 2 * q->subpacket[s].joint_stereo)) {",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": "avpriv_request_sample",
          "new_api": null,
          "old_text": "avpriv_request_sample(avctx, \"subbands = 0\")",
          "new_text": null,
          "old_line_content": "            avpriv_request_sample(avctx, \"subbands = 0\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 182,
          "old_api": "pow",
          "new_api": null,
          "old_text": "pow(pow2tab[i + 52],\n                               (1.0 / (double) q->gain_size_factor))",
          "new_text": null,
          "old_line_content": "        q->gain_table[i] = pow(pow2tab[i + 52],",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Too many subpackets %d for channels %d\\n\", q->num_subpackets, q->avctx->channels)",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"Too many subpackets %d for channels %d\\n\", q->num_subpackets, q->avctx->channels);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(MAX_SUBPACKETS, avctx->block_align)",
          "new_text": null,
          "old_line_content": "        if (s > FFMIN(MAX_SUBPACKETS, avctx->block_align)) {",
          "new_line_content": "        if (q->num_subpackets + q->subpacket[s].num_channels > q->avctx->channels) {",
          "content_same": false
        },
        {
          "line": 193,
          "old_api": "init_vlc",
          "new_api": null,
          "old_text": "init_vlc(&q->envelope_quant_index[i], 9, 24,\n                           envelope_quant_index_huffbits[i], 1, 1,\n                           envelope_quant_index_huffcodes[i], 2, 2, 0)",
          "new_text": null,
          "old_line_content": "        result |= init_vlc(&q->envelope_quant_index[i], 9, 24,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(q->avctx, AV_LOG_DEBUG, \"sqvh VLC init\\n\")",
          "new_text": null,
          "old_line_content": "    av_log(q->avctx, AV_LOG_DEBUG, \"sqvh VLC init\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": "init_pow2table",
          "new_api": null,
          "old_text": "init_pow2table()",
          "new_text": null,
          "old_line_content": "    init_pow2table();",
          "new_line_content": "        s++;",
          "content_same": false
        },
        {
          "line": 199,
          "old_api": "init_vlc",
          "new_api": null,
          "old_text": "init_vlc(&q->sqvh[i], vhvlcsize_tab[i], vhsize_tab[i],\n                           cvh_huffbits[i], 1, 1,\n                           cvh_huffcodes[i], 2, 2, 0)",
          "new_text": null,
          "old_line_content": "        result |= init_vlc(&q->sqvh[i], vhvlcsize_tab[i], vhsize_tab[i],",
          "new_line_content": "    for (i = 0; i < 13; i++) {",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": "init_cook_vlc_tables",
          "new_api": null,
          "old_text": "init_cook_vlc_tables(q)",
          "new_text": null,
          "old_line_content": "    if ((ret = init_cook_vlc_tables(q)))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": "imdct_calc",
          "new_api": null,
          "old_text": "q->mdct_ctx.imdct_calc(&q->mdct_ctx, q->mono_mdct_output, inbuffer)",
          "new_text": null,
          "old_line_content": "    q->mdct_ctx.imdct_calc(&q->mdct_ctx, q->mono_mdct_output, inbuffer);",
          "new_line_content": "                      cook_gains *gains_ptr, float *previous_buffer)",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": "imlt_window",
          "new_api": null,
          "old_text": "q->imlt_window(q, buffer1, gains_ptr, previous_buffer)",
          "new_text": null,
          "old_line_content": "    q->imlt_window(q, buffer1, gains_ptr, previous_buffer);",
          "new_line_content": "    float *buffer0 = q->mono_mdct_output;",
          "content_same": false
        },
        {
          "line": 210,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(q->avctx, AV_LOG_DEBUG, \"subpacket %i Joint-stereo VLC used.\\n\", i)",
          "new_text": null,
          "old_line_content": "            av_log(q->avctx, AV_LOG_DEBUG, \"subpacket %i Joint-stereo VLC used.\\n\", i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": "av_mallocz",
          "new_api": null,
          "old_text": "av_mallocz(avctx->block_align\n                   + DECODE_BYTES_PAD1(avctx->block_align)\n                   + AV_INPUT_BUFFER_PADDING_SIZE)",
          "new_text": null,
          "old_line_content": "        av_mallocz(avctx->block_align",
          "new_line_content": "    if (avctx->block_align >= UINT_MAX / 2)",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(q->avctx, AV_LOG_DEBUG, \"VLC tables initialized.\\n\")",
          "new_text": null,
          "old_line_content": "    av_log(q->avctx, AV_LOG_DEBUG, \"VLC tables initialized.\\n\");",
          "new_line_content": "                               (1 << q->subpacket[i].js_vlc_bits) - 1,",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(previous_buffer, buffer0,\n           q->samples_per_channel * sizeof(*previous_buffer))",
          "new_text": null,
          "old_line_content": "    memcpy(previous_buffer, buffer0,",
          "new_line_content": "    /* Apply gain profile */",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "       DECODE_BYTES_PAD1 or DECODE_BYTES_PAD2 for decode_bytes(),",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": "av_malloc_array",
          "new_api": null,
          "old_text": "av_malloc_array(mlt_size, sizeof(*q->mlt_window))",
          "new_text": null,
          "old_line_content": "    if ((q->mlt_window = av_malloc_array(mlt_size, sizeof(*q->mlt_window))) == 0)",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": "ff_sine_window_init",
          "new_api": null,
          "old_text": "ff_sine_window_init(q->mlt_window, mlt_size)",
          "new_text": null,
          "old_line_content": "    ff_sine_window_init(q->mlt_window, mlt_size);",
          "new_line_content": "    int j, ret;",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": "sqrt",
          "new_api": null,
          "old_text": "sqrt(2.0 / q->samples_per_channel)",
          "new_text": null,
          "old_line_content": "        q->mlt_window[j] *= sqrt(2.0 / q->samples_per_channel);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(&q->gb)",
          "new_text": null,
          "old_line_content": "    int vlc    = get_bits1(&q->gb);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": "av_log2",
          "new_api": null,
          "old_text": "av_log2(mlt_size)",
          "new_text": null,
          "old_line_content": "    if ((ret = ff_mdct_init(&q->mdct_ctx, av_log2(mlt_size) + 1, 1, 1.0 / 32768.0))) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 233,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&q->mlt_window)",
          "new_text": null,
          "old_line_content": "        av_freep(&q->mlt_window);",
          "new_line_content": "    /* Initialize the MLT window: simple sine window. */",
          "content_same": false
        },
        {
          "line": 1259,
          "old_api": "avpriv_request_sample",
          "new_api": null,
          "old_text": "avpriv_request_sample(avctx, \"samples_per_channel = %d\",\n                              q->samples_per_channel)",
          "new_text": null,
          "old_line_content": "        avpriv_request_sample(avctx, \"samples_per_channel = %d\",",
          "new_line_content": "        q->interpolate     = interpolate_float;",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": "av_log2",
          "new_api": null,
          "old_text": "av_log2(mlt_size)",
          "new_text": null,
          "old_line_content": "           av_log2(mlt_size) + 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "get_vlc2",
          "new_api": null,
          "old_text": "get_vlc2(&q->gb,\n                                               p->channel_coupling.table,\n                                               p->channel_coupling.bits, 2)",
          "new_text": null,
          "old_line_content": "            decouple_tab[start + i] = get_vlc2(&q->gb,",
          "new_line_content": "    int length = end - start + 1;",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(&q->gb, p->js_vlc_bits)",
          "new_text": null,
          "old_line_content": "            int v = get_bits(&q->gb, p->js_vlc_bits);",
          "new_line_content": "    if (vlc)",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": "dump_cook_context",
          "new_api": null,
          "old_text": "dump_cook_context(q)",
          "new_text": null,
          "old_line_content": "    dump_cook_context(q);",
          "new_line_content": "    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": "AV_BE2NE32C",
          "new_api": null,
          "old_text": "AV_BE2NE32C(0xf237c511u)",
          "new_text": null,
          "old_line_content": "        AV_BE2NE32C(0x37c511f2u), AV_BE2NE32C(0xf237c511u),",
          "new_line_content": " * @param inbuffer  pointer to byte array of indata",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": "AV_BE2NE32C",
          "new_api": null,
          "old_text": "AV_BE2NE32C(0xc511f237u)",
          "new_text": null,
          "old_line_content": "        AV_BE2NE32C(0x11f237c5u), AV_BE2NE32C(0xc511f237u),",
          "new_line_content": " * @param out       pointer to byte array of outdata",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(decode_buffer, 0, sizeof(q->decode_buffer_0))",
          "new_text": null,
          "old_line_content": "    memset(decode_buffer, 0, sizeof(q->decode_buffer_0));",
          "new_line_content": "    int i, j, res;",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(mlt_buffer_left,  0, 1024 * sizeof(*mlt_buffer_left))",
          "new_text": null,
          "old_line_content": "    memset(mlt_buffer_left,  0, 1024 * sizeof(*mlt_buffer_left));",
          "new_line_content": "    int idx, cpl_tmp;",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(mlt_buffer_right, 0, 1024 * sizeof(*mlt_buffer_right))",
          "new_text": null,
          "old_line_content": "    memset(mlt_buffer_right, 0, 1024 * sizeof(*mlt_buffer_right));",
          "new_line_content": "    float f1, f2;",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Deallocating memory.\\n\")",
          "new_text": null,
          "old_line_content": "    av_log(avctx, AV_LOG_DEBUG, \"Deallocating memory.\\n\");",
          "new_line_content": "    return off;",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": "decouple_info",
          "new_api": null,
          "old_text": "decouple_info(q, p, decouple_tab)",
          "new_text": null,
          "old_line_content": "    if ((res = decouple_info(q, p, decouple_tab)) < 0)",
          "new_line_content": "    const float *cplscale;",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&q->mlt_window)",
          "new_text": null,
          "old_line_content": "    av_freep(&q->mlt_window);",
          "new_line_content": "static av_cold int cook_decode_close(AVCodecContext *avctx)",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&q->decoded_bytes_buffer)",
          "new_text": null,
          "old_line_content": "    av_freep(&q->decoded_bytes_buffer);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": "ff_free_vlc",
          "new_api": null,
          "old_text": "ff_free_vlc(&q->sqvh[i])",
          "new_text": null,
          "old_line_content": "        ff_free_vlc(&q->sqvh[i]);",
          "new_line_content": "    /* Free the transform. */",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": "ff_free_vlc",
          "new_api": null,
          "old_text": "ff_free_vlc(&q->subpacket[i].channel_coupling)",
          "new_text": null,
          "old_line_content": "        ff_free_vlc(&q->subpacket[i].channel_coupling);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Memory deallocated.\\n\")",
          "new_text": null,
          "old_line_content": "    av_log(avctx, AV_LOG_DEBUG, \"Memory deallocated.\\n\");",
          "new_line_content": "    for (i = 0; i < 13; i++)",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": "decouple",
          "new_api": null,
          "old_text": "q->decouple(q, p, i, f1, f2, decode_buffer,\n                    mlt_buffer_left, mlt_buffer_right)",
          "new_text": null,
          "old_line_content": "        q->decouple(q, p, i, f1, f2, decode_buffer,",
          "new_line_content": "    idx = (1 << p->js_vlc_bits) - 1;",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": "get_bits_left",
          "new_api": null,
          "old_text": "get_bits_left(gb)",
          "new_text": null,
          "old_line_content": "    n = get_unary(gb, 0, get_bits_left(gb));     // amount of elements*2 to update",
          "new_line_content": " * @param gb          pointer to the GetBitContext",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gb, 3)",
          "new_text": null,
          "old_line_content": "        int index = get_bits(gb, 3);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gb, 4)",
          "new_text": null,
          "old_line_content": "        int gain = get_bits1(gb) ? get_bits(gb, 4) - 7 : -1;",
          "new_line_content": "    int i, n;",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": "decode_bytes",
          "new_api": null,
          "old_text": "decode_bytes(inbuffer, q->decoded_bytes_buffer,\n                          p->bits_per_subpacket / 8)",
          "new_text": null,
          "old_line_content": "    offset = decode_bytes(inbuffer, q->decoded_bytes_buffer,",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": "init_get_bits",
          "new_api": null,
          "old_text": "init_get_bits(&q->gb, q->decoded_bytes_buffer + offset,\n                  p->bits_per_subpacket)",
          "new_text": null,
          "old_line_content": "    init_get_bits(&q->gb, q->decoded_bytes_buffer + offset,",
          "new_line_content": "                                         const uint8_t *inbuffer,",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": "decode_gain_info",
          "new_api": null,
          "old_text": "decode_gain_info(&q->gb, gains_ptr->now)",
          "new_text": null,
          "old_line_content": "    decode_gain_info(&q->gb, gains_ptr->now);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(&q->gb, 6)",
          "new_text": null,
          "old_line_content": "    quant_index_table[0] = get_bits(&q->gb, 6) - 6; // This is used later in categorize",
          "new_line_content": " * @param quant_index_table pointer to the array",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": "vector_clipf",
          "new_api": null,
          "old_text": "q->adsp.vector_clipf(out, q->mono_mdct_output + q->samples_per_channel,\n                         -1.0f, 1.0f, FFALIGN(q->samples_per_channel, 8))",
          "new_text": null,
          "old_line_content": "    q->adsp.vector_clipf(out, q->mono_mdct_output + q->samples_per_channel,",
          "new_line_content": " * Saturate the output signal and interleave.",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": "FFALIGN",
          "new_api": null,
          "old_text": "FFALIGN(q->samples_per_channel, 8)",
          "new_text": null,
          "old_line_content": "                         -1.0f, 1.0f, FFALIGN(q->samples_per_channel, 8));",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": "get_vlc2",
          "new_api": null,
          "old_text": "get_vlc2(&q->gb, q->envelope_quant_index[vlc_index - 1].table,\n                     q->envelope_quant_index[vlc_index - 1].bits, 2)",
          "new_text": null,
          "old_line_content": "        j = get_vlc2(&q->gb, q->envelope_quant_index[vlc_index - 1].table,",
          "new_line_content": "            vlc_index /= 2;",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(q->avctx, AV_LOG_ERROR,\n                   \"Invalid quantizer %d at position %d, outside [-63, 63] range\\n\",\n                   quant_index_table[i], i)",
          "new_text": null,
          "old_line_content": "            av_log(q->avctx, AV_LOG_ERROR,",
          "new_line_content": "        if (vlc_index > 13)",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": "imlt_gain",
          "new_api": null,
          "old_text": "imlt_gain(q, decode_buffer, gains_ptr, previous_buffer)",
          "new_text": null,
          "old_line_content": "    imlt_gain(q, decode_buffer, gains_ptr, previous_buffer);",
          "new_line_content": " * @param previous_buffer   pointer to the previous buffer to be used for overlapping",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": "saturate_output",
          "new_api": null,
          "old_text": "q->saturate_output(q, out)",
          "new_text": null,
          "old_line_content": "        q->saturate_output(q, out);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(q->decode_buffer_1, 0, sizeof(q->decode_buffer_1))",
          "new_text": null,
          "old_line_content": "    memset(q->decode_buffer_1, 0, sizeof(q->decode_buffer_1));",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": "decode_bytes_and_gain",
          "new_api": null,
          "old_text": "decode_bytes_and_gain(q, p, inbuffer, &p->gains1)",
          "new_text": null,
          "old_line_content": "    decode_bytes_and_gain(q, p, inbuffer, &p->gains1);",
          "new_line_content": "static int decode_subpacket(COOKContext *q, COOKSubpacket *p,",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": "get_bits_count",
          "new_api": null,
          "old_text": "get_bits_count(&q->gb)",
          "new_text": null,
          "old_line_content": "    bits_left = p->bits_per_subpacket - get_bits_count(&q->gb);",
          "new_line_content": "    int exp_index2[102] = { 0 };",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": "joint_decode",
          "new_api": null,
          "old_text": "joint_decode(q, p, q->decode_buffer_1, q->decode_buffer_2)",
          "new_text": null,
          "old_line_content": "        if ((res = joint_decode(q, p, q->decode_buffer_1, q->decode_buffer_2)) < 0)",
          "new_line_content": "    int sub_packet_size = p->size;",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": "mono_decode",
          "new_api": null,
          "old_text": "mono_decode(q, p, q->decode_buffer_2)",
          "new_text": null,
          "old_line_content": "            if ((res = mono_decode(q, p, q->decode_buffer_2)) < 0)",
          "new_line_content": "            return res;",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": "av_clip_uintp2",
          "new_api": null,
          "old_text": "av_clip_uintp2((i - quant_index_table[index] + bias) / 2, 3)",
          "new_text": null,
          "old_line_content": "            exp_idx = av_clip_uintp2((i - quant_index_table[index] + bias) / 2, 3);",
          "new_line_content": "    bias = -32;",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "mlt_compensate_output",
          "new_api": null,
          "old_text": "mlt_compensate_output(q, q->decode_buffer_1, &p->gains1,\n                          p->mono_previous_buffer1,\n                          outbuffer ? outbuffer[p->ch_idx] : NULL)",
          "new_text": null,
          "old_line_content": "    mlt_compensate_output(q, q->decode_buffer_1, &p->gains1,",
          "new_line_content": "        if (p->num_channels == 2) {",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "mlt_compensate_output",
          "new_api": null,
          "old_text": "mlt_compensate_output(q, q->decode_buffer_2, &p->gains1,\n                                  p->mono_previous_buffer2,\n                                  outbuffer ? outbuffer[p->ch_idx + 1] : NULL)",
          "new_text": null,
          "old_line_content": "            mlt_compensate_output(q, q->decode_buffer_2, &p->gains1,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": "av_clip_uintp2",
          "new_api": null,
          "old_text": "av_clip_uintp2((bias - quant_index_table[i]) / 2, 3)",
          "new_text": null,
          "old_line_content": "        exp_idx = av_clip_uintp2((bias - quant_index_table[i]) / 2, 3);",
          "new_line_content": "        if (num_bits >= bits_left - 32)",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "mlt_compensate_output",
          "new_api": null,
          "old_text": "mlt_compensate_output(q, q->decode_buffer_2, &p->gains2,\n                                  p->mono_previous_buffer2,\n                                  outbuffer ? outbuffer[p->ch_idx + 1] : NULL)",
          "new_text": null,
          "old_line_content": "            mlt_compensate_output(q, q->decode_buffer_2, &p->gains2,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": "ff_get_buffer",
          "new_api": null,
          "old_text": "ff_get_buffer(avctx, frame, 0)",
          "new_text": null,
          "old_line_content": "        if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG,\n                   \"frame subpacket size total > avctx->block_align!\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_DEBUG,",
          "new_line_content": "    /* estimate subpacket sizes */",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG,\n               \"subpacket[%i] size %i js %i %i block_align %i\\n\",\n               i, q->subpacket[i].size, q->subpacket[i].joint_stereo, offset,\n               avctx->block_align)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_DEBUG,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "decode_subpacket",
          "new_api": null,
          "old_text": "decode_subpacket(q, &q->subpacket[i], buf + offset, samples)",
          "new_text": null,
          "old_line_content": "        if ((ret = decode_subpacket(q, &q->subpacket[i], buf + offset, samples)) < 0)",
          "new_line_content": "                                              q->subpacket[i].bits_per_subpdiv;",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"subpacket[%i] %i %i\\n\",\n               i, q->subpacket[i].size * 8, get_bits_count(&q->gb))",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"subpacket[%i] %i %i\\n\",",
          "new_line_content": "               i, q->subpacket[i].size, q->subpacket[i].joint_stereo, offset,",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": "get_bits_count",
          "new_api": null,
          "old_text": "get_bits_count(&q->gb)",
          "new_text": null,
          "old_line_content": "               i, q->subpacket[i].size * 8, get_bits_count(&q->gb));",
          "new_line_content": "               avctx->block_align);",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "FF_ARRAY_ELEMS",
          "new_api": null,
          "old_text": "FF_ARRAY_ELEMS(dither_tab)",
          "new_text": null,
          "old_line_content": "        if (++category[idx] >= FF_ARRAY_ELEMS(dither_tab))",
          "new_line_content": "static inline void expand_category(COOKContext *q, int *category,",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": "ff_dlog",
          "new_api": null,
          "old_text": "ff_dlog(q->avctx, \"COOKextradata\\n\")",
          "new_text": null,
          "old_line_content": "    ff_dlog(q->avctx, \"COOKextradata\\n\");",
          "new_line_content": "    return avctx->block_align;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 26,
      "total_additions": 109,
      "total_deletions": 109,
      "total_api_changes": 244
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 9,
        "api_related_lines": 244,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          169,
          175,
          176,
          177,
          178,
          179
        ]
      }
    },
    "api_calls_before": 150,
    "api_calls_after": 149,
    "diff_info": {
      "added_lines": 9,
      "removed_lines": 2,
      "total_diff_lines": 25
    }
  }
}