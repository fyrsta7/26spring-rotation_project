{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/380659604f2692b625928a3a76a1c046f473c9f6",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/380659604f2692b625928a3a76a1c046f473c9f6/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/380659604f2692b625928a3a76a1c046f473c9f6/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/380659604f2692b625928a3a76a1c046f473c9f6/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 486,
          "old_api": "av_log",
          "new_api": "get_ur_golomb_shorten",
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"header is wrong size: %d\\n\",\n               s->header_size)",
          "new_text": "get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE)",
          "old_line_content": "        av_log(s->avctx, AV_LOG_ERROR, \"header is wrong size: %d\\n\",",
          "new_line_content": "        s->header[i] = (char)get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE);",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": "get_ur_golomb_shorten",
          "new_api": "decode_aiff_header",
          "old_text": "get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE)",
          "new_text": "decode_aiff_header(s->avctx, s->header, s->header_size)",
          "old_line_content": "        s->header[i] = (char)get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE);",
          "new_line_content": "        if ((ret = decode_aiff_header(s->avctx, s->header, s->header_size)) < 0)",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": "decode_wave_header",
          "new_api": "avpriv_report_missing_feature",
          "old_text": "decode_wave_header(s->avctx, s->header, s->header_size)",
          "new_text": "avpriv_report_missing_feature(s->avctx, \"unsupported bit packing %\"\n                                      PRIX32, AV_RL32(s->header))",
          "old_line_content": "        if ((ret = decode_wave_header(s->avctx, s->header, s->header_size)) < 0)",
          "new_line_content": "        avpriv_report_missing_feature(s->avctx, \"unsupported bit packing %\"",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": "AV_RL32",
          "new_api": "allocate_buffers",
          "old_text": "AV_RL32(s->header)",
          "new_text": "allocate_buffers(s)",
          "old_line_content": "                                      PRIX32, AV_RL32(s->header));",
          "new_line_content": "    if ((ret = allocate_buffers(s)) < 0)",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"error allocating bitstream buffer\\n\")",
          "old_line_content": "            return AVERROR(ENOMEM);",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"error allocating bitstream buffer\\n\");",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": "av_fast_realloc",
          "new_api": "FFMAX",
          "old_text": "av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,\n                                      max_framesize + AV_INPUT_BUFFER_PADDING_SIZE)",
          "new_text": "FFMAX(s->max_framesize, s->blocksize * s->channels * 8)",
          "old_line_content": "            tmp_ptr = av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,",
          "new_line_content": "            max_framesize = FFMAX(s->max_framesize, s->blocksize * s->channels * 8);",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"error allocating bitstream buffer\\n\")",
          "old_line_content": "                return AVERROR(ENOMEM);",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"error allocating bitstream buffer\\n\");",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 643,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid or unsupported \"\n                                                \"block size: %d\\n\", blocksize)",
          "old_line_content": "                                                \"block size: %d\\n\", blocksize);",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid or unsupported \"",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"overread: %d\\n\", i - buf_size)",
          "old_line_content": "        s->bitstream_size  = 0;",
          "new_line_content": "        av_log(s->avctx, AV_LOG_ERROR, \"overread: %d\\n\", i - buf_size);",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "                }",
          "new_line_content": "                    return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&s->offset[i])",
          "old_line_content": "    }",
          "new_line_content": "        av_freep(&s->offset[i]);",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": null,
          "new_api": "av_fast_realloc",
          "old_text": null,
          "new_text": "av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,\n                                  s->max_framesize + AV_INPUT_BUFFER_PADDING_SIZE)",
          "old_line_content": "                                  s->max_framesize + AV_INPUT_BUFFER_PADDING_SIZE);",
          "new_line_content": "        tmp_ptr = av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&s->coeffs)",
          "old_line_content": "",
          "new_line_content": "    av_freep(&s->coeffs);",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "        }",
          "new_line_content": "            return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "get_ur_golomb_shorten",
          "old_text": null,
          "new_text": "get_ur_golomb_shorten(&s->gb, ENERGYSIZE)",
          "old_line_content": "                /* This is a hack as version 0 differed in the definition",
          "new_line_content": "                residual_size = get_ur_golomb_shorten(&s->gb, ENERGYSIZE);",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(tmp_ptr, 0, s->allocated_bitstream_size)",
          "old_line_content": "        s->bitstream = tmp_ptr;",
          "new_line_content": "        memset(tmp_ptr, 0, s->allocated_bitstream_size);",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"Shorten\")",
          "old_line_content": "    .type           = AVMEDIA_TYPE_AUDIO,",
          "new_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"Shorten\"),",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(buf_size, s->max_framesize - s->bitstream_size)",
          "old_line_content": "    input_buf_size = buf_size;",
          "new_line_content": "    buf_size       = FFMIN(buf_size, s->max_framesize - s->bitstream_size);",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"residual size unsupportd: %d\\n\", residual_size)",
          "old_line_content": "                    return AVERROR_INVALIDDATA;",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"residual size unsupportd: %d\\n\", residual_size);",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": null,
          "new_api": "memmove",
          "old_text": null,
          "new_text": "memmove(s->bitstream, &s->bitstream[s->bitstream_index],\n                s->bitstream_size)",
          "old_line_content": "                s->bitstream_size);",
          "new_line_content": "        memmove(s->bitstream, &s->bitstream[s->bitstream_index],",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf,\n               buf_size)",
          "old_line_content": "               buf_size);",
          "new_line_content": "        memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf,",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": null,
          "new_api": "decode_subframe_lpc",
          "old_text": null,
          "new_text": "decode_subframe_lpc(s, cmd, channel,\n                                               residual_size, coffset)",
          "old_line_content": "                                               residual_size, coffset)) < 0)",
          "new_line_content": "                if ((ret = decode_subframe_lpc(s, cmd, channel,",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": null,
          "new_api": "init_get_bits8",
          "old_text": null,
          "new_text": "init_get_bits8(&s->gb, buf, buf_size)",
          "old_line_content": "        return ret;",
          "new_line_content": "    if ((ret = init_get_bits8(&s->gb, buf, buf_size)) < 0)",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": null,
          "new_api": "skip_bits",
          "old_text": null,
          "new_text": "skip_bits(&s->gb, s->bitindex)",
          "old_line_content": "",
          "new_line_content": "    skip_bits(&s->gb, s->bitindex);",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "read_header",
          "old_text": null,
          "new_text": "read_header(s)",
          "old_line_content": "            return ret;",
          "new_line_content": "        if ((ret = read_header(s)) < 0)",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": null,
          "new_api": "av_fast_realloc",
          "old_text": null,
          "new_text": "av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,\n                                      max_framesize + AV_INPUT_BUFFER_PADDING_SIZE)",
          "old_line_content": "                                      max_framesize + AV_INPUT_BUFFER_PADDING_SIZE);",
          "new_line_content": "            tmp_ptr = av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "            }",
          "new_line_content": "                return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": null,
          "new_api": "fix_bitshift",
          "old_text": null,
          "new_text": "fix_bitshift(s, s->decoded[channel])",
          "old_line_content": "",
          "new_line_content": "            fix_bitshift(s, s->decoded[channel]);",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": null,
          "new_api": "get_ur_golomb_shorten",
          "old_text": null,
          "new_text": "get_ur_golomb_shorten(&s->gb, FNSIZE)",
          "old_line_content": "    if (s->version > 1)",
          "new_line_content": "    if (get_ur_golomb_shorten(&s->gb, FNSIZE) != FN_VERBATIM) {",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR,\n               \"missing verbatim section at beginning of stream\\n\")",
          "old_line_content": "        s->lpcqoffset = V2LPCQOFFSET;",
          "new_line_content": "        av_log(s->avctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": null,
          "new_api": "ff_get_buffer",
          "old_text": null,
          "new_text": "ff_get_buffer(avctx, frame, 0)",
          "old_line_content": "                    return ret;",
          "new_line_content": "                if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": null,
          "new_api": "get_bits_left",
          "old_text": null,
          "new_text": "get_bits_left(&s->gb)",
          "old_line_content": "            *got_frame_ptr = 0;",
          "new_line_content": "        if (get_bits_left(&s->gb) < 3 + FNSIZE) {",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"header is wrong size: %d\\n\",\n               s->header_size)",
          "old_line_content": "        return AVERROR_INVALIDDATA;",
          "new_line_content": "        av_log(s->avctx, AV_LOG_ERROR, \"header is wrong size: %d\\n\",",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": null,
          "new_api": "get_ur_golomb_shorten",
          "old_text": null,
          "new_text": "get_ur_golomb_shorten(&s->gb, FNSIZE)",
          "old_line_content": "",
          "new_line_content": "        cmd = get_ur_golomb_shorten(&s->gb, FNSIZE);",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": null,
          "new_api": "av_clip_uint8",
          "old_text": null,
          "new_text": "av_clip_uint8(s->decoded[chan][i])",
          "old_line_content": "                            break;",
          "new_line_content": "                            *samples_u8++ = av_clip_uint8(s->decoded[chan][i]);",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"unknown shorten function %d\\n\", cmd)",
          "old_line_content": "            *got_frame_ptr = 0;",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"unknown shorten function %d\\n\", cmd);",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": null,
          "new_api": "av_clip_int16",
          "old_text": null,
          "new_text": "av_clip_int16(s->decoded[chan][i])",
          "old_line_content": "                            break;",
          "new_line_content": "                            *samples_s16++ = av_clip_int16(s->decoded[chan][i]);",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('R','I','F','F')",
          "old_line_content": "        return AVERROR_INVALIDDATA;",
          "new_line_content": "    if (AV_RL32(s->header) == MKTAG('R','I','F','F')) {",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": null,
          "new_api": "decode_wave_header",
          "old_text": null,
          "new_text": "decode_wave_header(s->avctx, s->header, s->header_size)",
          "old_line_content": "    }",
          "new_line_content": "        if ((ret = decode_wave_header(s->avctx, s->header, s->header_size)) < 0)",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": null,
          "new_api": "bswap16_buf",
          "old_text": null,
          "new_text": "s->bdsp.bswap16_buf(((uint16_t **)frame->extended_data)[chan],\n                                            ((uint16_t **)frame->extended_data)[chan],\n                                            s->blocksize)",
          "old_line_content": "                                            ((uint16_t **)frame->extended_data)[chan],",
          "new_line_content": "                        s->bdsp.bswap16_buf(((uint16_t **)frame->extended_data)[chan],",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('F','O','R','M')",
          "old_line_content": "    for (i = 0; i < s->header_size; i++)",
          "new_line_content": "    } else if (AV_RL32(s->header) == MKTAG('F','O','R','M')) {",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": null,
          "new_api": "get_ur_golomb_shorten",
          "old_text": null,
          "new_text": "get_ur_golomb_shorten(&s->gb, VERBATIM_CKSIZE_SIZE)",
          "old_line_content": "                while (len--)",
          "new_line_content": "                len = get_ur_golomb_shorten(&s->gb, VERBATIM_CKSIZE_SIZE);",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": null,
          "new_api": "get_ur_golomb_shorten",
          "old_text": null,
          "new_text": "get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE)",
          "old_line_content": "                break;",
          "new_line_content": "                    get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE);",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": null,
          "new_api": "AV_RL32",
          "old_text": null,
          "new_text": "AV_RL32(s->header)",
          "old_line_content": "            return ret;",
          "new_line_content": "                                      PRIX32, AV_RL32(s->header));",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": null,
          "new_api": "get_ur_golomb_shorten",
          "old_text": null,
          "new_text": "get_ur_golomb_shorten(&s->gb, BITSHIFTSIZE)",
          "old_line_content": "                if (bitshift > 32) {",
          "new_line_content": "                unsigned bitshift = get_ur_golomb_shorten(&s->gb, BITSHIFTSIZE);",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"bitshift %d is invalid\\n\",\n                           bitshift)",
          "old_line_content": "                           bitshift);",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"bitshift %d is invalid\\n\",",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": null,
          "new_api": "init_offset",
          "old_text": null,
          "new_text": "init_offset(s)",
          "old_line_content": "",
          "new_line_content": "    if ((ret = init_offset(s)) < 0)",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": null,
          "new_api": "get_bits_count",
          "old_text": null,
          "new_text": "get_bits_count(&s->gb)",
          "old_line_content": "    if (i > buf_size) {",
          "new_line_content": "    i           = get_bits_count(&s->gb) / 8;",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": null,
          "new_api": "av_log2",
          "old_text": null,
          "new_text": "av_log2(s->blocksize)",
          "old_line_content": "                if (blocksize > s->blocksize) {",
          "new_line_content": "                unsigned blocksize = get_uint(s, av_log2(s->blocksize));",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": null,
          "new_api": "avpriv_report_missing_feature",
          "old_text": null,
          "new_text": "avpriv_report_missing_feature(avctx,\n                                                  \"Increasing block size\")",
          "old_line_content": "                                                  \"Increasing block size\");",
          "new_line_content": "                    avpriv_report_missing_feature(avctx,",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 642,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid or unsupported \"\n                                                \"block size: %d\\n\", blocksize)",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid or unsupported \"",
          "new_line_content": "                if (!blocksize || blocksize > MAX_BLOCKSIZE) {",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "                    return AVERROR(EINVAL);",
          "new_line_content": "                                                \"block size: %d\\n\", blocksize);",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&s->decoded_base[i])",
          "new_text": null,
          "old_line_content": "        av_freep(&s->decoded_base[i]);",
          "new_line_content": "        s->decoded[i] = NULL;",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": "av_fast_realloc",
          "new_api": null,
          "old_text": "av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,\n                                  s->max_framesize + AV_INPUT_BUFFER_PADDING_SIZE)",
          "new_text": null,
          "old_line_content": "        tmp_ptr = av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,",
          "new_line_content": "        s->max_framesize = 8192; // should hopefully be enough for the first header",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&s->bitstream)",
          "new_text": null,
          "old_line_content": "    av_freep(&s->bitstream);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"error allocating bitstream buffer\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"error allocating bitstream buffer\\n\");",
          "new_line_content": "            s->max_framesize = 0;",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": "get_ur_golomb_shorten",
          "new_api": null,
          "old_text": "get_ur_golomb_shorten(&s->gb, ENERGYSIZE)",
          "new_text": null,
          "old_line_content": "                residual_size = get_ur_golomb_shorten(&s->gb, ENERGYSIZE);",
          "new_line_content": "            if (cmd != FN_ZERO) {",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(tmp_ptr, 0, s->allocated_bitstream_size)",
          "new_text": null,
          "old_line_content": "        memset(tmp_ptr, 0, s->allocated_bitstream_size);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"Shorten\")",
          "new_text": null,
          "old_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"Shorten\"),",
          "new_line_content": "    .name           = \"shorten\",",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(buf_size, s->max_framesize - s->bitstream_size)",
          "new_text": null,
          "old_line_content": "    buf_size       = FFMIN(buf_size, s->max_framesize - s->bitstream_size);",
          "new_line_content": "    /* append current packet data to bitstream buffer */",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"residual size unsupportd: %d\\n\", residual_size)",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"residual size unsupportd: %d\\n\", residual_size);",
          "new_line_content": "                if (residual_size > 30U) {",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": "memmove",
          "new_api": null,
          "old_text": "memmove(s->bitstream, &s->bitstream[s->bitstream_index],\n                s->bitstream_size)",
          "new_text": null,
          "old_line_content": "        memmove(s->bitstream, &s->bitstream[s->bitstream_index],",
          "new_line_content": "        s->allocated_bitstream_size) {",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf,\n               buf_size)",
          "new_text": null,
          "old_line_content": "        memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf,",
          "new_line_content": "    if (buf)",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": "decode_subframe_lpc",
          "new_api": null,
          "old_text": "decode_subframe_lpc(s, cmd, channel,\n                                               residual_size, coffset)",
          "new_text": null,
          "old_line_content": "                if ((ret = decode_subframe_lpc(s, cmd, channel,",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "init_get_bits8",
          "new_api": null,
          "old_text": "init_get_bits8(&s->gb, buf, buf_size)",
          "new_text": null,
          "old_line_content": "    if ((ret = init_get_bits8(&s->gb, buf, buf_size)) < 0)",
          "new_line_content": "    /* init and position bitstream reader */",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": "skip_bits",
          "new_api": null,
          "old_text": "skip_bits(&s->gb, s->bitindex)",
          "new_text": null,
          "old_line_content": "    skip_bits(&s->gb, s->bitindex);",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": "read_header",
          "new_api": null,
          "old_text": "read_header(s)",
          "new_text": null,
          "old_line_content": "        if ((ret = read_header(s)) < 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(s->max_framesize, s->blocksize * s->channels * 8)",
          "new_text": null,
          "old_line_content": "            max_framesize = FFMAX(s->max_framesize, s->blocksize * s->channels * 8);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"error allocating bitstream buffer\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"error allocating bitstream buffer\\n\");",
          "new_line_content": "            if (!tmp_ptr) {",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "fix_bitshift",
          "new_api": null,
          "old_text": "fix_bitshift(s, s->decoded[channel])",
          "new_text": null,
          "old_line_content": "            fix_bitshift(s, s->decoded[channel]);",
          "new_line_content": "             * during encoding */",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": "allocate_buffers",
          "new_api": null,
          "old_text": "allocate_buffers(s)",
          "new_text": null,
          "old_line_content": "    if ((ret = allocate_buffers(s)) < 0)",
          "new_line_content": "    if (s->version > 1)",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": "init_offset",
          "new_api": null,
          "old_text": "init_offset(s)",
          "new_text": null,
          "old_line_content": "    if ((ret = init_offset(s)) < 0)",
          "new_line_content": "    if (s->avctx->extradata_size > 0)",
          "content_same": false
        },
        {
          "line": 728,
          "old_api": "ff_get_buffer",
          "new_api": null,
          "old_text": "ff_get_buffer(avctx, frame, 0)",
          "new_text": null,
          "old_line_content": "                if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)",
          "new_line_content": "                frame->nb_samples = s->blocksize;",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "get_bits_left",
          "new_api": null,
          "old_text": "get_bits_left(&s->gb)",
          "new_text": null,
          "old_line_content": "        if (get_bits_left(&s->gb) < 3 + FNSIZE) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR,\n               \"missing verbatim section at beginning of stream\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s->avctx, AV_LOG_ERROR,",
          "new_line_content": "    if (s->header_size >= OUT_BUFFER_SIZE ||",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": "get_ur_golomb_shorten",
          "new_api": null,
          "old_text": "get_ur_golomb_shorten(&s->gb, FNSIZE)",
          "new_text": null,
          "old_line_content": "        cmd = get_ur_golomb_shorten(&s->gb, FNSIZE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": "av_clip_uint8",
          "new_api": null,
          "old_text": "av_clip_uint8(s->decoded[chan][i])",
          "new_text": null,
          "old_line_content": "                            *samples_u8++ = av_clip_uint8(s->decoded[chan][i]);",
          "new_line_content": "                        case TYPE_U8:",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"unknown shorten function %d\\n\", cmd)",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"unknown shorten function %d\\n\", cmd);",
          "new_line_content": "        if (cmd > FN_VERBATIM) {",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": "get_ur_golomb_shorten",
          "new_api": null,
          "old_text": "get_ur_golomb_shorten(&s->gb, VERBATIM_CKSIZE_SIZE)",
          "new_text": null,
          "old_line_content": "    s->header_size = get_ur_golomb_shorten(&s->gb, VERBATIM_CKSIZE_SIZE);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "av_clip_int16",
          "new_api": null,
          "old_text": "av_clip_int16(s->decoded[chan][i])",
          "new_text": null,
          "old_line_content": "                            *samples_s16++ = av_clip_int16(s->decoded[chan][i]);",
          "new_line_content": "                        case TYPE_S16LH:",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": "bswap16_buf",
          "new_api": null,
          "old_text": "s->bdsp.bswap16_buf(((uint16_t **)frame->extended_data)[chan],\n                                            ((uint16_t **)frame->extended_data)[chan],\n                                            s->blocksize)",
          "new_text": null,
          "old_line_content": "                        s->bdsp.bswap16_buf(((uint16_t **)frame->extended_data)[chan],",
          "new_line_content": "                    if (s->swap && s->internal_ftype != TYPE_U8)",
          "content_same": false
        },
        {
          "line": 620,
          "old_api": "get_ur_golomb_shorten",
          "new_api": null,
          "old_text": "get_ur_golomb_shorten(&s->gb, VERBATIM_CKSIZE_SIZE)",
          "new_text": null,
          "old_line_content": "                len = get_ur_golomb_shorten(&s->gb, VERBATIM_CKSIZE_SIZE);",
          "new_line_content": "            case FN_VERBATIM:",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "get_ur_golomb_shorten",
          "new_api": null,
          "old_text": "get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE)",
          "new_text": null,
          "old_line_content": "                    get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE);",
          "new_line_content": "                while (len--)",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('R','I','F','F')",
          "new_text": null,
          "old_line_content": "    if (AV_RL32(s->header) == MKTAG('R','I','F','F')) {",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": "get_ur_golomb_shorten",
          "new_api": null,
          "old_text": "get_ur_golomb_shorten(&s->gb, BITSHIFTSIZE)",
          "new_text": null,
          "old_line_content": "                unsigned bitshift = get_ur_golomb_shorten(&s->gb, BITSHIFTSIZE);",
          "new_line_content": "            case FN_BITSHIFT: {",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('F','O','R','M')",
          "new_text": null,
          "old_line_content": "    } else if (AV_RL32(s->header) == MKTAG('F','O','R','M')) {",
          "new_line_content": "        return AVERROR_PATCHWELCOME;",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"bitshift %d is invalid\\n\",\n                           bitshift)",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"bitshift %d is invalid\\n\",",
          "new_line_content": "                if (bitshift > 32) {",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "decode_aiff_header",
          "new_api": null,
          "old_text": "decode_aiff_header(s->avctx, s->header, s->header_size)",
          "new_text": null,
          "old_line_content": "        if ((ret = decode_aiff_header(s->avctx, s->header, s->header_size)) < 0)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "avpriv_report_missing_feature",
          "new_api": null,
          "old_text": "avpriv_report_missing_feature(s->avctx, \"unsupported bit packing %\"\n                                      PRIX32, AV_RL32(s->header))",
          "new_text": null,
          "old_line_content": "        avpriv_report_missing_feature(s->avctx, \"unsupported bit packing %\"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": "get_bits_count",
          "new_api": null,
          "old_text": "get_bits_count(&s->gb)",
          "new_text": null,
          "old_line_content": "    s->bitindex = get_bits_count(&s->gb) - 8 * (get_bits_count(&s->gb) / 8);",
          "new_line_content": "finish_frame:",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": "av_log2",
          "new_api": null,
          "old_text": "av_log2(s->blocksize)",
          "new_text": null,
          "old_line_content": "                unsigned blocksize = get_uint(s, av_log2(s->blocksize));",
          "new_line_content": "            case FN_BLOCKSIZE: {",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": "avpriv_report_missing_feature",
          "new_api": null,
          "old_text": "avpriv_report_missing_feature(avctx,\n                                                  \"Increasing block size\")",
          "new_text": null,
          "old_line_content": "                    avpriv_report_missing_feature(avctx,",
          "new_line_content": "                if (blocksize > s->blocksize) {",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"overread: %d\\n\", i - buf_size)",
          "new_text": null,
          "old_line_content": "        av_log(s->avctx, AV_LOG_ERROR, \"overread: %d\\n\", i - buf_size);",
          "new_line_content": "    if (i > buf_size) {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 7,
      "total_additions": 43,
      "total_deletions": 43,
      "total_api_changes": 93
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 13,
        "api_related_lines": 93,
        "non_api_lines": 8,
        "non_api_line_numbers": [
          466,
          467,
          469,
          470,
          503,
          504,
          506,
          507
        ]
      }
    },
    "api_calls_before": 150,
    "api_calls_after": 150,
    "diff_info": {
      "added_lines": 7,
      "removed_lines": 6,
      "total_diff_lines": 32
    }
  }
}