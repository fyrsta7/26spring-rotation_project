{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/6dde65d7c0ac34ad1aa2619ec7d979cb6464f9af",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/6dde65d7c0ac34ad1aa2619ec7d979cb6464f9af/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/6dde65d7c0ac34ad1aa2619ec7d979cb6464f9af/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/6dde65d7c0ac34ad1aa2619ec7d979cb6464f9af/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1519,
          "old_api": "av_log",
          "new_api": "parse_frame_header",
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid bitstream id\\n\")",
          "new_text": "parse_frame_header(s)",
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"invalid bitstream id\\n\");",
          "new_line_content": "    err = parse_frame_header(s);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1664,
          "old_api": null,
          "new_api": "ff_ac3_parse_header",
          "old_text": null,
          "new_text": "ff_ac3_parse_header(&s->gbc, &hdr)",
          "old_line_content": "                buf += s->frame_size;",
          "new_line_content": "        err = ff_ac3_parse_header(&s->gbc, &hdr);",
          "content_same": false
        },
        {
          "line": 1792,
          "old_api": null,
          "new_api": "av_downmix_info_update_side_data",
          "old_text": null,
          "new_text": "av_downmix_info_update_side_data(frame)",
          "old_line_content": "        case AC3_DMIXMOD_DPLII:",
          "new_line_content": "    if ((downmix_info = av_downmix_info_update_side_data(frame))) {",
          "content_same": false
        },
        {
          "line": 1539,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG,\n                       \"unsupported substream %d: skipping frame\\n\",\n                       s->substreamid)",
          "old_line_content": "            break;",
          "new_line_content": "                av_log(avctx, AV_LOG_DEBUG,",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_WARNING, \"Ignoring non-compatible dependent frame.\\n\")",
          "old_line_content": "            }",
          "new_line_content": "                av_log(avctx, AV_LOG_WARNING, \"Ignoring non-compatible dependent frame.\\n\");",
          "content_same": false
        },
        {
          "line": 1545,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid frame type\\n\")",
          "old_line_content": "            return err;",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid frame type\\n\");",
          "content_same": false
        },
        {
          "line": 1558,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"incomplete frame\\n\")",
          "old_line_content": "                    return AVERROR_INVALIDDATA;",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"incomplete frame\\n\");",
          "content_same": false
        },
        {
          "line": 1816,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "}",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": null,
          "new_api": "av_crc_get_table",
          "old_text": null,
          "new_text": "av_crc_get_table(AV_CRC_16_ANSI)",
          "old_line_content": "    }",
          "new_line_content": "            if (av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, &buf[2],",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"frame CRC mismatch\\n\")",
          "old_line_content": "    if (s->frame_type == EAC3_FRAME_TYPE_DEPENDENT && !got_independent_frame) {",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"frame CRC mismatch\\n\");",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(full_buf_size, s->frame_size + skip)",
          "old_line_content": "static av_cold int ac3_decode_end(AVCodecContext *avctx)",
          "new_line_content": "        return FFMIN(full_buf_size, s->frame_size + skip);",
          "content_same": false
        },
        {
          "line": 1823,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(full_buf_size, s->superframe_size + skip)",
          "old_line_content": "    AC3DecodeContext *s = avctx->priv_data;",
          "new_line_content": "    return FFMIN(full_buf_size, s->superframe_size + skip);",
          "content_same": false
        },
        {
          "line": 1533,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid frame size\\n\")",
          "old_line_content": "                       s->substreamid);",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"invalid frame size\\n\");",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_WARNING, \"Ignoring dependent frame without independent frame.\\n\")",
          "old_line_content": "        s->output_mode  = s->channel_mode;",
          "new_line_content": "        av_log(avctx, AV_LOG_WARNING, \"Ignoring dependent frame without independent frame.\\n\");",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(full_buf_size, s->frame_size)",
          "old_line_content": "            s->output_mode |= AC3_OUTPUT_LFEON;",
          "new_line_content": "        return FFMIN(full_buf_size, s->frame_size);",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": null,
          "new_api": "ff_mdct_end",
          "old_text": null,
          "new_text": "ff_mdct_end(&s->imdct_512)",
          "old_line_content": "#define OFFSET(x) offsetof(AC3DecodeContext, x)",
          "new_line_content": "    ff_mdct_end(&s->imdct_512);",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": null,
          "new_api": "ff_mdct_end",
          "old_text": null,
          "new_text": "ff_mdct_end(&s->imdct_256)",
          "old_line_content": "#define PAR (AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_AUDIO_PARAM)",
          "new_line_content": "    ff_mdct_end(&s->imdct_256);",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&s->fdsp)",
          "old_line_content": "",
          "new_line_content": "    av_freep(&s->fdsp);",
          "content_same": false
        },
        {
          "line": 1835,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&s->downmix_coeffs[0])",
          "old_line_content": "",
          "new_line_content": "    av_freep(&s->downmix_coeffs[0]);",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": null,
          "new_api": "av_get_channel_layout_nb_channels",
          "old_text": null,
          "new_text": "av_get_channel_layout_nb_channels(channel_layout)",
          "old_line_content": "",
          "new_line_content": "        if (av_get_channel_layout_nb_channels(channel_layout) > EAC3_MAX_CHANNELS) {",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Too many channels (%d) coded\\n\",\n                   av_get_channel_layout_nb_channels(channel_layout))",
          "old_line_content": "        for (ch = 0; ch < EAC3_MAX_CHANNELS; ch++) {",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"Too many channels (%d) coded\\n\",",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": null,
          "new_api": "av_get_channel_layout_nb_channels",
          "old_text": null,
          "new_text": "av_get_channel_layout_nb_channels(channel_layout)",
          "old_line_content": "            if (s->channel_map & (1 << (EAC3_MAX_CHANNELS - ch - 1))) {",
          "new_line_content": "                   av_get_channel_layout_nb_channels(channel_layout));",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": null,
          "new_api": "av_get_channel_layout_nb_channels",
          "old_text": null,
          "new_text": "av_get_channel_layout_nb_channels(channel_layout)",
          "old_line_content": "                        return AVERROR_INVALIDDATA;",
          "new_line_content": "        avctx->channels = av_get_channel_layout_nb_channels(channel_layout);",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": null,
          "new_api": "av_get_channel_layout_channel_index",
          "old_text": null,
          "new_text": "av_get_channel_layout_channel_index(channel_layout,\n                                                                    ff_eac3_custom_channel_map_locations[ch][1])",
          "old_line_content": "                } else {",
          "new_line_content": "                    int index = av_get_channel_layout_channel_index(channel_layout,",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": null,
          "new_api": "set_downmix_coeffs",
          "old_text": null,
          "new_text": "set_downmix_coeffs(s)",
          "old_line_content": "    }",
          "new_line_content": "            if ((ret = set_downmix_coeffs(s)) < 0) {",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"error setting downmix coeffs\\n\")",
          "old_line_content": "    avctx->channels = s->out_channels;",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"error setting downmix coeffs\\n\");",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": null,
          "new_api": "av_get_channel_layout_channel_index",
          "old_text": null,
          "new_text": "av_get_channel_layout_channel_index(channel_layout,\n                                                                            1ULL << i)",
          "old_line_content": "                        }",
          "new_line_content": "                            int index = av_get_channel_layout_channel_index(channel_layout,",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"unable to determine channel mode\\n\")",
          "old_line_content": "    /* set audio service type based on bitstream mode for AC-3 */",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"unable to determine channel mode\\n\");",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": null,
          "new_api": "ff_get_buffer",
          "old_text": null,
          "new_text": "ff_get_buffer(avctx, frame, 0)",
          "old_line_content": "               s->num_blocks * AC3_BLOCK_SIZE * sizeof(SHORTFLOAT));",
          "new_line_content": "    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)",
          "content_same": false
        },
        {
          "line": 1498,
          "old_api": null,
          "new_api": "AV_RB16",
          "old_text": null,
          "new_text": "AV_RB16(buf)",
          "old_line_content": "    /* if consistent noise generation is enabled, seed the linear feedback generator",
          "new_line_content": "    if (buf_size >= 2 && AV_RB16(buf) == 0x770B) {",
          "content_same": false
        },
        {
          "line": 1756,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(ch>=AV_NUM_DATA_POINTERS || frame->extended_data[ch] == frame->data[ch])",
          "old_line_content": "     *",
          "new_line_content": "        av_assert0(ch>=AV_NUM_DATA_POINTERS || frame->extended_data[ch] == frame->data[ch]);",
          "content_same": false
        },
        {
          "line": 1757,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy((SHORTFLOAT *)frame->extended_data[ch],\n               s->output_buffer[map],\n               s->num_blocks * AC3_BLOCK_SIZE * sizeof(SHORTFLOAT))",
          "old_line_content": "     * Check whether the input layout is compatible, and make sure we're not",
          "new_line_content": "        memcpy((SHORTFLOAT *)frame->extended_data[ch],",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE)",
          "old_line_content": "     * decodes given the same AC-3 frame data, for use with non-linear edititing software. */",
          "new_line_content": "        int cnt = FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE) >> 1;",
          "content_same": false
        },
        {
          "line": 1501,
          "old_api": null,
          "new_api": "bswap16_buf",
          "old_text": null,
          "new_text": "s->bdsp.bswap16_buf((uint16_t *) s->input_buffer,\n                            (const uint16_t *) buf, cnt)",
          "old_line_content": "    if (s->consistent_noise_generation)",
          "new_line_content": "        s->bdsp.bswap16_buf((uint16_t *) s->input_buffer,",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": null,
          "new_api": "decode_audio_block",
          "old_text": null,
          "new_text": "decode_audio_block(s, blk, offset)",
          "old_line_content": "            output[ch] = s->outptr[channel_map[ch]];",
          "new_line_content": "        if (!err && decode_audio_block(s, blk, offset)) {",
          "content_same": false
        },
        {
          "line": 1633,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"error decoding the audio block\\n\")",
          "old_line_content": "        for (ch = 0; ch < s->out_channels; ch++) {",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"error decoding the audio block\\n\");",
          "content_same": false
        },
        {
          "line": 1504,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE)",
          "old_line_content": "    buf = s->input_buffer;",
          "new_line_content": "        memcpy(s->input_buffer, buf, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE));",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(s->output_buffer[ch + offset] + AC3_BLOCK_SIZE*blk, output[ch], AC3_BLOCK_SIZE*sizeof(SHORTFLOAT))",
          "old_line_content": "",
          "new_line_content": "                memcpy(s->output_buffer[ch + offset] + AC3_BLOCK_SIZE*blk, output[ch], AC3_BLOCK_SIZE*sizeof(SHORTFLOAT));",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE)",
          "old_line_content": "    /* parse the syncinfo */",
          "new_line_content": "        av_lfg_init_from_data(&s->dith_state, s->input_buffer, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE));",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": null,
          "new_api": "init_get_bits8",
          "old_text": null,
          "new_text": "init_get_bits8(&s->gbc, buf, buf_size)",
          "old_line_content": "        case AAC_AC3_PARSE_ERROR_SYNC:",
          "new_line_content": "    if ((ret = init_get_bits8(&s->gbc, buf, buf_size)) < 0)",
          "content_same": false
        },
        {
          "line": 1649,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(s->output[ch + offset], output[ch], AC3_BLOCK_SIZE*sizeof(SHORTFLOAT))",
          "old_line_content": "            skip = buf_size - s->frame_size;",
          "new_line_content": "        memcpy(s->output[ch + offset], output[ch], AC3_BLOCK_SIZE*sizeof(SHORTFLOAT));",
          "content_same": false
        },
        {
          "line": 1524,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"frame sync error\\n\")",
          "old_line_content": "        case AAC_AC3_PARSE_ERROR_FRAME_SIZE:",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"frame sync error\\n\");",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid bitstream id\\n\")",
          "old_line_content": "        case AAC_AC3_PARSE_ERROR_FRAME_TYPE:",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"invalid bitstream id\\n\");",
          "content_same": false
        },
        {
          "line": 1530,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid sample rate\\n\")",
          "old_line_content": "            if (s->substreamid) {",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"invalid sample rate\\n\");",
          "content_same": false
        },
        {
          "line": 1788,
          "old_api": null,
          "new_api": "ff_side_data_update_matrix_encoding",
          "old_text": null,
          "new_text": "ff_side_data_update_matrix_encoding(frame, matrix_encoding)",
          "old_line_content": "            break;",
          "new_line_content": "    if ((ret = ff_side_data_update_matrix_encoding(frame, matrix_encoding)) < 0)",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": null,
          "new_api": "init_get_bits8",
          "old_text": null,
          "new_text": "init_get_bits8(&s->gbc, buf + s->frame_size, buf_size - s->frame_size)",
          "old_line_content": "            if (hdr.num_blocks != s->num_blocks || s->sample_rate != hdr.sample_rate) {",
          "new_line_content": "        if ((ret = init_get_bits8(&s->gbc, buf + s->frame_size, buf_size - s->frame_size)) < 0)",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1537,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid frame type\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid frame type\\n\");",
          "new_line_content": "            /* TODO: add support for substreams */",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"incomplete frame\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"incomplete frame\\n\");",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 1784,
          "old_api": "av_downmix_info_update_side_data",
          "new_api": null,
          "old_text": "av_downmix_info_update_side_data(frame)",
          "new_text": null,
          "old_line_content": "    if ((downmix_info = av_downmix_info_update_side_data(frame))) {",
          "new_line_content": "        default: // not indicated or off",
          "content_same": false
        },
        {
          "line": 1808,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "        downmix_info->center_mix_level_ltrt   = gain_levels[s->  center_mix_level_ltrt];",
          "content_same": false
        },
        {
          "line": 1554,
          "old_api": "av_crc_get_table",
          "new_api": null,
          "old_text": "av_crc_get_table(AV_CRC_16_ANSI)",
          "new_text": null,
          "old_line_content": "            if (av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, &buf[2],",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"frame CRC mismatch\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"frame CRC mismatch\\n\");",
          "new_line_content": "        /* check that reported frame size fits in input buffer */",
          "content_same": false
        },
        {
          "line": 1813,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(full_buf_size, s->frame_size + skip)",
          "new_text": null,
          "old_line_content": "        return FFMIN(full_buf_size, s->frame_size + skip);",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 1815,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(full_buf_size, s->superframe_size + skip)",
          "new_text": null,
          "old_line_content": "    return FFMIN(full_buf_size, s->superframe_size + skip);",
          "new_line_content": "    } else",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_WARNING, \"Ignoring dependent frame without independent frame.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_WARNING, \"Ignoring dependent frame without independent frame.\\n\");",
          "new_line_content": "                if (avctx->err_recognition & AV_EF_EXPLODE)",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(full_buf_size, s->frame_size)",
          "new_text": null,
          "old_line_content": "        return FFMIN(full_buf_size, s->frame_size);",
          "new_line_content": "                err = AAC_AC3_PARSE_ERROR_CRC;",
          "content_same": false
        },
        {
          "line": 1824,
          "old_api": "ff_mdct_end",
          "new_api": null,
          "old_text": "ff_mdct_end(&s->imdct_512)",
          "new_text": null,
          "old_line_content": "    ff_mdct_end(&s->imdct_512);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1825,
          "old_api": "ff_mdct_end",
          "new_api": null,
          "old_text": "ff_mdct_end(&s->imdct_256)",
          "new_text": null,
          "old_line_content": "    ff_mdct_end(&s->imdct_256);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1826,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&s->fdsp)",
          "new_text": null,
          "old_line_content": "    av_freep(&s->fdsp);",
          "new_line_content": "/**",
          "content_same": false
        },
        {
          "line": 1827,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&s->downmix_coeffs[0])",
          "new_text": null,
          "old_line_content": "    av_freep(&s->downmix_coeffs[0]);",
          "new_line_content": " * Uninitialize the AC-3 decoder.",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": "av_get_channel_layout_nb_channels",
          "new_api": null,
          "old_text": "av_get_channel_layout_nb_channels(channel_layout)",
          "new_text": null,
          "old_line_content": "        if (av_get_channel_layout_nb_channels(channel_layout) > EAC3_MAX_CHANNELS) {",
          "new_line_content": "            ich_layout |= AV_CH_LOW_FREQUENCY;",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Too many channels (%d) coded\\n\",\n                   av_get_channel_layout_nb_channels(channel_layout))",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"Too many channels (%d) coded\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": "av_get_channel_layout_nb_channels",
          "new_api": null,
          "old_text": "av_get_channel_layout_nb_channels(channel_layout)",
          "new_text": null,
          "old_line_content": "                   av_get_channel_layout_nb_channels(channel_layout));",
          "new_line_content": "        channel_layout = ich_layout;",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": "av_get_channel_layout_nb_channels",
          "new_api": null,
          "old_text": "av_get_channel_layout_nb_channels(channel_layout)",
          "new_text": null,
          "old_line_content": "        avctx->channels = av_get_channel_layout_nb_channels(channel_layout);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": "av_get_channel_layout_channel_index",
          "new_api": null,
          "old_text": "av_get_channel_layout_channel_index(channel_layout,\n                                                                    ff_eac3_custom_channel_map_locations[ch][1])",
          "new_text": null,
          "old_line_content": "                    int index = av_get_channel_layout_channel_index(channel_layout,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": "set_downmix_coeffs",
          "new_api": null,
          "old_text": "set_downmix_coeffs(s)",
          "new_text": null,
          "old_line_content": "            if ((ret = set_downmix_coeffs(s)) < 0) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1594,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"error setting downmix coeffs\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"error setting downmix coeffs\\n\");",
          "new_line_content": "        s->loro_center_mix_level   = gain_levels[s->  center_mix_level];",
          "content_same": false
        },
        {
          "line": 1726,
          "old_api": "av_get_channel_layout_channel_index",
          "new_api": null,
          "old_text": "av_get_channel_layout_channel_index(channel_layout,\n                                                                            1ULL << i)",
          "new_text": null,
          "old_line_content": "                            int index = av_get_channel_layout_channel_index(channel_layout,",
          "new_line_content": "                        return AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"unable to determine channel mode\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"unable to determine channel mode\\n\");",
          "new_line_content": "        if (s->channels != s->out_channels && !((s->output_mode & AC3_OUTPUT_LFEON) &&",
          "content_same": false
        },
        {
          "line": 1481,
          "old_api": "AV_RL16",
          "new_api": null,
          "old_text": "AV_RL16(buf)",
          "new_text": null,
          "old_line_content": "        if (AV_RB16(buf) != 0x770B && AV_RL16(buf) != 0x770B) {",
          "new_line_content": "    for (i = 1; i < buf_size; i += 2) {",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": "ff_get_buffer",
          "new_api": null,
          "old_text": "ff_get_buffer(avctx, frame, 0)",
          "new_text": null,
          "old_line_content": "    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 1490,
          "old_api": "AV_RB16",
          "new_api": null,
          "old_text": "AV_RB16(buf)",
          "new_text": null,
          "old_line_content": "    if (buf_size >= 2 && AV_RB16(buf) == 0x770B) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1748,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(ch>=AV_NUM_DATA_POINTERS || frame->extended_data[ch] == frame->data[ch])",
          "new_text": null,
          "old_line_content": "        av_assert0(ch>=AV_NUM_DATA_POINTERS || frame->extended_data[ch] == frame->data[ch]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1749,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy((SHORTFLOAT *)frame->extended_data[ch],\n               s->output_buffer[map],\n               s->num_blocks * AC3_BLOCK_SIZE * sizeof(SHORTFLOAT))",
          "new_text": null,
          "old_line_content": "        memcpy((SHORTFLOAT *)frame->extended_data[ch],",
          "new_line_content": "    /* get output buffer */",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE)",
          "new_text": null,
          "old_line_content": "        int cnt = FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE) >> 1;",
          "new_line_content": "        return AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": "bswap16_buf",
          "new_api": null,
          "old_text": "s->bdsp.bswap16_buf((uint16_t *) s->input_buffer,\n                            (const uint16_t *) buf, cnt)",
          "new_text": null,
          "old_line_content": "        s->bdsp.bswap16_buf((uint16_t *) s->input_buffer,",
          "new_line_content": "    buf += i;",
          "content_same": false
        },
        {
          "line": 1624,
          "old_api": "decode_audio_block",
          "new_api": null,
          "old_text": "decode_audio_block(s, blk, offset)",
          "new_text": null,
          "old_line_content": "        if (!err && decode_audio_block(s, blk, offset)) {",
          "new_line_content": "        output[ch] = s->output[ch + offset];",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"error decoding the audio block\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"error decoding the audio block\\n\");",
          "new_line_content": "        s->outptr[ch] = s->output[ch + offset];",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE)",
          "new_text": null,
          "old_line_content": "        memcpy(s->input_buffer, buf, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE));",
          "new_line_content": "    /* copy input buffer to decoder context to avoid reading past the end",
          "content_same": false
        },
        {
          "line": 1630,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(s->output_buffer[ch + offset] + AC3_BLOCK_SIZE*blk, output[ch], AC3_BLOCK_SIZE*sizeof(SHORTFLOAT))",
          "new_text": null,
          "old_line_content": "                memcpy(s->output_buffer[ch + offset] + AC3_BLOCK_SIZE*blk, output[ch], AC3_BLOCK_SIZE*sizeof(SHORTFLOAT));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1502,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE)",
          "new_text": null,
          "old_line_content": "        av_lfg_init_from_data(&s->dith_state, s->input_buffer, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE));",
          "new_line_content": "                            (const uint16_t *) buf, cnt);",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": "init_get_bits8",
          "new_api": null,
          "old_text": "init_get_bits8(&s->gbc, buf, buf_size)",
          "new_text": null,
          "old_line_content": "    if ((ret = init_get_bits8(&s->gbc, buf, buf_size)) < 0)",
          "new_line_content": "     * with the contents of the AC-3 frame so that the noise is identical across",
          "content_same": false
        },
        {
          "line": 1511,
          "old_api": "parse_frame_header",
          "new_api": null,
          "old_text": "parse_frame_header(s)",
          "new_text": null,
          "old_line_content": "    err = parse_frame_header(s);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1641,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(s->output[ch + offset], output[ch], AC3_BLOCK_SIZE*sizeof(SHORTFLOAT))",
          "new_text": null,
          "old_line_content": "        memcpy(s->output[ch + offset], output[ch], AC3_BLOCK_SIZE*sizeof(SHORTFLOAT));",
          "new_line_content": "        for (ch = 0; ch < s->out_channels; ch++) {",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"frame sync error\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"frame sync error\\n\");",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 1522,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid sample rate\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"invalid sample rate\\n\");",
          "new_line_content": "        switch (err) {",
          "content_same": false
        },
        {
          "line": 1780,
          "old_api": "ff_side_data_update_matrix_encoding",
          "new_api": null,
          "old_text": "ff_side_data_update_matrix_encoding(frame, matrix_encoding)",
          "new_text": null,
          "old_line_content": "    if ((ret = ff_side_data_update_matrix_encoding(frame, matrix_encoding)) < 0)",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": "init_get_bits8",
          "new_api": null,
          "old_text": "init_get_bits8(&s->gbc, buf + s->frame_size, buf_size - s->frame_size)",
          "new_text": null,
          "old_line_content": "        if ((ret = init_get_bits8(&s->gbc, buf + s->frame_size, buf_size - s->frame_size)) < 0)",
          "new_line_content": "        AC3HeaderInfo hdr;",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid frame size\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"invalid frame size\\n\");",
          "new_line_content": "            return AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 1656,
          "old_api": "ff_ac3_parse_header",
          "new_api": null,
          "old_text": "ff_ac3_parse_header(&s->gbc, &hdr)",
          "new_text": null,
          "old_line_content": "        err = ff_ac3_parse_header(&s->gbc, &hdr);",
          "new_line_content": "        if (buf_size - s->frame_size <= 16) {",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG,\n                       \"unsupported substream %d: skipping frame\\n\",\n                       s->substreamid)",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_DEBUG,",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_WARNING, \"Ignoring non-compatible dependent frame.\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_WARNING, \"Ignoring non-compatible dependent frame.\\n\");",
          "new_line_content": "            return ret;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 1,
      "total_additions": 45,
      "total_deletions": 46,
      "total_api_changes": 92
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 15,
        "api_related_lines": 92,
        "non_api_lines": 12,
        "non_api_line_numbers": [
          1480,
          1482,
          1483,
          1484,
          1485,
          1486,
          1487,
          1488,
          1491,
          1494,
          1495,
          1470
        ]
      }
    },
    "api_calls_before": 267,
    "api_calls_after": 265,
    "diff_info": {
      "added_lines": 14,
      "removed_lines": 6,
      "total_diff_lines": 41
    }
  }
}