{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/c52638cca255737eb060dcdedf5be4414e622e82",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/c52638cca255737eb060dcdedf5be4414e622e82/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/c52638cca255737eb060dcdedf5be4414e622e82/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/c52638cca255737eb060dcdedf5be4414e622e82/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 267,
          "old_api": "av_log",
          "new_api": "init",
          "old_text": "av_log(s, AV_LOG_ERROR, \"Failed to initialize resampler\\n\")",
          "new_text": "s->resampler->init(s->resample, s->out_sample_rate, s->in_sample_rate, s->filter_size, s->phase_shift, s->linear_interp, s->cutoff, s->int_sample_fmt, s->filter_type, s->kaiser_beta, s->precision, s->cheby, s->exact_rational)",
          "old_line_content": "            av_log(s, AV_LOG_ERROR, \"Failed to initialize resampler\\n\");",
          "new_line_content": "        s->resample = s->resampler->init(s->resample, s->out_sample_rate, s->in_sample_rate, s->filter_size, s->phase_shift, s->linear_interp, s->cutoff, s->int_sample_fmt, s->filter_type, s->kaiser_beta, s->precision, s->cheby, s->exact_rational);",
          "content_same": false
        },
        {
          "line": 293,
          "old_api": "AVERROR",
          "new_api": "av_assert0",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_assert0(!s->in_ch_layout)",
          "old_line_content": "        ret = AVERROR(EINVAL);",
          "new_line_content": "        av_assert0(!s->in_ch_layout);",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": "av_get_channel_layout_nb_channels",
          "new_api": "av_get_channel_layout_string",
          "old_text": "av_get_channel_layout_nb_channels(s->out_ch_layout)",
          "new_text": "av_get_channel_layout_string(l1, sizeof(l1), s-> in.ch_count, s-> in_ch_layout)",
          "old_line_content": "    if (s->out_ch_layout && s->out.ch_count != av_get_channel_layout_nb_channels(s->out_ch_layout)) {",
          "new_line_content": "    av_get_channel_layout_string(l1, sizeof(l1), s-> in.ch_count, s-> in_ch_layout);",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": "av_log",
          "new_api": "av_get_channel_layout_string",
          "old_text": "av_log(s, AV_LOG_ERROR, \"Output channel layout %s mismatches specified channel count %d\\n\", l2, s->out.ch_count)",
          "new_text": "av_get_channel_layout_string(l2, sizeof(l2), s->out.ch_count, s->out_ch_layout)",
          "old_line_content": "        av_log(s, AV_LOG_ERROR, \"Output channel layout %s mismatches specified channel count %d\\n\", l2, s->out.ch_count);",
          "new_line_content": "    av_get_channel_layout_string(l2, sizeof(l2), s->out.ch_count, s->out_ch_layout);",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": "AVERROR",
          "new_api": "av_get_channel_layout_nb_channels",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_get_channel_layout_nb_channels(s->out_ch_layout)",
          "old_line_content": "        ret = AVERROR(EINVAL);",
          "new_line_content": "    if (s->out_ch_layout && s->out.ch_count != av_get_channel_layout_nb_channels(s->out_ch_layout)) {",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": "AVERROR",
          "new_api": "av_get_channel_layout_nb_channels",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_get_channel_layout_nb_channels(s->in_ch_layout)",
          "old_line_content": "        ret = AVERROR(EINVAL);",
          "new_line_content": "    if (s->in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s->in_ch_layout)) {",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(s, AV_LOG_ERROR, \"Rematrix is needed between %s and %s \"\n               \"but there is not enough information to do it\\n\", l1, l2)",
          "old_line_content": "        ret = AVERROR(EINVAL);",
          "new_line_content": "        av_log(s, AV_LOG_ERROR, \"Rematrix is needed between %s and %s \"",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": "av_mallocz_array",
          "new_api": "av_assert0",
          "old_text": "av_mallocz_array(countb, a->ch_count)",
          "new_text": "av_assert0(a->ch_count)",
          "old_line_content": "    a->data= av_mallocz_array(countb, a->ch_count);",
          "new_line_content": "    av_assert0(a->ch_count);",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "AVERROR",
          "new_api": "av_mallocz_array",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "av_mallocz_array(countb, a->ch_count)",
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "    a->data= av_mallocz_array(countb, a->ch_count);",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "copy",
          "new_api": "FFMIN",
          "old_text": "copy(out, in, out_count)",
          "new_text": "FFMIN(out_count, in_count)",
          "old_line_content": "            copy(out, in, out_count);",
          "new_line_content": "            out_count= FFMIN(out_count, in_count); //TODO check at the end if this is needed or redundant",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": "swri_rematrix",
          "new_api": "resample",
          "old_text": "swri_rematrix(s, preout, midbuf, out_count, preout==out)",
          "new_text": "resample(s, midbuf, out_count, postin, in_count)",
          "old_line_content": "            swri_rematrix(s, preout, midbuf, out_count, preout==out);",
          "new_line_content": "            out_count= resample(s, midbuf, out_count, postin, in_count);",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "resample",
          "new_api": "swri_rematrix",
          "old_text": "resample(s, preout, out_count, midbuf, in_count)",
          "new_text": "swri_rematrix(s, midbuf, postin, in_count, midbuf==out)",
          "old_line_content": "            out_count= resample(s, preout, out_count, midbuf, in_count);",
          "new_line_content": "            swri_rematrix(s, midbuf, postin, in_count, midbuf==out);",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": "av_assert0",
          "new_api": "swri_get_dither",
          "old_text": "av_assert0(s->dither.noise.ch_count == preout->ch_count)",
          "new_text": "swri_get_dither(s, s->dither.noise.ch[ch], s->dither.noise.count, (12345678913579ULL*ch + 3141592) % 2718281828U, s->dither.noise.fmt)",
          "old_line_content": "            av_assert0(s->dither.noise.ch_count == preout->ch_count);",
          "new_line_content": "                    if((ret=swri_get_dither(s, s->dither.noise.ch[ch], s->dither.noise.count, (12345678913579ULL*ch + 3141592) % 2718281828U, s->dither.noise.fmt))<0)",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": "swri_noise_shaping_float",
          "new_api": "swri_noise_shaping_int16",
          "old_text": "swri_noise_shaping_float(s, conv_src, preout, &s->dither.noise, out_count)",
          "new_text": "swri_noise_shaping_int16(s, conv_src, preout, &s->dither.noise, out_count)",
          "old_line_content": "                case AV_SAMPLE_FMT_FLTP :swri_noise_shaping_float(s, conv_src, preout, &s->dither.noise, out_count); break;",
          "new_line_content": "                case AV_SAMPLE_FMT_S16P :swri_noise_shaping_int16(s, conv_src, preout, &s->dither.noise, out_count); break;",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": "swri_noise_shaping_double",
          "new_api": "swri_noise_shaping_int32",
          "old_text": "swri_noise_shaping_double(s,conv_src, preout, &s->dither.noise, out_count)",
          "new_text": "swri_noise_shaping_int32(s, conv_src, preout, &s->dither.noise, out_count)",
          "old_line_content": "                case AV_SAMPLE_FMT_DBLP :swri_noise_shaping_double(s,conv_src, preout, &s->dither.noise, out_count); break;",
          "new_line_content": "                case AV_SAMPLE_FMT_S32P :swri_noise_shaping_int32(s, conv_src, preout, &s->dither.noise, out_count); break;",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": "AVERROR",
          "new_api": "swr_is_initialized",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "swr_is_initialized(s)",
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "    if (!swr_is_initialized(s)) {",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": "FFMIN",
          "new_api": "reversefill_audiodata",
          "old_text": "FFMIN(-s->drop_output, MAX_DROP_STEP)",
          "new_text": "reversefill_audiodata(&s->drop_temp, tmp_arg)",
          "old_line_content": "        ret = swr_convert(s, tmp_arg, FFMIN(-s->drop_output, MAX_DROP_STEP), in_arg, in_count); //FIXME optimize but this is as good as never called so maybe it doesn't matter",
          "new_line_content": "        reversefill_audiodata(&s->drop_temp, tmp_arg);",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": "buf_set",
          "new_api": "FFMIN",
          "old_text": "buf_set(&tmp, &s->in_buffer, s->in_buffer_index)",
          "new_text": "FFMIN(out_count, s->in_buffer_count)",
          "old_line_content": "            buf_set(&tmp, &s->in_buffer, s->in_buffer_index);",
          "new_line_content": "        size = FFMIN(out_count, s->in_buffer_count);",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": "reversefill_audiodata",
          "new_api": "memset",
          "old_text": "reversefill_audiodata(&s->silence, tmp_arg)",
          "new_text": "memset(s->silence.ch[0], s->silence.bps==1 ? 0x80 : 0, count*s->silence.bps*s->silence.ch_count)",
          "old_line_content": "    reversefill_audiodata(&s->silence, tmp_arg);",
          "new_line_content": "        memset(s->silence.ch[0], s->silence.bps==1 ? 0x80 : 0, count*s->silence.bps*s->silence.ch_count);",
          "content_same": false
        },
        {
          "line": 853,
          "old_api": "swr_convert",
          "new_api": "reversefill_audiodata",
          "old_text": "swr_convert(s, NULL, 0, (const uint8_t**)tmp_arg, count)",
          "new_text": "reversefill_audiodata(&s->silence, tmp_arg)",
          "old_line_content": "    ret = swr_convert(s, NULL, 0, (const uint8_t**)tmp_arg, count);",
          "new_line_content": "    reversefill_audiodata(&s->silence, tmp_arg);",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": "set_compensation",
          "new_api": "AVERROR",
          "old_text": "s->resampler->set_compensation(s->resample, sample_delta, compensation_distance)",
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "        return s->resampler->set_compensation(s->resample, sample_delta, compensation_distance);",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": "swr_inject_silence",
          "new_api": "fabs",
          "old_text": "swr_inject_silence(s,  delta / s->out_sample_rate)",
          "new_text": "fabs(fdelta)",
          "old_line_content": "                if(delta > 0) ret = swr_inject_silence(s,  delta / s->out_sample_rate);",
          "new_line_content": "            if(s->outpts == s->firstpts || fabs(fdelta) > s->min_hard_compensation){",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "av_log",
          "new_api": "swr_drop_output   (s, -delta / s-> in_sample_rate)",
          "old_text": "av_log(s, AV_LOG_ERROR, \"Failed to compensate for timestamp delta of %f\\n\", fdelta)",
          "new_text": "swr_drop_output   (s, -delta / s-> in_sample_rate)",
          "old_line_content": "                    av_log(s, AV_LOG_ERROR, \"Failed to compensate for timestamp delta of %f\\n\", fdelta);",
          "new_line_content": "                else          ret = swr_drop_output   (s, -delta / s-> in_sample_rate);",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "swr_set_compensation",
          "new_api": "av_clipf",
          "old_text": "swr_set_compensation(s, comp, duration)",
          "new_text": "av_clipf(fdelta, -max_soft_compensation, max_soft_compensation)",
          "old_line_content": "                swr_set_compensation(s, comp, duration);",
          "new_line_content": "                int comp = av_clipf(fdelta, -max_soft_compensation, max_soft_compensation) * duration ;",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 512,
          "old_api": null,
          "new_api": "buf_set",
          "old_text": null,
          "new_text": "buf_set(&out, &out, ret)",
          "old_line_content": "            s->in_buffer_index += consumed;",
          "new_line_content": "            buf_set(&out, &out, ret);",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": null,
          "new_api": "buf_set",
          "old_text": null,
          "new_text": "buf_set(&in, &in, -s->in_buffer_count)",
          "old_line_content": "                s->in_buffer_count=0;",
          "new_line_content": "                buf_set(&in, &in, -s->in_buffer_count);",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(in_count-padless, 0)",
          "old_line_content": "            ret_sum += ret;",
          "new_line_content": "            ret= s->resampler->multiple_resample(s->resample, &out, out_count, &in, FFMAX(in_count-padless, 0), &consumed);",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": null,
          "new_api": "buf_set",
          "old_text": null,
          "new_text": "buf_set(&in, &in, consumed)",
          "old_line_content": "",
          "new_line_content": "            buf_set(&in, &in, consumed);",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": null,
          "new_api": "buf_set",
          "old_text": null,
          "new_text": "buf_set(&tmp, &s->in_buffer, s->in_buffer_index)",
          "old_line_content": "            s->in_buffer_index=0;",
          "new_line_content": "            buf_set(&tmp, &s->in_buffer, s->in_buffer_index);",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": null,
          "new_api": "copy",
          "old_text": null,
          "new_text": "copy(&s->in_buffer, &tmp, s->in_buffer_count)",
          "old_line_content": "        }else",
          "new_line_content": "            copy(&s->in_buffer, &tmp, s->in_buffer_count);",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": null,
          "new_api": "swri_realloc_audio",
          "old_text": null,
          "new_text": "swri_realloc_audio(&s->in_buffer, size)",
          "old_line_content": "",
          "new_line_content": "            if((ret=swri_realloc_audio(&s->in_buffer, size)) < 0)",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": null,
          "new_api": "buf_set",
          "old_text": null,
          "new_text": "buf_set(&tmp, &s->in_buffer, s->in_buffer_index + s->in_buffer_count)",
          "old_line_content": "            s->in_buffer_count += count;",
          "new_line_content": "            buf_set(&tmp, &s->in_buffer, s->in_buffer_index + s->in_buffer_count);",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": null,
          "new_api": "copy",
          "old_text": null,
          "new_text": "copy(&tmp, &in, /*in_*/count)",
          "old_line_content": "            in_count -= count;",
          "new_line_content": "            copy(&tmp, &in, /*in_*/count);",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": null,
          "new_api": "buf_set",
          "old_text": null,
          "new_text": "buf_set(&in, &in, count)",
          "old_line_content": "            if(s->in_buffer_count != count || in_count)",
          "new_line_content": "            buf_set(&in, &in, count);",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(!s->resample)",
          "old_line_content": "        return out_count;",
          "new_line_content": "        av_assert0(!s->resample);",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": null,
          "new_api": "swri_audio_convert",
          "old_text": null,
          "new_text": "swri_audio_convert(s->full_convert, out, in, in_count)",
          "old_line_content": "    }",
          "new_line_content": "        swri_audio_convert(s->full_convert, out, in, in_count);",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": null,
          "new_api": "swri_realloc_audio",
          "old_text": null,
          "new_text": "swri_realloc_audio(&s->postin, in_count)",
          "old_line_content": "    if(s->resample_first){",
          "new_line_content": "    if((ret=swri_realloc_audio(&s->postin, in_count))<0)",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(s->midbuf.ch_count == s->used_ch_count)",
          "old_line_content": "            return ret;",
          "new_line_content": "        av_assert0(s->midbuf.ch_count == s->used_ch_count);",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": null,
          "new_api": "swri_realloc_audio",
          "old_text": null,
          "new_text": "swri_realloc_audio(&s->midbuf, out_count)",
          "old_line_content": "    }else{",
          "new_line_content": "        if((ret=swri_realloc_audio(&s->midbuf, out_count))<0)",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(s->midbuf.ch_count ==  s->out.ch_count)",
          "old_line_content": "            return ret;",
          "new_line_content": "        av_assert0(s->midbuf.ch_count ==  s->out.ch_count);",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": null,
          "new_api": "swri_realloc_audio",
          "old_text": null,
          "new_text": "swri_realloc_audio(&s->midbuf,  in_count)",
          "old_line_content": "    }",
          "new_line_content": "        if((ret=swri_realloc_audio(&s->midbuf,  in_count))<0)",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": null,
          "new_api": "swri_realloc_audio",
          "old_text": null,
          "new_text": "swri_realloc_audio(&s->preout, out_count)",
          "old_line_content": "",
          "new_line_content": "    if((ret=swri_realloc_audio(&s->preout, out_count))<0)",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(s->in.planar)",
          "old_line_content": "            return out_count;",
          "new_line_content": "            av_assert0(s->in.planar); //we only support planar internally so it has to be, we support copying non planar though",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": null,
          "new_api": "copy",
          "old_text": null,
          "new_text": "copy(out, in, out_count)",
          "old_line_content": "        }",
          "new_line_content": "            copy(out, in, out_count);",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": null,
          "new_api": "swri_audio_convert",
          "old_text": null,
          "new_text": "swri_audio_convert(s->in_convert, postin, in, in_count)",
          "old_line_content": "",
          "new_line_content": "        swri_audio_convert(s->in_convert, postin, in, in_count);",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": null,
          "new_api": "swri_rematrix",
          "old_text": null,
          "new_text": "swri_rematrix(s, preout, midbuf, out_count, preout==out)",
          "old_line_content": "        if(postin != midbuf)",
          "new_line_content": "            swri_rematrix(s, preout, midbuf, out_count, preout==out);",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": null,
          "new_api": "resample",
          "old_text": null,
          "new_text": "resample(s, preout, out_count, midbuf, in_count)",
          "old_line_content": "",
          "new_line_content": "            out_count= resample(s, preout, out_count, midbuf, in_count);",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(out_count, 1<<16)",
          "old_line_content": "            if (preout == in) {",
          "new_line_content": "            int dither_count= FFMAX(out_count, 1<<16);",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": null,
          "new_api": "swri_realloc_audio",
          "old_text": null,
          "new_text": "swri_realloc_audio(&s->dither.temp, dither_count)",
          "old_line_content": "            }",
          "new_line_content": "                if((ret=swri_realloc_audio(&s->dither.temp, dither_count))<0)",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": null,
          "new_api": "swri_realloc_audio",
          "old_text": null,
          "new_text": "swri_realloc_audio(&s->dither.noise, dither_count)",
          "old_line_content": "            if(ret)",
          "new_line_content": "            if((ret=swri_realloc_audio(&s->dither.noise, dither_count))<0)",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(s->dither.noise.ch_count == preout->ch_count)",
          "old_line_content": "            if(s->dither.noise_pos + out_count > s->dither.noise.count)",
          "new_line_content": "            av_assert0(s->dither.noise.ch_count == preout->ch_count);",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": null,
          "new_api": "mix_2_1_simd",
          "old_text": null,
          "new_text": "s->mix_2_1_simd(conv_src->ch[ch], preout->ch[ch], s->dither.noise.ch[ch] + s->dither.noise.bps * s->dither.noise_pos, s->native_simd_one, 0, 0, len1)",
          "old_line_content": "                        for(ch=0; ch<preout->ch_count; ch++)",
          "new_line_content": "                            s->mix_2_1_simd(conv_src->ch[ch], preout->ch[ch], s->dither.noise.ch[ch] + s->dither.noise.bps * s->dither.noise_pos, s->native_simd_one, 0, 0, len1);",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": null,
          "new_api": "mix_2_1_f",
          "old_text": null,
          "new_text": "s->mix_2_1_f(conv_src->ch[ch] + off, preout->ch[ch] + off, s->dither.noise.ch[ch] + s->dither.noise.bps * s->dither.noise_pos + off + len1, s->native_one, 0, 0, out_count - len1)",
          "old_line_content": "                    for(ch=0; ch<preout->ch_count; ch++)",
          "new_line_content": "                            s->mix_2_1_f(conv_src->ch[ch] + off, preout->ch[ch] + off, s->dither.noise.ch[ch] + s->dither.noise.bps * s->dither.noise_pos + off + len1, s->native_one, 0, 0, out_count - len1);",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "mix_2_1_f",
          "old_text": null,
          "new_text": "s->mix_2_1_f(conv_src->ch[ch], preout->ch[ch], s->dither.noise.ch[ch] + s->dither.noise.bps * s->dither.noise_pos, s->native_one, 0, 0, out_count)",
          "old_line_content": "            } else {",
          "new_line_content": "                        s->mix_2_1_f(conv_src->ch[ch], preout->ch[ch], s->dither.noise.ch[ch] + s->dither.noise.bps * s->dither.noise_pos, s->native_one, 0, 0, out_count);",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": null,
          "new_api": "swri_noise_shaping_float",
          "old_text": null,
          "new_text": "swri_noise_shaping_float(s, conv_src, preout, &s->dither.noise, out_count)",
          "old_line_content": "                }",
          "new_line_content": "                case AV_SAMPLE_FMT_FLTP :swri_noise_shaping_float(s, conv_src, preout, &s->dither.noise, out_count); break;",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": null,
          "new_api": "swri_noise_shaping_double",
          "old_text": null,
          "new_text": "swri_noise_shaping_double(s,conv_src, preout, &s->dither.noise, out_count)",
          "old_line_content": "            }",
          "new_line_content": "                case AV_SAMPLE_FMT_DBLP :swri_noise_shaping_double(s,conv_src, preout, &s->dither.noise, out_count); break;",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": null,
          "new_api": "swri_audio_convert",
          "old_text": null,
          "new_text": "swri_audio_convert(s->out_convert, out, conv_src, out_count)",
          "old_line_content": "    return out_count;",
          "new_line_content": "        swri_audio_convert(s->out_convert, out, conv_src, out_count);",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Context has not been initialized\\n\")",
          "old_line_content": "    }",
          "new_line_content": "        av_log(s, AV_LOG_ERROR, \"Context has not been initialized\\n\");",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "#if defined(ASSERT_LEVEL) && ASSERT_LEVEL >1",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": null,
          "new_api": "swr_get_out_samples",
          "old_text": null,
          "new_text": "swr_get_out_samples(s, in_count)",
          "old_line_content": "",
          "new_line_content": "    max_output = swr_get_out_samples(s, in_count);",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(s->drop_output, MAX_DROP_STEP)",
          "old_line_content": "",
          "new_line_content": "        if((ret=swri_realloc_audio(&s->drop_temp, FFMIN(s->drop_output, MAX_DROP_STEP)))<0)",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(-s->drop_output, MAX_DROP_STEP)",
          "old_line_content": "        in_count = 0;",
          "new_line_content": "        ret = swr_convert(s, tmp_arg, FFMIN(-s->drop_output, MAX_DROP_STEP), in_arg, in_count); //FIXME optimize but this is as good as never called so maybe it doesn't matter",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(s->drop_output)",
          "old_line_content": "    }",
          "new_line_content": "        av_assert0(s->drop_output);",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": null,
          "new_api": "av_get_bytes_per_sample",
          "old_text": null,
          "new_text": "av_get_bytes_per_sample(s->in_sample_fmt)",
          "old_line_content": "        }else{",
          "new_line_content": "        }else if(av_get_bytes_per_sample(s->in_sample_fmt) <= 4){",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": null,
          "new_api": "flush",
          "old_text": null,
          "new_text": "s->resampler->flush(s)",
          "old_line_content": "            s->flushed = 1;",
          "new_line_content": "                s->resampler->flush(s);",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": null,
          "new_api": "av_get_sample_fmt_name",
          "old_text": null,
          "new_text": "av_get_sample_fmt_name(s->int_sample_fmt)",
          "old_line_content": "    if(   s->int_sample_fmt != AV_SAMPLE_FMT_S16P",
          "new_line_content": "    av_log(s, AV_LOG_DEBUG, \"Using %s internally between filters\\n\", av_get_sample_fmt_name(s->int_sample_fmt));",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": null,
          "new_api": "av_get_sample_fmt_name",
          "old_text": null,
          "new_text": "av_get_sample_fmt_name(s->int_sample_fmt)",
          "old_line_content": "    }",
          "new_line_content": "        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is not supported internally, S16/S32/S64/FLT/DBL is supported\\n\", av_get_sample_fmt_name(s->int_sample_fmt));",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": null,
          "new_api": "fill_audiodata",
          "old_text": null,
          "new_text": "fill_audiodata(out, out_arg)",
          "old_line_content": "    if(s->resample){",
          "new_line_content": "    fill_audiodata(out, out_arg);",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": null,
          "new_api": "swr_convert_internal",
          "old_text": null,
          "new_text": "swr_convert_internal(s, out, out_count, in, in_count)",
          "old_line_content": "            s->outpts += ret * (int64_t)s->in_sample_rate;",
          "new_line_content": "        int ret = swr_convert_internal(s, out, out_count, in, in_count);",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": null,
          "new_api": "set_audiodata_fmt",
          "old_text": null,
          "new_text": "set_audiodata_fmt(&s-> in, s-> in_sample_fmt)",
          "old_line_content": "",
          "new_line_content": "    set_audiodata_fmt(&s-> in, s-> in_sample_fmt);",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": null,
          "new_api": "set_audiodata_fmt",
          "old_text": null,
          "new_text": "set_audiodata_fmt(&s->out, s->out_sample_fmt)",
          "old_line_content": "    if (s->firstpts_in_samples != AV_NOPTS_VALUE) {",
          "new_line_content": "    set_audiodata_fmt(&s->out, s->out_sample_fmt);",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": null,
          "new_api": "av_assert2",
          "old_text": null,
          "new_text": "av_assert2(max_output < 0 || ret < 0 || ret <= max_output)",
          "old_line_content": "        return ret;",
          "new_line_content": "        av_assert2(max_output < 0 || ret < 0 || ret <= max_output);",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": null,
          "new_api": "buf_set",
          "old_text": null,
          "new_text": "buf_set(&tmp, &s->in_buffer, s->in_buffer_index)",
          "old_line_content": "            if(ret<0)",
          "new_line_content": "            buf_set(&tmp, &s->in_buffer, s->in_buffer_index);",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": null,
          "new_api": "swr_convert_internal",
          "old_text": null,
          "new_text": "swr_convert_internal(s, out, size, &tmp, size)",
          "old_line_content": "                return ret;",
          "new_line_content": "            ret= swr_convert_internal(s, out, size, &tmp, size);",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": null,
          "new_api": "buf_set",
          "old_text": null,
          "new_text": "buf_set(out, out, ret)",
          "old_line_content": "            if(!s->in_buffer_count)",
          "new_line_content": "            buf_set(out, out, ret);",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Failed to initialize resampler\\n\")",
          "old_line_content": "        }",
          "new_line_content": "            av_log(s, AV_LOG_ERROR, \"Failed to initialize resampler\\n\");",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    }else",
          "new_line_content": "            return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": null,
          "new_api": "free",
          "old_text": null,
          "new_text": "s->resampler->free(&s->resample)",
          "old_line_content": "        && s->int_sample_fmt != AV_SAMPLE_FMT_S32P",
          "new_line_content": "        s->resampler->free(&s->resample);",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": null,
          "new_api": "buf_set",
          "old_text": null,
          "new_text": "buf_set(&tmp, &s->in_buffer, s->in_buffer_index)",
          "old_line_content": "                    s->in_buffer_index=0;",
          "new_line_content": "                    buf_set(&tmp, &s->in_buffer, s->in_buffer_index);",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16/s32/flt/dbl\\n\")",
          "old_line_content": "        goto fail;",
          "new_line_content": "        av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16/s32/flt/dbl\\n\");",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    }",
          "new_line_content": "        ret = AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": null,
          "new_api": "copy",
          "old_text": null,
          "new_text": "copy(&s->in_buffer, &tmp, s->in_buffer_count)",
          "old_line_content": "                }else",
          "new_line_content": "                    copy(&s->in_buffer, &tmp, s->in_buffer_count);",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": null,
          "new_api": "swri_realloc_audio",
          "old_text": null,
          "new_text": "swri_realloc_audio(&s->in_buffer, size)",
          "old_line_content": "            }",
          "new_line_content": "                    if((ret=swri_realloc_audio(&s->in_buffer, size)) < 0)",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": null,
          "new_api": "av_get_channel_layout_nb_channels",
          "old_text": null,
          "new_text": "av_get_channel_layout_nb_channels(s-> in_ch_layout)",
          "old_line_content": "        s->used_ch_count= s->in.ch_count;",
          "new_line_content": "        s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout);",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(in_count, out_count)",
          "old_line_content": "                if(ret<0)",
          "new_line_content": "                size = FFMIN(in_count, out_count);",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": null,
          "new_api": "swr_convert_internal",
          "old_text": null,
          "new_text": "swr_convert_internal(s, out, size, in, size)",
          "old_line_content": "                    return ret;",
          "new_line_content": "                ret= swr_convert_internal(s, out, size, in, size);",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": null,
          "new_api": "av_get_channel_layout_nb_channels",
          "old_text": null,
          "new_text": "av_get_channel_layout_nb_channels(s->out_ch_layout)",
          "old_line_content": "    if(!s-> in.ch_count){",
          "new_line_content": "        s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout);",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": null,
          "new_api": "buf_set",
          "old_text": null,
          "new_text": "buf_set(in, in, ret)",
          "old_line_content": "                ret2 += ret;",
          "new_line_content": "                buf_set(in, in, ret);",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Input channel count and layout are unset\\n\")",
          "old_line_content": "        goto fail;",
          "new_line_content": "        av_log(s, AV_LOG_ERROR, \"Input channel count and layout are unset\\n\");",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    }",
          "new_line_content": "        ret = AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": null,
          "new_api": "buf_set",
          "old_text": null,
          "new_text": "buf_set(&tmp, &s->in_buffer, s->in_buffer_index + s->in_buffer_count)",
          "old_line_content": "                s->in_buffer_count += in_count;",
          "new_line_content": "                buf_set(&tmp, &s->in_buffer, s->in_buffer_index + s->in_buffer_count);",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": null,
          "new_api": "copy",
          "old_text": null,
          "new_text": "copy(&tmp, in, in_count)",
          "old_line_content": "            }",
          "new_line_content": "                copy(&tmp, in, in_count);",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Output channel layout %s mismatches specified channel count %d\\n\", l2, s->out.ch_count)",
          "old_line_content": "        goto fail;",
          "new_line_content": "        av_log(s, AV_LOG_ERROR, \"Output channel layout %s mismatches specified channel count %d\\n\", l2, s->out.ch_count);",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    }",
          "new_line_content": "        ret = AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": null,
          "new_api": "av_assert2",
          "old_text": null,
          "new_text": "av_assert2(max_output < 0 || ret2 < 0 || ret2 <= max_output)",
          "old_line_content": "    }",
          "new_line_content": "        av_assert2(max_output < 0 || ret2 < 0 || ret2 <= max_output);",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Input channel layout %s mismatches specified channel count %d\\n\", l1, s->used_ch_count)",
          "old_line_content": "        goto fail;",
          "new_line_content": "        av_log(s, AV_LOG_ERROR, \"Input channel layout %s mismatches specified channel count %d\\n\", l1, s->used_ch_count);",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    }",
          "new_line_content": "        ret = AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    }",
          "new_line_content": "        ret = AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_VERBOSE, \"discarding %d audio samples\\n\", count)",
          "old_line_content": "}",
          "new_line_content": "    av_log(s, AV_LOG_VERBOSE, \"discarding %d audio samples\\n\", count);",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": null,
          "new_api": "swr_convert",
          "old_text": null,
          "new_text": "swr_convert(s, NULL, s->drop_output, tmp_arg, 0)",
          "old_line_content": "",
          "new_line_content": "    return swr_convert(s, NULL, s->drop_output, tmp_arg, 0);",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(s->used_ch_count)",
          "old_line_content": "    s->resample_first= RSC*s->out.ch_count/s->in.ch_count - RSC < s->out_sample_rate/(float)s-> in_sample_rate - 1.0;",
          "new_line_content": "av_assert0(s->used_ch_count);",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(s->out.ch_count)",
          "old_line_content": "",
          "new_line_content": "av_assert0(s->out.ch_count);",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": null,
          "new_api": "swri_dither_init",
          "old_text": null,
          "new_text": "swri_dither_init(s, s->out_sample_fmt, s->int_sample_fmt)",
          "old_line_content": "",
          "new_line_content": "    if ((ret = swri_dither_init(s, s->out_sample_fmt, s->int_sample_fmt)) < 0)",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": null,
          "new_api": "swr_inject_silence",
          "old_text": null,
          "new_text": "swr_inject_silence(s, MAX_SILENCE_STEP)",
          "old_line_content": "        count -= MAX_SILENCE_STEP;",
          "new_line_content": "        if ((ret = swr_inject_silence(s, MAX_SILENCE_STEP)) < 0)",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": null,
          "new_api": "swri_audio_convert_alloc",
          "old_text": null,
          "new_text": "swri_audio_convert_alloc(s->out_sample_fmt,\n                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0)",
          "old_line_content": "        return 0;",
          "new_line_content": "        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": null,
          "new_api": "swri_realloc_audio",
          "old_text": null,
          "new_text": "swri_realloc_audio(&s->silence, count)",
          "old_line_content": "",
          "new_line_content": "    if((ret=swri_realloc_audio(&s->silence, count))<0)",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": null,
          "new_api": "swri_audio_convert_alloc",
          "old_text": null,
          "new_text": "swri_audio_convert_alloc(s->out_sample_fmt,\n                                             s->int_sample_fmt, s->out.ch_count, NULL, 0)",
          "old_line_content": "",
          "new_line_content": "    s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt,",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    }",
          "new_line_content": "        ret = AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_VERBOSE, \"adding %d audio samples of silence\\n\", count)",
          "old_line_content": "    return ret;",
          "new_line_content": "    av_log(s, AV_LOG_VERBOSE, \"adding %d audio samples of silence\\n\", count);",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": null,
          "new_api": "swr_convert",
          "old_text": null,
          "new_text": "swr_convert(s, NULL, 0, (const uint8_t**)tmp_arg, count)",
          "old_line_content": "}",
          "new_line_content": "    ret = swr_convert(s, NULL, 0, (const uint8_t**)tmp_arg, count);",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": null,
          "new_api": "get_delay",
          "old_text": null,
          "new_text": "s->resampler->get_delay(s, base)",
          "old_line_content": "        return (s->in_buffer_count*base + (s->in_sample_rate>>1))/ s->in_sample_rate;",
          "new_line_content": "        return s->resampler->get_delay(s, base);",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    if (s->resampler && s->resample) {",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": null,
          "new_api": "set_audiodata_fmt",
          "old_text": null,
          "new_text": "set_audiodata_fmt(&s->midbuf, s->int_sample_fmt)",
          "old_line_content": "",
          "new_line_content": "    set_audiodata_fmt(&s->midbuf, s->int_sample_fmt);",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": null,
          "new_api": "set_audiodata_fmt",
          "old_text": null,
          "new_text": "set_audiodata_fmt(&s->preout, s->int_sample_fmt)",
          "old_line_content": "    if(s->resample){",
          "new_line_content": "    set_audiodata_fmt(&s->preout, s->int_sample_fmt);",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOSYS)",
          "old_line_content": "    } else {",
          "new_line_content": "            return AVERROR(ENOSYS);",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": null,
          "new_api": "get_out_samples",
          "old_text": null,
          "new_text": "s->resampler->get_out_samples(s, in_samples)",
          "old_line_content": "        out_samples = s->in_buffer_count + in_samples;",
          "new_line_content": "        out_samples = s->resampler->get_out_samples(s, in_samples);",
          "content_same": false
        },
        {
          "line": 367,
          "old_api": null,
          "new_api": "set_audiodata_fmt",
          "old_text": null,
          "new_text": "set_audiodata_fmt(&s->in_buffer, s->int_sample_fmt)",
          "old_line_content": "",
          "new_line_content": "        set_audiodata_fmt(&s->in_buffer, s->int_sample_fmt);",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(s->out_sample_rate == s->in_sample_rate)",
          "old_line_content": "",
          "new_line_content": "        av_assert0(s->out_sample_rate == s->in_sample_rate);",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(!s->preout.count)",
          "old_line_content": "    s->dither.temp  = s->preout;",
          "new_line_content": "    av_assert0(!s->preout.count);",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    return out_samples;",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": null,
          "new_api": "swri_rematrix_init",
          "old_text": null,
          "new_text": "swri_rematrix_init(s)",
          "old_line_content": "            goto fail;",
          "new_line_content": "        ret = swri_rematrix_init(s);",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "        s->flags |= SWR_FLAG_RESAMPLE;",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": null,
          "new_api": "swr_init",
          "old_text": null,
          "new_text": "swr_init(s)",
          "old_line_content": "            return ret;",
          "new_line_content": "        ret = swr_init(s);",
          "content_same": false
        },
        {
          "line": 387,
          "old_api": null,
          "new_api": "swr_close",
          "old_text": null,
          "new_text": "swr_close(s)",
          "old_line_content": "",
          "new_line_content": "    swr_close(s);",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": null,
          "new_api": "set_compensation",
          "old_text": null,
          "new_text": "s->resampler->set_compensation(s->resample, sample_delta, compensation_distance)",
          "old_line_content": "}",
          "new_line_content": "        return s->resampler->set_compensation(s->resample, sample_delta, compensation_distance);",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    if(a->count >= count)",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": null,
          "new_api": "FFALIGN",
          "old_text": null,
          "new_text": "FFALIGN(count*a->bps, ALIGN)",
          "old_line_content": "",
          "new_line_content": "    countb= FFALIGN(count*a->bps, ALIGN);",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(a->bps)",
          "old_line_content": "",
          "new_line_content": "    av_assert0(a->bps);",
          "content_same": false
        },
        {
          "line": 919,
          "old_api": null,
          "new_api": "swr_get_delay",
          "old_text": null,
          "new_text": "swr_get_delay(s, s->in_sample_rate * (int64_t)s->out_sample_rate)",
          "old_line_content": "",
          "new_line_content": "        int64_t delta = pts - swr_get_delay(s, s->in_sample_rate * (int64_t)s->out_sample_rate) - s->outpts + s->drop_output*(int64_t)s->in_sample_rate;",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": null,
          "new_api": "fabs",
          "old_text": null,
          "new_text": "fabs(fdelta)",
          "old_line_content": "                int ret;",
          "new_line_content": "        if(fabs(fdelta) > s->min_compensation) {",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "        a->ch[i]= a->data + i*(a->planar ? countb : a->bps);",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": null,
          "new_api": "swr_inject_silence",
          "old_text": null,
          "new_text": "swr_inject_silence(s,  delta / s->out_sample_rate)",
          "old_line_content": "                if(ret<0){",
          "new_line_content": "                if(delta > 0) ret = swr_inject_silence(s,  delta / s->out_sample_rate);",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Failed to compensate for timestamp delta of %f\\n\", fdelta)",
          "old_line_content": "            } else if(s->soft_compensation_duration && s->max_soft_compensation) {",
          "new_line_content": "                    av_log(s, AV_LOG_ERROR, \"Failed to compensate for timestamp delta of %f\\n\", fdelta);",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(a->ch[0], old.ch[0], a->count*a->ch_count*a->bps)",
          "old_line_content": "    a->count= count;",
          "new_line_content": "    if(a->count && !a->planar) memcpy(a->ch[0], old.ch[0], a->count*a->ch_count*a->bps);",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&old.data)",
          "old_line_content": "",
          "new_line_content": "    av_freep(&old.data);",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_VERBOSE, \"compensating audio timestamp drift:%f compensation:%d in:%d\\n\", fdelta, comp, duration)",
          "old_line_content": "            }",
          "new_line_content": "                av_log(s, AV_LOG_VERBOSE, \"compensating audio timestamp drift:%f compensation:%d in:%d\\n\", fdelta, comp, duration);",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": null,
          "new_api": "swr_set_compensation",
          "old_text": null,
          "new_text": "swr_set_compensation(s, comp, duration)",
          "old_line_content": "        }",
          "new_line_content": "                swr_set_compensation(s, comp, duration);",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(out->bps == in->bps)",
          "old_line_content": "    if(out->planar){",
          "new_line_content": "    av_assert0(out->bps == in->bps);",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(out->ch_count == in->ch_count)",
          "old_line_content": "        int ch;",
          "new_line_content": "    av_assert0(out->ch_count == in->ch_count);",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(out->ch[0], in->ch[0], count*out->ch_count*out->bps)",
          "old_line_content": "",
          "new_line_content": "        memcpy(out->ch[0], in->ch[0], count*out->ch_count*out->bps);",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(out->ch, 0, sizeof(out->ch))",
          "old_line_content": "        for(i=0; i<out->ch_count; i++)",
          "new_line_content": "        memset(out->ch, 0, sizeof(out->ch));",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": null,
          "new_api": "av_assert1",
          "old_text": null,
          "new_text": "av_assert1(s->in_buffer.planar   == in_param->planar)",
          "old_line_content": "",
          "new_line_content": "    av_assert1(s->in_buffer.planar   == in_param->planar);",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": null,
          "new_api": "av_assert1",
          "old_text": null,
          "new_text": "av_assert1(s->in_buffer.fmt      == in_param->fmt)",
          "old_line_content": "    tmp=out=*out_param;",
          "new_line_content": "    av_assert1(s->in_buffer.fmt      == in_param->fmt);",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": null,
          "new_api": "invert_initial_buffer",
          "old_text": null,
          "new_text": "s->resampler->invert_initial_buffer(s->resample, &s->in_buffer,\n                 &in, in_count, &s->in_buffer_index, &s->in_buffer_count)",
          "old_line_content": "    if (border == INT_MAX) {",
          "new_line_content": "    border = s->resampler->invert_initial_buffer(s->resample, &s->in_buffer,",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": null,
          "new_api": "buf_set",
          "old_text": null,
          "new_text": "buf_set(&in, &in, border)",
          "old_line_content": "        s->resample_in_constraint = 0;",
          "new_line_content": "        buf_set(&in, &in, border);",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": null,
          "new_api": "buf_set",
          "old_text": null,
          "new_text": "buf_set(&tmp, &s->in_buffer, s->in_buffer_index)",
          "old_line_content": "            out_count -= ret;",
          "new_line_content": "            buf_set(&tmp, &s->in_buffer, s->in_buffer_index);",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": null,
          "new_api": "multiple_resample",
          "old_text": null,
          "new_text": "s->resampler->multiple_resample(s->resample, &out, out_count, &tmp, s->in_buffer_count, &consumed)",
          "old_line_content": "            ret_sum += ret;",
          "new_line_content": "            ret= s->resampler->multiple_resample(s->resample, &out, out_count, &tmp, s->in_buffer_count, &consumed);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 517,
          "old_api": "buf_set",
          "new_api": null,
          "old_text": "buf_set(&in, &in, -s->in_buffer_count)",
          "new_text": null,
          "old_line_content": "                buf_set(&in, &in, -s->in_buffer_count);",
          "new_line_content": "                break;",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(in_count-padless, 0)",
          "new_text": null,
          "old_line_content": "            ret= s->resampler->multiple_resample(s->resample, &out, out_count, &in, FFMAX(in_count-padless, 0), &consumed);",
          "new_line_content": "        if((s->flushed || in_count > padless) && !s->in_buffer_count){",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": "buf_set",
          "new_api": null,
          "old_text": "buf_set(&out, &out, ret)",
          "new_text": null,
          "old_line_content": "            buf_set(&out, &out, ret);",
          "new_line_content": "            out_count -= ret;",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "buf_set",
          "new_api": null,
          "old_text": "buf_set(&tmp, &s->in_buffer, s->in_buffer_index)",
          "new_text": null,
          "old_line_content": "            buf_set(&tmp, &s->in_buffer, s->in_buffer_index);",
          "new_line_content": "        if(   size > s->in_buffer.count",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": "copy",
          "new_api": null,
          "old_text": "copy(&s->in_buffer, &tmp, s->in_buffer_count)",
          "new_text": null,
          "old_line_content": "            copy(&s->in_buffer, &tmp, s->in_buffer_count);",
          "new_line_content": "           && s->in_buffer_count + in_count <= s->in_buffer_index){",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": "swri_realloc_audio",
          "new_api": null,
          "old_text": "swri_realloc_audio(&s->in_buffer, size)",
          "new_text": null,
          "old_line_content": "            if((ret=swri_realloc_audio(&s->in_buffer, size)) < 0)",
          "new_line_content": "            s->in_buffer_index=0;",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": "buf_set",
          "new_api": null,
          "old_text": "buf_set(&tmp, &s->in_buffer, s->in_buffer_index + s->in_buffer_count)",
          "new_text": null,
          "old_line_content": "            buf_set(&tmp, &s->in_buffer, s->in_buffer_index + s->in_buffer_count);",
          "new_line_content": "            if(s->in_buffer_count && s->in_buffer_count+2 < count && out_count) count= s->in_buffer_count+2;",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "copy",
          "new_api": null,
          "old_text": "copy(&tmp, &in, /*in_*/count)",
          "new_text": null,
          "old_line_content": "            copy(&tmp, &in, /*in_*/count);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": "buf_set",
          "new_api": null,
          "old_text": "buf_set(&in, &in, count)",
          "new_text": null,
          "old_line_content": "            buf_set(&in, &in, count);",
          "new_line_content": "            in_count -= count;",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(!s->resample)",
          "new_text": null,
          "old_line_content": "        av_assert0(!s->resample);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": "swri_audio_convert",
          "new_api": null,
          "old_text": "swri_audio_convert(s->full_convert, out, in, in_count)",
          "new_text": null,
          "old_line_content": "        swri_audio_convert(s->full_convert, out, in, in_count);",
          "new_line_content": "    if(s->full_convert){",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "swri_realloc_audio",
          "new_api": null,
          "old_text": "swri_realloc_audio(&s->postin, in_count)",
          "new_text": null,
          "old_line_content": "    if((ret=swri_realloc_audio(&s->postin, in_count))<0)",
          "new_line_content": "//     in_count= FFMIN(in_count, in_in + 2 - s->hist_buffer_count);",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(s->midbuf.ch_count == s->used_ch_count)",
          "new_text": null,
          "old_line_content": "        av_assert0(s->midbuf.ch_count == s->used_ch_count);",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": "swri_realloc_audio",
          "new_api": null,
          "old_text": "swri_realloc_audio(&s->midbuf, out_count)",
          "new_text": null,
          "old_line_content": "        if((ret=swri_realloc_audio(&s->midbuf, out_count))<0)",
          "new_line_content": "    if(s->resample_first){",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(s->midbuf.ch_count ==  s->out.ch_count)",
          "new_text": null,
          "old_line_content": "        av_assert0(s->midbuf.ch_count ==  s->out.ch_count);",
          "new_line_content": "            return ret;",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "swri_realloc_audio",
          "new_api": null,
          "old_text": "swri_realloc_audio(&s->midbuf,  in_count)",
          "new_text": null,
          "old_line_content": "        if((ret=swri_realloc_audio(&s->midbuf,  in_count))<0)",
          "new_line_content": "    }else{",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": "swri_realloc_audio",
          "new_api": null,
          "old_text": "swri_realloc_audio(&s->preout, out_count)",
          "new_text": null,
          "old_line_content": "    if((ret=swri_realloc_audio(&s->preout, out_count))<0)",
          "new_line_content": "            return ret;",
          "content_same": false
        },
        {
          "line": 620,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(out_count, in_count)",
          "new_text": null,
          "old_line_content": "            out_count= FFMIN(out_count, in_count); //TODO check at the end if this is needed or redundant",
          "new_line_content": "       && !(s->out_sample_fmt==AV_SAMPLE_FMT_S32P && (s->dither.output_sample_bits&31))){",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(s->in.planar)",
          "new_text": null,
          "old_line_content": "            av_assert0(s->in.planar); //we only support planar internally so it has to be, we support copying non planar though",
          "new_line_content": "        if(preout==in){",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": "swri_audio_convert",
          "new_api": null,
          "old_text": "swri_audio_convert(s->in_convert, postin, in, in_count)",
          "new_text": null,
          "old_line_content": "        swri_audio_convert(s->in_convert, postin, in, in_count);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": "resample",
          "new_api": null,
          "old_text": "resample(s, midbuf, out_count, postin, in_count)",
          "new_text": null,
          "old_line_content": "            out_count= resample(s, midbuf, out_count, postin, in_count);",
          "new_line_content": "    if(s->resample_first){",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": "swri_rematrix",
          "new_api": null,
          "old_text": "swri_rematrix(s, midbuf, postin, in_count, midbuf==out)",
          "new_text": null,
          "old_line_content": "            swri_rematrix(s, midbuf, postin, in_count, midbuf==out);",
          "new_line_content": "    }else{",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(out_count, 1<<16)",
          "new_text": null,
          "old_line_content": "            int dither_count= FFMAX(out_count, 1<<16);",
          "new_line_content": "        if(s->dither.method){",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": "swri_realloc_audio",
          "new_api": null,
          "old_text": "swri_realloc_audio(&s->dither.temp, dither_count)",
          "new_text": null,
          "old_line_content": "                if((ret=swri_realloc_audio(&s->dither.temp, dither_count))<0)",
          "new_line_content": "            if (preout == in) {",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "swri_realloc_audio",
          "new_api": null,
          "old_text": "swri_realloc_audio(&s->dither.noise, dither_count)",
          "new_text": null,
          "old_line_content": "            if((ret=swri_realloc_audio(&s->dither.noise, dither_count))<0)",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": "swri_get_dither",
          "new_api": null,
          "old_text": "swri_get_dither(s, s->dither.noise.ch[ch], s->dither.noise.count, (12345678913579ULL*ch + 3141592) % 2718281828U, s->dither.noise.fmt)",
          "new_text": null,
          "old_line_content": "                    if((ret=swri_get_dither(s, s->dither.noise.ch[ch], s->dither.noise.count, (12345678913579ULL*ch + 3141592) % 2718281828U, s->dither.noise.fmt))<0)",
          "new_line_content": "            if(ret)",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": "mix_2_1_simd",
          "new_api": null,
          "old_text": "s->mix_2_1_simd(conv_src->ch[ch], preout->ch[ch], s->dither.noise.ch[ch] + s->dither.noise.bps * s->dither.noise_pos, s->native_simd_one, 0, 0, len1)",
          "new_text": null,
          "old_line_content": "                            s->mix_2_1_simd(conv_src->ch[ch], preout->ch[ch], s->dither.noise.ch[ch] + s->dither.noise.bps * s->dither.noise_pos, s->native_simd_one, 0, 0, len1);",
          "new_line_content": "                    if(len1)",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "mix_2_1_f",
          "new_api": null,
          "old_text": "s->mix_2_1_f(conv_src->ch[ch] + off, preout->ch[ch] + off, s->dither.noise.ch[ch] + s->dither.noise.bps * s->dither.noise_pos + off + len1, s->native_one, 0, 0, out_count - len1)",
          "new_text": null,
          "old_line_content": "                            s->mix_2_1_f(conv_src->ch[ch] + off, preout->ch[ch] + off, s->dither.noise.ch[ch] + s->dither.noise.bps * s->dither.noise_pos + off + len1, s->native_one, 0, 0, out_count - len1);",
          "new_line_content": "                    if(out_count != len1)",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": "mix_2_1_f",
          "new_api": null,
          "old_text": "s->mix_2_1_f(conv_src->ch[ch], preout->ch[ch], s->dither.noise.ch[ch] + s->dither.noise.bps * s->dither.noise_pos, s->native_one, 0, 0, out_count)",
          "new_text": null,
          "old_line_content": "                        s->mix_2_1_f(conv_src->ch[ch], preout->ch[ch], s->dither.noise.ch[ch] + s->dither.noise.bps * s->dither.noise_pos, s->native_one, 0, 0, out_count);",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": "swri_noise_shaping_int16",
          "new_api": null,
          "old_text": "swri_noise_shaping_int16(s, conv_src, preout, &s->dither.noise, out_count)",
          "new_text": null,
          "old_line_content": "                case AV_SAMPLE_FMT_S16P :swri_noise_shaping_int16(s, conv_src, preout, &s->dither.noise, out_count); break;",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "swri_noise_shaping_int32",
          "new_api": null,
          "old_text": "swri_noise_shaping_int32(s, conv_src, preout, &s->dither.noise, out_count)",
          "new_text": null,
          "old_line_content": "                case AV_SAMPLE_FMT_S32P :swri_noise_shaping_int32(s, conv_src, preout, &s->dither.noise, out_count); break;",
          "new_line_content": "                switch(s->int_sample_fmt) {",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": "swri_audio_convert",
          "new_api": null,
          "old_text": "swri_audio_convert(s->out_convert, out, conv_src, out_count)",
          "new_text": null,
          "old_line_content": "        swri_audio_convert(s->out_convert, out, conv_src, out_count);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": "swr_is_initialized",
          "new_api": null,
          "old_text": "swr_is_initialized(s)",
          "new_text": null,
          "old_line_content": "    if (!swr_is_initialized(s)) {",
          "new_line_content": "    int av_unused max_output;",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Context has not been initialized\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR, \"Context has not been initialized\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": "swr_get_out_samples",
          "new_api": null,
          "old_text": "swr_get_out_samples(s, in_count)",
          "new_text": null,
          "old_line_content": "    max_output = swr_get_out_samples(s, in_count);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(s->drop_output, MAX_DROP_STEP)",
          "new_text": null,
          "old_line_content": "        if((ret=swri_realloc_audio(&s->drop_temp, FFMIN(s->drop_output, MAX_DROP_STEP)))<0)",
          "new_line_content": "        uint8_t *tmp_arg[SWR_CH_MAX];",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "reversefill_audiodata",
          "new_api": null,
          "old_text": "reversefill_audiodata(&s->drop_temp, tmp_arg)",
          "new_text": null,
          "old_line_content": "        reversefill_audiodata(&s->drop_temp, tmp_arg);",
          "new_line_content": "            return ret;",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(s->drop_output)",
          "new_text": null,
          "old_line_content": "        av_assert0(s->drop_output);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": "av_get_bytes_per_sample",
          "new_api": null,
          "old_text": "av_get_bytes_per_sample(s->in_sample_fmt)",
          "new_text": null,
          "old_line_content": "        }else if(av_get_bytes_per_sample(s->in_sample_fmt) <= 4){",
          "new_line_content": "                 && s->engine != SWR_ENGINE_SOXR){",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": "flush",
          "new_api": null,
          "old_text": "s->resampler->flush(s)",
          "new_text": null,
          "old_line_content": "                s->resampler->flush(s);",
          "new_line_content": "        if(s->resample){",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": "av_get_sample_fmt_name",
          "new_api": null,
          "old_text": "av_get_sample_fmt_name(s->int_sample_fmt)",
          "new_text": null,
          "old_line_content": "    av_log(s, AV_LOG_DEBUG, \"Using %s internally between filters\\n\", av_get_sample_fmt_name(s->int_sample_fmt));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": "fill_audiodata",
          "new_api": null,
          "old_text": "fill_audiodata(in ,  (void*)in_arg)",
          "new_text": null,
          "old_line_content": "        fill_audiodata(in ,  (void*)in_arg);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": "av_get_sample_fmt_name",
          "new_api": null,
          "old_text": "av_get_sample_fmt_name(s->int_sample_fmt)",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is not supported internally, S16/S32/S64/FLT/DBL is supported\\n\", av_get_sample_fmt_name(s->int_sample_fmt));",
          "new_line_content": "        &&s->int_sample_fmt != AV_SAMPLE_FMT_FLTP",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "        &&s->int_sample_fmt != AV_SAMPLE_FMT_DBLP){",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": "swr_convert_internal",
          "new_api": null,
          "old_text": "swr_convert_internal(s, out, out_count, in, in_count)",
          "new_text": null,
          "old_line_content": "        int ret = swr_convert_internal(s, out, out_count, in, in_count);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": "set_audiodata_fmt",
          "new_api": null,
          "old_text": "set_audiodata_fmt(&s-> in, s-> in_sample_fmt)",
          "new_text": null,
          "old_line_content": "    set_audiodata_fmt(&s-> in, s-> in_sample_fmt);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": "set_audiodata_fmt",
          "new_api": null,
          "old_text": "set_audiodata_fmt(&s->out, s->out_sample_fmt)",
          "new_text": null,
          "old_line_content": "    set_audiodata_fmt(&s->out, s->out_sample_fmt);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": "av_assert2",
          "new_api": null,
          "old_text": "av_assert2(max_output < 0 || ret < 0 || ret <= max_output)",
          "new_text": null,
          "old_line_content": "        av_assert2(max_output < 0 || ret < 0 || ret <= max_output);",
          "new_line_content": "            s->outpts += ret * (int64_t)s->in_sample_rate;",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(out_count, s->in_buffer_count)",
          "new_text": null,
          "old_line_content": "        size = FFMIN(out_count, s->in_buffer_count);",
          "new_line_content": "        int ret2=0;",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "swr_convert_internal",
          "new_api": null,
          "old_text": "swr_convert_internal(s, out, size, &tmp, size)",
          "new_text": null,
          "old_line_content": "            ret= swr_convert_internal(s, out, size, &tmp, size);",
          "new_line_content": "        if(size){",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "buf_set",
          "new_api": null,
          "old_text": "buf_set(out, out, ret)",
          "new_text": null,
          "old_line_content": "            buf_set(out, out, ret);",
          "new_line_content": "            s->in_buffer_count -= ret;",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": "init",
          "new_api": null,
          "old_text": "s->resampler->init(s->resample, s->out_sample_rate, s->in_sample_rate, s->filter_size, s->phase_shift, s->linear_interp, s->cutoff, s->int_sample_fmt, s->filter_type, s->kaiser_beta, s->precision, s->cheby, s->exact_rational)",
          "new_text": null,
          "old_line_content": "        s->resample = s->resampler->init(s->resample, s->out_sample_rate, s->in_sample_rate, s->filter_size, s->phase_shift, s->linear_interp, s->cutoff, s->int_sample_fmt, s->filter_type, s->kaiser_beta, s->precision, s->cheby, s->exact_rational);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "            return AVERROR(ENOMEM);",
          "new_line_content": "        if (!s->resample) {",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "free",
          "new_api": null,
          "old_text": "s->resampler->free(&s->resample)",
          "new_text": null,
          "old_line_content": "        s->resampler->free(&s->resample);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": "buf_set",
          "new_api": null,
          "old_text": "buf_set(&tmp, &s->in_buffer, s->in_buffer_index)",
          "new_text": null,
          "old_line_content": "                    buf_set(&tmp, &s->in_buffer, s->in_buffer_index);",
          "new_line_content": "                if(   size > s->in_buffer.count",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16/s32/flt/dbl\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16/s32/flt/dbl\\n\");",
          "new_line_content": "        && s->int_sample_fmt != AV_SAMPLE_FMT_DBLP",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        ret = AVERROR(EINVAL);",
          "new_line_content": "        && s->resample){",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": "copy",
          "new_api": null,
          "old_text": "copy(&s->in_buffer, &tmp, s->in_buffer_count)",
          "new_text": null,
          "old_line_content": "                    copy(&s->in_buffer, &tmp, s->in_buffer_count);",
          "new_line_content": "                && s->in_buffer_count + in_count - out_count <= s->in_buffer_index){",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": "swri_realloc_audio",
          "new_api": null,
          "old_text": "swri_realloc_audio(&s->in_buffer, size)",
          "new_text": null,
          "old_line_content": "                    if((ret=swri_realloc_audio(&s->in_buffer, size)) < 0)",
          "new_line_content": "                    s->in_buffer_index=0;",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "av_get_channel_layout_nb_channels",
          "new_api": null,
          "old_text": "av_get_channel_layout_nb_channels(s-> in_ch_layout)",
          "new_text": null,
          "old_line_content": "        s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout);",
          "new_line_content": "#define RSC 1 //FIXME finetune",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(in_count, out_count)",
          "new_text": null,
          "old_line_content": "                size = FFMIN(in_count, out_count);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": "swr_convert_internal",
          "new_api": null,
          "old_text": "swr_convert_internal(s, out, size, in, size)",
          "new_text": null,
          "old_line_content": "                ret= swr_convert_internal(s, out, size, in, size);",
          "new_line_content": "            if(out_count){",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": "av_get_channel_layout_nb_channels",
          "new_api": null,
          "old_text": "av_get_channel_layout_nb_channels(s->out_ch_layout)",
          "new_text": null,
          "old_line_content": "        s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout);",
          "new_line_content": "        s->used_ch_count= s->in.ch_count;",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "buf_set",
          "new_api": null,
          "old_text": "buf_set(in, in, ret)",
          "new_text": null,
          "old_line_content": "                buf_set(in, in, ret);",
          "new_line_content": "                if(ret<0)",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(!s->in_ch_layout)",
          "new_text": null,
          "old_line_content": "        av_assert0(!s->in_ch_layout);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Input channel count and layout are unset\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR, \"Input channel count and layout are unset\\n\");",
          "new_line_content": "    if(!s-> in.ch_count){",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "buf_set",
          "new_api": null,
          "old_text": "buf_set(&tmp, &s->in_buffer, s->in_buffer_index + s->in_buffer_count)",
          "new_text": null,
          "old_line_content": "                buf_set(&tmp, &s->in_buffer, s->in_buffer_index + s->in_buffer_count);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "copy",
          "new_api": null,
          "old_text": "copy(&tmp, in, in_count)",
          "new_text": null,
          "old_line_content": "                copy(&tmp, in, in_count);",
          "new_line_content": "            if(in_count){",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": "av_get_channel_layout_string",
          "new_api": null,
          "old_text": "av_get_channel_layout_string(l1, sizeof(l1), s-> in.ch_count, s-> in_ch_layout)",
          "new_text": null,
          "old_line_content": "    av_get_channel_layout_string(l1, sizeof(l1), s-> in.ch_count, s-> in_ch_layout);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": "av_get_channel_layout_string",
          "new_api": null,
          "old_text": "av_get_channel_layout_string(l2, sizeof(l2), s->out.ch_count, s->out_ch_layout)",
          "new_text": null,
          "old_line_content": "    av_get_channel_layout_string(l2, sizeof(l2), s->out.ch_count, s->out_ch_layout);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "av_assert2",
          "new_api": null,
          "old_text": "av_assert2(max_output < 0 || ret2 < 0 || ret2 <= max_output)",
          "new_text": null,
          "old_line_content": "        av_assert2(max_output < 0 || ret2 < 0 || ret2 <= max_output);",
          "new_line_content": "        if(ret2>0 && !s->drop_output)",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "av_get_channel_layout_nb_channels",
          "new_api": null,
          "old_text": "av_get_channel_layout_nb_channels(s->in_ch_layout)",
          "new_text": null,
          "old_line_content": "    if (s->in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s->in_ch_layout)) {",
          "new_line_content": "        goto fail;",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Input channel layout %s mismatches specified channel count %d\\n\", l1, s->used_ch_count)",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR, \"Input channel layout %s mismatches specified channel count %d\\n\", l1, s->used_ch_count);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Rematrix is needed between %s and %s \"\n               \"but there is not enough information to do it\\n\", l1, l2)",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR, \"Rematrix is needed between %s and %s \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_VERBOSE, \"discarding %d audio samples\\n\", count)",
          "new_text": null,
          "old_line_content": "    av_log(s, AV_LOG_VERBOSE, \"discarding %d audio samples\\n\", count);",
          "new_line_content": "        return 0;",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "swr_convert",
          "new_api": null,
          "old_text": "swr_convert(s, NULL, s->drop_output, tmp_arg, 0)",
          "new_text": null,
          "old_line_content": "    return swr_convert(s, NULL, s->drop_output, tmp_arg, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(s->used_ch_count)",
          "new_text": null,
          "old_line_content": "av_assert0(s->used_ch_count);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(s->out.ch_count)",
          "new_text": null,
          "old_line_content": "av_assert0(s->out.ch_count);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": "swri_dither_init",
          "new_api": null,
          "old_text": "swri_dither_init(s, s->out_sample_fmt, s->int_sample_fmt)",
          "new_text": null,
          "old_line_content": "    if ((ret = swri_dither_init(s, s->out_sample_fmt, s->int_sample_fmt)) < 0)",
          "new_line_content": "    s->drop_temp= s->out;",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": "swr_inject_silence",
          "new_api": null,
          "old_text": "swr_inject_silence(s, MAX_SILENCE_STEP)",
          "new_text": null,
          "old_line_content": "        if ((ret = swr_inject_silence(s, MAX_SILENCE_STEP)) < 0)",
          "new_line_content": "#define MAX_SILENCE_STEP 16384",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": "swri_audio_convert_alloc",
          "new_api": null,
          "old_text": "swri_audio_convert_alloc(s->out_sample_fmt,\n                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0)",
          "new_text": null,
          "old_line_content": "        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": "swri_realloc_audio",
          "new_api": null,
          "old_text": "swri_realloc_audio(&s->silence, count)",
          "new_text": null,
          "old_line_content": "    if((ret=swri_realloc_audio(&s->silence, count))<0)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 334,
          "old_api": "swri_audio_convert_alloc",
          "new_api": null,
          "old_text": "swri_audio_convert_alloc(s->int_sample_fmt,\n                                             s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0)",
          "new_text": null,
          "old_line_content": "    s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(s->silence.ch[i], s->silence.bps==1 ? 0x80 : 0, count*s->silence.bps)",
          "new_text": null,
          "old_line_content": "        memset(s->silence.ch[i], s->silence.bps==1 ? 0x80 : 0, count*s->silence.bps);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        ret = AVERROR(ENOMEM);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_VERBOSE, \"adding %d audio samples of silence\\n\", count)",
          "new_text": null,
          "old_line_content": "    av_log(s, AV_LOG_VERBOSE, \"adding %d audio samples of silence\\n\", count);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": "get_delay",
          "new_api": null,
          "old_text": "s->resampler->get_delay(s, base)",
          "new_text": null,
          "old_line_content": "        return s->resampler->get_delay(s, base);",
          "new_line_content": "int64_t swr_get_delay(struct SwrContext *s, int64_t base){",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 360,
          "old_api": "set_audiodata_fmt",
          "new_api": null,
          "old_text": "set_audiodata_fmt(&s->postin, s->int_sample_fmt)",
          "new_text": null,
          "old_line_content": "    set_audiodata_fmt(&s->postin, s->int_sample_fmt);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": "set_audiodata_fmt",
          "new_api": null,
          "old_text": "set_audiodata_fmt(&s->midbuf, s->int_sample_fmt)",
          "new_text": null,
          "old_line_content": "    set_audiodata_fmt(&s->midbuf, s->int_sample_fmt);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOSYS)",
          "new_text": null,
          "old_line_content": "            return AVERROR(ENOSYS);",
          "new_line_content": "    if (s->resampler && s->resample) {",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": "get_out_samples",
          "new_api": null,
          "old_text": "s->resampler->get_out_samples(s, in_samples)",
          "new_text": null,
          "old_line_content": "        out_samples = s->resampler->get_out_samples(s, in_samples);",
          "new_line_content": "        if (!s->resampler->get_out_samples)",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "set_audiodata_fmt",
          "new_api": null,
          "old_text": "set_audiodata_fmt(&s->in_buffer, s->int_sample_fmt)",
          "new_text": null,
          "old_line_content": "        set_audiodata_fmt(&s->in_buffer, s->int_sample_fmt);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(s->out_sample_rate == s->in_sample_rate)",
          "new_text": null,
          "old_line_content": "        av_assert0(s->out_sample_rate == s->in_sample_rate);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 368,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(!s->preout.count)",
          "new_text": null,
          "old_line_content": "    av_assert0(!s->preout.count);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": "swri_rematrix_init",
          "new_api": null,
          "old_text": "swri_rematrix_init(s)",
          "new_text": null,
          "old_line_content": "        ret = swri_rematrix_init(s);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": "swr_init",
          "new_api": null,
          "old_text": "swr_init(s)",
          "new_text": null,
          "old_line_content": "        ret = swr_init(s);",
          "new_line_content": "    if (!s->resample) {",
          "content_same": false
        },
        {
          "line": 385,
          "old_api": "swr_close",
          "new_api": null,
          "old_text": "swr_close(s)",
          "new_text": null,
          "old_line_content": "    swr_close(s);",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": "FFALIGN",
          "new_api": null,
          "old_text": "FFALIGN(count*a->bps, ALIGN)",
          "new_text": null,
          "old_line_content": "    countb= FFALIGN(count*a->bps, ALIGN);",
          "new_line_content": "    count*=2;",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": "swr_get_delay",
          "new_api": null,
          "old_text": "swr_get_delay(s, s->in_sample_rate * (int64_t)s->out_sample_rate)",
          "new_text": null,
          "old_line_content": "        return (s->outpts = pts - swr_get_delay(s, s->in_sample_rate * (int64_t)s->out_sample_rate));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(a->bps)",
          "new_text": null,
          "old_line_content": "    av_assert0(a->bps);",
          "new_line_content": "    old= *a;",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(a->ch_count)",
          "new_text": null,
          "old_line_content": "    av_assert0(a->ch_count);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "fabs",
          "new_api": null,
          "old_text": "fabs(fdelta)",
          "new_text": null,
          "old_line_content": "        if(fabs(fdelta) > s->min_compensation) {",
          "new_line_content": "        double fdelta = delta /(double)(s->in_sample_rate * (int64_t)s->out_sample_rate);",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": "fabs",
          "new_api": null,
          "old_text": "fabs(fdelta)",
          "new_text": null,
          "old_line_content": "            if(s->outpts == s->firstpts || fabs(fdelta) > s->min_hard_compensation){",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": "swr_drop_output   (s, -delta / s-> in_sample_rate)",
          "new_api": null,
          "old_text": "swr_drop_output   (s, -delta / s-> in_sample_rate)",
          "new_text": null,
          "old_line_content": "                else          ret = swr_drop_output   (s, -delta / s-> in_sample_rate);",
          "new_line_content": "                int ret;",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(a->ch[i], old.ch[i], a->count*a->bps)",
          "new_text": null,
          "old_line_content": "        if(a->count && a->planar) memcpy(a->ch[i], old.ch[i], a->count*a->bps);",
          "new_line_content": "    for(i=0; i<a->ch_count; i++){",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&old.data)",
          "new_text": null,
          "old_line_content": "    av_freep(&old.data);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "av_clipf",
          "new_api": null,
          "old_text": "av_clipf(fdelta, -max_soft_compensation, max_soft_compensation)",
          "new_text": null,
          "old_line_content": "                int comp = av_clipf(fdelta, -max_soft_compensation, max_soft_compensation) * duration ;",
          "new_line_content": "                int duration = s->out_sample_rate * s->soft_compensation_duration;",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_VERBOSE, \"compensating audio timestamp drift:%f compensation:%d in:%d\\n\", fdelta, comp, duration)",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_VERBOSE, \"compensating audio timestamp drift:%f compensation:%d in:%d\\n\", fdelta, comp, duration);",
          "new_line_content": "                double max_soft_compensation = s->max_soft_compensation / (s->max_soft_compensation < 0 ? -s->in_sample_rate : 1);",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(out->planar == in->planar)",
          "new_text": null,
          "old_line_content": "    av_assert0(out->planar == in->planar);",
          "new_line_content": "static void copy(AudioData *out, AudioData *in,",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(out->bps == in->bps)",
          "new_text": null,
          "old_line_content": "    av_assert0(out->bps == in->bps);",
          "new_line_content": "                 int count){",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(out->ch[ch], in->ch[ch], count*out->bps)",
          "new_text": null,
          "old_line_content": "            memcpy(out->ch[ch], in->ch[ch], count*out->bps);",
          "new_line_content": "        int ch;",
          "content_same": false
        },
        {
          "line": 438,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(out->ch, 0, sizeof(out->ch))",
          "new_text": null,
          "old_line_content": "        memset(out->ch, 0, sizeof(out->ch));",
          "new_line_content": "    int i;",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "av_assert1",
          "new_api": null,
          "old_text": "av_assert1(s->in_buffer.ch_count == in_param->ch_count)",
          "new_text": null,
          "old_line_content": "    av_assert1(s->in_buffer.ch_count == in_param->ch_count);",
          "new_line_content": "    int padless = ARCH_X86 && s->engine == SWR_ENGINE_SWR ? 7 : 0;",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": "av_assert1",
          "new_api": null,
          "old_text": "av_assert1(s->in_buffer.planar   == in_param->planar)",
          "new_text": null,
          "old_line_content": "    av_assert1(s->in_buffer.planar   == in_param->planar);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": "invert_initial_buffer",
          "new_api": null,
          "old_text": "s->resampler->invert_initial_buffer(s->resample, &s->in_buffer,\n                 &in, in_count, &s->in_buffer_index, &s->in_buffer_count)",
          "new_text": null,
          "old_line_content": "    border = s->resampler->invert_initial_buffer(s->resample, &s->in_buffer,",
          "new_line_content": "    in =  *in_param;",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "buf_set",
          "new_api": null,
          "old_text": "buf_set(&in, &in, border)",
          "new_text": null,
          "old_line_content": "        buf_set(&in, &in, border);",
          "new_line_content": "        return border;",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "buf_set",
          "new_api": null,
          "old_text": "buf_set(&tmp, &s->in_buffer, s->in_buffer_index)",
          "new_text": null,
          "old_line_content": "            buf_set(&tmp, &s->in_buffer, s->in_buffer_index);",
          "new_line_content": "        int ret, size, consumed;",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "multiple_resample",
          "new_api": null,
          "old_text": "s->resampler->multiple_resample(s->resample, &out, out_count, &tmp, s->in_buffer_count, &consumed)",
          "new_text": null,
          "old_line_content": "            ret= s->resampler->multiple_resample(s->resample, &out, out_count, &tmp, s->in_buffer_count, &consumed);",
          "new_line_content": "        if(!s->resample_in_constraint && s->in_buffer_count){",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": "buf_set",
          "new_api": null,
          "old_text": "buf_set(&out, &out, ret)",
          "new_text": null,
          "old_line_content": "            buf_set(&out, &out, ret);",
          "new_line_content": "            out_count -= ret;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 24,
      "total_additions": 124,
      "total_deletions": 124,
      "total_api_changes": 272
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 2,
        "api_related_lines": 272,
        "non_api_lines": 2,
        "non_api_line_numbers": [
          226,
          227
        ]
      }
    },
    "api_calls_before": 222,
    "api_calls_after": 222,
    "diff_info": {
      "added_lines": 2,
      "removed_lines": 0,
      "total_diff_lines": 14
    }
  }
}