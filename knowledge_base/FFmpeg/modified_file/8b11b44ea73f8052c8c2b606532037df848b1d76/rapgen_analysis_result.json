{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/8b11b44ea73f8052c8c2b606532037df848b1d76",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/8b11b44ea73f8052c8c2b606532037df848b1d76/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/8b11b44ea73f8052c8c2b606532037df848b1d76/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/8b11b44ea73f8052c8c2b606532037df848b1d76/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 643,
          "old_api": "ff_imdct_half",
          "new_api": "vector_fmul_window",
          "old_text": "ff_imdct_half(&s->imdct_512, s->tmp_output, s->transform_coeffs[ch])",
          "new_text": "s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128)",
          "old_line_content": "            ff_imdct_half(&s->imdct_512, s->tmp_output, s->transform_coeffs[ch]);",
          "new_line_content": "            s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128);",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": "memset",
          "new_api": "memcpy",
          "old_text": "memset(s->delay[2], 0, channel_data_size)",
          "new_text": "memcpy(s->delay[1], s->delay[0], channel_data_size)",
          "old_line_content": "            memset(s->delay[2], 0, channel_data_size);",
          "new_line_content": "            memcpy(s->delay[1], s->delay[0], channel_data_size);",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "get_bits1",
          "new_api": "av_log",
          "old_text": "get_bits1(gbc)",
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"coupling not allowed in mono or dual-mono\\n\")",
          "old_line_content": "            if (s->eac3 && get_bits1(gbc)) {",
          "new_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"coupling not allowed in mono or dual-mono\\n\");",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": "get_bits",
          "new_api": "get_bits1",
          "old_text": "get_bits(gbc, 4)",
          "new_text": "get_bits1(gbc)",
          "old_line_content": "            cpl_end_subband   = get_bits(gbc, 4) + 3;",
          "new_line_content": "                s->phase_flags_in_use = get_bits1(gbc);",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": "get_bits",
          "new_api": "get_bits1",
          "old_text": "get_bits(gbc, 3)",
          "new_text": "get_bits1(gbc)",
          "old_line_content": "            s->bit_alloc_params.floor  = ff_ac3_floor_tab[get_bits(gbc, 3)];",
          "new_line_content": "        if (get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": "FFMAX",
          "new_api": "get_bits",
          "old_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "new_text": "get_bits(gbc, 2)",
          "old_line_content": "                bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "new_line_content": "            s->bit_alloc_params.fast_decay = ff_ac3_fast_decay_tab[get_bits(gbc, 2)] >> s->bit_alloc_params.sr_shift;",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": "av_log",
          "new_api": "get_bits",
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"new bit allocation info must be present in block 0\\n\")",
          "new_text": "get_bits(gbc, 2)",
          "old_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new bit allocation info must be present in block 0\\n\");",
          "new_line_content": "            s->bit_alloc_params.db_per_bit = ff_ac3_db_per_bit_tab[get_bits(gbc, 2)];",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "get_bits1",
          "new_api": "skip_bits",
          "old_text": "get_bits1(gbc)",
          "new_text": "skip_bits(gbc, 10)",
          "old_line_content": "        if (s->first_cpl_leak || get_bits1(gbc)) {",
          "new_line_content": "        skip_bits(gbc, 10); // skip converter snr offset",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": "FFMAX",
          "new_api": "get_bits",
          "old_text": "FFMAX(bit_alloc_stages[CPL_CH], 2)",
          "new_text": "get_bits(gbc, 3)",
          "old_line_content": "                bit_alloc_stages[CPL_CH] = FFMAX(bit_alloc_stages[CPL_CH], 2);",
          "new_line_content": "            int sl = get_bits(gbc, 3);",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": "av_log",
          "new_api": "FFMAX",
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"new coupling leak info must be present in block 0\\n\")",
          "new_text": "FFMAX(bit_alloc_stages[CPL_CH], 2)",
          "old_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new coupling leak info must be present in block 0\\n\");",
          "new_line_content": "                bit_alloc_stages[CPL_CH] = FFMAX(bit_alloc_stages[CPL_CH], 2);",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": "av_log",
          "new_api": "get_bits1",
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"delta bit allocation strategy reserved\\n\")",
          "new_text": "get_bits1(gbc)",
          "old_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"delta bit allocation strategy reserved\\n\");",
          "new_line_content": "    if (s->dba_syntax && get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1090,
          "old_api": "FFMAX",
          "new_api": "get_bits",
          "old_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "new_text": "get_bits(gbc, 2)",
          "old_line_content": "            bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "new_line_content": "            s->dba_mode[ch] = get_bits(gbc, 2);",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": "get_bits",
          "new_api": "FFMAX",
          "old_text": "get_bits(gbc, 3)",
          "new_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "old_line_content": "                s->dba_nsegs[ch] = get_bits(gbc, 3);",
          "new_line_content": "            bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": "FFMAX",
          "new_api": "get_bits",
          "old_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "new_text": "get_bits(gbc, 5)",
          "old_line_content": "                bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "new_line_content": "                    s->dba_offsets[ch][seg] = get_bits(gbc, 5);",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": "decode_transform_coeffs",
          "new_api": "skip_bits",
          "old_text": "decode_transform_coeffs(s, blk)",
          "new_text": "skip_bits(gbc, 8)",
          "old_line_content": "    decode_transform_coeffs(s, blk);",
          "new_line_content": "            skip_bits(gbc, 8);",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": "parse_frame_header",
          "new_api": "init_get_bits",
          "old_text": "parse_frame_header(s)",
          "new_text": "init_get_bits(&s->gbc, buf, buf_size * 8)",
          "old_line_content": "    err = parse_frame_header(s);",
          "new_line_content": "        init_get_bits(&s->gbc, buf, buf_size * 8);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1025,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 4)",
          "old_line_content": "                s->snr_offset[ch] = snr;",
          "new_line_content": "                    snr = (csnr + get_bits(gbc, 4)) << 2;",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(bit_alloc_stages[ch], 1)",
          "old_line_content": "                if (!s->eac3) {",
          "new_line_content": "                    bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 1);",
          "content_same": false
        },
        {
          "line": 517,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 4)",
          "old_line_content": "                mantissa = (mantissa << (32-quantization_tab[bap]))>>8;",
          "new_line_content": "                mantissa = b5_mantissas[get_bits(gbc, 4)];",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, quantization_tab[bap])",
          "old_line_content": "        coeffs[freq] = mantissa >> exps[freq];",
          "new_line_content": "                mantissa = get_bits(gbc, quantization_tab[bap]);",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 3)",
          "old_line_content": "            }",
          "new_line_content": "                    s->fast_gain[ch] = ff_ac3_fast_gain_tab[get_bits(gbc, 3)];",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "old_line_content": "            return -1;",
          "new_line_content": "                        bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"new snr offsets must be present in block 0\\n\")",
          "old_line_content": "    /* fast gain (E-AC-3 only) */",
          "new_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new snr offsets must be present in block 0\\n\");",
          "content_same": false
        },
        {
          "line": 1048,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "            if(blk && prev != s->fast_gain[ch])",
          "new_line_content": "    if (s->fast_gain_syntax && get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 3)",
          "old_line_content": "    } else if (s->eac3 && !blk) {",
          "new_line_content": "            s->fast_gain[ch] = ff_ac3_fast_gain_tab[get_bits(gbc, 3)];",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "old_line_content": "    }",
          "new_line_content": "                bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    if (cpl_in_use) {",
          "new_line_content": "    if (s->frame_type == EAC3_FRAME_TYPE_INDEPENDENT && get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": null,
          "new_api": "ac3_decode_transform_coeffs_ch",
          "old_text": null,
          "new_text": "ac3_decode_transform_coeffs_ch(s, ch, m)",
          "old_line_content": "        if (!blk && CONFIG_EAC3_DECODER)",
          "new_line_content": "        ac3_decode_transform_coeffs_ch(s, ch, m);",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "            if(blk && (fl != s->bit_alloc_params.cpl_fast_leak ||",
          "new_line_content": "        if (s->first_cpl_leak || get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": null,
          "new_api": "ff_eac3_decode_transform_coeffs_aht_ch",
          "old_text": null,
          "new_text": "ff_eac3_decode_transform_coeffs_aht_ch(s, ch)",
          "old_line_content": "}",
          "new_line_content": "            ff_eac3_decode_transform_coeffs_aht_ch(s, ch);",
          "content_same": false
        },
        {
          "line": 1069,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 3)",
          "old_line_content": "                       sl != s->bit_alloc_params.cpl_slow_leak)) {",
          "new_line_content": "            int fl = get_bits(gbc, 3);",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"new coupling leak info must be present in block 0\\n\")",
          "old_line_content": "",
          "new_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new coupling leak info must be present in block 0\\n\");",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"delta bit allocation strategy reserved\\n\")",
          "old_line_content": "        /* channel delta offset, len and bit allocation */",
          "new_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"delta bit allocation strategy reserved\\n\");",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": null,
          "new_api": "decode_transform_coeffs_ch",
          "old_text": null,
          "new_text": "decode_transform_coeffs_ch(s, blk, CPL_CH, &m)",
          "old_line_content": "        } else {",
          "new_line_content": "                decode_transform_coeffs_ch(s, blk, CPL_CH, &m);",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": null,
          "new_api": "calc_transform_coeffs_cpl",
          "old_text": null,
          "new_text": "calc_transform_coeffs_cpl(s)",
          "old_line_content": "            end = s->end_freq[ch];",
          "new_line_content": "                calc_transform_coeffs_cpl(s);",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 3)",
          "old_line_content": "                }",
          "new_line_content": "                s->dba_nsegs[ch] = get_bits(gbc, 3);",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 4)",
          "old_line_content": "            }",
          "new_line_content": "                    s->dba_lengths[ch][seg] = get_bits(gbc, 4);",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 3)",
          "old_line_content": "        }",
          "new_line_content": "                    s->dba_values[ch][seg] = get_bits(gbc, 3);",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "old_line_content": "            s->dba_mode[ch] = DBA_NONE;",
          "new_line_content": "                bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": null,
          "new_api": "remove_dithering",
          "old_text": null,
          "new_text": "remove_dithering(s)",
          "old_line_content": " * reference: Section 7.5.4 Rematrixing : Decoding Technique",
          "new_line_content": "    remove_dithering(s);",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": null,
          "new_api": "ff_ac3_bit_alloc_calc_psd",
          "old_text": null,
          "new_text": "ff_ac3_bit_alloc_calc_psd(s->dexps[ch],\n                                      s->start_freq[ch], s->end_freq[ch],\n                                      s->psd[ch], s->band_psd[ch])",
          "old_line_content": "            /* Compute excitation function, Compute masking curve, and",
          "new_line_content": "            ff_ac3_bit_alloc_calc_psd(s->dexps[ch],",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(s->end_freq[1], s->end_freq[2])",
          "old_line_content": "            for(i=ff_ac3_rematrix_band_tab[bnd]; i<bndend; i++) {",
          "new_line_content": "    end = FFMIN(s->end_freq[1], s->end_freq[2]);",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(end, ff_ac3_rematrix_band_tab[bnd+1])",
          "old_line_content": "                s->fixed_coeffs[2][i] = tmp0 - tmp1;",
          "new_line_content": "            bndend = FFMIN(end, ff_ac3_rematrix_band_tab[bnd+1]);",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": null,
          "new_api": "ff_ac3_bit_alloc_calc_mask",
          "old_text": null,
          "new_text": "ff_ac3_bit_alloc_calc_mask(&s->bit_alloc_params, s->band_psd[ch],\n                                           s->start_freq[ch], s->end_freq[ch],\n                                           s->fast_gain[ch], (ch == s->lfe_ch),\n                                           s->dba_mode[ch], s->dba_nsegs[ch],\n                                           s->dba_offsets[ch], s->dba_lengths[ch],\n                                           s->dba_values[ch], s->mask[ch])",
          "old_line_content": "                                           s->dba_values[ch], s->mask[ch])) {",
          "new_line_content": "            if (ff_ac3_bit_alloc_calc_mask(&s->bit_alloc_params, s->band_psd[ch],",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"error in bit allocation\\n\")",
          "old_line_content": "            /* Compute bit allocation */",
          "new_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"error in bit allocation\\n\");",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": null,
          "new_api": "ff_ac3_bit_alloc_calc_bap",
          "old_text": null,
          "new_text": "ff_ac3_bit_alloc_calc_bap(s->mask[ch], s->psd[ch],\n                                      s->start_freq[ch], s->end_freq[ch],\n                                      s->snr_offset[ch],\n                                      s->bit_alloc_params.floor,\n                                      bap_tab, s->bap[ch])",
          "old_line_content": "        }",
          "new_line_content": "            ff_ac3_bit_alloc_calc_bap(s->mask[ch], s->psd[ch],",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "",
          "new_line_content": "    if (s->skip_syntax && get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 9)",
          "old_line_content": "    /* unpack the transform coefficients",
          "new_line_content": "        int skipl = get_bits(gbc, 9);",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": null,
          "new_api": "ff_imdct_half",
          "old_text": null,
          "new_text": "ff_imdct_half(&s->imdct_256, s->tmp_output, x)",
          "old_line_content": "        } else {",
          "new_line_content": "            ff_imdct_half(&s->imdct_256, s->tmp_output, x);",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": null,
          "new_api": "ff_imdct_half",
          "old_text": null,
          "new_text": "ff_imdct_half(&s->imdct_256, s->delay[ch-1], x)",
          "old_line_content": "        }",
          "new_line_content": "            ff_imdct_half(&s->imdct_256, s->delay[ch-1], x);",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": null,
          "new_api": "decode_transform_coeffs",
          "old_text": null,
          "new_text": "decode_transform_coeffs(s, blk)",
          "old_line_content": "",
          "new_line_content": "    decode_transform_coeffs(s, blk);",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": null,
          "new_api": "ff_imdct_half",
          "old_text": null,
          "new_text": "ff_imdct_half(&s->imdct_512, s->tmp_output, s->transform_coeffs[ch])",
          "old_line_content": "}",
          "new_line_content": "            ff_imdct_half(&s->imdct_512, s->tmp_output, s->transform_coeffs[ch]);",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": null,
          "new_api": "vector_fmul_window",
          "old_text": null,
          "new_text": "s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128)",
          "old_line_content": "",
          "new_line_content": "            s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128);",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(s->delay[ch-1], s->tmp_output+128, 128*sizeof(float))",
          "old_line_content": "/**",
          "new_line_content": "            memcpy(s->delay[ch-1], s->tmp_output+128, 128*sizeof(float));",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": null,
          "new_api": "do_rematrixing",
          "old_text": null,
          "new_text": "do_rematrixing(s)",
          "old_line_content": "        if(s->channel_mode == AC3_CHMODE_DUALMONO) {",
          "new_line_content": "        do_rematrixing(s);",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "int32_to_float_fmul_scalar",
          "old_text": null,
          "new_text": "s->dsp.int32_to_float_fmul_scalar(s->transform_coeffs[ch], s->fixed_coeffs[ch], gain, 256)",
          "old_line_content": "       and short transforms cannot be mixed. */",
          "new_line_content": "        s->dsp.int32_to_float_fmul_scalar(s->transform_coeffs[ch], s->fixed_coeffs[ch], gain, 256);",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": null,
          "new_api": "ac3_upmix_delay",
          "old_text": null,
          "new_text": "ac3_upmix_delay(s)",
          "old_line_content": "        if(downmix_output) {",
          "new_line_content": "            ac3_upmix_delay(s);",
          "content_same": false
        },
        {
          "line": 1193,
          "old_api": null,
          "new_api": "do_imdct",
          "old_text": null,
          "new_text": "do_imdct(s, s->channels)",
          "old_line_content": "    } else {",
          "new_line_content": "        do_imdct(s, s->channels);",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": null,
          "new_api": "ac3_downmix",
          "old_text": null,
          "new_text": "s->dsp.ac3_downmix(s->output, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256)",
          "old_line_content": "        }",
          "new_line_content": "            s->dsp.ac3_downmix(s->output, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256);",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": null,
          "new_api": "ac3_downmix",
          "old_text": null,
          "new_text": "s->dsp.ac3_downmix(s->delay, s->downmix_coeffs, s->out_channels, s->fbw_channels, 128)",
          "old_line_content": "",
          "new_line_content": "            s->dsp.ac3_downmix(s->delay, s->downmix_coeffs, s->out_channels, s->fbw_channels, 128);",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": null,
          "new_api": "do_imdct",
          "old_text": null,
          "new_text": "do_imdct(s, s->out_channels)",
          "old_line_content": "",
          "new_line_content": "        do_imdct(s, s->out_channels);",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(s->delay[3], 0, channel_data_size)",
          "old_line_content": "    }",
          "new_line_content": "            memset(s->delay[3], 0, channel_data_size);",
          "content_same": false
        },
        {
          "line": 704,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(s->delay[2], s->delay[1], channel_data_size)",
          "old_line_content": "",
          "new_line_content": "            memcpy(s->delay[2], s->delay[1], channel_data_size);",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(s->delay[1], 0, channel_data_size)",
          "old_line_content": "/**",
          "new_line_content": "            memset(s->delay[1], 0, channel_data_size);",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE)",
          "old_line_content": "",
          "new_line_content": "        memcpy(s->input_buffer, buf, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE));",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": null,
          "new_api": "init_get_bits",
          "old_text": null,
          "new_text": "init_get_bits(&s->gbc, s->input_buffer, buf_size * 8)",
          "old_line_content": "    /* parse the syncinfo */",
          "new_line_content": "        init_get_bits(&s->gbc, s->input_buffer, buf_size * 8);",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": null,
          "new_api": "parse_frame_header",
          "old_text": null,
          "new_text": "parse_frame_header(s)",
          "old_line_content": "        err = AAC_AC3_PARSE_ERROR_FRAME_SIZE;",
          "new_line_content": "    err = parse_frame_header(s);",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"incomplete frame\\n\")",
          "old_line_content": "    if(err != AAC_AC3_PARSE_ERROR_FRAME_SIZE && avctx->error_recognition >= FF_ER_CAREFUL) {",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"incomplete frame\\n\");",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": null,
          "new_api": "av_crc_get_table",
          "old_text": null,
          "new_text": "av_crc_get_table(AV_CRC_16_ANSI)",
          "old_line_content": "",
          "new_line_content": "        if(av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, &buf[2], s->frame_size-2)) {",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    } else if (!blk) {",
          "new_line_content": "    if (!eac3 || get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"frame CRC mismatch\\n\")",
          "old_line_content": "    if(err && err != AAC_AC3_PARSE_ERROR_CRC) {",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"frame CRC mismatch\\n\");",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    } else {",
          "new_line_content": "            coded_band_struct[subbnd] = get_bits1(gbc);",
          "content_same": false
        },
        {
          "line": 1259,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"frame sync error\\n\")",
          "old_line_content": "            case AAC_AC3_PARSE_ERROR_SAMPLE_RATE:",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"frame sync error\\n\");",
          "content_same": false
        },
        {
          "line": 1262,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid bitstream id\\n\")",
          "old_line_content": "            case AAC_AC3_PARSE_ERROR_FRAME_SIZE:",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid bitstream id\\n\");",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid sample rate\\n\")",
          "old_line_content": "            case AAC_AC3_PARSE_ERROR_FRAME_TYPE:",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid sample rate\\n\");",
          "content_same": false
        },
        {
          "line": 1268,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid frame size\\n\")",
          "old_line_content": "                if(s->frame_type == EAC3_FRAME_TYPE_DEPENDENT || s->substreamid) {",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid frame size\\n\");",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"unsupported frame type : skipping frame\\n\")",
          "old_line_content": "                break;",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"unsupported frame type : skipping frame\\n\");",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid frame type\\n\")",
          "old_line_content": "                break;",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid frame type\\n\");",
          "content_same": false
        },
        {
          "line": 1281,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid header\\n\")",
          "old_line_content": "    /* if frame is ok, set audio parameters */",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid header\\n\");",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(band_sizes, bnd_sz, n_bands)",
          "old_line_content": " */",
          "new_line_content": "        memcpy(band_sizes, bnd_sz, n_bands);",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(bit_alloc_stages, 0, AC3_MAX_CHANNELS)",
          "old_line_content": "        for (ch = 1; ch <= fbw_channels; ch++) {",
          "new_line_content": "    memset(bit_alloc_stages, 0, AC3_MAX_CHANNELS);",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "",
          "new_line_content": "            s->block_switch[ch] = get_bits1(gbc);",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": null,
          "new_api": "set_downmix_coeffs",
          "old_text": null,
          "new_text": "set_downmix_coeffs(s)",
          "old_line_content": "            s->output_mode  = s->out_channels == 1 ? AC3_CHMODE_MONO : AC3_CHMODE_STEREO;",
          "new_line_content": "            set_downmix_coeffs(s);",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    i = !(s->channel_mode);",
          "new_line_content": "            s->dither_flag[ch] = get_bits1(gbc);",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": null,
          "new_api": "decode_audio_block",
          "old_text": null,
          "new_text": "decode_audio_block(s, blk)",
          "old_line_content": "        out_samples += 256 * s->out_channels;",
          "new_line_content": "        if (!err && decode_audio_block(s, blk)) {",
          "content_same": false
        },
        {
          "line": 1322,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"error decoding the audio block\\n\")",
          "old_line_content": "    }",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"error decoding the audio block\\n\");",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "        }",
          "new_line_content": "        if(get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 8)",
          "old_line_content": "    } while(i--);",
          "new_line_content": "            s->dynamic_range[i] = ((dynamic_range_tab[get_bits(gbc, 8)]-1.0) *",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": null,
          "new_api": "float_to_int16_interleave",
          "old_text": null,
          "new_text": "s->dsp.float_to_int16_interleave(out_samples, output, 256, s->out_channels)",
          "old_line_content": "}",
          "new_line_content": "        s->dsp.float_to_int16_interleave(out_samples, output, 256, s->out_channels);",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "        /* TODO: parse spectral extension strategy info */",
          "new_line_content": "    if (s->eac3 && (!blk || get_bits1(gbc))) {",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    }",
          "new_line_content": "        if (get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "av_log_missing_feature",
          "old_text": null,
          "new_text": "av_log_missing_feature(s->avctx, \"Spectral extension\", 1)",
          "old_line_content": "",
          "new_line_content": "            av_log_missing_feature(s->avctx, \"Spectral extension\", 1);",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": null,
          "new_api": "ff_mdct_end",
          "old_text": null,
          "new_text": "ff_mdct_end(&s->imdct_512)",
          "old_line_content": "    return 0;",
          "new_line_content": "    ff_mdct_end(&s->imdct_512);",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": null,
          "new_api": "ff_mdct_end",
          "old_text": null,
          "new_text": "ff_mdct_end(&s->imdct_256)",
          "old_line_content": "}",
          "new_line_content": "    ff_mdct_end(&s->imdct_256);",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&s->input_buffer)",
          "old_line_content": "AVCodec ac3_decoder = {",
          "new_line_content": "    av_freep(&s->input_buffer);",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "            /* coupling in use */",
          "new_line_content": "    if (s->eac3 ? s->cpl_strategy_exists[blk] : get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS)",
          "old_line_content": "            int cpl_start_subband, cpl_end_subband;",
          "new_line_content": "        memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "            if (channel_mode < AC3_CHMODE_STEREO) {",
          "new_line_content": "            s->cpl_in_use[blk] = get_bits1(gbc);",
          "content_same": false
        },
        {
          "line": 1354,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"ATSC A/52A (AC-3)\")",
          "old_line_content": "    .name = \"eac3\",",
          "new_line_content": "    .long_name = NULL_IF_CONFIG_SMALL(\"ATSC A/52A (AC-3)\"),",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "",
          "new_line_content": "            if (s->eac3 && get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": null,
          "new_api": "av_log_missing_feature",
          "old_text": null,
          "new_text": "av_log_missing_feature(s->avctx, \"Enhanced coupling\", 1)",
          "old_line_content": "            if (s->eac3 && s->channel_mode == AC3_CHMODE_STEREO) {",
          "new_line_content": "                av_log_missing_feature(s->avctx, \"Enhanced coupling\", 1);",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"ATSC A/52B (AC-3, E-AC-3)\")",
          "old_line_content": "",
          "new_line_content": "    .long_name = NULL_IF_CONFIG_SMALL(\"ATSC A/52B (AC-3, E-AC-3)\"),",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 4)",
          "old_line_content": "                return -1;",
          "new_line_content": "            cpl_start_subband = get_bits(gbc, 4);",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 4)",
          "old_line_content": "            }",
          "new_line_content": "            cpl_end_subband   = get_bits(gbc, 4) + 3;",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"invalid coupling range (%d >= %d)\\n\",\n                       cpl_start_subband, cpl_end_subband)",
          "old_line_content": "            s->end_freq[CPL_CH]   = cpl_end_subband   * 12 + 37;",
          "new_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"invalid coupling range (%d >= %d)\\n\",",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": null,
          "new_api": "decode_band_structure",
          "old_text": null,
          "new_text": "decode_band_structure(gbc, blk, s->eac3, 0, cpl_start_subband,\n                                  cpl_end_subband,\n                                  ff_eac3_default_cpl_band_struct,\n                                  &s->num_cpl_bands, s->cpl_band_sizes)",
          "old_line_content": "            /* coupling not in use */",
          "new_line_content": "            decode_band_structure(gbc, blk, s->eac3, 0, cpl_start_subband,",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"new coupling strategy must be present in block 0\\n\")",
          "old_line_content": "    }",
          "new_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new coupling strategy must be present in block 0\\n\");",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "                    for (bnd = 0; bnd < s->num_cpl_bands; bnd++) {",
          "new_line_content": "                if ((s->eac3 && s->first_cpl_coords[ch]) || get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 2)",
          "old_line_content": "                            s->cpl_coords[ch][bnd] = cpl_coord_mant << 22;",
          "new_line_content": "                    master_cpl_coord = 3 * get_bits(gbc, 2);",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 4)",
          "old_line_content": "                            s->cpl_coords[ch][bnd] = (cpl_coord_mant + 16) << 21;",
          "new_line_content": "                        cpl_coord_exp = get_bits(gbc, 4);",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 4)",
          "old_line_content": "                        s->cpl_coords[ch][bnd] >>= (cpl_coord_exp + master_cpl_coord);",
          "new_line_content": "                        cpl_coord_mant = get_bits(gbc, 4);",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"new coupling coordinates must be present in block 0\\n\")",
          "old_line_content": "                s->first_cpl_coords[ch] = 1;",
          "new_line_content": "                    av_log(s->avctx, AV_LOG_ERROR, \"new coupling coordinates must be present in block 0\\n\");",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    /* stereo rematrixing strategy and band structure */",
          "new_line_content": "                s->phase_flags[bnd] = s->phase_flags_in_use? get_bits1(gbc) : 0;",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    }",
          "new_line_content": "                s->rematrixing_flags[bnd] = get_bits1(gbc);",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"new rematrixing strategy must be present in block 0\\n\")",
          "old_line_content": "    /* exponent strategies for each channel */",
          "new_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new rematrixing strategy must be present in block 0\\n\");",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 2 - (ch == s->lfe_ch))",
          "old_line_content": "    /* channel bandwidth */",
          "new_line_content": "            s->exp_strategy[blk][ch] = get_bits(gbc, 2 - (ch == s->lfe_ch));",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 6)",
          "old_line_content": "                s->end_freq[ch] = bandwidth_code * 3 + 73;",
          "new_line_content": "                int bandwidth_code = get_bits(gbc, 6);",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"bandwidth code = %d > 60\\n\", bandwidth_code)",
          "old_line_content": "            group_size = 3 << (s->exp_strategy[blk][ch] - 1);",
          "new_line_content": "                    av_log(s->avctx, AV_LOG_ERROR, \"bandwidth code = %d > 60\\n\", bandwidth_code);",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS)",
          "old_line_content": "                                    (3 << (s->exp_strategy[blk][CPL_CH] - 1));",
          "new_line_content": "                memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": null,
          "new_api": "av_lfg_get",
          "old_text": null,
          "new_text": "av_lfg_get(&s->dith_state)",
          "old_line_content": "                if(m->b1){",
          "new_line_content": "                    mantissa = (av_lfg_get(&s->dith_state) & 0x7FFFFF) - 0x400000;",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 4)",
          "old_line_content": "                return -1;",
          "new_line_content": "            s->dexps[ch][0] = get_bits(gbc, 4) << !ch;",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": null,
          "new_api": "decode_exponents",
          "old_text": null,
          "new_text": "decode_exponents(gbc, s->exp_strategy[blk][ch],\n                                 s->num_exp_groups[ch], s->dexps[ch][0],\n                                 &s->dexps[ch][s->start_freq[ch]+!!ch])",
          "old_line_content": "            }",
          "new_line_content": "            if (decode_exponents(gbc, s->exp_strategy[blk][ch],",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"exponent out-of-range\\n\")",
          "old_line_content": "        }",
          "new_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"exponent out-of-range\\n\");",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 5)",
          "old_line_content": "                }",
          "new_line_content": "                    int bits      = get_bits(gbc, 5);",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": null,
          "new_api": "skip_bits",
          "old_text": null,
          "new_text": "skip_bits(gbc, 2)",
          "old_line_content": "    if (s->bit_allocation_syntax) {",
          "new_line_content": "                skip_bits(gbc, 2); /* skip gainrng */",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 2)",
          "old_line_content": "            for(ch=!cpl_in_use; ch<=s->channels; ch++)",
          "new_line_content": "            s->bit_alloc_params.slow_decay = ff_ac3_slow_decay_tab[get_bits(gbc, 2)] >> s->bit_alloc_params.sr_shift;",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 2)",
          "old_line_content": "        } else if (!blk) {",
          "new_line_content": "            s->bit_alloc_params.slow_gain  = ff_ac3_slow_gain_tab[get_bits(gbc, 2)];",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 7)",
          "old_line_content": "                }",
          "new_line_content": "                    int bits      = get_bits(gbc, 7);",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 3)",
          "old_line_content": "            return -1;",
          "new_line_content": "            s->bit_alloc_params.floor  = ff_ac3_floor_tab[get_bits(gbc, 3)];",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "old_line_content": "    }",
          "new_line_content": "                bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"new bit allocation info must be present in block 0\\n\")",
          "old_line_content": "    /* signal-to-noise ratio offsets and fast gains (signal-to-mask ratios) */",
          "new_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new bit allocation info must be present in block 0\\n\");",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 3)",
          "old_line_content": "                    mantissa = m->b4_mant;",
          "new_line_content": "                mantissa = b3_mantissas[get_bits(gbc, 3)];",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "                /* snr offset */",
          "new_line_content": "        if(s->snr_offset_strategy && get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 6)",
          "old_line_content": "                /* run at least last bit allocation stage if snr offset changes */",
          "new_line_content": "            csnr = (get_bits(gbc, 6) - 15) << 4;",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 7)",
          "old_line_content": "                break;",
          "new_line_content": "                    int bits   = get_bits(gbc, 7);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 512,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 4)",
          "new_text": null,
          "old_line_content": "                mantissa = b5_mantissas[get_bits(gbc, 4)];",
          "new_line_content": "                    m->b4_mant = b4_mantissas[bits][1];",
          "content_same": false
        },
        {
          "line": 515,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, quantization_tab[bap])",
          "new_text": null,
          "old_line_content": "                mantissa = get_bits(gbc, quantization_tab[bap]);",
          "new_line_content": "                break;",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 3)",
          "new_text": null,
          "old_line_content": "                    s->fast_gain[ch] = ff_ac3_fast_gain_tab[get_bits(gbc, 3)];",
          "new_line_content": "                s->snr_offset[ch] = snr;",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "new_text": null,
          "old_line_content": "                        bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "new_line_content": "                if (!s->eac3) {",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"new snr offsets must be present in block 0\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new snr offsets must be present in block 0\\n\");",
          "new_line_content": "                    if(blk && prev != s->fast_gain[ch])",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "    if (s->fast_gain_syntax && get_bits1(gbc)) {",
          "new_line_content": "            return -1;",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 3)",
          "new_text": null,
          "old_line_content": "            s->fast_gain[ch] = ff_ac3_fast_gain_tab[get_bits(gbc, 3)];",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "new_text": null,
          "old_line_content": "                bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "new_line_content": "        for (ch = !cpl_in_use; ch <= s->channels; ch++) {",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "    if (s->frame_type == EAC3_FRAME_TYPE_INDEPENDENT && get_bits1(gbc)) {",
          "new_line_content": "        for (ch = !cpl_in_use; ch <= s->channels; ch++)",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": "ac3_decode_transform_coeffs_ch",
          "new_api": null,
          "old_text": "ac3_decode_transform_coeffs_ch(s, ch, m)",
          "new_text": null,
          "old_line_content": "        ac3_decode_transform_coeffs_ch(s, ch, m);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": "skip_bits",
          "new_api": null,
          "old_text": "skip_bits(gbc, 10)",
          "new_text": null,
          "old_line_content": "        skip_bits(gbc, 10); // skip converter snr offset",
          "new_line_content": "            s->fast_gain[ch] = ff_ac3_fast_gain_tab[4];",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": "ff_eac3_decode_transform_coeffs_aht_ch",
          "new_api": null,
          "old_text": "ff_eac3_decode_transform_coeffs_aht_ch(s, ch)",
          "new_text": null,
          "old_line_content": "            ff_eac3_decode_transform_coeffs_aht_ch(s, ch);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 3)",
          "new_text": null,
          "old_line_content": "            int fl = get_bits(gbc, 3);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 3)",
          "new_text": null,
          "old_line_content": "            int sl = get_bits(gbc, 3);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "    if (s->dba_syntax && get_bits1(gbc)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": "decode_transform_coeffs_ch",
          "new_api": null,
          "old_text": "decode_transform_coeffs_ch(s, blk, ch, &m)",
          "new_text": null,
          "old_line_content": "        decode_transform_coeffs_ch(s, blk, ch, &m);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 2)",
          "new_text": null,
          "old_line_content": "            s->dba_mode[ch] = get_bits(gbc, 2);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "calc_transform_coeffs_cpl",
          "new_api": null,
          "old_text": "calc_transform_coeffs_cpl(s)",
          "new_text": null,
          "old_line_content": "                calc_transform_coeffs_cpl(s);",
          "new_line_content": "        /* tranform coefficients for coupling channel come right after the",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 5)",
          "new_text": null,
          "old_line_content": "                    s->dba_offsets[ch][seg] = get_bits(gbc, 5);",
          "new_line_content": "        /* channel delta offset, len and bit allocation */",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 4)",
          "new_text": null,
          "old_line_content": "                    s->dba_lengths[ch][seg] = get_bits(gbc, 4);",
          "new_line_content": "        for (ch = !cpl_in_use; ch <= fbw_channels; ch++) {",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 3)",
          "new_text": null,
          "old_line_content": "                    s->dba_values[ch][seg] = get_bits(gbc, 3);",
          "new_line_content": "            if (s->dba_mode[ch] == DBA_NEW) {",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": "remove_dithering",
          "new_api": null,
          "old_text": "remove_dithering(s)",
          "new_text": null,
          "old_line_content": "    remove_dithering(s);",
          "new_line_content": "            s->fixed_coeffs[ch][end] = 0;",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": "ff_ac3_bit_alloc_calc_psd",
          "new_api": null,
          "old_text": "ff_ac3_bit_alloc_calc_psd(s->dexps[ch],\n                                      s->start_freq[ch], s->end_freq[ch],\n                                      s->psd[ch], s->band_psd[ch])",
          "new_text": null,
          "old_line_content": "            ff_ac3_bit_alloc_calc_psd(s->dexps[ch],",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(s->end_freq[1], s->end_freq[2])",
          "new_text": null,
          "old_line_content": "    end = FFMIN(s->end_freq[1], s->end_freq[2]);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(end, ff_ac3_rematrix_band_tab[bnd+1])",
          "new_text": null,
          "old_line_content": "            bndend = FFMIN(end, ff_ac3_rematrix_band_tab[bnd+1]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": "ff_ac3_bit_alloc_calc_mask",
          "new_api": null,
          "old_text": "ff_ac3_bit_alloc_calc_mask(&s->bit_alloc_params, s->band_psd[ch],\n                                           s->start_freq[ch], s->end_freq[ch],\n                                           s->fast_gain[ch], (ch == s->lfe_ch),\n                                           s->dba_mode[ch], s->dba_nsegs[ch],\n                                           s->dba_offsets[ch], s->dba_lengths[ch],\n                                           s->dba_values[ch], s->mask[ch])",
          "new_text": null,
          "old_line_content": "            if (ff_ac3_bit_alloc_calc_mask(&s->bit_alloc_params, s->band_psd[ch],",
          "new_line_content": "                                      s->psd[ch], s->band_psd[ch]);",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"error in bit allocation\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"error in bit allocation\\n\");",
          "new_line_content": "                                           s->start_freq[ch], s->end_freq[ch],",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": "ff_ac3_bit_alloc_calc_bap",
          "new_api": null,
          "old_text": "ff_ac3_bit_alloc_calc_bap(s->mask[ch], s->psd[ch],\n                                      s->start_freq[ch], s->end_freq[ch],\n                                      s->snr_offset[ch],\n                                      s->bit_alloc_params.floor,\n                                      bap_tab, s->bap[ch])",
          "new_text": null,
          "old_line_content": "            ff_ac3_bit_alloc_calc_bap(s->mask[ch], s->psd[ch],",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "    if (s->skip_syntax && get_bits1(gbc)) {",
          "new_line_content": "                                      bap_tab, s->bap[ch]);",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 9)",
          "new_text": null,
          "old_line_content": "        int skipl = get_bits(gbc, 9);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": "skip_bits",
          "new_api": null,
          "old_text": "skip_bits(gbc, 8)",
          "new_text": null,
          "old_line_content": "            skip_bits(gbc, 8);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": "ff_imdct_half",
          "new_api": null,
          "old_text": "ff_imdct_half(&s->imdct_256, s->tmp_output, x)",
          "new_text": null,
          "old_line_content": "            ff_imdct_half(&s->imdct_256, s->tmp_output, x);",
          "new_line_content": "        if (s->block_switch[ch]) {",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": "vector_fmul_window",
          "new_api": null,
          "old_text": "s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128)",
          "new_text": null,
          "old_line_content": "            s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128);",
          "new_line_content": "            int i;",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": "ff_imdct_half",
          "new_api": null,
          "old_text": "ff_imdct_half(&s->imdct_256, s->delay[ch-1], x)",
          "new_text": null,
          "old_line_content": "            ff_imdct_half(&s->imdct_256, s->delay[ch-1], x);",
          "new_line_content": "                x[i] = s->transform_coeffs[ch][2*i];",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": "vector_fmul_window",
          "new_api": null,
          "old_text": "s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128)",
          "new_text": null,
          "old_line_content": "            s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128);",
          "new_line_content": "            for(i=0; i<128; i++)",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(s->delay[ch-1], s->tmp_output+128, 128*sizeof(float))",
          "new_text": null,
          "old_line_content": "            memcpy(s->delay[ch-1], s->tmp_output+128, 128*sizeof(float));",
          "new_line_content": "                x[i] = s->transform_coeffs[ch][2*i+1];",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": "do_rematrixing",
          "new_api": null,
          "old_text": "do_rematrixing(s)",
          "new_text": null,
          "old_line_content": "        do_rematrixing(s);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1171,
          "old_api": "int32_to_float_fmul_scalar",
          "new_api": null,
          "old_text": "s->dsp.int32_to_float_fmul_scalar(s->transform_coeffs[ch], s->fixed_coeffs[ch], gain, 256)",
          "new_text": null,
          "old_line_content": "        s->dsp.int32_to_float_fmul_scalar(s->transform_coeffs[ch], s->fixed_coeffs[ch], gain, 256);",
          "new_line_content": "        if(s->channel_mode == AC3_CHMODE_DUALMONO) {",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": "ac3_upmix_delay",
          "new_api": null,
          "old_text": "ac3_upmix_delay(s)",
          "new_text": null,
          "old_line_content": "            ac3_upmix_delay(s);",
          "new_line_content": "    if(different_transforms) {",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": "do_imdct",
          "new_api": null,
          "old_text": "do_imdct(s, s->channels)",
          "new_text": null,
          "old_line_content": "        do_imdct(s, s->channels);",
          "new_line_content": "        if(s->downmixed) {",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "ac3_downmix",
          "new_api": null,
          "old_text": "s->dsp.ac3_downmix(s->output, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256)",
          "new_text": null,
          "old_line_content": "            s->dsp.ac3_downmix(s->output, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": "ac3_downmix",
          "new_api": null,
          "old_text": "s->dsp.ac3_downmix(s->transform_coeffs+1, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256)",
          "new_text": null,
          "old_line_content": "            s->dsp.ac3_downmix(s->transform_coeffs+1, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256);",
          "new_line_content": "        if(downmix_output) {",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(s->delay[1], s->delay[0], channel_data_size)",
          "new_text": null,
          "old_line_content": "            memcpy(s->delay[1], s->delay[0], channel_data_size);",
          "new_line_content": "    int channel_data_size = sizeof(s->delay[0]);",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(s->delay[3], 0, channel_data_size)",
          "new_text": null,
          "old_line_content": "            memset(s->delay[3], 0, channel_data_size);",
          "new_line_content": "        case AC3_CHMODE_STEREO:",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": "do_imdct",
          "new_api": null,
          "old_text": "do_imdct(s, s->out_channels)",
          "new_text": null,
          "old_line_content": "        do_imdct(s, s->out_channels);",
          "new_line_content": "        if(downmix_output && !s->downmixed) {",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(s->delay[2], s->delay[1], channel_data_size)",
          "new_text": null,
          "old_line_content": "            memcpy(s->delay[2], s->delay[1], channel_data_size);",
          "new_line_content": "        case AC3_CHMODE_3F2R:",
          "content_same": false
        },
        {
          "line": 1227,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE)",
          "new_text": null,
          "old_line_content": "        memcpy(s->input_buffer, buf, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": "init_get_bits",
          "new_api": null,
          "old_text": "init_get_bits(&s->gbc, s->input_buffer, buf_size * 8)",
          "new_text": null,
          "old_line_content": "        init_get_bits(&s->gbc, s->input_buffer, buf_size * 8);",
          "new_line_content": "    /* initialize the GetBitContext with the start of valid AC-3 Frame */",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": "init_get_bits",
          "new_api": null,
          "old_text": "init_get_bits(&s->gbc, buf, buf_size * 8)",
          "new_text": null,
          "old_line_content": "        init_get_bits(&s->gbc, buf, buf_size * 8);",
          "new_line_content": "        /* copy input buffer to decoder context to avoid reading past the end",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"incomplete frame\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"incomplete frame\\n\");",
          "new_line_content": "    *data_size = 0;",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "av_crc_get_table",
          "new_api": null,
          "old_text": "av_crc_get_table(AV_CRC_16_ANSI)",
          "new_text": null,
          "old_line_content": "        if(av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, &buf[2], s->frame_size-2)) {",
          "new_line_content": "        err = AAC_AC3_PARSE_ERROR_FRAME_SIZE;",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "    if (!eac3 || get_bits1(gbc)) {",
          "new_line_content": "    const uint8_t *band_struct;",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"frame CRC mismatch\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"frame CRC mismatch\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "            coded_band_struct[subbnd] = get_bits1(gbc);",
          "new_line_content": "    n_subbands = end_subband - start_subband;",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"frame sync error\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"frame sync error\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1257,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid bitstream id\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid bitstream id\\n\");",
          "new_line_content": "        switch(err) {",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid sample rate\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid sample rate\\n\");",
          "new_line_content": "                return -1;",
          "content_same": false
        },
        {
          "line": 1263,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid frame size\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid frame size\\n\");",
          "new_line_content": "                break;",
          "content_same": false
        },
        {
          "line": 1269,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"unsupported frame type : skipping frame\\n\")",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"unsupported frame type : skipping frame\\n\");",
          "new_line_content": "                break;",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid frame type\\n\")",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid frame type\\n\");",
          "new_line_content": "                /* TODO: add support for substreams and dependent frames */",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid header\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid header\\n\");",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(band_sizes, bnd_sz, n_bands)",
          "new_text": null,
          "old_line_content": "        memcpy(band_sizes, bnd_sz, n_bands);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(bit_alloc_stages, 0, AC3_MAX_CHANNELS)",
          "new_text": null,
          "old_line_content": "    memset(bit_alloc_stages, 0, AC3_MAX_CHANNELS);",
          "new_line_content": "    int downmix_output;",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "            s->block_switch[ch] = get_bits1(gbc);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": "set_downmix_coeffs",
          "new_api": null,
          "old_text": "set_downmix_coeffs(s)",
          "new_text": null,
          "old_line_content": "            set_downmix_coeffs(s);",
          "new_line_content": "        avctx->channel_layout = s->channel_layout;",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "            s->dither_flag[ch] = get_bits1(gbc);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": "decode_audio_block",
          "new_api": null,
          "old_text": "decode_audio_block(s, blk)",
          "new_text": null,
          "old_line_content": "        if (!err && decode_audio_block(s, blk)) {",
          "new_line_content": "    /* decode the audio blocks */",
          "content_same": false
        },
        {
          "line": 1317,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"error decoding the audio block\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"error decoding the audio block\\n\");",
          "new_line_content": "    channel_map = ff_ac3_dec_channel_map[s->output_mode & ~AC3_OUTPUT_LFEON][s->lfe_on];",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "        if(get_bits1(gbc)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 8)",
          "new_text": null,
          "old_line_content": "            s->dynamic_range[i] = ((dynamic_range_tab[get_bits(gbc, 8)]-1.0) *",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": "float_to_int16_interleave",
          "new_api": null,
          "old_text": "s->dsp.float_to_int16_interleave(out_samples, output, 256, s->out_channels)",
          "new_text": null,
          "old_line_content": "        s->dsp.float_to_int16_interleave(out_samples, output, 256, s->out_channels);",
          "new_line_content": "    for (blk = 0; blk < s->num_blocks; blk++) {",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "    if (s->eac3 && (!blk || get_bits1(gbc))) {",
          "new_line_content": "            s->dynamic_range[i] = 1.0f;",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "        if (get_bits1(gbc)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "av_log_missing_feature",
          "new_api": null,
          "old_text": "av_log_missing_feature(s->avctx, \"Spectral extension\", 1)",
          "new_text": null,
          "old_line_content": "            av_log_missing_feature(s->avctx, \"Spectral extension\", 1);",
          "new_line_content": "    } while(i--);",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": "ff_mdct_end",
          "new_api": null,
          "old_text": "ff_mdct_end(&s->imdct_512)",
          "new_text": null,
          "old_line_content": "    ff_mdct_end(&s->imdct_512);",
          "new_line_content": " * Uninitialize the AC-3 decoder.",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": "ff_mdct_end",
          "new_api": null,
          "old_text": "ff_mdct_end(&s->imdct_256)",
          "new_text": null,
          "old_line_content": "    ff_mdct_end(&s->imdct_256);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 1336,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&s->input_buffer)",
          "new_text": null,
          "old_line_content": "    av_freep(&s->input_buffer);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "    if (s->eac3 ? s->cpl_strategy_exists[blk] : get_bits1(gbc)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS)",
          "new_text": null,
          "old_line_content": "        memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "            s->cpl_in_use[blk] = get_bits1(gbc);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"coupling not allowed in mono or dual-mono\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"coupling not allowed in mono or dual-mono\\n\");",
          "new_line_content": "        if (s->cpl_in_use[blk]) {",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"ATSC A/52A (AC-3)\")",
          "new_text": null,
          "old_line_content": "    .long_name = NULL_IF_CONFIG_SMALL(\"ATSC A/52A (AC-3)\"),",
          "new_line_content": "    .id = CODEC_ID_AC3,",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "av_log_missing_feature",
          "new_api": null,
          "old_text": "av_log_missing_feature(s->avctx, \"Enhanced coupling\", 1)",
          "new_text": null,
          "old_line_content": "                av_log_missing_feature(s->avctx, \"Enhanced coupling\", 1);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1361,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"ATSC A/52B (AC-3, E-AC-3)\")",
          "new_text": null,
          "old_line_content": "    .long_name = NULL_IF_CONFIG_SMALL(\"ATSC A/52B (AC-3, E-AC-3)\"),",
          "new_line_content": "    .id = CODEC_ID_EAC3,",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "                    s->channel_in_cpl[ch] = get_bits1(gbc);",
          "new_line_content": "            if (s->eac3 && s->channel_mode == AC3_CHMODE_STEREO) {",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 4)",
          "new_text": null,
          "old_line_content": "            cpl_start_subband = get_bits(gbc, 4);",
          "new_line_content": "            if (channel_mode == AC3_CHMODE_STEREO)",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"invalid coupling range (%d >= %d)\\n\",\n                       cpl_start_subband, cpl_end_subband)",
          "new_text": null,
          "old_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"invalid coupling range (%d >= %d)\\n\",",
          "new_line_content": "            /* coupling frequency range */",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": "decode_band_structure",
          "new_api": null,
          "old_text": "decode_band_structure(gbc, blk, s->eac3, 0, cpl_start_subband,\n                                  cpl_end_subband,\n                                  ff_eac3_default_cpl_band_struct,\n                                  &s->num_cpl_bands, s->cpl_band_sizes)",
          "new_text": null,
          "old_line_content": "            decode_band_structure(gbc, blk, s->eac3, 0, cpl_start_subband,",
          "new_line_content": "                return -1;",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"new coupling strategy must be present in block 0\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new coupling strategy must be present in block 0\\n\");",
          "new_line_content": "            s->first_cpl_leak = s->eac3;",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "                if ((s->eac3 && s->first_cpl_coords[ch]) || get_bits1(gbc)) {",
          "new_line_content": "    if (cpl_in_use) {",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 2)",
          "new_text": null,
          "old_line_content": "                    master_cpl_coord = 3 * get_bits(gbc, 2);",
          "new_line_content": "            if (s->channel_in_cpl[ch]) {",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 4)",
          "new_text": null,
          "old_line_content": "                        cpl_coord_exp = get_bits(gbc, 4);",
          "new_line_content": "                    int master_cpl_coord, cpl_coord_exp, cpl_coord_mant;",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 4)",
          "new_text": null,
          "old_line_content": "                        cpl_coord_mant = get_bits(gbc, 4);",
          "new_line_content": "                    s->first_cpl_coords[ch] = 0;",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"new coupling coordinates must be present in block 0\\n\")",
          "new_text": null,
          "old_line_content": "                    av_log(s->avctx, AV_LOG_ERROR, \"new coupling coordinates must be present in block 0\\n\");",
          "new_line_content": "                        else",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "                s->phase_flags[bnd] = s->phase_flags_in_use? get_bits1(gbc) : 0;",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "        if ((s->eac3 && !blk) || get_bits1(gbc)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"new rematrixing strategy must be present in block 0\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new rematrixing strategy must be present in block 0\\n\");",
          "new_line_content": "            if(cpl_in_use && s->start_freq[CPL_CH] <= 61)",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 2 - (ch == s->lfe_ch))",
          "new_text": null,
          "old_line_content": "            s->exp_strategy[blk][ch] = get_bits(gbc, 2 - (ch == s->lfe_ch));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 6)",
          "new_text": null,
          "old_line_content": "                int bandwidth_code = get_bits(gbc, 6);",
          "new_line_content": "            int group_size;",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"bandwidth code = %d > 60\\n\", bandwidth_code)",
          "new_text": null,
          "old_line_content": "                    av_log(s->avctx, AV_LOG_ERROR, \"bandwidth code = %d > 60\\n\", bandwidth_code);",
          "new_line_content": "            if (s->channel_in_cpl[ch])",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS)",
          "new_text": null,
          "old_line_content": "                memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);",
          "new_line_content": "                s->end_freq[ch] = bandwidth_code * 3 + 73;",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "av_lfg_get",
          "new_api": null,
          "old_text": "av_lfg_get(&s->dith_state)",
          "new_text": null,
          "old_line_content": "                    mantissa = (av_lfg_get(&s->dith_state) & 0x7FFFFF) - 0x400000;",
          "new_line_content": "        int bap = baps[freq];",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 4)",
          "new_text": null,
          "old_line_content": "            s->dexps[ch][0] = get_bits(gbc, 4) << !ch;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": "decode_exponents",
          "new_api": null,
          "old_text": "decode_exponents(gbc, s->exp_strategy[blk][ch],\n                                 s->num_exp_groups[ch], s->dexps[ch][0],\n                                 &s->dexps[ch][s->start_freq[ch]+!!ch])",
          "new_text": null,
          "old_line_content": "            if (decode_exponents(gbc, s->exp_strategy[blk][ch],",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"exponent out-of-range\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"exponent out-of-range\\n\");",
          "new_line_content": "        if (s->exp_strategy[blk][ch] != EXP_REUSE) {",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 5)",
          "new_text": null,
          "old_line_content": "                    int bits      = get_bits(gbc, 5);",
          "new_line_content": "                if(m->b1){",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": "skip_bits",
          "new_api": null,
          "old_text": "skip_bits(gbc, 2)",
          "new_text": null,
          "old_line_content": "                skip_bits(gbc, 2); /* skip gainrng */",
          "new_line_content": "                                 &s->dexps[ch][s->start_freq[ch]+!!ch])) {",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "        if (get_bits1(gbc)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 2)",
          "new_text": null,
          "old_line_content": "            s->bit_alloc_params.slow_decay = ff_ac3_slow_decay_tab[get_bits(gbc, 2)] >> s->bit_alloc_params.sr_shift;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 2)",
          "new_text": null,
          "old_line_content": "            s->bit_alloc_params.fast_decay = ff_ac3_fast_decay_tab[get_bits(gbc, 2)] >> s->bit_alloc_params.sr_shift;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 2)",
          "new_text": null,
          "old_line_content": "            s->bit_alloc_params.slow_gain  = ff_ac3_slow_gain_tab[get_bits(gbc, 2)];",
          "new_line_content": "    /* bit allocation information */",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 7)",
          "new_text": null,
          "old_line_content": "                    int bits      = get_bits(gbc, 7);",
          "new_line_content": "                if(m->b2){",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 2)",
          "new_text": null,
          "old_line_content": "            s->bit_alloc_params.db_per_bit = ff_ac3_db_per_bit_tab[get_bits(gbc, 2)];",
          "new_line_content": "    if (s->bit_allocation_syntax) {",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 3)",
          "new_text": null,
          "old_line_content": "                mantissa = b3_mantissas[get_bits(gbc, 3)];",
          "new_line_content": "                    m->b2_mant[0] = b2_mantissas[bits][2];",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "        if(s->snr_offset_strategy && get_bits1(gbc)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 6)",
          "new_text": null,
          "old_line_content": "            csnr = (get_bits(gbc, 6) - 15) << 4;",
          "new_line_content": "    /* signal-to-noise ratio offsets and fast gains (signal-to-mask ratios) */",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 7)",
          "new_text": null,
          "old_line_content": "                    int bits   = get_bits(gbc, 7);",
          "new_line_content": "                if(m->b4){",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 4)",
          "new_text": null,
          "old_line_content": "                    snr = (csnr + get_bits(gbc, 4)) << 2;",
          "new_line_content": "            int csnr;",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(bit_alloc_stages[ch], 1)",
          "new_text": null,
          "old_line_content": "                    bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 1);",
          "new_line_content": "                /* snr offset */",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 16,
      "total_additions": 119,
      "total_deletions": 119,
      "total_api_changes": 254
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 13,
        "api_related_lines": 254,
        "non_api_lines": 13,
        "non_api_line_numbers": [
          419,
          420,
          421,
          422,
          423,
          424,
          425,
          426,
          427,
          428,
          429,
          430,
          434
        ]
      }
    },
    "api_calls_before": 184,
    "api_calls_after": 184,
    "diff_info": {
      "added_lines": 11,
      "removed_lines": 6,
      "total_diff_lines": 34
    }
  }
}