{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/7a15b25827980281a061041ebf83d9a1ed6de9be",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/7a15b25827980281a061041ebf83d9a1ed6de9be/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/7a15b25827980281a061041ebf83d9a1ed6de9be/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/7a15b25827980281a061041ebf83d9a1ed6de9be/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 99,
          "old_api": "bytestream_get_le16",
          "new_api": "av_memcpy_backptr",
          "old_text": "bytestream_get_le16(&srcptr)",
          "new_text": "av_memcpy_backptr(destptr, ofs, cnt)",
          "old_line_content": "            ofs = bytestream_get_le16(&srcptr);",
          "new_line_content": "            av_memcpy_backptr(destptr, ofs, cnt);",
          "content_same": false
        },
        {
          "line": 175,
          "old_api": "get_buffer",
          "new_api": "av_log",
          "old_text": "avctx->get_buffer(avctx, &c->pic)",
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\")",
          "old_line_content": "    if(avctx->get_buffer(avctx, &c->pic) < 0){",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": "AV_RL32",
          "new_api": "FFMIN",
          "old_text": "AV_RL32(encoded)",
          "new_text": "FFMIN(mthread_inlen, len - 8)",
          "old_line_content": "                mthread_inlen = AV_RL32(encoded);",
          "new_line_content": "                mthread_inlen = FFMIN(mthread_inlen, len - 8);",
          "content_same": false
        },
        {
          "line": 189,
          "old_api": "FFMIN",
          "new_api": "AV_RL32",
          "old_text": "FFMIN(mthread_inlen, len - 8)",
          "new_text": "AV_RL32(encoded+4)",
          "old_line_content": "                mthread_inlen = FFMIN(mthread_inlen, len - 8);",
          "new_line_content": "                mthread_outlen = AV_RL32(encoded+4);",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": "AV_RL32",
          "new_api": "FFMIN",
          "old_text": "AV_RL32(encoded+4)",
          "new_text": "FFMIN(mthread_outlen, c->decomp_size)",
          "old_line_content": "                mthread_outlen = AV_RL32(encoded+4);",
          "new_line_content": "                mthread_outlen = FFMIN(mthread_outlen, c->decomp_size);",
          "content_same": false
        },
        {
          "line": 191,
          "old_api": "FFMIN",
          "new_api": "mszh_decomp",
          "old_text": "FFMIN(mthread_outlen, c->decomp_size)",
          "new_text": "mszh_decomp(encoded + 8, mthread_inlen, c->decomp_buf, c->decomp_size)",
          "old_line_content": "                mthread_outlen = FFMIN(mthread_outlen, c->decomp_size);",
          "new_line_content": "                mszh_dlen = mszh_decomp(encoded + 8, mthread_inlen, c->decomp_buf, c->decomp_size);",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": "AV_RL32",
          "new_api": "FFMIN",
          "old_text": "AV_RL32(encoded)",
          "new_text": "FFMIN(mthread_inlen, len - 8)",
          "old_line_content": "            mthread_inlen = AV_RL32(encoded);",
          "new_line_content": "            mthread_inlen = FFMIN(mthread_inlen, len - 8);",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": "FFMIN",
          "new_api": "AV_RL32",
          "old_text": "FFMIN(mthread_inlen, len - 8)",
          "new_text": "AV_RL32(encoded+4)",
          "old_line_content": "            mthread_inlen = FFMIN(mthread_inlen, len - 8);",
          "new_line_content": "            mthread_outlen = AV_RL32(encoded+4);",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": "AV_RL32",
          "new_api": "FFMIN",
          "old_text": "AV_RL32(encoded+4)",
          "new_text": "FFMIN(mthread_outlen, c->decomp_size)",
          "old_line_content": "            mthread_outlen = AV_RL32(encoded+4);",
          "new_line_content": "            mthread_outlen = FFMIN(mthread_outlen, c->decomp_size);",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": "FFMIN",
          "new_api": "zlib_decomp",
          "old_text": "FFMIN(mthread_outlen, c->decomp_size)",
          "new_text": "zlib_decomp(avctx, encoded + 8, mthread_inlen, 0, mthread_outlen)",
          "old_line_content": "            mthread_outlen = FFMIN(mthread_outlen, c->decomp_size);",
          "new_line_content": "            ret = zlib_decomp(avctx, encoded + 8, mthread_inlen, 0, mthread_outlen);",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": "AV_RL16",
          "new_api": "AV_WL16",
          "old_text": "AV_RL16(encoded+pixel_ptr+1)",
          "new_text": "AV_WL16(encoded+pixel_ptr+1, uqvq)",
          "old_line_content": "                    uqvq -= AV_RL16(encoded+pixel_ptr+1);",
          "new_line_content": "                    AV_WL16(encoded+pixel_ptr+1, uqvq);",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": "av_malloc",
          "new_api": "av_log",
          "old_text": "av_malloc(max_decomp_size)",
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Can't allocate decompression buffer.\\n\")",
          "old_line_content": "        if ((c->decomp_buf = av_malloc(max_decomp_size)) == NULL) {",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"Can't allocate decompression buffer.\\n\");",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 132,
          "old_api": null,
          "new_api": "inflate",
          "old_text": null,
          "new_text": "inflate(&c->zstream, Z_FINISH)",
          "old_line_content": "    c->zstream.avail_out = c->decomp_size - offset;",
          "new_line_content": "    zret = inflate(&c->zstream, Z_FINISH);",
          "content_same": false
        },
        {
          "line": 134,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Inflate error: %d\\n\", zret)",
          "old_line_content": "    if (zret != Z_OK && zret != Z_STREAM_END) {",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Inflate error: %d\\n\", zret);",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Compression enabled.\\n\")",
          "old_line_content": "        case COMP_MSZH:",
          "new_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"Compression enabled.\\n\");",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": null,
          "new_api": "AV_RL16",
          "old_text": null,
          "new_text": "AV_RL16(encoded+pixel_ptr)",
          "old_line_content": "                yq = encoded[pixel_ptr++];",
          "new_line_content": "                uqvq = AV_RL16(encoded+pixel_ptr);",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Decoded size differs (%d != %lu)\\n\",\n               expected, c->zstream.total_out)",
          "old_line_content": "    if (expected != (unsigned int)c->zstream.total_out) {",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Decoded size differs (%d != %lu)\\n\",",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"No compression.\\n\")",
          "old_line_content": "            c->decomp_size = 0;",
          "new_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"No compression.\\n\");",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(y_out + col, encoded, 2)",
          "old_line_content": "            for (col = 0; col < width - 1; col += 2) {",
          "new_line_content": "                memcpy(y_out + col, encoded, 2);",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": null,
          "new_api": "AV_RL16",
          "old_text": null,
          "new_text": "AV_RL16(encoded+pixel_ptr+1)",
          "old_line_content": "                    encoded[pixel_ptr] = yq -= encoded[pixel_ptr];",
          "new_line_content": "                    uqvq -= AV_RL16(encoded+pixel_ptr+1);",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Unsupported compression format for MSZH (%d).\\n\", c->compression)",
          "old_line_content": "        default:",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"Unsupported compression format for MSZH (%d).\\n\", c->compression);",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"High speed compression.\\n\")",
          "old_line_content": "        case COMP_ZLIB_HISPEED:",
          "new_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"High speed compression.\\n\");",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"High compression.\\n\")",
          "old_line_content": "        case COMP_ZLIB_HICOMP:",
          "new_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"High compression.\\n\");",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Normal compression.\\n\")",
          "old_line_content": "        case COMP_ZLIB_NORMAL:",
          "new_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"Normal compression.\\n\");",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(y_out + col, encoded, 2)",
          "old_line_content": "            for (col = 0; col < width - 1; col += 2) {",
          "new_line_content": "                memcpy(y_out + col, encoded, 2);",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(y_out + col - c->pic.linesize[0], encoded, 2)",
          "old_line_content": "                encoded += 2;",
          "new_line_content": "                memcpy(y_out + col - c->pic.linesize[0], encoded, 2);",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Unsupported compression level for ZLIB: (%d).\\n\", c->compression)",
          "old_line_content": "            if (c->compression < Z_NO_COMPRESSION || c->compression > Z_BEST_COMPRESSION) {",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"Unsupported compression level for ZLIB: (%d).\\n\", c->compression);",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Compression level for ZLIB: (%d).\\n\", c->compression)",
          "old_line_content": "            }",
          "new_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"Compression level for ZLIB: (%d).\\n\", c->compression);",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown codec in compression switch.\\n\")",
          "old_line_content": "    default:",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown codec in compression switch.\\n\");",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown imagetype in image decoder.\\n\")",
          "old_line_content": "    default:",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown imagetype in image decoder.\\n\");",
          "content_same": false
        },
        {
          "line": 170,
          "old_api": null,
          "new_api": "release_buffer",
          "old_text": null,
          "new_text": "avctx->release_buffer(avctx, &c->pic)",
          "old_line_content": "    if(c->pic.data[0])",
          "new_line_content": "        avctx->release_buffer(avctx, &c->pic);",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(max_decomp_size)",
          "old_line_content": "    if (c->decomp_size) {",
          "new_line_content": "        if ((c->decomp_buf = av_malloc(max_decomp_size)) == NULL) {",
          "content_same": false
        },
        {
          "line": 174,
          "old_api": null,
          "new_api": "get_buffer",
          "old_text": null,
          "new_text": "avctx->get_buffer(avctx, &c->pic)",
          "old_line_content": "    c->pic.buffer_hints = FF_BUFFER_HINTS_VALID;",
          "new_line_content": "    if(avctx->get_buffer(avctx, &c->pic) < 0){",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Multithread encoder flag set.\\n\")",
          "old_line_content": "    if (c->flags & FLAG_MULTITHREAD)",
          "new_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Multithread encoder flag set.\\n\");",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Nullframe insertion flag set.\\n\")",
          "old_line_content": "    if (c->flags & FLAG_NULLFRAME)",
          "new_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Nullframe insertion flag set.\\n\");",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"PNG filter flag set.\\n\")",
          "old_line_content": "    if (avctx->codec_id == CODEC_ID_ZLIB && (c->flags & FLAG_PNGFILTER))",
          "new_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"PNG filter flag set.\\n\");",
          "content_same": false
        },
        {
          "line": 187,
          "old_api": null,
          "new_api": "AV_RL32",
          "old_text": null,
          "new_text": "AV_RL32(encoded)",
          "old_line_content": "            if (c->flags & FLAG_MULTITHREAD) {",
          "new_line_content": "                mthread_inlen = AV_RL32(encoded);",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": null,
          "new_api": "FFALIGN",
          "old_text": null,
          "new_text": "FFALIGN(avctx->height, 4)",
          "old_line_content": "    unsigned int basesize = avctx->width * avctx->height;",
          "new_line_content": "    unsigned int max_basesize = FFALIGN(avctx->width, 4) * FFALIGN(avctx->height, 4) + AV_LZO_OUTPUT_PADDING;",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Unknown flag set (%d).\\n\", c->flags)",
          "old_line_content": "    if (c->flags & FLAGMASK_UNUSED)",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Unknown flag set (%d).\\n\", c->flags);",
          "content_same": false
        },
        {
          "line": 193,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Mthread1 decoded size differs (%d != %d)\\n\",\n                           mthread_outlen, mszh_dlen)",
          "old_line_content": "                if (mthread_outlen != mszh_dlen) {",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"Mthread1 decoded size differs (%d != %d)\\n\",",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(&c->zstream, 0, sizeof(z_stream))",
          "old_line_content": "    // Needed if zlib unused or init aborted before inflateInit",
          "new_line_content": "    memset(&c->zstream, 0, sizeof(z_stream));",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": null,
          "new_api": "mszh_decomp",
          "old_text": null,
          "new_text": "mszh_decomp(encoded + 8 + mthread_inlen, len - 8 - mthread_inlen,\n                                        c->decomp_buf + mthread_outlen, c->decomp_size - mthread_outlen)",
          "old_line_content": "                }",
          "new_line_content": "                mszh_dlen = mszh_decomp(encoded + 8 + mthread_inlen, len - 8 - mthread_inlen,",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": null,
          "new_api": "inflateInit",
          "old_text": null,
          "new_text": "inflateInit(&c->zstream)",
          "old_line_content": "        c->zstream.opaque = Z_NULL;",
          "new_line_content": "        zret = inflateInit(&c->zstream);",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Extradata size too small.\\n\")",
          "old_line_content": "    if (avctx->extradata_size < 8) {",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Extradata size too small.\\n\");",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Mthread2 decoded size differs (%d != %d)\\n\",\n                           mthread_outlen, mszh_dlen)",
          "old_line_content": "                if (mthread_outlen != mszh_dlen) {",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"Mthread2 decoded size differs (%d != %d)\\n\",",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Inflate init error: %d\\n\", zret)",
          "old_line_content": "        if (zret != Z_OK) {",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"Inflate init error: %d\\n\", zret);",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": null,
          "new_api": "avcodec_check_dimensions",
          "old_text": null,
          "new_text": "avcodec_check_dimensions(avctx, avctx->width, avctx->height)",
          "old_line_content": "",
          "new_line_content": "    if (avcodec_check_dimensions(avctx, avctx->width, avctx->height) < 0) {",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": null,
          "new_api": "mszh_decomp",
          "old_text": null,
          "new_text": "mszh_decomp(encoded, len, c->decomp_buf, c->decomp_size)",
          "old_line_content": "            } else {",
          "new_line_content": "                mszh_dlen = mszh_decomp(encoded, len, c->decomp_buf, c->decomp_size);",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown imagetype in pngfilter switch.\\n\")",
          "old_line_content": "        default:",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown imagetype in pngfilter switch.\\n\");",
          "content_same": false
        },
        {
          "line": 209,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Decoded size differs (%d != %d)\\n\",\n                           c->decomp_size, mszh_dlen)",
          "old_line_content": "                if (c->decomp_size != mszh_dlen) {",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"Decoded size differs (%d != %d)\\n\",",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Codec id and codec type mismatch. This should not happen.\\n\")",
          "old_line_content": "        (avctx->codec_id == CODEC_ID_ZLIB  && avctx->extradata[7] != CODEC_ZLIB)) {",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Codec id and codec type mismatch. This should not happen.\\n\");",
          "content_same": false
        },
        {
          "line": 90,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(destptr, srcptr, 4)",
          "old_line_content": "            mask = *srcptr++;",
          "new_line_content": "            memcpy(destptr, srcptr, 4);",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 1:1:1.\\n\")",
          "old_line_content": "        avctx->pix_fmt = PIX_FMT_YUV444P;",
          "new_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 1:1:1.\\n\");",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown MSZH compression in frame decoder.\\n\")",
          "old_line_content": "        default:",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown MSZH compression in frame decoder.\\n\");",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": null,
          "new_api": "release_buffer",
          "old_text": null,
          "new_text": "avctx->release_buffer(avctx, &c->pic)",
          "old_line_content": "    if (c->pic.data[0])",
          "new_line_content": "        avctx->release_buffer(avctx, &c->pic);",
          "content_same": false
        },
        {
          "line": 94,
          "old_api": null,
          "new_api": "bytestream_get_le16",
          "old_text": null,
          "new_text": "bytestream_get_le16(&srcptr)",
          "old_line_content": "        if (!(mask & maskbit)) {",
          "new_line_content": "            ofs = bytestream_get_le16(&srcptr);",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": null,
          "new_api": "inflateEnd",
          "old_text": null,
          "new_text": "inflateEnd(&c->zstream)",
          "old_line_content": "#if CONFIG_ZLIB_DECODER",
          "new_line_content": "    inflateEnd(&c->zstream);",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 4:2:2.\\n\")",
          "old_line_content": "        avctx->pix_fmt = PIX_FMT_YUV422P;",
          "new_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 4:2:2.\\n\");",
          "content_same": false
        },
        {
          "line": 98,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(cnt, destptr_end - destptr)",
          "old_line_content": "        } else {",
          "new_line_content": "            cnt = FFMIN(cnt, destptr_end - destptr);",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Image type is RGB 24.\\n\")",
          "old_line_content": "        avctx->pix_fmt = PIX_FMT_BGR24;",
          "new_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Image type is RGB 24.\\n\");",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(y_out + col, encoded, 4)",
          "old_line_content": "            for (col = 0; col < width - 3; col += 4) {",
          "new_line_content": "                memcpy(y_out + col, encoded, 4);",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": null,
          "new_api": "AV_RL32",
          "old_text": null,
          "new_text": "AV_RL32(encoded)",
          "old_line_content": "            int ret;",
          "new_line_content": "            mthread_inlen = AV_RL32(encoded);",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 4:1:1.\\n\")",
          "old_line_content": "        avctx->pix_fmt = PIX_FMT_YUV411P;",
          "new_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 4:1:1.\\n\");",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Unsupported image format %d.\\n\", c->imgtype)",
          "old_line_content": "    default:",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Unsupported image format %d.\\n\", c->imgtype);",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"LCL (LossLess Codec Library) MSZH\")",
          "old_line_content": "    CODEC_CAP_DR1,",
          "new_line_content": "    .long_name = NULL_IF_CONFIG_SMALL(\"LCL (LossLess Codec Library) MSZH\"),",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": null,
          "new_api": "zlib_decomp",
          "old_text": null,
          "new_text": "zlib_decomp(avctx, encoded + 8 + mthread_inlen, len - 8 - mthread_inlen,\n                              mthread_outlen, mthread_outlen)",
          "old_line_content": "            if (ret < 0) return ret;",
          "new_line_content": "            ret = zlib_decomp(avctx, encoded + 8 + mthread_inlen, len - 8 - mthread_inlen,",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 2:1:1.\\n\")",
          "old_line_content": "        avctx->pix_fmt = PIX_FMT_YUV422P;",
          "new_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 2:1:1.\\n\");",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": null,
          "new_api": "zlib_decomp",
          "old_text": null,
          "new_text": "zlib_decomp(avctx, encoded, len, 0, c->decomp_size)",
          "old_line_content": "        } else {",
          "new_line_content": "            int ret = zlib_decomp(avctx, encoded, len, 0, c->decomp_size);",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown codec in frame decoder compression switch.\\n\")",
          "old_line_content": "    default:",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown codec in frame decoder compression switch.\\n\");",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(outptr + pixel_ptr, encoded, 3 * width)",
          "old_line_content": "            pixel_ptr = row * c->pic.linesize[0];",
          "new_line_content": "            memcpy(outptr + pixel_ptr, encoded, 3 * width);",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 4:2:0.\\n\")",
          "old_line_content": "        avctx->pix_fmt = PIX_FMT_YUV420P;",
          "new_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 4:2:0.\\n\");",
          "content_same": false
        },
        {
          "line": 123,
          "old_api": null,
          "new_api": "inflateReset",
          "old_text": null,
          "new_text": "inflateReset(&c->zstream)",
          "old_line_content": "    LclDecContext *c = avctx->priv_data;",
          "new_line_content": "    int zret = inflateReset(&c->zstream);",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"LCL (LossLess Codec Library) ZLIB\")",
          "old_line_content": "    CODEC_CAP_DR1,",
          "new_line_content": "    .long_name = NULL_IF_CONFIG_SMALL(\"LCL (LossLess Codec Library) ZLIB\"),",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Inflate reset error: %d\\n\", zret)",
          "old_line_content": "    if (zret != Z_OK) {",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Inflate reset error: %d\\n\", zret);",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(y_out + col, encoded, 4)",
          "old_line_content": "            for (col = 0; col < width - 3; col += 4) {",
          "new_line_content": "                memcpy(y_out + col, encoded, 4);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 384,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(y_out + col, encoded, 4)",
          "new_text": null,
          "old_line_content": "                memcpy(y_out + col, encoded, 4);",
          "new_line_content": "                encoded += 4;",
          "content_same": false
        },
        {
          "line": 133,
          "old_api": "inflate",
          "new_api": null,
          "old_text": "inflate(&c->zstream, Z_FINISH)",
          "new_text": null,
          "old_line_content": "    zret = inflate(&c->zstream, Z_FINISH);",
          "new_line_content": "    if (zret != Z_OK && zret != Z_STREAM_END) {",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"LCL (LossLess Codec Library) ZLIB\")",
          "new_text": null,
          "old_line_content": "    .long_name = NULL_IF_CONFIG_SMALL(\"LCL (LossLess Codec Library) ZLIB\"),",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 135,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Inflate error: %d\\n\", zret)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Inflate error: %d\\n\", zret);",
          "new_line_content": "        return -1;",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Compression enabled.\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"Compression enabled.\\n\");",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": "AV_RL16",
          "new_api": null,
          "old_text": "AV_RL16(encoded+pixel_ptr)",
          "new_text": null,
          "old_line_content": "                uqvq = AV_RL16(encoded+pixel_ptr);",
          "new_line_content": "                pixel_ptr += 2;",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Decoded size differs (%d != %lu)\\n\",\n               expected, c->zstream.total_out)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Decoded size differs (%d != %lu)\\n\",",
          "new_line_content": "               expected, c->zstream.total_out);",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"No compression.\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"No compression.\\n\");",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(y_out + col, encoded, 2)",
          "new_text": null,
          "old_line_content": "                memcpy(y_out + col, encoded, 2);",
          "new_line_content": "                encoded += 2;",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Unsupported compression format for MSZH (%d).\\n\", c->compression)",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"Unsupported compression format for MSZH (%d).\\n\", c->compression);",
          "new_line_content": "            return 1;",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "AV_WL16",
          "new_api": null,
          "old_text": "AV_WL16(encoded+pixel_ptr+1, uqvq)",
          "new_text": null,
          "old_line_content": "                    AV_WL16(encoded+pixel_ptr+1, uqvq);",
          "new_line_content": "                    pixel_ptr += 3;",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"High speed compression.\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"High speed compression.\\n\");",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"High compression.\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"High compression.\\n\");",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Normal compression.\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"Normal compression.\\n\");",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(y_out + col, encoded, 2)",
          "new_text": null,
          "old_line_content": "                memcpy(y_out + col, encoded, 2);",
          "new_line_content": "                encoded += 2;",
          "content_same": false
        },
        {
          "line": 414,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(y_out + col - c->pic.linesize[0], encoded, 2)",
          "new_text": null,
          "old_line_content": "                memcpy(y_out + col - c->pic.linesize[0], encoded, 2);",
          "new_line_content": "                encoded += 2;",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Unsupported compression level for ZLIB: (%d).\\n\", c->compression)",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"Unsupported compression level for ZLIB: (%d).\\n\", c->compression);",
          "new_line_content": "                return 1;",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Compression level for ZLIB: (%d).\\n\", c->compression)",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_DEBUG, \"Compression level for ZLIB: (%d).\\n\", c->compression);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown codec in compression switch.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown codec in compression switch.\\n\");",
          "new_line_content": "        return 1;",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown imagetype in image decoder.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown imagetype in image decoder.\\n\");",
          "new_line_content": "        return -1;",
          "content_same": false
        },
        {
          "line": 171,
          "old_api": "release_buffer",
          "new_api": null,
          "old_text": "avctx->release_buffer(avctx, &c->pic)",
          "new_text": null,
          "old_line_content": "        avctx->release_buffer(avctx, &c->pic);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Can't allocate decompression buffer.\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"Can't allocate decompression buffer.\\n\");",
          "new_line_content": "            return 1;",
          "content_same": false
        },
        {
          "line": 176,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "new_line_content": "        return -1;",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Multithread encoder flag set.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Multithread encoder flag set.\\n\");",
          "new_line_content": "    if (c->flags & FLAG_NULLFRAME)",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Nullframe insertion flag set.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Nullframe insertion flag set.\\n\");",
          "new_line_content": "    if (avctx->codec_id == CODEC_ID_ZLIB && (c->flags & FLAG_PNGFILTER))",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"PNG filter flag set.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"PNG filter flag set.\\n\");",
          "new_line_content": "    if (c->flags & FLAGMASK_UNUSED)",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": "FFALIGN",
          "new_api": null,
          "old_text": "FFALIGN(avctx->height, 4)",
          "new_text": null,
          "old_line_content": "    unsigned int max_basesize = FFALIGN(avctx->width, 4) * FFALIGN(avctx->height, 4) + AV_LZO_OUTPUT_PADDING;",
          "new_line_content": "    unsigned int max_decomp_size;",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Unknown flag set (%d).\\n\", c->flags)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Unknown flag set (%d).\\n\", c->flags);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": "mszh_decomp",
          "new_api": null,
          "old_text": "mszh_decomp(encoded + 8, mthread_inlen, c->decomp_buf, c->decomp_size)",
          "new_text": null,
          "old_line_content": "                mszh_dlen = mszh_decomp(encoded + 8, mthread_inlen, c->decomp_buf, c->decomp_size);",
          "new_line_content": "                if (mthread_outlen != mszh_dlen) {",
          "content_same": false
        },
        {
          "line": 194,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Mthread1 decoded size differs (%d != %d)\\n\",\n                           mthread_outlen, mszh_dlen)",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"Mthread1 decoded size differs (%d != %d)\\n\",",
          "new_line_content": "                           mthread_outlen, mszh_dlen);",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(&c->zstream, 0, sizeof(z_stream))",
          "new_text": null,
          "old_line_content": "    memset(&c->zstream, 0, sizeof(z_stream));",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 198,
          "old_api": "mszh_decomp",
          "new_api": null,
          "old_text": "mszh_decomp(encoded + 8 + mthread_inlen, len - 8 - mthread_inlen,\n                                        c->decomp_buf + mthread_outlen, c->decomp_size - mthread_outlen)",
          "new_text": null,
          "old_line_content": "                mszh_dlen = mszh_decomp(encoded + 8 + mthread_inlen, len - 8 - mthread_inlen,",
          "new_line_content": "                                        c->decomp_buf + mthread_outlen, c->decomp_size - mthread_outlen);",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": "inflateInit",
          "new_api": null,
          "old_text": "inflateInit(&c->zstream)",
          "new_text": null,
          "old_line_content": "        zret = inflateInit(&c->zstream);",
          "new_line_content": "        if (zret != Z_OK) {",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Extradata size too small.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Extradata size too small.\\n\");",
          "new_line_content": "        return 1;",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Mthread2 decoded size differs (%d != %d)\\n\",\n                           mthread_outlen, mszh_dlen)",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"Mthread2 decoded size differs (%d != %d)\\n\",",
          "new_line_content": "                           mthread_outlen, mszh_dlen);",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Inflate init error: %d\\n\", zret)",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"Inflate init error: %d\\n\", zret);",
          "new_line_content": "            return 1;",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": "avcodec_check_dimensions",
          "new_api": null,
          "old_text": "avcodec_check_dimensions(avctx, avctx->width, avctx->height)",
          "new_text": null,
          "old_line_content": "    if (avcodec_check_dimensions(avctx, avctx->width, avctx->height) < 0) {",
          "new_line_content": "        return 1;",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": "mszh_decomp",
          "new_api": null,
          "old_text": "mszh_decomp(encoded, len, c->decomp_buf, c->decomp_size)",
          "new_text": null,
          "old_line_content": "                mszh_dlen = mszh_decomp(encoded, len, c->decomp_buf, c->decomp_size);",
          "new_line_content": "                if (c->decomp_size != mszh_dlen) {",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown imagetype in pngfilter switch.\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown imagetype in pngfilter switch.\\n\");",
          "new_line_content": "            return -1;",
          "content_same": false
        },
        {
          "line": 210,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Decoded size differs (%d != %d)\\n\",\n                           c->decomp_size, mszh_dlen)",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"Decoded size differs (%d != %d)\\n\",",
          "new_line_content": "                           c->decomp_size, mszh_dlen);",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Codec id and codec type mismatch. This should not happen.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Codec id and codec type mismatch. This should not happen.\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "release_buffer",
          "new_api": null,
          "old_text": "avctx->release_buffer(avctx, &c->pic)",
          "new_text": null,
          "old_line_content": "        avctx->release_buffer(avctx, &c->pic);",
          "new_line_content": "#if CONFIG_ZLIB_DECODER",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 1:1:1.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 1:1:1.\\n\");",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown MSZH compression in frame decoder.\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown MSZH compression in frame decoder.\\n\");",
          "new_line_content": "            return -1;",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": "inflateEnd",
          "new_api": null,
          "old_text": "inflateEnd(&c->zstream)",
          "new_text": null,
          "old_line_content": "    inflateEnd(&c->zstream);",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 95,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(destptr, srcptr, 4)",
          "new_text": null,
          "old_line_content": "            memcpy(destptr, srcptr, 4);",
          "new_line_content": "            cnt = (ofs >> 11) + 1;",
          "content_same": false
        },
        {
          "line": 253,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown codec in frame decoder compression switch.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"BUG! Unknown codec in frame decoder compression switch.\\n\");",
          "new_line_content": "        return -1;",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 4:2:2.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 4:2:2.\\n\");",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 103,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(cnt, destptr_end - destptr)",
          "new_text": null,
          "old_line_content": "            cnt = FFMIN(cnt, destptr_end - destptr);",
          "new_line_content": "        if (!maskbit) {",
          "content_same": false
        },
        {
          "line": 104,
          "old_api": "av_memcpy_backptr",
          "new_api": null,
          "old_text": "av_memcpy_backptr(destptr, ofs, cnt)",
          "new_text": null,
          "old_line_content": "            av_memcpy_backptr(destptr, ofs, cnt);",
          "new_line_content": "            mask = *srcptr++;",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Image type is RGB 24.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Image type is RGB 24.\\n\");",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 362,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(y_out + col, encoded, 4)",
          "new_text": null,
          "old_line_content": "                memcpy(y_out + col, encoded, 4);",
          "new_line_content": "                encoded += 4;",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 4:1:1.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 4:1:1.\\n\");",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": "zlib_decomp",
          "new_api": null,
          "old_text": "zlib_decomp(avctx, encoded + 8, mthread_inlen, 0, mthread_outlen)",
          "new_text": null,
          "old_line_content": "            ret = zlib_decomp(avctx, encoded + 8, mthread_inlen, 0, mthread_outlen);",
          "new_line_content": "            if (ret < 0) return ret;",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"LCL (LossLess Codec Library) MSZH\")",
          "new_text": null,
          "old_line_content": "    .long_name = NULL_IF_CONFIG_SMALL(\"LCL (LossLess Codec Library) MSZH\"),",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": "zlib_decomp",
          "new_api": null,
          "old_text": "zlib_decomp(avctx, encoded + 8 + mthread_inlen, len - 8 - mthread_inlen,\n                              mthread_outlen, mthread_outlen)",
          "new_text": null,
          "old_line_content": "            ret = zlib_decomp(avctx, encoded + 8 + mthread_inlen, len - 8 - mthread_inlen,",
          "new_line_content": "                              mthread_outlen, mthread_outlen);",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 2:1:1.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 2:1:1.\\n\");",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": "zlib_decomp",
          "new_api": null,
          "old_text": "zlib_decomp(avctx, encoded, len, 0, c->decomp_size)",
          "new_text": null,
          "old_line_content": "            int ret = zlib_decomp(avctx, encoded, len, 0, c->decomp_size);",
          "new_line_content": "            if (ret < 0) return ret;",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(outptr + pixel_ptr, encoded, 3 * width)",
          "new_text": null,
          "old_line_content": "            memcpy(outptr + pixel_ptr, encoded, 3 * width);",
          "new_line_content": "            encoded += 3 * width;",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 4:2:0.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Image type is YUV 4:2:0.\\n\");",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 124,
          "old_api": "inflateReset",
          "new_api": null,
          "old_text": "inflateReset(&c->zstream)",
          "new_text": null,
          "old_line_content": "    int zret = inflateReset(&c->zstream);",
          "new_line_content": "    if (zret != Z_OK) {",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Unsupported image format %d.\\n\", c->imgtype)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Unsupported image format %d.\\n\", c->imgtype);",
          "new_line_content": "        return 1;",
          "content_same": false
        },
        {
          "line": 126,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Inflate reset error: %d\\n\", zret)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Inflate reset error: %d\\n\", zret);",
          "new_line_content": "        return -1;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 12,
      "total_additions": 63,
      "total_deletions": 63,
      "total_api_changes": 138
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 12,
        "api_related_lines": 138,
        "non_api_lines": 9,
        "non_api_line_numbers": [
          105,
          106,
          76,
          84,
          85,
          89,
          91,
          92,
          93
        ]
      }
    },
    "api_calls_before": 76,
    "api_calls_after": 76,
    "diff_info": {
      "added_lines": 7,
      "removed_lines": 8,
      "total_diff_lines": 44
    }
  }
}