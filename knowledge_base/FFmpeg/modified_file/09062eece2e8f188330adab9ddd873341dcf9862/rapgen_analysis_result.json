{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/09062eece2e8f188330adab9ddd873341dcf9862",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/09062eece2e8f188330adab9ddd873341dcf9862/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/09062eece2e8f188330adab9ddd873341dcf9862/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/09062eece2e8f188330adab9ddd873341dcf9862/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 115,
          "old_api": "GET_VLC",
          "new_api": "UPDATE_CACHE",
          "old_text": "GET_VLC(code, bits, gb, vlc[0].table, VLC_BITS, VLC_DEPTH)",
          "new_text": "UPDATE_CACHE(bits, gb)",
          "old_line_content": "        GET_VLC(code, bits, gb, vlc[0].table, VLC_BITS, VLC_DEPTH);",
          "new_line_content": "            UPDATE_CACHE(bits, gb);",
          "content_same": false
        },
        {
          "line": 123,
          "old_api": "UPDATE_CACHE",
          "new_api": "GET_VLC",
          "old_text": "UPDATE_CACHE(bits, gb)",
          "new_text": "GET_VLC(code, bits, gb, vlc[2].table, VLC_BITS, VLC_DEPTH)",
          "old_line_content": "            UPDATE_CACHE(bits, gb);",
          "new_line_content": "            GET_VLC(code, bits, gb, vlc[2].table, VLC_BITS, VLC_DEPTH);",
          "content_same": false
        },
        {
          "line": 130,
          "old_api": "UPDATE_CACHE",
          "new_api": "GET_VLC",
          "old_text": "UPDATE_CACHE(bits, gb)",
          "new_text": "GET_VLC(code, bits, gb, vlc[3].table, VLC_BITS, VLC_DEPTH)",
          "old_line_content": "            UPDATE_CACHE(bits, gb);",
          "new_line_content": "            GET_VLC(code, bits, gb, vlc[3].table, VLC_BITS, VLC_DEPTH);",
          "content_same": false
        },
        {
          "line": 172,
          "old_api": "OPEN_READER",
          "new_api": "GET_VLC",
          "old_text": "OPEN_READER(bits, gb)",
          "new_text": "GET_VLC(code, bits, gb, vlc->table, VLC_BITS, VLC_DEPTH)",
          "old_line_content": "    OPEN_READER(bits, gb);",
          "new_line_content": "        GET_VLC(code, bits, gb, vlc->table, VLC_BITS, VLC_DEPTH);",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": "UPDATE_CACHE",
          "new_api": "CLOSE_READER",
          "old_text": "UPDATE_CACHE(bits, gb)",
          "new_text": "CLOSE_READER(bits, gb)",
          "old_line_content": "        UPDATE_CACHE(bits, gb);",
          "new_line_content": "    CLOSE_READER(bits, gb);",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": "av_log",
          "new_api": "read_argb_line",
          "old_text": "av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Could not read code table %d.\\n\", i)",
          "new_text": "read_argb_line(ctx, gb, pred, vlc, dst)",
          "old_line_content": "            av_log(ctx->avctx, AV_LOG_ERROR,",
          "new_line_content": "        read_argb_line(ctx, gb, pred, vlc, dst);",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": "get_bits",
          "new_api": "read_code_table",
          "old_text": "get_bits(gb, 8)",
          "new_text": "read_code_table(ctx, gb, &vlc[i])",
          "old_line_content": "    block = get_bits(gb, 8);",
          "new_line_content": "        ret = read_code_table(ctx, gb, &vlc[i]);",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": "av_log",
          "new_api": "read_yuv_component_line",
          "old_text": "av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Could not read code table %d.\\n\", i)",
          "new_text": "read_yuv_component_line(ctx, gb, &pred[0], &vlc[0], dst[0], 0)",
          "old_line_content": "            av_log(ctx->avctx, AV_LOG_ERROR,",
          "new_line_content": "        read_yuv_component_line(ctx, gb, &pred[0], &vlc[0], dst[0], 0); /* Y */",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": "read_yuv_component_line",
          "new_api": "ff_free_vlc",
          "old_text": "read_yuv_component_line(ctx, gb, &pred[1], &vlc[1], dst[1], 1)",
          "new_text": "ff_free_vlc(&vlc[i])",
          "old_line_content": "        read_yuv_component_line(ctx, gb, &pred[1], &vlc[1], dst[1], 1); /* U */",
          "new_line_content": "        ff_free_vlc(&vlc[i]);",
          "content_same": false
        },
        {
          "line": 385,
          "old_api": "MKTAG",
          "new_api": "ff_canopus_parse_info_tag",
          "old_text": "MKTAG('I', 'N', 'F', 'O')",
          "new_text": "ff_canopus_parse_info_tag(avctx, src + 8, info_offset)",
          "old_line_content": "    if (info_tag == MKTAG('I', 'N', 'F', 'O')) {",
          "new_line_content": "        ff_canopus_parse_info_tag(avctx, src + 8, info_offset);",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": "av_fast_padded_malloc",
          "new_api": "bswap16_buf",
          "old_text": "av_fast_padded_malloc(&ctx->swapped_buf,\n                          &ctx->swapped_buf_size, data_size)",
          "new_text": "ctx->bdsp.bswap16_buf((uint16_t *) ctx->swapped_buf, (uint16_t *) src,\n                          data_size / 2)",
          "old_line_content": "    av_fast_padded_malloc(&ctx->swapped_buf,",
          "new_line_content": "    ctx->bdsp.bswap16_buf((uint16_t *) ctx->swapped_buf, (uint16_t *) src,",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": "av_log",
          "new_api": "init_get_bits8",
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Could not allocate swapped buffer.\\n\")",
          "new_text": "init_get_bits8(&gb, ctx->swapped_buf, data_size)",
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Could not allocate swapped buffer.\\n\");",
          "new_line_content": "    if ((ret = init_get_bits8(&gb, ctx->swapped_buf, data_size)) < 0)",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": "get_bits_left",
          "new_api": "ff_thread_get_buffer",
          "old_text": "get_bits_left(&gb)",
          "new_text": "ff_thread_get_buffer(avctx, &frame, 0)",
          "old_line_content": "    if(get_bits_left(&gb) < avctx->height * avctx->width)",
          "new_line_content": "        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 129,
          "old_api": null,
          "new_api": "UPDATE_CACHE",
          "old_text": null,
          "new_text": "UPDATE_CACHE(bits, gb)",
          "old_line_content": "            /* Green */",
          "new_line_content": "            UPDATE_CACHE(bits, gb);",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": null,
          "new_api": "av_fast_padded_malloc",
          "old_text": null,
          "new_text": "av_fast_padded_malloc(&ctx->swapped_buf,\n                          &ctx->swapped_buf_size, data_size)",
          "old_line_content": "",
          "new_line_content": "    av_fast_padded_malloc(&ctx->swapped_buf,",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Could not allocate swapped buffer.\\n\")",
          "old_line_content": "    }",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Could not allocate swapped buffer.\\n\");",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 143,
          "old_api": null,
          "new_api": "CLOSE_READER",
          "old_text": null,
          "new_text": "CLOSE_READER(bits, gb)",
          "old_line_content": "            dst[1] = 0;",
          "new_line_content": "    CLOSE_READER(bits, gb);",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": null,
          "new_api": "skip_bits",
          "old_text": null,
          "new_text": "skip_bits(gb, 16)",
          "old_line_content": "    VLC vlc[3];",
          "new_line_content": "    skip_bits(gb, 16);",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": null,
          "new_api": "read_code_table",
          "old_text": null,
          "new_text": "read_code_table(ctx, gb, &vlc[i])",
          "old_line_content": "    pred[2] = 0x80;",
          "new_line_content": "        ret = read_code_table(ctx, gb, &vlc[i]);",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": null,
          "new_api": "ff_free_vlc",
          "old_text": null,
          "new_text": "ff_free_vlc(&vlc[j])",
          "old_line_content": "",
          "new_line_content": "                ff_free_vlc(&vlc[j]);",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Could not read code table %d.\\n\", i)",
          "old_line_content": "",
          "new_line_content": "            av_log(ctx->avctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": null,
          "new_api": "AV_RL32",
          "old_text": null,
          "new_text": "AV_RL32(src)",
          "old_line_content": "    /*",
          "new_line_content": "    coding_type = (AV_RL32(src) >> 8) & 0xFF;",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Frame coding type: %d\\n\", coding_type)",
          "old_line_content": "     * Read in coding type. The types are as follows:",
          "new_line_content": "    av_log(avctx, AV_LOG_DEBUG, \"Frame coding type: %d\\n\", coding_type);",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": null,
          "new_api": "get_bits_left",
          "old_text": null,
          "new_text": "get_bits_left(&gb)",
          "old_line_content": "     * 0 - YUY2",
          "new_line_content": "    if(get_bits_left(&gb) < avctx->height * avctx->width)",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": null,
          "new_api": "OPEN_READER",
          "old_text": null,
          "new_text": "OPEN_READER(bits, gb)",
          "old_line_content": "",
          "new_line_content": "    OPEN_READER(bits, gb);",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": null,
          "new_api": "read_rgb24_component_line",
          "old_text": null,
          "new_text": "read_rgb24_component_line(ctx, gb, &pred[j], &vlc[j], &dst[j])",
          "old_line_content": "                   \"Could not read code table %d.\\n\", i);",
          "new_line_content": "            read_rgb24_component_line(ctx, gb, &pred[j], &vlc[j], &dst[j]);",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": null,
          "new_api": "ff_free_vlc",
          "old_text": null,
          "new_text": "ff_free_vlc(&vlc[i])",
          "old_line_content": "    for (i = 0; i < avctx->height; i++) {",
          "new_line_content": "        ff_free_vlc(&vlc[i]);",
          "content_same": false
        },
        {
          "line": 171,
          "old_api": null,
          "new_api": "UPDATE_CACHE",
          "old_text": null,
          "new_text": "UPDATE_CACHE(bits, gb)",
          "old_line_content": "",
          "new_line_content": "        UPDATE_CACHE(bits, gb);",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": null,
          "new_api": "decode_yuv_frame",
          "old_text": null,
          "new_text": "decode_yuv_frame(ctx, &gb, pic)",
          "old_line_content": "    switch (coding_type) {",
          "new_line_content": "        ret = decode_yuv_frame(ctx, &gb, pic);",
          "content_same": false
        },
        {
          "line": 55,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gb, 5)",
          "old_line_content": "    num_codes_sum = 0;",
          "new_line_content": "    num_lens = get_bits(gb, 5);",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": null,
          "new_api": "ff_thread_get_buffer",
          "old_text": null,
          "new_text": "ff_thread_get_buffer(avctx, &frame, 0)",
          "old_line_content": "            return ret;",
          "new_line_content": "        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)",
          "content_same": false
        },
        {
          "line": 58,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(ctx->avctx, AV_LOG_ERROR, \"To long VLCs %d\\n\", num_lens)",
          "old_line_content": "",
          "new_line_content": "        av_log(ctx->avctx, AV_LOG_ERROR, \"To long VLCs %d\\n\", num_lens);",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": null,
          "new_api": "decode_rgb24_frame",
          "old_text": null,
          "new_text": "decode_rgb24_frame(ctx, &gb, pic)",
          "old_line_content": "    case 1:",
          "new_line_content": "        ret = decode_rgb24_frame(ctx, &gb, pic);",
          "content_same": false
        },
        {
          "line": 63,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gb, 9)",
          "old_line_content": "",
          "new_line_content": "        num_codes      = get_bits(gb, 9);",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": null,
          "new_api": "skip_bits",
          "old_text": null,
          "new_text": "skip_bits(gb, 8)",
          "old_line_content": "    pred[0] = 0x80;",
          "new_line_content": "    skip_bits(gb, 8);",
          "content_same": false
        },
        {
          "line": 194,
          "old_api": null,
          "new_api": "OPEN_READER",
          "old_text": null,
          "new_text": "OPEN_READER(bits, gb)",
          "old_line_content": "",
          "new_line_content": "    OPEN_READER(bits, gb);",
          "content_same": false
        },
        {
          "line": 67,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Too many VLCs (%d) to be read.\\n\", num_codes_sum)",
          "old_line_content": "",
          "new_line_content": "            av_log(ctx->avctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gb, 8)",
          "old_line_content": "    pred[2] = 0x80;",
          "new_line_content": "    block = get_bits(gb, 8);",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": null,
          "new_api": "avpriv_request_sample",
          "old_text": null,
          "new_text": "avpriv_request_sample(ctx->avctx, \"Blocked YUV\")",
          "old_line_content": "    dst[0] = pic->data[0];",
          "new_line_content": "        avpriv_request_sample(ctx->avctx, \"Blocked YUV\");",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": null,
          "new_api": "ff_thread_get_buffer",
          "old_text": null,
          "new_text": "ff_thread_get_buffer(avctx, &frame, 0)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": null,
          "new_api": "decode_argb_frame",
          "old_text": null,
          "new_text": "decode_argb_frame(ctx, &gb, pic)",
          "old_line_content": "        break;",
          "new_line_content": "        ret = decode_argb_frame(ctx, &gb, pic);",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": null,
          "new_api": "UPDATE_CACHE",
          "old_text": null,
          "new_text": "UPDATE_CACHE(bits, gb)",
          "old_line_content": "    int i;",
          "new_line_content": "        UPDATE_CACHE(bits, gb);",
          "content_same": false
        },
        {
          "line": 73,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gb, 8)",
          "old_line_content": "",
          "new_line_content": "            symbols[count] = get_bits(gb, 8);",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": null,
          "new_api": "GET_VLC",
          "old_text": null,
          "new_text": "GET_VLC(code, bits, gb, vlc->table, VLC_BITS, VLC_DEPTH)",
          "old_line_content": "",
          "new_line_content": "        GET_VLC(code, bits, gb, vlc->table, VLC_BITS, VLC_DEPTH);",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Unknown coding type: %d.\\n\", coding_type)",
          "old_line_content": "            return ret;",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Unknown coding type: %d.\\n\", coding_type);",
          "content_same": false
        },
        {
          "line": 334,
          "old_api": null,
          "new_api": "ff_free_vlc",
          "old_text": null,
          "new_text": "ff_free_vlc(&vlc[j])",
          "old_line_content": "        return AVERROR_PATCHWELCOME;",
          "new_line_content": "                ff_free_vlc(&vlc[j]);",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": null,
          "new_api": "CLOSE_READER",
          "old_text": null,
          "new_text": "CLOSE_READER(bits, gb)",
          "old_line_content": "    for (i = 0; i < ctx->avctx->width >> is_chroma; i++) {",
          "new_line_content": "    CLOSE_READER(bits, gb);",
          "content_same": false
        },
        {
          "line": 80,
          "old_api": null,
          "new_api": "ff_init_vlc_from_lengths",
          "old_text": null,
          "new_text": "ff_init_vlc_from_lengths(vlc, VLC_BITS, count, bits, 1,\n                                    symbols, 1, 1, 0, 0, ctx->avctx)",
          "old_line_content": "        }",
          "new_line_content": "    return ff_init_vlc_from_lengths(vlc, VLC_BITS, count, bits, 1,",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Could not read code table %d.\\n\", i)",
          "old_line_content": "",
          "new_line_content": "            av_log(ctx->avctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": null,
          "new_api": "read_yuv_component_line",
          "old_text": null,
          "new_text": "read_yuv_component_line(ctx, gb, &pred[1], &vlc[1], dst[1], 1)",
          "old_line_content": "                   \"Could not read code table %d.\\n\", i);",
          "new_line_content": "        read_yuv_component_line(ctx, gb, &pred[1], &vlc[1], dst[1], 1); /* U */",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": null,
          "new_api": "read_yuv_component_line",
          "old_text": null,
          "new_text": "read_yuv_component_line(ctx, gb, &pred[2], &vlc[1], dst[2], 1)",
          "old_line_content": "            return ret;",
          "new_line_content": "        read_yuv_component_line(ctx, gb, &pred[2], &vlc[1], dst[2], 1); /* V */",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&ctx->swapped_buf)",
          "old_line_content": "",
          "new_line_content": "    av_freep(&ctx->swapped_buf);",
          "content_same": false
        },
        {
          "line": 96,
          "old_api": null,
          "new_api": "OPEN_READER",
          "old_text": null,
          "new_text": "OPEN_READER(bits, gb)",
          "old_line_content": "static int read_argb_line(CLLCContext *ctx, GetBitContext *gb, int *top_left,",
          "new_line_content": "    OPEN_READER(bits, gb);",
          "content_same": false
        },
        {
          "line": 122,
          "old_api": null,
          "new_api": "UPDATE_CACHE",
          "old_text": null,
          "new_text": "UPDATE_CACHE(bits, gb)",
          "old_line_content": "            /* Red */",
          "new_line_content": "            UPDATE_CACHE(bits, gb);",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": null,
          "new_api": "skip_bits",
          "old_text": null,
          "new_text": "skip_bits(gb, 16)",
          "old_line_content": "",
          "new_line_content": "    skip_bits(gb, 16);",
          "content_same": false
        },
        {
          "line": 106,
          "old_api": null,
          "new_api": "UPDATE_CACHE",
          "old_text": null,
          "new_text": "UPDATE_CACHE(bits, gb)",
          "old_line_content": "    dst     = outbuf;",
          "new_line_content": "        UPDATE_CACHE(bits, gb);",
          "content_same": false
        },
        {
          "line": 107,
          "old_api": null,
          "new_api": "GET_VLC",
          "old_text": null,
          "new_text": "GET_VLC(code, bits, gb, vlc[0].table, VLC_BITS, VLC_DEPTH)",
          "old_line_content": "    pred[0] = top_left[0];",
          "new_line_content": "        GET_VLC(code, bits, gb, vlc[0].table, VLC_BITS, VLC_DEPTH);",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": null,
          "new_api": "read_code_table",
          "old_text": null,
          "new_text": "read_code_table(ctx, gb, &vlc[i])",
          "old_line_content": "    pred[3] = 0x80;",
          "new_line_content": "        ret = read_code_table(ctx, gb, &vlc[i]);",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": null,
          "new_api": "ff_bswapdsp_init",
          "old_text": null,
          "new_text": "ff_bswapdsp_init(&ctx->bdsp)",
          "old_line_content": "{",
          "new_line_content": "    ff_bswapdsp_init(&ctx->bdsp);",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": null,
          "new_api": "ff_free_vlc",
          "old_text": null,
          "new_text": "ff_free_vlc(&vlc[j])",
          "old_line_content": "",
          "new_line_content": "                ff_free_vlc(&vlc[j]);",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Could not read code table %d.\\n\", i)",
          "old_line_content": "",
          "new_line_content": "            av_log(ctx->avctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"Canopus Lossless Codec\")",
          "old_line_content": "",
          "new_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"Canopus Lossless Codec\"),",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Frame is too small %d.\\n\", avpkt->size)",
          "old_line_content": "    ThreadFrame frame = { .f = data };",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Frame is too small %d.\\n\", avpkt->size);",
          "content_same": false
        },
        {
          "line": 116,
          "old_api": null,
          "new_api": "GET_VLC",
          "old_text": null,
          "new_text": "GET_VLC(code, bits, gb, vlc[1].table, VLC_BITS, VLC_DEPTH)",
          "old_line_content": "",
          "new_line_content": "            GET_VLC(code, bits, gb, vlc[1].table, VLC_BITS, VLC_DEPTH);",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": null,
          "new_api": "AV_RL32",
          "old_text": null,
          "new_text": "AV_RL32(src)",
          "old_line_content": "    int coding_type, ret;",
          "new_line_content": "    info_tag    = AV_RL32(src);",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('I', 'N', 'F', 'O')",
          "old_line_content": "",
          "new_line_content": "    if (info_tag == MKTAG('I', 'N', 'F', 'O')) {",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": null,
          "new_api": "AV_RL32",
          "old_text": null,
          "new_text": "AV_RL32(src + 4)",
          "old_line_content": "    if (avpkt->size < 4 + 4) {",
          "new_line_content": "        info_offset = AV_RL32(src + 4);",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR,\n                   \"Invalid INFO header offset: 0x%08\"PRIX32\" is too large.\\n\",\n                   info_offset)",
          "old_line_content": "        return AVERROR_INVALIDDATA;",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": null,
          "new_api": "ff_free_vlc",
          "old_text": null,
          "new_text": "ff_free_vlc(&vlc[i])",
          "old_line_content": "    /* Read in and restore every line */",
          "new_line_content": "        ff_free_vlc(&vlc[i]);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 256,
          "old_api": "read_argb_line",
          "new_api": null,
          "old_text": "read_argb_line(ctx, gb, pred, vlc, dst)",
          "new_text": null,
          "old_line_content": "        read_argb_line(ctx, gb, pred, vlc, dst);",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": "AV_RL32",
          "new_api": null,
          "old_text": "AV_RL32(src)",
          "new_text": null,
          "old_line_content": "    info_tag    = AV_RL32(src);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 386,
          "old_api": "AV_RL32",
          "new_api": null,
          "old_text": "AV_RL32(src + 4)",
          "new_text": null,
          "old_line_content": "        info_offset = AV_RL32(src + 4);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 131,
          "old_api": "GET_VLC",
          "new_api": null,
          "old_text": "GET_VLC(code, bits, gb, vlc[2].table, VLC_BITS, VLC_DEPTH)",
          "new_text": null,
          "old_line_content": "            GET_VLC(code, bits, gb, vlc[2].table, VLC_BITS, VLC_DEPTH);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 388,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR,\n                   \"Invalid INFO header offset: 0x%08\"PRIX32\" is too large.\\n\",\n                   info_offset)",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR,",
          "new_line_content": "        src         += info_offset;",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": "ff_free_vlc",
          "new_api": null,
          "old_text": "ff_free_vlc(&vlc[i])",
          "new_text": null,
          "old_line_content": "        ff_free_vlc(&vlc[i]);",
          "new_line_content": "    uint8_t *dst;",
          "content_same": false
        },
        {
          "line": 137,
          "old_api": "UPDATE_CACHE",
          "new_api": null,
          "old_text": "UPDATE_CACHE(bits, gb)",
          "new_text": null,
          "old_line_content": "            UPDATE_CACHE(bits, gb);",
          "new_line_content": "            dst[3] = 0;",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": "GET_VLC",
          "new_api": null,
          "old_text": "GET_VLC(code, bits, gb, vlc[3].table, VLC_BITS, VLC_DEPTH)",
          "new_text": null,
          "old_line_content": "            GET_VLC(code, bits, gb, vlc[3].table, VLC_BITS, VLC_DEPTH);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": "ff_canopus_parse_info_tag",
          "new_api": null,
          "old_text": "ff_canopus_parse_info_tag(avctx, src + 8, info_offset)",
          "new_text": null,
          "old_line_content": "        ff_canopus_parse_info_tag(avctx, src + 8, info_offset);",
          "new_line_content": "    /* Make sure our bswap16'd buffer is big enough */",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 151,
          "old_api": "CLOSE_READER",
          "new_api": null,
          "old_text": "CLOSE_READER(bits, gb)",
          "new_text": null,
          "old_line_content": "    CLOSE_READER(bits, gb);",
          "new_line_content": "        top_left[3] = outbuf[3];",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "bswap16_buf",
          "new_api": null,
          "old_text": "ctx->bdsp.bswap16_buf((uint16_t *) ctx->swapped_buf, (uint16_t *) src,\n                          data_size / 2)",
          "new_text": null,
          "old_line_content": "    ctx->bdsp.bswap16_buf((uint16_t *) ctx->swapped_buf, (uint16_t *) src,",
          "new_line_content": "     *",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": "skip_bits",
          "new_api": null,
          "old_text": "skip_bits(gb, 16)",
          "new_text": null,
          "old_line_content": "    skip_bits(gb, 16);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "init_get_bits8",
          "new_api": null,
          "old_text": "init_get_bits8(&gb, ctx->swapped_buf, data_size)",
          "new_text": null,
          "old_line_content": "    if ((ret = init_get_bits8(&gb, ctx->swapped_buf, data_size)) < 0)",
          "new_line_content": "     * 2 - BGR24 (Quads)",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": "read_code_table",
          "new_api": null,
          "old_text": "read_code_table(ctx, gb, &vlc[i])",
          "new_text": null,
          "old_line_content": "        ret = read_code_table(ctx, gb, &vlc[i]);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "ff_free_vlc",
          "new_api": null,
          "old_text": "ff_free_vlc(&vlc[j])",
          "new_text": null,
          "old_line_content": "                ff_free_vlc(&vlc[j]);",
          "new_line_content": "    /* Read in and restore every line */",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Could not read code table %d.\\n\", i)",
          "new_text": null,
          "old_line_content": "            av_log(ctx->avctx, AV_LOG_ERROR,",
          "new_line_content": "        for (j = 0; j < 3; j++)",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": "AV_RL32",
          "new_api": null,
          "old_text": "AV_RL32(src)",
          "new_text": null,
          "old_line_content": "    coding_type = (AV_RL32(src) >> 8) & 0xFF;",
          "new_line_content": "        avctx->pix_fmt             = AV_PIX_FMT_YUV422P;",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Frame coding type: %d\\n\", coding_type)",
          "new_text": null,
          "old_line_content": "    av_log(avctx, AV_LOG_DEBUG, \"Frame coding type: %d\\n\", coding_type);",
          "new_line_content": "        avctx->bits_per_raw_sample = 8;",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": "read_rgb24_component_line",
          "new_api": null,
          "old_text": "read_rgb24_component_line(ctx, gb, &pred[j], &vlc[j], &dst[j])",
          "new_text": null,
          "old_line_content": "            read_rgb24_component_line(ctx, gb, &pred[j], &vlc[j], &dst[j]);",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": "ff_free_vlc",
          "new_api": null,
          "old_text": "ff_free_vlc(&vlc[i])",
          "new_text": null,
          "old_line_content": "        ff_free_vlc(&vlc[i]);",
          "new_line_content": "    uint8_t block;",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": "ff_thread_get_buffer",
          "new_api": null,
          "old_text": "ff_thread_get_buffer(avctx, &frame, 0)",
          "new_text": null,
          "old_line_content": "        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)",
          "new_line_content": "    case 1:",
          "content_same": false
        },
        {
          "line": 180,
          "old_api": "GET_VLC",
          "new_api": null,
          "old_text": "GET_VLC(code, bits, gb, vlc->table, VLC_BITS, VLC_DEPTH)",
          "new_text": null,
          "old_line_content": "        GET_VLC(code, bits, gb, vlc->table, VLC_BITS, VLC_DEPTH);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 438,
          "old_api": "decode_yuv_frame",
          "new_api": null,
          "old_text": "decode_yuv_frame(ctx, &gb, pic)",
          "new_text": null,
          "old_line_content": "        ret = decode_yuv_frame(ctx, &gb, pic);",
          "new_line_content": "        avctx->bits_per_raw_sample = 8;",
          "content_same": false
        },
        {
          "line": 57,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gb, 5)",
          "new_text": null,
          "old_line_content": "    num_lens = get_bits(gb, 5);",
          "new_line_content": "    if (num_lens > VLC_BITS * VLC_DEPTH) {",
          "content_same": false
        },
        {
          "line": 187,
          "old_api": "CLOSE_READER",
          "new_api": null,
          "old_text": "CLOSE_READER(bits, gb)",
          "new_text": null,
          "old_line_content": "    CLOSE_READER(bits, gb);",
          "new_line_content": "static int read_yuv_component_line(CLLCContext *ctx, GetBitContext *gb,",
          "content_same": false
        },
        {
          "line": 60,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(ctx->avctx, AV_LOG_ERROR, \"To long VLCs %d\\n\", num_lens)",
          "new_text": null,
          "old_line_content": "        av_log(ctx->avctx, AV_LOG_ERROR, \"To long VLCs %d\\n\", num_lens);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": "ff_thread_get_buffer",
          "new_api": null,
          "old_text": "ff_thread_get_buffer(avctx, &frame, 0)",
          "new_text": null,
          "old_line_content": "        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)",
          "new_line_content": "    case 3:",
          "content_same": false
        },
        {
          "line": 65,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gb, 9)",
          "new_text": null,
          "old_line_content": "        num_codes      = get_bits(gb, 9);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": "decode_rgb24_frame",
          "new_api": null,
          "old_text": "decode_rgb24_frame(ctx, &gb, pic)",
          "new_text": null,
          "old_line_content": "        ret = decode_rgb24_frame(ctx, &gb, pic);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 69,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Too many VLCs (%d) to be read.\\n\", num_codes_sum)",
          "new_text": null,
          "old_line_content": "            av_log(ctx->avctx, AV_LOG_ERROR,",
          "new_line_content": "            return AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": "skip_bits",
          "new_api": null,
          "old_text": "skip_bits(gb, 8)",
          "new_text": null,
          "old_line_content": "    skip_bits(gb, 8);",
          "new_line_content": "    /* Read in code table for luma and chroma */",
          "content_same": false
        },
        {
          "line": 202,
          "old_api": "OPEN_READER",
          "new_api": null,
          "old_text": "OPEN_READER(bits, gb)",
          "new_text": null,
          "old_line_content": "    OPEN_READER(bits, gb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 75,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gb, 8)",
          "new_text": null,
          "old_line_content": "            symbols[count] = get_bits(gb, 8);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": "ff_thread_get_buffer",
          "new_api": null,
          "old_text": "ff_thread_get_buffer(avctx, &frame, 0)",
          "new_text": null,
          "old_line_content": "        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)",
          "new_line_content": "    default:",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": "avpriv_request_sample",
          "new_api": null,
          "old_text": "avpriv_request_sample(ctx->avctx, \"Blocked YUV\")",
          "new_text": null,
          "old_line_content": "        avpriv_request_sample(ctx->avctx, \"Blocked YUV\");",
          "new_line_content": "            for (j = 0; j < i; j++)",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": "decode_argb_frame",
          "new_api": null,
          "old_text": "decode_argb_frame(ctx, &gb, pic)",
          "new_text": null,
          "old_line_content": "        ret = decode_argb_frame(ctx, &gb, pic);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": "UPDATE_CACHE",
          "new_api": null,
          "old_text": "UPDATE_CACHE(bits, gb)",
          "new_text": null,
          "old_line_content": "        UPDATE_CACHE(bits, gb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 209,
          "old_api": "GET_VLC",
          "new_api": null,
          "old_text": "GET_VLC(code, bits, gb, vlc->table, VLC_BITS, VLC_DEPTH)",
          "new_text": null,
          "old_line_content": "        GET_VLC(code, bits, gb, vlc->table, VLC_BITS, VLC_DEPTH);",
          "new_line_content": "    /* Stash the first pixel */",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": "read_code_table",
          "new_api": null,
          "old_text": "read_code_table(ctx, gb, &vlc[i])",
          "new_text": null,
          "old_line_content": "        ret = read_code_table(ctx, gb, &vlc[i]);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Unknown coding type: %d.\\n\", coding_type)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Unknown coding type: %d.\\n\", coding_type);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": "ff_free_vlc",
          "new_api": null,
          "old_text": "ff_free_vlc(&vlc[j])",
          "new_text": null,
          "old_line_content": "                ff_free_vlc(&vlc[j]);",
          "new_line_content": "    /* Read in and restore every line */",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": "CLOSE_READER",
          "new_api": null,
          "old_text": "CLOSE_READER(bits, gb)",
          "new_text": null,
          "old_line_content": "    CLOSE_READER(bits, gb);",
          "new_line_content": "static int decode_argb_frame(CLLCContext *ctx, GetBitContext *gb, AVFrame *pic)",
          "content_same": false
        },
        {
          "line": 88,
          "old_api": "ff_init_vlc_sparse",
          "new_api": null,
          "old_text": "ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,\n                              codes, 2, 2, symbols, 1, 1, 0)",
          "new_text": null,
          "old_line_content": "    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,",
          "new_line_content": "static int read_argb_line(CLLCContext *ctx, GetBitContext *gb, int *top_left,",
          "content_same": false
        },
        {
          "line": 352,
          "old_api": "read_yuv_component_line",
          "new_api": null,
          "old_text": "read_yuv_component_line(ctx, gb, &pred[0], &vlc[0], dst[0], 0)",
          "new_text": null,
          "old_line_content": "        read_yuv_component_line(ctx, gb, &pred[0], &vlc[0], dst[0], 0); /* Y */",
          "new_line_content": "    for (i = 0; i < 2; i++)",
          "content_same": false
        },
        {
          "line": 354,
          "old_api": "read_yuv_component_line",
          "new_api": null,
          "old_text": "read_yuv_component_line(ctx, gb, &pred[2], &vlc[1], dst[2], 1)",
          "new_text": null,
          "old_line_content": "        read_yuv_component_line(ctx, gb, &pred[2], &vlc[1], dst[2], 1); /* V */",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&ctx->swapped_buf)",
          "new_text": null,
          "old_line_content": "    av_freep(&ctx->swapped_buf);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 104,
          "old_api": "OPEN_READER",
          "new_api": null,
          "old_text": "OPEN_READER(bits, gb)",
          "new_text": null,
          "old_line_content": "    OPEN_READER(bits, gb);",
          "new_line_content": "    for (i = 0; i < ctx->avctx->width; i++) {",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": "ff_free_vlc",
          "new_api": null,
          "old_text": "ff_free_vlc(&vlc[i])",
          "new_text": null,
          "old_line_content": "        ff_free_vlc(&vlc[i]);",
          "new_line_content": "    CLLCContext *ctx = avctx->priv_data;",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": "skip_bits",
          "new_api": null,
          "old_text": "skip_bits(gb, 16)",
          "new_text": null,
          "old_line_content": "    skip_bits(gb, 16);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 114,
          "old_api": "UPDATE_CACHE",
          "new_api": null,
          "old_text": "UPDATE_CACHE(bits, gb)",
          "new_text": null,
          "old_line_content": "        UPDATE_CACHE(bits, gb);",
          "new_line_content": "            /* Red */",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": "read_code_table",
          "new_api": null,
          "old_text": "read_code_table(ctx, gb, &vlc[i])",
          "new_text": null,
          "old_line_content": "        ret = read_code_table(ctx, gb, &vlc[i]);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": "ff_bswapdsp_init",
          "new_api": null,
          "old_text": "ff_bswapdsp_init(&ctx->bdsp)",
          "new_text": null,
          "old_line_content": "    ff_bswapdsp_init(&ctx->bdsp);",
          "new_line_content": "    .type           = AVMEDIA_TYPE_VIDEO,",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": "ff_free_vlc",
          "new_api": null,
          "old_text": "ff_free_vlc(&vlc[j])",
          "new_text": null,
          "old_line_content": "                ff_free_vlc(&vlc[j]);",
          "new_line_content": "    /* Read in and restore every line */",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"Canopus Lossless Codec\")",
          "new_text": null,
          "old_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"Canopus Lossless Codec\"),",
          "new_line_content": "    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Frame is too small %d.\\n\", avpkt->size)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Frame is too small %d.\\n\", avpkt->size);",
          "new_line_content": "        if (info_offset > UINT32_MAX - 8 || info_offset + 8 > avpkt->size) {",
          "content_same": false
        },
        {
          "line": 124,
          "old_api": "GET_VLC",
          "new_api": null,
          "old_text": "GET_VLC(code, bits, gb, vlc[1].table, VLC_BITS, VLC_DEPTH)",
          "new_text": null,
          "old_line_content": "            GET_VLC(code, bits, gb, vlc[1].table, VLC_BITS, VLC_DEPTH);",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 13,
      "total_additions": 57,
      "total_deletions": 57,
      "total_api_changes": 127
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 12,
        "api_related_lines": 127,
        "non_api_lines": 10,
        "non_api_line_numbers": [
          77,
          81,
          50,
          82,
          49,
          53,
          83,
          84,
          85,
          89
        ]
      }
    },
    "api_calls_before": 70,
    "api_calls_after": 70,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 11,
      "total_diff_lines": 40
    }
  }
}