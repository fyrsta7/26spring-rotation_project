{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/35fd7b2968834c5994bfd2a93edfbf0dea5e667e",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/35fd7b2968834c5994bfd2a93edfbf0dea5e667e/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/35fd7b2968834c5994bfd2a93edfbf0dea5e667e/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/35fd7b2968834c5994bfd2a93edfbf0dea5e667e/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 151,
          "old_api": "AV_RL32",
          "new_api": "get_buffer",
          "old_text": "AV_RL32(src)",
          "new_text": "avctx->get_buffer(avctx, pic)",
          "old_line_content": "    version = AV_RL32(src);",
          "new_line_content": "    if (avctx->get_buffer(avctx, pic) < 0) {",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": "vble_unpack",
          "new_api": "AV_RL32",
          "old_text": "vble_unpack(ctx, &gb)",
          "new_text": "AV_RL32(src)",
          "old_line_content": "    if (vble_unpack(ctx, &gb) < 0) {",
          "new_line_content": "    version = AV_RL32(src);",
          "content_same": false
        },
        {
          "line": 172,
          "old_api": "vble_restore_plane",
          "new_api": "av_log",
          "old_text": "vble_restore_plane(ctx, 1, offset, width_uv, height_uv)",
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Invalid Code\\n\")",
          "old_line_content": "        vble_restore_plane(ctx, 1, offset, width_uv, height_uv);",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Invalid Code\\n\");",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": "av_malloc",
          "new_api": "avcodec_alloc_frame",
          "old_text": "av_malloc(ctx->size * sizeof(*ctx->len))",
          "new_text": "avcodec_alloc_frame()",
          "old_line_content": "    ctx->len = av_malloc(ctx->size * sizeof(*ctx->len));",
          "new_line_content": "    avctx->coded_frame = avcodec_alloc_frame();",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": "vble_decode_close",
          "new_api": "AVERROR",
          "old_text": "vble_decode_close(avctx)",
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "        vble_decode_close(avctx);",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Could not allocate lengths buffer.\\n\")",
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Could not allocate lengths buffer.\\n\");",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 257,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"VBLE Lossless Codec\")",
          "old_line_content": "",
          "new_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"VBLE Lossless Codec\"),",
          "content_same": false
        },
        {
          "line": 148,
          "old_api": null,
          "new_api": "release_buffer",
          "old_text": null,
          "new_text": "avctx->release_buffer(avctx, pic)",
          "old_line_content": "    pic->pict_type = FF_I_TYPE;",
          "new_line_content": "        avctx->release_buffer(avctx, pic);",
          "content_same": false
        },
        {
          "line": 152,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Could not allocate buffer.\\n\")",
          "old_line_content": "",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Could not allocate buffer.\\n\");",
          "content_same": false
        },
        {
          "line": 153,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    if (version != 1) {",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Unsupported VBLE Version: %d\\n\", version)",
          "old_line_content": "    }",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Unsupported VBLE Version: %d\\n\", version);",
          "content_same": false
        },
        {
          "line": 168,
          "old_api": null,
          "new_api": "init_get_bits",
          "old_text": null,
          "new_text": "init_get_bits(&gb, src + 4, (avpkt->size - 4) * 8)",
          "old_line_content": "",
          "new_line_content": "    init_get_bits(&gb, src + 4, (avpkt->size - 4) * 8);",
          "content_same": false
        },
        {
          "line": 171,
          "old_api": null,
          "new_api": "vble_unpack",
          "old_text": null,
          "new_text": "vble_unpack(ctx, &gb)",
          "old_line_content": "        offset += avctx->width * avctx->height;",
          "new_line_content": "    if (vble_unpack(ctx, &gb) < 0) {",
          "content_same": false
        },
        {
          "line": 177,
          "old_api": null,
          "new_api": "vble_restore_plane",
          "old_text": null,
          "new_text": "vble_restore_plane(ctx, 0, offset, avctx->width, avctx->height)",
          "old_line_content": "",
          "new_line_content": "    vble_restore_plane(ctx, 0, offset, avctx->width, avctx->height);",
          "content_same": false
        },
        {
          "line": 54,
          "old_api": null,
          "new_api": "show_bits",
          "old_text": null,
          "new_text": "show_bits(gb, 8)",
          "old_line_content": "    }",
          "new_line_content": "    int val = show_bits(gb, 8);",
          "content_same": false
        },
        {
          "line": 182,
          "old_api": null,
          "new_api": "vble_restore_plane",
          "old_text": null,
          "new_text": "vble_restore_plane(ctx, 1, offset, width_uv, height_uv)",
          "old_line_content": "}",
          "new_line_content": "        vble_restore_plane(ctx, 1, offset, width_uv, height_uv);",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": null,
          "new_api": "vble_restore_plane",
          "old_text": null,
          "new_text": "vble_restore_plane(ctx, 2, offset, width_uv, height_uv)",
          "old_line_content": "{",
          "new_line_content": "        vble_restore_plane(ctx, 2, offset, width_uv, height_uv);",
          "content_same": false
        },
        {
          "line": 58,
          "old_api": null,
          "new_api": "skip_bits",
          "old_text": null,
          "new_text": "skip_bits(gb, val + 1)",
          "old_line_content": "}",
          "new_line_content": "        skip_bits(gb, val + 1);",
          "content_same": false
        },
        {
          "line": 61,
          "old_api": null,
          "new_api": "skip_bits",
          "old_text": null,
          "new_text": "skip_bits(gb, 8)",
          "old_line_content": "{",
          "new_line_content": "        skip_bits(gb, 8);",
          "content_same": false
        },
        {
          "line": 62,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gb)",
          "old_line_content": "    int i;",
          "new_line_content": "        if (get_bits1(gb))",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": null,
          "new_api": "release_buffer",
          "old_text": null,
          "new_text": "avctx->release_buffer(avctx, pic)",
          "old_line_content": "{",
          "new_line_content": "        avctx->release_buffer(avctx, pic);",
          "content_same": false
        },
        {
          "line": 202,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&avctx->coded_frame)",
          "old_line_content": "",
          "new_line_content": "    av_freep(&avctx->coded_frame);",
          "content_same": false
        },
        {
          "line": 203,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&ctx->len)",
          "old_line_content": "    /* Stash for later use */",
          "new_line_content": "    av_freep(&ctx->len);",
          "content_same": false
        },
        {
          "line": 76,
          "old_api": null,
          "new_api": "vble_read_reverse_unary",
          "old_text": null,
          "new_text": "vble_read_reverse_unary(gb)",
          "old_line_content": "        /* Check we have enough bits left */",
          "new_line_content": "        ctx->len[i] = vble_read_reverse_unary(gb);",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&ctx->val)",
          "old_line_content": "    ctx->avctx = avctx;",
          "new_line_content": "    av_freep(&ctx->val);",
          "content_same": false
        },
        {
          "line": 83,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(ctx->val, 0, ctx->size)",
          "old_line_content": "    }",
          "new_line_content": "    memset(ctx->val, 0, ctx->size);",
          "content_same": false
        },
        {
          "line": 87,
          "old_api": null,
          "new_api": "get_bits_left",
          "old_text": null,
          "new_text": "get_bits_left(gb)",
          "old_line_content": "",
          "new_line_content": "        if (get_bits_left(gb) < ctx->len[i])",
          "content_same": false
        },
        {
          "line": 92,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gb, ctx->len[i])",
          "old_line_content": "    uint8_t *dst = pic->data[plane];",
          "new_line_content": "            ctx->val[i] = (1 << ctx->len[i]) + get_bits(gb, ctx->len[i]) - 1;",
          "content_same": false
        },
        {
          "line": 226,
          "old_api": null,
          "new_api": "avpicture_get_size",
          "old_text": null,
          "new_text": "avpicture_get_size(avctx->pix_fmt,\n                                   avctx->width, avctx->height)",
          "old_line_content": "",
          "new_line_content": "    ctx->size = avpicture_get_size(avctx->pix_fmt,",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(ctx->size * sizeof(*ctx->len))",
          "old_line_content": "    if (!ctx->val) {",
          "new_line_content": "    ctx->len = av_malloc(ctx->size * sizeof(*ctx->len));",
          "content_same": false
        },
        {
          "line": 233,
          "old_api": null,
          "new_api": "vble_decode_close",
          "old_text": null,
          "new_text": "vble_decode_close(avctx)",
          "old_line_content": "    }",
          "new_line_content": "        vble_decode_close(avctx);",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(ctx->size * sizeof(*ctx->val))",
          "old_line_content": "",
          "new_line_content": "    ctx->val = av_malloc(ctx->size * sizeof(*ctx->val));",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Could not allocate values buffer.\\n\")",
          "old_line_content": "    .type           = AVMEDIA_TYPE_VIDEO,",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Could not allocate values buffer.\\n\");",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": null,
          "new_api": "vble_decode_close",
          "old_text": null,
          "new_text": "vble_decode_close(avctx)",
          "old_line_content": "    .id             = CODEC_ID_VBLE,",
          "new_line_content": "        vble_decode_close(avctx);",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    .priv_data_size = sizeof(VBLEContext),",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": null,
          "new_api": "mid_pred",
          "old_text": null,
          "new_text": "mid_pred(a, b, c)",
          "old_line_content": "{",
          "new_line_content": "            dst[j] += mid_pred(a, b, c);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 138,
          "old_api": "release_buffer",
          "new_api": null,
          "old_text": "avctx->release_buffer(avctx, pic)",
          "new_text": null,
          "old_line_content": "        avctx->release_buffer(avctx, pic);",
          "new_line_content": "    GetBitContext gb;",
          "content_same": false
        },
        {
          "line": 141,
          "old_api": "get_buffer",
          "new_api": null,
          "old_text": "avctx->get_buffer(avctx, pic)",
          "new_text": null,
          "old_line_content": "    if (avctx->get_buffer(avctx, pic) < 0) {",
          "new_line_content": "    int offset = 0;",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Could not allocate buffer.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Could not allocate buffer.\\n\");",
          "new_line_content": "    int width_uv = avctx->width / 2, height_uv = avctx->height / 2;",
          "content_same": false
        },
        {
          "line": 143,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 154,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Unsupported VBLE Version: %d\\n\", version)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Unsupported VBLE Version: %d\\n\", version);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": "init_get_bits",
          "new_api": null,
          "old_text": "init_get_bits(&gb, src + 4, (avpkt->size - 4) * 8)",
          "new_text": null,
          "old_line_content": "    init_get_bits(&gb, src + 4, (avpkt->size - 4) * 8);",
          "new_line_content": "    pic->pict_type = FF_I_TYPE;",
          "content_same": false
        },
        {
          "line": 162,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Invalid Code\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Invalid Code\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 167,
          "old_api": "vble_restore_plane",
          "new_api": null,
          "old_text": "vble_restore_plane(ctx, 0, offset, avctx->width, avctx->height)",
          "new_text": null,
          "old_line_content": "    vble_restore_plane(ctx, 0, offset, avctx->width, avctx->height);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 44,
          "old_api": "show_bits",
          "new_api": null,
          "old_text": "show_bits(gb, 8)",
          "new_text": null,
          "old_line_content": "    int val = show_bits(gb, 8);",
          "new_line_content": "        8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,",
          "content_same": false
        },
        {
          "line": 47,
          "old_api": "av_log2_16bit",
          "new_api": null,
          "old_text": "av_log2_16bit(av_reverse[val])",
          "new_text": null,
          "old_line_content": "        val = 7 - av_log2_16bit(av_reverse[val]);",
          "new_line_content": "        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,",
          "content_same": false
        },
        {
          "line": 48,
          "old_api": "skip_bits",
          "new_api": null,
          "old_text": "skip_bits(gb, val + 1)",
          "new_text": null,
          "old_line_content": "        skip_bits(gb, val + 1);",
          "new_line_content": "        7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,",
          "content_same": false
        },
        {
          "line": 175,
          "old_api": "vble_restore_plane",
          "new_api": null,
          "old_text": "vble_restore_plane(ctx, 2, offset, width_uv, height_uv)",
          "new_text": null,
          "old_line_content": "        vble_restore_plane(ctx, 2, offset, width_uv, height_uv);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 51,
          "old_api": "skip_bits",
          "new_api": null,
          "old_text": "skip_bits(gb, 8)",
          "new_text": null,
          "old_line_content": "        skip_bits(gb, 8);",
          "new_line_content": "        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,",
          "content_same": false
        },
        {
          "line": 52,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gb)",
          "new_text": null,
          "old_line_content": "        if (get_bits1(gb))",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": "release_buffer",
          "new_api": null,
          "old_text": "avctx->release_buffer(avctx, pic)",
          "new_text": null,
          "old_line_content": "        avctx->release_buffer(avctx, pic);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&avctx->coded_frame)",
          "new_text": null,
          "old_line_content": "    av_freep(&avctx->coded_frame);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 193,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&ctx->len)",
          "new_text": null,
          "old_line_content": "    av_freep(&ctx->len);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 66,
          "old_api": "vble_read_reverse_unary",
          "new_api": null,
          "old_text": "vble_read_reverse_unary(gb)",
          "new_text": null,
          "old_line_content": "        ctx->len[i] = vble_read_reverse_unary(gb);",
          "new_line_content": "    /* Return something larger than 8 on error */",
          "content_same": false
        },
        {
          "line": 194,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&ctx->val)",
          "new_text": null,
          "old_line_content": "    av_freep(&ctx->val);",
          "new_line_content": "static av_cold int vble_decode_close(AVCodecContext *avctx)",
          "content_same": false
        },
        {
          "line": 73,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(ctx->val, 0, ctx->size)",
          "new_text": null,
          "old_line_content": "    memset(ctx->val, 0, ctx->size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 77,
          "old_api": "get_bits_left",
          "new_api": null,
          "old_text": "get_bits_left(gb)",
          "new_text": null,
          "old_line_content": "        if (get_bits_left(gb) < ctx->len[i])",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 209,
          "old_api": "avcodec_alloc_frame",
          "new_api": null,
          "old_text": "avcodec_alloc_frame()",
          "new_text": null,
          "old_line_content": "    avctx->coded_frame = avcodec_alloc_frame();",
          "new_line_content": "static av_cold int vble_decode_init(AVCodecContext *avctx)",
          "content_same": false
        },
        {
          "line": 82,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gb, ctx->len[i])",
          "new_text": null,
          "old_line_content": "            ctx->val[i] = (1 << ctx->len[i]) + get_bits(gb, ctx->len[i]) - 1;",
          "new_line_content": "    /* For any values that have length 0 */",
          "content_same": false
        },
        {
          "line": 212,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Could not allocate frame.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Could not allocate frame.\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "    /* Stash for later use */",
          "content_same": false
        },
        {
          "line": 216,
          "old_api": "avpicture_get_size",
          "new_api": null,
          "old_text": "avpicture_get_size(avctx->pix_fmt,\n                                   avctx->width, avctx->height)",
          "new_text": null,
          "old_line_content": "    ctx->size = avpicture_get_size(avctx->pix_fmt,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(ctx->size * sizeof(*ctx->val))",
          "new_text": null,
          "old_line_content": "    ctx->val = av_malloc(ctx->size * sizeof(*ctx->val));",
          "new_line_content": "                                   avctx->width, avctx->height);",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Could not allocate values buffer.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Could not allocate values buffer.\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": "vble_decode_close",
          "new_api": null,
          "old_text": "vble_decode_close(avctx)",
          "new_text": null,
          "old_line_content": "        vble_decode_close(avctx);",
          "new_line_content": "    if (!ctx->len) {",
          "content_same": false
        },
        {
          "line": 115,
          "old_api": "mid_pred",
          "new_api": null,
          "old_text": "mid_pred(a, b, c)",
          "new_text": null,
          "old_line_content": "            dst[j] += mid_pred(a, b, c);",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"VBLE Lossless Codec\")",
          "new_text": null,
          "old_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"VBLE Lossless Codec\"),",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 6,
      "total_additions": 31,
      "total_deletions": 32,
      "total_api_changes": 69
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 11,
        "api_related_lines": 69,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          43,
          45,
          46,
          49,
          50,
          57
        ]
      }
    },
    "api_calls_before": 39,
    "api_calls_after": 38,
    "diff_info": {
      "added_lines": 11,
      "removed_lines": 1,
      "total_diff_lines": 28
    }
  }
}