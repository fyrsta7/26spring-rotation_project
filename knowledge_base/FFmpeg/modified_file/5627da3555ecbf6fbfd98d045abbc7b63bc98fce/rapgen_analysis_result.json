{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/5627da3555ecbf6fbfd98d045abbc7b63bc98fce",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/5627da3555ecbf6fbfd98d045abbc7b63bc98fce/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/5627da3555ecbf6fbfd98d045abbc7b63bc98fce/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/5627da3555ecbf6fbfd98d045abbc7b63bc98fce/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 198,
          "old_api": "ffio_fill",
          "new_api": "av_builtin_constant_p",
          "old_text": "ffio_fill(pb, 0xff, bytes - 1)",
          "new_text": "av_builtin_constant_p(bytes)",
          "old_line_content": "    ffio_fill(pb, 0xff, bytes - 1);",
          "new_line_content": "    if (av_builtin_constant_p(bytes) && bytes == 1)",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": "avio_wb64",
          "new_api": "put_ebml_id",
          "old_text": "avio_wb64(pb, uid)",
          "new_text": "put_ebml_id(pb, elementid)",
          "old_line_content": "    avio_wb64(pb, uid);",
          "new_line_content": "    put_ebml_id(pb, elementid);",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": "avio_w8",
          "new_api": "put_ebml_length",
          "old_text": "avio_w8(pb, (uint8_t)(val >> i * 8))",
          "new_text": "put_ebml_length(pb, bytes, 0)",
          "old_line_content": "        avio_w8(pb, (uint8_t)(val >> i * 8));",
          "new_line_content": "    put_ebml_length(pb, bytes, 0);",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "avio_w8",
          "new_api": "put_ebml_length",
          "old_text": "avio_w8(pb, (uint8_t)(val >> i * 8))",
          "new_text": "put_ebml_length(pb, bytes, 0)",
          "old_line_content": "        avio_w8(pb, (uint8_t)(val >> i * 8));",
          "new_line_content": "    put_ebml_length(pb, bytes, 0);",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": "av_double2int",
          "new_api": "put_ebml_id",
          "old_text": "av_double2int(val)",
          "new_text": "put_ebml_id(pb, elementid)",
          "old_line_content": "    avio_wb64(pb, av_double2int(val));",
          "new_line_content": "    put_ebml_id(pb, elementid);",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "avio_write",
          "new_api": "put_ebml_id",
          "old_text": "avio_write(pb, buf, size)",
          "new_text": "put_ebml_id(pb, elementid)",
          "old_line_content": "    avio_write(pb, buf, size);",
          "new_line_content": "    put_ebml_id(pb, elementid);",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": "put_ebml_id",
          "new_api": "av_assert0",
          "old_text": "put_ebml_id(pb, EBML_ID_VOID)",
          "new_text": "av_assert0(size >= 2)",
          "old_line_content": "    put_ebml_id(pb, EBML_ID_VOID);",
          "new_line_content": "    av_assert0(size >= 2);",
          "content_same": false
        },
        {
          "line": 334,
          "old_api": "ffio_fill",
          "new_api": "put_ebml_length",
          "old_text": "ffio_fill(pb, 0, size)",
          "new_text": "put_ebml_length(pb, size, 8)",
          "old_line_content": "    ffio_fill(pb, 0, size);",
          "new_line_content": "        put_ebml_length(pb, size, 8);",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": "put_ebml_id",
          "new_api": "ebml_length_size",
          "old_text": "put_ebml_id(pb, elementid)",
          "new_text": "ebml_length_size(expectedsize)",
          "old_line_content": "    put_ebml_id(pb, elementid);",
          "new_line_content": "    int bytes = expectedsize ? ebml_length_size(expectedsize) : 8;",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": "avio_tell",
          "new_api": "put_ebml_id",
          "old_text": "avio_tell(pb)",
          "new_text": "put_ebml_id(pb, elementid)",
          "old_line_content": "    return (ebml_master) { avio_tell(pb), bytes };",
          "new_line_content": "    put_ebml_id(pb, elementid);",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": "avio_seek",
          "new_api": "avio_tell",
          "old_text": "avio_seek(pb, master.pos - master.sizebytes, SEEK_SET)",
          "new_text": "avio_tell(pb)",
          "old_line_content": "    if (avio_seek(pb, master.pos - master.sizebytes, SEEK_SET) < 0)",
          "new_line_content": "    int64_t pos = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": "put_ebml_length",
          "new_api": "avio_seek",
          "old_text": "put_ebml_length(pb, pos - master.pos, master.sizebytes)",
          "new_text": "avio_seek(pb, master.pos - master.sizebytes, SEEK_SET)",
          "old_line_content": "    put_ebml_length(pb, pos - master.pos, master.sizebytes);",
          "new_line_content": "    if (avio_seek(pb, master.pos - master.sizebytes, SEEK_SET) < 0)",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": "put_ebml_id",
          "new_api": "avio_tell",
          "old_text": "put_ebml_id(pb, id)",
          "new_text": "avio_tell(pb)",
          "old_line_content": "    put_ebml_id(pb, id);",
          "new_line_content": "        mkv_add_seekhead_entry(mkv, id, avio_tell(pb));",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": "avio_write",
          "new_api": "put_ebml_binary",
          "old_text": "avio_write(pb, buf + skip, size - skip)",
          "new_text": "put_ebml_binary(pb, EBML_ID_CRC32, crc, sizeof(crc))",
          "old_line_content": "    avio_write(pb, buf + skip, size - skip);",
          "new_line_content": "        put_ebml_binary(pb, EBML_ID_CRC32, crc, sizeof(crc));",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": "ffio_free_dyn_buf",
          "new_api": "ffio_reset_dyn_buf",
          "old_text": "ffio_free_dyn_buf(dyn_cp)",
          "new_text": "ffio_reset_dyn_buf(*dyn_cp)",
          "old_line_content": "        ffio_free_dyn_buf(dyn_cp);",
          "new_line_content": "        ffio_reset_dyn_buf(*dyn_cp);",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": "avio_get_dyn_buf",
          "new_api": "IS_SEEKABLE",
          "old_text": "avio_get_dyn_buf(elem->bc, &buf)",
          "new_text": "IS_SEEKABLE(pb, mkv)",
          "old_line_content": "        int size = avio_get_dyn_buf(elem->bc, &buf);",
          "new_line_content": "    if (IS_SEEKABLE(pb, mkv)) {",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": "put_ebml_id",
          "new_api": "mkv_add_seekhead_entry",
          "old_text": "put_ebml_id(pb, id)",
          "new_text": "mkv_add_seekhead_entry(mkv, id, elem->pos)",
          "old_line_content": "        put_ebml_id(pb, id);",
          "new_line_content": "        mkv_add_seekhead_entry(mkv, id, elem->pos);",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": "avio_write",
          "new_api": "put_ebml_id",
          "old_text": "avio_write(pb, buf, size)",
          "new_text": "put_ebml_id(pb, id)",
          "old_line_content": "        avio_write(pb, buf, size);",
          "new_line_content": "        put_ebml_id(pb, id);",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": "ffio_free_dyn_buf",
          "new_api": "av_packet_free",
          "old_text": "ffio_free_dyn_buf(&mkv->cluster_bc)",
          "new_text": "av_packet_free(&mkv->cur_audio_pkt)",
          "old_line_content": "    ffio_free_dyn_buf(&mkv->cluster_bc);",
          "new_line_content": "    av_packet_free(&mkv->cur_audio_pkt);",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": "av_freep",
          "new_api": "ffio_free_dyn_buf",
          "old_text": "av_freep(&mkv->cues.entries)",
          "new_text": "ffio_free_dyn_buf(&mkv->tags.bc)",
          "old_line_content": "    av_freep(&mkv->cues.entries);",
          "new_line_content": "    ffio_free_dyn_buf(&mkv->tags.bc);",
          "content_same": false
        },
        {
          "line": 514,
          "old_api": "put_ebml_uint",
          "new_api": "put_ebml_id",
          "old_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_SEEKPOSITION, entry->segmentpos)",
          "new_text": "put_ebml_id(dyn_cp, entry->elementid)",
          "old_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_SEEKPOSITION, entry->segmentpos);",
          "new_line_content": "        put_ebml_id(dyn_cp, entry->elementid);",
          "content_same": false
        },
        {
          "line": 517,
          "old_api": "end_ebml_master_crc32",
          "new_api": "end_ebml_master",
          "old_text": "end_ebml_master_crc32(pb, &dyn_cp, mkv,\n                                MATROSKA_ID_SEEKHEAD, 0, 0, 0)",
          "new_text": "end_ebml_master(dyn_cp, seekentry)",
          "old_line_content": "    ret = end_ebml_master_crc32(pb, &dyn_cp, mkv,",
          "new_line_content": "        end_ebml_master(dyn_cp, seekentry);",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": "avio_seek",
          "new_api": "put_ebml_void",
          "old_text": "avio_seek(pb, destpos, SEEK_SET)",
          "new_text": "put_ebml_void(pb, remaining)",
          "old_line_content": "    if ((ret64 = avio_seek(pb, destpos, SEEK_SET)) < 0)",
          "new_line_content": "    put_ebml_void(pb, remaining);",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": "AVERROR",
          "new_api": "av_realloc_array",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "av_realloc_array(entries, cues->num_entries + 1, sizeof(mkv_cuepoint))",
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "    entries = av_realloc_array(entries, cues->num_entries + 1, sizeof(mkv_cuepoint));",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": "put_ebml_uint",
          "new_api": "start_ebml_master",
          "old_text": "put_ebml_uint(cuepoint, MATROSKA_ID_CUECLUSTERPOSITION , entry->cluster_pos)",
          "new_text": "start_ebml_master(cuepoint, MATROSKA_ID_CUETRACKPOSITION, MAX_CUETRACKPOS_SIZE)",
          "old_line_content": "            put_ebml_uint(cuepoint, MATROSKA_ID_CUECLUSTERPOSITION , entry->cluster_pos);",
          "new_line_content": "            track_positions = start_ebml_master(cuepoint, MATROSKA_ID_CUETRACKPOSITION, MAX_CUETRACKPOS_SIZE);",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": "avio_get_dyn_buf",
          "new_api": "end_ebml_master",
          "old_text": "avio_get_dyn_buf(cuepoint, &buf)",
          "new_text": "end_ebml_master(cuepoint, track_positions)",
          "old_line_content": "        size = avio_get_dyn_buf(cuepoint, &buf);",
          "new_line_content": "            end_ebml_master(cuepoint, track_positions);",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": "ffio_free_dyn_buf",
          "new_api": "ffio_reset_dyn_buf",
          "old_text": "ffio_free_dyn_buf(&cuepoint)",
          "new_text": "ffio_reset_dyn_buf(cuepoint)",
          "old_line_content": "    ffio_free_dyn_buf(&cuepoint);",
          "new_line_content": "        ffio_reset_dyn_buf(cuepoint);",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": "put_xiph_size",
          "new_api": "avio_w8",
          "old_text": "put_xiph_size(pb, header_len[j])",
          "new_text": "avio_w8(pb, 2)",
          "old_line_content": "        put_xiph_size(pb, header_len[j]);",
          "new_line_content": "    avio_w8(pb, 2);                    // number packets - 1",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": "avio_wl16",
          "new_api": "avio_write",
          "old_text": "avio_wl16(pb, 0x410)",
          "new_text": "avio_write(pb, par->extradata, 2)",
          "old_line_content": "        avio_wl16(pb, 0x410); // fallback to the most recent version",
          "new_line_content": "        avio_write(pb, par->extradata, 2);",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": "ff_vorbiscomment_length",
          "new_api": "av_dict_set",
          "old_text": "ff_vorbiscomment_length(dict, vendor, NULL, 0)",
          "new_text": "av_dict_set(&dict, \"WAVEFORMATEXTENSIBLE_CHANNEL_MASK\", buf, 0)",
          "old_line_content": "        len = ff_vorbiscomment_length(dict, vendor, NULL, 0);",
          "new_line_content": "        av_dict_set(&dict, \"WAVEFORMATEXTENSIBLE_CHANNEL_MASK\", buf, 0);",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "avio_w8",
          "new_api": "av_assert1",
          "old_text": "avio_w8(pb, 0x84)",
          "new_text": "av_assert1(len < (1 << 24) - 4)",
          "old_line_content": "        avio_w8(pb, 0x84);",
          "new_line_content": "        av_assert1(len < (1 << 24) - 4);",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "ff_vorbiscomment_write",
          "new_api": "avio_wb24",
          "old_text": "ff_vorbiscomment_write(pb, dict, vendor, NULL, 0)",
          "new_text": "avio_wb24(pb, len)",
          "old_line_content": "        ff_vorbiscomment_write(pb, dict, vendor, NULL, 0);",
          "new_line_content": "        avio_wb24(pb, len);",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": "av_dict_free",
          "new_api": "ff_vorbiscomment_write",
          "old_text": "av_dict_free(&dict)",
          "new_text": "ff_vorbiscomment_write(pb, dict, vendor, NULL, 0)",
          "old_line_content": "        av_dict_free(&dict);",
          "new_line_content": "        ff_vorbiscomment_write(pb, dict, vendor, NULL, 0);",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(s, AV_LOG_ERROR,\n               \"Error parsing AAC extradata, unable to determine samplerate.\\n\")",
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "        av_log(s, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": "put_flac_codecpriv",
          "new_api": "put_xiph_codecpriv",
          "old_text": "put_flac_codecpriv(s, dyn_cp, par)",
          "new_text": "put_xiph_codecpriv(s, dyn_cp, par)",
          "old_line_content": "        return put_flac_codecpriv(s, dyn_cp, par);",
          "new_line_content": "        return put_xiph_codecpriv(s, dyn_cp, par);",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": "put_wv_codecpriv",
          "new_api": "put_flac_codecpriv",
          "old_text": "put_wv_codecpriv(dyn_cp, par)",
          "new_text": "put_flac_codecpriv(s, dyn_cp, par)",
          "old_line_content": "        return put_wv_codecpriv(dyn_cp, par);",
          "new_line_content": "        return put_flac_codecpriv(s, dyn_cp, par);",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "ff_isom_write_avcc",
          "new_api": "put_wv_codecpriv",
          "old_text": "ff_isom_write_avcc(dyn_cp, par->extradata,\n                                  par->extradata_size)",
          "new_text": "put_wv_codecpriv(dyn_cp, par)",
          "old_line_content": "        return ff_isom_write_avcc(dyn_cp, par->extradata,",
          "new_line_content": "        return put_wv_codecpriv(dyn_cp, par);",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": "put_ebml_void",
          "new_api": "avio_write",
          "old_text": "put_ebml_void(pb, MAX_PCE_SIZE + 2 + 4)",
          "new_text": "avio_write(dyn_cp, par->extradata, par->extradata_size)",
          "old_line_content": "            put_ebml_void(pb, MAX_PCE_SIZE + 2 + 4);",
          "new_line_content": "            avio_write(dyn_cp, par->extradata, par->extradata_size);",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "avio_write",
          "new_api": "avio_wl32",
          "old_text": "avio_write(dyn_cp, par->extradata, par->extradata_size)",
          "new_text": "avio_wl32(dyn_cp, par->codec_tag)",
          "old_line_content": "            avio_write(dyn_cp, par->extradata, par->extradata_size);",
          "new_line_content": "            avio_wl32(dyn_cp, par->codec_tag);",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": "ff_codec_get_id",
          "new_api": "ff_codec_get_tag",
          "old_text": "ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag)",
          "new_text": "ff_codec_get_tag(ff_codec_movvideo_tags,\n                                                    par->codec_id)",
          "old_line_content": "            if (   ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag) == par->codec_id",
          "new_line_content": "                par->codec_tag = ff_codec_get_tag(ff_codec_movvideo_tags,",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "avio_w8",
          "new_api": "avio_wl32",
          "old_text": "avio_w8(dyn_cp, 0)",
          "new_text": "avio_wl32(dyn_cp, par->codec_tag)",
          "old_line_content": "                    avio_w8(dyn_cp, 0);",
          "new_line_content": "                avio_wl32(dyn_cp, par->codec_tag);",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": "avio_write",
          "new_api": "avio_w8",
          "old_text": "avio_write(dyn_cp, par->extradata, par->extradata_size)",
          "new_text": "avio_w8(dyn_cp, 0)",
          "old_line_content": "            avio_write(dyn_cp, par->extradata, par->extradata_size);",
          "new_line_content": "                    avio_w8(dyn_cp, 0);",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": "ff_codec_get_tag",
          "new_api": "avio_write",
          "old_text": "ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id)",
          "new_text": "avio_write(dyn_cp, par->extradata, par->extradata_size)",
          "old_line_content": "            if (!ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id))",
          "new_line_content": "            avio_write(dyn_cp, par->extradata, par->extradata_size);",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "avcodec_get_name",
          "new_api": "ff_codec_get_tag",
          "old_text": "avcodec_get_name(par->codec_id)",
          "new_text": "ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id)",
          "old_line_content": "                       avcodec_get_name(par->codec_id));",
          "new_line_content": "            if (!ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id))",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(s, AV_LOG_ERROR, \"No bmp codec tag found for codec %s\\n\",\n                       avcodec_get_name(par->codec_id))",
          "old_line_content": "                ret = AVERROR(EINVAL);",
          "new_line_content": "                av_log(s, AV_LOG_ERROR, \"No bmp codec tag found for codec %s\\n\",",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "av_log",
          "new_api": "ff_codec_get_tag",
          "old_text": "av_log(s, AV_LOG_ERROR, \"No wav codec tag found for codec %s\\n\",\n                   avcodec_get_name(par->codec_id))",
          "new_text": "ff_codec_get_tag(ff_codec_wav_tags, par->codec_id)",
          "old_line_content": "            av_log(s, AV_LOG_ERROR, \"No wav codec tag found for codec %s\\n\",",
          "new_line_content": "        tag = ff_codec_get_tag(ff_codec_wav_tags, par->codec_id);",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(s, AV_LOG_ERROR, \"No wav codec tag found for codec %s\\n\",\n                   avcodec_get_name(par->codec_id))",
          "old_line_content": "            ret = AVERROR(EINVAL);",
          "new_line_content": "            av_log(s, AV_LOG_ERROR, \"No wav codec tag found for codec %s\\n\",",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "put_ebml_binary",
          "new_api": "avio_get_dyn_buf",
          "old_text": "put_ebml_binary(pb, MATROSKA_ID_CODECPRIVATE, codecpriv,\n                            codecpriv_size)",
          "new_text": "avio_get_dyn_buf(dyn_cp, &codecpriv)",
          "old_line_content": "            put_ebml_binary(pb, MATROSKA_ID_CODECPRIVATE, codecpriv,",
          "new_line_content": "        codecpriv_size = avio_get_dyn_buf(dyn_cp, &codecpriv);",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": "put_ebml_uint",
          "new_api": "avcodec_enum_to_chroma_pos",
          "old_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORCHROMASITINGVERT, (ypos >> 7) + 1)",
          "new_text": "avcodec_enum_to_chroma_pos(&xpos, &ypos, par->chroma_location)",
          "old_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORCHROMASITINGVERT, (ypos >> 7) + 1);",
          "new_line_content": "        avcodec_enum_to_chroma_pos(&xpos, &ypos, par->chroma_location);",
          "content_same": false
        },
        {
          "line": 910,
          "old_api": "end_ebml_master",
          "new_api": "av_q2d",
          "old_text": "end_ebml_master(dyn_cp, meta_element)",
          "new_text": "av_q2d(metadata->min_luminance)",
          "old_line_content": "        end_ebml_master(dyn_cp, meta_element);",
          "new_line_content": "                           av_q2d(metadata->min_luminance));",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": "put_ebml_binary",
          "new_api": "avio_tell",
          "old_text": "put_ebml_binary(pb, MATROSKA_ID_VIDEOCOLOR, colour, colorinfo_size)",
          "new_text": "avio_tell(dyn_cp)",
          "old_line_content": "        put_ebml_binary(pb, MATROSKA_ID_VIDEOCOLOR, colour, colorinfo_size);",
          "new_line_content": "    colorinfo_size = avio_tell(dyn_cp);",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": "AV_WB32",
          "new_api": "put_ebml_uint",
          "old_text": "AV_WB32(private,      0)",
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOPROJECTIONTYPE,\n                      MATROSKA_VIDEO_PROJECTION_TYPE_EQUIRECTANGULAR)",
          "old_line_content": "        AV_WB32(private,      0); // version + flags",
          "new_line_content": "        put_ebml_uint(pb, MATROSKA_ID_VIDEOPROJECTIONTYPE,",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "put_ebml_binary",
          "new_api": "AV_WB32",
          "old_text": "put_ebml_binary(pb, MATROSKA_ID_VIDEOPROJECTIONPRIVATE,\n                        private, 20)",
          "new_text": "AV_WB32(private + 12, spherical->bound_left)",
          "old_line_content": "        put_ebml_binary(pb, MATROSKA_ID_VIDEOPROJECTIONPRIVATE,",
          "new_line_content": "        AV_WB32(private + 12, spherical->bound_left);",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": "AV_WB32",
          "new_api": "put_ebml_uint",
          "old_text": "AV_WB32(private,     0)",
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOPROJECTIONTYPE,\n                      MATROSKA_VIDEO_PROJECTION_TYPE_CUBEMAP)",
          "old_line_content": "        AV_WB32(private,     0); // version + flags",
          "new_line_content": "        put_ebml_uint(pb, MATROSKA_ID_VIDEOPROJECTIONTYPE,",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": "put_ebml_binary",
          "new_api": "AV_WB32",
          "old_text": "put_ebml_binary(pb, MATROSKA_ID_VIDEOPROJECTIONPRIVATE,\n                        private, 12)",
          "new_text": "AV_WB32(private + 4, 0)",
          "old_line_content": "        put_ebml_binary(pb, MATROSKA_ID_VIDEOPROJECTIONPRIVATE,",
          "new_line_content": "        AV_WB32(private + 4, 0); // layout",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": "atoi",
          "new_api": "av_dict_get",
          "old_text": "atoi(tag->value)",
          "new_text": "av_dict_get(st->metadata, \"stereo_mode\", NULL, 0)",
          "old_line_content": "        int stereo_mode = atoi(tag->value);",
          "new_line_content": "    if ((tag = av_dict_get(st->metadata, \"stereo_mode\", NULL, 0)) ||",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(s, AV_LOG_ERROR,\n               \"The specified stereo mode is not valid.\\n\")",
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "        av_log(s, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 1143,
          "old_api": "put_ebml_uid (pb, MATROSKA_ID_TRACKUID,    track->uid)",
          "new_api": "start_ebml_master",
          "old_text": "put_ebml_uid (pb, MATROSKA_ID_TRACKUID,    track->uid)",
          "new_text": "start_ebml_master(pb, MATROSKA_ID_TRACKENTRY, 0)",
          "old_line_content": "    put_ebml_uid (pb, MATROSKA_ID_TRACKUID,    track->uid);",
          "new_line_content": "    track_master = start_ebml_master(pb, MATROSKA_ID_TRACKENTRY, 0);",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": "av_dict_get",
          "new_api": "put_ebml_uint",
          "old_text": "av_dict_get(st->metadata, \"title\", NULL, 0)",
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGLACING, 0)",
          "old_line_content": "    if ((tag = av_dict_get(st->metadata, \"title\", NULL, 0)))",
          "new_line_content": "    put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGLACING, 0);    // no lacing (yet)",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(s, AV_LOG_ERROR,\n                   \"Only VP8 or VP9 or AV1 video and Vorbis or Opus audio and WebVTT subtitles are supported for WebM.\\n\")",
          "old_line_content": "            return AVERROR(EINVAL);",
          "new_line_content": "            av_log(s, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(s, AV_LOG_ERROR, \"Raw RGB is not supported Natively in Matroska, you can use AVI or NUT or\\n\"\n                                        \"If you would like to store it anyway using VFW mode, enable allow_raw_vfw (-allow_raw_vfw 1)\\n\")",
          "old_line_content": "                return AVERROR(EINVAL);",
          "new_line_content": "                av_log(s, AV_LOG_ERROR, \"Raw RGB is not supported Natively in Matroska, you can use AVI or NUT or\\n\"",
          "content_same": false
        },
        {
          "line": 1236,
          "old_api": "av_inv_q",
          "new_api": "put_ebml_uint",
          "old_text": "av_inv_q(st->r_frame_rate)",
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKDEFAULTDURATION, 1000000000LL * st->avg_frame_rate.den / st->avg_frame_rate.num)",
          "old_line_content": "                && av_cmp_q(av_inv_q(st->r_frame_rate), st->time_base) > 0)",
          "new_line_content": "            put_ebml_uint(pb, MATROSKA_ID_TRACKDEFAULTDURATION, 1000000000LL * st->avg_frame_rate.den / st->avg_frame_rate.num);",
          "content_same": false
        },
        {
          "line": 1258,
          "old_api": "put_ebml_uint (pb, MATROSKA_ID_VIDEOPIXELWIDTH , par->width)",
          "new_api": "start_ebml_master",
          "old_text": "put_ebml_uint (pb, MATROSKA_ID_VIDEOPIXELWIDTH , par->width)",
          "new_text": "start_ebml_master(pb, MATROSKA_ID_TRACKVIDEO, 0)",
          "old_line_content": "        put_ebml_uint (pb, MATROSKA_ID_VIDEOPIXELWIDTH , par->width);",
          "new_line_content": "        subinfo = start_ebml_master(pb, MATROSKA_ID_TRACKVIDEO, 0);",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": "mkv_write_field_order",
          "new_api": "put_ebml_uint (pb, MATROSKA_ID_VIDEOPIXELHEIGHT, par->height)",
          "old_text": "mkv_write_field_order(pb, mkv->mode, par->field_order)",
          "new_text": "put_ebml_uint (pb, MATROSKA_ID_VIDEOPIXELHEIGHT, par->height)",
          "old_line_content": "        mkv_write_field_order(pb, mkv->mode, par->field_order);",
          "new_line_content": "        put_ebml_uint (pb, MATROSKA_ID_VIDEOPIXELHEIGHT, par->height);",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": "put_ebml_uint",
          "new_api": "atoi",
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOALPHAMODE, 1)",
          "new_text": "atoi(tag->value)",
          "old_line_content": "            put_ebml_uint(pb, MATROSKA_ID_VIDEOALPHAMODE, 1);",
          "new_line_content": "            ((tag = av_dict_get( s->metadata, \"alpha_mode\", NULL, 0)) && atoi(tag->value)) ||",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": "av_log",
          "new_api": "av_rescale",
          "old_text": "av_log(s, AV_LOG_ERROR, \"Overflow in display width\\n\")",
          "new_text": "av_rescale(par->width, st->sample_aspect_ratio.num, st->sample_aspect_ratio.den)",
          "old_line_content": "                av_log(s, AV_LOG_ERROR, \"Overflow in display width\\n\");",
          "new_line_content": "            int64_t d_width = av_rescale(par->width, st->sample_aspect_ratio.num, st->sample_aspect_ratio.den);",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": "mkv_write_video_color",
          "new_api": "put_ebml_binary",
          "old_text": "mkv_write_video_color(pb, st, par)",
          "new_text": "put_ebml_binary(pb, MATROSKA_ID_VIDEOCOLORSPACE, &color_space, sizeof(color_space))",
          "old_line_content": "        mkv_write_video_color(pb, st, par);",
          "new_line_content": "            put_ebml_binary(pb, MATROSKA_ID_VIDEOCOLORSPACE, &color_space, sizeof(color_space));",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": "end_ebml_master",
          "new_api": "mkv_write_video_projection",
          "old_text": "end_ebml_master(pb, subinfo)",
          "new_text": "mkv_write_video_projection(s, pb, st)",
          "old_line_content": "        end_ebml_master(pb, subinfo);",
          "new_line_content": "        mkv_write_video_projection(s, pb, st);",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": "start_ebml_master",
          "new_api": "put_ebml_string",
          "old_text": "start_ebml_master(pb, MATROSKA_ID_TRACKAUDIO, 6 + 4 * 9)",
          "new_text": "put_ebml_string(pb, MATROSKA_ID_CODECID, \"A_MS/ACM\")",
          "old_line_content": "        subinfo = start_ebml_master(pb, MATROSKA_ID_TRACKAUDIO, 6 + 4 * 9);",
          "new_line_content": "            put_ebml_string(pb, MATROSKA_ID_CODECID, \"A_MS/ACM\");",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": "avio_tell",
          "new_api": "put_ebml_uint  (pb, MATROSKA_ID_AUDIOCHANNELS    , par->channels)",
          "old_text": "avio_tell(pb)",
          "new_text": "put_ebml_uint  (pb, MATROSKA_ID_AUDIOCHANNELS    , par->channels)",
          "old_line_content": "        track->sample_rate_offset = avio_tell(pb);",
          "new_line_content": "        put_ebml_uint  (pb, MATROSKA_ID_AUDIOCHANNELS    , par->channels);",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": "put_ebml_float",
          "new_api": "put_ebml_float (pb, MATROSKA_ID_AUDIOSAMPLINGFREQ, sample_rate)",
          "old_text": "put_ebml_float(pb, MATROSKA_ID_AUDIOOUTSAMPLINGFREQ, output_sample_rate)",
          "new_text": "put_ebml_float (pb, MATROSKA_ID_AUDIOSAMPLINGFREQ, sample_rate)",
          "old_line_content": "            put_ebml_float(pb, MATROSKA_ID_AUDIOOUTSAMPLINGFREQ, output_sample_rate);",
          "new_line_content": "        put_ebml_float (pb, MATROSKA_ID_AUDIOSAMPLINGFREQ, sample_rate);",
          "content_same": false
        },
        {
          "line": 1348,
          "old_api": "av_get_bits_per_sample",
          "new_api": "put_ebml_float",
          "old_text": "av_get_bits_per_sample(par->codec_id)",
          "new_text": "put_ebml_float(pb, MATROSKA_ID_AUDIOOUTSAMPLINGFREQ, output_sample_rate)",
          "old_line_content": "        bit_depth = av_get_bits_per_sample(par->codec_id);",
          "new_line_content": "            put_ebml_float(pb, MATROSKA_ID_AUDIOOUTSAMPLINGFREQ, output_sample_rate);",
          "content_same": false
        },
        {
          "line": 1460,
          "old_api": "strrchr",
          "new_api": "AVERROR",
          "old_text": "strrchr(p, '-')",
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    if ((p = strrchr(p, '-')) &&",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 1478,
          "old_api": "end_ebml_master",
          "new_api": "put_ebml_string",
          "old_text": "end_ebml_master(pb, tag)",
          "new_text": "put_ebml_string(pb, MATROSKA_ID_TAGLANG, lang)",
          "old_line_content": "    end_ebml_master(pb, tag);",
          "new_line_content": "        put_ebml_string(pb, MATROSKA_ID_TAGLANG, lang);",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": "av_freep",
          "new_api": "end_ebml_master",
          "old_text": "av_freep(&key)",
          "new_text": "end_ebml_master(pb, tag)",
          "old_line_content": "    av_freep(&key);",
          "new_line_content": "    end_ebml_master(pb, tag);",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": "put_ebml_uid",
          "new_api": "start_ebml_master",
          "old_text": "put_ebml_uid(*pb, elementid, uid)",
          "new_text": "start_ebml_master(*pb, MATROSKA_ID_TAGTARGETS, 4 + 1 + 8)",
          "old_line_content": "        put_ebml_uid(*pb, elementid, uid);",
          "new_line_content": "    targets = start_ebml_master(*pb, MATROSKA_ID_TAGTARGETS, 4 + 1 + 8);",
          "content_same": false
        },
        {
          "line": 1532,
          "old_api": "mkv_write_simpletag",
          "new_api": "av_dict_get",
          "old_text": "mkv_write_simpletag(*pb, t)",
          "new_text": "av_dict_get(m, \"\", t, AV_DICT_IGNORE_SUFFIX)",
          "old_line_content": "            ret = mkv_write_simpletag(*pb, t);",
          "new_line_content": "    while ((t = av_dict_get(m, \"\", t, AV_DICT_IGNORE_SUFFIX))) {",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": "mkv_check_tag",
          "new_api": "ff_metadata_conv_ctx",
          "old_text": "mkv_check_tag(s->metadata, 0)",
          "new_text": "ff_metadata_conv_ctx(s, ff_mkv_metadata_conv, NULL)",
          "old_line_content": "    if (mkv_check_tag(s->metadata, 0)) {",
          "new_line_content": "    ff_metadata_conv_ctx(s, ff_mkv_metadata_conv, NULL);",
          "content_same": false
        },
        {
          "line": 1592,
          "old_api": "put_ebml_string",
          "new_api": "start_ebml_master",
          "old_text": "put_ebml_string(pb, MATROSKA_ID_TAGNAME, \"DURATION\")",
          "new_text": "start_ebml_master(pb, MATROSKA_ID_SIMPLETAG,\n                                          2 + 1 + 8 + 23)",
          "old_line_content": "            put_ebml_string(pb, MATROSKA_ID_TAGNAME, \"DURATION\");",
          "new_line_content": "            simpletag = start_ebml_master(pb, MATROSKA_ID_SIMPLETAG,",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": "end_ebml_master",
          "new_api": "put_ebml_void",
          "old_text": "end_ebml_master(pb, tag)",
          "new_text": "put_ebml_void(pb, 23)",
          "old_line_content": "            end_ebml_master(pb, tag);",
          "new_line_content": "            put_ebml_void(pb, 23);",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": "put_ebml_uint",
          "new_api": "start_ebml_master",
          "old_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_EDITIONFLAGDEFAULT, 1)",
          "new_text": "start_ebml_master(dyn_cp, MATROSKA_ID_EDITIONENTRY, 0)",
          "old_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_EDITIONFLAGDEFAULT, 1);",
          "new_line_content": "    editionentry = start_ebml_master(dyn_cp, MATROSKA_ID_EDITIONENTRY, 0);",
          "content_same": false
        },
        {
          "line": 1687,
          "old_api": "put_ebml_uint",
          "new_api": "start_ebml_master",
          "old_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_CHAPTERTIMESTART, chapterstart)",
          "new_text": "start_ebml_master(dyn_cp, MATROSKA_ID_CHAPTERATOM, 0)",
          "old_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_CHAPTERTIMESTART, chapterstart);",
          "new_line_content": "        chapteratom = start_ebml_master(dyn_cp, MATROSKA_ID_CHAPTERATOM, 0);",
          "content_same": false
        },
        {
          "line": 1689,
          "old_api": "av_dict_get",
          "new_api": "put_ebml_uint",
          "old_text": "av_dict_get(c->metadata, \"title\", NULL, 0)",
          "new_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_CHAPTERTIMESTART, chapterstart)",
          "old_line_content": "        if ((t = av_dict_get(c->metadata, \"title\", NULL, 0))) {",
          "new_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_CHAPTERTIMESTART, chapterstart);",
          "content_same": false
        },
        {
          "line": 1690,
          "old_api": "start_ebml_master",
          "new_api": "put_ebml_uint",
          "old_text": "start_ebml_master(dyn_cp, MATROSKA_ID_CHAPTERDISPLAY, 0)",
          "new_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_CHAPTERTIMEEND, chapterend)",
          "old_line_content": "            chapterdisplay = start_ebml_master(dyn_cp, MATROSKA_ID_CHAPTERDISPLAY, 0);",
          "new_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_CHAPTERTIMEEND, chapterend);",
          "content_same": false
        },
        {
          "line": 1691,
          "old_api": "put_ebml_string",
          "new_api": "av_dict_get",
          "old_text": "put_ebml_string(dyn_cp, MATROSKA_ID_CHAPSTRING, t->value)",
          "new_text": "av_dict_get(c->metadata, \"title\", NULL, 0)",
          "old_line_content": "            put_ebml_string(dyn_cp, MATROSKA_ID_CHAPSTRING, t->value);",
          "new_line_content": "        if ((t = av_dict_get(c->metadata, \"title\", NULL, 0))) {",
          "content_same": false
        },
        {
          "line": 1692,
          "old_api": "put_ebml_string",
          "new_api": "start_ebml_master",
          "old_text": "put_ebml_string(dyn_cp, MATROSKA_ID_CHAPLANG  , \"und\")",
          "new_text": "start_ebml_master(dyn_cp, MATROSKA_ID_CHAPTERDISPLAY, 0)",
          "old_line_content": "            put_ebml_string(dyn_cp, MATROSKA_ID_CHAPLANG  , \"und\");",
          "new_line_content": "            chapterdisplay = start_ebml_master(dyn_cp, MATROSKA_ID_CHAPTERDISPLAY, 0);",
          "content_same": false
        },
        {
          "line": 1693,
          "old_api": "end_ebml_master",
          "new_api": "put_ebml_string",
          "old_text": "end_ebml_master(dyn_cp, chapterdisplay)",
          "new_text": "put_ebml_string(dyn_cp, MATROSKA_ID_CHAPSTRING, t->value)",
          "old_line_content": "            end_ebml_master(dyn_cp, chapterdisplay);",
          "new_line_content": "            put_ebml_string(dyn_cp, MATROSKA_ID_CHAPSTRING, t->value);",
          "content_same": false
        },
        {
          "line": 1697,
          "old_api": "mkv_check_tag",
          "new_api": "end_ebml_master",
          "old_text": "mkv_check_tag(c->metadata, MATROSKA_ID_TAGTARGETS_CHAPTERUID)",
          "new_text": "end_ebml_master(dyn_cp, chapteratom)",
          "old_line_content": "        if (tags && mkv_check_tag(c->metadata, MATROSKA_ID_TAGTARGETS_CHAPTERUID)) {",
          "new_line_content": "        end_ebml_master(dyn_cp, chapteratom);",
          "content_same": false
        },
        {
          "line": 1767,
          "old_api": "av_dict_get",
          "new_api": "start_ebml_master",
          "old_text": "av_dict_get(st->metadata, \"title\", NULL, 0)",
          "new_text": "start_ebml_master(dyn_cp, MATROSKA_ID_ATTACHEDFILE, 0)",
          "old_line_content": "        if (t = av_dict_get(st->metadata, \"title\", NULL, 0))",
          "new_line_content": "        attached_file = start_ebml_master(dyn_cp, MATROSKA_ID_ATTACHEDFILE, 0);",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": "av_log",
          "new_api": "put_ebml_string",
          "old_text": "av_log(s, AV_LOG_ERROR, \"Attachment stream %d has no filename tag.\\n\", i)",
          "new_text": "put_ebml_string(dyn_cp, MATROSKA_ID_FILEDESC, t->value)",
          "old_line_content": "            av_log(s, AV_LOG_ERROR, \"Attachment stream %d has no filename tag.\\n\", i);",
          "new_line_content": "            put_ebml_string(dyn_cp, MATROSKA_ID_FILEDESC, t->value);",
          "content_same": false
        },
        {
          "line": 1771,
          "old_api": "ffio_free_dyn_buf",
          "new_api": "av_dict_get",
          "old_text": "ffio_free_dyn_buf(&dyn_cp)",
          "new_text": "av_dict_get(st->metadata, \"filename\", NULL, 0)",
          "old_line_content": "            ffio_free_dyn_buf(&dyn_cp);",
          "new_line_content": "        if (!(t = av_dict_get(st->metadata, \"filename\", NULL, 0))) {",
          "content_same": false
        },
        {
          "line": 1772,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(s, AV_LOG_ERROR, \"Attachment stream %d has no filename tag.\\n\", i)",
          "old_line_content": "            return AVERROR(EINVAL);",
          "new_line_content": "            av_log(s, AV_LOG_ERROR, \"Attachment stream %d has no filename tag.\\n\", i);",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": "put_ebml_string",
          "new_api": "AVERROR",
          "old_text": "put_ebml_string(dyn_cp, MATROSKA_ID_FILENAME, t->value)",
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "        put_ebml_string(dyn_cp, MATROSKA_ID_FILENAME, t->value);",
          "new_line_content": "            return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 1776,
          "old_api": "get_mimetype",
          "new_api": "put_ebml_string",
          "old_text": "get_mimetype(st)",
          "new_text": "put_ebml_string(dyn_cp, MATROSKA_ID_FILENAME, t->value)",
          "old_line_content": "        mimetype = get_mimetype(st);",
          "new_line_content": "        put_ebml_string(dyn_cp, MATROSKA_ID_FILENAME, t->value);",
          "content_same": false
        },
        {
          "line": 1778,
          "old_api": "put_ebml_string",
          "new_api": "get_mimetype",
          "old_text": "put_ebml_string(dyn_cp, MATROSKA_ID_FILEMIMETYPE, mimetype)",
          "new_text": "get_mimetype(st)",
          "old_line_content": "        put_ebml_string(dyn_cp, MATROSKA_ID_FILEMIMETYPE, mimetype);",
          "new_line_content": "        mimetype = get_mimetype(st);",
          "content_same": false
        },
        {
          "line": 1779,
          "old_api": "put_ebml_binary",
          "new_api": "av_assert0",
          "old_text": "put_ebml_binary(dyn_cp, MATROSKA_ID_FILEDATA, st->codecpar->extradata, st->codecpar->extradata_size)",
          "new_text": "av_assert0(mimetype)",
          "old_line_content": "        put_ebml_binary(dyn_cp, MATROSKA_ID_FILEDATA, st->codecpar->extradata, st->codecpar->extradata_size);",
          "new_line_content": "        av_assert0(mimetype);",
          "content_same": false
        },
        {
          "line": 1780,
          "old_api": "put_ebml_uid",
          "new_api": "put_ebml_string",
          "old_text": "put_ebml_uid(dyn_cp, MATROSKA_ID_FILEUID, track->uid)",
          "new_text": "put_ebml_string(dyn_cp, MATROSKA_ID_FILEMIMETYPE, mimetype)",
          "old_line_content": "        put_ebml_uid(dyn_cp, MATROSKA_ID_FILEUID, track->uid);",
          "new_line_content": "        put_ebml_string(dyn_cp, MATROSKA_ID_FILEMIMETYPE, mimetype);",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": "end_ebml_master",
          "new_api": "put_ebml_binary",
          "old_text": "end_ebml_master(dyn_cp, attached_file)",
          "new_text": "put_ebml_binary(dyn_cp, MATROSKA_ID_FILEDATA, st->codecpar->extradata, st->codecpar->extradata_size)",
          "old_line_content": "        end_ebml_master(dyn_cp, attached_file);",
          "new_line_content": "        put_ebml_binary(dyn_cp, MATROSKA_ID_FILEDATA, st->codecpar->extradata, st->codecpar->extradata_size);",
          "content_same": false
        },
        {
          "line": 1783,
          "old_api": "end_ebml_master_crc32",
          "new_api": "end_ebml_master",
          "old_text": "end_ebml_master_crc32(pb, &dyn_cp, mkv,\n                                 MATROSKA_ID_ATTACHMENTS, 0, 0, 1)",
          "new_text": "end_ebml_master(dyn_cp, attached_file)",
          "old_line_content": "    return end_ebml_master_crc32(pb, &dyn_cp, mkv,",
          "new_line_content": "        end_ebml_master(dyn_cp, attached_file);",
          "content_same": false
        },
        {
          "line": 1803,
          "old_api": "av_parse_time",
          "new_api": "av_dict_get",
          "old_text": "av_parse_time(&us, duration->value, 1)",
          "new_text": "av_dict_get(s->streams[i]->metadata, \"DURATION\", NULL, 0)",
          "old_line_content": "        if (duration && (av_parse_time(&us, duration->value, 1) == 0))",
          "new_line_content": "        duration = av_dict_get(s->streams[i]->metadata, \"DURATION\", NULL, 0);",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": "put_ebml_uint  (pb, EBML_ID_EBMLREADVERSION   ,           1)",
          "new_api": "start_ebml_master",
          "old_text": "put_ebml_uint  (pb, EBML_ID_EBMLREADVERSION   ,           1)",
          "new_text": "start_ebml_master(pb, EBML_ID_HEADER, MAX_EBML_HEADER_SIZE)",
          "old_line_content": "    put_ebml_uint  (pb, EBML_ID_EBMLREADVERSION   ,           1);",
          "new_line_content": "    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, MAX_EBML_HEADER_SIZE);",
          "content_same": false
        },
        {
          "line": 1835,
          "old_api": "put_ebml_uint  (pb, EBML_ID_EBMLMAXIDLENGTH   ,           4)",
          "new_api": "put_ebml_uint  (pb, EBML_ID_EBMLVERSION       ,           1)",
          "old_text": "put_ebml_uint  (pb, EBML_ID_EBMLMAXIDLENGTH   ,           4)",
          "new_text": "put_ebml_uint  (pb, EBML_ID_EBMLVERSION       ,           1)",
          "old_line_content": "    put_ebml_uint  (pb, EBML_ID_EBMLMAXIDLENGTH   ,           4);",
          "new_line_content": "    put_ebml_uint  (pb, EBML_ID_EBMLVERSION       ,           1);",
          "content_same": false
        },
        {
          "line": 1836,
          "old_api": "put_ebml_uint  (pb, EBML_ID_EBMLMAXSIZELENGTH ,           8)",
          "new_api": "put_ebml_uint  (pb, EBML_ID_EBMLREADVERSION   ,           1)",
          "old_text": "put_ebml_uint  (pb, EBML_ID_EBMLMAXSIZELENGTH ,           8)",
          "new_text": "put_ebml_uint  (pb, EBML_ID_EBMLREADVERSION   ,           1)",
          "old_line_content": "    put_ebml_uint  (pb, EBML_ID_EBMLMAXSIZELENGTH ,           8);",
          "new_line_content": "    put_ebml_uint  (pb, EBML_ID_EBMLREADVERSION   ,           1);",
          "content_same": false
        },
        {
          "line": 1837,
          "old_api": "put_ebml_string",
          "new_api": "put_ebml_uint  (pb, EBML_ID_EBMLMAXIDLENGTH   ,           4)",
          "old_text": "put_ebml_string(pb, EBML_ID_DOCTYPE           , s->oformat->name)",
          "new_text": "put_ebml_uint  (pb, EBML_ID_EBMLMAXIDLENGTH   ,           4)",
          "old_line_content": "    put_ebml_string(pb, EBML_ID_DOCTYPE           , s->oformat->name);",
          "new_line_content": "    put_ebml_uint  (pb, EBML_ID_EBMLMAXIDLENGTH   ,           4);",
          "content_same": false
        },
        {
          "line": 1838,
          "old_api": "put_ebml_uint  (pb, EBML_ID_DOCTYPEVERSION    ,     version)",
          "new_api": "put_ebml_uint  (pb, EBML_ID_EBMLMAXSIZELENGTH ,           8)",
          "old_text": "put_ebml_uint  (pb, EBML_ID_DOCTYPEVERSION    ,     version)",
          "new_text": "put_ebml_uint  (pb, EBML_ID_EBMLMAXSIZELENGTH ,           8)",
          "old_line_content": "    put_ebml_uint  (pb, EBML_ID_DOCTYPEVERSION    ,     version);",
          "new_line_content": "    put_ebml_uint  (pb, EBML_ID_EBMLMAXSIZELENGTH ,           8);",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": "put_ebml_uint  (pb, EBML_ID_DOCTYPEREADVERSION,           2)",
          "new_api": "put_ebml_string",
          "old_text": "put_ebml_uint  (pb, EBML_ID_DOCTYPEREADVERSION,           2)",
          "new_text": "put_ebml_string(pb, EBML_ID_DOCTYPE           , s->oformat->name)",
          "old_line_content": "    put_ebml_uint  (pb, EBML_ID_DOCTYPEREADVERSION,           2);",
          "new_line_content": "    put_ebml_string(pb, EBML_ID_DOCTYPE           , s->oformat->name);",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": "end_ebml_master",
          "new_api": "put_ebml_uint  (pb, EBML_ID_DOCTYPEVERSION    ,     version)",
          "old_text": "end_ebml_master(pb, ebml_header)",
          "new_text": "put_ebml_uint  (pb, EBML_ID_DOCTYPEVERSION    ,     version)",
          "old_line_content": "    end_ebml_master(pb, ebml_header);",
          "new_line_content": "    put_ebml_uint  (pb, EBML_ID_DOCTYPEVERSION    ,     version);",
          "content_same": false
        },
        {
          "line": 1842,
          "old_api": "put_ebml_id",
          "new_api": "end_ebml_master",
          "old_text": "put_ebml_id(pb, MATROSKA_ID_SEGMENT)",
          "new_text": "end_ebml_master(pb, ebml_header)",
          "old_line_content": "    put_ebml_id(pb, MATROSKA_ID_SEGMENT);",
          "new_line_content": "    end_ebml_master(pb, ebml_header);",
          "content_same": false
        },
        {
          "line": 1844,
          "old_api": "avio_tell",
          "new_api": "put_ebml_id",
          "old_text": "avio_tell(pb)",
          "new_text": "put_ebml_id(pb, MATROSKA_ID_SEGMENT)",
          "old_line_content": "    mkv->segment_offset = avio_tell(pb);",
          "new_line_content": "    put_ebml_id(pb, MATROSKA_ID_SEGMENT);",
          "content_same": false
        },
        {
          "line": 1850,
          "old_api": "start_ebml_master_crc32",
          "new_api": "mkv_start_seekhead",
          "old_text": "start_ebml_master_crc32(&mkv->info.bc, mkv)",
          "new_text": "mkv_start_seekhead(mkv, pb)",
          "old_line_content": "    ret = start_ebml_master_crc32(&mkv->info.bc, mkv);",
          "new_line_content": "    mkv_start_seekhead(mkv, pb);",
          "content_same": false
        },
        {
          "line": 1857,
          "old_api": "put_ebml_string",
          "new_api": "put_ebml_uint",
          "old_text": "put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value)",
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000)",
          "old_line_content": "        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);",
          "new_line_content": "    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);",
          "content_same": false
        },
        {
          "line": 1885,
          "old_api": "get_metadata_duration",
          "new_api": "avio_tell",
          "old_text": "get_metadata_duration(s)",
          "new_text": "avio_tell(pb)",
          "old_line_content": "        int64_t metadata_duration = get_metadata_duration(s);",
          "new_line_content": "    mkv->duration_offset = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": "av_log",
          "new_api": "av_rescale",
          "old_text": "av_log(s, AV_LOG_DEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration)",
          "new_text": "av_rescale(s->duration, 1000, AV_TIME_BASE)",
          "old_line_content": "            av_log(s, AV_LOG_DEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration);",
          "new_line_content": "            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);",
          "content_same": false
        },
        {
          "line": 1892,
          "old_api": "av_rescale",
          "new_api": "av_log",
          "old_text": "av_rescale(metadata_duration, 1000, AV_TIME_BASE)",
          "new_text": "av_log(s, AV_LOG_DEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration)",
          "old_line_content": "            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);",
          "new_line_content": "            av_log(s, AV_LOG_DEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration);",
          "content_same": false
        },
        {
          "line": 1894,
          "old_api": "av_log",
          "new_api": "av_rescale",
          "old_text": "av_log(s, AV_LOG_DEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration)",
          "new_text": "av_rescale(metadata_duration, 1000, AV_TIME_BASE)",
          "old_line_content": "            av_log(s, AV_LOG_DEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration);",
          "new_line_content": "            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);",
          "content_same": false
        },
        {
          "line": 1896,
          "old_api": "put_ebml_void",
          "new_api": "av_log",
          "old_text": "put_ebml_void(pb, 11)",
          "new_text": "av_log(s, AV_LOG_DEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration)",
          "old_line_content": "            put_ebml_void(pb, 11);              // assumes double-precision float to be written",
          "new_line_content": "            av_log(s, AV_LOG_DEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration);",
          "content_same": false
        },
        {
          "line": 1984,
          "old_api": "AVERROR",
          "new_api": "av_malloc",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "av_malloc(srclen)",
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "    dst = av_malloc(srclen);",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": "AV_RB32",
          "new_api": "ff_avc_parse_nal_units_buf",
          "old_text": "AV_RB32(par->extradata)",
          "new_text": "ff_avc_parse_nal_units_buf(pkt->data, &data, &size)",
          "old_line_content": "               (AV_RB24(par->extradata) == 1 || AV_RB32(par->extradata) == 1)) {",
          "new_line_content": "        err = ff_avc_parse_nal_units_buf(pkt->data, &data, &size);",
          "content_same": false
        },
        {
          "line": 2060,
          "old_api": "ff_hevc_annexb2mp4_buf",
          "new_api": "AV_RB32",
          "old_text": "ff_hevc_annexb2mp4_buf(pkt->data, &data, &size, 0, NULL)",
          "new_text": "AV_RB32(par->extradata)",
          "old_line_content": "        err = ff_hevc_annexb2mp4_buf(pkt->data, &data, &size, 0, NULL);",
          "new_line_content": "               (AV_RB24(par->extradata) == 1 || AV_RB32(par->extradata) == 1)) {",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": "ff_av1_filter_obus_buf",
          "new_api": "ff_hevc_annexb2mp4_buf",
          "old_text": "ff_av1_filter_obus_buf(pkt->data, &data, &size, &offset)",
          "new_text": "ff_hevc_annexb2mp4_buf(pkt->data, &data, &size, 0, NULL)",
          "old_line_content": "        err = ff_av1_filter_obus_buf(pkt->data, &data, &size, &offset);",
          "new_line_content": "        err = ff_hevc_annexb2mp4_buf(pkt->data, &data, &size, 0, NULL);",
          "content_same": false
        },
        {
          "line": 2064,
          "old_api": "mkv_strip_wavpack",
          "new_api": "ff_av1_filter_obus_buf",
          "old_text": "mkv_strip_wavpack(pkt->data, &data, &size)",
          "new_text": "ff_av1_filter_obus_buf(pkt->data, &data, &size, &offset)",
          "old_line_content": "        err = mkv_strip_wavpack(pkt->data, &data, &size);",
          "new_line_content": "        err = ff_av1_filter_obus_buf(pkt->data, &data, &size, &offset);",
          "content_same": false
        },
        {
          "line": 2110,
          "old_api": "put_ebml_num",
          "new_api": "put_ebml_id",
          "old_text": "put_ebml_num(pb, track_number, track->track_num_size)",
          "new_text": "put_ebml_id(pb, blockid)",
          "old_line_content": "    put_ebml_num(pb, track_number, track->track_num_size);",
          "new_line_content": "    put_ebml_id(pb, blockid);",
          "content_same": false
        },
        {
          "line": 2111,
          "old_api": "avio_wb16",
          "new_api": "put_ebml_length",
          "old_text": "avio_wb16(pb, ts - mkv->cluster_pts)",
          "new_text": "put_ebml_length(pb, size + track->track_num_size + 3, 0)",
          "old_line_content": "    avio_wb16(pb, ts - mkv->cluster_pts);",
          "new_line_content": "    put_ebml_length(pb, size + track->track_num_size + 3, 0);",
          "content_same": false
        },
        {
          "line": 2112,
          "old_api": "avio_w8",
          "new_api": "put_ebml_num",
          "old_text": "avio_w8(pb, (blockid == MATROSKA_ID_SIMPLEBLOCK && keyframe) ? (1 << 7) : 0)",
          "new_text": "put_ebml_num(pb, track_number, track->track_num_size)",
          "old_line_content": "    avio_w8(pb, (blockid == MATROSKA_ID_SIMPLEBLOCK && keyframe) ? (1 << 7) : 0);",
          "new_line_content": "    put_ebml_num(pb, track_number, track->track_num_size);",
          "content_same": false
        },
        {
          "line": 2113,
          "old_api": "avio_write",
          "new_api": "avio_wb16",
          "old_text": "avio_write(pb, data + offset, size)",
          "new_text": "avio_wb16(pb, ts - mkv->cluster_pts)",
          "old_line_content": "    avio_write(pb, data + offset, size);",
          "new_line_content": "    avio_wb16(pb, ts - mkv->cluster_pts);",
          "content_same": false
        },
        {
          "line": 2115,
          "old_api": "av_free",
          "new_api": "avio_write",
          "old_text": "av_free(data)",
          "new_text": "avio_write(pb, data + offset, size)",
          "old_line_content": "        av_free(data);",
          "new_line_content": "    avio_write(pb, data + offset, size);",
          "content_same": false
        },
        {
          "line": 2132,
          "old_api": "end_ebml_master",
          "new_api": "put_ebml_binary",
          "old_text": "end_ebml_master(pb, block_more)",
          "new_text": "put_ebml_binary(pb, MATROSKA_ID_BLOCKADDITIONAL,\n                        side_data, side_data_size)",
          "old_line_content": "        end_ebml_master(pb, block_more);",
          "new_line_content": "        put_ebml_binary(pb, MATROSKA_ID_BLOCKADDITIONAL,",
          "content_same": false
        },
        {
          "line": 2178,
          "old_api": "put_ebml_id",
          "new_api": "mkv_blockgroup_size",
          "old_text": "put_ebml_id(pb, MATROSKA_ID_BLOCK)",
          "new_text": "mkv_blockgroup_size(size, track->track_num_size)",
          "old_line_content": "    put_ebml_id(pb, MATROSKA_ID_BLOCK);",
          "new_line_content": "                                   mkv_blockgroup_size(size, track->track_num_size));",
          "content_same": false
        },
        {
          "line": 2180,
          "old_api": "put_ebml_num",
          "new_api": "put_ebml_id",
          "old_text": "put_ebml_num(pb, track->track_num, track->track_num_size)",
          "new_text": "put_ebml_id(pb, MATROSKA_ID_BLOCK)",
          "old_line_content": "    put_ebml_num(pb, track->track_num, track->track_num_size);",
          "new_line_content": "    put_ebml_id(pb, MATROSKA_ID_BLOCK);",
          "content_same": false
        },
        {
          "line": 2181,
          "old_api": "avio_wb16",
          "new_api": "put_ebml_length",
          "old_text": "avio_wb16(pb, ts - mkv->cluster_pts)",
          "new_text": "put_ebml_length(pb, size + track->track_num_size + 3, 0)",
          "old_line_content": "    avio_wb16(pb, ts - mkv->cluster_pts);",
          "new_line_content": "    put_ebml_length(pb, size + track->track_num_size + 3, 0);",
          "content_same": false
        },
        {
          "line": 2182,
          "old_api": "avio_w8",
          "new_api": "put_ebml_num",
          "old_text": "avio_w8(pb, flags)",
          "new_text": "put_ebml_num(pb, track->track_num, track->track_num_size)",
          "old_line_content": "    avio_w8(pb, flags);",
          "new_line_content": "    put_ebml_num(pb, track->track_num, track->track_num_size);",
          "content_same": false
        },
        {
          "line": 2188,
          "old_api": "put_ebml_uint",
          "new_api": "avio_printf",
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, pkt->duration)",
          "new_text": "avio_printf(pb, \"%.*s\\n%.*s\\n%.*s\", id_size_int, id, settings_size_int, settings, pkt->size, pkt->data)",
          "old_line_content": "    put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, pkt->duration);",
          "new_line_content": "    avio_printf(pb, \"%.*s\\n%.*s\\n%.*s\", id_size_int, id, settings_size_int, settings, pkt->size, pkt->data);",
          "content_same": false
        },
        {
          "line": 2240,
          "old_api": "mkv_write_codecprivate",
          "new_api": "memcpy",
          "old_text": "mkv_write_codecprivate(s, mkv->track.bc, par, 1, 0)",
          "new_text": "memcpy(par->extradata, side_data, side_data_size)",
          "old_line_content": "            mkv_write_codecprivate(s, mkv->track.bc, par, 1, 0);",
          "new_line_content": "            memcpy(par->extradata, side_data, side_data_size);",
          "content_same": false
        },
        {
          "line": 2241,
          "old_api": "avio_tell",
          "new_api": "avio_seek",
          "old_text": "avio_tell(mkv->track.bc)",
          "new_text": "avio_seek(mkv->track.bc, track->codecpriv_offset, SEEK_SET)",
          "old_line_content": "            filler = MAX_PCE_SIZE + 2 + 4 - (avio_tell(mkv->track.bc) - track->codecpriv_offset);",
          "new_line_content": "            avio_seek(mkv->track.bc, track->codecpriv_offset, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 2243,
          "old_api": "put_ebml_void",
          "new_api": "avio_tell",
          "old_text": "put_ebml_void(mkv->track.bc, filler)",
          "new_text": "avio_tell(mkv->track.bc)",
          "old_line_content": "                put_ebml_void(mkv->track.bc, filler);",
          "new_line_content": "            filler = MAX_PCE_SIZE + 2 + 4 - (avio_tell(mkv->track.bc) - track->codecpriv_offset);",
          "content_same": false
        },
        {
          "line": 2245,
          "old_api": "put_ebml_float",
          "new_api": "put_ebml_void",
          "old_text": "put_ebml_float(mkv->track.bc, MATROSKA_ID_AUDIOSAMPLINGFREQ, track->sample_rate)",
          "new_text": "put_ebml_void(mkv->track.bc, filler)",
          "old_line_content": "            put_ebml_float(mkv->track.bc, MATROSKA_ID_AUDIOSAMPLINGFREQ, track->sample_rate);",
          "new_line_content": "                put_ebml_void(mkv->track.bc, filler);",
          "content_same": false
        },
        {
          "line": 2246,
          "old_api": "put_ebml_float",
          "new_api": "avio_seek",
          "old_text": "put_ebml_float(mkv->track.bc, MATROSKA_ID_AUDIOOUTSAMPLINGFREQ, output_sample_rate)",
          "new_text": "avio_seek(mkv->track.bc, track->sample_rate_offset, SEEK_SET)",
          "old_line_content": "            put_ebml_float(mkv->track.bc, MATROSKA_ID_AUDIOOUTSAMPLINGFREQ, output_sample_rate);",
          "new_line_content": "            avio_seek(mkv->track.bc, track->sample_rate_offset, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(s, AV_LOG_ERROR, \"Invalid FLAC STREAMINFO metadata for output stream %d\\n\",\n                       pkt->stream_index)",
          "old_line_content": "                return AVERROR(EINVAL);",
          "new_line_content": "                av_log(s, AV_LOG_ERROR, \"Invalid FLAC STREAMINFO metadata for output stream %d\\n\",",
          "content_same": false
        },
        {
          "line": 2286,
          "old_api": "put_ebml_binary",
          "new_api": "avio_seek",
          "old_text": "put_ebml_binary(mkv->track.bc, MATROSKA_ID_CODECPRIVATE, codecpriv, 4)",
          "new_text": "avio_seek(mkv->track.bc, track->codecpriv_offset, SEEK_SET)",
          "old_line_content": "            put_ebml_binary(mkv->track.bc, MATROSKA_ID_CODECPRIVATE, codecpriv, 4);",
          "new_line_content": "            avio_seek(mkv->track.bc, track->codecpriv_offset, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 2288,
          "old_api": "ff_alloc_extradata",
          "new_api": "put_ebml_binary",
          "old_text": "ff_alloc_extradata(par, side_data_size)",
          "new_text": "put_ebml_binary(mkv->track.bc, MATROSKA_ID_CODECPRIVATE, codecpriv, 4)",
          "old_line_content": "            ret = ff_alloc_extradata(par, side_data_size);",
          "new_line_content": "            put_ebml_binary(mkv->track.bc, MATROSKA_ID_CODECPRIVATE, codecpriv, 4);",
          "content_same": false
        },
        {
          "line": 2338,
          "old_api": "FFMAX",
          "new_api": "avio_tell",
          "old_text": "FFMAX(0, ts)",
          "new_text": "avio_tell(s->pb)",
          "old_line_content": "        mkv->cluster_pts = FFMAX(0, ts);",
          "new_line_content": "        mkv->cluster_pos = avio_tell(s->pb);",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": "av_log",
          "new_api": "FFMAX",
          "old_text": "av_log(s, AV_LOG_DEBUG,\n               \"Starting new cluster with timestamp \"\n               \"%\" PRId64 \" at offset %\" PRId64 \" bytes\\n\",\n               mkv->cluster_pts, mkv->cluster_pos)",
          "new_text": "FFMAX(0, ts)",
          "old_line_content": "        av_log(s, AV_LOG_DEBUG,",
          "new_line_content": "        put_ebml_uint(mkv->cluster_bc, MATROSKA_ID_CLUSTERTIMECODE, FFMAX(0, ts));",
          "content_same": false
        },
        {
          "line": 2459,
          "old_api": "av_log",
          "new_api": "av_packet_unref",
          "old_text": "av_log(s, AV_LOG_ERROR,\n                   \"Could not write cached audio packet ret:%d\\n\", ret)",
          "new_text": "av_packet_unref(mkv->cur_audio_pkt)",
          "old_line_content": "            av_log(s, AV_LOG_ERROR,",
          "new_line_content": "        av_packet_unref(mkv->cur_audio_pkt);",
          "content_same": false
        },
        {
          "line": 2471,
          "old_api": "mkv_write_packet_internal",
          "new_api": "av_packet_ref",
          "old_text": "mkv_write_packet_internal(s, pkt)",
          "new_text": "av_packet_ref(mkv->cur_audio_pkt, pkt)",
          "old_line_content": "        ret = mkv_write_packet_internal(s, pkt);",
          "new_line_content": "            ret = av_packet_ref(mkv->cur_audio_pkt, pkt);",
          "content_same": false
        },
        {
          "line": 2486,
          "old_api": "avio_tell",
          "new_api": "av_log",
          "old_text": "avio_tell(s->pb)",
          "new_text": "av_log(s, AV_LOG_DEBUG,\n                   \"Flushing cluster at offset %\" PRIu64 \" bytes\\n\",\n                   avio_tell(s->pb))",
          "old_line_content": "                   avio_tell(s->pb));",
          "new_line_content": "            av_log(s, AV_LOG_DEBUG,",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": "av_log",
          "new_api": "mkv_write_packet_internal",
          "old_text": "av_log(s, AV_LOG_ERROR,\n                   \"Could not write cached audio packet ret:%d\\n\", ret)",
          "new_text": "mkv_write_packet_internal(s, mkv->cur_audio_pkt)",
          "old_line_content": "            av_log(s, AV_LOG_ERROR,",
          "new_line_content": "        ret = mkv_write_packet_internal(s, mkv->cur_audio_pkt);",
          "content_same": false
        },
        {
          "line": 2577,
          "old_api": "avio_tell",
          "new_api": "put_ebml_void",
          "old_text": "avio_tell(pb)",
          "new_text": "put_ebml_void(pb, mkv->reserve_cues_space - size)",
          "old_line_content": "            endpos = avio_tell(pb);",
          "new_line_content": "                put_ebml_void(pb, mkv->reserve_cues_space - size);",
          "content_same": false
        },
        {
          "line": 2586,
          "old_api": "put_ebml_length",
          "new_api": "avio_seek",
          "old_text": "put_ebml_length(pb, endpos - mkv->segment_offset, 8)",
          "new_text": "avio_seek(pb, mkv->segment_offset - 8, SEEK_SET)",
          "old_line_content": "        put_ebml_length(pb, endpos - mkv->segment_offset, 8);",
          "new_line_content": "        if ((ret64 = avio_seek(pb, mkv->segment_offset - 8, SEEK_SET)) < 0)",
          "content_same": false
        },
        {
          "line": 2597,
          "old_api": "put_ebml_float",
          "new_api": "av_log",
          "old_text": "put_ebml_float(mkv->info.bc, MATROSKA_ID_DURATION, mkv->duration)",
          "new_text": "av_log(s, AV_LOG_DEBUG, \"end duration = %\" PRIu64 \"\\n\", mkv->duration)",
          "old_line_content": "        put_ebml_float(mkv->info.bc, MATROSKA_ID_DURATION, mkv->duration);",
          "new_line_content": "        av_log(s, AV_LOG_DEBUG, \"end duration = %\" PRIu64 \"\\n\", mkv->duration);",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": "end_ebml_master_crc32",
          "new_api": "avio_seek",
          "old_text": "end_ebml_master_crc32(pb, &mkv->info.bc, mkv,\n                                    MATROSKA_ID_INFO, 0, 0, 0)",
          "new_text": "avio_seek(mkv->info.bc, mkv->duration_offset, SEEK_SET)",
          "old_line_content": "        ret = end_ebml_master_crc32(pb, &mkv->info.bc, mkv,",
          "new_line_content": "        avio_seek(mkv->info.bc, mkv->duration_offset, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 2629,
          "old_api": "snprintf",
          "new_api": "avio_seek",
          "old_text": "snprintf(duration_string, 20, \"%02d:%02d:%012.9f\",\n                         (int) duration_sec / 3600, ((int) duration_sec / 60) % 60,\n                         fmod(duration_sec, 60))",
          "new_text": "avio_seek(mkv->tags.bc, track->duration_offset, SEEK_SET)",
          "old_line_content": "                snprintf(duration_string, 20, \"%02d:%02d:%012.9f\",",
          "new_line_content": "                avio_seek(mkv->tags.bc, track->duration_offset, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 2631,
          "old_api": "fmod",
          "new_api": "snprintf",
          "old_text": "fmod(duration_sec, 60)",
          "new_text": "snprintf(duration_string, 20, \"%02d:%02d:%012.9f\",\n                         (int) duration_sec / 3600, ((int) duration_sec / 60) % 60,\n                         fmod(duration_sec, 60))",
          "old_line_content": "                         fmod(duration_sec, 60));",
          "new_line_content": "                snprintf(duration_string, 20, \"%02d:%02d:%012.9f\",",
          "content_same": false
        },
        {
          "line": 2633,
          "old_api": "put_ebml_binary",
          "new_api": "fmod",
          "old_text": "put_ebml_binary(mkv->tags.bc, MATROSKA_ID_TAGSTRING, duration_string, 20)",
          "new_text": "fmod(duration_sec, 60)",
          "old_line_content": "                put_ebml_binary(mkv->tags.bc, MATROSKA_ID_TAGSTRING, duration_string, 20);",
          "new_line_content": "                         fmod(duration_sec, 60));",
          "content_same": false
        },
        {
          "line": 2710,
          "old_api": "avcodec_get_name",
          "new_api": "av_log",
          "old_text": "avcodec_get_name(s->streams[i]->codecpar->codec_id)",
          "new_text": "av_log(s, AV_LOG_ERROR,\n                   \"The Matroska muxer does not yet support muxing %s\\n\",\n                   avcodec_get_name(s->streams[i]->codecpar->codec_id))",
          "old_line_content": "                   avcodec_get_name(s->streams[i]->codecpar->codec_id));",
          "new_line_content": "            av_log(s, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 2728,
          "old_api": "AVERROR",
          "new_api": "av_packet_alloc",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "av_packet_alloc()",
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "    mkv->cur_audio_pkt = av_packet_alloc();",
          "content_same": false
        },
        {
          "line": 2731,
          "old_api": "AVERROR",
          "new_api": "av_mallocz_array",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks))",
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));",
          "content_same": false
        },
        {
          "line": 2758,
          "old_api": "get_mimetype",
          "new_api": "av_log",
          "old_text": "get_mimetype(st)",
          "new_text": "av_log(s, AV_LOG_WARNING, \"Stream %d will be ignored \"\n                       \"as WebM doesn't support attachments.\\n\", i)",
          "old_line_content": "            } else if (!get_mimetype(st)) {",
          "new_line_content": "                av_log(s, AV_LOG_WARNING, \"Stream %d will be ignored \"",
          "content_same": false
        },
        {
          "line": 2761,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(s, AV_LOG_ERROR, \"Attachment stream %d has no mimetype \"\n                       \"tag and it cannot be deduced from the codec id.\\n\", i)",
          "old_line_content": "                return AVERROR(EINVAL);",
          "new_line_content": "                av_log(s, AV_LOG_ERROR, \"Attachment stream %d has no mimetype \"",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2049,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_DEBUG,\n           \"Writing block of size %d with pts %\" PRId64 \", dts %\" PRId64 \", \"\n           \"duration %\" PRId64 \" at relative offset %\" PRId64 \" in cluster \"\n           \"at offset %\" PRId64 \". TrackNumber %u, keyframe %d\\n\",\n           pkt->size, pkt->pts, pkt->dts, pkt->duration, avio_tell(pb),\n           mkv->cluster_pos, track_number, keyframe != 0)",
          "old_line_content": "           \"duration %\" PRId64 \" at relative offset %\" PRId64 \" in cluster \"",
          "new_line_content": "    av_log(s, AV_LOG_DEBUG,",
          "content_same": false
        },
        {
          "line": 2053,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "",
          "new_line_content": "           pkt->size, pkt->pts, pkt->dts, pkt->duration, avio_tell(pb),",
          "content_same": false
        },
        {
          "line": 2057,
          "old_api": null,
          "new_api": "AV_RB32",
          "old_text": null,
          "new_text": "AV_RB32(par->extradata)",
          "old_line_content": "    } else if (par->codec_id == AV_CODEC_ID_HEVC && par->extradata_size > 6 &&",
          "new_line_content": "        (AV_RB24(par->extradata) == 1 || AV_RB32(par->extradata) == 1)) {",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": null,
          "new_api": "mkv_strip_wavpack",
          "old_text": null,
          "new_text": "mkv_strip_wavpack(pkt->data, &data, &size)",
          "old_line_content": "        data = pkt->data;",
          "new_line_content": "        err = mkv_strip_wavpack(pkt->data, &data, &size);",
          "content_same": false
        },
        {
          "line": 2071,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Error when reformatting data of \"\n               \"a packet from stream %d.\\n\", pkt->stream_index)",
          "old_line_content": "        return err;",
          "new_line_content": "        av_log(s, AV_LOG_ERROR, \"Error when reformatting data of \"",
          "content_same": false
        },
        {
          "line": 2083,
          "old_api": null,
          "new_api": "av_packet_get_side_data",
          "old_text": null,
          "new_text": "av_packet_get_side_data(pkt,\n                                        AV_PKT_DATA_SKIP_SAMPLES,\n                                        &side_data_size)",
          "old_line_content": "                                        &side_data_size);",
          "new_line_content": "    side_data = av_packet_get_side_data(pkt,",
          "content_same": false
        },
        {
          "line": 2087,
          "old_api": null,
          "new_api": "AV_RL32",
          "old_text": null,
          "new_text": "AV_RL32(side_data + 4)",
          "old_line_content": "                                       (AVRational){1, 1000000000});",
          "new_line_content": "        discard_padding = av_rescale_q(AV_RL32(side_data + 4),",
          "content_same": false
        },
        {
          "line": 2092,
          "old_api": null,
          "new_api": "av_packet_get_side_data",
          "old_text": null,
          "new_text": "av_packet_get_side_data(pkt,\n                                        AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL,\n                                        &side_data_size)",
          "old_line_content": "                                        &side_data_size);",
          "new_line_content": "    side_data = av_packet_get_side_data(pkt,",
          "content_same": false
        },
        {
          "line": 2097,
          "old_api": null,
          "new_api": "AV_RB64",
          "old_text": null,
          "new_text": "AV_RB64(side_data)",
          "old_line_content": "        } else {",
          "new_line_content": "        if (side_data_size < 8 || (additional_id = AV_RB64(side_data)) != 1) {",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": null,
          "new_api": "start_ebml_master",
          "old_text": null,
          "new_text": "start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP, 0)",
          "old_line_content": "    }",
          "new_line_content": "        block_group = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP, 0);",
          "content_same": false
        },
        {
          "line": 2114,
          "old_api": null,
          "new_api": "avio_w8",
          "old_text": null,
          "new_text": "avio_w8(pb, (blockid == MATROSKA_ID_SIMPLEBLOCK && keyframe) ? (1 << 7) : 0)",
          "old_line_content": "    if (data != pkt->data)",
          "new_line_content": "    avio_w8(pb, (blockid == MATROSKA_ID_SIMPLEBLOCK && keyframe) ? (1 << 7) : 0);",
          "content_same": false
        },
        {
          "line": 2117,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(data)",
          "old_line_content": "    if (blockid == MATROSKA_ID_BLOCK && !keyframe)",
          "new_line_content": "        av_free(data);",
          "content_same": false
        },
        {
          "line": 2120,
          "old_api": null,
          "new_api": "put_ebml_sint",
          "old_text": null,
          "new_text": "put_ebml_sint(pb, MATROSKA_ID_BLOCKREFERENCE, track->last_timestamp - ts)",
          "old_line_content": "",
          "new_line_content": "        put_ebml_sint(pb, MATROSKA_ID_BLOCKREFERENCE, track->last_timestamp - ts);",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": null,
          "new_api": "put_ebml_sint",
          "old_text": null,
          "new_text": "put_ebml_sint(pb, MATROSKA_ID_DISCARDPADDING, discard_padding)",
          "old_line_content": "    if (side_data_size) {",
          "new_line_content": "        put_ebml_sint(pb, MATROSKA_ID_DISCARDPADDING, discard_padding);",
          "content_same": false
        },
        {
          "line": 2127,
          "old_api": null,
          "new_api": "start_ebml_master",
          "old_text": null,
          "new_text": "start_ebml_master(pb, MATROSKA_ID_BLOCKADDITIONS, 0)",
          "old_line_content": "        /* Until dbc50f8a our demuxer used a wrong default value",
          "new_line_content": "        block_additions = start_ebml_master(pb, MATROSKA_ID_BLOCKADDITIONS, 0);",
          "content_same": false
        },
        {
          "line": 2128,
          "old_api": null,
          "new_api": "start_ebml_master",
          "old_text": null,
          "new_text": "start_ebml_master(pb, MATROSKA_ID_BLOCKMORE, 0)",
          "old_line_content": "         * of BlockAddID, so we write it unconditionally. */",
          "new_line_content": "        block_more = start_ebml_master(pb, MATROSKA_ID_BLOCKMORE, 0);",
          "content_same": false
        },
        {
          "line": 2131,
          "old_api": null,
          "new_api": "put_ebml_uint  (pb, MATROSKA_ID_BLOCKADDID, additional_id)",
          "old_text": null,
          "new_text": "put_ebml_uint  (pb, MATROSKA_ID_BLOCKADDID, additional_id)",
          "old_line_content": "                        side_data, side_data_size);",
          "new_line_content": "        put_ebml_uint  (pb, MATROSKA_ID_BLOCKADDID, additional_id);",
          "content_same": false
        },
        {
          "line": 2134,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(pb, block_more)",
          "old_line_content": "    }",
          "new_line_content": "        end_ebml_master(pb, block_more);",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(pb, block_additions)",
          "old_line_content": "    if (side_data_size || discard_padding)",
          "new_line_content": "        end_ebml_master(pb, block_additions);",
          "content_same": false
        },
        {
          "line": 2138,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(pb, block_group)",
          "old_line_content": "    return 0;",
          "new_line_content": "        end_ebml_master(pb, block_group);",
          "content_same": false
        },
        {
          "line": 2154,
          "old_api": null,
          "new_api": "av_packet_get_side_data",
          "old_text": null,
          "new_text": "av_packet_get_side_data(pkt, AV_PKT_DATA_WEBVTT_IDENTIFIER,\n                                 &id_size)",
          "old_line_content": "    id = id ? id : \"\";",
          "new_line_content": "    id = av_packet_get_side_data(pkt, AV_PKT_DATA_WEBVTT_IDENTIFIER,",
          "content_same": false
        },
        {
          "line": 2158,
          "old_api": null,
          "new_api": "av_packet_get_side_data",
          "old_text": null,
          "new_text": "av_packet_get_side_data(pkt, AV_PKT_DATA_WEBVTT_SETTINGS,\n                                       &settings_size)",
          "old_line_content": "    settings = settings ? settings : \"\";",
          "new_line_content": "    settings = av_packet_get_side_data(pkt, AV_PKT_DATA_WEBVTT_SETTINGS,",
          "content_same": false
        },
        {
          "line": 2164,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    size = id_size + 1 + settings_size + 1 + pkt->size;",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 2170,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_DEBUG,\n           \"Writing block of size %d with pts %\" PRId64 \", dts %\" PRId64 \", \"\n           \"duration %\" PRId64 \" at relative offset %\" PRId64 \" in cluster \"\n           \"at offset %\" PRId64 \". TrackNumber %u, keyframe %d\\n\",\n           size, pkt->pts, pkt->dts, pkt->duration, avio_tell(pb),\n           mkv->cluster_pos, track->track_num, 1)",
          "old_line_content": "           \"duration %\" PRId64 \" at relative offset %\" PRId64 \" in cluster \"",
          "new_line_content": "    av_log(s, AV_LOG_DEBUG,",
          "content_same": false
        },
        {
          "line": 2174,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "",
          "new_line_content": "           size, pkt->pts, pkt->dts, pkt->duration, avio_tell(pb),",
          "content_same": false
        },
        {
          "line": 2177,
          "old_api": null,
          "new_api": "start_ebml_master",
          "old_text": null,
          "new_text": "start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,\n                                   mkv_blockgroup_size(size, track->track_num_size))",
          "old_line_content": "",
          "new_line_content": "    blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,",
          "content_same": false
        },
        {
          "line": 2183,
          "old_api": null,
          "new_api": "avio_wb16",
          "old_text": null,
          "new_text": "avio_wb16(pb, ts - mkv->cluster_pts)",
          "old_line_content": "",
          "new_line_content": "    avio_wb16(pb, ts - mkv->cluster_pts);",
          "content_same": false
        },
        {
          "line": 2184,
          "old_api": null,
          "new_api": "avio_w8",
          "old_text": null,
          "new_text": "avio_w8(pb, flags)",
          "old_line_content": "    id_size_int       = id_size;",
          "new_line_content": "    avio_w8(pb, flags);",
          "content_same": false
        },
        {
          "line": 2190,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, pkt->duration)",
          "old_line_content": "",
          "new_line_content": "    put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, pkt->duration);",
          "content_same": false
        },
        {
          "line": 2191,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(pb, blockgroup)",
          "old_line_content": "    return 0;",
          "new_line_content": "    end_ebml_master(pb, blockgroup);",
          "content_same": false
        },
        {
          "line": 2206,
          "old_api": null,
          "new_api": "end_ebml_master_crc32",
          "old_text": null,
          "new_text": "end_ebml_master_crc32(s->pb, &mkv->cluster_bc, mkv,\n                                MATROSKA_ID_CLUSTER, 0, 1, 0)",
          "old_line_content": "    if (ret < 0)",
          "new_line_content": "    ret = end_ebml_master_crc32(s->pb, &mkv->cluster_bc, mkv,",
          "content_same": false
        },
        {
          "line": 2211,
          "old_api": null,
          "new_api": "avio_write_marker",
          "old_text": null,
          "new_text": "avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_FLUSH_POINT)",
          "old_line_content": "}",
          "new_line_content": "    avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_FLUSH_POINT);",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": null,
          "new_api": "av_packet_get_side_data",
          "old_text": null,
          "new_text": "av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA,\n                                        &side_data_size)",
          "old_line_content": "",
          "new_line_content": "    side_data = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA,",
          "content_same": false
        },
        {
          "line": 2231,
          "old_api": null,
          "new_api": "get_aac_sample_rates",
          "old_text": null,
          "new_text": "get_aac_sample_rates(s, mkv, side_data, side_data_size,\n                                       &track->sample_rate, &output_sample_rate)",
          "old_line_content": "            if (ret < 0)",
          "new_line_content": "            ret = get_aac_sample_rates(s, mkv, side_data, side_data_size,",
          "content_same": false
        },
        {
          "line": 2237,
          "old_api": null,
          "new_api": "ff_alloc_extradata",
          "old_text": null,
          "new_text": "ff_alloc_extradata(par, side_data_size)",
          "old_line_content": "                return ret;",
          "new_line_content": "            ret = ff_alloc_extradata(par, side_data_size);",
          "content_same": false
        },
        {
          "line": 2242,
          "old_api": null,
          "new_api": "mkv_write_codecprivate",
          "old_text": null,
          "new_text": "mkv_write_codecprivate(s, mkv->track.bc, par, 1, 0)",
          "old_line_content": "            if (filler)",
          "new_line_content": "            mkv_write_codecprivate(s, mkv->track.bc, par, 1, 0);",
          "content_same": false
        },
        {
          "line": 2247,
          "old_api": null,
          "new_api": "put_ebml_float",
          "old_text": null,
          "new_text": "put_ebml_float(mkv->track.bc, MATROSKA_ID_AUDIOSAMPLINGFREQ, track->sample_rate)",
          "old_line_content": "        } else if (!par->extradata_size && !track->sample_rate) {",
          "new_line_content": "            put_ebml_float(mkv->track.bc, MATROSKA_ID_AUDIOSAMPLINGFREQ, track->sample_rate);",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": null,
          "new_api": "ffio_fill",
          "old_text": null,
          "new_text": "ffio_fill(pb, 0xff, bytes - 1)",
          "old_line_content": "",
          "new_line_content": "    ffio_fill(pb, 0xff, bytes - 1);",
          "content_same": false
        },
        {
          "line": 2248,
          "old_api": null,
          "new_api": "put_ebml_float",
          "old_text": null,
          "new_text": "put_ebml_float(mkv->track.bc, MATROSKA_ID_AUDIOOUTSAMPLINGFREQ, output_sample_rate)",
          "old_line_content": "            // No extradata (codecpar or packet side data).",
          "new_line_content": "            put_ebml_float(mkv->track.bc, MATROSKA_ID_AUDIOOUTSAMPLINGFREQ, output_sample_rate);",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Error parsing AAC extradata, unable to determine samplerate.\\n\")",
          "old_line_content": "        }",
          "new_line_content": "            av_log(s, AV_LOG_ERROR, \"Error parsing AAC extradata, unable to determine samplerate.\\n\");",
          "content_same": false
        },
        {
          "line": 2252,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "        break;",
          "new_line_content": "            return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 2261,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "            par->extradata = side_data;",
          "new_line_content": "                return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 2264,
          "old_api": null,
          "new_api": "avio_seek",
          "old_text": null,
          "new_text": "avio_seek(mkv->track.bc, track->codecpriv_offset, SEEK_SET)",
          "old_line_content": "            par->extradata = old_extradata;",
          "new_line_content": "            avio_seek(mkv->track.bc, track->codecpriv_offset, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 2265,
          "old_api": null,
          "new_api": "mkv_write_codecprivate",
          "old_text": null,
          "new_text": "mkv_write_codecprivate(s, mkv->track.bc, par, 1, 0)",
          "old_line_content": "        }",
          "new_line_content": "            mkv_write_codecprivate(s, mkv->track.bc, par, 1, 0);",
          "content_same": false
        },
        {
          "line": 222,
          "old_api": null,
          "new_api": "ebml_num_size",
          "old_text": null,
          "new_text": "ebml_num_size(length + 1)",
          "old_line_content": "",
          "new_line_content": "    return ebml_num_size(length + 1);",
          "content_same": false
        },
        {
          "line": 2276,
          "old_api": null,
          "new_api": "avio_open_dyn_buf",
          "old_text": null,
          "new_text": "avio_open_dyn_buf(&dyn_cp)",
          "old_line_content": "                return ret;",
          "new_line_content": "            ret = avio_open_dyn_buf(&dyn_cp);",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": null,
          "new_api": "ff_isom_write_av1c",
          "old_text": null,
          "new_text": "ff_isom_write_av1c(dyn_cp, side_data, side_data_size)",
          "old_line_content": "            if ((ret = dyn_cp->error) < 0 ||",
          "new_line_content": "            ff_isom_write_av1c(dyn_cp, side_data, side_data_size);",
          "content_same": false
        },
        {
          "line": 2280,
          "old_api": null,
          "new_api": "avio_get_dyn_buf",
          "old_text": null,
          "new_text": "avio_get_dyn_buf(dyn_cp, &codecpriv)",
          "old_line_content": "                !codecpriv_size && (ret = AVERROR_INVALIDDATA)) {",
          "new_line_content": "            codecpriv_size = avio_get_dyn_buf(dyn_cp, &codecpriv);",
          "content_same": false
        },
        {
          "line": 233,
          "old_api": null,
          "new_api": "avio_w8",
          "old_text": null,
          "new_text": "avio_w8(pb, (uint8_t)(num >> i * 8))",
          "old_line_content": "",
          "new_line_content": "        avio_w8(pb, (uint8_t)(num >> i * 8));",
          "content_same": false
        },
        {
          "line": 2283,
          "old_api": null,
          "new_api": "ffio_free_dyn_buf",
          "old_text": null,
          "new_text": "ffio_free_dyn_buf(&dyn_cp)",
          "old_line_content": "            }",
          "new_line_content": "                ffio_free_dyn_buf(&dyn_cp);",
          "content_same": false
        },
        {
          "line": 2289,
          "old_api": null,
          "new_api": "ffio_free_dyn_buf",
          "old_text": null,
          "new_text": "ffio_free_dyn_buf(&dyn_cp)",
          "old_line_content": "            if (ret < 0)",
          "new_line_content": "            ffio_free_dyn_buf(&dyn_cp);",
          "content_same": false
        },
        {
          "line": 2290,
          "old_api": null,
          "new_api": "ff_alloc_extradata",
          "old_text": null,
          "new_text": "ff_alloc_extradata(par, side_data_size)",
          "old_line_content": "                return ret;",
          "new_line_content": "            ret = ff_alloc_extradata(par, side_data_size);",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": null,
          "new_api": "ebml_length_size",
          "old_text": null,
          "new_text": "ebml_length_size(length)",
          "old_line_content": "    // sizes larger than this are currently undefined in EBML",
          "new_line_content": "    int needed_bytes = ebml_length_size(length);",
          "content_same": false
        },
        {
          "line": 2293,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(par->extradata, side_data, side_data_size)",
          "old_line_content": "            return AVERROR_INVALIDDATA;",
          "new_line_content": "            memcpy(par->extradata, side_data, side_data_size);",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(length < (1ULL << 56) - 1)",
          "old_line_content": "    if (bytes == 0)",
          "new_line_content": "    av_assert0(length < (1ULL << 56) - 1);",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_DEBUG, \"Ignoring new extradata in a packet for stream %d.\\n\", pkt->stream_index)",
          "old_line_content": "    }",
          "new_line_content": "            av_log(s, AV_LOG_DEBUG, \"Ignoring new extradata in a packet for stream %d.\\n\", pkt->stream_index);",
          "content_same": false
        },
        {
          "line": 253,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(bytes >= needed_bytes)",
          "old_line_content": "}",
          "new_line_content": "    av_assert0(bytes >= needed_bytes);",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": null,
          "new_api": "put_ebml_num",
          "old_text": null,
          "new_text": "put_ebml_num(pb, length, bytes)",
          "old_line_content": "",
          "new_line_content": "    put_ebml_num(pb, length, bytes);",
          "content_same": false
        },
        {
          "line": 263,
          "old_api": null,
          "new_api": "put_ebml_length",
          "old_text": null,
          "new_text": "put_ebml_length(pb, 8, 0)",
          "old_line_content": "}",
          "new_line_content": "    put_ebml_length(pb, 8, 0);",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": null,
          "new_api": "avio_wb64",
          "old_text": null,
          "new_text": "avio_wb64(pb, uid)",
          "old_line_content": "",
          "new_line_content": "    avio_wb64(pb, uid);",
          "content_same": false
        },
        {
          "line": 2319,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Can't write packet with unknown timestamp\\n\")",
          "old_line_content": "    }",
          "new_line_content": "        av_log(s, AV_LOG_ERROR, \"Can't write packet with unknown timestamp\\n\");",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    ts += track->ts_offset;",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": null,
          "new_api": "put_ebml_id",
          "old_text": null,
          "new_text": "put_ebml_id(pb, elementid)",
          "old_line_content": "    for (i = bytes - 1; i >= 0; i--)",
          "new_line_content": "    put_ebml_id(pb, elementid);",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": null,
          "new_api": "avio_w8",
          "old_text": null,
          "new_text": "avio_w8(pb, (uint8_t)(val >> i * 8))",
          "old_line_content": "",
          "new_line_content": "        avio_w8(pb, (uint8_t)(val >> i * 8));",
          "content_same": false
        },
        {
          "line": 2327,
          "old_api": null,
          "new_api": "mkv_end_cluster",
          "old_text": null,
          "new_text": "mkv_end_cluster(s)",
          "old_line_content": "                return ret;",
          "new_line_content": "            ret = mkv_end_cluster(s);",
          "content_same": false
        },
        {
          "line": 2330,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_WARNING, \"Starting new cluster due to timestamp\\n\")",
          "old_line_content": "    }",
          "new_line_content": "            av_log(s, AV_LOG_WARNING, \"Starting new cluster due to timestamp\\n\");",
          "content_same": false
        },
        {
          "line": 2335,
          "old_api": null,
          "new_api": "start_ebml_master_crc32",
          "old_text": null,
          "new_text": "start_ebml_master_crc32(&mkv->cluster_bc, mkv)",
          "old_line_content": "            return ret;",
          "new_line_content": "        ret = start_ebml_master_crc32(&mkv->cluster_bc, mkv);",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": null,
          "new_api": "put_ebml_id",
          "old_text": null,
          "new_text": "put_ebml_id(pb, elementid)",
          "old_line_content": "    for (i = bytes - 1; i >= 0; i--)",
          "new_line_content": "    put_ebml_id(pb, elementid);",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": null,
          "new_api": "avio_w8",
          "old_text": null,
          "new_text": "avio_w8(pb, (uint8_t)(val >> i * 8))",
          "old_line_content": "",
          "new_line_content": "        avio_w8(pb, (uint8_t)(val >> i * 8));",
          "content_same": false
        },
        {
          "line": 2340,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(0, ts)",
          "old_line_content": "               \"Starting new cluster with timestamp \"",
          "new_line_content": "        mkv->cluster_pts = FFMAX(0, ts);",
          "content_same": false
        },
        {
          "line": 2341,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_DEBUG,\n               \"Starting new cluster with timestamp \"\n               \"%\" PRId64 \" at offset %\" PRId64 \" bytes\\n\",\n               mkv->cluster_pts, mkv->cluster_pos)",
          "old_line_content": "               \"%\" PRId64 \" at offset %\" PRId64 \" bytes\\n\",",
          "new_line_content": "        av_log(s, AV_LOG_DEBUG,",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": null,
          "new_api": "put_ebml_length",
          "old_text": null,
          "new_text": "put_ebml_length(pb, 8, 0)",
          "old_line_content": "}",
          "new_line_content": "    put_ebml_length(pb, 8, 0);",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": null,
          "new_api": "av_double2int",
          "old_text": null,
          "new_text": "av_double2int(val)",
          "old_line_content": "",
          "new_line_content": "    avio_wb64(pb, av_double2int(val));",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "    if (par->codec_type != AVMEDIA_TYPE_SUBTITLE ||",
          "new_line_content": "    relative_packet_pos = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 2352,
          "old_api": null,
          "new_api": "mkv_write_block",
          "old_text": null,
          "new_text": "mkv_write_block(s, pb, MATROSKA_ID_SIMPLEBLOCK, pkt, keyframe)",
          "old_line_content": "            return ret;",
          "new_line_content": "        ret = mkv_write_block(s, pb, MATROSKA_ID_SIMPLEBLOCK, pkt, keyframe);",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": null,
          "new_api": "put_ebml_length",
          "old_text": null,
          "new_text": "put_ebml_length(pb, size, 0)",
          "old_line_content": "}",
          "new_line_content": "    put_ebml_length(pb, size, 0);",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": null,
          "new_api": "avio_write",
          "old_text": null,
          "new_text": "avio_write(pb, buf, size)",
          "old_line_content": "",
          "new_line_content": "    avio_write(pb, buf, size);",
          "content_same": false
        },
        {
          "line": 2355,
          "old_api": null,
          "new_api": "IS_SEEKABLE",
          "old_text": null,
          "new_text": "IS_SEEKABLE(s->pb, mkv)",
          "old_line_content": "             par->codec_type == AVMEDIA_TYPE_SUBTITLE ||",
          "new_line_content": "        if (keyframe && IS_SEEKABLE(s->pb, mkv) &&",
          "content_same": false
        },
        {
          "line": 2359,
          "old_api": null,
          "new_api": "mkv_add_cuepoint",
          "old_text": null,
          "new_text": "mkv_add_cuepoint(mkv, pkt->stream_index, ts,\n                                   mkv->cluster_pos, relative_packet_pos, 0)",
          "old_line_content": "            if (ret < 0)",
          "new_line_content": "            ret = mkv_add_cuepoint(mkv, pkt->stream_index, ts,",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": null,
          "new_api": "strlen",
          "old_text": null,
          "new_text": "strlen(str)",
          "old_line_content": "",
          "new_line_content": "    put_ebml_binary(pb, elementid, str, strlen(str));",
          "content_same": false
        },
        {
          "line": 2367,
          "old_api": null,
          "new_api": "mkv_write_vtt_blocks",
          "old_text": null,
          "new_text": "mkv_write_vtt_blocks(s, pb, pkt)",
          "old_line_content": "                return ret;",
          "new_line_content": "            ret = mkv_write_vtt_blocks(s, pb, pkt);",
          "content_same": false
        },
        {
          "line": 2371,
          "old_api": null,
          "new_api": "start_ebml_master",
          "old_text": null,
          "new_text": "start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,\n                                                       mkv_blockgroup_size(pkt->size,\n                                                                           track->track_num_size))",
          "old_line_content": "                                                                           track->track_num_size));",
          "new_line_content": "            ebml_master blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,",
          "content_same": false
        },
        {
          "line": 2372,
          "old_api": null,
          "new_api": "mkv_blockgroup_size",
          "old_text": null,
          "new_text": "mkv_blockgroup_size(pkt->size,\n                                                                           track->track_num_size)",
          "old_line_content": "",
          "new_line_content": "                                                       mkv_blockgroup_size(pkt->size,",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": null,
          "new_api": "put_ebml_id",
          "old_text": null,
          "new_text": "put_ebml_id(pb, EBML_ID_VOID)",
          "old_line_content": "    // size we need to reserve so 2 cases, we use 8 bytes to store the",
          "new_line_content": "    put_ebml_id(pb, EBML_ID_VOID);",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": null,
          "new_api": "put_ebml_length",
          "old_text": null,
          "new_text": "put_ebml_length(pb, size, 0)",
          "old_line_content": "        size -= 9;",
          "new_line_content": "        put_ebml_length(pb, size, 0);",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": null,
          "new_api": "ffio_fill",
          "old_text": null,
          "new_text": "ffio_fill(pb, 0, size)",
          "old_line_content": "",
          "new_line_content": "    ffio_fill(pb, 0, size);",
          "content_same": false
        },
        {
          "line": 2385,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration)",
          "old_line_content": "        }",
          "new_line_content": "            put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(pb, blockgroup)",
          "old_line_content": "",
          "new_line_content": "            end_ebml_master(pb, blockgroup);",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": null,
          "new_api": "IS_SEEKABLE",
          "old_text": null,
          "new_text": "IS_SEEKABLE(s->pb, mkv)",
          "old_line_content": "                                   mkv->cluster_pos, relative_packet_pos, duration);",
          "new_line_content": "        if (IS_SEEKABLE(s->pb, mkv)) {",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": null,
          "new_api": "mkv_add_cuepoint",
          "old_text": null,
          "new_text": "mkv_add_cuepoint(mkv, pkt->stream_index, ts,\n                                   mkv->cluster_pos, relative_packet_pos, duration)",
          "old_line_content": "            if (ret < 0)",
          "new_line_content": "            ret = mkv_add_cuepoint(mkv, pkt->stream_index, ts,",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": null,
          "new_api": "put_ebml_size_unknown",
          "old_text": null,
          "new_text": "put_ebml_size_unknown(pb, bytes)",
          "old_line_content": "}",
          "new_line_content": "    put_ebml_size_unknown(pb, bytes);",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "",
          "new_line_content": "    return (ebml_master) { avio_tell(pb), bytes };",
          "content_same": false
        },
        {
          "line": 2397,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(mkv->duration,   ts + duration)",
          "old_line_content": "",
          "new_line_content": "    mkv->duration   = FFMAX(mkv->duration,   ts + duration);",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(track->duration, ts + duration)",
          "old_line_content": "    return 0;",
          "new_line_content": "    track->duration = FFMAX(track->duration, ts + duration);",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": null,
          "new_api": "put_ebml_length",
          "old_text": null,
          "new_text": "put_ebml_length(pb, pos - master.pos, master.sizebytes)",
          "old_line_content": "}",
          "new_line_content": "    put_ebml_length(pb, pos - master.pos, master.sizebytes);",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": null,
          "new_api": "avio_seek",
          "old_text": null,
          "new_text": "avio_seek(pb, pos, SEEK_SET)",
          "old_line_content": "",
          "new_line_content": "    avio_seek(pb, pos, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": null,
          "new_api": "av_assert1",
          "old_text": null,
          "new_text": "av_assert1(seekhead->num_entries < MAX_SEEKHEAD_ENTRIES)",
          "old_line_content": "    seekhead->entries[seekhead->num_entries].elementid    = elementid;",
          "new_line_content": "    av_assert1(seekhead->num_entries < MAX_SEEKHEAD_ENTRIES);",
          "content_same": false
        },
        {
          "line": 2413,
          "old_api": null,
          "new_api": "mkv_check_new_extra_data",
          "old_text": null,
          "new_text": "mkv_check_new_extra_data(s, pkt)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ret = mkv_check_new_extra_data(s, pkt);",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": null,
          "new_api": "avio_open_dyn_buf",
          "old_text": null,
          "new_text": "avio_open_dyn_buf(dyn_cp)",
          "old_line_content": "",
          "new_line_content": "    if (!*dyn_cp && (ret = avio_open_dyn_buf(dyn_cp)) < 0)",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(mkv->cluster_bc)",
          "old_line_content": "        if (mkv->is_dash && codec_type == AVMEDIA_TYPE_VIDEO) {",
          "new_line_content": "        cluster_size  = avio_tell(mkv->cluster_bc);",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": null,
          "new_api": "put_ebml_void",
          "old_text": null,
          "new_text": "put_ebml_void(*dyn_cp, 6)",
          "old_line_content": "    return 0;",
          "new_line_content": "        put_ebml_void(*dyn_cp, 6); /* Reserve space for CRC32 so position/size calculations using avio_tell() take it into account */",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": null,
          "new_api": "avio_get_dyn_buf",
          "old_text": null,
          "new_text": "avio_get_dyn_buf(*dyn_cp, &buf)",
          "old_line_content": "        goto fail;",
          "new_line_content": "    size = avio_get_dyn_buf(*dyn_cp, &buf);",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": null,
          "new_api": "mkv_end_cluster",
          "old_text": null,
          "new_text": "mkv_end_cluster(s)",
          "old_line_content": "                return ret;",
          "new_line_content": "            ret = mkv_end_cluster(s);",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": null,
          "new_api": "put_ebml_id",
          "old_text": null,
          "new_text": "put_ebml_id(pb, id)",
          "old_line_content": "    if (mkv->write_crc) {",
          "new_line_content": "    put_ebml_id(pb, id);",
          "content_same": false
        },
        {
          "line": 399,
          "old_api": null,
          "new_api": "put_ebml_length",
          "old_text": null,
          "new_text": "put_ebml_length(pb, size, length_size)",
          "old_line_content": "        skip = 6; /* Skip reserved 6-byte long void element from the dynamic buffer. */",
          "new_line_content": "    put_ebml_length(pb, size, length_size);",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": null,
          "new_api": "av_crc_get_table",
          "old_text": null,
          "new_text": "av_crc_get_table(AV_CRC_32_IEEE_LE)",
          "old_line_content": "    }",
          "new_line_content": "        AV_WL32(crc, av_crc(av_crc_get_table(AV_CRC_32_IEEE_LE), UINT32_MAX, buf + skip, size - skip) ^ UINT32_MAX);",
          "content_same": false
        },
        {
          "line": 2452,
          "old_api": null,
          "new_api": "avio_write_marker",
          "old_text": null,
          "new_text": "avio_write_marker(s->pb,\n                          av_rescale_q(pkt->dts, s->streams[pkt->stream_index]->time_base, AV_TIME_BASE_Q),\n                          keyframe && (mkv->have_video ? codec_type == AVMEDIA_TYPE_VIDEO : 1) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT)",
          "old_line_content": "                          keyframe && (mkv->have_video ? codec_type == AVMEDIA_TYPE_VIDEO : 1) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT);",
          "new_line_content": "        avio_write_marker(s->pb,",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": null,
          "new_api": "avio_write",
          "old_text": null,
          "new_text": "avio_write(pb, buf + skip, size - skip)",
          "old_line_content": "fail:",
          "new_line_content": "    avio_write(pb, buf + skip, size - skip);",
          "content_same": false
        },
        {
          "line": 2453,
          "old_api": null,
          "new_api": "av_rescale_q",
          "old_text": null,
          "new_text": "av_rescale_q(pkt->dts, s->streams[pkt->stream_index]->time_base, AV_TIME_BASE_Q)",
          "old_line_content": "",
          "new_line_content": "                          av_rescale_q(pkt->dts, s->streams[pkt->stream_index]->time_base, AV_TIME_BASE_Q),",
          "content_same": false
        },
        {
          "line": 2458,
          "old_api": null,
          "new_api": "mkv_write_packet_internal",
          "old_text": null,
          "new_text": "mkv_write_packet_internal(s, mkv->cur_audio_pkt)",
          "old_line_content": "        if (ret < 0) {",
          "new_line_content": "        ret = mkv_write_packet_internal(s, mkv->cur_audio_pkt);",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": null,
          "new_api": "ffio_free_dyn_buf",
          "old_text": null,
          "new_text": "ffio_free_dyn_buf(dyn_cp)",
          "old_line_content": "    return ret;",
          "new_line_content": "        ffio_free_dyn_buf(dyn_cp);",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR,\n                   \"Could not write cached audio packet ret:%d\\n\", ret)",
          "old_line_content": "            return ret;",
          "new_line_content": "            av_log(s, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 2473,
          "old_api": null,
          "new_api": "mkv_write_packet_internal",
          "old_text": null,
          "new_text": "mkv_write_packet_internal(s, pkt)",
          "old_line_content": "}",
          "new_line_content": "        ret = mkv_write_packet_internal(s, pkt);",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": null,
          "new_api": "avio_get_dyn_buf",
          "old_text": null,
          "new_text": "avio_get_dyn_buf(elem->bc, &buf)",
          "old_line_content": "        if (elem->bc->error < 0)",
          "new_line_content": "        int size = avio_get_dyn_buf(elem->bc, &buf);",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "",
          "new_line_content": "        elem->pos = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": null,
          "new_api": "put_ebml_length",
          "old_text": null,
          "new_text": "put_ebml_length(pb, size, 0)",
          "old_line_content": "",
          "new_line_content": "        put_ebml_length(pb, size, 0);",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": null,
          "new_api": "avio_write",
          "old_text": null,
          "new_text": "avio_write(pb, buf, size)",
          "old_line_content": "        return 0;",
          "new_line_content": "        avio_write(pb, buf, size);",
          "content_same": false
        },
        {
          "line": 2483,
          "old_api": null,
          "new_api": "mkv_end_cluster",
          "old_text": null,
          "new_text": "mkv_end_cluster(s)",
          "old_line_content": "                return ret;",
          "new_line_content": "            int ret = mkv_end_cluster(s);",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": null,
          "new_api": "end_ebml_master_crc32",
          "old_text": null,
          "new_text": "end_ebml_master_crc32(pb, &elem->bc, mkv, id, 0, 0, 1)",
          "old_line_content": "",
          "new_line_content": "        return end_ebml_master_crc32(pb, &elem->bc, mkv, id, 0, 0, 1);",
          "content_same": false
        },
        {
          "line": 2488,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(s->pb)",
          "old_line_content": "        return 1;",
          "new_line_content": "                   avio_tell(s->pb));",
          "content_same": false
        },
        {
          "line": 2492,
          "old_api": null,
          "new_api": "mkv_write_packet",
          "old_text": null,
          "new_text": "mkv_write_packet(s, pkt)",
          "old_line_content": "",
          "new_line_content": "    return mkv_write_packet(s, pkt);",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": null,
          "new_api": "ffio_fill",
          "old_text": null,
          "new_text": "ffio_fill(pb, 255, size / 255)",
          "old_line_content": "}",
          "new_line_content": "    ffio_fill(pb, 255, size / 255);",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": null,
          "new_api": "avio_w8",
          "old_text": null,
          "new_text": "avio_w8(pb, size % 255)",
          "old_line_content": "",
          "new_line_content": "    avio_w8(pb, size % 255);",
          "content_same": false
        },
        {
          "line": 2506,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR,\n                   \"Could not write cached audio packet ret:%d\\n\", ret)",
          "old_line_content": "            return ret;",
          "new_line_content": "            av_log(s, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": null,
          "new_api": "ffio_free_dyn_buf",
          "old_text": null,
          "new_text": "ffio_free_dyn_buf(&mkv->track.bc)",
          "old_line_content": "",
          "new_line_content": "    ffio_free_dyn_buf(&mkv->track.bc);",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&mkv->cues.entries)",
          "old_line_content": "}",
          "new_line_content": "    av_freep(&mkv->cues.entries);",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&mkv->tracks)",
          "old_line_content": "",
          "new_line_content": "    av_freep(&mkv->tracks);",
          "content_same": false
        },
        {
          "line": 2513,
          "old_api": null,
          "new_api": "end_ebml_master_crc32",
          "old_text": null,
          "new_text": "end_ebml_master_crc32(pb, &mkv->cluster_bc, mkv,\n                                    MATROSKA_ID_CLUSTER, 0, 0, 0)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "        ret = end_ebml_master_crc32(pb, &mkv->cluster_bc, mkv,",
          "content_same": false
        },
        {
          "line": 2519,
          "old_api": null,
          "new_api": "mkv_write_chapters",
          "old_text": null,
          "new_text": "mkv_write_chapters(s)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ret = mkv_write_chapters(s);",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "    // and size, 6 bytes for a CRC32 element, and 2 bytes to guarantee",
          "new_line_content": "    mkv->seekhead.filepos = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 2523,
          "old_api": null,
          "new_api": "IS_SEEKABLE",
          "old_text": null,
          "new_text": "IS_SEEKABLE(pb, mkv)",
          "old_line_content": "",
          "new_line_content": "    if (!IS_SEEKABLE(pb, mkv))",
          "content_same": false
        },
        {
          "line": 2526,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "    if (mkv->cues.num_entries && mkv->reserve_cues_space >= 0) {",
          "new_line_content": "    endpos = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 479,
          "old_api": null,
          "new_api": "put_ebml_void",
          "old_text": null,
          "new_text": "put_ebml_void(pb, mkv->seekhead.reserved_size)",
          "old_line_content": "",
          "new_line_content": "    put_ebml_void(pb, mkv->seekhead.reserved_size);",
          "content_same": false
        },
        {
          "line": 2533,
          "old_api": null,
          "new_api": "start_ebml_master_crc32",
          "old_text": null,
          "new_text": "start_ebml_master_crc32(&cues, mkv)",
          "old_line_content": "            return ret;",
          "new_line_content": "        ret = start_ebml_master_crc32(&cues, mkv);",
          "content_same": false
        },
        {
          "line": 2537,
          "old_api": null,
          "new_api": "mkv_assemble_cues",
          "old_text": null,
          "new_text": "mkv_assemble_cues(s->streams, cues, &mkv->cues,\n                                mkv->tracks, s->nb_streams)",
          "old_line_content": "        if (ret < 0) {",
          "new_line_content": "        ret = mkv_assemble_cues(s->streams, cues, &mkv->cues,",
          "content_same": false
        },
        {
          "line": 2540,
          "old_api": null,
          "new_api": "ffio_free_dyn_buf",
          "old_text": null,
          "new_text": "ffio_free_dyn_buf(&cues)",
          "old_line_content": "        }",
          "new_line_content": "            ffio_free_dyn_buf(&cues);",
          "content_same": false
        },
        {
          "line": 2545,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(cues)",
          "old_line_content": "            size += 4 + length_size;",
          "new_line_content": "            size  = avio_tell(cues);",
          "content_same": false
        },
        {
          "line": 2546,
          "old_api": null,
          "new_api": "ebml_length_size",
          "old_text": null,
          "new_text": "ebml_length_size(size)",
          "old_line_content": "            if (mkv->reserve_cues_space < size) {",
          "new_line_content": "            length_size = ebml_length_size(size);",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": null,
          "new_api": "avio_seek",
          "old_text": null,
          "new_text": "avio_seek(pb, seekhead->filepos, SEEK_SET)",
          "old_line_content": "",
          "new_line_content": "    if ((ret64 = avio_seek(pb, seekhead->filepos, SEEK_SET)) < 0)",
          "content_same": false
        },
        {
          "line": 2549,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_WARNING,\n                       \"Insufficient space reserved for Cues: \"\n                       \"%d < %\"PRIu64\". No Cues will be output.\\n\",\n                       mkv->reserve_cues_space, size)",
          "old_line_content": "                       \"%d < %\"PRIu64\". No Cues will be output.\\n\",",
          "new_line_content": "                av_log(s, AV_LOG_WARNING,",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": null,
          "new_api": "start_ebml_master_crc32",
          "old_text": null,
          "new_text": "start_ebml_master_crc32(&dyn_cp, mkv)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ret = start_ebml_master_crc32(&dyn_cp, mkv);",
          "content_same": false
        },
        {
          "line": 2553,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "            } else {",
          "new_line_content": "                ret2 = AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 2556,
          "old_api": null,
          "new_api": "avio_seek",
          "old_text": null,
          "new_text": "avio_seek(pb, mkv->cues_pos, SEEK_SET)",
          "old_line_content": "                    return ret64;",
          "new_line_content": "                if ((ret64 = avio_seek(pb, mkv->cues_pos, SEEK_SET)) < 0) {",
          "content_same": false
        },
        {
          "line": 2557,
          "old_api": null,
          "new_api": "ffio_free_dyn_buf",
          "old_text": null,
          "new_text": "ffio_free_dyn_buf(&cues)",
          "old_line_content": "                }",
          "new_line_content": "                    ffio_free_dyn_buf(&cues);",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": null,
          "new_api": "start_ebml_master",
          "old_text": null,
          "new_text": "start_ebml_master(dyn_cp, MATROSKA_ID_SEEKENTRY,\n                                                  MAX_SEEKENTRY_SIZE)",
          "old_line_content": "",
          "new_line_content": "        ebml_master seekentry = start_ebml_master(dyn_cp, MATROSKA_ID_SEEKENTRY,",
          "content_same": false
        },
        {
          "line": 513,
          "old_api": null,
          "new_api": "ebml_id_size",
          "old_text": null,
          "new_text": "ebml_id_size(entry->elementid)",
          "old_line_content": "",
          "new_line_content": "        put_ebml_length(dyn_cp, ebml_id_size(entry->elementid), 0);",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_SEEKPOSITION, entry->segmentpos)",
          "old_line_content": "    }",
          "new_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_SEEKPOSITION, entry->segmentpos);",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": null,
          "new_api": "end_ebml_master_crc32",
          "old_text": null,
          "new_text": "end_ebml_master_crc32(pb, &dyn_cp, mkv,\n                                MATROSKA_ID_SEEKHEAD, 0, 0, 0)",
          "old_line_content": "    if (ret < 0)",
          "new_line_content": "    ret = end_ebml_master_crc32(pb, &dyn_cp, mkv,",
          "content_same": false
        },
        {
          "line": 2571,
          "old_api": null,
          "new_api": "end_ebml_master_crc32",
          "old_text": null,
          "new_text": "end_ebml_master_crc32(pb, &cues, mkv, MATROSKA_ID_CUES,\n                                    length_size, 0, 1)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "        ret = end_ebml_master_crc32(pb, &cues, mkv, MATROSKA_ID_CUES,",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "",
          "new_line_content": "    remaining = seekhead->filepos + seekhead->reserved_size - avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": null,
          "new_api": "avio_seek",
          "old_text": null,
          "new_text": "avio_seek(pb, destpos, SEEK_SET)",
          "old_line_content": "",
          "new_line_content": "    if ((ret64 = avio_seek(pb, destpos, SEEK_SET)) < 0)",
          "content_same": false
        },
        {
          "line": 2579,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "",
          "new_line_content": "            endpos = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 2588,
          "old_api": null,
          "new_api": "put_ebml_length",
          "old_text": null,
          "new_text": "put_ebml_length(pb, endpos - mkv->segment_offset, 8)",
          "old_line_content": "",
          "new_line_content": "        put_ebml_length(pb, endpos - mkv->segment_offset, 8);",
          "content_same": false
        },
        {
          "line": 2591,
          "old_api": null,
          "new_api": "mkv_write_seekhead",
          "old_text": null,
          "new_text": "mkv_write_seekhead(pb, mkv, 1, mkv->info.pos)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ret = mkv_write_seekhead(pb, mkv, 1, mkv->info.pos);",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 2599,
          "old_api": null,
          "new_api": "put_ebml_float",
          "old_text": null,
          "new_text": "put_ebml_float(mkv->info.bc, MATROSKA_ID_DURATION, mkv->duration)",
          "old_line_content": "                                    MATROSKA_ID_INFO, 0, 0, 0);",
          "new_line_content": "        put_ebml_float(mkv->info.bc, MATROSKA_ID_DURATION, mkv->duration);",
          "content_same": false
        },
        {
          "line": 2600,
          "old_api": null,
          "new_api": "end_ebml_master_crc32",
          "old_text": null,
          "new_text": "end_ebml_master_crc32(pb, &mkv->info.bc, mkv,\n                                    MATROSKA_ID_INFO, 0, 0, 0)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "        ret = end_ebml_master_crc32(pb, &mkv->info.bc, mkv,",
          "content_same": false
        },
        {
          "line": 2608,
          "old_api": null,
          "new_api": "avio_seek",
          "old_text": null,
          "new_text": "avio_seek(pb, mkv->track.pos, SEEK_SET)",
          "old_line_content": "                                    MATROSKA_ID_TRACKS, 0, 0, 0);",
          "new_line_content": "        avio_seek(pb, mkv->track.pos, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 2609,
          "old_api": null,
          "new_api": "end_ebml_master_crc32",
          "old_text": null,
          "new_text": "end_ebml_master_crc32(pb, &mkv->track.bc, mkv,\n                                    MATROSKA_ID_TRACKS, 0, 0, 0)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "        ret = end_ebml_master_crc32(pb, &mkv->track.bc, mkv,",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": null,
          "new_api": "avio_open_dyn_buf",
          "old_text": null,
          "new_text": "avio_open_dyn_buf(&cuepoint)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ret = avio_open_dyn_buf(&cuepoint);",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(cuepoint, MATROSKA_ID_CUETIME, pts)",
          "old_line_content": "        // put all the entries from different tracks that have the exact same",
          "new_line_content": "        put_ebml_uint(cuepoint, MATROSKA_ID_CUETIME, pts);",
          "content_same": false
        },
        {
          "line": 2623,
          "old_api": null,
          "new_api": "av_q2d",
          "old_text": null,
          "new_text": "av_q2d(st->time_base)",
          "old_line_content": "",
          "new_line_content": "                double duration_sec = track->duration * av_q2d(st->time_base);",
          "content_same": false
        },
        {
          "line": 2626,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_DEBUG, \"stream %d end duration = %\" PRIu64 \"\\n\", i,\n                       track->duration)",
          "old_line_content": "",
          "new_line_content": "                av_log(s, AV_LOG_DEBUG, \"stream %d end duration = %\" PRIu64 \"\\n\", i,",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(idx >= 0 && idx < num_tracks)",
          "old_line_content": "                continue;",
          "new_line_content": "            av_assert0(idx >= 0 && idx < num_tracks);",
          "content_same": false
        },
        {
          "line": 2635,
          "old_api": null,
          "new_api": "put_ebml_binary",
          "old_text": null,
          "new_text": "put_ebml_binary(mkv->tags.bc, MATROSKA_ID_TAGSTRING, duration_string, 20)",
          "old_line_content": "        }",
          "new_line_content": "                put_ebml_binary(mkv->tags.bc, MATROSKA_ID_TAGSTRING, duration_string, 20);",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(cuepoint, MATROSKA_ID_CUECLUSTERPOSITION , entry->cluster_pos)",
          "old_line_content": "            if (entry->duration > 0)",
          "new_line_content": "            put_ebml_uint(cuepoint, MATROSKA_ID_CUECLUSTERPOSITION , entry->cluster_pos);",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(cuepoint, MATROSKA_ID_CUEDURATION    , entry->duration)",
          "old_line_content": "        } while (++entry < end && entry->pts == pts);",
          "new_line_content": "                put_ebml_uint(cuepoint, MATROSKA_ID_CUEDURATION    , entry->duration);",
          "content_same": false
        },
        {
          "line": 2639,
          "old_api": null,
          "new_api": "avio_seek",
          "old_text": null,
          "new_text": "avio_seek(pb, mkv->tags.pos, SEEK_SET)",
          "old_line_content": "                                    MATROSKA_ID_TAGS, 0, 0, 0);",
          "new_line_content": "        avio_seek(pb, mkv->tags.pos, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 2640,
          "old_api": null,
          "new_api": "end_ebml_master_crc32",
          "old_text": null,
          "new_text": "end_ebml_master_crc32(pb, &mkv->tags.bc, mkv,\n                                    MATROSKA_ID_TAGS, 0, 0, 0)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "        ret = end_ebml_master_crc32(pb, &mkv->tags.bc, mkv,",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": null,
          "new_api": "avio_get_dyn_buf",
          "old_text": null,
          "new_text": "avio_get_dyn_buf(cuepoint, &buf)",
          "old_line_content": "            break;",
          "new_line_content": "        size = avio_get_dyn_buf(cuepoint, &buf);",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": null,
          "new_api": "put_ebml_binary",
          "old_text": null,
          "new_text": "put_ebml_binary(dyn_cp, MATROSKA_ID_POINTENTRY, buf, size)",
          "old_line_content": "    }",
          "new_line_content": "        put_ebml_binary(dyn_cp, MATROSKA_ID_POINTENTRY, buf, size);",
          "content_same": false
        },
        {
          "line": 2646,
          "old_api": null,
          "new_api": "avio_seek",
          "old_text": null,
          "new_text": "avio_seek(pb, endpos, SEEK_SET)",
          "old_line_content": "    return ret2;",
          "new_line_content": "    avio_seek(pb, endpos, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": null,
          "new_api": "ffio_free_dyn_buf",
          "old_text": null,
          "new_text": "ffio_free_dyn_buf(&cuepoint)",
          "old_line_content": "    return ret;",
          "new_line_content": "    ffio_free_dyn_buf(&cuepoint);",
          "content_same": false
        },
        {
          "line": 2659,
          "old_api": null,
          "new_api": "avcodec_get_type",
          "old_text": null,
          "new_text": "avcodec_get_type(codec_id)",
          "old_line_content": "        if (type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO)",
          "new_line_content": "        enum AVMediaType type = avcodec_get_type(codec_id);",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": null,
          "new_api": "avpriv_split_xiph_headers",
          "old_text": null,
          "new_text": "avpriv_split_xiph_headers(par->extradata, par->extradata_size,\n                                    first_header_size, header_start, header_len)",
          "old_line_content": "    if (err < 0) {",
          "new_line_content": "    err = avpriv_split_xiph_headers(par->extradata, par->extradata_size,",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Extradata corrupt.\\n\")",
          "old_line_content": "    }",
          "new_line_content": "        av_log(s, AV_LOG_ERROR, \"Extradata corrupt.\\n\");",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": null,
          "new_api": "put_xiph_size",
          "old_text": null,
          "new_text": "put_xiph_size(pb, header_len[j])",
          "old_line_content": "    for (j = 0; j < 3; j++)",
          "new_line_content": "        put_xiph_size(pb, header_len[j]);",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": null,
          "new_api": "avio_write",
          "old_text": null,
          "new_text": "avio_write(pb, header_start[j], header_len[j])",
          "old_line_content": "    return 0;",
          "new_line_content": "        avio_write(pb, header_start[j], header_len[j]);",
          "content_same": false
        },
        {
          "line": 2683,
          "old_api": null,
          "new_api": "av_lfg_get",
          "old_text": null,
          "new_text": "av_lfg_get(c)",
          "old_line_content": "        if (!uid)",
          "new_line_content": "        uid  = (uint64_t)av_lfg_get(c) << 32;",
          "content_same": false
        },
        {
          "line": 2684,
          "old_api": null,
          "new_api": "av_lfg_get",
          "old_text": null,
          "new_text": "av_lfg_get(c)",
          "old_line_content": "            continue;",
          "new_line_content": "        uid |= av_lfg_get(c);",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": null,
          "new_api": "avio_wl16",
          "old_text": null,
          "new_text": "avio_wl16(pb, 0x410)",
          "old_line_content": "}",
          "new_line_content": "        avio_wl16(pb, 0x410); // fallback to the most recent version",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": null,
          "new_api": "ff_flac_is_native_layout",
          "old_text": null,
          "new_text": "ff_flac_is_native_layout(par->channel_layout)",
          "old_line_content": "                                   !write_comment);",
          "new_line_content": "                         !ff_flac_is_native_layout(par->channel_layout));",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": null,
          "new_api": "ff_flac_write_header",
          "old_text": null,
          "new_text": "ff_flac_write_header(pb, par->extradata, par->extradata_size,\n                                   !write_comment)",
          "old_line_content": "",
          "new_line_content": "    int ret = ff_flac_write_header(pb, par->extradata, par->extradata_size,",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": null,
          "new_api": "snprintf",
          "old_text": null,
          "new_text": "snprintf(buf, sizeof(buf), \"0x%\"PRIx64, par->channel_layout)",
          "old_line_content": "",
          "new_line_content": "        snprintf(buf, sizeof(buf), \"0x%\"PRIx64, par->channel_layout);",
          "content_same": false
        },
        {
          "line": 2712,
          "old_api": null,
          "new_api": "avcodec_get_name",
          "old_text": null,
          "new_text": "avcodec_get_name(s->streams[i]->codecpar->codec_id)",
          "old_line_content": "        }",
          "new_line_content": "                   avcodec_get_name(s->streams[i]->codecpar->codec_id));",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": null,
          "new_api": "ff_vorbiscomment_length",
          "old_text": null,
          "new_text": "ff_vorbiscomment_length(dict, vendor, NULL, 0)",
          "old_line_content": "",
          "new_line_content": "        len = ff_vorbiscomment_length(dict, vendor, NULL, 0);",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": null,
          "new_api": "avio_w8",
          "old_text": null,
          "new_text": "avio_w8(pb, 0x84)",
          "old_line_content": "",
          "new_line_content": "        avio_w8(pb, 0x84);",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": null,
          "new_api": "av_dict_free",
          "old_text": null,
          "new_text": "av_dict_free(&dict)",
          "old_line_content": "",
          "new_line_content": "        av_dict_free(&dict);",
          "content_same": false
        },
        {
          "line": 2722,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(s->oformat->name, \"webm\")",
          "old_line_content": "        mkv->write_crc = 0;",
          "new_line_content": "    if (!strcmp(s->oformat->name, \"webm\")) {",
          "content_same": false
        },
        {
          "line": 2730,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    if (!mkv->tracks)",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 2733,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": null,
          "new_api": "avpriv_mpeg4audio_get_config2",
          "old_text": null,
          "new_text": "avpriv_mpeg4audio_get_config2(&mp4ac, extradata, extradata_size, 1, s)",
          "old_line_content": "     * case a bitstream filter will provide the muxer with the extradata in the",
          "new_line_content": "    ret = avpriv_mpeg4audio_get_config2(&mp4ac, extradata, extradata_size, 1, s);",
          "content_same": false
        },
        {
          "line": 2736,
          "old_api": null,
          "new_api": "av_get_random_seed",
          "old_text": null,
          "new_text": "av_get_random_seed()",
          "old_line_content": "        // Calculate the SegmentUID now in order not to waste our random seed.",
          "new_line_content": "        av_lfg_init(&c, av_get_random_seed());",
          "content_same": false
        },
        {
          "line": 2740,
          "old_api": null,
          "new_api": "av_lfg_get",
          "old_text": null,
          "new_text": "av_lfg_get(&c)",
          "old_line_content": "",
          "new_line_content": "            mkv->segment_uid[i] = av_lfg_get(&c);",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": null,
          "new_api": "IS_SEEKABLE",
          "old_text": null,
          "new_text": "IS_SEEKABLE(s->pb, mkv)",
          "old_line_content": "               \"Error parsing AAC extradata, unable to determine samplerate.\\n\");",
          "new_line_content": "    if (ret < 0 && (extradata_size || !IS_SEEKABLE(s->pb, mkv))) {",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 2750,
          "old_api": null,
          "new_api": "mkv_get_uid",
          "old_text": null,
          "new_text": "mkv_get_uid(mkv->tracks, i, &c)",
          "old_line_content": "",
          "new_line_content": "            track->uid = mkv_get_uid(mkv->tracks, i, &c);",
          "content_same": false
        },
        {
          "line": 2754,
          "old_api": null,
          "new_api": "avpriv_set_pts_info",
          "old_text": null,
          "new_text": "avpriv_set_pts_info(st, 64, 1, 1000)",
          "old_line_content": "        if (st->codecpar->codec_type == AVMEDIA_TYPE_ATTACHMENT) {",
          "new_line_content": "        avpriv_set_pts_info(st, 64, 1, 1000);",
          "content_same": false
        },
        {
          "line": 2760,
          "old_api": null,
          "new_api": "get_mimetype",
          "old_text": null,
          "new_text": "get_mimetype(st)",
          "old_line_content": "                       \"tag and it cannot be deduced from the codec id.\\n\", i);",
          "new_line_content": "            } else if (!get_mimetype(st)) {",
          "content_same": false
        },
        {
          "line": 2763,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "            mkv->nb_attachments++;",
          "new_line_content": "                return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 2771,
          "old_api": null,
          "new_api": "ebml_num_size",
          "old_text": null,
          "new_text": "ebml_num_size(track->track_num)",
          "old_line_content": "",
          "new_line_content": "        track->track_num_size = ebml_num_size(track->track_num);",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": null,
          "new_api": "ff_isom_write_avcc",
          "old_text": null,
          "new_text": "ff_isom_write_avcc(dyn_cp, par->extradata,\n                                  par->extradata_size)",
          "old_line_content": "    case AV_CODEC_ID_HEVC:",
          "new_line_content": "        return ff_isom_write_avcc(dyn_cp, par->extradata,",
          "content_same": false
        },
        {
          "line": 2775,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    return 0;",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": null,
          "new_api": "ff_isom_write_hvcc",
          "old_text": null,
          "new_text": "ff_isom_write_hvcc(dyn_cp, par->extradata,\n                                  par->extradata_size, 0)",
          "old_line_content": "    case AV_CODEC_ID_AV1:",
          "new_line_content": "        return ff_isom_write_hvcc(dyn_cp, par->extradata,",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": null,
          "new_api": "ff_isom_write_av1c",
          "old_text": null,
          "new_text": "ff_isom_write_av1c(dyn_cp, par->extradata,\n                                      par->extradata_size)",
          "old_line_content": "        else",
          "new_line_content": "            return ff_isom_write_av1c(dyn_cp, par->extradata,",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": null,
          "new_api": "put_ebml_void",
          "old_text": null,
          "new_text": "put_ebml_void(pb, 4 + 3)",
          "old_line_content": "    case AV_CODEC_ID_ALAC:",
          "new_line_content": "            put_ebml_void(pb, 4 + 3);",
          "content_same": false
        },
        {
          "line": 2786,
          "old_api": null,
          "new_api": "AV_RB16",
          "old_text": null,
          "new_text": "AV_RB16(pkt->data)",
          "old_line_content": "    } else if (st->codecpar->codec_id == AV_CODEC_ID_VP9) {",
          "new_line_content": "        if (pkt->size > 2 && (AV_RB16(pkt->data) & 0xfff0) == 0xfff0)",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR,\n                   \"Invalid extradata found, ALAC expects a 36-byte \"\n                   \"QuickTime atom.\")",
          "old_line_content": "                   \"QuickTime atom.\");",
          "new_line_content": "            av_log(s, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 2789,
          "old_api": null,
          "new_api": "ff_stream_add_bitstream_filter",
          "old_text": null,
          "new_text": "ff_stream_add_bitstream_filter(st, \"vp9_superframe\", NULL)",
          "old_line_content": "",
          "new_line_content": "        ret = ff_stream_add_bitstream_filter(st, \"vp9_superframe\", NULL);",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "avio_write",
          "old_text": null,
          "new_text": "avio_write(dyn_cp, par->extradata + 12,\n                       par->extradata_size - 12)",
          "old_line_content": "        break;",
          "new_line_content": "            avio_write(dyn_cp, par->extradata + 12,",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": null,
          "new_api": "put_ebml_void",
          "old_text": null,
          "new_text": "put_ebml_void(pb, MAX_PCE_SIZE + 2 + 4)",
          "old_line_content": "    default:",
          "new_line_content": "            put_ebml_void(pb, MAX_PCE_SIZE + 2 + 4);",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": null,
          "new_api": "ff_codec_get_id",
          "old_text": null,
          "new_text": "ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag)",
          "old_line_content": "        } else if (par->extradata_size && par->codec_id != AV_CODEC_ID_TTA)",
          "new_line_content": "            ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag) == AV_CODEC_ID_PRORES) {",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": null,
          "new_api": "avio_write",
          "old_text": null,
          "new_text": "avio_write(dyn_cp, par->extradata, par->extradata_size)",
          "old_line_content": "",
          "new_line_content": "            avio_write(dyn_cp, par->extradata, par->extradata_size);",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": null,
          "new_api": "avio_open_dyn_buf",
          "old_text": null,
          "new_text": "avio_open_dyn_buf(&dyn_cp)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ret = avio_open_dyn_buf(&dyn_cp);",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": null,
          "new_api": "mkv_write_native_codecprivate",
          "old_text": null,
          "new_text": "mkv_write_native_codecprivate(s, pb, par, dyn_cp)",
          "old_line_content": "        if (qt_id) {",
          "new_line_content": "        ret = mkv_write_native_codecprivate(s, pb, par, dyn_cp);",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": null,
          "new_api": "ff_codec_get_id",
          "old_text": null,
          "new_text": "ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag)",
          "old_line_content": "            ) {",
          "new_line_content": "            if (   ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag) == par->codec_id",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": null,
          "new_api": "AV_RL32",
          "old_text": null,
          "new_text": "AV_RL32(par->extradata + 4)",
          "old_line_content": "                int i;",
          "new_line_content": "                && (!par->extradata_size || ff_codec_get_id(ff_codec_movvideo_tags, AV_RL32(par->extradata + 4)) != par->codec_id)",
          "content_same": false
        },
        {
          "line": 2836,
          "old_api": null,
          "new_api": "OFFSET",
          "old_text": null,
          "new_text": "OFFSET(write_crc)",
          "old_line_content": "    { \"infer\", \"For each track type, mark the first track of disposition default as default; if none exists, mark the first track as default.\", 0, AV_OPT_TYPE_CONST, { .i64 = DEFAULT_MODE_INFER }, 0, 0, FLAGS, \"default_mode\" },",
          "new_line_content": "    { \"write_crc32\", \"write a CRC32 element inside every Level 1 element\", OFFSET(write_crc), AV_OPT_TYPE_BOOL, { .i64 = 1 }, 0, 1, FLAGS },",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": null,
          "new_api": "avio_wb32",
          "old_text": null,
          "new_text": "avio_wb32(dyn_cp, 0x5a + par->extradata_size)",
          "old_line_content": "                for(i = 0; i < 0x5a - 8; i++)",
          "new_line_content": "                avio_wb32(dyn_cp, 0x5a + par->extradata_size);",
          "content_same": false
        },
        {
          "line": 2837,
          "old_api": null,
          "new_api": "OFFSET",
          "old_text": null,
          "new_text": "OFFSET(default_mode)",
          "old_line_content": "    { \"infer_no_subs\", \"For each track type, mark the first track of disposition default as default; for audio and video: if none exists, mark the first track as default.\", 0, AV_OPT_TYPE_CONST, { .i64 = DEFAULT_MODE_INFER_NO_SUBS }, 0, 0, FLAGS, \"default_mode\" },",
          "new_line_content": "    { \"default_mode\", \"Controls how a track's FlagDefault is inferred\", OFFSET(default_mode), AV_OPT_TYPE_INT, { .i64 = DEFAULT_MODE_INFER }, DEFAULT_MODE_INFER, DEFAULT_MODE_PASSTHROUGH, FLAGS, \"default_mode\" },",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_WARNING, \"codec %s is not supported by this format\\n\",\n                       avcodec_get_name(par->codec_id))",
          "old_line_content": "",
          "new_line_content": "                av_log(s, AV_LOG_WARNING, \"codec %s is not supported by this format\\n\",",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": null,
          "new_api": "avcodec_get_name",
          "old_text": null,
          "new_text": "avcodec_get_name(par->codec_id)",
          "old_line_content": "            if (!par->codec_tag)",
          "new_line_content": "                       avcodec_get_name(par->codec_id));",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": null,
          "new_api": "ff_codec_get_tag",
          "old_text": null,
          "new_text": "ff_codec_get_tag(ff_codec_bmp_tags,\n                                                  par->codec_id)",
          "old_line_content": "            if (!par->codec_tag && par->codec_id != AV_CODEC_ID_RAWVIDEO) {",
          "new_line_content": "                par->codec_tag = ff_codec_get_tag(ff_codec_bmp_tags,",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": null,
          "new_api": "avcodec_get_name",
          "old_text": null,
          "new_text": "avcodec_get_name(par->codec_id)",
          "old_line_content": "            }",
          "new_line_content": "                       avcodec_get_name(par->codec_id));",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "",
          "new_line_content": "                ret = AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 2854,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"Matroska\")",
          "old_line_content": "    .extensions        = \"mkv\",",
          "new_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"Matroska\"),",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": null,
          "new_api": "ff_put_bmp_header",
          "old_text": null,
          "new_text": "ff_put_bmp_header(dyn_cp, par, 0, 0, mkv->flipped_raw_rgb)",
          "old_line_content": "    } else if (par->codec_type == AVMEDIA_TYPE_AUDIO) {",
          "new_line_content": "            ff_put_bmp_header(dyn_cp, par, 0, 0, mkv->flipped_raw_rgb);",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "avcodec_get_name",
          "old_text": null,
          "new_text": "avcodec_get_name(par->codec_id)",
          "old_line_content": "        }",
          "new_line_content": "                   avcodec_get_name(par->codec_id));",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "        if (!par->codec_tag)",
          "new_line_content": "            ret = AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "ff_put_wav_header",
          "old_text": null,
          "new_text": "ff_put_wav_header(s, dyn_cp, par, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX)",
          "old_line_content": "",
          "new_line_content": "        ff_put_wav_header(s, dyn_cp, par, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX);",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": null,
          "new_api": "put_ebml_binary",
          "old_text": null,
          "new_text": "put_ebml_binary(pb, MATROSKA_ID_CODECPRIVATE, codecpriv,\n                            codecpriv_size)",
          "old_line_content": "    }",
          "new_line_content": "            put_ebml_binary(pb, MATROSKA_ID_CODECPRIVATE, codecpriv,",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": null,
          "new_api": "ffio_free_dyn_buf",
          "old_text": null,
          "new_text": "ffio_free_dyn_buf(&dyn_cp)",
          "old_line_content": "}",
          "new_line_content": "    ffio_free_dyn_buf(&dyn_cp);",
          "content_same": false
        },
        {
          "line": 2890,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"WebM\")",
          "old_line_content": "    .extensions        = \"webm\",",
          "new_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"WebM\"),",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": null,
          "new_api": "ffio_init_context",
          "old_text": null,
          "new_text": "ffio_init_context(dyn_cp, colour, sizeof(colour), 1, NULL, NULL, NULL, NULL)",
          "old_line_content": "    if (par->color_trc != AVCOL_TRC_UNSPECIFIED &&",
          "new_line_content": "    ffio_init_context(dyn_cp, colour, sizeof(colour), 1, NULL, NULL, NULL, NULL);",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORTRANSFERCHARACTERISTICS,\n                      par->color_trc)",
          "old_line_content": "    }",
          "new_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORTRANSFERCHARACTERISTICS,",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORMATRIXCOEFF, par->color_space)",
          "old_line_content": "    if (par->color_primaries != AVCOL_PRI_UNSPECIFIED &&",
          "new_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORMATRIXCOEFF, par->color_space);",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORPRIMARIES, par->color_primaries)",
          "old_line_content": "    if (par->color_range != AVCOL_RANGE_UNSPECIFIED &&",
          "new_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORPRIMARIES, par->color_primaries);",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORRANGE, par->color_range)",
          "old_line_content": "    if (par->chroma_location != AVCHROMA_LOC_UNSPECIFIED &&",
          "new_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORRANGE, par->color_range);",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORCHROMASITINGHORZ, (xpos >> 7) + 1)",
          "old_line_content": "    }",
          "new_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORCHROMASITINGHORZ, (xpos >> 7) + 1);",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORCHROMASITINGVERT, (ypos >> 7) + 1)",
          "old_line_content": "",
          "new_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORCHROMASITINGVERT, (ypos >> 7) + 1);",
          "content_same": false
        },
        {
          "line": 2919,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"Matroska Audio\")",
          "old_line_content": "    .extensions        = \"mka\",",
          "new_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"Matroska Audio\"),",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": null,
          "new_api": "av_stream_get_side_data",
          "old_text": null,
          "new_text": "av_stream_get_side_data(st, AV_PKT_DATA_CONTENT_LIGHT_LEVEL,\n                                        NULL)",
          "old_line_content": "    if (side_data) {",
          "new_line_content": "    side_data = av_stream_get_side_data(st, AV_PKT_DATA_CONTENT_LIGHT_LEVEL,",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORMAXCLL,  metadata->MaxCLL)",
          "old_line_content": "    }",
          "new_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORMAXCLL,  metadata->MaxCLL);",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORMAXFALL, metadata->MaxFALL)",
          "old_line_content": "",
          "new_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORMAXFALL, metadata->MaxFALL);",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": null,
          "new_api": "av_stream_get_side_data",
          "old_text": null,
          "new_text": "av_stream_get_side_data(st, AV_PKT_DATA_MASTERING_DISPLAY_METADATA,\n                                        NULL)",
          "old_line_content": "    if (side_data) {",
          "new_line_content": "    side_data = av_stream_get_side_data(st, AV_PKT_DATA_MASTERING_DISPLAY_METADATA,",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": null,
          "new_api": "start_ebml_master",
          "old_text": null,
          "new_text": "start_ebml_master(\n            dyn_cp, MATROSKA_ID_VIDEOCOLORMASTERINGMETA, 10 * (2 + 1 + 8))",
          "old_line_content": "        const AVMasteringDisplayMetadata *metadata = side_data;",
          "new_line_content": "        ebml_master meta_element = start_ebml_master(",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": null,
          "new_api": "put_ebml_float",
          "old_text": null,
          "new_text": "put_ebml_float(dyn_cp, MATROSKA_ID_VIDEOCOLOR_WHITEY,\n                           av_q2d(metadata->white_point[1]))",
          "old_line_content": "        }",
          "new_line_content": "            put_ebml_float(dyn_cp, MATROSKA_ID_VIDEOCOLOR_WHITEY,",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": null,
          "new_api": "av_q2d",
          "old_text": null,
          "new_text": "av_q2d(metadata->white_point[1])",
          "old_line_content": "        if (metadata->has_luminance) {",
          "new_line_content": "                           av_q2d(metadata->white_point[1]));",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": null,
          "new_api": "put_ebml_float",
          "old_text": null,
          "new_text": "put_ebml_float(dyn_cp, MATROSKA_ID_VIDEOCOLOR_LUMINANCEMIN,\n                           av_q2d(metadata->min_luminance))",
          "old_line_content": "        }",
          "new_line_content": "            put_ebml_float(dyn_cp, MATROSKA_ID_VIDEOCOLOR_LUMINANCEMIN,",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(dyn_cp, meta_element)",
          "old_line_content": "",
          "new_line_content": "        end_ebml_master(dyn_cp, meta_element);",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": null,
          "new_api": "put_ebml_binary",
          "old_text": null,
          "new_text": "put_ebml_binary(pb, MATROSKA_ID_VIDEOCOLOR, colour, colorinfo_size)",
          "old_line_content": "",
          "new_line_content": "        put_ebml_binary(pb, MATROSKA_ID_VIDEOCOLOR, colour, colorinfo_size);",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": null,
          "new_api": "av_stream_get_side_data",
          "old_text": null,
          "new_text": "av_stream_get_side_data(st, AV_PKT_DATA_SPHERICAL,\n                                                            NULL)",
          "old_line_content": "",
          "new_line_content": "        (const AVSphericalMapping *)av_stream_get_side_data(st, AV_PKT_DATA_SPHERICAL,",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_WARNING, \"Unknown projection type\\n\")",
          "old_line_content": "    }",
          "new_line_content": "        av_log(s, AV_LOG_WARNING, \"Unknown projection type\\n\");",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": null,
          "new_api": "start_ebml_master",
          "old_text": null,
          "new_text": "start_ebml_master(pb, MATROSKA_ID_VIDEOPROJECTION,\n                                   4 * (2 + 1 + 8) + (2 + 1 + 20))",
          "old_line_content": "",
          "new_line_content": "    projection = start_ebml_master(pb, MATROSKA_ID_VIDEOPROJECTION,",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOPROJECTIONTYPE,\n                      MATROSKA_VIDEO_PROJECTION_TYPE_EQUIRECTANGULAR)",
          "old_line_content": "        break;",
          "new_line_content": "        put_ebml_uint(pb, MATROSKA_ID_VIDEOPROJECTIONTYPE,",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": null,
          "new_api": "AV_WB32",
          "old_text": null,
          "new_text": "AV_WB32(private + 16, spherical->bound_right)",
          "old_line_content": "                        private, 20);",
          "new_line_content": "        AV_WB32(private + 16, spherical->bound_right);",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": null,
          "new_api": "put_ebml_binary",
          "old_text": null,
          "new_text": "put_ebml_binary(pb, MATROSKA_ID_VIDEOPROJECTIONPRIVATE,\n                        private, 20)",
          "old_line_content": "        break;",
          "new_line_content": "        put_ebml_binary(pb, MATROSKA_ID_VIDEOPROJECTIONPRIVATE,",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": null,
          "new_api": "AV_WB32",
          "old_text": null,
          "new_text": "AV_WB32(private + 8, spherical->padding)",
          "old_line_content": "                        private, 12);",
          "new_line_content": "        AV_WB32(private + 8, spherical->padding);",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": null,
          "new_api": "put_ebml_binary",
          "old_text": null,
          "new_text": "put_ebml_binary(pb, MATROSKA_ID_VIDEOPROJECTIONPRIVATE,\n                        private, 12)",
          "old_line_content": "        break;",
          "new_line_content": "        put_ebml_binary(pb, MATROSKA_ID_VIDEOPROJECTIONPRIVATE,",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(0)",
          "old_line_content": "",
          "new_line_content": "        av_assert0(0);",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": null,
          "new_api": "put_ebml_float",
          "old_text": null,
          "new_text": "put_ebml_float(pb, MATROSKA_ID_VIDEOPROJECTIONPOSEYAW,\n                       (double) spherical->yaw   / (1 << 16))",
          "old_line_content": "    if (spherical->pitch)",
          "new_line_content": "        put_ebml_float(pb, MATROSKA_ID_VIDEOPROJECTIONPOSEYAW,",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": null,
          "new_api": "put_ebml_float",
          "old_text": null,
          "new_text": "put_ebml_float(pb, MATROSKA_ID_VIDEOPROJECTIONPOSEPITCH,\n                       (double) spherical->pitch / (1 << 16))",
          "old_line_content": "    if (spherical->roll)",
          "new_line_content": "        put_ebml_float(pb, MATROSKA_ID_VIDEOPROJECTIONPOSEPITCH,",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": null,
          "new_api": "put_ebml_float",
          "old_text": null,
          "new_text": "put_ebml_float(pb, MATROSKA_ID_VIDEOPROJECTIONPOSEROLL,\n                       (double) spherical->roll  / (1 << 16))",
          "old_line_content": "",
          "new_line_content": "        put_ebml_float(pb, MATROSKA_ID_VIDEOPROJECTIONPOSEROLL,",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(pb, projection)",
          "old_line_content": "",
          "new_line_content": "    end_ebml_master(pb, projection);",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOFLAGINTERLACED,\n                      MATROSKA_VIDEO_INTERLACE_FLAG_PROGRESSIVE)",
          "old_line_content": "        break;",
          "new_line_content": "        put_ebml_uint(pb, MATROSKA_ID_VIDEOFLAGINTERLACED,",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOFLAGINTERLACED,\n                      MATROSKA_VIDEO_INTERLACE_FLAG_INTERLACED)",
          "old_line_content": "        if (mode != MODE_WEBM) {",
          "new_line_content": "        put_ebml_uint(pb, MATROSKA_ID_VIDEOFLAGINTERLACED,",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,\n                              MATROSKA_VIDEO_FIELDORDER_TT)",
          "old_line_content": "                break;",
          "new_line_content": "                put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,\n                              MATROSKA_VIDEO_FIELDORDER_BB)",
          "old_line_content": "                break;",
          "new_line_content": "                put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,\n                              MATROSKA_VIDEO_FIELDORDER_TB)",
          "old_line_content": "                break;",
          "new_line_content": "                put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,\n                              MATROSKA_VIDEO_FIELDORDER_BT)",
          "old_line_content": "                break;",
          "new_line_content": "                put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get( s->metadata, \"stereo_mode\", NULL, 0)",
          "old_line_content": "",
          "new_line_content": "        (tag = av_dict_get( s->metadata, \"stereo_mode\", NULL, 0))) {",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": null,
          "new_api": "atoi",
          "old_text": null,
          "new_text": "atoi(tag->value)",
          "old_line_content": "        for (int i = 0; i < MATROSKA_VIDEO_STEREOMODE_TYPE_NB; i++)",
          "new_line_content": "        int stereo_mode = atoi(tag->value);",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(tag->value, ff_matroska_video_stereo_mode[i])",
          "old_line_content": "                break;",
          "new_line_content": "            if (!strcmp(tag->value, ff_matroska_video_stereo_mode[i])){",
          "content_same": false
        },
        {
          "line": 1048,
          "old_api": null,
          "new_api": "ff_mkv_stereo3d_conv",
          "old_text": null,
          "new_text": "ff_mkv_stereo3d_conv(st, stereo_mode)",
          "old_line_content": "                return ret;",
          "new_line_content": "            int ret = ff_mkv_stereo3d_conv(st, stereo_mode);",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": null,
          "new_api": "av_stream_get_side_data",
          "old_text": null,
          "new_text": "av_stream_get_side_data(st, AV_PKT_DATA_STEREO3D,\n                                                        NULL)",
          "old_line_content": "    if (stereo) {",
          "new_line_content": "    stereo = (const AVStereo3D*)av_stream_get_side_data(st, AV_PKT_DATA_STEREO3D,",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOSTEREOMODE, format)",
          "old_line_content": "    return 0;",
          "new_line_content": "    put_ebml_uint(pb, MATROSKA_ID_VIDEOSTEREOMODE, format);",
          "content_same": false
        },
        {
          "line": 1137,
          "old_api": null,
          "new_api": "get_aac_sample_rates",
          "old_text": null,
          "new_text": "get_aac_sample_rates(s, mkv, par->extradata, par->extradata_size,\n                                   &sample_rate, &output_sample_rate)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "        ret = get_aac_sample_rates(s, mkv, par->extradata, par->extradata_size,",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": null,
          "new_api": "put_ebml_uid (pb, MATROSKA_ID_TRACKUID,    track->uid)",
          "old_text": null,
          "new_text": "put_ebml_uid (pb, MATROSKA_ID_TRACKUID,    track->uid)",
          "old_line_content": "",
          "new_line_content": "    put_ebml_uid (pb, MATROSKA_ID_TRACKUID,    track->uid);",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(st->metadata, \"language\", NULL, 0)",
          "old_line_content": "                    tag && tag->value[0] ? tag->value : \"und\");",
          "new_line_content": "    tag = av_dict_get(st->metadata, \"language\", NULL, 0);",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": null,
          "new_api": "put_ebml_string",
          "old_text": null,
          "new_text": "put_ebml_string(pb, MATROSKA_ID_TRACKLANGUAGE,\n                    tag && tag->value[0] ? tag->value : \"und\")",
          "old_line_content": "",
          "new_line_content": "    put_ebml_string(pb, MATROSKA_ID_TRACKLANGUAGE,",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGDEFAULT, 0)",
          "old_line_content": "    if (st->disposition & AV_DISPOSITION_FORCED)",
          "new_line_content": "        put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGDEFAULT, 0);",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGFORCED, 1)",
          "old_line_content": "    if (mkv->mode == MODE_WEBM) {",
          "new_line_content": "        put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGFORCED, 1);",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "",
          "new_line_content": "            return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": null,
          "new_api": "put_ebml_string",
          "old_text": null,
          "new_text": "put_ebml_string(pb, MATROSKA_ID_CODECID, codec_id)",
          "old_line_content": "        if (st->disposition & AV_DISPOSITION_COMMENT)",
          "new_line_content": "        put_ebml_string(pb, MATROSKA_ID_CODECID, codec_id);",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGVISUALIMPAIRED,  1)",
          "old_line_content": "            (st->disposition & (AV_DISPOSITION_ORIGINAL | AV_DISPOSITION_DUB))",
          "new_line_content": "            put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGVISUALIMPAIRED,  1);",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGORIGINAL,\n                          !!(st->disposition & AV_DISPOSITION_ORIGINAL))",
          "old_line_content": "",
          "new_line_content": "            put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGORIGINAL,",
          "content_same": false
        },
        {
          "line": 1213,
          "old_api": null,
          "new_api": "put_ebml_string",
          "old_text": null,
          "new_text": "put_ebml_string(pb, MATROSKA_ID_CODECID, ff_mkv_codec_tags[j].str)",
          "old_line_content": "                    break;",
          "new_line_content": "                    put_ebml_string(pb, MATROSKA_ID_CODECID, ff_mkv_codec_tags[j].str);",
          "content_same": false
        },
        {
          "line": 1224,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "        }",
          "new_line_content": "                return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKTYPE, MATROSKA_TRACK_TYPE_VIDEO)",
          "old_line_content": "        if(   st->avg_frame_rate.num > 0 && st->avg_frame_rate.den > 0",
          "new_line_content": "        put_ebml_uint(pb, MATROSKA_ID_TRACKTYPE, MATROSKA_TRACK_TYPE_VIDEO);",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": null,
          "new_api": "av_inv_q",
          "old_text": null,
          "new_text": "av_inv_q(st->avg_frame_rate)",
          "old_line_content": "        else if(   st->r_frame_rate.num > 0 && st->r_frame_rate.den > 0",
          "new_line_content": "           && av_cmp_q(av_inv_q(st->avg_frame_rate), st->time_base) > 0)",
          "content_same": false
        },
        {
          "line": 1238,
          "old_api": null,
          "new_api": "av_inv_q",
          "old_text": null,
          "new_text": "av_inv_q(st->r_frame_rate)",
          "old_line_content": "",
          "new_line_content": "                && av_cmp_q(av_inv_q(st->r_frame_rate), st->time_base) > 0)",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKDEFAULTDURATION, 1000000000LL * st->r_frame_rate.den / st->r_frame_rate.num)",
          "old_line_content": "        if (!native_id &&",
          "new_line_content": "            put_ebml_uint(pb, MATROSKA_ID_TRACKDEFAULTDURATION, 1000000000LL * st->r_frame_rate.den / st->r_frame_rate.num);",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": null,
          "new_api": "ff_codec_get_tag",
          "old_text": null,
          "new_text": "ff_codec_get_tag(ff_codec_movvideo_tags, par->codec_id)",
          "old_line_content": "             par->codec_id == AV_CODEC_ID_SVQ1 ||",
          "new_line_content": "            ff_codec_get_tag(ff_codec_movvideo_tags, par->codec_id) &&",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": null,
          "new_api": "ff_codec_get_tag",
          "old_text": null,
          "new_text": "ff_codec_get_tag(ff_codec_bmp_tags,   par->codec_id)",
          "old_line_content": "             par->codec_id == AV_CODEC_ID_SVQ3 ||",
          "new_line_content": "            ((!ff_codec_get_tag(ff_codec_bmp_tags,   par->codec_id) && par->codec_id != AV_CODEC_ID_RAWVIDEO) ||",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": null,
          "new_api": "put_ebml_string",
          "old_text": null,
          "new_text": "put_ebml_string(pb, MATROSKA_ID_CODECID, \"V_QUICKTIME\")",
          "old_line_content": "            // if there is no mkv-specific codec ID, use VFW mode",
          "new_line_content": "            put_ebml_string(pb, MATROSKA_ID_CODECID, \"V_QUICKTIME\");",
          "content_same": false
        },
        {
          "line": 1253,
          "old_api": null,
          "new_api": "put_ebml_string",
          "old_text": null,
          "new_text": "put_ebml_string(pb, MATROSKA_ID_CODECID, \"V_MS/VFW/FOURCC\")",
          "old_line_content": "            s->internal->avoid_negative_ts_use_pts = 0;",
          "new_line_content": "            put_ebml_string(pb, MATROSKA_ID_CODECID, \"V_MS/VFW/FOURCC\");",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": null,
          "new_api": "put_ebml_uint (pb, MATROSKA_ID_VIDEOPIXELWIDTH , par->width)",
          "old_text": null,
          "new_text": "put_ebml_uint (pb, MATROSKA_ID_VIDEOPIXELWIDTH , par->width)",
          "old_line_content": "",
          "new_line_content": "        put_ebml_uint (pb, MATROSKA_ID_VIDEOPIXELWIDTH , par->width);",
          "content_same": false
        },
        {
          "line": 1263,
          "old_api": null,
          "new_api": "mkv_write_field_order",
          "old_text": null,
          "new_text": "mkv_write_field_order(pb, mkv->mode, par->field_order)",
          "old_line_content": "        // check both side data and metadata for stereo information,",
          "new_line_content": "        mkv_write_field_order(pb, mkv->mode, par->field_order);",
          "content_same": false
        },
        {
          "line": 1267,
          "old_api": null,
          "new_api": "mkv_write_stereo_mode",
          "old_text": null,
          "new_text": "mkv_write_stereo_mode(s, pb, st, mkv->mode,\n                                    &display_width_div,\n                                    &display_height_div)",
          "old_line_content": "                                    &display_height_div);",
          "new_line_content": "        ret = mkv_write_stereo_mode(s, pb, st, mkv->mode,",
          "content_same": false
        },
        {
          "line": 1273,
          "old_api": null,
          "new_api": "atoi",
          "old_text": null,
          "new_text": "atoi(tag->value)",
          "old_line_content": "            (par->format == AV_PIX_FMT_YUVA420P)) {",
          "new_line_content": "        if (((tag = av_dict_get(st->metadata, \"alpha_mode\", NULL, 0)) && atoi(tag->value)) ||",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOALPHAMODE, 1)",
          "old_line_content": "",
          "new_line_content": "            put_ebml_uint(pb, MATROSKA_ID_VIDEOALPHAMODE, 1);",
          "content_same": false
        },
        {
          "line": 1284,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Overflow in display width\\n\")",
          "old_line_content": "            }",
          "new_line_content": "                av_log(s, AV_LOG_ERROR, \"Overflow in display width\\n\");",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "            if (d_width != par->width || display_width_div != 1 || display_height_div != 1) {",
          "new_line_content": "                return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 1289,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYWIDTH , d_width / display_width_div)",
          "old_line_content": "                } else {",
          "new_line_content": "                    put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYWIDTH , d_width / display_width_div);",
          "content_same": false
        },
        {
          "line": 1290,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYHEIGHT, par->height / display_height_div)",
          "old_line_content": "                    AVRational display_aspect_ratio;",
          "new_line_content": "                    put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYHEIGHT, par->height / display_height_div);",
          "content_same": false
        },
        {
          "line": 1293,
          "old_api": null,
          "new_api": "av_reduce",
          "old_text": null,
          "new_text": "av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n                              par->width  * (int64_t)st->sample_aspect_ratio.num,\n                              par->height * (int64_t)st->sample_aspect_ratio.den,\n                              1024 * 1024)",
          "old_line_content": "                              par->height * (int64_t)st->sample_aspect_ratio.den,",
          "new_line_content": "                    av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYHEIGHT, display_aspect_ratio.den)",
          "old_line_content": "                }",
          "new_line_content": "                    put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYHEIGHT, display_aspect_ratio.den);",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYUNIT, MATROSKA_VIDEO_DISPLAYUNIT_DAR)",
          "old_line_content": "            }",
          "new_line_content": "                    put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYUNIT, MATROSKA_VIDEO_DISPLAYUNIT_DAR);",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYWIDTH , par->width / display_width_div)",
          "old_line_content": "        } else if (mkv->mode != MODE_WEBM)",
          "new_line_content": "            put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYWIDTH , par->width / display_width_div);",
          "content_same": false
        },
        {
          "line": 1306,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYUNIT, MATROSKA_VIDEO_DISPLAYUNIT_UNKNOWN)",
          "old_line_content": "        if (par->codec_id == AV_CODEC_ID_RAWVIDEO) {",
          "new_line_content": "            put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYUNIT, MATROSKA_VIDEO_DISPLAYUNIT_UNKNOWN);",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": null,
          "new_api": "av_le2ne32",
          "old_text": null,
          "new_text": "av_le2ne32(par->codec_tag)",
          "old_line_content": "        }",
          "new_line_content": "            uint32_t color_space = av_le2ne32(par->codec_tag);",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": null,
          "new_api": "mkv_write_video_color",
          "old_text": null,
          "new_text": "mkv_write_video_color(pb, st, par)",
          "old_line_content": "",
          "new_line_content": "        mkv_write_video_color(pb, st, par);",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(pb, subinfo)",
          "old_line_content": "",
          "new_line_content": "        end_ebml_master(pb, subinfo);",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": null,
          "new_api": "av_rescale_q",
          "old_text": null,
          "new_text": "av_rescale_q(par->initial_padding,\n                                              (AVRational){ 1, 48000 },\n                                              (AVRational){ 1, 1000000000 })",
          "old_line_content": "                                              (AVRational){ 1, 1000000000 });",
          "new_line_content": "            int64_t codecdelay = av_rescale_q(par->initial_padding,",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Initial padding is invalid\\n\")",
          "old_line_content": "            }",
          "new_line_content": "                av_log(s, AV_LOG_ERROR, \"Initial padding is invalid\\n\");",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "//            track->ts_offset = av_rescale_q(par->initial_padding,",
          "new_line_content": "                return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 1331,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_CODECDELAY, codecdelay)",
          "old_line_content": "        if (par->codec_id == AV_CODEC_ID_OPUS)",
          "new_line_content": "            put_ebml_uint(pb, MATROSKA_ID_CODECDELAY, codecdelay);",
          "content_same": false
        },
        {
          "line": 1336,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKTYPE, MATROSKA_TRACK_TYPE_AUDIO)",
          "old_line_content": "        if (!native_id)",
          "new_line_content": "        put_ebml_uint(pb, MATROSKA_ID_TRACKTYPE, MATROSKA_TRACK_TYPE_AUDIO);",
          "content_same": false
        },
        {
          "line": 1342,
          "old_api": null,
          "new_api": "start_ebml_master",
          "old_text": null,
          "new_text": "start_ebml_master(pb, MATROSKA_ID_TRACKAUDIO, 6 + 4 * 9)",
          "old_line_content": "",
          "new_line_content": "        subinfo = start_ebml_master(pb, MATROSKA_ID_TRACKAUDIO, 6 + 4 * 9);",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "        if (output_sample_rate)",
          "new_line_content": "        track->sample_rate_offset = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 1350,
          "old_api": null,
          "new_api": "av_get_bits_per_sample",
          "old_text": null,
          "new_text": "av_get_bits_per_sample(par->codec_id)",
          "old_line_content": "            if (par->bits_per_raw_sample)",
          "new_line_content": "        bit_depth = av_get_bits_per_sample(par->codec_id);",
          "content_same": false
        },
        {
          "line": 1355,
          "old_api": null,
          "new_api": "av_get_bytes_per_sample",
          "old_text": null,
          "new_text": "av_get_bytes_per_sample(par->format)",
          "old_line_content": "        if (!bit_depth)",
          "new_line_content": "                bit_depth = av_get_bytes_per_sample(par->format) << 3;",
          "content_same": false
        },
        {
          "line": 1360,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_AUDIOBITDEPTH, bit_depth)",
          "old_line_content": "        break;",
          "new_line_content": "            put_ebml_uint(pb, MATROSKA_ID_AUDIOBITDEPTH, bit_depth);",
          "content_same": false
        },
        {
          "line": 1361,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(pb, subinfo)",
          "old_line_content": "",
          "new_line_content": "        end_ebml_master(pb, subinfo);",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Subtitle codec %d is not supported.\\n\", par->codec_id)",
          "old_line_content": "        }",
          "new_line_content": "            av_log(s, AV_LOG_ERROR, \"Subtitle codec %d is not supported.\\n\", par->codec_id);",
          "content_same": false
        },
        {
          "line": 1367,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOSYS)",
          "old_line_content": "        if (mkv->mode != MODE_WEBM && st->disposition & AV_DISPOSITION_DESCRIPTIONS)",
          "new_line_content": "            return AVERROR(ENOSYS);",
          "content_same": false
        },
        {
          "line": 1370,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGTEXTDESCRIPTIONS, 1)",
          "old_line_content": "        if (mkv->mode != MODE_WEBM || par->codec_id != AV_CODEC_ID_WEBVTT)",
          "new_line_content": "            put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGTEXTDESCRIPTIONS, 1);",
          "content_same": false
        },
        {
          "line": 1375,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKTYPE, native_id)",
          "old_line_content": "    default:",
          "new_line_content": "        put_ebml_uint(pb, MATROSKA_ID_TRACKTYPE, native_id);",
          "content_same": false
        },
        {
          "line": 1378,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR, \"Only audio, video, and subtitles are supported for Matroska.\\n\")",
          "old_line_content": "    }",
          "new_line_content": "        av_log(s, AV_LOG_ERROR, \"Only audio, video, and subtitles are supported for Matroska.\\n\");",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 1383,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "        track->codecpriv_offset = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 1384,
          "old_api": null,
          "new_api": "mkv_write_codecprivate",
          "old_text": null,
          "new_text": "mkv_write_codecprivate(s, pb, par, native_id, qt_id)",
          "old_line_content": "            return ret;",
          "new_line_content": "        ret = mkv_write_codecprivate(s, pb, par, native_id, qt_id);",
          "content_same": false
        },
        {
          "line": 1389,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(pb, track_master)",
          "old_line_content": "    return 0;",
          "new_line_content": "    end_ebml_master(pb, track_master);",
          "content_same": false
        },
        {
          "line": 1403,
          "old_api": null,
          "new_api": "start_ebml_master_crc32",
          "old_text": null,
          "new_text": "start_ebml_master_crc32(&mkv->track.bc, mkv)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ret = start_ebml_master_crc32(&mkv->track.bc, mkv);",
          "content_same": false
        },
        {
          "line": 1425,
          "old_api": null,
          "new_api": "CASE",
          "old_text": null,
          "new_text": "CASE(AUDIO,    audio)",
          "old_line_content": "#undef CASE",
          "new_line_content": "            CASE(AUDIO,    audio)",
          "content_same": false
        },
        {
          "line": 1426,
          "old_api": null,
          "new_api": "CASE",
          "old_text": null,
          "new_text": "CASE(SUBTITLE, subtitle)",
          "old_line_content": "            }",
          "new_line_content": "            CASE(SUBTITLE, subtitle)",
          "content_same": false
        },
        {
          "line": 1431,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(video_default_idx, video_idx)",
          "old_line_content": "        if (mkv->default_mode != DEFAULT_MODE_INFER_NO_SUBS)",
          "new_line_content": "        video_default_idx = FFMAX(video_default_idx, video_idx);",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(subtitle_default_idx, subtitle_idx)",
          "old_line_content": "    for (i = 0; i < s->nb_streams; i++) {",
          "new_line_content": "            subtitle_default_idx = FFMAX(subtitle_default_idx, subtitle_idx);",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": null,
          "new_api": "mkv_write_track",
          "old_text": null,
          "new_text": "mkv_write_track(s, mkv, st, &mkv->tracks[i],\n                              mkv->track.bc, is_default)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "        ret = mkv_write_track(s, mkv, st, &mkv->tracks[i],",
          "content_same": false
        },
        {
          "line": 1448,
          "old_api": null,
          "new_api": "end_ebml_master_crc32_tentatively",
          "old_text": null,
          "new_text": "end_ebml_master_crc32_tentatively(pb, &mkv->track, mkv,\n                                             MATROSKA_ID_TRACKS)",
          "old_line_content": "}",
          "new_line_content": "    return end_ebml_master_crc32_tentatively(pb, &mkv->track, mkv,",
          "content_same": false
        },
        {
          "line": 1454,
          "old_api": null,
          "new_api": "av_strdup",
          "old_text": null,
          "new_text": "av_strdup(t->key)",
          "old_line_content": "    const uint8_t *lang = NULL;",
          "new_line_content": "    uint8_t *key = av_strdup(t->key);",
          "content_same": false
        },
        {
          "line": 1462,
          "old_api": null,
          "new_api": "strrchr",
          "old_text": null,
          "new_text": "strrchr(p, '-')",
          "old_line_content": "        *p = 0;",
          "new_line_content": "    if ((p = strrchr(p, '-')) &&",
          "content_same": false
        },
        {
          "line": 1463,
          "old_api": null,
          "new_api": "ff_convert_lang_to",
          "old_text": null,
          "new_text": "ff_convert_lang_to(p + 1, AV_LANG_ISO639_2_BIBL)",
          "old_line_content": "",
          "new_line_content": "        (lang = ff_convert_lang_to(p + 1, AV_LANG_ISO639_2_BIBL)))",
          "content_same": false
        },
        {
          "line": 1475,
          "old_api": null,
          "new_api": "start_ebml_master",
          "old_text": null,
          "new_text": "start_ebml_master(pb, MATROSKA_ID_SIMPLETAG, 0)",
          "old_line_content": "    if (lang)",
          "new_line_content": "    tag = start_ebml_master(pb, MATROSKA_ID_SIMPLETAG, 0);",
          "content_same": false
        },
        {
          "line": 1479,
          "old_api": null,
          "new_api": "put_ebml_string",
          "old_text": null,
          "new_text": "put_ebml_string(pb, MATROSKA_ID_TAGSTRING, t->value)",
          "old_line_content": "",
          "new_line_content": "    put_ebml_string(pb, MATROSKA_ID_TAGSTRING, t->value);",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&key)",
          "old_line_content": "}",
          "new_line_content": "    av_freep(&key);",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": null,
          "new_api": "start_ebml_master_crc32",
          "old_text": null,
          "new_text": "start_ebml_master_crc32(pb, mkv)",
          "old_line_content": "            return ret;",
          "new_line_content": "        ret = start_ebml_master_crc32(pb, mkv);",
          "content_same": false
        },
        {
          "line": 1498,
          "old_api": null,
          "new_api": "start_ebml_master",
          "old_text": null,
          "new_text": "start_ebml_master(*pb, MATROSKA_ID_TAG,        0)",
          "old_line_content": "    if (elementid)",
          "new_line_content": "    *tag    = start_ebml_master(*pb, MATROSKA_ID_TAG,        0);",
          "content_same": false
        },
        {
          "line": 1501,
          "old_api": null,
          "new_api": "put_ebml_uid",
          "old_text": null,
          "new_text": "put_ebml_uid(*pb, elementid, uid)",
          "old_line_content": "    return 0;",
          "new_line_content": "        put_ebml_uid(*pb, elementid, uid);",
          "content_same": false
        },
        {
          "line": 1502,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(*pb, targets)",
          "old_line_content": "}",
          "new_line_content": "    end_ebml_master(*pb, targets);",
          "content_same": false
        },
        {
          "line": 1511,
          "old_api": null,
          "new_api": "av_strcasecmp",
          "old_text": null,
          "new_text": "av_strcasecmp(name, \"encoding_tool\")",
          "old_line_content": "           (elementid != MATROSKA_ID_TAGTARGETS_TRACKUID ||",
          "new_line_content": "           av_strcasecmp(name, \"encoding_tool\") &&",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": null,
          "new_api": "av_strcasecmp",
          "old_text": null,
          "new_text": "av_strcasecmp(name, \"filename\")",
          "old_line_content": "}",
          "new_line_content": "            (av_strcasecmp(name, \"filename\") &&",
          "content_same": false
        },
        {
          "line": 1517,
          "old_api": null,
          "new_api": "av_strcasecmp",
          "old_text": null,
          "new_text": "av_strcasecmp(name, \"mimetype\")",
          "old_line_content": "",
          "new_line_content": "             av_strcasecmp(name, \"mimetype\")));",
          "content_same": false
        },
        {
          "line": 1528,
          "old_api": null,
          "new_api": "mkv_write_tag_targets",
          "old_text": null,
          "new_text": "mkv_write_tag_targets(mkv, pb, tag ? tag : &tag2, elementid, uid)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ret = mkv_write_tag_targets(mkv, pb, tag ? tag : &tag2, elementid, uid);",
          "content_same": false
        },
        {
          "line": 1533,
          "old_api": null,
          "new_api": "mkv_check_tag_name",
          "old_text": null,
          "new_text": "mkv_check_tag_name(t->key, elementid)",
          "old_line_content": "            if (ret < 0)",
          "new_line_content": "        if (mkv_check_tag_name(t->key, elementid)) {",
          "content_same": false
        },
        {
          "line": 1534,
          "old_api": null,
          "new_api": "mkv_write_simpletag",
          "old_text": null,
          "new_text": "mkv_write_simpletag(*pb, t)",
          "old_line_content": "                return ret;",
          "new_line_content": "            ret = mkv_write_simpletag(*pb, t);",
          "content_same": false
        },
        {
          "line": 1541,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(*pb, tag2)",
          "old_line_content": "    return 0;",
          "new_line_content": "        end_ebml_master(*pb, tag2);",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(m, \"\", t, AV_DICT_IGNORE_SUFFIX)",
          "old_line_content": "            return 1;",
          "new_line_content": "    while ((t = av_dict_get(m, \"\", t, AV_DICT_IGNORE_SUFFIX)))",
          "content_same": false
        },
        {
          "line": 1551,
          "old_api": null,
          "new_api": "mkv_check_tag_name",
          "old_text": null,
          "new_text": "mkv_check_tag_name(t->key, elementid)",
          "old_line_content": "",
          "new_line_content": "        if (mkv_check_tag_name(t->key, elementid))",
          "content_same": false
        },
        {
          "line": 1560,
          "old_api": null,
          "new_api": "IS_SEEKABLE",
          "old_text": null,
          "new_text": "IS_SEEKABLE(s->pb, mkv)",
          "old_line_content": "",
          "new_line_content": "    ebml_master tag, *tagp = IS_SEEKABLE(s->pb, mkv) ? &tag : NULL;",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": null,
          "new_api": "mkv_check_tag",
          "old_text": null,
          "new_text": "mkv_check_tag(s->metadata, 0)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "    if (mkv_check_tag(s->metadata, 0)) {",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": null,
          "new_api": "mkv_write_tag",
          "old_text": null,
          "new_text": "mkv_write_tag(mkv, s->metadata, &mkv->tags.bc, NULL, 0, 0)",
          "old_line_content": "            return ret;",
          "new_line_content": "        ret = mkv_write_tag(mkv, s->metadata, &mkv->tags.bc, NULL, 0, 0);",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": null,
          "new_api": "mkv_check_tag",
          "old_text": null,
          "new_text": "mkv_check_tag(st->metadata, MATROSKA_ID_TAGTARGETS_TRACKUID)",
          "old_line_content": "",
          "new_line_content": "        if (!tagp && !mkv_check_tag(st->metadata, MATROSKA_ID_TAGTARGETS_TRACKUID))",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": null,
          "new_api": "mkv_write_tag",
          "old_text": null,
          "new_text": "mkv_write_tag(mkv, st->metadata, &mkv->tags.bc, tagp,\n                            MATROSKA_ID_TAGTARGETS_TRACKUID, track->uid)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "        ret = mkv_write_tag(mkv, st->metadata, &mkv->tags.bc, tagp,",
          "content_same": false
        },
        {
          "line": 1594,
          "old_api": null,
          "new_api": "put_ebml_string",
          "old_text": null,
          "new_text": "put_ebml_string(pb, MATROSKA_ID_TAGNAME, \"DURATION\")",
          "old_line_content": "",
          "new_line_content": "            put_ebml_string(pb, MATROSKA_ID_TAGNAME, \"DURATION\");",
          "content_same": false
        },
        {
          "line": 1595,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "            // Reserve space to write duration as a 20-byte string.",
          "new_line_content": "            track->duration_offset = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 1600,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(pb, simpletag)",
          "old_line_content": "        }",
          "new_line_content": "            end_ebml_master(pb, simpletag);",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(pb, tag)",
          "old_line_content": "    }",
          "new_line_content": "            end_ebml_master(pb, tag);",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": null,
          "new_api": "mkv_check_tag",
          "old_text": null,
          "new_text": "mkv_check_tag(st->metadata, MATROSKA_ID_TAGTARGETS_ATTACHUID)",
          "old_line_content": "",
          "new_line_content": "            if (!mkv_check_tag(st->metadata, MATROSKA_ID_TAGTARGETS_ATTACHUID))",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": null,
          "new_api": "mkv_write_tag",
          "old_text": null,
          "new_text": "mkv_write_tag(mkv, st->metadata, &mkv->tags.bc, NULL,\n                                MATROSKA_ID_TAGTARGETS_ATTACHUID, track->uid)",
          "old_line_content": "            if (ret < 0)",
          "new_line_content": "            ret = mkv_write_tag(mkv, st->metadata, &mkv->tags.bc, NULL,",
          "content_same": false
        },
        {
          "line": 1624,
          "old_api": null,
          "new_api": "end_ebml_master_crc32_tentatively",
          "old_text": null,
          "new_text": "end_ebml_master_crc32_tentatively(s->pb, &mkv->tags, mkv,\n                                                 MATROSKA_ID_TAGS)",
          "old_line_content": "    }",
          "new_line_content": "        return end_ebml_master_crc32_tentatively(s->pb, &mkv->tags, mkv,",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": null,
          "new_api": "start_ebml_master_crc32",
          "old_text": null,
          "new_text": "start_ebml_master_crc32(&dyn_cp, mkv)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ret = start_ebml_master_crc32(&dyn_cp, mkv);",
          "content_same": false
        },
        {
          "line": 1659,
          "old_api": null,
          "new_api": "put_ebml_uint",
          "old_text": null,
          "new_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_EDITIONFLAGDEFAULT, 1)",
          "old_line_content": "         * corresponding to chapters will be put into a new Tags element. */",
          "new_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_EDITIONFLAGDEFAULT, 1);",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": null,
          "new_api": "mkv_new_chapter_ids_needed",
          "old_text": null,
          "new_text": "mkv_new_chapter_ids_needed(s)",
          "old_line_content": "    for (unsigned i = 0; i < s->nb_chapters; i++) {",
          "new_line_content": "    create_new_ids = mkv_new_chapter_ids_needed(s);",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": null,
          "new_api": "av_rescale_q",
          "old_text": null,
          "new_text": "av_rescale_q(c->start, c->time_base, scale)",
          "old_line_content": "        const AVDictionaryEntry *t;",
          "new_line_content": "        int64_t chapterstart = av_rescale_q(c->start, c->time_base, scale);",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": null,
          "new_api": "av_rescale_q",
          "old_text": null,
          "new_text": "av_rescale_q(c->end,   c->time_base, scale)",
          "old_line_content": "#if FF_API_CHAPTER_ID_INT",
          "new_line_content": "        int64_t chapterend   = av_rescale_q(c->end,   c->time_base, scale);",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_ERROR,\n                   \"Invalid chapter start (%\"PRId64\") or end (%\"PRId64\").\\n\",\n                   chapterstart, chapterend)",
          "old_line_content": "                   chapterstart, chapterend);",
          "new_line_content": "            av_log(s, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 1694,
          "old_api": null,
          "new_api": "put_ebml_string",
          "old_text": null,
          "new_text": "put_ebml_string(dyn_cp, MATROSKA_ID_CHAPLANG  , \"und\")",
          "old_line_content": "        }",
          "new_line_content": "            put_ebml_string(dyn_cp, MATROSKA_ID_CHAPLANG  , \"und\");",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": null,
          "new_api": "mkv_check_tag",
          "old_text": null,
          "new_text": "mkv_check_tag(c->metadata, MATROSKA_ID_TAGTARGETS_CHAPTERUID)",
          "old_line_content": "                                MATROSKA_ID_TAGTARGETS_CHAPTERUID, uid);",
          "new_line_content": "        if (tags && mkv_check_tag(c->metadata, MATROSKA_ID_TAGTARGETS_CHAPTERUID)) {",
          "content_same": false
        },
        {
          "line": 1700,
          "old_api": null,
          "new_api": "mkv_write_tag",
          "old_text": null,
          "new_text": "mkv_write_tag(mkv, c->metadata, tags, NULL,\n                                MATROSKA_ID_TAGTARGETS_CHAPTERUID, uid)",
          "old_line_content": "            if (ret < 0)",
          "new_line_content": "            ret = mkv_write_tag(mkv, c->metadata, tags, NULL,",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": null,
          "new_api": "end_ebml_master",
          "old_text": null,
          "new_text": "end_ebml_master(dyn_cp, editionentry)",
          "old_line_content": "",
          "new_line_content": "    end_ebml_master(dyn_cp, editionentry);",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": null,
          "new_api": "end_ebml_master_crc32",
          "old_text": null,
          "new_text": "end_ebml_master_crc32(pb, &dyn_cp, mkv, MATROSKA_ID_CHAPTERS, 0, 0, 1)",
          "old_line_content": "        goto fail;",
          "new_line_content": "    ret = end_ebml_master_crc32(pb, &dyn_cp, mkv, MATROSKA_ID_CHAPTERS, 0, 0, 1);",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": null,
          "new_api": "end_ebml_master_crc32",
          "old_text": null,
          "new_text": "end_ebml_master_crc32(pb, &dyn_tags, mkv,\n                                     MATROSKA_ID_TAGS, 0, 0, 1)",
          "old_line_content": "    return 0;",
          "new_line_content": "        return end_ebml_master_crc32(pb, &dyn_tags, mkv,",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": null,
          "new_api": "ffio_free_dyn_buf",
          "old_text": null,
          "new_text": "ffio_free_dyn_buf(&dyn_cp)",
          "old_line_content": "}",
          "new_line_content": "    ffio_free_dyn_buf(&dyn_cp);",
          "content_same": false
        },
        {
          "line": 1731,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(st->metadata, \"mimetype\", NULL, 0)",
          "old_line_content": "    if (st->codecpar->codec_id != AV_CODEC_ID_NONE) {",
          "new_line_content": "    if (t = av_dict_get(st->metadata, \"mimetype\", NULL, 0))",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": null,
          "new_api": "avcodec_descriptor_get",
          "old_text": null,
          "new_text": "avcodec_descriptor_get(st->codecpar->codec_id)",
          "old_line_content": "            return desc->mime_types[0];",
          "new_line_content": "        const AVCodecDescriptor *desc = avcodec_descriptor_get(st->codecpar->codec_id);",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": null,
          "new_api": "start_ebml_master_crc32",
          "old_text": null,
          "new_text": "start_ebml_master_crc32(&dyn_cp, mkv)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ret = start_ebml_master_crc32(&dyn_cp, mkv);",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": null,
          "new_api": "ffio_free_dyn_buf",
          "old_text": null,
          "new_text": "ffio_free_dyn_buf(&dyn_cp)",
          "old_line_content": "        }",
          "new_line_content": "            ffio_free_dyn_buf(&dyn_cp);",
          "content_same": false
        },
        {
          "line": 1782,
          "old_api": null,
          "new_api": "put_ebml_uid",
          "old_text": null,
          "new_text": "put_ebml_uid(dyn_cp, MATROSKA_ID_FILEUID, track->uid)",
          "old_line_content": "    }",
          "new_line_content": "        put_ebml_uid(dyn_cp, MATROSKA_ID_FILEUID, track->uid);",
          "content_same": false
        },
        {
          "line": 1785,
          "old_api": null,
          "new_api": "end_ebml_master_crc32",
          "old_text": null,
          "new_text": "end_ebml_master_crc32(pb, &dyn_cp, mkv,\n                                 MATROSKA_ID_ATTACHMENTS, 0, 0, 1)",
          "old_line_content": "}",
          "new_line_content": "    return end_ebml_master_crc32(pb, &dyn_cp, mkv,",
          "content_same": false
        },
        {
          "line": 1791,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(s->metadata, \"DURATION\",\n                                                    NULL, 0)",
          "old_line_content": "    int64_t max = 0;",
          "new_line_content": "    const AVDictionaryEntry *duration = av_dict_get(s->metadata, \"DURATION\",",
          "content_same": false
        },
        {
          "line": 1796,
          "old_api": null,
          "new_api": "av_parse_time",
          "old_text": null,
          "new_text": "av_parse_time(&us, duration->value, 1)",
          "old_line_content": "        return us;",
          "new_line_content": "    if (duration && (av_parse_time(&us, duration->value, 1) == 0) && us > 0) {",
          "content_same": false
        },
        {
          "line": 1797,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_DEBUG, \"get_metadata_duration found duration in context metadata: %\" PRId64 \"\\n\", us)",
          "old_line_content": "    }",
          "new_line_content": "        av_log(s, AV_LOG_DEBUG, \"get_metadata_duration found duration in context metadata: %\" PRId64 \"\\n\", us);",
          "content_same": false
        },
        {
          "line": 1805,
          "old_api": null,
          "new_api": "av_parse_time",
          "old_text": null,
          "new_text": "av_parse_time(&us, duration->value, 1)",
          "old_line_content": "    }",
          "new_line_content": "        if (duration && (av_parse_time(&us, duration->value, 1) == 0))",
          "content_same": false
        },
        {
          "line": 1806,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(max, us)",
          "old_line_content": "",
          "new_line_content": "            max = FFMAX(max, us);",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s, AV_LOG_DEBUG, \"get_metadata_duration returned: %\" PRId64 \"\\n\", max)",
          "old_line_content": "}",
          "new_line_content": "    av_log(s, AV_LOG_DEBUG, \"get_metadata_duration returned: %\" PRId64 \"\\n\", max);",
          "content_same": false
        },
        {
          "line": 1823,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(s->metadata, \"stereo_mode\", NULL, 0)",
          "old_line_content": "        version = 4;",
          "new_line_content": "        av_dict_get(s->metadata, \"stereo_mode\", NULL, 0) ||",
          "content_same": false
        },
        {
          "line": 1824,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(s->metadata, \"alpha_mode\", NULL, 0)",
          "old_line_content": "",
          "new_line_content": "        av_dict_get(s->metadata, \"alpha_mode\", NULL, 0))",
          "content_same": false
        },
        {
          "line": 1829,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0)",
          "old_line_content": "            version = 4;",
          "new_line_content": "            av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0) ||",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0)",
          "old_line_content": "    }",
          "new_line_content": "            av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0))",
          "content_same": false
        },
        {
          "line": 1841,
          "old_api": null,
          "new_api": "put_ebml_uint  (pb, EBML_ID_DOCTYPEREADVERSION,           2)",
          "old_text": null,
          "new_text": "put_ebml_uint  (pb, EBML_ID_DOCTYPEREADVERSION,           2)",
          "old_line_content": "",
          "new_line_content": "    put_ebml_uint  (pb, EBML_ID_DOCTYPEREADVERSION,           2);",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": null,
          "new_api": "put_ebml_size_unknown",
          "old_text": null,
          "new_text": "put_ebml_size_unknown(pb, 8)",
          "old_line_content": "",
          "new_line_content": "    put_ebml_size_unknown(pb, 8);",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "    // We write a SeekHead at the beginning to point to all other level",
          "new_line_content": "    mkv->segment_offset = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 1852,
          "old_api": null,
          "new_api": "start_ebml_master_crc32",
          "old_text": null,
          "new_text": "start_ebml_master_crc32(&mkv->info.bc, mkv)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ret = start_ebml_master_crc32(&mkv->info.bc, mkv);",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(s->metadata, \"title\", NULL, 0)",
          "old_line_content": "    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {",
          "new_line_content": "    if ((tag = av_dict_get(s->metadata, \"title\", NULL, 0)))",
          "content_same": false
        },
        {
          "line": 1862,
          "old_api": null,
          "new_api": "av_dict_get",
          "old_text": null,
          "new_text": "av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)",
          "old_line_content": "        else",
          "new_line_content": "        if ((tag = av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)))",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": null,
          "new_api": "put_ebml_string",
          "old_text": null,
          "new_text": "put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT)",
          "old_line_content": "        if (mkv->mode != MODE_WEBM)",
          "new_line_content": "            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);",
          "content_same": false
        },
        {
          "line": 1868,
          "old_api": null,
          "new_api": "put_ebml_binary",
          "old_text": null,
          "new_text": "put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, mkv->segment_uid, 16)",
          "old_line_content": "        const char *ident = \"Lavf\";",
          "new_line_content": "            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, mkv->segment_uid, 16);",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": null,
          "new_api": "put_ebml_string",
          "old_text": null,
          "new_text": "put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident)",
          "old_line_content": "    }",
          "new_line_content": "        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);",
          "content_same": false
        },
        {
          "line": 1872,
          "old_api": null,
          "new_api": "put_ebml_string",
          "old_text": null,
          "new_text": "put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident)",
          "old_line_content": "",
          "new_line_content": "        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": null,
          "new_api": "ff_parse_creation_time_metadata",
          "old_text": null,
          "new_text": "ff_parse_creation_time_metadata(s, &creation_time, 0)",
          "old_line_content": "        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;",
          "new_line_content": "    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {",
          "content_same": false
        },
        {
          "line": 1879,
          "old_api": null,
          "new_api": "AV_WB64",
          "old_text": null,
          "new_text": "AV_WB64(date_utc_buf, date_utc)",
          "old_line_content": "    }",
          "new_line_content": "        AV_WB64(date_utc_buf, date_utc);",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": null,
          "new_api": "put_ebml_binary",
          "old_text": null,
          "new_text": "put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8)",
          "old_line_content": "",
          "new_line_content": "        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);",
          "content_same": false
        },
        {
          "line": 1887,
          "old_api": null,
          "new_api": "get_metadata_duration",
          "old_text": null,
          "new_text": "get_metadata_duration(s)",
          "old_line_content": "        if (s->duration > 0) {",
          "new_line_content": "        int64_t metadata_duration = get_metadata_duration(s);",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": null,
          "new_api": "put_ebml_float",
          "old_text": null,
          "new_text": "put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration)",
          "old_line_content": "        } else if (metadata_duration > 0) {",
          "new_line_content": "            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);",
          "content_same": false
        },
        {
          "line": 1895,
          "old_api": null,
          "new_api": "put_ebml_float",
          "old_text": null,
          "new_text": "put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration)",
          "old_line_content": "        } else if (s->pb->seekable & AVIO_SEEKABLE_NORMAL) {",
          "new_line_content": "            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);",
          "content_same": false
        },
        {
          "line": 1898,
          "old_api": null,
          "new_api": "put_ebml_void",
          "old_text": null,
          "new_text": "put_ebml_void(pb, 11)",
          "old_line_content": "    }",
          "new_line_content": "            put_ebml_void(pb, 11);              // assumes double-precision float to be written",
          "content_same": false
        },
        {
          "line": 1901,
          "old_api": null,
          "new_api": "end_ebml_master_crc32_tentatively",
          "old_text": null,
          "new_text": "end_ebml_master_crc32_tentatively(s->pb, &mkv->info,\n                                            mkv, MATROSKA_ID_INFO)",
          "old_line_content": "    if (ret < 0)",
          "new_line_content": "    ret = end_ebml_master_crc32_tentatively(s->pb, &mkv->info,",
          "content_same": false
        },
        {
          "line": 1907,
          "old_api": null,
          "new_api": "mkv_write_tracks",
          "old_text": null,
          "new_text": "mkv_write_tracks(s)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ret = mkv_write_tracks(s);",
          "content_same": false
        },
        {
          "line": 1911,
          "old_api": null,
          "new_api": "mkv_write_chapters",
          "old_text": null,
          "new_text": "mkv_write_chapters(s)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ret = mkv_write_chapters(s);",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": null,
          "new_api": "mkv_write_attachments",
          "old_text": null,
          "new_text": "mkv_write_attachments(s)",
          "old_line_content": "            return ret;",
          "new_line_content": "        ret = mkv_write_attachments(s);",
          "content_same": false
        },
        {
          "line": 1923,
          "old_api": null,
          "new_api": "mkv_write_tags",
          "old_text": null,
          "new_text": "mkv_write_tags(s)",
          "old_line_content": "        return ret;",
          "new_line_content": "    ret = mkv_write_tags(s);",
          "content_same": false
        },
        {
          "line": 1927,
          "old_api": null,
          "new_api": "IS_SEEKABLE",
          "old_text": null,
          "new_text": "IS_SEEKABLE(pb, mkv)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "    if (!IS_SEEKABLE(pb, mkv)) {",
          "content_same": false
        },
        {
          "line": 1928,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "            return ret;",
          "new_line_content": "        ret = mkv_write_seekhead(pb, mkv, 0, avio_tell(pb));",
          "content_same": false
        },
        {
          "line": 1936,
          "old_api": null,
          "new_api": "put_ebml_void",
          "old_text": null,
          "new_text": "put_ebml_void(pb, s->metadata_header_padding)",
          "old_line_content": "",
          "new_line_content": "        put_ebml_void(pb, s->metadata_header_padding);",
          "content_same": false
        },
        {
          "line": 1940,
          "old_api": null,
          "new_api": "IS_SEEKABLE",
          "old_text": null,
          "new_text": "IS_SEEKABLE(pb, mkv)",
          "old_line_content": "            if (mkv->reserve_cues_space == 1)",
          "new_line_content": "        if (IS_SEEKABLE(pb, mkv)) {",
          "content_same": false
        },
        {
          "line": 1941,
          "old_api": null,
          "new_api": "avio_tell",
          "old_text": null,
          "new_text": "avio_tell(pb)",
          "old_line_content": "                mkv->reserve_cues_space++;",
          "new_line_content": "            mkv->cues_pos = avio_tell(pb);",
          "content_same": false
        },
        {
          "line": 1944,
          "old_api": null,
          "new_api": "put_ebml_void",
          "old_text": null,
          "new_text": "put_ebml_void(pb, mkv->reserve_cues_space)",
          "old_line_content": "            mkv->reserve_cues_space = -1;",
          "new_line_content": "            put_ebml_void(pb, mkv->reserve_cues_space);",
          "content_same": false
        },
        {
          "line": 1953,
          "old_api": null,
          "new_api": "IS_SEEKABLE",
          "old_text": null,
          "new_text": "IS_SEEKABLE(pb, mkv)",
          "old_line_content": "            mkv->cluster_time_limit = 5000;",
          "new_line_content": "    if (IS_SEEKABLE(pb, mkv)) {",
          "content_same": false
        },
        {
          "line": 1971,
          "old_api": null,
          "new_api": "ebml_length_size",
          "old_text": null,
          "new_text": "ebml_length_size(size)",
          "old_line_content": "    size += 9;              // max size of block duration incl. length field",
          "new_line_content": "    size += ebml_length_size(size);",
          "content_same": false
        },
        {
          "line": 1986,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    while (srclen >= WV_HEADER_SIZE) {",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 1991,
          "old_api": null,
          "new_api": "ff_wv_parse_header",
          "old_text": null,
          "new_text": "ff_wv_parse_header(&header, src)",
          "old_line_content": "            goto fail;",
          "new_line_content": "        ret = ff_wv_parse_header(&header, src);",
          "content_same": false
        },
        {
          "line": 2003,
          "old_api": null,
          "new_api": "AV_WL32",
          "old_text": null,
          "new_text": "AV_WL32(dst + offset, header.samples)",
          "old_line_content": "        }",
          "new_line_content": "            AV_WL32(dst + offset, header.samples);",
          "content_same": false
        },
        {
          "line": 2006,
          "old_api": null,
          "new_api": "AV_WL32",
          "old_text": null,
          "new_text": "AV_WL32(dst + offset,     header.flags)",
          "old_line_content": "        offset += 8;",
          "new_line_content": "        AV_WL32(dst + offset,     header.flags);",
          "content_same": false
        },
        {
          "line": 2007,
          "old_api": null,
          "new_api": "AV_WL32",
          "old_text": null,
          "new_text": "AV_WL32(dst + offset + 4, header.crc)",
          "old_line_content": "",
          "new_line_content": "        AV_WL32(dst + offset + 4, header.crc);",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": null,
          "new_api": "AV_WL32",
          "old_text": null,
          "new_text": "AV_WL32(dst + offset, header.blocksize)",
          "old_line_content": "        }",
          "new_line_content": "            AV_WL32(dst + offset, header.blocksize);",
          "content_same": false
        },
        {
          "line": 2015,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(dst + offset, src, header.blocksize)",
          "old_line_content": "        srclen -= header.blocksize;",
          "new_line_content": "        memcpy(dst + offset, src, header.blocksize);",
          "content_same": false
        },
        {
          "line": 2026,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&dst)",
          "old_line_content": "}",
          "new_line_content": "    av_freep(&dst);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2051,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "           pkt->size, pkt->pts, pkt->dts, pkt->duration, avio_tell(pb),",
          "new_line_content": "           \"duration %\" PRId64 \" at relative offset %\" PRId64 \" in cluster \"",
          "content_same": false
        },
        {
          "line": 2055,
          "old_api": "AV_RB32",
          "new_api": null,
          "old_text": "AV_RB32(par->extradata)",
          "new_text": null,
          "old_line_content": "        (AV_RB24(par->extradata) == 1 || AV_RB32(par->extradata) == 1)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2056,
          "old_api": "ff_avc_parse_nal_units_buf",
          "new_api": null,
          "old_text": "ff_avc_parse_nal_units_buf(pkt->data, &data, &size)",
          "new_text": null,
          "old_line_content": "        err = ff_avc_parse_nal_units_buf(pkt->data, &data, &size);",
          "new_line_content": "    if (par->codec_id == AV_CODEC_ID_H264 && par->extradata_size > 0 &&",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Error when reformatting data of \"\n               \"a packet from stream %d.\\n\", pkt->stream_index)",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR, \"Error when reformatting data of \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2081,
          "old_api": "av_packet_get_side_data",
          "new_api": null,
          "old_text": "av_packet_get_side_data(pkt,\n                                        AV_PKT_DATA_SKIP_SAMPLES,\n                                        &side_data_size)",
          "new_text": null,
          "old_line_content": "    side_data = av_packet_get_side_data(pkt,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2085,
          "old_api": "AV_RL32",
          "new_api": null,
          "old_text": "AV_RL32(side_data + 4)",
          "new_text": null,
          "old_line_content": "        discard_padding = av_rescale_q(AV_RL32(side_data + 4),",
          "new_line_content": "                                        &side_data_size);",
          "content_same": false
        },
        {
          "line": 2090,
          "old_api": "av_packet_get_side_data",
          "new_api": null,
          "old_text": "av_packet_get_side_data(pkt,\n                                        AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL,\n                                        &side_data_size)",
          "new_text": null,
          "old_line_content": "    side_data = av_packet_get_side_data(pkt,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2095,
          "old_api": "AV_RB64",
          "new_api": null,
          "old_text": "AV_RB64(side_data)",
          "new_text": null,
          "old_line_content": "        if (side_data_size < 8 || (additional_id = AV_RB64(side_data)) != 1) {",
          "new_line_content": "    if (side_data) {",
          "content_same": false
        },
        {
          "line": 2104,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP, 0)",
          "new_text": null,
          "old_line_content": "        block_group = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2108,
          "old_api": "put_ebml_id",
          "new_api": null,
          "old_text": "put_ebml_id(pb, blockid)",
          "new_text": null,
          "old_line_content": "    put_ebml_id(pb, blockid);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2109,
          "old_api": "put_ebml_length",
          "new_api": null,
          "old_text": "put_ebml_length(pb, size + track->track_num_size + 3, 0)",
          "new_text": null,
          "old_line_content": "    put_ebml_length(pb, size + track->track_num_size + 3, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2118,
          "old_api": "put_ebml_sint",
          "new_api": null,
          "old_text": "put_ebml_sint(pb, MATROSKA_ID_BLOCKREFERENCE, track->last_timestamp - ts)",
          "new_text": null,
          "old_line_content": "        put_ebml_sint(pb, MATROSKA_ID_BLOCKREFERENCE, track->last_timestamp - ts);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": "put_ebml_sint",
          "new_api": null,
          "old_text": "put_ebml_sint(pb, MATROSKA_ID_DISCARDPADDING, discard_padding)",
          "new_text": null,
          "old_line_content": "        put_ebml_sint(pb, MATROSKA_ID_DISCARDPADDING, discard_padding);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2125,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(pb, MATROSKA_ID_BLOCKADDITIONS, 0)",
          "new_text": null,
          "old_line_content": "        block_additions = start_ebml_master(pb, MATROSKA_ID_BLOCKADDITIONS, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2126,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(pb, MATROSKA_ID_BLOCKMORE, 0)",
          "new_text": null,
          "old_line_content": "        block_more = start_ebml_master(pb, MATROSKA_ID_BLOCKMORE, 0);",
          "new_line_content": "    if (side_data_size) {",
          "content_same": false
        },
        {
          "line": 2129,
          "old_api": "put_ebml_uint  (pb, MATROSKA_ID_BLOCKADDID, additional_id)",
          "new_api": null,
          "old_text": "put_ebml_uint  (pb, MATROSKA_ID_BLOCKADDID, additional_id)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint  (pb, MATROSKA_ID_BLOCKADDID, additional_id);",
          "new_line_content": "        /* Until dbc50f8a our demuxer used a wrong default value",
          "content_same": false
        },
        {
          "line": 2130,
          "old_api": "put_ebml_binary",
          "new_api": null,
          "old_text": "put_ebml_binary(pb, MATROSKA_ID_BLOCKADDITIONAL,\n                        side_data, side_data_size)",
          "new_text": null,
          "old_line_content": "        put_ebml_binary(pb, MATROSKA_ID_BLOCKADDITIONAL,",
          "new_line_content": "         * of BlockAddID, so we write it unconditionally. */",
          "content_same": false
        },
        {
          "line": 2133,
          "old_api": "end_ebml_master",
          "new_api": null,
          "old_text": "end_ebml_master(pb, block_additions)",
          "new_text": null,
          "old_line_content": "        end_ebml_master(pb, block_additions);",
          "new_line_content": "                        side_data, side_data_size);",
          "content_same": false
        },
        {
          "line": 2136,
          "old_api": "end_ebml_master",
          "new_api": null,
          "old_text": "end_ebml_master(pb, block_group)",
          "new_text": null,
          "old_line_content": "        end_ebml_master(pb, block_group);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2152,
          "old_api": "av_packet_get_side_data",
          "new_api": null,
          "old_text": "av_packet_get_side_data(pkt, AV_PKT_DATA_WEBVTT_IDENTIFIER,\n                                 &id_size)",
          "new_text": null,
          "old_line_content": "    id = av_packet_get_side_data(pkt, AV_PKT_DATA_WEBVTT_IDENTIFIER,",
          "new_line_content": "    const int flags = 0;",
          "content_same": false
        },
        {
          "line": 2156,
          "old_api": "av_packet_get_side_data",
          "new_api": null,
          "old_text": "av_packet_get_side_data(pkt, AV_PKT_DATA_WEBVTT_SETTINGS,\n                                       &settings_size)",
          "new_text": null,
          "old_line_content": "    settings = av_packet_get_side_data(pkt, AV_PKT_DATA_WEBVTT_SETTINGS,",
          "new_line_content": "    id = id ? id : \"\";",
          "content_same": false
        },
        {
          "line": 2162,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "    if (id_size > INT_MAX - 2 || settings_size > INT_MAX - id_size - 2 ||",
          "content_same": false
        },
        {
          "line": 2168,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_DEBUG,\n           \"Writing block of size %d with pts %\" PRId64 \", dts %\" PRId64 \", \"\n           \"duration %\" PRId64 \" at relative offset %\" PRId64 \" in cluster \"\n           \"at offset %\" PRId64 \". TrackNumber %u, keyframe %d\\n\",\n           size, pkt->pts, pkt->dts, pkt->duration, avio_tell(pb),\n           mkv->cluster_pos, track->track_num, 1)",
          "new_text": null,
          "old_line_content": "    av_log(s, AV_LOG_DEBUG,",
          "new_line_content": "    /* The following string is identical to the one in mkv_write_block so that",
          "content_same": false
        },
        {
          "line": 2172,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "           size, pkt->pts, pkt->dts, pkt->duration, avio_tell(pb),",
          "new_line_content": "           \"duration %\" PRId64 \" at relative offset %\" PRId64 \" in cluster \"",
          "content_same": false
        },
        {
          "line": 2175,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,\n                                   mkv_blockgroup_size(size, track->track_num_size))",
          "new_text": null,
          "old_line_content": "    blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,",
          "new_line_content": "           mkv->cluster_pos, track->track_num, 1);",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": "mkv_blockgroup_size",
          "new_api": null,
          "old_text": "mkv_blockgroup_size(size, track->track_num_size)",
          "new_text": null,
          "old_line_content": "                                   mkv_blockgroup_size(size, track->track_num_size));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2179,
          "old_api": "put_ebml_length",
          "new_api": null,
          "old_text": "put_ebml_length(pb, size + track->track_num_size + 3, 0)",
          "new_text": null,
          "old_line_content": "    put_ebml_length(pb, size + track->track_num_size + 3, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2186,
          "old_api": "avio_printf",
          "new_api": null,
          "old_text": "avio_printf(pb, \"%.*s\\n%.*s\\n%.*s\", id_size_int, id, settings_size_int, settings, pkt->size, pkt->data)",
          "new_text": null,
          "old_line_content": "    avio_printf(pb, \"%.*s\\n%.*s\\n%.*s\", id_size_int, id, settings_size_int, settings, pkt->size, pkt->data);",
          "new_line_content": "    id_size_int       = id_size;",
          "content_same": false
        },
        {
          "line": 2189,
          "old_api": "end_ebml_master",
          "new_api": null,
          "old_text": "end_ebml_master(pb, blockgroup)",
          "new_text": null,
          "old_line_content": "    end_ebml_master(pb, blockgroup);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2204,
          "old_api": "end_ebml_master_crc32",
          "new_api": null,
          "old_text": "end_ebml_master_crc32(s->pb, &mkv->cluster_bc, mkv,\n                                MATROSKA_ID_CLUSTER, 0, 1, 0)",
          "new_text": null,
          "old_line_content": "    ret = end_ebml_master_crc32(s->pb, &mkv->cluster_bc, mkv,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": "avio_write_marker",
          "new_api": null,
          "old_text": "avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_FLUSH_POINT)",
          "new_text": null,
          "old_line_content": "    avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_FLUSH_POINT);",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 2222,
          "old_api": "av_packet_get_side_data",
          "new_api": null,
          "old_text": "av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA,\n                                        &side_data_size)",
          "new_text": null,
          "old_line_content": "    side_data = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA,",
          "new_line_content": "    int ret;",
          "content_same": false
        },
        {
          "line": 2229,
          "old_api": "get_aac_sample_rates",
          "new_api": null,
          "old_text": "get_aac_sample_rates(s, mkv, side_data, side_data_size,\n                                       &track->sample_rate, &output_sample_rate)",
          "new_text": null,
          "old_line_content": "            ret = get_aac_sample_rates(s, mkv, side_data, side_data_size,",
          "new_line_content": "        if (side_data_size && mkv->track.bc) {",
          "content_same": false
        },
        {
          "line": 2235,
          "old_api": "ff_alloc_extradata",
          "new_api": null,
          "old_text": "ff_alloc_extradata(par, side_data_size)",
          "new_text": null,
          "old_line_content": "            ret = ff_alloc_extradata(par, side_data_size);",
          "new_line_content": "            if (!output_sample_rate)",
          "content_same": false
        },
        {
          "line": 2238,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(par->extradata, side_data, side_data_size)",
          "new_text": null,
          "old_line_content": "            memcpy(par->extradata, side_data, side_data_size);",
          "new_line_content": "            if (ret < 0)",
          "content_same": false
        },
        {
          "line": 2239,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(mkv->track.bc, track->codecpriv_offset, SEEK_SET)",
          "new_text": null,
          "old_line_content": "            avio_seek(mkv->track.bc, track->codecpriv_offset, SEEK_SET);",
          "new_line_content": "                return ret;",
          "content_same": false
        },
        {
          "line": 2244,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(mkv->track.bc, track->sample_rate_offset, SEEK_SET)",
          "new_text": null,
          "old_line_content": "            avio_seek(mkv->track.bc, track->sample_rate_offset, SEEK_SET);",
          "new_line_content": "            if (filler)",
          "content_same": false
        },
        {
          "line": 2249,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Error parsing AAC extradata, unable to determine samplerate.\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(s, AV_LOG_ERROR, \"Error parsing AAC extradata, unable to determine samplerate.\\n\");",
          "new_line_content": "        } else if (!par->extradata_size && !track->sample_rate) {",
          "content_same": false
        },
        {
          "line": 2250,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "            return AVERROR(EINVAL);",
          "new_line_content": "            // No extradata (codecpar or packet side data).",
          "content_same": false
        },
        {
          "line": 2257,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Invalid FLAC STREAMINFO metadata for output stream %d\\n\",\n                       pkt->stream_index)",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_ERROR, \"Invalid FLAC STREAMINFO metadata for output stream %d\\n\",",
          "new_line_content": "            uint8_t *old_extradata = par->extradata;",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(mkv->track.bc, track->codecpriv_offset, SEEK_SET)",
          "new_text": null,
          "old_line_content": "            avio_seek(mkv->track.bc, track->codecpriv_offset, SEEK_SET);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": "mkv_write_codecprivate",
          "new_api": null,
          "old_text": "mkv_write_codecprivate(s, mkv->track.bc, par, 1, 0)",
          "new_text": null,
          "old_line_content": "            mkv_write_codecprivate(s, mkv->track.bc, par, 1, 0);",
          "new_line_content": "            par->extradata = side_data;",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": "ebml_num_size",
          "new_api": null,
          "old_text": "ebml_num_size(length + 1)",
          "new_text": null,
          "old_line_content": "    return ebml_num_size(length + 1);",
          "new_line_content": "static int ebml_length_size(uint64_t length)",
          "content_same": false
        },
        {
          "line": 2274,
          "old_api": "avio_open_dyn_buf",
          "new_api": null,
          "old_text": "avio_open_dyn_buf(&dyn_cp)",
          "new_text": null,
          "old_line_content": "            ret = avio_open_dyn_buf(&dyn_cp);",
          "new_line_content": "            uint8_t *codecpriv;",
          "content_same": false
        },
        {
          "line": 2277,
          "old_api": "ff_isom_write_av1c",
          "new_api": null,
          "old_text": "ff_isom_write_av1c(dyn_cp, side_data, side_data_size)",
          "new_text": null,
          "old_line_content": "            ff_isom_write_av1c(dyn_cp, side_data, side_data_size);",
          "new_line_content": "            if (ret < 0)",
          "content_same": false
        },
        {
          "line": 2278,
          "old_api": "avio_get_dyn_buf",
          "new_api": null,
          "old_text": "avio_get_dyn_buf(dyn_cp, &codecpriv)",
          "new_text": null,
          "old_line_content": "            codecpriv_size = avio_get_dyn_buf(dyn_cp, &codecpriv);",
          "new_line_content": "                return ret;",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": "avio_w8",
          "new_api": null,
          "old_text": "avio_w8(pb, (uint8_t)(num >> i * 8))",
          "new_text": null,
          "old_line_content": "        avio_w8(pb, (uint8_t)(num >> i * 8));",
          "new_line_content": "    num |= 1ULL << bytes * 7;",
          "content_same": false
        },
        {
          "line": 2281,
          "old_api": "ffio_free_dyn_buf",
          "new_api": null,
          "old_text": "ffio_free_dyn_buf(&dyn_cp)",
          "new_text": null,
          "old_line_content": "                ffio_free_dyn_buf(&dyn_cp);",
          "new_line_content": "            if ((ret = dyn_cp->error) < 0 ||",
          "content_same": false
        },
        {
          "line": 2284,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(mkv->track.bc, track->codecpriv_offset, SEEK_SET)",
          "new_text": null,
          "old_line_content": "            avio_seek(mkv->track.bc, track->codecpriv_offset, SEEK_SET);",
          "new_line_content": "                return ret;",
          "content_same": false
        },
        {
          "line": 2287,
          "old_api": "ffio_free_dyn_buf",
          "new_api": null,
          "old_text": "ffio_free_dyn_buf(&dyn_cp)",
          "new_text": null,
          "old_line_content": "            ffio_free_dyn_buf(&dyn_cp);",
          "new_line_content": "            // Do not write the OBUs as we don't have space saved for them",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": "ebml_length_size",
          "new_api": null,
          "old_text": "ebml_length_size(length)",
          "new_text": null,
          "old_line_content": "    int needed_bytes = ebml_length_size(length);",
          "new_line_content": "static void put_ebml_length(AVIOContext *pb, uint64_t length, int bytes)",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(par->extradata, side_data, side_data_size)",
          "new_text": null,
          "old_line_content": "            memcpy(par->extradata, side_data, side_data_size);",
          "new_line_content": "            if (ret < 0)",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(length < (1ULL << 56) - 1)",
          "new_text": null,
          "old_line_content": "    av_assert0(length < (1ULL << 56) - 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2297,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_DEBUG, \"Ignoring new extradata in a packet for stream %d.\\n\", pkt->stream_index)",
          "new_text": null,
          "old_line_content": "            av_log(s, AV_LOG_DEBUG, \"Ignoring new extradata in a packet for stream %d.\\n\", pkt->stream_index);",
          "new_line_content": "    default:",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(bytes >= needed_bytes)",
          "new_text": null,
          "old_line_content": "    av_assert0(bytes >= needed_bytes);",
          "new_line_content": "    // The bytes needed to write the given size must not exceed",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": "put_ebml_num",
          "new_api": null,
          "old_text": "put_ebml_num(pb, length, bytes)",
          "new_text": null,
          "old_line_content": "    put_ebml_num(pb, length, bytes);",
          "new_line_content": "    // the bytes that we ought to use.",
          "content_same": false
        },
        {
          "line": 260,
          "old_api": "put_ebml_id",
          "new_api": null,
          "old_text": "put_ebml_id(pb, elementid)",
          "new_text": null,
          "old_line_content": "    put_ebml_id(pb, elementid);",
          "new_line_content": "static void put_ebml_uid(AVIOContext *pb, uint32_t elementid, uint64_t uid)",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": "put_ebml_length",
          "new_api": null,
          "old_text": "put_ebml_length(pb, 8, 0)",
          "new_text": null,
          "old_line_content": "    put_ebml_length(pb, 8, 0);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2317,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Can't write packet with unknown timestamp\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR, \"Can't write packet with unknown timestamp\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "    if (ts == AV_NOPTS_VALUE) {",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "put_ebml_id",
          "new_api": null,
          "old_text": "put_ebml_id(pb, elementid)",
          "new_text": null,
          "old_line_content": "    put_ebml_id(pb, elementid);",
          "new_line_content": "        bytes++;",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": "put_ebml_length",
          "new_api": null,
          "old_text": "put_ebml_length(pb, bytes, 0)",
          "new_text": null,
          "old_line_content": "    put_ebml_length(pb, bytes, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2325,
          "old_api": "mkv_end_cluster",
          "new_api": null,
          "old_text": "mkv_end_cluster(s)",
          "new_text": null,
          "old_line_content": "            ret = mkv_end_cluster(s);",
          "new_line_content": "        int64_t cluster_time = ts - mkv->cluster_pts;",
          "content_same": false
        },
        {
          "line": 2328,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_WARNING, \"Starting new cluster due to timestamp\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(s, AV_LOG_WARNING, \"Starting new cluster due to timestamp\\n\");",
          "new_line_content": "            if (ret < 0)",
          "content_same": false
        },
        {
          "line": 2333,
          "old_api": "start_ebml_master_crc32",
          "new_api": null,
          "old_text": "start_ebml_master_crc32(&mkv->cluster_bc, mkv)",
          "new_text": null,
          "old_line_content": "        ret = start_ebml_master_crc32(&mkv->cluster_bc, mkv);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": "put_ebml_id",
          "new_api": null,
          "old_text": "put_ebml_id(pb, elementid)",
          "new_text": null,
          "old_line_content": "    put_ebml_id(pb, elementid);",
          "new_line_content": "        bytes++;",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": "put_ebml_length",
          "new_api": null,
          "old_text": "put_ebml_length(pb, bytes, 0)",
          "new_text": null,
          "old_line_content": "    put_ebml_length(pb, bytes, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2336,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(s->pb)",
          "new_text": null,
          "old_line_content": "        mkv->cluster_pos = avio_tell(s->pb);",
          "new_line_content": "        if (ret < 0)",
          "content_same": false
        },
        {
          "line": 2337,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(0, ts)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(mkv->cluster_bc, MATROSKA_ID_CLUSTERTIMECODE, FFMAX(0, ts));",
          "new_line_content": "            return ret;",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": "put_ebml_id",
          "new_api": null,
          "old_text": "put_ebml_id(pb, elementid)",
          "new_text": null,
          "old_line_content": "    put_ebml_id(pb, elementid);",
          "new_line_content": "static void put_ebml_float(AVIOContext *pb, uint32_t elementid, double val)",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": "put_ebml_length",
          "new_api": null,
          "old_text": "put_ebml_length(pb, 8, 0)",
          "new_text": null,
          "old_line_content": "    put_ebml_length(pb, 8, 0);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2346,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "    relative_packet_pos = avio_tell(pb);",
          "new_line_content": "    pb = mkv->cluster_bc;",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": "put_ebml_id",
          "new_api": null,
          "old_text": "put_ebml_id(pb, elementid)",
          "new_text": null,
          "old_line_content": "    put_ebml_id(pb, elementid);",
          "new_line_content": "                            const void *buf, int size)",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": "put_ebml_length",
          "new_api": null,
          "old_text": "put_ebml_length(pb, size, 0)",
          "new_text": null,
          "old_line_content": "    put_ebml_length(pb, size, 0);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2350,
          "old_api": "mkv_write_block",
          "new_api": null,
          "old_text": "mkv_write_block(s, pb, MATROSKA_ID_SIMPLEBLOCK, pkt, keyframe)",
          "new_text": null,
          "old_line_content": "        ret = mkv_write_block(s, pb, MATROSKA_ID_SIMPLEBLOCK, pkt, keyframe);",
          "new_line_content": "    if (par->codec_type != AVMEDIA_TYPE_SUBTITLE ||",
          "content_same": false
        },
        {
          "line": 2353,
          "old_api": "IS_SEEKABLE",
          "new_api": null,
          "old_text": "IS_SEEKABLE(s->pb, mkv)",
          "new_text": null,
          "old_line_content": "        if (keyframe && IS_SEEKABLE(s->pb, mkv) &&",
          "new_line_content": "        if (ret < 0)",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": "mkv_add_cuepoint",
          "new_api": null,
          "old_text": "mkv_add_cuepoint(mkv, pkt->stream_index, ts,\n                                   mkv->cluster_pos, relative_packet_pos, 0)",
          "new_text": null,
          "old_line_content": "            ret = mkv_add_cuepoint(mkv, pkt->stream_index, ts,",
          "new_line_content": "             par->codec_type == AVMEDIA_TYPE_SUBTITLE ||",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "strlen",
          "new_api": null,
          "old_text": "strlen(str)",
          "new_text": null,
          "old_line_content": "    put_ebml_binary(pb, elementid, str, strlen(str));",
          "new_line_content": "                            const char *str)",
          "content_same": false
        },
        {
          "line": 2365,
          "old_api": "mkv_write_vtt_blocks",
          "new_api": null,
          "old_text": "mkv_write_vtt_blocks(s, pb, pkt)",
          "new_text": null,
          "old_line_content": "            ret = mkv_write_vtt_blocks(s, pb, pkt);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(size >= 2)",
          "new_text": null,
          "old_line_content": "    av_assert0(size >= 2);",
          "new_line_content": "static void put_ebml_void(AVIOContext *pb, int size)",
          "content_same": false
        },
        {
          "line": 2369,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,\n                                                       mkv_blockgroup_size(pkt->size,\n                                                                           track->track_num_size))",
          "new_text": null,
          "old_line_content": "            ebml_master blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,",
          "new_line_content": "                return ret;",
          "content_same": false
        },
        {
          "line": 2370,
          "old_api": "mkv_blockgroup_size",
          "new_api": null,
          "old_text": "mkv_blockgroup_size(pkt->size,\n                                                                           track->track_num_size)",
          "new_text": null,
          "old_line_content": "                                                       mkv_blockgroup_size(pkt->size,",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": "put_ebml_length",
          "new_api": null,
          "old_text": "put_ebml_length(pb, size, 0)",
          "new_text": null,
          "old_line_content": "        put_ebml_length(pb, size, 0);",
          "new_line_content": "    if (size < 10) {",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": "put_ebml_length",
          "new_api": null,
          "old_text": "put_ebml_length(pb, size, 8)",
          "new_text": null,
          "old_line_content": "        put_ebml_length(pb, size, 8);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 2383,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration)",
          "new_text": null,
          "old_line_content": "            put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);",
          "new_line_content": "            /* All subtitle blocks are considered to be keyframes. */",
          "content_same": false
        },
        {
          "line": 2384,
          "old_api": "end_ebml_master",
          "new_api": null,
          "old_text": "end_ebml_master(pb, blockgroup)",
          "new_text": null,
          "old_line_content": "            end_ebml_master(pb, blockgroup);",
          "new_line_content": "            mkv_write_block(s, pb, MATROSKA_ID_BLOCK, pkt, 1);",
          "content_same": false
        },
        {
          "line": 2387,
          "old_api": "IS_SEEKABLE",
          "new_api": null,
          "old_text": "IS_SEEKABLE(s->pb, mkv)",
          "new_text": null,
          "old_line_content": "        if (IS_SEEKABLE(s->pb, mkv)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": "ebml_length_size",
          "new_api": null,
          "old_text": "ebml_length_size(expectedsize)",
          "new_text": null,
          "old_line_content": "    int bytes = expectedsize ? ebml_length_size(expectedsize) : 8;",
          "new_line_content": "                                     uint64_t expectedsize)",
          "content_same": false
        },
        {
          "line": 2388,
          "old_api": "mkv_add_cuepoint",
          "new_api": null,
          "old_text": "mkv_add_cuepoint(mkv, pkt->stream_index, ts,\n                                   mkv->cluster_pos, relative_packet_pos, duration)",
          "new_text": null,
          "old_line_content": "            ret = mkv_add_cuepoint(mkv, pkt->stream_index, ts,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": "put_ebml_size_unknown",
          "new_api": null,
          "old_text": "put_ebml_size_unknown(pb, bytes)",
          "new_text": null,
          "old_line_content": "    put_ebml_size_unknown(pb, bytes);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2395,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(mkv->duration,   ts + duration)",
          "new_text": null,
          "old_line_content": "    mkv->duration   = FFMAX(mkv->duration,   ts + duration);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(track->duration, ts + duration)",
          "new_text": null,
          "old_line_content": "    track->duration = FFMAX(track->duration, ts + duration);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "    int64_t pos = avio_tell(pb);",
          "new_line_content": "static void end_ebml_master(AVIOContext *pb, ebml_master master)",
          "content_same": false
        },
        {
          "line": 354,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(pb, pos, SEEK_SET)",
          "new_text": null,
          "old_line_content": "    avio_seek(pb, pos, SEEK_SET);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 362,
          "old_api": "av_assert1",
          "new_api": null,
          "old_text": "av_assert1(seekhead->num_entries < MAX_SEEKHEAD_ENTRIES)",
          "new_text": null,
          "old_line_content": "    av_assert1(seekhead->num_entries < MAX_SEEKHEAD_ENTRIES);",
          "new_line_content": "    mkv_seekhead *seekhead = &mkv->seekhead;",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": "mkv_check_new_extra_data",
          "new_api": null,
          "old_text": "mkv_check_new_extra_data(s, pkt)",
          "new_text": null,
          "old_line_content": "    ret = mkv_check_new_extra_data(s, pkt);",
          "new_line_content": "    int start_new_cluster;",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "avio_open_dyn_buf",
          "new_api": null,
          "old_text": "avio_open_dyn_buf(dyn_cp)",
          "new_text": null,
          "old_line_content": "    if (!*dyn_cp && (ret = avio_open_dyn_buf(dyn_cp)) < 0)",
          "new_line_content": "    int ret;",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(mkv->cluster_bc)",
          "new_text": null,
          "old_line_content": "        cluster_size  = avio_tell(mkv->cluster_bc);",
          "new_line_content": "        cluster_time += mkv->tracks[pkt->stream_index].ts_offset;",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": "put_ebml_void",
          "new_api": null,
          "old_text": "put_ebml_void(*dyn_cp, 6)",
          "new_text": null,
          "old_line_content": "        put_ebml_void(*dyn_cp, 6); /* Reserve space for CRC32 so position/size calculations using avio_tell() take it into account */",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": "avio_get_dyn_buf",
          "new_api": null,
          "old_text": "avio_get_dyn_buf(*dyn_cp, &buf)",
          "new_text": null,
          "old_line_content": "    size = avio_get_dyn_buf(*dyn_cp, &buf);",
          "new_line_content": "    int ret, size, skip = 0;",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "        mkv_add_seekhead_entry(mkv, id, avio_tell(pb));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": "mkv_end_cluster",
          "new_api": null,
          "old_text": "mkv_end_cluster(s)",
          "new_text": null,
          "old_line_content": "            ret = mkv_end_cluster(s);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": "put_ebml_length",
          "new_api": null,
          "old_text": "put_ebml_length(pb, size, length_size)",
          "new_text": null,
          "old_line_content": "    put_ebml_length(pb, size, length_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 400,
          "old_api": "av_crc_get_table",
          "new_api": null,
          "old_text": "av_crc_get_table(AV_CRC_32_IEEE_LE)",
          "new_text": null,
          "old_line_content": "        AV_WL32(crc, av_crc(av_crc_get_table(AV_CRC_32_IEEE_LE), UINT32_MAX, buf + skip, size - skip) ^ UINT32_MAX);",
          "new_line_content": "    if (mkv->write_crc) {",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": "put_ebml_binary",
          "new_api": null,
          "old_text": "put_ebml_binary(pb, EBML_ID_CRC32, crc, sizeof(crc))",
          "new_text": null,
          "old_line_content": "        put_ebml_binary(pb, EBML_ID_CRC32, crc, sizeof(crc));",
          "new_line_content": "        skip = 6; /* Skip reserved 6-byte long void element from the dynamic buffer. */",
          "content_same": false
        },
        {
          "line": 2450,
          "old_api": "avio_write_marker",
          "new_api": null,
          "old_text": "avio_write_marker(s->pb,\n                          av_rescale_q(pkt->dts, s->streams[pkt->stream_index]->time_base, AV_TIME_BASE_Q),\n                          keyframe && (mkv->have_video ? codec_type == AVMEDIA_TYPE_VIDEO : 1) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT)",
          "new_text": null,
          "old_line_content": "        avio_write_marker(s->pb,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2451,
          "old_api": "av_rescale_q",
          "new_api": null,
          "old_text": "av_rescale_q(pkt->dts, s->streams[pkt->stream_index]->time_base, AV_TIME_BASE_Q)",
          "new_text": null,
          "old_line_content": "                          av_rescale_q(pkt->dts, s->streams[pkt->stream_index]->time_base, AV_TIME_BASE_Q),",
          "new_line_content": "    if (!mkv->cluster_pos)",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": "ffio_reset_dyn_buf",
          "new_api": null,
          "old_text": "ffio_reset_dyn_buf(*dyn_cp)",
          "new_text": null,
          "old_line_content": "        ffio_reset_dyn_buf(*dyn_cp);",
          "new_line_content": "fail:",
          "content_same": false
        },
        {
          "line": 2456,
          "old_api": "mkv_write_packet_internal",
          "new_api": null,
          "old_text": "mkv_write_packet_internal(s, mkv->cur_audio_pkt)",
          "new_text": null,
          "old_line_content": "        ret = mkv_write_packet_internal(s, mkv->cur_audio_pkt);",
          "new_line_content": "    // check if we have an audio packet cached",
          "content_same": false
        },
        {
          "line": 2457,
          "old_api": "av_packet_unref",
          "new_api": null,
          "old_text": "av_packet_unref(mkv->cur_audio_pkt)",
          "new_text": null,
          "old_line_content": "        av_packet_unref(mkv->cur_audio_pkt);",
          "new_line_content": "    if (mkv->cur_audio_pkt->size > 0) {",
          "content_same": false
        },
        {
          "line": 2469,
          "old_api": "av_packet_ref",
          "new_api": null,
          "old_text": "av_packet_ref(mkv->cur_audio_pkt, pkt)",
          "new_text": null,
          "old_line_content": "            ret = av_packet_ref(mkv->cur_audio_pkt, pkt);",
          "new_line_content": "    if (codec_type == AVMEDIA_TYPE_AUDIO) {",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "IS_SEEKABLE",
          "new_api": null,
          "old_text": "IS_SEEKABLE(pb, mkv)",
          "new_text": null,
          "old_line_content": "    if (IS_SEEKABLE(pb, mkv)) {",
          "new_line_content": "                                             MatroskaMuxContext *mkv, uint32_t id)",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "        elem->pos = avio_tell(pb);",
          "new_line_content": "            return elem->bc->error;",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": "mkv_add_seekhead_entry",
          "new_api": null,
          "old_text": "mkv_add_seekhead_entry(mkv, id, elem->pos)",
          "new_text": null,
          "old_line_content": "        mkv_add_seekhead_entry(mkv, id, elem->pos);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": "put_ebml_length",
          "new_api": null,
          "old_text": "put_ebml_length(pb, size, 0)",
          "new_text": null,
          "old_line_content": "        put_ebml_length(pb, size, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": "mkv_end_cluster",
          "new_api": null,
          "old_text": "mkv_end_cluster(s)",
          "new_text": null,
          "old_line_content": "            int ret = mkv_end_cluster(s);",
          "new_line_content": "    if (!pkt) {",
          "content_same": false
        },
        {
          "line": 2484,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_DEBUG,\n                   \"Flushing cluster at offset %\" PRIu64 \" bytes\\n\",\n                   avio_tell(s->pb))",
          "new_text": null,
          "old_line_content": "            av_log(s, AV_LOG_DEBUG,",
          "new_line_content": "            if (ret < 0)",
          "content_same": false
        },
        {
          "line": 438,
          "old_api": "end_ebml_master_crc32",
          "new_api": null,
          "old_text": "end_ebml_master_crc32(pb, &elem->bc, mkv, id, 0, 0, 1)",
          "new_text": null,
          "old_line_content": "        return end_ebml_master_crc32(pb, &elem->bc, mkv, id, 0, 0, 1);",
          "new_line_content": "        return 0;",
          "content_same": false
        },
        {
          "line": 2490,
          "old_api": "mkv_write_packet",
          "new_api": null,
          "old_text": "mkv_write_packet(s, pkt)",
          "new_text": null,
          "old_line_content": "    return mkv_write_packet(s, pkt);",
          "new_line_content": "        return 1;",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": "ffio_fill",
          "new_api": null,
          "old_text": "ffio_fill(pb, 255, size / 255)",
          "new_text": null,
          "old_line_content": "    ffio_fill(pb, 255, size / 255);",
          "new_line_content": "static void put_xiph_size(AVIOContext *pb, int size)",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": "avio_w8",
          "new_api": null,
          "old_text": "avio_w8(pb, size % 255)",
          "new_text": null,
          "old_line_content": "    avio_w8(pb, size % 255);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": "av_packet_free",
          "new_api": null,
          "old_text": "av_packet_free(&mkv->cur_audio_pkt)",
          "new_text": null,
          "old_line_content": "    av_packet_free(&mkv->cur_audio_pkt);",
          "new_line_content": "    MatroskaMuxContext *mkv = s->priv_data;",
          "content_same": false
        },
        {
          "line": 2502,
          "old_api": "mkv_write_packet_internal",
          "new_api": null,
          "old_text": "mkv_write_packet_internal(s, mkv->cur_audio_pkt)",
          "new_text": null,
          "old_line_content": "        ret = mkv_write_packet_internal(s, mkv->cur_audio_pkt);",
          "new_line_content": "    // check if we have an audio packet cached",
          "content_same": false
        },
        {
          "line": 457,
          "old_api": "ffio_free_dyn_buf",
          "new_api": null,
          "old_text": "ffio_free_dyn_buf(&mkv->info.bc)",
          "new_text": null,
          "old_line_content": "    ffio_free_dyn_buf(&mkv->info.bc);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&mkv->tracks)",
          "new_text": null,
          "old_line_content": "    av_freep(&mkv->tracks);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2511,
          "old_api": "end_ebml_master_crc32",
          "new_api": null,
          "old_text": "end_ebml_master_crc32(pb, &mkv->cluster_bc, mkv,\n                                    MATROSKA_ID_CLUSTER, 0, 0, 0)",
          "new_text": null,
          "old_line_content": "        ret = end_ebml_master_crc32(pb, &mkv->cluster_bc, mkv,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2517,
          "old_api": "mkv_write_chapters",
          "new_api": null,
          "old_text": "mkv_write_chapters(s)",
          "new_text": null,
          "old_line_content": "    ret = mkv_write_chapters(s);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "    mkv->seekhead.filepos = avio_tell(pb);",
          "new_line_content": "static void mkv_start_seekhead(MatroskaMuxContext *mkv, AVIOContext *pb)",
          "content_same": false
        },
        {
          "line": 2521,
          "old_api": "IS_SEEKABLE",
          "new_api": null,
          "old_text": "IS_SEEKABLE(pb, mkv)",
          "new_text": null,
          "old_line_content": "    if (!IS_SEEKABLE(pb, mkv))",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 2524,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "    endpos = avio_tell(pb);",
          "new_line_content": "        return 0;",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": "put_ebml_void",
          "new_api": null,
          "old_text": "put_ebml_void(pb, mkv->seekhead.reserved_size)",
          "new_text": null,
          "old_line_content": "    put_ebml_void(pb, mkv->seekhead.reserved_size);",
          "new_line_content": "    // that an EBML void element will fit afterwards",
          "content_same": false
        },
        {
          "line": 2531,
          "old_api": "start_ebml_master_crc32",
          "new_api": null,
          "old_text": "start_ebml_master_crc32(&cues, mkv)",
          "new_text": null,
          "old_line_content": "        ret = start_ebml_master_crc32(&cues, mkv);",
          "new_line_content": "        int length_size = 0;",
          "content_same": false
        },
        {
          "line": 2535,
          "old_api": "mkv_assemble_cues",
          "new_api": null,
          "old_text": "mkv_assemble_cues(s->streams, cues, &mkv->cues,\n                                mkv->tracks, s->nb_streams)",
          "new_text": null,
          "old_line_content": "        ret = mkv_assemble_cues(s->streams, cues, &mkv->cues,",
          "new_line_content": "            return ret;",
          "content_same": false
        },
        {
          "line": 2538,
          "old_api": "ffio_free_dyn_buf",
          "new_api": null,
          "old_text": "ffio_free_dyn_buf(&cues)",
          "new_text": null,
          "old_line_content": "            ffio_free_dyn_buf(&cues);",
          "new_line_content": "                                mkv->tracks, s->nb_streams);",
          "content_same": false
        },
        {
          "line": 2543,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(cues)",
          "new_text": null,
          "old_line_content": "            size  = avio_tell(cues);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2544,
          "old_api": "ebml_length_size",
          "new_api": null,
          "old_text": "ebml_length_size(size)",
          "new_text": null,
          "old_line_content": "            length_size = ebml_length_size(size);",
          "new_line_content": "        if (mkv->reserve_cues_space) {",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(pb, seekhead->filepos, SEEK_SET)",
          "new_text": null,
          "old_line_content": "    if ((ret64 = avio_seek(pb, seekhead->filepos, SEEK_SET)) < 0)",
          "new_line_content": "    int i, ret;",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_WARNING,\n                       \"Insufficient space reserved for Cues: \"\n                       \"%d < %\"PRIu64\". No Cues will be output.\\n\",\n                       mkv->reserve_cues_space, size)",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_WARNING,",
          "new_line_content": "            size += 4 + length_size;",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "start_ebml_master_crc32",
          "new_api": null,
          "old_text": "start_ebml_master_crc32(&dyn_cp, mkv)",
          "new_text": null,
          "old_line_content": "    ret = start_ebml_master_crc32(&dyn_cp, mkv);",
          "new_line_content": "        return error_on_seek_failure ? ret64 : 0;",
          "content_same": false
        },
        {
          "line": 2551,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "                ret2 = AVERROR(EINVAL);",
          "new_line_content": "                       \"%d < %\"PRIu64\". No Cues will be output.\\n\",",
          "content_same": false
        },
        {
          "line": 2554,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(pb, mkv->cues_pos, SEEK_SET)",
          "new_text": null,
          "old_line_content": "                if ((ret64 = avio_seek(pb, mkv->cues_pos, SEEK_SET)) < 0) {",
          "new_line_content": "                goto after_cues;",
          "content_same": false
        },
        {
          "line": 2555,
          "old_api": "ffio_free_dyn_buf",
          "new_api": null,
          "old_text": "ffio_free_dyn_buf(&cues)",
          "new_text": null,
          "old_line_content": "                    ffio_free_dyn_buf(&cues);",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(dyn_cp, MATROSKA_ID_SEEKENTRY,\n                                                  MAX_SEEKENTRY_SIZE)",
          "new_text": null,
          "old_line_content": "        ebml_master seekentry = start_ebml_master(dyn_cp, MATROSKA_ID_SEEKENTRY,",
          "new_line_content": "    for (i = 0; i < seekhead->num_entries; i++) {",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": "put_ebml_id",
          "new_api": null,
          "old_text": "put_ebml_id(dyn_cp, MATROSKA_ID_SEEKID)",
          "new_text": null,
          "old_line_content": "        put_ebml_id(dyn_cp, MATROSKA_ID_SEEKID);",
          "new_line_content": "                                                  MAX_SEEKENTRY_SIZE);",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": "ebml_id_size",
          "new_api": null,
          "old_text": "ebml_id_size(entry->elementid)",
          "new_text": null,
          "old_line_content": "        put_ebml_length(dyn_cp, ebml_id_size(entry->elementid), 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 515,
          "old_api": "end_ebml_master",
          "new_api": null,
          "old_text": "end_ebml_master(dyn_cp, seekentry)",
          "new_text": null,
          "old_line_content": "        end_ebml_master(dyn_cp, seekentry);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2569,
          "old_api": "end_ebml_master_crc32",
          "new_api": null,
          "old_text": "end_ebml_master_crc32(pb, &cues, mkv, MATROSKA_ID_CUES,\n                                    length_size, 0, 1)",
          "new_text": null,
          "old_line_content": "        ret = end_ebml_master_crc32(pb, &cues, mkv, MATROSKA_ID_CUES,",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "    remaining = seekhead->filepos + seekhead->reserved_size - avio_tell(pb);",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": "put_ebml_void",
          "new_api": null,
          "old_text": "put_ebml_void(pb, remaining)",
          "new_text": null,
          "old_line_content": "    put_ebml_void(pb, remaining);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2575,
          "old_api": "put_ebml_void",
          "new_api": null,
          "old_text": "put_ebml_void(pb, mkv->reserve_cues_space - size)",
          "new_text": null,
          "old_line_content": "                put_ebml_void(pb, mkv->reserve_cues_space - size);",
          "new_line_content": "        if (mkv->reserve_cues_space) {",
          "content_same": false
        },
        {
          "line": 2584,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(pb, mkv->segment_offset - 8, SEEK_SET)",
          "new_text": null,
          "old_line_content": "        if ((ret64 = avio_seek(pb, mkv->segment_offset - 8, SEEK_SET)) < 0)",
          "new_line_content": "     * via an EBML number, so leave the unknown length field. */",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": "av_realloc_array",
          "new_api": null,
          "old_text": "av_realloc_array(entries, cues->num_entries + 1, sizeof(mkv_cuepoint))",
          "new_text": null,
          "old_line_content": "    entries = av_realloc_array(entries, cues->num_entries + 1, sizeof(mkv_cuepoint));",
          "new_line_content": "        return 0;",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": "mkv_write_seekhead",
          "new_api": null,
          "old_text": "mkv_write_seekhead(pb, mkv, 1, mkv->info.pos)",
          "new_text": null,
          "old_line_content": "    ret = mkv_write_seekhead(pb, mkv, 1, mkv->info.pos);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2595,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_DEBUG, \"end duration = %\" PRIu64 \"\\n\", mkv->duration)",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_DEBUG, \"end duration = %\" PRIu64 \"\\n\", mkv->duration);",
          "new_line_content": "    if (mkv->info.bc) {",
          "content_same": false
        },
        {
          "line": 2596,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(mkv->info.bc, mkv->duration_offset, SEEK_SET)",
          "new_text": null,
          "old_line_content": "        avio_seek(mkv->info.bc, mkv->duration_offset, SEEK_SET);",
          "new_line_content": "        // update the duration",
          "content_same": false
        },
        {
          "line": 2606,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(pb, mkv->track.pos, SEEK_SET)",
          "new_text": null,
          "old_line_content": "        avio_seek(pb, mkv->track.pos, SEEK_SET);",
          "new_line_content": "    if (mkv->track.bc) {",
          "content_same": false
        },
        {
          "line": 2607,
          "old_api": "end_ebml_master_crc32",
          "new_api": null,
          "old_text": "end_ebml_master_crc32(pb, &mkv->track.bc, mkv,\n                                    MATROSKA_ID_TRACKS, 0, 0, 0)",
          "new_text": null,
          "old_line_content": "        ret = end_ebml_master_crc32(pb, &mkv->track.bc, mkv,",
          "new_line_content": "        // write Tracks master",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": "avio_open_dyn_buf",
          "new_api": null,
          "old_text": "avio_open_dyn_buf(&cuepoint)",
          "new_text": null,
          "old_line_content": "    ret = avio_open_dyn_buf(&cuepoint);",
          "new_line_content": "    int ret;",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(cuepoint, MATROSKA_ID_CUETIME, pts)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(cuepoint, MATROSKA_ID_CUETIME, pts);",
          "new_line_content": "        int size;",
          "content_same": false
        },
        {
          "line": 2621,
          "old_api": "av_q2d",
          "new_api": null,
          "old_text": "av_q2d(st->time_base)",
          "new_text": null,
          "old_line_content": "                double duration_sec = track->duration * av_q2d(st->time_base);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2624,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_DEBUG, \"stream %d end duration = %\" PRIu64 \"\\n\", i,\n                       track->duration)",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_DEBUG, \"stream %d end duration = %\" PRIu64 \"\\n\", i,",
          "new_line_content": "                char duration_string[20] = \"\";",
          "content_same": false
        },
        {
          "line": 2627,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(mkv->tags.bc, track->duration_offset, SEEK_SET)",
          "new_text": null,
          "old_line_content": "                avio_seek(mkv->tags.bc, track->duration_offset, SEEK_SET);",
          "new_line_content": "                       track->duration);",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(idx >= 0 && idx < num_tracks)",
          "new_text": null,
          "old_line_content": "            av_assert0(idx >= 0 && idx < num_tracks);",
          "new_line_content": "            int idx = entry->stream_idx;",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(cuepoint, MATROSKA_ID_CUETRACKPOSITION, MAX_CUETRACKPOS_SIZE)",
          "new_text": null,
          "old_line_content": "            track_positions = start_ebml_master(cuepoint, MATROSKA_ID_CUETRACKPOSITION, MAX_CUETRACKPOS_SIZE);",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(cuepoint, MATROSKA_ID_CUETRACK           , tracks[idx].track_num)",
          "new_text": null,
          "old_line_content": "            put_ebml_uint(cuepoint, MATROSKA_ID_CUETRACK           , tracks[idx].track_num);",
          "new_line_content": "            tracks[idx].has_cue = 1;",
          "content_same": false
        },
        {
          "line": 2637,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(pb, mkv->tags.pos, SEEK_SET)",
          "new_text": null,
          "old_line_content": "        avio_seek(pb, mkv->tags.pos, SEEK_SET);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": "end_ebml_master",
          "new_api": null,
          "old_text": "end_ebml_master(cuepoint, track_positions)",
          "new_text": null,
          "old_line_content": "            end_ebml_master(cuepoint, track_positions);",
          "new_line_content": "            if (entry->duration > 0)",
          "content_same": false
        },
        {
          "line": 2638,
          "old_api": "end_ebml_master_crc32",
          "new_api": null,
          "old_text": "end_ebml_master_crc32(pb, &mkv->tags.bc, mkv,\n                                    MATROSKA_ID_TAGS, 0, 0, 0)",
          "new_text": null,
          "old_line_content": "        ret = end_ebml_master_crc32(pb, &mkv->tags.bc, mkv,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "put_ebml_binary",
          "new_api": null,
          "old_text": "put_ebml_binary(dyn_cp, MATROSKA_ID_POINTENTRY, buf, size)",
          "new_text": null,
          "old_line_content": "        put_ebml_binary(dyn_cp, MATROSKA_ID_POINTENTRY, buf, size);",
          "new_line_content": "        if ((ret = cuepoint->error) < 0)",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": "ffio_reset_dyn_buf",
          "new_api": null,
          "old_text": "ffio_reset_dyn_buf(cuepoint)",
          "new_text": null,
          "old_line_content": "        ffio_reset_dyn_buf(cuepoint);",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 2644,
          "old_api": "avio_seek",
          "new_api": null,
          "old_text": "avio_seek(pb, endpos, SEEK_SET)",
          "new_text": null,
          "old_line_content": "    avio_seek(pb, endpos, SEEK_SET);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2657,
          "old_api": "avcodec_get_type",
          "new_api": null,
          "old_text": "avcodec_get_type(codec_id)",
          "new_text": null,
          "old_line_content": "        enum AVMediaType type = avcodec_get_type(codec_id);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": "avpriv_split_xiph_headers",
          "new_api": null,
          "old_text": "avpriv_split_xiph_headers(par->extradata, par->extradata_size,\n                                    first_header_size, header_start, header_len)",
          "new_text": null,
          "old_line_content": "    err = avpriv_split_xiph_headers(par->extradata, par->extradata_size,",
          "new_line_content": "        first_header_size = 42;",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Extradata corrupt.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR, \"Extradata corrupt.\\n\");",
          "new_line_content": "                                    first_header_size, header_start, header_len);",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": "avio_w8",
          "new_api": null,
          "old_text": "avio_w8(pb, 2)",
          "new_text": null,
          "old_line_content": "    avio_w8(pb, 2);                    // number packets - 1",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "avio_write",
          "new_api": null,
          "old_text": "avio_write(pb, header_start[j], header_len[j])",
          "new_text": null,
          "old_line_content": "        avio_write(pb, header_start[j], header_len[j]);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2681,
          "old_api": "av_lfg_get",
          "new_api": null,
          "old_text": "av_lfg_get(c)",
          "new_text": null,
          "old_line_content": "        uid  = (uint64_t)av_lfg_get(c) << 32;",
          "new_line_content": "        uint64_t uid;",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": "av_lfg_get",
          "new_api": null,
          "old_text": "av_lfg_get(c)",
          "new_text": null,
          "old_line_content": "        uid |= av_lfg_get(c);",
          "new_line_content": "        int k;",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": "avio_write",
          "new_api": null,
          "old_text": "avio_write(pb, par->extradata, 2)",
          "new_text": null,
          "old_line_content": "        avio_write(pb, par->extradata, 2);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "ff_flac_is_native_layout",
          "new_api": null,
          "old_text": "ff_flac_is_native_layout(par->channel_layout)",
          "new_text": null,
          "old_line_content": "                         !ff_flac_is_native_layout(par->channel_layout));",
          "new_line_content": "    int write_comment = (par->channel_layout &&",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "ff_flac_write_header",
          "new_api": null,
          "old_text": "ff_flac_write_header(pb, par->extradata, par->extradata_size,\n                                   !write_comment)",
          "new_text": null,
          "old_line_content": "    int ret = ff_flac_write_header(pb, par->extradata, par->extradata_size,",
          "new_line_content": "                         !(par->channel_layout & ~0x3ffffULL) &&",
          "content_same": false
        },
        {
          "line": 2708,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR,\n                   \"The Matroska muxer does not yet support muxing %s\\n\",\n                   avcodec_get_name(s->streams[i]->codecpar->codec_id))",
          "new_text": null,
          "old_line_content": "            av_log(s, AV_LOG_ERROR,",
          "new_line_content": "            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": "snprintf",
          "new_api": null,
          "old_text": "snprintf(buf, sizeof(buf), \"0x%\"PRIx64, par->channel_layout)",
          "new_text": null,
          "old_line_content": "        snprintf(buf, sizeof(buf), \"0x%\"PRIx64, par->channel_layout);",
          "new_line_content": "        int64_t len;",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": "av_dict_set",
          "new_api": null,
          "old_text": "av_dict_set(&dict, \"WAVEFORMATEXTENSIBLE_CHANNEL_MASK\", buf, 0)",
          "new_text": null,
          "old_line_content": "        av_dict_set(&dict, \"WAVEFORMATEXTENSIBLE_CHANNEL_MASK\", buf, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": "av_assert1",
          "new_api": null,
          "old_text": "av_assert1(len < (1 << 24) - 4)",
          "new_text": null,
          "old_line_content": "        av_assert1(len < (1 << 24) - 4);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": "avio_wb24",
          "new_api": null,
          "old_text": "avio_wb24(pb, len)",
          "new_text": null,
          "old_line_content": "        avio_wb24(pb, len);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2720,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(s->oformat->name, \"webm\")",
          "new_text": null,
          "old_line_content": "    if (!strcmp(s->oformat->name, \"webm\")) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2726,
          "old_api": "av_packet_alloc",
          "new_api": null,
          "old_text": "av_packet_alloc()",
          "new_text": null,
          "old_line_content": "    mkv->cur_audio_pkt = av_packet_alloc();",
          "new_line_content": "        mkv->mode = MODE_MATROSKAv2;",
          "content_same": false
        },
        {
          "line": 2729,
          "old_api": "av_mallocz_array",
          "new_api": null,
          "old_text": "av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks))",
          "new_text": null,
          "old_line_content": "    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));",
          "new_line_content": "    if (!mkv->cur_audio_pkt)",
          "content_same": false
        },
        {
          "line": 685,
          "old_api": "avpriv_mpeg4audio_get_config2",
          "new_api": null,
          "old_text": "avpriv_mpeg4audio_get_config2(&mp4ac, extradata, extradata_size, 1, s)",
          "new_text": null,
          "old_line_content": "    ret = avpriv_mpeg4audio_get_config2(&mp4ac, extradata, extradata_size, 1, s);",
          "new_line_content": "    int ret;",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": "av_get_random_seed",
          "new_api": null,
          "old_text": "av_get_random_seed()",
          "new_text": null,
          "old_line_content": "        av_lfg_init(&c, av_get_random_seed());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2738,
          "old_api": "av_lfg_get",
          "new_api": null,
          "old_text": "av_lfg_get(&c)",
          "new_text": null,
          "old_line_content": "            mkv->segment_uid[i] = av_lfg_get(&c);",
          "new_line_content": "        // Calculate the SegmentUID now in order not to waste our random seed.",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": "IS_SEEKABLE",
          "new_api": null,
          "old_text": "IS_SEEKABLE(s->pb, mkv)",
          "new_text": null,
          "old_line_content": "    if (ret < 0 && (extradata_size || !IS_SEEKABLE(s->pb, mkv))) {",
          "new_line_content": "     * Abort however if s->pb is not seekable, as we would not be able to seek back",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR,\n               \"Error parsing AAC extradata, unable to determine samplerate.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR,",
          "new_line_content": "     * to write the sample rate elements once the extradata shows up, anyway. */",
          "content_same": false
        },
        {
          "line": 2748,
          "old_api": "mkv_get_uid",
          "new_api": null,
          "old_text": "mkv_get_uid(mkv->tracks, i, &c)",
          "new_text": null,
          "old_line_content": "            track->uid = mkv_get_uid(mkv->tracks, i, &c);",
          "new_line_content": "            track->uid = i + 1;",
          "content_same": false
        },
        {
          "line": 2752,
          "old_api": "avpriv_set_pts_info",
          "new_api": null,
          "old_text": "avpriv_set_pts_info(st, 64, 1, 1000)",
          "new_text": null,
          "old_line_content": "        avpriv_set_pts_info(st, 64, 1, 1000);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2756,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_WARNING, \"Stream %d will be ignored \"\n                       \"as WebM doesn't support attachments.\\n\", i)",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_WARNING, \"Stream %d will be ignored \"",
          "new_line_content": "        if (st->codecpar->codec_type == AVMEDIA_TYPE_ATTACHMENT) {",
          "content_same": false
        },
        {
          "line": 2759,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Attachment stream %d has no mimetype \"\n                       \"tag and it cannot be deduced from the codec id.\\n\", i)",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_ERROR, \"Attachment stream %d has no mimetype \"",
          "new_line_content": "                       \"as WebM doesn't support attachments.\\n\", i);",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": "put_xiph_codecpriv",
          "new_api": null,
          "old_text": "put_xiph_codecpriv(s, dyn_cp, par)",
          "new_text": null,
          "old_line_content": "        return put_xiph_codecpriv(s, dyn_cp, par);",
          "new_line_content": "    case AV_CODEC_ID_VORBIS:",
          "content_same": false
        },
        {
          "line": 2769,
          "old_api": "ebml_num_size",
          "new_api": null,
          "old_text": "ebml_num_size(track->track_num)",
          "new_text": null,
          "old_line_content": "        track->track_num_size = ebml_num_size(track->track_num);",
          "new_line_content": "        nb_tracks++;",
          "content_same": false
        },
        {
          "line": 2773,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": "ff_isom_write_hvcc",
          "new_api": null,
          "old_text": "ff_isom_write_hvcc(dyn_cp, par->extradata,\n                                  par->extradata_size, 0)",
          "new_text": null,
          "old_line_content": "        return ff_isom_write_hvcc(dyn_cp, par->extradata,",
          "new_line_content": "                                  par->extradata_size);",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": "ff_isom_write_av1c",
          "new_api": null,
          "old_text": "ff_isom_write_av1c(dyn_cp, par->extradata,\n                                      par->extradata_size)",
          "new_text": null,
          "old_line_content": "            return ff_isom_write_av1c(dyn_cp, par->extradata,",
          "new_line_content": "    case AV_CODEC_ID_AV1:",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": "put_ebml_void",
          "new_api": null,
          "old_text": "put_ebml_void(pb, 4 + 3)",
          "new_text": null,
          "old_line_content": "            put_ebml_void(pb, 4 + 3);",
          "new_line_content": "                                      par->extradata_size);",
          "content_same": false
        },
        {
          "line": 2784,
          "old_api": "AV_RB16",
          "new_api": null,
          "old_text": "AV_RB16(pkt->data)",
          "new_text": null,
          "old_line_content": "        if (pkt->size > 2 && (AV_RB16(pkt->data) & 0xfff0) == 0xfff0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2785,
          "old_api": "ff_stream_add_bitstream_filter",
          "new_api": null,
          "old_text": "ff_stream_add_bitstream_filter(st, \"aac_adtstoasc\", NULL)",
          "new_text": null,
          "old_line_content": "            ret = ff_stream_add_bitstream_filter(st, \"aac_adtstoasc\", NULL);",
          "new_line_content": "    if (st->codecpar->codec_id == AV_CODEC_ID_AAC) {",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR,\n                   \"Invalid extradata found, ALAC expects a 36-byte \"\n                   \"QuickTime atom.\")",
          "new_text": null,
          "old_line_content": "            av_log(s, AV_LOG_ERROR,",
          "new_line_content": "    case AV_CODEC_ID_ALAC:",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "avio_write",
          "new_api": null,
          "old_text": "avio_write(dyn_cp, par->extradata + 12,\n                       par->extradata_size - 12)",
          "new_text": null,
          "old_line_content": "            avio_write(dyn_cp, par->extradata + 12,",
          "new_line_content": "            return AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": "avio_write",
          "new_api": null,
          "old_text": "avio_write(dyn_cp, par->extradata, par->extradata_size)",
          "new_text": null,
          "old_line_content": "            avio_write(dyn_cp, par->extradata, par->extradata_size);",
          "new_line_content": "    case AV_CODEC_ID_AAC:",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": "ff_codec_get_id",
          "new_api": null,
          "old_text": "ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag)",
          "new_text": null,
          "old_line_content": "            ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag) == AV_CODEC_ID_PRORES) {",
          "new_line_content": "    default:",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": "avio_wl32",
          "new_api": null,
          "old_text": "avio_wl32(dyn_cp, par->codec_tag)",
          "new_text": null,
          "old_line_content": "            avio_wl32(dyn_cp, par->codec_tag);",
          "new_line_content": "        if (par->codec_id == AV_CODEC_ID_PRORES &&",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": "avio_open_dyn_buf",
          "new_api": null,
          "old_text": "avio_open_dyn_buf(&dyn_cp)",
          "new_text": null,
          "old_line_content": "    ret = avio_open_dyn_buf(&dyn_cp);",
          "new_line_content": "    int ret, codecpriv_size;",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": "mkv_write_native_codecprivate",
          "new_api": null,
          "old_text": "mkv_write_native_codecprivate(s, pb, par, dyn_cp)",
          "new_text": null,
          "old_line_content": "        ret = mkv_write_native_codecprivate(s, pb, par, dyn_cp);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2826,
          "old_api": "OFFSET",
          "new_api": null,
          "old_text": "OFFSET(reserve_cues_space)",
          "new_text": null,
          "old_line_content": "    { \"reserve_index_space\", \"Reserve a given amount of space (in bytes) at the beginning of the file for the index (cues).\", OFFSET(reserve_cues_space), AV_OPT_TYPE_INT,   { .i64 = 0 },   0, INT_MAX,   FLAGS },",
          "new_line_content": "#define FLAGS AV_OPT_FLAG_ENCODING_PARAM",
          "content_same": false
        },
        {
          "line": 2827,
          "old_api": "OFFSET",
          "new_api": null,
          "old_text": "OFFSET(cluster_size_limit)",
          "new_text": null,
          "old_line_content": "    { \"cluster_size_limit\",  \"Store at most the provided amount of bytes in a cluster. \",                                     OFFSET(cluster_size_limit), AV_OPT_TYPE_INT  , { .i64 = -1 }, -1, INT_MAX,   FLAGS },",
          "new_line_content": "static const AVOption options[] = {",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "ff_codec_get_tag",
          "new_api": null,
          "old_text": "ff_codec_get_tag(ff_codec_movvideo_tags,\n                                                    par->codec_id)",
          "new_text": null,
          "old_line_content": "                par->codec_tag = ff_codec_get_tag(ff_codec_movvideo_tags,",
          "new_line_content": "        if (qt_id) {",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "AV_RL32",
          "new_api": null,
          "old_text": "AV_RL32(par->extradata + 4)",
          "new_text": null,
          "old_line_content": "                && (!par->extradata_size || ff_codec_get_id(ff_codec_movvideo_tags, AV_RL32(par->extradata + 4)) != par->codec_id)",
          "new_line_content": "                                                    par->codec_id);",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": "avio_wb32",
          "new_api": null,
          "old_text": "avio_wb32(dyn_cp, 0x5a + par->extradata_size)",
          "new_text": null,
          "old_line_content": "                avio_wb32(dyn_cp, 0x5a + par->extradata_size);",
          "new_line_content": "            ) {",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": "avio_wl32",
          "new_api": null,
          "old_text": "avio_wl32(dyn_cp, par->codec_tag)",
          "new_text": null,
          "old_line_content": "                avio_wl32(dyn_cp, par->codec_tag);",
          "new_line_content": "                int i;",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_WARNING, \"codec %s is not supported by this format\\n\",\n                       avcodec_get_name(par->codec_id))",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_WARNING, \"codec %s is not supported by this format\\n\",",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": "ff_codec_get_tag",
          "new_api": null,
          "old_text": "ff_codec_get_tag(ff_codec_bmp_tags,\n                                                  par->codec_id)",
          "new_text": null,
          "old_line_content": "                par->codec_tag = ff_codec_get_tag(ff_codec_bmp_tags,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"No bmp codec tag found for codec %s\\n\",\n                       avcodec_get_name(par->codec_id))",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_ERROR, \"No bmp codec tag found for codec %s\\n\",",
          "new_line_content": "                                                  par->codec_id);",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": "avcodec_get_name",
          "new_api": null,
          "old_text": "avcodec_get_name(par->codec_id)",
          "new_text": null,
          "old_line_content": "                       avcodec_get_name(par->codec_id));",
          "new_line_content": "            if (!par->codec_tag && par->codec_id != AV_CODEC_ID_RAWVIDEO) {",
          "content_same": false
        },
        {
          "line": 2852,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"Matroska\")",
          "new_text": null,
          "old_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"Matroska\"),",
          "new_line_content": "AVOutputFormat ff_matroska_muxer = {",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "ff_put_bmp_header",
          "new_api": null,
          "old_text": "ff_put_bmp_header(dyn_cp, par, 0, 0, mkv->flipped_raw_rgb)",
          "new_text": null,
          "old_line_content": "            ff_put_bmp_header(dyn_cp, par, 0, 0, mkv->flipped_raw_rgb);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "ff_codec_get_tag",
          "new_api": null,
          "old_text": "ff_codec_get_tag(ff_codec_wav_tags, par->codec_id)",
          "new_text": null,
          "old_line_content": "        tag = ff_codec_get_tag(ff_codec_wav_tags, par->codec_id);",
          "new_line_content": "    } else if (par->codec_type == AVMEDIA_TYPE_AUDIO) {",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": "avcodec_get_name",
          "new_api": null,
          "old_text": "avcodec_get_name(par->codec_id)",
          "new_text": null,
          "old_line_content": "                   avcodec_get_name(par->codec_id));",
          "new_line_content": "        if (!tag) {",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": "ff_put_wav_header",
          "new_api": null,
          "old_text": "ff_put_wav_header(s, dyn_cp, par, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX)",
          "new_text": null,
          "old_line_content": "        ff_put_wav_header(s, dyn_cp, par, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX);",
          "new_line_content": "            par->codec_tag = tag;",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": "avio_get_dyn_buf",
          "new_api": null,
          "old_text": "avio_get_dyn_buf(dyn_cp, &codecpriv)",
          "new_text": null,
          "old_line_content": "        codecpriv_size = avio_get_dyn_buf(dyn_cp, &codecpriv);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "ffio_free_dyn_buf",
          "new_api": null,
          "old_text": "ffio_free_dyn_buf(&dyn_cp)",
          "new_text": null,
          "old_line_content": "    ffio_free_dyn_buf(&dyn_cp);",
          "new_line_content": "                            codecpriv_size);",
          "content_same": false
        },
        {
          "line": 2888,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"WebM\")",
          "new_text": null,
          "old_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"WebM\"),",
          "new_line_content": "AVOutputFormat ff_webm_muxer = {",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": "ffio_init_context",
          "new_api": null,
          "old_text": "ffio_init_context(dyn_cp, colour, sizeof(colour), 1, NULL, NULL, NULL, NULL)",
          "new_text": null,
          "old_line_content": "    ffio_init_context(dyn_cp, colour, sizeof(colour), 1, NULL, NULL, NULL, NULL);",
          "new_line_content": "    const void *side_data;",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORTRANSFERCHARACTERISTICS,\n                      par->color_trc)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORTRANSFERCHARACTERISTICS,",
          "new_line_content": "    if (par->color_trc != AVCOL_TRC_UNSPECIFIED &&",
          "content_same": false
        },
        {
          "line": 853,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORMATRIXCOEFF, par->color_space)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORMATRIXCOEFF, par->color_space);",
          "new_line_content": "    if (par->color_space != AVCOL_SPC_UNSPECIFIED &&",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORPRIMARIES, par->color_primaries)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORPRIMARIES, par->color_primaries);",
          "new_line_content": "    if (par->color_primaries != AVCOL_PRI_UNSPECIFIED &&",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORRANGE, par->color_range)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORRANGE, par->color_range);",
          "new_line_content": "    if (par->color_range != AVCOL_RANGE_UNSPECIFIED &&",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "avcodec_enum_to_chroma_pos",
          "new_api": null,
          "old_text": "avcodec_enum_to_chroma_pos(&xpos, &ypos, par->chroma_location)",
          "new_text": null,
          "old_line_content": "        avcodec_enum_to_chroma_pos(&xpos, &ypos, par->chroma_location);",
          "new_line_content": "        int xpos, ypos;",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORCHROMASITINGHORZ, (xpos >> 7) + 1)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORCHROMASITINGHORZ, (xpos >> 7) + 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2917,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"Matroska Audio\")",
          "new_text": null,
          "old_line_content": "    .long_name         = NULL_IF_CONFIG_SMALL(\"Matroska Audio\"),",
          "new_line_content": "AVOutputFormat ff_matroska_audio_muxer = {",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "av_stream_get_side_data",
          "new_api": null,
          "old_text": "av_stream_get_side_data(st, AV_PKT_DATA_CONTENT_LIGHT_LEVEL,\n                                        NULL)",
          "new_text": null,
          "old_line_content": "    side_data = av_stream_get_side_data(st, AV_PKT_DATA_CONTENT_LIGHT_LEVEL,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORMAXCLL,  metadata->MaxCLL)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORMAXCLL,  metadata->MaxCLL);",
          "new_line_content": "    if (side_data) {",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORMAXFALL, metadata->MaxFALL)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_VIDEOCOLORMAXFALL, metadata->MaxFALL);",
          "new_line_content": "        const AVContentLightMetadata *metadata = side_data;",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": "av_stream_get_side_data",
          "new_api": null,
          "old_text": "av_stream_get_side_data(st, AV_PKT_DATA_MASTERING_DISPLAY_METADATA,\n                                        NULL)",
          "new_text": null,
          "old_line_content": "    side_data = av_stream_get_side_data(st, AV_PKT_DATA_MASTERING_DISPLAY_METADATA,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(\n            dyn_cp, MATROSKA_ID_VIDEOCOLORMASTERINGMETA, 10 * (2 + 1 + 8))",
          "new_text": null,
          "old_line_content": "        ebml_master meta_element = start_ebml_master(",
          "new_line_content": "                                        NULL);",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "put_ebml_float",
          "new_api": null,
          "old_text": "put_ebml_float(dyn_cp, MATROSKA_ID_VIDEOCOLOR_RX,\n                           av_q2d(metadata->display_primaries[0][0]))",
          "new_text": null,
          "old_line_content": "            put_ebml_float(dyn_cp, MATROSKA_ID_VIDEOCOLOR_RX,",
          "new_line_content": "        const AVMasteringDisplayMetadata *metadata = side_data;",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": "av_q2d",
          "new_api": null,
          "old_text": "av_q2d(metadata->display_primaries[0][0])",
          "new_text": null,
          "old_line_content": "                           av_q2d(metadata->display_primaries[0][0]));",
          "new_line_content": "        if (metadata->has_primaries) {",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "put_ebml_float",
          "new_api": null,
          "old_text": "put_ebml_float(dyn_cp, MATROSKA_ID_VIDEOCOLOR_LUMINANCEMAX,\n                           av_q2d(metadata->max_luminance))",
          "new_text": null,
          "old_line_content": "            put_ebml_float(dyn_cp, MATROSKA_ID_VIDEOCOLOR_LUMINANCEMAX,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": "av_q2d",
          "new_api": null,
          "old_text": "av_q2d(metadata->max_luminance)",
          "new_text": null,
          "old_line_content": "                           av_q2d(metadata->max_luminance));",
          "new_line_content": "        if (metadata->has_luminance) {",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(dyn_cp)",
          "new_text": null,
          "old_line_content": "    colorinfo_size = avio_tell(dyn_cp);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": "av_stream_get_side_data",
          "new_api": null,
          "old_text": "av_stream_get_side_data(st, AV_PKT_DATA_SPHERICAL,\n                                                            NULL)",
          "new_text": null,
          "old_line_content": "        (const AVSphericalMapping *)av_stream_get_side_data(st, AV_PKT_DATA_SPHERICAL,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_WARNING, \"Unknown projection type\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_WARNING, \"Unknown projection type\\n\");",
          "new_line_content": "        spherical->projection != AV_SPHERICAL_EQUIRECTANGULAR_TILE &&",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(pb, MATROSKA_ID_VIDEOPROJECTION,\n                                   4 * (2 + 1 + 8) + (2 + 1 + 20))",
          "new_text": null,
          "old_line_content": "    projection = start_ebml_master(pb, MATROSKA_ID_VIDEOPROJECTION,",
          "new_line_content": "    // Maximally 4 8-byte elements with id-length 2 + 1 byte length field",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOPROJECTIONTYPE,\n                      MATROSKA_VIDEO_PROJECTION_TYPE_EQUIRECTANGULAR)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(pb, MATROSKA_ID_VIDEOPROJECTIONTYPE,",
          "new_line_content": "    switch (spherical->projection) {",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOPROJECTIONTYPE,\n                      MATROSKA_VIDEO_PROJECTION_TYPE_EQUIRECTANGULAR)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(pb, MATROSKA_ID_VIDEOPROJECTIONTYPE,",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": "AV_WB32",
          "new_api": null,
          "old_text": "AV_WB32(private +  4, spherical->bound_top)",
          "new_text": null,
          "old_line_content": "        AV_WB32(private +  4, spherical->bound_top);",
          "new_line_content": "                      MATROSKA_VIDEO_PROJECTION_TYPE_EQUIRECTANGULAR);",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOPROJECTIONTYPE,\n                      MATROSKA_VIDEO_PROJECTION_TYPE_CUBEMAP)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(pb, MATROSKA_ID_VIDEOPROJECTIONTYPE,",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": "AV_WB32",
          "new_api": null,
          "old_text": "AV_WB32(private + 4, 0)",
          "new_text": null,
          "old_line_content": "        AV_WB32(private + 4, 0); // layout",
          "new_line_content": "                      MATROSKA_VIDEO_PROJECTION_TYPE_CUBEMAP);",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(0)",
          "new_text": null,
          "old_line_content": "        av_assert0(0);",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 973,
          "old_api": "put_ebml_float",
          "new_api": null,
          "old_text": "put_ebml_float(pb, MATROSKA_ID_VIDEOPROJECTIONPOSEYAW,\n                       (double) spherical->yaw   / (1 << 16))",
          "new_text": null,
          "old_line_content": "        put_ebml_float(pb, MATROSKA_ID_VIDEOPROJECTIONPOSEYAW,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": "put_ebml_float",
          "new_api": null,
          "old_text": "put_ebml_float(pb, MATROSKA_ID_VIDEOPROJECTIONPOSEPITCH,\n                       (double) spherical->pitch / (1 << 16))",
          "new_text": null,
          "old_line_content": "        put_ebml_float(pb, MATROSKA_ID_VIDEOPROJECTIONPOSEPITCH,",
          "new_line_content": "                       (double) spherical->yaw   / (1 << 16));",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": "put_ebml_float",
          "new_api": null,
          "old_text": "put_ebml_float(pb, MATROSKA_ID_VIDEOPROJECTIONPOSEROLL,\n                       (double) spherical->roll  / (1 << 16))",
          "new_text": null,
          "old_line_content": "        put_ebml_float(pb, MATROSKA_ID_VIDEOPROJECTIONPOSEROLL,",
          "new_line_content": "                       (double) spherical->pitch / (1 << 16));",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "end_ebml_master",
          "new_api": null,
          "old_text": "end_ebml_master(pb, projection)",
          "new_text": null,
          "old_line_content": "    end_ebml_master(pb, projection);",
          "new_line_content": "                       (double) spherical->roll  / (1 << 16));",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOFLAGINTERLACED,\n                      MATROSKA_VIDEO_INTERLACE_FLAG_PROGRESSIVE)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(pb, MATROSKA_ID_VIDEOFLAGINTERLACED,",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOFLAGINTERLACED,\n                      MATROSKA_VIDEO_INTERLACE_FLAG_INTERLACED)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(pb, MATROSKA_ID_VIDEOFLAGINTERLACED,",
          "new_line_content": "    case AV_FIELD_TB:",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,\n                              MATROSKA_VIDEO_FIELDORDER_TT)",
          "new_text": null,
          "old_line_content": "                put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,",
          "new_line_content": "            switch (field_order) {",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,\n                              MATROSKA_VIDEO_FIELDORDER_BB)",
          "new_text": null,
          "old_line_content": "                put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,",
          "new_line_content": "                break;",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,\n                              MATROSKA_VIDEO_FIELDORDER_TB)",
          "new_text": null,
          "old_line_content": "                put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,",
          "new_line_content": "                break;",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,\n                              MATROSKA_VIDEO_FIELDORDER_BT)",
          "new_text": null,
          "old_line_content": "                put_ebml_uint(pb, MATROSKA_ID_VIDEOFIELDORDER,",
          "new_line_content": "                break;",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(st->metadata, \"stereo_mode\", NULL, 0)",
          "new_text": null,
          "old_line_content": "    if ((tag = av_dict_get(st->metadata, \"stereo_mode\", NULL, 0)) ||",
          "new_line_content": "    *h_height = 1;",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get( s->metadata, \"stereo_mode\", NULL, 0)",
          "new_text": null,
          "old_line_content": "        (tag = av_dict_get( s->metadata, \"stereo_mode\", NULL, 0))) {",
          "new_line_content": "    // convert metadata into proper side data and add it to the stream",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(tag->value, ff_matroska_video_stereo_mode[i])",
          "new_text": null,
          "old_line_content": "            if (!strcmp(tag->value, ff_matroska_video_stereo_mode[i])){",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": "ff_mkv_stereo3d_conv",
          "new_api": null,
          "old_text": "ff_mkv_stereo3d_conv(st, stereo_mode)",
          "new_text": null,
          "old_line_content": "            int ret = ff_mkv_stereo3d_conv(st, stereo_mode);",
          "new_line_content": "        if (stereo_mode < MATROSKA_VIDEO_STEREOMODE_TYPE_NB &&",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": "av_stream_get_side_data",
          "new_api": null,
          "old_text": "av_stream_get_side_data(st, AV_PKT_DATA_STEREO3D,\n                                                        NULL)",
          "new_text": null,
          "old_line_content": "    stereo = (const AVStereo3D*)av_stream_get_side_data(st, AV_PKT_DATA_STEREO3D,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR,\n               \"The specified stereo mode is not valid.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR,",
          "new_line_content": "        format != MATROSKA_VIDEO_STEREOMODE_TYPE_RIGHT_LEFT)",
          "content_same": false
        },
        {
          "line": 1110,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEOSTEREOMODE, format)",
          "new_text": null,
          "old_line_content": "    put_ebml_uint(pb, MATROSKA_ID_VIDEOSTEREOMODE, format);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": "get_aac_sample_rates",
          "new_api": null,
          "old_text": "get_aac_sample_rates(s, mkv, par->extradata, par->extradata_size,\n                                   &sample_rate, &output_sample_rate)",
          "new_text": null,
          "old_line_content": "        ret = get_aac_sample_rates(s, mkv, par->extradata, par->extradata_size,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(pb, MATROSKA_ID_TRACKENTRY, 0)",
          "new_text": null,
          "old_line_content": "    track_master = start_ebml_master(pb, MATROSKA_ID_TRACKENTRY, 0);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKNUMBER, track->track_num)",
          "new_text": null,
          "old_line_content": "    put_ebml_uint(pb, MATROSKA_ID_TRACKNUMBER, track->track_num);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1147,
          "old_api": "put_ebml_string",
          "new_api": null,
          "old_text": "put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag->value)",
          "new_text": null,
          "old_line_content": "        put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag->value);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1155,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGDEFAULT, 0)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGDEFAULT, 0);",
          "new_line_content": "    // if we need to clear it.",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGFORCED, 1)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGFORCED, 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR,\n                   \"Only VP8 or VP9 or AV1 video and Vorbis or Opus audio and WebVTT subtitles are supported for WebM.\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(s, AV_LOG_ERROR,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": "put_ebml_string",
          "new_api": null,
          "old_text": "put_ebml_string(pb, MATROSKA_ID_CODECID, codec_id)",
          "new_text": null,
          "old_line_content": "        put_ebml_string(pb, MATROSKA_ID_CODECID, codec_id);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGCOMMENTARY, 1)",
          "new_text": null,
          "old_line_content": "            put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGCOMMENTARY, 1);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGORIGINAL,\n                          !!(st->disposition & AV_DISPOSITION_ORIGINAL))",
          "new_text": null,
          "old_line_content": "            put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGORIGINAL,",
          "new_line_content": "            (st->disposition & (AV_DISPOSITION_ORIGINAL | AV_DISPOSITION_DUB))",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": "put_ebml_string",
          "new_api": null,
          "old_text": "put_ebml_string(pb, MATROSKA_ID_CODECID, ff_mkv_codec_tags[j].str)",
          "new_text": null,
          "old_line_content": "                    put_ebml_string(pb, MATROSKA_ID_CODECID, ff_mkv_codec_tags[j].str);",
          "new_line_content": "            for (j = 0; ff_mkv_codec_tags[j].id != AV_CODEC_ID_NONE; j++) {",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Raw RGB is not supported Natively in Matroska, you can use AVI or NUT or\\n\"\n                                        \"If you would like to store it anyway using VFW mode, enable allow_raw_vfw (-allow_raw_vfw 1)\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_ERROR, \"Raw RGB is not supported Natively in Matroska, you can use AVI or NUT or\\n\"",
          "new_line_content": "                native_id = 0;",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKTYPE, MATROSKA_TRACK_TYPE_VIDEO)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(pb, MATROSKA_ID_TRACKTYPE, MATROSKA_TRACK_TYPE_VIDEO);",
          "new_line_content": "    case AVMEDIA_TYPE_VIDEO:",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": "av_inv_q",
          "new_api": null,
          "old_text": "av_inv_q(st->avg_frame_rate)",
          "new_text": null,
          "old_line_content": "           && av_cmp_q(av_inv_q(st->avg_frame_rate), st->time_base) > 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKDEFAULTDURATION, 1000000000LL * st->avg_frame_rate.den / st->avg_frame_rate.num)",
          "new_text": null,
          "old_line_content": "            put_ebml_uint(pb, MATROSKA_ID_TRACKDEFAULTDURATION, 1000000000LL * st->avg_frame_rate.den / st->avg_frame_rate.num);",
          "new_line_content": "        if(   st->avg_frame_rate.num > 0 && st->avg_frame_rate.den > 0",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKDEFAULTDURATION, 1000000000LL * st->r_frame_rate.den / st->r_frame_rate.num)",
          "new_text": null,
          "old_line_content": "            put_ebml_uint(pb, MATROSKA_ID_TRACKDEFAULTDURATION, 1000000000LL * st->r_frame_rate.den / st->r_frame_rate.num);",
          "new_line_content": "        else if(   st->r_frame_rate.num > 0 && st->r_frame_rate.den > 0",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": "ff_codec_get_tag",
          "new_api": null,
          "old_text": "ff_codec_get_tag(ff_codec_movvideo_tags, par->codec_id)",
          "new_text": null,
          "old_line_content": "            ff_codec_get_tag(ff_codec_movvideo_tags, par->codec_id) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": "ff_codec_get_tag",
          "new_api": null,
          "old_text": "ff_codec_get_tag(ff_codec_bmp_tags,   par->codec_id)",
          "new_text": null,
          "old_line_content": "            ((!ff_codec_get_tag(ff_codec_bmp_tags,   par->codec_id) && par->codec_id != AV_CODEC_ID_RAWVIDEO) ||",
          "new_line_content": "        if (!native_id &&",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": "put_ebml_string",
          "new_api": null,
          "old_text": "put_ebml_string(pb, MATROSKA_ID_CODECID, \"V_QUICKTIME\")",
          "new_text": null,
          "old_line_content": "            put_ebml_string(pb, MATROSKA_ID_CODECID, \"V_QUICKTIME\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": "put_ebml_string",
          "new_api": null,
          "old_text": "put_ebml_string(pb, MATROSKA_ID_CODECID, \"V_MS/VFW/FOURCC\")",
          "new_text": null,
          "old_line_content": "            put_ebml_string(pb, MATROSKA_ID_CODECID, \"V_MS/VFW/FOURCC\");",
          "new_line_content": "        else if (!native_id) {",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(pb, MATROSKA_ID_TRACKVIDEO, 0)",
          "new_text": null,
          "old_line_content": "        subinfo = start_ebml_master(pb, MATROSKA_ID_TRACKVIDEO, 0);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1259,
          "old_api": "put_ebml_uint (pb, MATROSKA_ID_VIDEOPIXELHEIGHT, par->height)",
          "new_api": null,
          "old_text": "put_ebml_uint (pb, MATROSKA_ID_VIDEOPIXELHEIGHT, par->height)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint (pb, MATROSKA_ID_VIDEOPIXELHEIGHT, par->height);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": "mkv_write_stereo_mode",
          "new_api": null,
          "old_text": "mkv_write_stereo_mode(s, pb, st, mkv->mode,\n                                    &display_width_div,\n                                    &display_height_div)",
          "new_text": null,
          "old_line_content": "        ret = mkv_write_stereo_mode(s, pb, st, mkv->mode,",
          "new_line_content": "        // check both side data and metadata for stereo information,",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": "atoi",
          "new_api": null,
          "old_text": "atoi(tag->value)",
          "new_text": null,
          "old_line_content": "        if (((tag = av_dict_get(st->metadata, \"alpha_mode\", NULL, 0)) && atoi(tag->value)) ||",
          "new_line_content": "            return ret;",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": "atoi",
          "new_api": null,
          "old_text": "atoi(tag->value)",
          "new_text": null,
          "old_line_content": "            ((tag = av_dict_get( s->metadata, \"alpha_mode\", NULL, 0)) && atoi(tag->value)) ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1280,
          "old_api": "av_rescale",
          "new_api": null,
          "old_text": "av_rescale(par->width, st->sample_aspect_ratio.num, st->sample_aspect_ratio.den)",
          "new_text": null,
          "old_line_content": "            int64_t d_width = av_rescale(par->width, st->sample_aspect_ratio.num, st->sample_aspect_ratio.den);",
          "new_line_content": "        // a single source view and/or the display aspect ratio",
          "content_same": false
        },
        {
          "line": 1283,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "                return AVERROR(EINVAL);",
          "new_line_content": "            if (d_width > INT_MAX) {",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYWIDTH , d_width / display_width_div)",
          "new_text": null,
          "old_line_content": "                    put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYWIDTH , d_width / display_width_div);",
          "new_line_content": "            if (d_width != par->width || display_width_div != 1 || display_height_div != 1) {",
          "content_same": false
        },
        {
          "line": 1288,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYHEIGHT, par->height / display_height_div)",
          "new_text": null,
          "old_line_content": "                    put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYHEIGHT, par->height / display_height_div);",
          "new_line_content": "                if (mkv->mode == MODE_WEBM || display_width_div != 1 || display_height_div != 1) {",
          "content_same": false
        },
        {
          "line": 1291,
          "old_api": "av_reduce",
          "new_api": null,
          "old_text": "av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n                              par->width  * (int64_t)st->sample_aspect_ratio.num,\n                              par->height * (int64_t)st->sample_aspect_ratio.den,\n                              1024 * 1024)",
          "new_text": null,
          "old_line_content": "                    av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYWIDTH,  display_aspect_ratio.num)",
          "new_text": null,
          "old_line_content": "                    put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYWIDTH,  display_aspect_ratio.num);",
          "new_line_content": "                              par->height * (int64_t)st->sample_aspect_ratio.den,",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYHEIGHT, display_aspect_ratio.den)",
          "new_text": null,
          "old_line_content": "                    put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYHEIGHT, display_aspect_ratio.den);",
          "new_line_content": "                              1024 * 1024);",
          "content_same": false
        },
        {
          "line": 1301,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYWIDTH , par->width / display_width_div)",
          "new_text": null,
          "old_line_content": "            put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYWIDTH , par->width / display_width_div);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYHEIGHT, par->height / display_height_div)",
          "new_text": null,
          "old_line_content": "            put_ebml_uint(pb, MATROSKA_ID_VIDEODISPLAYHEIGHT, par->height / display_height_div);",
          "new_line_content": "        } else if (display_width_div != 1 || display_height_div != 1) {",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": "av_le2ne32",
          "new_api": null,
          "old_text": "av_le2ne32(par->codec_tag)",
          "new_text": null,
          "old_line_content": "            uint32_t color_space = av_le2ne32(par->codec_tag);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": "put_ebml_binary",
          "new_api": null,
          "old_text": "put_ebml_binary(pb, MATROSKA_ID_VIDEOCOLORSPACE, &color_space, sizeof(color_space))",
          "new_text": null,
          "old_line_content": "            put_ebml_binary(pb, MATROSKA_ID_VIDEOCOLORSPACE, &color_space, sizeof(color_space));",
          "new_line_content": "        if (par->codec_id == AV_CODEC_ID_RAWVIDEO) {",
          "content_same": false
        },
        {
          "line": 1311,
          "old_api": "mkv_write_video_projection",
          "new_api": null,
          "old_text": "mkv_write_video_projection(s, pb, st)",
          "new_text": null,
          "old_line_content": "        mkv_write_video_projection(s, pb, st);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1318,
          "old_api": "av_rescale_q",
          "new_api": null,
          "old_text": "av_rescale_q(par->initial_padding,\n                                              (AVRational){ 1, 48000 },\n                                              (AVRational){ 1, 1000000000 })",
          "new_text": null,
          "old_line_content": "            int64_t codecdelay = av_rescale_q(par->initial_padding,",
          "new_line_content": "    case AVMEDIA_TYPE_AUDIO:",
          "content_same": false
        },
        {
          "line": 1322,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Initial padding is invalid\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(s, AV_LOG_ERROR, \"Initial padding is invalid\\n\");",
          "new_line_content": "                                              (AVRational){ 1, 1000000000 });",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "                return AVERROR(EINVAL);",
          "new_line_content": "            if (codecdelay < 0) {",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_CODECDELAY, codecdelay)",
          "new_text": null,
          "old_line_content": "            put_ebml_uint(pb, MATROSKA_ID_CODECDELAY, codecdelay);",
          "new_line_content": "//                                            st->time_base);",
          "content_same": false
        },
        {
          "line": 1332,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_SEEKPREROLL, OPUS_SEEK_PREROLL)",
          "new_text": null,
          "old_line_content": "            put_ebml_uint(pb, MATROSKA_ID_SEEKPREROLL, OPUS_SEEK_PREROLL);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": "put_ebml_string",
          "new_api": null,
          "old_text": "put_ebml_string(pb, MATROSKA_ID_CODECID, \"A_MS/ACM\")",
          "new_text": null,
          "old_line_content": "            put_ebml_string(pb, MATROSKA_ID_CODECID, \"A_MS/ACM\");",
          "new_line_content": "        if (!native_id)",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": "put_ebml_uint  (pb, MATROSKA_ID_AUDIOCHANNELS    , par->channels)",
          "new_api": null,
          "old_text": "put_ebml_uint  (pb, MATROSKA_ID_AUDIOCHANNELS    , par->channels)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint  (pb, MATROSKA_ID_AUDIOCHANNELS    , par->channels);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": "put_ebml_float (pb, MATROSKA_ID_AUDIOSAMPLINGFREQ, sample_rate)",
          "new_api": null,
          "old_text": "put_ebml_float (pb, MATROSKA_ID_AUDIOSAMPLINGFREQ, sample_rate)",
          "new_text": null,
          "old_line_content": "        put_ebml_float (pb, MATROSKA_ID_AUDIOSAMPLINGFREQ, sample_rate);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": "av_get_bytes_per_sample",
          "new_api": null,
          "old_text": "av_get_bytes_per_sample(par->format)",
          "new_text": null,
          "old_line_content": "                bit_depth = av_get_bytes_per_sample(par->format) << 3;",
          "new_line_content": "                bit_depth = par->bits_per_raw_sample;",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_AUDIOBITDEPTH, bit_depth)",
          "new_text": null,
          "old_line_content": "            put_ebml_uint(pb, MATROSKA_ID_AUDIOBITDEPTH, bit_depth);",
          "new_line_content": "            bit_depth = par->bits_per_coded_sample;",
          "content_same": false
        },
        {
          "line": 1359,
          "old_api": "end_ebml_master",
          "new_api": null,
          "old_text": "end_ebml_master(pb, subinfo)",
          "new_text": null,
          "old_line_content": "        end_ebml_master(pb, subinfo);",
          "new_line_content": "        if (bit_depth)",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Subtitle codec %d is not supported.\\n\", par->codec_id)",
          "new_text": null,
          "old_line_content": "            av_log(s, AV_LOG_ERROR, \"Subtitle codec %d is not supported.\\n\", par->codec_id);",
          "new_line_content": "    case AVMEDIA_TYPE_SUBTITLE:",
          "content_same": false
        },
        {
          "line": 1365,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOSYS)",
          "new_text": null,
          "old_line_content": "            return AVERROR(ENOSYS);",
          "new_line_content": "        if (!native_id) {",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGTEXTDESCRIPTIONS, 1)",
          "new_text": null,
          "old_line_content": "            put_ebml_uint(pb, MATROSKA_ID_TRACKFLAGTEXTDESCRIPTIONS, 1);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1373,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_TRACKTYPE, native_id)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(pb, MATROSKA_ID_TRACKTYPE, native_id);",
          "new_line_content": "            native_id = MATROSKA_TRACK_TYPE_SUBTITLE;",
          "content_same": false
        },
        {
          "line": 1376,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR, \"Only audio, video, and subtitles are supported for Matroska.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_ERROR, \"Only audio, video, and subtitles are supported for Matroska.\\n\");",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 1377,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "    default:",
          "content_same": false
        },
        {
          "line": 1381,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "        track->codecpriv_offset = avio_tell(pb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1382,
          "old_api": "mkv_write_codecprivate",
          "new_api": null,
          "old_text": "mkv_write_codecprivate(s, pb, par, native_id, qt_id)",
          "new_text": null,
          "old_line_content": "        ret = mkv_write_codecprivate(s, pb, par, native_id, qt_id);",
          "new_line_content": "    if (mkv->mode != MODE_WEBM || par->codec_id != AV_CODEC_ID_WEBVTT) {",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": "end_ebml_master",
          "new_api": null,
          "old_text": "end_ebml_master(pb, track_master)",
          "new_text": null,
          "old_line_content": "    end_ebml_master(pb, track_master);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1401,
          "old_api": "start_ebml_master_crc32",
          "new_api": null,
          "old_text": "start_ebml_master_crc32(&mkv->track.bc, mkv)",
          "new_text": null,
          "old_line_content": "    ret = start_ebml_master_crc32(&mkv->track.bc, mkv);",
          "new_line_content": "        return 0;",
          "content_same": false
        },
        {
          "line": 1422,
          "old_api": "CASE",
          "new_api": null,
          "old_text": "CASE(VIDEO,    video)",
          "new_text": null,
          "old_line_content": "            CASE(VIDEO,    video)",
          "new_line_content": "                    variable ## _default_idx = i;             \\",
          "content_same": false
        },
        {
          "line": 1423,
          "old_api": "CASE",
          "new_api": null,
          "old_text": "CASE(AUDIO,    audio)",
          "new_text": null,
          "old_line_content": "            CASE(AUDIO,    audio)",
          "new_line_content": "                break;",
          "content_same": false
        },
        {
          "line": 1429,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(video_default_idx, video_idx)",
          "new_text": null,
          "old_line_content": "        video_default_idx = FFMAX(video_default_idx, video_idx);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1430,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(audio_default_idx, audio_idx)",
          "new_text": null,
          "old_line_content": "        audio_default_idx = FFMAX(audio_default_idx, audio_idx);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1440,
          "old_api": "mkv_write_track",
          "new_api": null,
          "old_text": "mkv_write_track(s, mkv, st, &mkv->tracks[i],\n                              mkv->track.bc, is_default)",
          "new_text": null,
          "old_line_content": "        ret = mkv_write_track(s, mkv, st, &mkv->tracks[i],",
          "new_line_content": "                             i == video_default_idx || i == audio_default_idx ||",
          "content_same": false
        },
        {
          "line": 1446,
          "old_api": "end_ebml_master_crc32_tentatively",
          "new_api": null,
          "old_text": "end_ebml_master_crc32_tentatively(pb, &mkv->track, mkv,\n                                             MATROSKA_ID_TRACKS)",
          "new_text": null,
          "old_line_content": "    return end_ebml_master_crc32_tentatively(pb, &mkv->track, mkv,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": "av_strdup",
          "new_api": null,
          "old_text": "av_strdup(t->key)",
          "new_text": null,
          "old_line_content": "    uint8_t *key = av_strdup(t->key);",
          "new_line_content": "static int mkv_write_simpletag(AVIOContext *pb, const AVDictionaryEntry *t)",
          "content_same": false
        },
        {
          "line": 1458,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": "ff_convert_lang_to",
          "new_api": null,
          "old_text": "ff_convert_lang_to(p + 1, AV_LANG_ISO639_2_BIBL)",
          "new_text": null,
          "old_line_content": "        (lang = ff_convert_lang_to(p + 1, AV_LANG_ISO639_2_BIBL)))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1473,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(pb, MATROSKA_ID_SIMPLETAG, 0)",
          "new_text": null,
          "old_line_content": "    tag = start_ebml_master(pb, MATROSKA_ID_SIMPLETAG, 0);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1474,
          "old_api": "put_ebml_string",
          "new_api": null,
          "old_text": "put_ebml_string(pb, MATROSKA_ID_TAGNAME, key)",
          "new_text": null,
          "old_line_content": "    put_ebml_string(pb, MATROSKA_ID_TAGNAME, key);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1477,
          "old_api": "put_ebml_string",
          "new_api": null,
          "old_text": "put_ebml_string(pb, MATROSKA_ID_TAGSTRING, t->value)",
          "new_text": null,
          "old_line_content": "    put_ebml_string(pb, MATROSKA_ID_TAGSTRING, t->value);",
          "new_line_content": "    if (lang)",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": "start_ebml_master_crc32",
          "new_api": null,
          "old_text": "start_ebml_master_crc32(pb, mkv)",
          "new_text": null,
          "old_line_content": "        ret = start_ebml_master_crc32(pb, mkv);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(*pb, MATROSKA_ID_TAG,        0)",
          "new_text": null,
          "old_line_content": "    *tag    = start_ebml_master(*pb, MATROSKA_ID_TAG,        0);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(*pb, MATROSKA_ID_TAGTARGETS, 4 + 1 + 8)",
          "new_text": null,
          "old_line_content": "    targets = start_ebml_master(*pb, MATROSKA_ID_TAGTARGETS, 4 + 1 + 8);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": "end_ebml_master",
          "new_api": null,
          "old_text": "end_ebml_master(*pb, targets)",
          "new_text": null,
          "old_line_content": "    end_ebml_master(*pb, targets);",
          "new_line_content": "    if (elementid)",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": "av_strcasecmp",
          "new_api": null,
          "old_text": "av_strcasecmp(name, \"title\")",
          "new_text": null,
          "old_line_content": "    return av_strcasecmp(name, \"title\") &&",
          "new_line_content": "static int mkv_check_tag_name(const char *name, uint32_t elementid)",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": "av_strcasecmp",
          "new_api": null,
          "old_text": "av_strcasecmp(name, \"stereo_mode\")",
          "new_text": null,
          "old_line_content": "           av_strcasecmp(name, \"stereo_mode\") &&",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": "av_strcasecmp",
          "new_api": null,
          "old_text": "av_strcasecmp(name, \"mimetype\")",
          "new_text": null,
          "old_line_content": "             av_strcasecmp(name, \"mimetype\")));",
          "new_line_content": "           (elementid != MATROSKA_ID_TAGTARGETS_ATTACHUID ||",
          "content_same": false
        },
        {
          "line": 1526,
          "old_api": "mkv_write_tag_targets",
          "new_api": null,
          "old_text": "mkv_write_tag_targets(mkv, pb, tag ? tag : &tag2, elementid, uid)",
          "new_text": null,
          "old_line_content": "    ret = mkv_write_tag_targets(mkv, pb, tag ? tag : &tag2, elementid, uid);",
          "new_line_content": "    int ret;",
          "content_same": false
        },
        {
          "line": 1530,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(m, \"\", t, AV_DICT_IGNORE_SUFFIX)",
          "new_text": null,
          "old_line_content": "    while ((t = av_dict_get(m, \"\", t, AV_DICT_IGNORE_SUFFIX))) {",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": "mkv_check_tag_name",
          "new_api": null,
          "old_text": "mkv_check_tag_name(t->key, elementid)",
          "new_text": null,
          "old_line_content": "        if (mkv_check_tag_name(t->key, elementid)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1539,
          "old_api": "end_ebml_master",
          "new_api": null,
          "old_text": "end_ebml_master(*pb, tag2)",
          "new_text": null,
          "old_line_content": "        end_ebml_master(*pb, tag2);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(m, \"\", t, AV_DICT_IGNORE_SUFFIX)",
          "new_text": null,
          "old_line_content": "    while ((t = av_dict_get(m, \"\", t, AV_DICT_IGNORE_SUFFIX)))",
          "new_line_content": "    const AVDictionaryEntry *t = NULL;",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": "mkv_check_tag_name",
          "new_api": null,
          "old_text": "mkv_check_tag_name(t->key, elementid)",
          "new_text": null,
          "old_line_content": "        if (mkv_check_tag_name(t->key, elementid))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1558,
          "old_api": "IS_SEEKABLE",
          "new_api": null,
          "old_text": "IS_SEEKABLE(s->pb, mkv)",
          "new_text": null,
          "old_line_content": "    ebml_master tag, *tagp = IS_SEEKABLE(s->pb, mkv) ? &tag : NULL;",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1563,
          "old_api": "ff_metadata_conv_ctx",
          "new_api": null,
          "old_text": "ff_metadata_conv_ctx(s, ff_mkv_metadata_conv, NULL)",
          "new_text": null,
          "old_line_content": "    ff_metadata_conv_ctx(s, ff_mkv_metadata_conv, NULL);",
          "new_line_content": "    mkv->wrote_tags = 1;",
          "content_same": false
        },
        {
          "line": 1566,
          "old_api": "mkv_write_tag",
          "new_api": null,
          "old_text": "mkv_write_tag(mkv, s->metadata, &mkv->tags.bc, NULL, 0, 0)",
          "new_text": null,
          "old_line_content": "        ret = mkv_write_tag(mkv, s->metadata, &mkv->tags.bc, NULL, 0, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": "mkv_check_tag",
          "new_api": null,
          "old_text": "mkv_check_tag(st->metadata, MATROSKA_ID_TAGTARGETS_TRACKUID)",
          "new_text": null,
          "old_line_content": "        if (!tagp && !mkv_check_tag(st->metadata, MATROSKA_ID_TAGTARGETS_TRACKUID))",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 1581,
          "old_api": "mkv_write_tag",
          "new_api": null,
          "old_text": "mkv_write_tag(mkv, st->metadata, &mkv->tags.bc, tagp,\n                            MATROSKA_ID_TAGTARGETS_TRACKUID, track->uid)",
          "new_text": null,
          "old_line_content": "        ret = mkv_write_tag(mkv, st->metadata, &mkv->tags.bc, tagp,",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 1590,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(pb, MATROSKA_ID_SIMPLETAG,\n                                          2 + 1 + 8 + 23)",
          "new_text": null,
          "old_line_content": "            simpletag = start_ebml_master(pb, MATROSKA_ID_SIMPLETAG,",
          "new_line_content": "            ebml_master simpletag;",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "            track->duration_offset = avio_tell(pb);",
          "new_line_content": "                                          2 + 1 + 8 + 23);",
          "content_same": false
        },
        {
          "line": 1597,
          "old_api": "put_ebml_void",
          "new_api": null,
          "old_text": "put_ebml_void(pb, 23)",
          "new_text": null,
          "old_line_content": "            put_ebml_void(pb, 23);",
          "new_line_content": "            // Reserve space to write duration as a 20-byte string.",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": "end_ebml_master",
          "new_api": null,
          "old_text": "end_ebml_master(pb, simpletag)",
          "new_text": null,
          "old_line_content": "            end_ebml_master(pb, simpletag);",
          "new_line_content": "            // 2 (ebml id) + 1 (data size) + 20 (data)",
          "content_same": false
        },
        {
          "line": 1611,
          "old_api": "mkv_check_tag",
          "new_api": null,
          "old_text": "mkv_check_tag(st->metadata, MATROSKA_ID_TAGTARGETS_ATTACHUID)",
          "new_text": null,
          "old_line_content": "            if (!mkv_check_tag(st->metadata, MATROSKA_ID_TAGTARGETS_ATTACHUID))",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 1614,
          "old_api": "mkv_write_tag",
          "new_api": null,
          "old_text": "mkv_write_tag(mkv, st->metadata, &mkv->tags.bc, NULL,\n                                MATROSKA_ID_TAGTARGETS_ATTACHUID, track->uid)",
          "new_text": null,
          "old_line_content": "            ret = mkv_write_tag(mkv, st->metadata, &mkv->tags.bc, NULL,",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 1622,
          "old_api": "end_ebml_master_crc32_tentatively",
          "new_api": null,
          "old_text": "end_ebml_master_crc32_tentatively(s->pb, &mkv->tags, mkv,\n                                                 MATROSKA_ID_TAGS)",
          "new_text": null,
          "old_line_content": "        return end_ebml_master_crc32_tentatively(s->pb, &mkv->tags, mkv,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": "start_ebml_master_crc32",
          "new_api": null,
          "old_text": "start_ebml_master_crc32(&dyn_cp, mkv)",
          "new_text": null,
          "old_line_content": "    ret = start_ebml_master_crc32(&dyn_cp, mkv);",
          "new_line_content": "        return 0;",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(dyn_cp, MATROSKA_ID_EDITIONENTRY, 0)",
          "new_text": null,
          "old_line_content": "    editionentry = start_ebml_master(dyn_cp, MATROSKA_ID_EDITIONENTRY, 0);",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 1664,
          "old_api": "mkv_new_chapter_ids_needed",
          "new_api": null,
          "old_text": "mkv_new_chapter_ids_needed(s)",
          "new_text": null,
          "old_line_content": "    create_new_ids = mkv_new_chapter_ids_needed(s);",
          "new_line_content": "        tags = NULL;",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": "av_rescale_q",
          "new_api": null,
          "old_text": "av_rescale_q(c->start, c->time_base, scale)",
          "new_text": null,
          "old_line_content": "        int64_t chapterstart = av_rescale_q(c->start, c->time_base, scale);",
          "new_line_content": "        ebml_master chapteratom, chapterdisplay;",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": "av_rescale_q",
          "new_api": null,
          "old_text": "av_rescale_q(c->end,   c->time_base, scale)",
          "new_text": null,
          "old_line_content": "        int64_t chapterend   = av_rescale_q(c->end,   c->time_base, scale);",
          "new_line_content": "        const AVChapter *c   = s->chapters[i];",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_ERROR,\n                   \"Invalid chapter start (%\"PRId64\") or end (%\"PRId64\").\\n\",\n                   chapterstart, chapterend)",
          "new_text": null,
          "old_line_content": "            av_log(s, AV_LOG_ERROR,",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(dyn_cp, MATROSKA_ID_CHAPTERATOM, 0)",
          "new_text": null,
          "old_line_content": "        chapteratom = start_ebml_master(dyn_cp, MATROSKA_ID_CHAPTERATOM, 0);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1686,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(dyn_cp, MATROSKA_ID_CHAPTERUID, uid)",
          "new_text": null,
          "old_line_content": "        put_ebml_uint(dyn_cp, MATROSKA_ID_CHAPTERUID, uid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": "mkv_write_tag",
          "new_api": null,
          "old_text": "mkv_write_tag(mkv, c->metadata, tags, NULL,\n                                MATROSKA_ID_TAGTARGETS_CHAPTERUID, uid)",
          "new_text": null,
          "old_line_content": "            ret = mkv_write_tag(mkv, c->metadata, tags, NULL,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": "end_ebml_master",
          "new_api": null,
          "old_text": "end_ebml_master(dyn_cp, editionentry)",
          "new_text": null,
          "old_line_content": "    end_ebml_master(dyn_cp, editionentry);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": "end_ebml_master_crc32",
          "new_api": null,
          "old_text": "end_ebml_master_crc32(pb, &dyn_cp, mkv, MATROSKA_ID_CHAPTERS, 0, 0, 1)",
          "new_text": null,
          "old_line_content": "    ret = end_ebml_master_crc32(pb, &dyn_cp, mkv, MATROSKA_ID_CHAPTERS, 0, 0, 1);",
          "new_line_content": "    mkv->wrote_chapters = 1;",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": "end_ebml_master_crc32",
          "new_api": null,
          "old_text": "end_ebml_master_crc32(pb, &dyn_tags, mkv,\n                                     MATROSKA_ID_TAGS, 0, 0, 1)",
          "new_text": null,
          "old_line_content": "        return end_ebml_master_crc32(pb, &dyn_tags, mkv,",
          "new_line_content": "        goto fail;",
          "content_same": false
        },
        {
          "line": 1719,
          "old_api": "ffio_free_dyn_buf",
          "new_api": null,
          "old_text": "ffio_free_dyn_buf(tags)",
          "new_text": null,
          "old_line_content": "        ffio_free_dyn_buf(tags);",
          "new_line_content": "        /* tags == &mkv->tags.bc can only happen if mkv->tags.bc was",
          "content_same": false
        },
        {
          "line": 1729,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(st->metadata, \"mimetype\", NULL, 0)",
          "new_text": null,
          "old_line_content": "    if (t = av_dict_get(st->metadata, \"mimetype\", NULL, 0))",
          "new_line_content": "    const AVDictionaryEntry *t;",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": "avcodec_descriptor_get",
          "new_api": null,
          "old_text": "avcodec_descriptor_get(st->codecpar->codec_id)",
          "new_text": null,
          "old_line_content": "        const AVCodecDescriptor *desc = avcodec_descriptor_get(st->codecpar->codec_id);",
          "new_line_content": "        return t->value;",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": "start_ebml_master_crc32",
          "new_api": null,
          "old_text": "start_ebml_master_crc32(&dyn_cp, mkv)",
          "new_text": null,
          "old_line_content": "    ret = start_ebml_master_crc32(&dyn_cp, mkv);",
          "new_line_content": "        return 0;",
          "content_same": false
        },
        {
          "line": 1765,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(dyn_cp, MATROSKA_ID_ATTACHEDFILE, 0)",
          "new_text": null,
          "old_line_content": "        attached_file = start_ebml_master(dyn_cp, MATROSKA_ID_ATTACHEDFILE, 0);",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 1768,
          "old_api": "put_ebml_string",
          "new_api": null,
          "old_text": "put_ebml_string(dyn_cp, MATROSKA_ID_FILEDESC, t->value)",
          "new_text": null,
          "old_line_content": "            put_ebml_string(dyn_cp, MATROSKA_ID_FILEDESC, t->value);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(mimetype)",
          "new_text": null,
          "old_line_content": "        av_assert0(mimetype);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1789,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(s->metadata, \"DURATION\",\n                                                    NULL, 0)",
          "new_text": null,
          "old_line_content": "    const AVDictionaryEntry *duration = av_dict_get(s->metadata, \"DURATION\",",
          "new_line_content": "static int64_t get_metadata_duration(AVFormatContext *s)",
          "content_same": false
        },
        {
          "line": 1794,
          "old_api": "av_parse_time",
          "new_api": null,
          "old_text": "av_parse_time(&us, duration->value, 1)",
          "new_text": null,
          "old_line_content": "    if (duration && (av_parse_time(&us, duration->value, 1) == 0) && us > 0) {",
          "new_line_content": "    int64_t us;",
          "content_same": false
        },
        {
          "line": 1795,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_DEBUG, \"get_metadata_duration found duration in context metadata: %\" PRId64 \"\\n\", us)",
          "new_text": null,
          "old_line_content": "        av_log(s, AV_LOG_DEBUG, \"get_metadata_duration found duration in context metadata: %\" PRId64 \"\\n\", us);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1801,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(s->streams[i]->metadata, \"DURATION\", NULL, 0)",
          "new_text": null,
          "old_line_content": "        duration = av_dict_get(s->streams[i]->metadata, \"DURATION\", NULL, 0);",
          "new_line_content": "    for (unsigned i = 0; i < s->nb_streams; i++) {",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(max, us)",
          "new_text": null,
          "old_line_content": "            max = FFMAX(max, us);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1807,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_DEBUG, \"get_metadata_duration returned: %\" PRId64 \"\\n\", max)",
          "new_text": null,
          "old_line_content": "    av_log(s, AV_LOG_DEBUG, \"get_metadata_duration returned: %\" PRId64 \"\\n\", max);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(s->metadata, \"stereo_mode\", NULL, 0)",
          "new_text": null,
          "old_line_content": "        av_dict_get(s->metadata, \"stereo_mode\", NULL, 0) ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1822,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(s->metadata, \"alpha_mode\", NULL, 0)",
          "new_text": null,
          "old_line_content": "        av_dict_get(s->metadata, \"alpha_mode\", NULL, 0))",
          "new_line_content": "    if (mkv->mode != MODE_WEBM ||",
          "content_same": false
        },
        {
          "line": 1827,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0)",
          "new_text": null,
          "old_line_content": "            av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0) ||",
          "new_line_content": "    for (i = 0; i < s->nb_streams; i++) {",
          "content_same": false
        },
        {
          "line": 1828,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0)",
          "new_text": null,
          "old_line_content": "            av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0))",
          "new_line_content": "        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": "start_ebml_master",
          "new_api": null,
          "old_text": "start_ebml_master(pb, EBML_ID_HEADER, MAX_EBML_HEADER_SIZE)",
          "new_text": null,
          "old_line_content": "    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, MAX_EBML_HEADER_SIZE);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": "put_ebml_uint  (pb, EBML_ID_EBMLVERSION       ,           1)",
          "new_api": null,
          "old_text": "put_ebml_uint  (pb, EBML_ID_EBMLVERSION       ,           1)",
          "new_text": null,
          "old_line_content": "    put_ebml_uint  (pb, EBML_ID_EBMLVERSION       ,           1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1843,
          "old_api": "put_ebml_size_unknown",
          "new_api": null,
          "old_text": "put_ebml_size_unknown(pb, 8)",
          "new_text": null,
          "old_line_content": "    put_ebml_size_unknown(pb, 8);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": "mkv_start_seekhead",
          "new_api": null,
          "old_text": "mkv_start_seekhead(mkv, pb)",
          "new_text": null,
          "old_line_content": "    mkv_start_seekhead(mkv, pb);",
          "new_line_content": "    // We write a SeekHead at the beginning to point to all other level",
          "content_same": false
        },
        {
          "line": 1855,
          "old_api": "put_ebml_uint",
          "new_api": null,
          "old_text": "put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000)",
          "new_text": null,
          "old_line_content": "    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);",
          "new_line_content": "    pb = mkv->info.bc;",
          "content_same": false
        },
        {
          "line": 1856,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(s->metadata, \"title\", NULL, 0)",
          "new_text": null,
          "old_line_content": "    if ((tag = av_dict_get(s->metadata, \"title\", NULL, 0)))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1860,
          "old_api": "av_dict_get",
          "new_api": null,
          "old_text": "av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)",
          "new_text": null,
          "old_line_content": "        if ((tag = av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)))",
          "new_line_content": "    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {",
          "content_same": false
        },
        {
          "line": 1866,
          "old_api": "put_ebml_binary",
          "new_api": null,
          "old_text": "put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, mkv->segment_uid, 16)",
          "new_text": null,
          "old_line_content": "            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, mkv->segment_uid, 16);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1869,
          "old_api": "put_ebml_string",
          "new_api": null,
          "old_text": "put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident)",
          "new_text": null,
          "old_line_content": "        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1870,
          "old_api": "put_ebml_string",
          "new_api": null,
          "old_text": "put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident)",
          "new_text": null,
          "old_line_content": "        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);",
          "new_line_content": "        const char *ident = \"Lavf\";",
          "content_same": false
        },
        {
          "line": 1873,
          "old_api": "ff_parse_creation_time_metadata",
          "new_api": null,
          "old_text": "ff_parse_creation_time_metadata(s, &creation_time, 0)",
          "new_text": null,
          "old_line_content": "    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": "AV_WB64",
          "new_api": null,
          "old_text": "AV_WB64(date_utc_buf, date_utc)",
          "new_text": null,
          "old_line_content": "        AV_WB64(date_utc_buf, date_utc);",
          "new_line_content": "        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": "put_ebml_binary",
          "new_api": null,
          "old_text": "put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8)",
          "new_text": null,
          "old_line_content": "        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);",
          "new_line_content": "        uint8_t date_utc_buf[8];",
          "content_same": false
        },
        {
          "line": 1883,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "    mkv->duration_offset = avio_tell(pb);",
          "new_line_content": "    // reserve space for the duration",
          "content_same": false
        },
        {
          "line": 1888,
          "old_api": "av_rescale",
          "new_api": null,
          "old_text": "av_rescale(s->duration, 1000, AV_TIME_BASE)",
          "new_text": null,
          "old_line_content": "            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1889,
          "old_api": "put_ebml_float",
          "new_api": null,
          "old_text": "put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration)",
          "new_text": null,
          "old_line_content": "            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);",
          "new_line_content": "        if (s->duration > 0) {",
          "content_same": false
        },
        {
          "line": 1893,
          "old_api": "put_ebml_float",
          "new_api": null,
          "old_text": "put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration)",
          "new_text": null,
          "old_line_content": "            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);",
          "new_line_content": "        } else if (metadata_duration > 0) {",
          "content_same": false
        },
        {
          "line": 1899,
          "old_api": "end_ebml_master_crc32_tentatively",
          "new_api": null,
          "old_text": "end_ebml_master_crc32_tentatively(s->pb, &mkv->info,\n                                            mkv, MATROSKA_ID_INFO)",
          "new_text": null,
          "old_line_content": "    ret = end_ebml_master_crc32_tentatively(s->pb, &mkv->info,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1905,
          "old_api": "mkv_write_tracks",
          "new_api": null,
          "old_text": "mkv_write_tracks(s)",
          "new_text": null,
          "old_line_content": "    ret = mkv_write_tracks(s);",
          "new_line_content": "    pb = s->pb;",
          "content_same": false
        },
        {
          "line": 1909,
          "old_api": "mkv_write_chapters",
          "new_api": null,
          "old_text": "mkv_write_chapters(s)",
          "new_text": null,
          "old_line_content": "    ret = mkv_write_chapters(s);",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 1914,
          "old_api": "mkv_write_attachments",
          "new_api": null,
          "old_text": "mkv_write_attachments(s)",
          "new_text": null,
          "old_line_content": "        ret = mkv_write_attachments(s);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1921,
          "old_api": "mkv_write_tags",
          "new_api": null,
          "old_text": "mkv_write_tags(s)",
          "new_text": null,
          "old_line_content": "    ret = mkv_write_tags(s);",
          "new_line_content": "    /* Must come after mkv_write_chapters() to write chapter tags",
          "content_same": false
        },
        {
          "line": 1925,
          "old_api": "IS_SEEKABLE",
          "new_api": null,
          "old_text": "IS_SEEKABLE(pb, mkv)",
          "new_text": null,
          "old_line_content": "    if (!IS_SEEKABLE(pb, mkv)) {",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 1926,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "        ret = mkv_write_seekhead(pb, mkv, 0, avio_tell(pb));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1934,
          "old_api": "put_ebml_void",
          "new_api": null,
          "old_text": "put_ebml_void(pb, s->metadata_header_padding)",
          "new_text": null,
          "old_line_content": "        put_ebml_void(pb, s->metadata_header_padding);",
          "new_line_content": "        if (s->metadata_header_padding == 1)",
          "content_same": false
        },
        {
          "line": 1938,
          "old_api": "IS_SEEKABLE",
          "new_api": null,
          "old_text": "IS_SEEKABLE(pb, mkv)",
          "new_text": null,
          "old_line_content": "        if (IS_SEEKABLE(pb, mkv)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1939,
          "old_api": "avio_tell",
          "new_api": null,
          "old_text": "avio_tell(pb)",
          "new_text": null,
          "old_line_content": "            mkv->cues_pos = avio_tell(pb);",
          "new_line_content": "    if (mkv->reserve_cues_space) {",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": "put_ebml_void",
          "new_api": null,
          "old_text": "put_ebml_void(pb, mkv->reserve_cues_space)",
          "new_text": null,
          "old_line_content": "            put_ebml_void(pb, mkv->reserve_cues_space);",
          "new_line_content": "            if (mkv->reserve_cues_space == 1)",
          "content_same": false
        },
        {
          "line": 1951,
          "old_api": "IS_SEEKABLE",
          "new_api": null,
          "old_text": "IS_SEEKABLE(pb, mkv)",
          "new_text": null,
          "old_line_content": "    if (IS_SEEKABLE(pb, mkv)) {",
          "new_line_content": "    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or",
          "content_same": false
        },
        {
          "line": 1969,
          "old_api": "ebml_length_size",
          "new_api": null,
          "old_text": "ebml_length_size(size)",
          "new_text": null,
          "old_line_content": "    size += ebml_length_size(size);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1982,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(srclen)",
          "new_text": null,
          "old_line_content": "    dst = av_malloc(srclen);",
          "new_line_content": "    int ret;",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": "ff_wv_parse_header",
          "new_api": null,
          "old_text": "ff_wv_parse_header(&header, src)",
          "new_text": null,
          "old_line_content": "        ret = ff_wv_parse_header(&header, src);",
          "new_line_content": "        WvHeader header;",
          "content_same": false
        },
        {
          "line": 2001,
          "old_api": "AV_WL32",
          "new_api": null,
          "old_text": "AV_WL32(dst + offset, header.samples)",
          "new_text": null,
          "old_line_content": "            AV_WL32(dst + offset, header.samples);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2004,
          "old_api": "AV_WL32",
          "new_api": null,
          "old_text": "AV_WL32(dst + offset,     header.flags)",
          "new_text": null,
          "old_line_content": "        AV_WL32(dst + offset,     header.flags);",
          "new_line_content": "            offset += 4;",
          "content_same": false
        },
        {
          "line": 2005,
          "old_api": "AV_WL32",
          "new_api": null,
          "old_text": "AV_WL32(dst + offset + 4, header.crc)",
          "new_text": null,
          "old_line_content": "        AV_WL32(dst + offset + 4, header.crc);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2009,
          "old_api": "AV_WL32",
          "new_api": null,
          "old_text": "AV_WL32(dst + offset, header.blocksize)",
          "new_text": null,
          "old_line_content": "            AV_WL32(dst + offset, header.blocksize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2013,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(dst + offset, src, header.blocksize)",
          "new_text": null,
          "old_line_content": "        memcpy(dst + offset, src, header.blocksize);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2024,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&dst)",
          "new_text": null,
          "old_line_content": "    av_freep(&dst);",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 2047,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s, AV_LOG_DEBUG,\n           \"Writing block of size %d with pts %\" PRId64 \", dts %\" PRId64 \", \"\n           \"duration %\" PRId64 \" at relative offset %\" PRId64 \" in cluster \"\n           \"at offset %\" PRId64 \". TrackNumber %u, keyframe %d\\n\",\n           pkt->size, pkt->pts, pkt->dts, pkt->duration, avio_tell(pb),\n           mkv->cluster_pos, track_number, keyframe != 0)",
          "new_text": null,
          "old_line_content": "    av_log(s, AV_LOG_DEBUG,",
          "new_line_content": "    /* The following string is identical to the one in mkv_write_vtt_blocks",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 158,
      "total_additions": 439,
      "total_deletions": 438,
      "total_api_changes": 1035
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 2,
        "api_related_lines": 1035,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          199
        ]
      }
    },
    "api_calls_before": 675,
    "api_calls_after": 676,
    "diff_info": {
      "added_lines": 2,
      "removed_lines": 0,
      "total_diff_lines": 14
    }
  }
}