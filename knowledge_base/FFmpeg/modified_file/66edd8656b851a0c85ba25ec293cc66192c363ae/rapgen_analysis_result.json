{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/66edd8656b851a0c85ba25ec293cc66192c363ae",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/66edd8656b851a0c85ba25ec293cc66192c363ae/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/66edd8656b851a0c85ba25ec293cc66192c363ae/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/66edd8656b851a0c85ba25ec293cc66192c363ae/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 219,
          "old_api": "ff_lpc_init",
          "new_api": "ff_lpc_end",
          "old_text": "ff_lpc_init(s, blocksize, max_order, lpc_type)",
          "new_text": "ff_lpc_end(s)",
          "old_line_content": "        ff_lpc_init(s, blocksize, max_order, lpc_type);",
          "new_line_content": "        ff_lpc_end(s);",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": "fabs",
          "new_api": "evaluate_lls",
          "old_text": "fabs(eval - var[0])",
          "new_text": "m[pass&1].evaluate_lls(&m[(pass-1)&1], var+1, max_order-1)",
          "old_line_content": "                    eval= (512>>pass) + fabs(eval - var[0]);",
          "new_line_content": "                    eval= m[pass&1].evaluate_lls(&m[(pass-1)&1], var+1, max_order-1);",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": "FFALIGN",
          "new_api": "AVERROR",
          "old_text": "FFALIGN(max_order, 4)",
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    s->windowed_samples = s->windowed_buffer + FFALIGN(max_order, 4);",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 259,
          "old_api": null,
          "new_api": "fabs",
          "old_text": null,
          "new_text": "fabs(eval - var[0])",
          "old_line_content": "                    inv = 1/eval;",
          "new_line_content": "                    eval= (512>>pass) + fabs(eval - var[0]);",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": null,
          "new_api": "sqrt",
          "old_text": null,
          "new_text": "sqrt(inv)",
          "old_line_content": "                    for(j=0; j<=max_order; j++)",
          "new_line_content": "                    rinv = sqrt(inv);",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": null,
          "new_api": "update_lls",
          "old_text": null,
          "new_text": "m[pass&1].update_lls(&m[pass&1], var)",
          "old_line_content": "            }",
          "new_line_content": "                m[pass&1].update_lls(&m[pass&1], var);",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": null,
          "new_api": "avpriv_solve_lls",
          "old_text": null,
          "new_text": "avpriv_solve_lls(&m[pass&1], 0.001, 0)",
          "old_line_content": "        }",
          "new_line_content": "            avpriv_solve_lls(&m[pass&1], 0.001, 0);",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": null,
          "new_api": "sqrt",
          "old_text": null,
          "new_text": "sqrt(m[(pass-1)&1].variance[i] / weight)",
          "old_line_content": "        }",
          "new_line_content": "            ref[i]= sqrt(m[(pass-1)&1].variance[i] / weight) * (blocksize - max_order) / 4000;",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": null,
          "new_api": "estimate_best_order",
          "old_text": null,
          "new_text": "estimate_best_order(ref, min_order, max_order)",
          "old_line_content": "        i = opt_order-1;",
          "new_line_content": "        opt_order = estimate_best_order(ref, min_order, max_order);",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": null,
          "new_api": "quantize_lpc_coefs",
          "old_text": null,
          "new_text": "quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift)",
          "old_line_content": "    } else {",
          "new_line_content": "        quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift);",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": null,
          "new_api": "quantize_lpc_coefs",
          "old_text": null,
          "new_text": "quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift)",
          "old_line_content": "        }",
          "new_line_content": "            quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift);",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": null,
          "new_api": "FFALIGN",
          "old_text": null,
          "new_text": "FFALIGN(max_order, 4)",
          "old_line_content": "                                    sizeof(*s->windowed_samples));",
          "new_line_content": "    s->windowed_buffer = av_mallocz((blocksize + 2 + FFALIGN(max_order, 4)) *",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": null,
          "new_api": "FFALIGN",
          "old_text": null,
          "new_text": "FFALIGN(max_order, 4)",
          "old_line_content": "",
          "new_line_content": "    s->windowed_samples = s->windowed_buffer + FFALIGN(max_order, 4);",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": null,
          "new_api": "lpc_compute_autocorr",
          "old_text": null,
          "new_text": "s->lpc_compute_autocorr(s->windowed_samples, len, order, autoc)",
          "old_line_content": "    signal = autoc[0];",
          "new_line_content": "    s->lpc_compute_autocorr(s->windowed_samples, len, order, autoc);",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": null,
          "new_api": "ff_lpc_init_x86",
          "old_text": null,
          "new_text": "ff_lpc_init_x86(s)",
          "old_line_content": "",
          "new_line_content": "        ff_lpc_init_x86(s);",
          "content_same": false
        },
        {
          "line": 187,
          "old_api": null,
          "new_api": "compute_ref_coefs",
          "old_text": null,
          "new_text": "compute_ref_coefs(autoc, order, ref, error)",
          "old_line_content": "    for (i = 0; i < order; i++)",
          "new_line_content": "    compute_ref_coefs(autoc, order, ref, error);",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&s->windowed_buffer)",
          "old_line_content": "}",
          "new_line_content": "    av_freep(&s->windowed_buffer);",
          "content_same": false
        },
        {
          "line": 212,
          "old_api": null,
          "new_api": "av_assert2",
          "old_text": null,
          "new_text": "av_assert2(max_order >= MIN_LPC_ORDER && max_order <= MAX_LPC_ORDER &&\n           lpc_type > FF_LPC_TYPE_FIXED)",
          "old_line_content": "           lpc_type > FF_LPC_TYPE_FIXED);",
          "new_line_content": "    av_assert2(max_order >= MIN_LPC_ORDER && max_order <= MAX_LPC_ORDER &&",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": null,
          "new_api": "av_assert0",
          "old_text": null,
          "new_text": "av_assert0(lpc_type == FF_LPC_TYPE_CHOLESKY || lpc_type == FF_LPC_TYPE_LEVINSON)",
          "old_line_content": "",
          "new_line_content": "    av_assert0(lpc_type == FF_LPC_TYPE_CHOLESKY || lpc_type == FF_LPC_TYPE_LEVINSON);",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": null,
          "new_api": "ff_lpc_init",
          "old_text": null,
          "new_text": "ff_lpc_init(s, blocksize, max_order, lpc_type)",
          "old_line_content": "    }",
          "new_line_content": "        ff_lpc_init(s, blocksize, max_order, lpc_type);",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": null,
          "new_api": "lpc_apply_welch_window",
          "old_text": null,
          "new_text": "s->lpc_apply_welch_window(samples, blocksize, s->windowed_samples)",
          "old_line_content": "",
          "new_line_content": "        s->lpc_apply_welch_window(samples, blocksize, s->windowed_samples);",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": null,
          "new_api": "lpc_compute_autocorr",
          "old_text": null,
          "new_text": "s->lpc_compute_autocorr(s->windowed_samples, blocksize, max_order, autoc)",
          "old_line_content": "",
          "new_line_content": "        s->lpc_compute_autocorr(s->windowed_samples, blocksize, max_order, autoc);",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": null,
          "new_api": "compute_lpc_coefs",
          "old_text": null,
          "new_text": "compute_lpc_coefs(autoc, max_order, &lpc[0][0], MAX_LPC_ORDER, 0, 1)",
          "old_line_content": "",
          "new_line_content": "        compute_lpc_coefs(autoc, max_order, &lpc[0][0], MAX_LPC_ORDER, 0, 1);",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": null,
          "new_api": "fabs",
          "old_text": null,
          "new_text": "fabs(lpc[i][i])",
          "old_line_content": "",
          "new_line_content": "            ref[i] = fabs(lpc[i][i]);",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": null,
          "new_api": "LOCAL_ALIGNED",
          "old_text": null,
          "new_text": "LOCAL_ALIGNED(32, double, var, [FFALIGN(MAX_LPC_ORDER+1,4)])",
          "old_line_content": "        double av_uninit(weight);",
          "new_line_content": "        LOCAL_ALIGNED(32, double, var, [FFALIGN(MAX_LPC_ORDER+1,4)]);",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": null,
          "new_api": "FFALIGN",
          "old_text": null,
          "new_text": "FFALIGN(MAX_LPC_ORDER+1,4)",
          "old_line_content": "",
          "new_line_content": "        memset(var, 0, FFALIGN(MAX_LPC_ORDER+1,4)*sizeof(*var));",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": null,
          "new_api": "avpriv_init_lls",
          "old_text": null,
          "new_text": "avpriv_init_lls(&m[pass&1], max_order)",
          "old_line_content": "",
          "new_line_content": "            avpriv_init_lls(&m[pass&1], max_order);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 257,
          "old_api": "evaluate_lls",
          "new_api": null,
          "old_text": "m[pass&1].evaluate_lls(&m[(pass-1)&1], var+1, max_order-1)",
          "new_text": null,
          "old_line_content": "                    eval= m[pass&1].evaluate_lls(&m[(pass-1)&1], var+1, max_order-1);",
          "new_line_content": "                    double eval, inv, rinv;",
          "content_same": false
        },
        {
          "line": 260,
          "old_api": "sqrt",
          "new_api": null,
          "old_text": "sqrt(inv)",
          "new_text": null,
          "old_line_content": "                    rinv = sqrt(inv);",
          "new_line_content": "                    inv = 1/eval;",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "update_lls",
          "new_api": null,
          "old_text": "m[pass&1].update_lls(&m[pass&1], var)",
          "new_text": null,
          "old_line_content": "                m[pass&1].update_lls(&m[pass&1], var);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": "avpriv_solve_lls",
          "new_api": null,
          "old_text": "avpriv_solve_lls(&m[pass&1], 0.001, 0)",
          "new_text": null,
          "old_line_content": "            avpriv_solve_lls(&m[pass&1], 0.001, 0);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": "sqrt",
          "new_api": null,
          "old_text": "sqrt(m[(pass-1)&1].variance[i] / weight)",
          "new_text": null,
          "old_line_content": "            ref[i]= sqrt(m[(pass-1)&1].variance[i] / weight) * (blocksize - max_order) / 4000;",
          "new_line_content": "                lpc[i][j]=-m[(pass-1)&1].coeff[i][j];",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "estimate_best_order",
          "new_api": null,
          "old_text": "estimate_best_order(ref, min_order, max_order)",
          "new_text": null,
          "old_line_content": "        opt_order = estimate_best_order(ref, min_order, max_order);",
          "new_line_content": "    if(omethod == ORDER_METHOD_EST) {",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": "quantize_lpc_coefs",
          "new_api": null,
          "old_text": "quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift)",
          "new_text": null,
          "old_line_content": "        quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift);",
          "new_line_content": "        i = opt_order-1;",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "quantize_lpc_coefs",
          "new_api": null,
          "old_text": "quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift)",
          "new_text": null,
          "old_line_content": "            quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift);",
          "new_line_content": "        for(i=min_order-1; i<max_order; i++) {",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": "FFALIGN",
          "new_api": null,
          "old_text": "FFALIGN(max_order, 4)",
          "new_text": null,
          "old_line_content": "    s->windowed_buffer = av_mallocz((blocksize + 2 + FFALIGN(max_order, 4)) *",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "    if (!s->windowed_buffer)",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": "lpc_compute_autocorr",
          "new_api": null,
          "old_text": "s->lpc_compute_autocorr(s->windowed_samples, len, order, autoc)",
          "new_text": null,
          "old_line_content": "    s->lpc_compute_autocorr(s->windowed_samples, len, order, autoc);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": "ff_lpc_init_x86",
          "new_api": null,
          "old_text": "ff_lpc_init_x86(s)",
          "new_text": null,
          "old_line_content": "        ff_lpc_init_x86(s);",
          "new_line_content": "    if (ARCH_X86)",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": "compute_ref_coefs",
          "new_api": null,
          "old_text": "compute_ref_coefs(autoc, order, ref, error)",
          "new_text": null,
          "old_line_content": "    compute_ref_coefs(autoc, order, ref, error);",
          "new_line_content": "    signal = autoc[0];",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&s->windowed_buffer)",
          "new_text": null,
          "old_line_content": "    av_freep(&s->windowed_buffer);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 211,
          "old_api": "av_assert2",
          "new_api": null,
          "old_text": "av_assert2(max_order >= MIN_LPC_ORDER && max_order <= MAX_LPC_ORDER &&\n           lpc_type > FF_LPC_TYPE_FIXED)",
          "new_text": null,
          "old_line_content": "    av_assert2(max_order >= MIN_LPC_ORDER && max_order <= MAX_LPC_ORDER &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": "av_assert0",
          "new_api": null,
          "old_text": "av_assert0(lpc_type == FF_LPC_TYPE_CHOLESKY || lpc_type == FF_LPC_TYPE_LEVINSON)",
          "new_text": null,
          "old_line_content": "    av_assert0(lpc_type == FF_LPC_TYPE_CHOLESKY || lpc_type == FF_LPC_TYPE_LEVINSON);",
          "new_line_content": "           lpc_type > FF_LPC_TYPE_FIXED);",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": "ff_lpc_end",
          "new_api": null,
          "old_text": "ff_lpc_end(s)",
          "new_text": null,
          "old_line_content": "        ff_lpc_end(s);",
          "new_line_content": "        lpc_type  != s->lpc_type) {",
          "content_same": false
        },
        {
          "line": 226,
          "old_api": "lpc_apply_welch_window",
          "new_api": null,
          "old_text": "s->lpc_apply_welch_window(samples, blocksize, s->windowed_samples)",
          "new_text": null,
          "old_line_content": "        s->lpc_apply_welch_window(samples, blocksize, s->windowed_samples);",
          "new_line_content": "    if (lpc_type == FF_LPC_TYPE_LEVINSON || (lpc_type == FF_LPC_TYPE_CHOLESKY && lpc_passes > 1)) {",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": "lpc_compute_autocorr",
          "new_api": null,
          "old_text": "s->lpc_compute_autocorr(s->windowed_samples, blocksize, max_order, autoc)",
          "new_text": null,
          "old_line_content": "        s->lpc_compute_autocorr(s->windowed_samples, blocksize, max_order, autoc);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": "compute_lpc_coefs",
          "new_api": null,
          "old_text": "compute_lpc_coefs(autoc, max_order, &lpc[0][0], MAX_LPC_ORDER, 0, 1)",
          "new_text": null,
          "old_line_content": "        compute_lpc_coefs(autoc, max_order, &lpc[0][0], MAX_LPC_ORDER, 0, 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 233,
          "old_api": "fabs",
          "new_api": null,
          "old_text": "fabs(lpc[i][i])",
          "new_text": null,
          "old_line_content": "            ref[i] = fabs(lpc[i][i]);",
          "new_line_content": "        for(i=0; i<max_order; i++)",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": "LOCAL_ALIGNED",
          "new_api": null,
          "old_text": "LOCAL_ALIGNED(32, double, var, [FFALIGN(MAX_LPC_ORDER+1,4)])",
          "new_text": null,
          "old_line_content": "        LOCAL_ALIGNED(32, double, var, [FFALIGN(MAX_LPC_ORDER+1,4)]);",
          "new_line_content": "        LLSModel *m = s->lls_models;",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": "FFALIGN",
          "new_api": null,
          "old_text": "FFALIGN(MAX_LPC_ORDER+1,4)",
          "new_text": null,
          "old_line_content": "        memset(var, 0, FFALIGN(MAX_LPC_ORDER+1,4)*sizeof(*var));",
          "new_line_content": "        double av_uninit(weight);",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": "avpriv_init_lls",
          "new_api": null,
          "old_text": "avpriv_init_lls(&m[pass&1], max_order)",
          "new_text": null,
          "old_line_content": "            avpriv_init_lls(&m[pass&1], max_order);",
          "new_line_content": "        for(; pass<lpc_passes; pass++){",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 3,
      "total_additions": 24,
      "total_deletions": 24,
      "total_api_changes": 51
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 2,
        "api_related_lines": 51,
        "non_api_lines": 2,
        "non_api_line_numbers": [
          179,
          182
        ]
      }
    },
    "api_calls_before": 38,
    "api_calls_after": 38,
    "diff_info": {
      "added_lines": 2,
      "removed_lines": 1,
      "total_diff_lines": 17
    }
  }
}