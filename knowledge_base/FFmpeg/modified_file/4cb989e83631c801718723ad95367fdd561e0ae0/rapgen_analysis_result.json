{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/4cb989e83631c801718723ad95367fdd561e0ae0",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/4cb989e83631c801718723ad95367fdd561e0ae0/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/4cb989e83631c801718723ad95367fdd561e0ae0/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/4cb989e83631c801718723ad95367fdd561e0ae0/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1185,
          "old_api": "bytestream_get_le32",
          "new_api": "memset",
          "old_text": "bytestream_get_le32(&rgb[c])",
          "new_text": "memset(ptr_x, 0, bxmin)",
          "old_line_content": "                    *ptr_x++ = bytestream_get_le32(&rgb[c]) >> 16;",
          "new_line_content": "            memset(ptr_x, 0, bxmin);",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": "bytestream2_get_byte",
          "new_api": "bytestream2_peek_byte",
          "old_text": "bytestream2_get_byte(gb)",
          "new_text": "bytestream2_peek_byte(gb)",
          "old_line_content": "            while (bytestream2_get_byte(gb) != 0);",
          "new_line_content": "        if (!bytestream2_peek_byte(gb))",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": "strlen",
          "new_api": "bytestream2_get_bytes_left",
          "old_text": "strlen(value_type)",
          "new_text": "bytestream2_get_bytes_left(gb)",
          "old_line_content": "            gb->buffer += strlen(value_type) + 1;",
          "new_line_content": "    if (bytestream2_get_bytes_left(gb) >= minimum_length &&",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": "bytestream2_get_le32",
          "new_api": "strcmp",
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": "strcmp(gb->buffer, value_name)",
          "old_line_content": "            var_size = bytestream2_get_le32(gb);",
          "new_line_content": "        !strcmp(gb->buffer, value_name)) {",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": "strlen",
          "old_text": "bytestream2_get_bytes_left(gb)",
          "new_text": "strlen(value_name)",
          "old_line_content": "            if (var_size > bytestream2_get_bytes_left(gb))",
          "new_line_content": "        gb->buffer += strlen(value_name) + 1;",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": "av_log",
          "new_api": "bytestream2_get_bytes_left",
          "old_text": "av_log(s->avctx, AV_LOG_WARNING,\n                   \"Unknown data type %s for header variable %s.\\n\",\n                   value_type, value_name)",
          "new_text": "bytestream2_get_bytes_left(gb)",
          "old_line_content": "            av_log(s->avctx, AV_LOG_WARNING,",
          "new_line_content": "            if (var_size > bytestream2_get_bytes_left(gb))",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": "bytestream2_get_le32",
          "new_api": "bytestream2_get_bytes_left",
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": "bytestream2_get_bytes_left(gb)",
          "old_line_content": "    magic_number = bytestream2_get_le32(gb);",
          "new_line_content": "    if (bytestream2_get_bytes_left(gb) < 10) {",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": "avpriv_report_missing_feature",
          "old_text": "bytestream2_get_bytes_left(gb)",
          "new_text": "avpriv_report_missing_feature(s->avctx, \"deep data\")",
          "old_line_content": "    while (bytestream2_get_bytes_left(gb) > 0) {",
          "new_line_content": "        avpriv_report_missing_feature(s->avctx, \"deep data\");",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": "bytestream2_peek_byte",
          "new_api": "bytestream2_get_bytes_left",
          "old_text": "bytestream2_peek_byte(gb)",
          "new_text": "bytestream2_get_bytes_left(gb)",
          "old_line_content": "            if (bytestream2_peek_byte(gb)) {",
          "new_line_content": "    while (bytestream2_get_bytes_left(gb) > 0) {",
          "content_same": false
        },
        {
          "line": 1337,
          "old_api": "bytestream2_peek_byte",
          "new_api": "bytestream2_get_bytes_left",
          "old_text": "bytestream2_peek_byte(gb)",
          "new_text": "bytestream2_get_bytes_left(gb)",
          "old_line_content": "                if (!bytestream2_peek_byte(gb))",
          "new_line_content": "               bytestream2_get_bytes_left(gb) > 0) {",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": "bytestream2_peek_byte",
          "old_text": "bytestream2_get_bytes_left(gb)",
          "new_text": "bytestream2_peek_byte(gb)",
          "old_line_content": "                while (bytestream2_get_bytes_left(gb) > 0) {",
          "new_line_content": "        if (!bytestream2_peek_byte(gb)) {",
          "content_same": false
        },
        {
          "line": 1354,
          "old_api": "bytestream2_peek_byte",
          "new_api": "bytestream2_get_bytes_left",
          "old_text": "bytestream2_peek_byte(gb)",
          "new_text": "bytestream2_get_bytes_left(gb)",
          "old_line_content": "                        if (!bytestream2_peek_byte(gb))",
          "new_line_content": "                while (bytestream2_get_bytes_left(gb) > 0) {",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": "check_header_variable",
          "new_api": "bytestream2_peek_byte",
          "old_text": "check_header_variable(s, \"channels\",\n                                              \"chlist\", 38)",
          "new_text": "bytestream2_peek_byte(gb)",
          "old_line_content": "        if ((var_size = check_header_variable(s, \"channels\",",
          "new_line_content": "            if (!bytestream2_peek_byte(gb))",
          "content_same": false
        },
        {
          "line": 1385,
          "old_api": "strlen",
          "new_api": "strcmp",
          "old_text": "strlen(s->layer)",
          "new_text": "strcmp(s->layer, \"\")",
          "old_line_content": "                        ch_gb.buffer += strlen(s->layer);",
          "new_line_content": "                if (strcmp(s->layer, \"\") != 0) {",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": "av_log",
          "new_api": "strlen",
          "old_text": "av_log(s->avctx, AV_LOG_INFO,\n                               \"Channel doesn't match layer : %s.\\n\", ch_gb.buffer)",
          "new_text": "strlen(s->layer)",
          "old_line_content": "                        av_log(s->avctx, AV_LOG_INFO,",
          "new_line_content": "                        ch_gb.buffer += strlen(s->layer);",
          "content_same": false
        },
        {
          "line": 1429,
          "old_api": "av_log",
          "new_api": "bytestream2_get_bytes_left",
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header.\\n\")",
          "new_text": "bytestream2_get_bytes_left(&ch_gb)",
          "old_line_content": "                    av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header.\\n\");",
          "new_line_content": "                while (bytestream2_get_bytes_left(&ch_gb) > 0 &&",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": "bytestream2_get_le32",
          "new_api": "av_log",
          "old_text": "bytestream2_get_le32(&ch_gb)",
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header.\\n\")",
          "old_line_content": "                current_pixel_type = bytestream2_get_le32(&ch_gb);",
          "new_line_content": "                    av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header.\\n\");",
          "content_same": false
        },
        {
          "line": 1447,
          "old_api": "avpriv_report_missing_feature",
          "new_api": "bytestream2_skip",
          "old_text": "avpriv_report_missing_feature(s->avctx,\n                                                  \"Subsampling %dx%d\",\n                                                  xsub, ysub)",
          "new_text": "bytestream2_skip(&ch_gb, 4)",
          "old_line_content": "                    avpriv_report_missing_feature(s->avctx,",
          "new_line_content": "                bytestream2_skip(&ch_gb, 4);",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": "check_header_variable",
          "new_api": "av_log",
          "old_text": "check_header_variable(s, \"tiles\",\n                                                     \"tiledesc\", 22)",
          "new_text": "av_log(s->avctx, AV_LOG_WARNING,\n                       \"Found more than one compression attribute.\\n\")",
          "old_line_content": "        } else if ((var_size = check_header_variable(s, \"tiles\",",
          "new_line_content": "                av_log(s->avctx, AV_LOG_WARNING,",
          "content_same": false
        },
        {
          "line": 1604,
          "old_api": "av_log",
          "new_api": "check_header_variable",
          "old_text": "av_log(s->avctx, AV_LOG_WARNING,\n                       \"Found tile attribute and scanline flags. Exr will be interpreted as scanline.\\n\")",
          "new_text": "check_header_variable(s, \"tiles\",\n                                                     \"tiledesc\", 22)",
          "old_line_content": "                av_log(s->avctx, AV_LOG_WARNING,",
          "new_line_content": "        } else if ((var_size = check_header_variable(s, \"tiles\",",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": "avpriv_report_missing_feature",
          "new_api": "bytestream2_get_byte",
          "old_text": "avpriv_report_missing_feature(s->avctx, \"Tile level mode %d\",\n                                              s->tile_attr.level_mode)",
          "new_text": "bytestream2_get_byte(gb)",
          "old_line_content": "                avpriv_report_missing_feature(s->avctx, \"Tile level mode %d\",",
          "new_line_content": "            tileLevel = bytestream2_get_byte(gb);",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": "av_dict_set",
          "new_api": "check_header_variable",
          "old_text": "av_dict_set(&metadata, \"writer\", key, 0)",
          "new_text": "check_header_variable(s, \"writer\",\n                                                     \"string\", 1)",
          "old_line_content": "            av_dict_set(&metadata, \"writer\", key, 0);",
          "new_line_content": "        } else if ((var_size = check_header_variable(s, \"writer\",",
          "content_same": false
        },
        {
          "line": 1659,
          "old_api": "strncmp",
          "new_api": "check_header_variable",
          "old_text": "strncmp(\"scanlineimage\", key, var_size)",
          "new_text": "check_header_variable(s, \"type\",\n                                                     \"string\", 16)",
          "old_line_content": "            if (strncmp(\"scanlineimage\", key, var_size) &&",
          "new_line_content": "        } else if ((var_size = check_header_variable(s, \"type\",",
          "content_same": false
        },
        {
          "line": 1664,
          "old_api": "check_header_variable",
          "new_api": "strncmp",
          "old_text": "check_header_variable(s, \"preview\",\n                                                     \"preview\", 16)",
          "new_text": "strncmp(\"scanlineimage\", key, var_size)",
          "old_line_content": "        } else if ((var_size = check_header_variable(s, \"preview\",",
          "new_line_content": "            if (strncmp(\"scanlineimage\", key, var_size) &&",
          "content_same": false
        },
        {
          "line": 1697,
          "old_api": "bytestream2_skip",
          "new_api": "bytestream2_get_bytes_left",
          "old_text": "bytestream2_skip(gb, 1)",
          "new_text": "bytestream2_get_bytes_left(gb)",
          "old_line_content": "            bytestream2_skip(gb, 1);",
          "new_line_content": "            while (bytestream2_get_bytes_left(gb) > 0 &&",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": "bytestream2_get_byte",
          "old_text": "bytestream2_get_bytes_left(gb)",
          "new_text": "bytestream2_get_byte(gb)",
          "old_line_content": "            while (bytestream2_get_bytes_left(gb) > 0 &&",
          "new_line_content": "                name[i++] = bytestream2_get_byte(gb);",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": "bytestream2_get_le32",
          "new_api": "bytestream2_get_bytes_left",
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": "bytestream2_get_bytes_left(gb)",
          "old_line_content": "            size = bytestream2_get_le32(gb);",
          "new_line_content": "            while (bytestream2_get_bytes_left(gb) > 0 &&",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "FFMIN",
          "new_api": "bytestream2_get_byte",
          "old_text": "FFMIN(sizeof(value) - 1, size)",
          "new_text": "bytestream2_get_byte(gb)",
          "old_line_content": "            bytestream2_get_buffer(gb, value, FFMIN(sizeof(value) - 1, size));",
          "new_line_content": "                type[i++] = bytestream2_get_byte(gb);",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": "av_dict_set",
          "new_api": "bytestream2_skip",
          "old_text": "av_dict_set(&metadata, name, value, 0)",
          "new_text": "bytestream2_skip(gb, 1)",
          "old_line_content": "                av_dict_set(&metadata, name, value, 0);",
          "new_line_content": "            bytestream2_skip(gb, 1);",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": "av_log",
          "new_api": "av_dict_set",
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Missing compression attribute.\\n\")",
          "new_text": "av_dict_set(&metadata, name, value, 0)",
          "old_line_content": "        av_log(s->avctx, AV_LOG_ERROR, \"Missing compression attribute.\\n\");",
          "new_line_content": "                av_dict_set(&metadata, name, value, 0);",
          "content_same": false
        },
        {
          "line": 1838,
          "old_api": "av_pix_fmt_desc_get",
          "new_api": "ff_set_dimensions",
          "old_text": "av_pix_fmt_desc_get(avctx->pix_fmt)",
          "new_text": "ff_set_dimensions(avctx, s->w, s->h)",
          "old_line_content": "    s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "new_line_content": "    if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0)",
          "content_same": false
        },
        {
          "line": 1866,
          "old_api": "av_log",
          "new_api": "bytestream2_get_bytes_left",
          "old_text": "av_log(s->avctx, AV_LOG_DEBUG, \"recreating invalid scanline offset table\\n\")",
          "new_text": "bytestream2_get_bytes_left(gb)",
          "old_line_content": "        av_log(s->avctx, AV_LOG_DEBUG, \"recreating invalid scanline offset table\\n\");",
          "new_line_content": "    if (bytestream2_get_bytes_left(gb)/8 < nb_blocks)",
          "content_same": false
        },
        {
          "line": 1870,
          "old_api": "bytestream2_init_writer",
          "new_api": "bytestream2_peek_le64",
          "old_text": "bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8)",
          "new_text": "bytestream2_peek_le64(gb)",
          "old_line_content": "        bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8);",
          "new_line_content": "    if (!s->is_tile && bytestream2_peek_le64(gb) == 0) {",
          "content_same": false
        },
        {
          "line": 1952,
          "old_api": "powf",
          "new_api": "exr_half2float",
          "old_text": "powf(t.f, one_gamma)",
          "new_text": "exr_half2float(i)",
          "old_line_content": "                    t.f = powf(t.f, one_gamma);",
          "new_line_content": "                t = exr_half2float(i);",
          "content_same": false
        },
        {
          "line": 1979,
          "old_api": "ff_free_vlc",
          "new_api": "av_freep",
          "old_text": "ff_free_vlc(&td->vlc)",
          "new_text": "av_freep(&td->tmp)",
          "old_line_content": "        ff_free_vlc(&td->vlc);",
          "new_line_content": "        av_freep(&td->tmp);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2051,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"OpenEXR image\")",
          "old_line_content": "    .close            = decode_end,",
          "new_line_content": "    .long_name        = NULL_IF_CONFIG_SMALL(\"OpenEXR image\"),",
          "content_same": false
        },
        {
          "line": 1543,
          "old_api": null,
          "new_api": "check_header_variable",
          "old_text": null,
          "new_text": "check_header_variable(s, \"displayWindow\",\n                                                     \"box2i\", 34)",
          "old_line_content": "                ret = AVERROR_INVALIDDATA;",
          "new_line_content": "        } else if ((var_size = check_header_variable(s, \"displayWindow\",",
          "content_same": false
        },
        {
          "line": 1552,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "            s->w = dx - sx + 1;",
          "new_line_content": "            sx = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1553,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "            s->h = dy - sy + 1;",
          "new_line_content": "            sy = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1554,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "",
          "new_line_content": "            dx = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1555,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "            continue;",
          "new_line_content": "            dy = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": null,
          "new_api": "check_header_variable",
          "old_text": null,
          "new_text": "check_header_variable(s, \"lineOrder\",\n                                                     \"lineOrder\", 25)",
          "old_line_content": "                goto fail;",
          "new_line_content": "        } else if ((var_size = check_header_variable(s, \"lineOrder\",",
          "content_same": false
        },
        {
          "line": 1569,
          "old_api": null,
          "new_api": "bytestream2_get_byte",
          "old_text": null,
          "new_text": "bytestream2_get_byte(gb)",
          "old_line_content": "                goto fail;",
          "new_line_content": "            line_order = bytestream2_get_byte(gb);",
          "content_same": false
        },
        {
          "line": 1570,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_DEBUG, \"line order: %d.\\n\", line_order)",
          "old_line_content": "            }",
          "new_line_content": "            av_log(s->avctx, AV_LOG_DEBUG, \"line order: %d.\\n\", line_order);",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Unknown line order.\\n\")",
          "old_line_content": "            continue;",
          "new_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"Unknown line order.\\n\");",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": null,
          "new_api": "check_header_variable",
          "old_text": null,
          "new_text": "check_header_variable(s, \"pixelAspectRatio\",\n                                                     \"float\", 31)",
          "old_line_content": "            }",
          "new_line_content": "        } else if ((var_size = check_header_variable(s, \"pixelAspectRatio\",",
          "content_same": false
        },
        {
          "line": 1585,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "            if (!var_size) {",
          "new_line_content": "            s->sar = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1588,
          "old_api": null,
          "new_api": "check_header_variable",
          "old_text": null,
          "new_text": "check_header_variable(s, \"compression\",\n                                                     \"compression\", 29)",
          "old_line_content": "            }",
          "new_line_content": "        } else if ((var_size = check_header_variable(s, \"compression\",",
          "content_same": false
        },
        {
          "line": 1596,
          "old_api": null,
          "new_api": "bytestream2_get_byte",
          "old_text": null,
          "new_text": "bytestream2_get_byte(gb)",
          "old_line_content": "            }",
          "new_line_content": "                s->compression = bytestream2_get_byte(gb);",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": null,
          "new_api": "bytestream2_skip",
          "old_text": null,
          "new_text": "bytestream2_skip(gb, 1)",
          "old_line_content": "            continue;",
          "new_line_content": "                bytestream2_skip(gb, 1);",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_WARNING,\n                       \"Found tile attribute and scanline flags. Exr will be interpreted as scanline.\\n\")",
          "old_line_content": "",
          "new_line_content": "                av_log(s->avctx, AV_LOG_WARNING,",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "            s->tile_attr.level_round = (tileLevel >> 4) & 0x0f;",
          "new_line_content": "            s->tile_attr.xSize = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "",
          "new_line_content": "            s->tile_attr.ySize = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": null,
          "new_api": "avpriv_report_missing_feature",
          "old_text": null,
          "new_text": "avpriv_report_missing_feature(s->avctx, \"Tile level mode %d\",\n                                              s->tile_attr.level_mode)",
          "old_line_content": "",
          "new_line_content": "                avpriv_report_missing_feature(s->avctx, \"Tile level mode %d\",",
          "content_same": false
        },
        {
          "line": 1627,
          "old_api": null,
          "new_api": "avpriv_report_missing_feature",
          "old_text": null,
          "new_text": "avpriv_report_missing_feature(s->avctx, \"Tile level round %d\",\n                                              s->tile_attr.level_round)",
          "old_line_content": "",
          "new_line_content": "                avpriv_report_missing_feature(s->avctx, \"Tile level round %d\",",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(sizeof(key) - 1, var_size)",
          "old_line_content": "                                                     \"rational\", 33)) >= 0) {",
          "new_line_content": "            bytestream2_get_buffer(gb, key, FFMIN(sizeof(key) - 1, var_size));",
          "content_same": false
        },
        {
          "line": 1639,
          "old_api": null,
          "new_api": "av_dict_set",
          "old_text": null,
          "new_text": "av_dict_set(&metadata, \"writer\", key, 0)",
          "old_line_content": "            if (!var_size) {",
          "new_line_content": "            av_dict_set(&metadata, \"writer\", key, 0);",
          "content_same": false
        },
        {
          "line": 1642,
          "old_api": null,
          "new_api": "check_header_variable",
          "old_text": null,
          "new_text": "check_header_variable(s, \"framesPerSecond\",\n                                                     \"rational\", 33)",
          "old_line_content": "            }",
          "new_line_content": "        } else if ((var_size = check_header_variable(s, \"framesPerSecond\",",
          "content_same": false
        },
        {
          "line": 1649,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "                                                     \"int\", 23)) >= 0) {",
          "new_line_content": "            s->avctx->framerate.num = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "",
          "new_line_content": "            s->avctx->framerate.den = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": null,
          "new_api": "check_header_variable",
          "old_text": null,
          "new_text": "check_header_variable(s, \"chunkCount\",\n                                                     \"int\", 23)",
          "old_line_content": "            continue;",
          "new_line_content": "        } else if ((var_size = check_header_variable(s, \"chunkCount\",",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": null,
          "new_api": "bytestream_get_le32",
          "old_text": null,
          "new_text": "bytestream_get_le32(&src)",
          "old_line_content": "                    // 16-bit",
          "new_line_content": "                            t.i = bytestream_get_le32(&src);",
          "content_same": false
        },
        {
          "line": 1656,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "            uint8_t key[256] = { 0 };",
          "new_line_content": "            s->chunk_count = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": null,
          "new_api": "bytestream_get_le16",
          "old_text": null,
          "new_text": "bytestream_get_le16(&src)",
          "old_line_content": "                        }",
          "new_line_content": "                            *ptr_x++ = s->gamma_table[bytestream_get_le16(&src)];",
          "content_same": false
        },
        {
          "line": 1663,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(sizeof(key) - 1, var_size)",
          "old_line_content": "            continue;",
          "new_line_content": "            bytestream2_get_buffer(gb, key, FFMIN(sizeof(key) - 1, var_size));",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": null,
          "new_api": "strncmp",
          "old_text": null,
          "new_text": "strncmp(\"tiledimage\", key, var_size)",
          "old_line_content": "                                                     \"preview\", 16)) >= 0) {",
          "new_line_content": "                strncmp(\"tiledimage\", key, var_size))",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": null,
          "new_api": "bytestream_get_le16",
          "old_text": null,
          "new_text": "bytestream_get_le16(&src)",
          "old_line_content": "                // Zero out the end if xmax+1 is not w",
          "new_line_content": "                            *ptr_x++ = exr_half2float(bytestream_get_le16(&src));;",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": null,
          "new_api": "check_header_variable",
          "old_text": null,
          "new_text": "check_header_variable(s, \"preview\",\n                                                     \"preview\", 16)",
          "old_line_content": "",
          "new_line_content": "        } else if ((var_size = check_header_variable(s, \"preview\",",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "                return AVERROR_INVALIDDATA;",
          "new_line_content": "            uint32_t pw = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(ptr_x, 0, axmax)",
          "old_line_content": "",
          "new_line_content": "                memset(ptr_x, 0, axmax);",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "",
          "new_line_content": "            uint32_t ph = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": null,
          "new_api": "bytestream2_get_bytes_left",
          "old_text": null,
          "new_text": "bytestream2_get_bytes_left(gb)",
          "old_line_content": "            continue;",
          "new_line_content": "            if (psize >= bytestream2_get_bytes_left(gb))",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": null,
          "new_api": "av_assert1",
          "old_text": null,
          "new_text": "av_assert1(s->pixel_type == EXR_UINT)",
          "old_line_content": "            const uint8_t * a;",
          "new_line_content": "        av_assert1(s->pixel_type == EXR_UINT);",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": null,
          "new_api": "bytestream2_skip",
          "old_text": null,
          "new_text": "bytestream2_skip(gb, psize)",
          "old_line_content": "        // Check if there are enough bytes for a header",
          "new_line_content": "            bytestream2_skip(gb, psize);",
          "content_same": false
        },
        {
          "line": 1684,
          "old_api": null,
          "new_api": "bytestream2_get_bytes_left",
          "old_text": null,
          "new_text": "bytestream2_get_bytes_left(gb)",
          "old_line_content": "",
          "new_line_content": "        if (bytestream2_get_bytes_left(gb) <= 9) {",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header\\n\")",
          "old_line_content": "        // Process unknown variables",
          "new_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": null,
          "new_api": "bytestream2_peek_byte",
          "old_text": null,
          "new_text": "bytestream2_peek_byte(gb)",
          "old_line_content": "            i = 0;",
          "new_line_content": "                   bytestream2_peek_byte(gb) && i < 255) {",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": null,
          "new_api": "bytestream_get_le32",
          "old_text": null,
          "new_text": "bytestream_get_le32(&rgb[c])",
          "old_line_content": "            }",
          "new_line_content": "                    *ptr_x++ = bytestream_get_le32(&rgb[c]) >> 16;",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": null,
          "new_api": "bytestream2_skip",
          "old_text": null,
          "new_text": "bytestream2_skip(gb, 1)",
          "old_line_content": "            }",
          "new_line_content": "            bytestream2_skip(gb, 1);",
          "content_same": false
        },
        {
          "line": 1705,
          "old_api": null,
          "new_api": "bytestream2_peek_byte",
          "old_text": null,
          "new_text": "bytestream2_peek_byte(gb)",
          "old_line_content": "",
          "new_line_content": "                   bytestream2_peek_byte(gb) && i < 255) {",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": null,
          "new_api": "bytestream_get_le32",
          "old_text": null,
          "new_text": "bytestream_get_le32(&a)",
          "old_line_content": "",
          "new_line_content": "                    *ptr_x++ = bytestream_get_le32(&a) >> 16;",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "        }",
          "new_line_content": "            size = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(ptr_x, 0, axmax)",
          "old_line_content": "            if (channel_buffer[3])",
          "new_line_content": "            memset(ptr_x, 0, axmax);",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(sizeof(value) - 1, size)",
          "old_line_content": "",
          "new_line_content": "            bytestream2_get_buffer(gb, value, FFMIN(sizeof(value) - 1, size));",
          "content_same": false
        },
        {
          "line": 1712,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(type, \"string\")",
          "old_line_content": "    if (s->compression == EXR_UNKN) {",
          "new_line_content": "            if (!strcmp(type, \"string\"))",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Missing compression attribute.\\n\")",
          "old_line_content": "    if (s->is_tile) {",
          "new_line_content": "        av_log(s->avctx, AV_LOG_ERROR, \"Missing compression attribute.\\n\");",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile attribute.\\n\")",
          "old_line_content": "",
          "new_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile attribute.\\n\");",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": null,
          "new_api": "bytestream2_get_bytes_left",
          "old_text": null,
          "new_text": "bytestream2_get_bytes_left(gb)",
          "old_line_content": "        for (int i = 0; i < 2; i++) // value_name and value_type",
          "new_line_content": "    while (bytestream2_get_bytes_left(gb) > 0) {",
          "content_same": false
        },
        {
          "line": 1731,
          "old_api": null,
          "new_api": "bytestream2_get_bytes_left",
          "old_text": null,
          "new_text": "bytestream2_get_bytes_left(gb)",
          "old_line_content": "",
          "new_line_content": "    if (bytestream2_get_bytes_left(gb) <= 0) {",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Incomplete frame.\\n\")",
          "old_line_content": "    frame->metadata = metadata;",
          "new_line_content": "        av_log(s->avctx, AV_LOG_ERROR, \"Incomplete frame.\\n\");",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": null,
          "new_api": "bytestream2_get_byte",
          "old_text": null,
          "new_text": "bytestream2_get_byte(gb)",
          "old_line_content": "}",
          "new_line_content": "            while (bytestream2_get_byte(gb) != 0);",
          "content_same": false
        },
        {
          "line": 1224,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": " * Check if the variable name corresponds to its data type.",
          "new_line_content": "        bytestream2_skip(gb, bytestream2_get_le32(gb));",
          "content_same": false
        },
        {
          "line": 1740,
          "old_api": null,
          "new_api": "bytestream2_skip",
          "old_text": null,
          "new_text": "bytestream2_skip(gb, 1)",
          "old_line_content": "}",
          "new_line_content": "    bytestream2_skip(gb, 1);",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": null,
          "new_api": "av_dict_free",
          "old_text": null,
          "new_text": "av_dict_free(&metadata)",
          "old_line_content": "                        int *got_frame, AVPacket *avpkt)",
          "new_line_content": "    av_dict_free(&metadata);",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(gb->buffer, value_type)",
          "old_line_content": "                var_size = 0;",
          "new_line_content": "        if (!strcmp(gb->buffer, value_type)) {",
          "content_same": false
        },
        {
          "line": 1253,
          "old_api": null,
          "new_api": "strlen",
          "old_text": null,
          "new_text": "strlen(value_type)",
          "old_line_content": "        } else {",
          "new_line_content": "            gb->buffer += strlen(value_type) + 1;",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "            // value_type not found, reset the buffer",
          "new_line_content": "            var_size = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1764,
          "old_api": null,
          "new_api": "bytestream2_init",
          "old_text": null,
          "new_text": "bytestream2_init(gb, avpkt->data, avpkt->size)",
          "old_line_content": "    switch (s->pixel_type) {",
          "new_line_content": "    bytestream2_init(gb, avpkt->data, avpkt->size);",
          "content_same": false
        },
        {
          "line": 1766,
          "old_api": null,
          "new_api": "decode_header",
          "old_text": null,
          "new_text": "decode_header(s, picture)",
          "old_line_content": "    case EXR_HALF:",
          "new_line_content": "    if ((ret = decode_header(s, picture)) < 0)",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": null,
          "new_api": "strlen",
          "old_text": null,
          "new_text": "strlen(value_name)",
          "old_line_content": "    }",
          "new_line_content": "            gb->buffer -= strlen(value_name) + 1;",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_WARNING,\n                   \"Unknown data type %s for header variable %s.\\n\",\n                   value_type, value_name)",
          "old_line_content": "",
          "new_line_content": "            av_log(s->avctx, AV_LOG_WARNING,",
          "content_same": false
        },
        {
          "line": 1803,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Missing channel list.\\n\")",
          "old_line_content": "        avctx->color_trc = s->apply_trc_type;",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Missing channel list.\\n\");",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Header too short to parse.\\n\")",
          "old_line_content": "    if (magic_number != 20000630) {",
          "new_line_content": "        av_log(s->avctx, AV_LOG_ERROR, \"Header too short to parse.\\n\");",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "        return AVERROR_INVALIDDATA;",
          "new_line_content": "    magic_number = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1311,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Wrong magic number %d.\\n\", magic_number)",
          "old_line_content": "    if (version != 2) {",
          "new_line_content": "        av_log(s->avctx, AV_LOG_ERROR, \"Wrong magic number %d.\\n\", magic_number);",
          "content_same": false
        },
        {
          "line": 1826,
          "old_api": null,
          "new_api": "avpriv_report_missing_feature",
          "old_text": null,
          "new_text": "avpriv_report_missing_feature(avctx, \"Compression %d\", s->compression)",
          "old_line_content": "     * It's possible for the data window can larger or outside the display window */",
          "new_line_content": "        avpriv_report_missing_feature(avctx, \"Compression %d\", s->compression);",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": null,
          "new_api": "bytestream2_get_byte",
          "old_text": null,
          "new_text": "bytestream2_get_byte(gb)",
          "old_line_content": "",
          "new_line_content": "    version = bytestream2_get_byte(gb);",
          "content_same": false
        },
        {
          "line": 1317,
          "old_api": null,
          "new_api": "avpriv_report_missing_feature",
          "old_text": null,
          "new_text": "avpriv_report_missing_feature(s->avctx, \"Version %d\", version)",
          "old_line_content": "",
          "new_line_content": "        avpriv_report_missing_feature(s->avctx, \"Version %d\", version);",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": null,
          "new_api": "bytestream2_get_le24",
          "old_text": null,
          "new_text": "bytestream2_get_le24(gb)",
          "old_line_content": "        s->is_multipart = 1;",
          "new_line_content": "    flags = bytestream2_get_le24(gb);",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Wrong or missing size information.\\n\")",
          "old_line_content": "        return ret;",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Wrong or missing size information.\\n\");",
          "content_same": false
        },
        {
          "line": 1841,
          "old_api": null,
          "new_api": "av_int2float",
          "old_text": null,
          "new_text": "av_int2float(s->sar)",
          "old_line_content": "",
          "new_line_content": "    ff_set_sar(s->avctx, av_d2q(av_int2float(s->sar), 255));",
          "content_same": false
        },
        {
          "line": 1843,
          "old_api": null,
          "new_api": "av_pix_fmt_desc_get",
          "old_text": null,
          "new_text": "av_pix_fmt_desc_get(avctx->pix_fmt)",
          "old_line_content": "        planes           = s->desc->nb_components;",
          "new_line_content": "    s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": null,
          "new_api": "bytestream2_peek_byte",
          "old_text": null,
          "new_text": "bytestream2_peek_byte(gb)",
          "old_line_content": "                    break;",
          "new_line_content": "            if (bytestream2_peek_byte(gb)) {",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": null,
          "new_api": "skip_header_chunk",
          "old_text": null,
          "new_text": "skip_header_chunk(s)",
          "old_line_content": "            }",
          "new_line_content": "                skip_header_chunk(s);",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": null,
          "new_api": "bytestream2_skip",
          "old_text": null,
          "new_text": "bytestream2_skip(gb, 1)",
          "old_line_content": "            s->current_part++;",
          "new_line_content": "                bytestream2_skip(gb, 1);",
          "content_same": false
        },
        {
          "line": 1342,
          "old_api": null,
          "new_api": "bytestream2_peek_byte",
          "old_text": null,
          "new_text": "bytestream2_peek_byte(gb)",
          "old_line_content": "        }",
          "new_line_content": "                if (!bytestream2_peek_byte(gb))",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": null,
          "new_api": "bytestream2_skip",
          "old_text": null,
          "new_text": "bytestream2_skip(gb, 1)",
          "old_line_content": "            if (!s->is_multipart)",
          "new_line_content": "            bytestream2_skip(gb, 1);",
          "content_same": false
        },
        {
          "line": 1863,
          "old_api": null,
          "new_api": "ff_thread_get_buffer",
          "old_text": null,
          "new_text": "ff_thread_get_buffer(avctx, &frame, 0)",
          "old_line_content": "",
          "new_line_content": "    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)",
          "content_same": false
        },
        {
          "line": 1352,
          "old_api": null,
          "new_api": "bytestream2_skip",
          "old_text": null,
          "new_text": "bytestream2_skip(gb, 1)",
          "old_line_content": "                    } else {",
          "new_line_content": "            bytestream2_skip(gb, 1);",
          "content_same": false
        },
        {
          "line": 1355,
          "old_api": null,
          "new_api": "bytestream2_peek_byte",
          "old_text": null,
          "new_text": "bytestream2_peek_byte(gb)",
          "old_line_content": "                            break;",
          "new_line_content": "                    if (bytestream2_peek_byte(gb)) {",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": null,
          "new_api": "skip_header_chunk",
          "old_text": null,
          "new_text": "skip_header_chunk(s)",
          "old_line_content": "                    }",
          "new_line_content": "                        skip_header_chunk(s);",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": null,
          "new_api": "bytestream2_skip",
          "old_text": null,
          "new_text": "bytestream2_skip(gb, 1)",
          "old_line_content": "            }",
          "new_line_content": "                        bytestream2_skip(gb, 1);",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_DEBUG, \"recreating invalid scanline offset table\\n\")",
          "old_line_content": "",
          "new_line_content": "        av_log(s->avctx, AV_LOG_DEBUG, \"recreating invalid scanline offset table\\n\");",
          "content_same": false
        },
        {
          "line": 1873,
          "old_api": null,
          "new_api": "bytestream2_tell",
          "old_text": null,
          "new_text": "bytestream2_tell(gb)",
          "old_line_content": "            /* write offset of prev scanline in offset table */",
          "new_line_content": "        start_offset_table = bytestream2_tell(gb);",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": null,
          "new_api": "bytestream2_init_writer",
          "old_text": null,
          "new_text": "bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8)",
          "old_line_content": "",
          "new_line_content": "        bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8);",
          "content_same": false
        },
        {
          "line": 1879,
          "old_api": null,
          "new_api": "bytestream2_put_le64",
          "old_text": null,
          "new_text": "bytestream2_put_le64(&offset_table_writer, start_next_scanline)",
          "old_line_content": "        }",
          "new_line_content": "            bytestream2_put_le64(&offset_table_writer, start_next_scanline);",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": null,
          "new_api": "check_header_variable",
          "old_text": null,
          "new_text": "check_header_variable(s, \"channels\",\n                                              \"chlist\", 38)",
          "old_line_content": "                goto fail;",
          "new_line_content": "        if ((var_size = check_header_variable(s, \"channels\",",
          "content_same": false
        },
        {
          "line": 1882,
          "old_api": null,
          "new_api": "bytestream2_seek",
          "old_text": null,
          "new_text": "bytestream2_seek(gb, start_next_scanline + 4, SEEK_SET)",
          "old_line_content": "",
          "new_line_content": "            bytestream2_seek(gb, start_next_scanline + 4, SEEK_SET);/* skip line number */",
          "content_same": false
        },
        {
          "line": 1883,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "    // save pointer we are going to use in decode_block",
          "new_line_content": "            start_next_scanline += (bytestream2_get_le32(gb) + 8);",
          "content_same": false
        },
        {
          "line": 1885,
          "old_api": null,
          "new_api": "bytestream2_seek",
          "old_text": null,
          "new_text": "bytestream2_seek(gb, start_offset_table, SEEK_SET)",
          "old_line_content": "    s->buf_size = avpkt->size;",
          "new_line_content": "        bytestream2_seek(gb, start_offset_table, SEEK_SET);",
          "content_same": false
        },
        {
          "line": 1377,
          "old_api": null,
          "new_api": "bytestream2_init",
          "old_text": null,
          "new_text": "bytestream2_init(&ch_gb, gb->buffer, var_size)",
          "old_line_content": "                int channel_index = -1;",
          "new_line_content": "            bytestream2_init(&ch_gb, gb->buffer, var_size);",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": null,
          "new_api": "bytestream2_get_bytes_left",
          "old_text": null,
          "new_text": "bytestream2_get_bytes_left(&ch_gb)",
          "old_line_content": "",
          "new_line_content": "            while (bytestream2_get_bytes_left(&ch_gb) >= 19) {",
          "content_same": false
        },
        {
          "line": 1895,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(s->ymin, s->h)",
          "old_line_content": "",
          "new_line_content": "        for (y = 0; y < FFMIN(s->ymin, s->h); y++) {",
          "content_same": false
        },
        {
          "line": 1896,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(ptr, 0, out_line_size)",
          "old_line_content": "    s->picture = picture;",
          "new_line_content": "            memset(ptr, 0, out_line_size);",
          "content_same": false
        },
        {
          "line": 1386,
          "old_api": null,
          "new_api": "strlen",
          "old_text": null,
          "new_text": "strlen(s->layer)",
          "old_line_content": "                        if (*ch_gb.buffer == '.')",
          "new_line_content": "                    if (strncmp(ch_gb.buffer, s->layer, strlen(s->layer)) == 0) {",
          "content_same": false
        },
        {
          "line": 1388,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_INFO,\n                               \"Channel match layer : %s.\\n\", ch_gb.buffer)",
          "old_line_content": "                    } else {",
          "new_line_content": "                        av_log(s->avctx, AV_LOG_INFO,",
          "content_same": false
        },
        {
          "line": 1903,
          "old_api": null,
          "new_api": "execute2",
          "old_text": null,
          "new_text": "avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks)",
          "old_line_content": "        for (i = 0; i < planes; i++) {",
          "new_line_content": "    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);",
          "content_same": false
        },
        {
          "line": 1905,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(0, s->ymax + 1)",
          "old_line_content": "            for (y = ymax; y < avctx->height; y++) {",
          "new_line_content": "    ymax = FFMAX(0, s->ymax + 1);",
          "content_same": false
        },
        {
          "line": 1395,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_INFO,\n                               \"Channel doesn't match layer : %s.\\n\", ch_gb.buffer)",
          "old_line_content": "                }",
          "new_line_content": "                        av_log(s->avctx, AV_LOG_INFO,",
          "content_same": false
        },
        {
          "line": 1911,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(ptr, 0, out_line_size)",
          "old_line_content": "    picture->pict_type = AV_PICTURE_TYPE_I;",
          "new_line_content": "                memset(ptr, 0, out_line_size);",
          "content_same": false
        },
        {
          "line": 1405,
          "old_api": null,
          "new_api": "av_strcasecmp",
          "old_text": null,
          "new_text": "av_strcasecmp(ch_gb.buffer, \"U\")",
          "old_line_content": "                        channel_index = 1;",
          "new_line_content": "                        !av_strcasecmp(ch_gb.buffer, \"U\")) {",
          "content_same": false
        },
        {
          "line": 1408,
          "old_api": null,
          "new_api": "av_strcasecmp",
          "old_text": null,
          "new_text": "av_strcasecmp(ch_gb.buffer, \"G\")",
          "old_line_content": "                        channel_index = 1;",
          "new_line_content": "                    } else if (!av_strcasecmp(ch_gb.buffer, \"G\") ||",
          "content_same": false
        },
        {
          "line": 1409,
          "old_api": null,
          "new_api": "av_strcasecmp",
          "old_text": null,
          "new_text": "av_strcasecmp(ch_gb.buffer, \"V\")",
          "old_line_content": "                        s->is_luma = 1;",
          "new_line_content": "                               !av_strcasecmp(ch_gb.buffer, \"V\")) {",
          "content_same": false
        },
        {
          "line": 1416,
          "old_api": null,
          "new_api": "av_strcasecmp",
          "old_text": null,
          "new_text": "av_strcasecmp(ch_gb.buffer, \"Z\")",
          "old_line_content": "                        channel_index = 3;",
          "new_line_content": "                               !av_strcasecmp(ch_gb.buffer, \"Z\") ||",
          "content_same": false
        },
        {
          "line": 1417,
          "old_api": null,
          "new_api": "av_strcasecmp",
          "old_text": null,
          "new_text": "av_strcasecmp(ch_gb.buffer, \"W\")",
          "old_line_content": "                    } else {",
          "new_line_content": "                               !av_strcasecmp(ch_gb.buffer, \"W\")) {",
          "content_same": false
        },
        {
          "line": 1420,
          "old_api": null,
          "new_api": "av_strcasecmp",
          "old_text": null,
          "new_text": "av_strcasecmp(ch_gb.buffer, \"A\")",
          "old_line_content": "                    }",
          "new_line_content": "                    } else if (!av_strcasecmp(ch_gb.buffer, \"A\")) {",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": null,
          "new_api": "ff_exrdsp_init",
          "old_text": null,
          "new_text": "ff_exrdsp_init(&s->dsp)",
          "old_line_content": "",
          "new_line_content": "    ff_exrdsp_init(&s->dsp);",
          "content_same": false
        },
        {
          "line": 1423,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_WARNING,\n                               \"Unsupported channel %.256s.\\n\", ch_gb.buffer)",
          "old_line_content": "                /* skip until you get a 0 */",
          "new_line_content": "                        av_log(s->avctx, AV_LOG_WARNING,",
          "content_same": false
        },
        {
          "line": 1935,
          "old_api": null,
          "new_api": "ff_bswapdsp_init",
          "old_text": null,
          "new_text": "ff_bswapdsp_init(&s->bbdsp)",
          "old_line_content": "        for (i = 0; i < 65536; ++i) {",
          "new_line_content": "    ff_bswapdsp_init(&s->bbdsp);",
          "content_same": false
        },
        {
          "line": 1938,
          "old_api": null,
          "new_api": "avpriv_get_trc_function_from_trc",
          "old_text": null,
          "new_text": "avpriv_get_trc_function_from_trc(s->apply_trc_type)",
          "old_line_content": "            s->gamma_table[i] = t;",
          "new_line_content": "    trc_func = avpriv_get_trc_function_from_trc(s->apply_trc_type);",
          "content_same": false
        },
        {
          "line": 1941,
          "old_api": null,
          "new_api": "exr_half2float",
          "old_text": null,
          "new_text": "exr_half2float(i)",
          "old_line_content": "        if (one_gamma > 0.9999f && one_gamma < 1.0001f) {",
          "new_line_content": "            t = exr_half2float(i);",
          "content_same": false
        },
        {
          "line": 1430,
          "old_api": null,
          "new_api": "bytestream2_get_byte",
          "old_text": null,
          "new_text": "bytestream2_get_byte(&ch_gb)",
          "old_line_content": "                    ret = AVERROR_INVALIDDATA;",
          "new_line_content": "                       bytestream2_get_byte(&ch_gb))",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": null,
          "new_api": "trc_func",
          "old_text": null,
          "new_text": "trc_func(t.f)",
          "old_line_content": "            for (i = 0; i < 65536; ++i) {",
          "new_line_content": "            t.f = trc_func(t.f);",
          "content_same": false
        },
        {
          "line": 1433,
          "old_api": null,
          "new_api": "bytestream2_get_bytes_left",
          "old_text": null,
          "new_text": "bytestream2_get_bytes_left(&ch_gb)",
          "old_line_content": "",
          "new_line_content": "                if (bytestream2_get_bytes_left(&ch_gb) < 4) {",
          "content_same": false
        },
        {
          "line": 1948,
          "old_api": null,
          "new_api": "exr_half2float",
          "old_text": null,
          "new_text": "exr_half2float(i)",
          "old_line_content": "                /* If negative value we reuse half value */",
          "new_line_content": "                s->gamma_table[i] = exr_half2float(i);",
          "content_same": false
        },
        {
          "line": 1439,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(&ch_gb)",
          "old_line_content": "                    goto fail;",
          "new_line_content": "                current_pixel_type = bytestream2_get_le32(&ch_gb);",
          "content_same": false
        },
        {
          "line": 1441,
          "old_api": null,
          "new_api": "avpriv_report_missing_feature",
          "old_text": null,
          "new_text": "avpriv_report_missing_feature(s->avctx, \"Pixel type %d\",\n                                                  current_pixel_type)",
          "old_line_content": "",
          "new_line_content": "                    avpriv_report_missing_feature(s->avctx, \"Pixel type %d\",",
          "content_same": false
        },
        {
          "line": 1957,
          "old_api": null,
          "new_api": "powf",
          "old_text": null,
          "new_text": "powf(t.f, one_gamma)",
          "old_line_content": "    }",
          "new_line_content": "                    t.f = powf(t.f, one_gamma);",
          "content_same": false
        },
        {
          "line": 1448,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(&ch_gb)",
          "old_line_content": "                                                  \"Subsampling %dx%d\",",
          "new_line_content": "                xsub = bytestream2_get_le32(&ch_gb);",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(&ch_gb)",
          "old_line_content": "                                                  xsub, ysub);",
          "new_line_content": "                ysub = bytestream2_get_le32(&ch_gb);",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": null,
          "new_api": "avpriv_report_missing_feature",
          "old_text": null,
          "new_text": "avpriv_report_missing_feature(s->avctx,\n                                                  \"Subsampling %dx%d\",\n                                                  xsub, ysub)",
          "old_line_content": "                }",
          "new_line_content": "                    avpriv_report_missing_feature(s->avctx,",
          "content_same": false
        },
        {
          "line": 1965,
          "old_api": null,
          "new_api": "av_mallocz_array",
          "old_text": null,
          "new_text": "av_mallocz_array(avctx->thread_count, sizeof(EXRThreadData))",
          "old_line_content": "}",
          "new_line_content": "    s->thread_data = av_mallocz_array(avctx->thread_count, sizeof(EXRThreadData));",
          "content_same": false
        },
        {
          "line": 1462,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR,\n                               \"RGB channels not of the same depth.\\n\")",
          "old_line_content": "                    s->pixel_type                     = current_pixel_type;",
          "new_line_content": "                        av_log(s->avctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 1980,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&td->bitmap)",
          "old_line_content": "    }",
          "new_line_content": "        av_freep(&td->bitmap);",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&td->lut)",
          "old_line_content": "",
          "new_line_content": "        av_freep(&td->lut);",
          "content_same": false
        },
        {
          "line": 1470,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_WARNING,\n                            \"Multiple channels with index %d.\\n\", channel_index)",
          "old_line_content": "                    }",
          "new_line_content": "                    av_log(s->avctx, AV_LOG_WARNING,",
          "content_same": false
        },
        {
          "line": 1984,
          "old_api": null,
          "new_api": "ff_free_vlc",
          "old_text": null,
          "new_text": "ff_free_vlc(&td->vlc)",
          "old_line_content": "",
          "new_line_content": "        ff_free_vlc(&td->vlc);",
          "content_same": false
        },
        {
          "line": 1987,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&s->thread_data)",
          "old_line_content": "",
          "new_line_content": "    av_freep(&s->thread_data);",
          "content_same": false
        },
        {
          "line": 1988,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&s->channels)",
          "old_line_content": "#define OFFSET(x) offsetof(EXRContext, x)",
          "new_line_content": "    av_freep(&s->channels);",
          "content_same": false
        },
        {
          "line": 1478,
          "old_api": null,
          "new_api": "av_realloc",
          "old_text": null,
          "new_text": "av_realloc(s->channels,\n                                         ++s->nb_channels * sizeof(EXRChannel))",
          "old_line_content": "                }",
          "new_line_content": "                s->channels = av_realloc(s->channels,",
          "content_same": false
        },
        {
          "line": 1481,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "                channel->xsub       = xsub;",
          "new_line_content": "                    ret = AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 1996,
          "old_api": null,
          "new_api": "OFFSET",
          "old_text": null,
          "new_text": "OFFSET(layer)",
          "old_line_content": "        AV_OPT_TYPE_FLOAT, { .dbl = 1.0f }, 0.001, FLT_MAX, VD },",
          "new_line_content": "    { \"layer\", \"Set the decoding layer\", OFFSET(layer),",
          "content_same": false
        },
        {
          "line": 1998,
          "old_api": null,
          "new_api": "OFFSET",
          "old_text": null,
          "new_text": "OFFSET(selected_part)",
          "old_line_content": "    // XXX: Note the abuse of the enum using AVCOL_TRC_UNSPECIFIED to subsume the existing gamma option",
          "new_line_content": "    { \"part\",  \"Set the decoding part\", OFFSET(selected_part),",
          "content_same": false
        },
        {
          "line": 2000,
          "old_api": null,
          "new_api": "OFFSET",
          "old_text": null,
          "new_text": "OFFSET(gamma)",
          "old_line_content": "        AV_OPT_TYPE_INT, {.i64 = AVCOL_TRC_UNSPECIFIED }, 1, AVCOL_TRC_NB-1, VD, \"apply_trc_type\"},",
          "new_line_content": "    { \"gamma\", \"Set the float gamma value when decoding\", OFFSET(gamma),",
          "content_same": false
        },
        {
          "line": 2004,
          "old_api": null,
          "new_api": "OFFSET",
          "old_text": null,
          "new_text": "OFFSET(apply_trc_type)",
          "old_line_content": "        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_UNSPECIFIED },  INT_MIN, INT_MAX, VD, \"apply_trc_type\"},",
          "new_line_content": "    { \"apply_trc\", \"color transfer characteristics to apply to EXR linear input\", OFFSET(apply_trc_type),",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": null,
          "new_api": "FFMIN3",
          "old_text": null,
          "new_text": "FFMIN3(s->channel_offsets[0],\n                           s->channel_offsets[1],\n                           s->channel_offsets[2])",
          "old_line_content": "                    if (s->channel_offsets[1] < 0)",
          "new_line_content": "                if (FFMIN3(s->channel_offsets[0],",
          "content_same": false
        },
        {
          "line": 1503,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Missing red channel.\\n\")",
          "old_line_content": "                    ret = AVERROR_INVALIDDATA;",
          "new_line_content": "                        av_log(s->avctx, AV_LOG_ERROR, \"Missing red channel.\\n\");",
          "content_same": false
        },
        {
          "line": 1505,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Missing green channel.\\n\")",
          "old_line_content": "                }",
          "new_line_content": "                        av_log(s->avctx, AV_LOG_ERROR, \"Missing green channel.\\n\");",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Missing blue channel.\\n\")",
          "old_line_content": "",
          "new_line_content": "                        av_log(s->avctx, AV_LOG_ERROR, \"Missing blue channel.\\n\");",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": null,
          "new_api": "check_header_variable",
          "old_text": null,
          "new_text": "check_header_variable(s, \"dataWindow\", \"box2i\",\n                                                     31)",
          "old_line_content": "                goto fail;",
          "new_line_content": "        } else if ((var_size = check_header_variable(s, \"dataWindow\", \"box2i\",",
          "content_same": false
        },
        {
          "line": 1524,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "            if (xmin > xmax || ymin > ymax ||",
          "new_line_content": "            xmin   = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "                (unsigned)xmax - xmin >= INT_MAX ||",
          "new_line_content": "            ymin   = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1526,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "                (unsigned)ymax - ymin >= INT_MAX) {",
          "new_line_content": "            xmax   = bytestream2_get_le32(gb);",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": null,
          "new_api": "bytestream2_get_le32",
          "old_text": null,
          "new_text": "bytestream2_get_le32(gb)",
          "old_line_content": "                ret = AVERROR_INVALIDDATA;",
          "new_line_content": "            ymax   = bytestream2_get_le32(gb);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1538,
          "old_api": "check_header_variable",
          "new_api": null,
          "old_text": "check_header_variable(s, \"displayWindow\",\n                                                     \"box2i\", 34)",
          "new_text": null,
          "old_line_content": "        } else if ((var_size = check_header_variable(s, \"displayWindow\",",
          "new_line_content": "            s->ymax = ymax;",
          "content_same": false
        },
        {
          "line": 1547,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            sx = bytestream2_get_le32(gb);",
          "new_line_content": "            if (!var_size) {",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            sy = bytestream2_get_le32(gb);",
          "new_line_content": "                ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            dx = bytestream2_get_le32(gb);",
          "new_line_content": "                goto fail;",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            dy = bytestream2_get_le32(gb);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": "check_header_variable",
          "new_api": null,
          "old_text": "check_header_variable(s, \"lineOrder\",\n                                                     \"lineOrder\", 25)",
          "new_text": null,
          "old_line_content": "        } else if ((var_size = check_header_variable(s, \"lineOrder\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": "bytestream2_get_byte",
          "new_api": null,
          "old_text": "bytestream2_get_byte(gb)",
          "new_text": null,
          "old_line_content": "            line_order = bytestream2_get_byte(gb);",
          "new_line_content": "            if (!var_size) {",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_DEBUG, \"line order: %d.\\n\", line_order)",
          "new_text": null,
          "old_line_content": "            av_log(s->avctx, AV_LOG_DEBUG, \"line order: %d.\\n\", line_order);",
          "new_line_content": "                ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Unknown line order.\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"Unknown line order.\\n\");",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": "check_header_variable",
          "new_api": null,
          "old_text": "check_header_variable(s, \"pixelAspectRatio\",\n                                                     \"float\", 31)",
          "new_text": null,
          "old_line_content": "        } else if ((var_size = check_header_variable(s, \"pixelAspectRatio\",",
          "new_line_content": "                ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            s->sar = bytestream2_get_le32(gb);",
          "new_line_content": "            if (!var_size) {",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": "check_header_variable",
          "new_api": null,
          "old_text": "check_header_variable(s, \"compression\",\n                                                     \"compression\", 29)",
          "new_text": null,
          "old_line_content": "        } else if ((var_size = check_header_variable(s, \"compression\",",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1591,
          "old_api": "bytestream2_get_byte",
          "new_api": null,
          "old_text": "bytestream2_get_byte(gb)",
          "new_text": null,
          "old_line_content": "                s->compression = bytestream2_get_byte(gb);",
          "new_line_content": "                ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": "bytestream2_skip",
          "new_api": null,
          "old_text": "bytestream2_skip(gb, 1)",
          "new_text": null,
          "old_line_content": "                bytestream2_skip(gb, 1);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1594,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_WARNING,\n                       \"Found more than one compression attribute.\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(s->avctx, AV_LOG_WARNING,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            s->tile_attr.xSize = bytestream2_get_le32(gb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1608,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            s->tile_attr.ySize = bytestream2_get_le32(gb);",
          "new_line_content": "            if (!s->is_tile)",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": "bytestream2_get_byte",
          "new_api": null,
          "old_text": "bytestream2_get_byte(gb)",
          "new_text": null,
          "old_line_content": "            tileLevel = bytestream2_get_byte(gb);",
          "new_line_content": "                       \"Found tile attribute and scanline flags. Exr will be interpreted as scanline.\\n\");",
          "content_same": false
        },
        {
          "line": 1622,
          "old_api": "avpriv_report_missing_feature",
          "new_api": null,
          "old_text": "avpriv_report_missing_feature(s->avctx, \"Tile level round %d\",\n                                              s->tile_attr.level_round)",
          "new_text": null,
          "old_line_content": "                avpriv_report_missing_feature(s->avctx, \"Tile level round %d\",",
          "new_line_content": "                ret = AVERROR_PATCHWELCOME;",
          "content_same": false
        },
        {
          "line": 1629,
          "old_api": "check_header_variable",
          "new_api": null,
          "old_text": "check_header_variable(s, \"writer\",\n                                                     \"string\", 1)",
          "new_text": null,
          "old_line_content": "        } else if ((var_size = check_header_variable(s, \"writer\",",
          "new_line_content": "                ret = AVERROR_PATCHWELCOME;",
          "content_same": false
        },
        {
          "line": 1633,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(sizeof(key) - 1, var_size)",
          "new_text": null,
          "old_line_content": "            bytestream2_get_buffer(gb, key, FFMIN(sizeof(key) - 1, var_size));",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 1637,
          "old_api": "check_header_variable",
          "new_api": null,
          "old_text": "check_header_variable(s, \"framesPerSecond\",\n                                                     \"rational\", 33)",
          "new_text": null,
          "old_line_content": "        } else if ((var_size = check_header_variable(s, \"framesPerSecond\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1644,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            s->avctx->framerate.num = bytestream2_get_le32(gb);",
          "new_line_content": "            if (!var_size) {",
          "content_same": false
        },
        {
          "line": 1645,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            s->avctx->framerate.den = bytestream2_get_le32(gb);",
          "new_line_content": "                ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 1648,
          "old_api": "check_header_variable",
          "new_api": null,
          "old_text": "check_header_variable(s, \"chunkCount\",\n                                                     \"int\", 23)",
          "new_text": null,
          "old_line_content": "        } else if ((var_size = check_header_variable(s, \"chunkCount\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            s->chunk_count = bytestream2_get_le32(gb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1654,
          "old_api": "check_header_variable",
          "new_api": null,
          "old_text": "check_header_variable(s, \"type\",\n                                                     \"string\", 16)",
          "new_text": null,
          "old_line_content": "        } else if ((var_size = check_header_variable(s, \"type\",",
          "new_line_content": "                                                     \"int\", 23)) >= 0) {",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": "bytestream_get_le16",
          "new_api": null,
          "old_text": "bytestream_get_le16(&src)",
          "new_text": null,
          "old_line_content": "                            *ptr_x++ = s->gamma_table[bytestream_get_le16(&src)];",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(sizeof(key) - 1, var_size)",
          "new_text": null,
          "old_line_content": "            bytestream2_get_buffer(gb, key, FFMIN(sizeof(key) - 1, var_size));",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 1660,
          "old_api": "strncmp",
          "new_api": null,
          "old_text": "strncmp(\"tiledimage\", key, var_size)",
          "new_text": null,
          "old_line_content": "                strncmp(\"tiledimage\", key, var_size))",
          "new_line_content": "                                                     \"string\", 16)) >= 0) {",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": "bytestream_get_le16",
          "new_api": null,
          "old_text": "bytestream_get_le16(&src)",
          "new_text": null,
          "old_line_content": "                            *ptr_x++ = exr_half2float(bytestream_get_le16(&src));;",
          "new_line_content": "                        for (x = 0; x < xsize; x++) {",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            uint32_t pw = bytestream2_get_le32(gb);",
          "new_line_content": "                return AVERROR_PATCHWELCOME;",
          "content_same": false
        },
        {
          "line": 1155,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(ptr_x, 0, axmax)",
          "new_text": null,
          "old_line_content": "                memset(ptr_x, 0, axmax);",
          "new_line_content": "                        }",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            uint32_t ph = bytestream2_get_le32(gb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": null,
          "old_text": "bytestream2_get_bytes_left(gb)",
          "new_text": null,
          "old_line_content": "            if (psize >= bytestream2_get_bytes_left(gb))",
          "new_line_content": "                                                     \"preview\", 16)) >= 0) {",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": "av_assert1",
          "new_api": null,
          "old_text": "av_assert1(s->pixel_type == EXR_UINT)",
          "new_text": null,
          "old_line_content": "        av_assert1(s->pixel_type == EXR_UINT);",
          "new_line_content": "                channel_buffer[c] += td->channel_line_size;",
          "content_same": false
        },
        {
          "line": 1673,
          "old_api": "bytestream2_skip",
          "new_api": null,
          "old_text": "bytestream2_skip(gb, psize)",
          "new_text": null,
          "old_line_content": "            bytestream2_skip(gb, psize);",
          "new_line_content": "            int64_t psize = 4LL * pw * ph;",
          "content_same": false
        },
        {
          "line": 1679,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": null,
          "old_text": "bytestream2_get_bytes_left(gb)",
          "new_text": null,
          "old_line_content": "        if (bytestream2_get_bytes_left(gb) <= 9) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(ptr_x, 0, bxmin)",
          "new_text": null,
          "old_line_content": "            memset(ptr_x, 0, bxmin);",
          "new_line_content": "                a = channel_buffer[3];",
          "content_same": false
        },
        {
          "line": 1692,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": null,
          "old_text": "bytestream2_get_bytes_left(gb)",
          "new_text": null,
          "old_line_content": "            while (bytestream2_get_bytes_left(gb) > 0 &&",
          "new_line_content": "            uint8_t name[256] = { 0 };",
          "content_same": false
        },
        {
          "line": 1693,
          "old_api": "bytestream2_peek_byte",
          "new_api": null,
          "old_text": "bytestream2_peek_byte(gb)",
          "new_text": null,
          "old_line_content": "                   bytestream2_peek_byte(gb) && i < 255) {",
          "new_line_content": "            uint8_t type[256] = { 0 };",
          "content_same": false
        },
        {
          "line": 1694,
          "old_api": "bytestream2_get_byte",
          "new_api": null,
          "old_text": "bytestream2_get_byte(gb)",
          "new_text": null,
          "old_line_content": "                name[i++] = bytestream2_get_byte(gb);",
          "new_line_content": "            uint8_t value[256] = { 0 };",
          "content_same": false
        },
        {
          "line": 1700,
          "old_api": "bytestream2_peek_byte",
          "new_api": null,
          "old_text": "bytestream2_peek_byte(gb)",
          "new_text": null,
          "old_line_content": "                   bytestream2_peek_byte(gb) && i < 255) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": "bytestream_get_le32",
          "new_api": null,
          "old_text": "bytestream_get_le32(&a)",
          "new_text": null,
          "old_line_content": "                    *ptr_x++ = bytestream_get_le32(&a) >> 16;",
          "new_line_content": "                for (c = 0; c < rgb_channel_count; c++) {",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": "bytestream2_get_byte",
          "new_api": null,
          "old_text": "bytestream2_get_byte(gb)",
          "new_text": null,
          "old_line_content": "                type[i++] = bytestream2_get_byte(gb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": "bytestream2_skip",
          "new_api": null,
          "old_text": "bytestream2_skip(gb, 1)",
          "new_text": null,
          "old_line_content": "            bytestream2_skip(gb, 1);",
          "new_line_content": "            i = 0;",
          "content_same": false
        },
        {
          "line": 1193,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(ptr_x, 0, axmax)",
          "new_text": null,
          "old_line_content": "            memset(ptr_x, 0, axmax);",
          "new_line_content": "                if (channel_buffer[3])",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(type, \"string\")",
          "new_text": null,
          "old_line_content": "            if (!strcmp(type, \"string\"))",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1720,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile attribute.\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile attribute.\\n\");",
          "new_line_content": "        goto fail;",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": null,
          "old_text": "bytestream2_get_bytes_left(gb)",
          "new_text": null,
          "old_line_content": "    while (bytestream2_get_bytes_left(gb) > 0) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": "bytestream2_peek_byte",
          "new_api": null,
          "old_text": "bytestream2_peek_byte(gb)",
          "new_text": null,
          "old_line_content": "        if (!bytestream2_peek_byte(gb))",
          "new_line_content": "static void skip_header_chunk(EXRContext *s)",
          "content_same": false
        },
        {
          "line": 1726,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": null,
          "old_text": "bytestream2_get_bytes_left(gb)",
          "new_text": null,
          "old_line_content": "    if (bytestream2_get_bytes_left(gb) <= 0) {",
          "new_line_content": "            ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Incomplete frame.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s->avctx, AV_LOG_ERROR, \"Incomplete frame.\\n\");",
          "new_line_content": "            goto fail;",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "        bytestream2_skip(gb, bytestream2_get_le32(gb));",
          "new_line_content": "        // Process unknown variables",
          "content_same": false
        },
        {
          "line": 1735,
          "old_api": "bytestream2_skip",
          "new_api": null,
          "old_text": "bytestream2_skip(gb, 1)",
          "new_text": null,
          "old_line_content": "    bytestream2_skip(gb, 1);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1738,
          "old_api": "av_dict_free",
          "new_api": null,
          "old_text": "av_dict_free(&metadata)",
          "new_text": null,
          "old_line_content": "    av_dict_free(&metadata);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": null,
          "old_text": "bytestream2_get_bytes_left(gb)",
          "new_text": null,
          "old_line_content": "    if (bytestream2_get_bytes_left(gb) >= minimum_length &&",
          "new_line_content": "                                 unsigned int minimum_length)",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(gb->buffer, value_name)",
          "new_text": null,
          "old_line_content": "        !strcmp(gb->buffer, value_name)) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": "strlen",
          "new_api": null,
          "old_text": "strlen(value_name)",
          "new_text": null,
          "old_line_content": "        gb->buffer += strlen(value_name) + 1;",
          "new_line_content": "    int var_size = -1;",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(gb->buffer, value_type)",
          "new_text": null,
          "old_line_content": "        if (!strcmp(gb->buffer, value_type)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1759,
          "old_api": "bytestream2_init",
          "new_api": null,
          "old_text": "bytestream2_init(gb, avpkt->data, avpkt->size)",
          "new_text": null,
          "old_line_content": "    bytestream2_init(gb, avpkt->data, avpkt->size);",
          "new_line_content": "    int nb_blocks;   /* nb scanline or nb tile */",
          "content_same": false
        },
        {
          "line": 1761,
          "old_api": "decode_header",
          "new_api": null,
          "old_text": "decode_header(s, picture)",
          "new_text": null,
          "old_line_content": "    if ((ret = decode_header(s, picture)) < 0)",
          "new_line_content": "    uint64_t start_next_scanline;",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": "strlen",
          "new_api": null,
          "old_text": "strlen(value_name)",
          "new_text": null,
          "old_line_content": "            gb->buffer -= strlen(value_name) + 1;",
          "new_line_content": "            // don't go read past boundaries",
          "content_same": false
        },
        {
          "line": 1798,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Missing channel list.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Missing channel list.\\n\");",
          "new_line_content": "                avctx->pix_fmt = AV_PIX_FMT_GRAY16;",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": null,
          "old_text": "bytestream2_get_bytes_left(gb)",
          "new_text": null,
          "old_line_content": "    if (bytestream2_get_bytes_left(gb) < 10) {",
          "new_line_content": "    s->is_tile            = 0;",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Header too short to parse.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(s->avctx, AV_LOG_ERROR, \"Header too short to parse.\\n\");",
          "new_line_content": "    s->is_multipart       = 0;",
          "content_same": false
        },
        {
          "line": 1306,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Wrong magic number %d.\\n\", magic_number)",
          "new_text": null,
          "old_line_content": "        av_log(s->avctx, AV_LOG_ERROR, \"Wrong magic number %d.\\n\", magic_number);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": "avpriv_report_missing_feature",
          "new_api": null,
          "old_text": "avpriv_report_missing_feature(avctx, \"Compression %d\", s->compression)",
          "new_text": null,
          "old_line_content": "        avpriv_report_missing_feature(avctx, \"Compression %d\", s->compression);",
          "new_line_content": "    case EXR_B44:",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": "bytestream2_get_byte",
          "new_api": null,
          "old_text": "bytestream2_get_byte(gb)",
          "new_text": null,
          "old_line_content": "    version = bytestream2_get_byte(gb);",
          "new_line_content": "         * int 20000630 little-endian */",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": "avpriv_report_missing_feature",
          "new_api": null,
          "old_text": "avpriv_report_missing_feature(s->avctx, \"Version %d\", version)",
          "new_text": null,
          "old_line_content": "        avpriv_report_missing_feature(s->avctx, \"Version %d\", version);",
          "new_line_content": "        return AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": "bytestream2_get_le24",
          "new_api": null,
          "old_text": "bytestream2_get_le24(gb)",
          "new_text": null,
          "old_line_content": "    flags = bytestream2_get_le24(gb);",
          "new_line_content": "    if (version != 2) {",
          "content_same": false
        },
        {
          "line": 1829,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Wrong or missing size information.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Wrong or missing size information.\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": "ff_set_dimensions",
          "new_api": null,
          "old_text": "ff_set_dimensions(avctx, s->w, s->h)",
          "new_text": null,
          "old_line_content": "    if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0)",
          "new_line_content": "        s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) {",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": "avpriv_report_missing_feature",
          "new_api": null,
          "old_text": "avpriv_report_missing_feature(s->avctx, \"deep data\")",
          "new_text": null,
          "old_line_content": "        avpriv_report_missing_feature(s->avctx, \"deep data\");",
          "new_line_content": "    if (flags & 0x02)",
          "content_same": false
        },
        {
          "line": 1836,
          "old_api": "av_int2float",
          "new_api": null,
          "old_text": "av_int2float(s->sar)",
          "new_text": null,
          "old_line_content": "    ff_set_sar(s->avctx, av_d2q(av_int2float(s->sar), 255));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1332,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": null,
          "old_text": "bytestream2_get_bytes_left(gb)",
          "new_text": null,
          "old_line_content": "               bytestream2_get_bytes_left(gb) > 0) {",
          "new_line_content": "    // Parse the header",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": "skip_header_chunk",
          "new_api": null,
          "old_text": "skip_header_chunk(s)",
          "new_text": null,
          "old_line_content": "                skip_header_chunk(s);",
          "new_line_content": "        int var_size;",
          "content_same": false
        },
        {
          "line": 1336,
          "old_api": "bytestream2_skip",
          "new_api": null,
          "old_text": "bytestream2_skip(gb, 1)",
          "new_text": null,
          "old_line_content": "                bytestream2_skip(gb, 1);",
          "new_line_content": "        while (s->is_multipart && s->current_part < s->selected_part &&",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": "bytestream2_skip",
          "new_api": null,
          "old_text": "bytestream2_skip(gb, 1)",
          "new_text": null,
          "old_line_content": "            bytestream2_skip(gb, 1);",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": "bytestream2_peek_byte",
          "new_api": null,
          "old_text": "bytestream2_peek_byte(gb)",
          "new_text": null,
          "old_line_content": "        if (!bytestream2_peek_byte(gb)) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": "ff_thread_get_buffer",
          "new_api": null,
          "old_text": "ff_thread_get_buffer(avctx, &frame, 0)",
          "new_text": null,
          "old_line_content": "    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)",
          "new_line_content": "    } else { /* scanline */",
          "content_same": false
        },
        {
          "line": 1347,
          "old_api": "bytestream2_skip",
          "new_api": null,
          "old_text": "bytestream2_skip(gb, 1)",
          "new_text": null,
          "old_line_content": "            bytestream2_skip(gb, 1);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1861,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": null,
          "old_text": "bytestream2_get_bytes_left(gb)",
          "new_text": null,
          "old_line_content": "    if (bytestream2_get_bytes_left(gb)/8 < nb_blocks)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1350,
          "old_api": "bytestream2_peek_byte",
          "new_api": null,
          "old_text": "bytestream2_peek_byte(gb)",
          "new_text": null,
          "old_line_content": "                    if (bytestream2_peek_byte(gb)) {",
          "new_line_content": "            if (!s->is_multipart)",
          "content_same": false
        },
        {
          "line": 1351,
          "old_api": "skip_header_chunk",
          "new_api": null,
          "old_text": "skip_header_chunk(s)",
          "new_text": null,
          "old_line_content": "                        skip_header_chunk(s);",
          "new_line_content": "                break;",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": "bytestream2_skip",
          "new_api": null,
          "old_text": "bytestream2_skip(gb, 1)",
          "new_text": null,
          "old_line_content": "                        bytestream2_skip(gb, 1);",
          "new_line_content": "            if (s->current_part == s->selected_part) {",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": "bytestream2_peek_le64",
          "new_api": null,
          "old_text": "bytestream2_peek_le64(gb)",
          "new_text": null,
          "old_line_content": "    if (!s->is_tile && bytestream2_peek_le64(gb) == 0) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1868,
          "old_api": "bytestream2_tell",
          "new_api": null,
          "old_text": "bytestream2_tell(gb)",
          "new_text": null,
          "old_line_content": "        start_offset_table = bytestream2_tell(gb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": "bytestream2_put_le64",
          "new_api": null,
          "old_text": "bytestream2_put_le64(&offset_table_writer, start_next_scanline)",
          "new_text": null,
          "old_line_content": "            bytestream2_put_le64(&offset_table_writer, start_next_scanline);",
          "new_line_content": "        start_next_scanline = start_offset_table + nb_blocks * 8;",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": "bytestream2_seek",
          "new_api": null,
          "old_text": "bytestream2_seek(gb, start_next_scanline + 4, SEEK_SET)",
          "new_text": null,
          "old_line_content": "            bytestream2_seek(gb, start_next_scanline + 4, SEEK_SET);/* skip line number */",
          "new_line_content": "        for (y = 0; y < nb_blocks; y++) {",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            start_next_scanline += (bytestream2_get_le32(gb) + 8);",
          "new_line_content": "            /* write offset of prev scanline in offset table */",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": "bytestream2_seek",
          "new_api": null,
          "old_text": "bytestream2_seek(gb, start_offset_table, SEEK_SET)",
          "new_text": null,
          "old_line_content": "        bytestream2_seek(gb, start_offset_table, SEEK_SET);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1372,
          "old_api": "bytestream2_init",
          "new_api": null,
          "old_text": "bytestream2_init(&ch_gb, gb->buffer, var_size)",
          "new_text": null,
          "old_line_content": "            bytestream2_init(&ch_gb, gb->buffer, var_size);",
          "new_line_content": "            if (!var_size) {",
          "content_same": false
        },
        {
          "line": 1374,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": null,
          "old_text": "bytestream2_get_bytes_left(&ch_gb)",
          "new_text": null,
          "old_line_content": "            while (bytestream2_get_bytes_left(&ch_gb) >= 19) {",
          "new_line_content": "                goto fail;",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(s->ymin, s->h)",
          "new_text": null,
          "old_line_content": "        for (y = 0; y < FFMIN(s->ymin, s->h); y++) {",
          "new_line_content": "    s->buf_size = avpkt->size;",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(ptr, 0, out_line_size)",
          "new_text": null,
          "old_line_content": "            memset(ptr, 0, out_line_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(s->layer, \"\")",
          "new_text": null,
          "old_line_content": "                if (strcmp(s->layer, \"\") != 0) {",
          "new_line_content": "                EXRChannel *channel;",
          "content_same": false
        },
        {
          "line": 1381,
          "old_api": "strlen",
          "new_api": null,
          "old_text": "strlen(s->layer)",
          "new_text": null,
          "old_line_content": "                    if (strncmp(ch_gb.buffer, s->layer, strlen(s->layer)) == 0) {",
          "new_line_content": "                enum ExrPixelType current_pixel_type;",
          "content_same": false
        },
        {
          "line": 1383,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_INFO,\n                               \"Channel match layer : %s.\\n\", ch_gb.buffer)",
          "new_text": null,
          "old_line_content": "                        av_log(s->avctx, AV_LOG_INFO,",
          "new_line_content": "                int xsub, ysub;",
          "content_same": false
        },
        {
          "line": 1898,
          "old_api": "execute2",
          "new_api": null,
          "old_text": "avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks)",
          "new_text": null,
          "old_line_content": "    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1900,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(0, s->ymax + 1)",
          "new_text": null,
          "old_line_content": "    ymax = FFMAX(0, s->ymax + 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(ptr, 0, out_line_size)",
          "new_text": null,
          "old_line_content": "                memset(ptr, 0, out_line_size);",
          "new_line_content": "    // Zero out the end if ymax+1 is not h",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": "av_strcasecmp",
          "new_api": null,
          "old_text": "av_strcasecmp(ch_gb.buffer, \"R\")",
          "new_text": null,
          "old_line_content": "                    if (!av_strcasecmp(ch_gb.buffer, \"R\") ||",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": "av_strcasecmp",
          "new_api": null,
          "old_text": "av_strcasecmp(ch_gb.buffer, \"X\")",
          "new_text": null,
          "old_line_content": "                        !av_strcasecmp(ch_gb.buffer, \"X\") ||",
          "new_line_content": "                    layer_match = 1;",
          "content_same": false
        },
        {
          "line": 1400,
          "old_api": "av_strcasecmp",
          "new_api": null,
          "old_text": "av_strcasecmp(ch_gb.buffer, \"U\")",
          "new_text": null,
          "old_line_content": "                        !av_strcasecmp(ch_gb.buffer, \"U\")) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1407,
          "old_api": "av_strcasecmp",
          "new_api": null,
          "old_text": "av_strcasecmp(ch_gb.buffer, \"Y\")",
          "new_text": null,
          "old_line_content": "                    } else if (!av_strcasecmp(ch_gb.buffer, \"Y\")) {",
          "new_line_content": "                        s->is_luma = 0;",
          "content_same": false
        },
        {
          "line": 1410,
          "old_api": "av_strcasecmp",
          "new_api": null,
          "old_text": "av_strcasecmp(ch_gb.buffer, \"B\")",
          "new_text": null,
          "old_line_content": "                    } else if (!av_strcasecmp(ch_gb.buffer, \"B\") ||",
          "new_line_content": "                        channel_index = 1;",
          "content_same": false
        },
        {
          "line": 1411,
          "old_api": "av_strcasecmp",
          "new_api": null,
          "old_text": "av_strcasecmp(ch_gb.buffer, \"Z\")",
          "new_text": null,
          "old_line_content": "                               !av_strcasecmp(ch_gb.buffer, \"Z\") ||",
          "new_line_content": "                        s->is_luma = 0;",
          "content_same": false
        },
        {
          "line": 1927,
          "old_api": "ff_exrdsp_init",
          "new_api": null,
          "old_text": "ff_exrdsp_init(&s->dsp)",
          "new_text": null,
          "old_line_content": "    ff_exrdsp_init(&s->dsp);",
          "new_line_content": "    float one_gamma = 1.0f / s->gamma;",
          "content_same": false
        },
        {
          "line": 1418,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_WARNING,\n                               \"Unsupported channel %.256s.\\n\", ch_gb.buffer)",
          "new_text": null,
          "old_line_content": "                        av_log(s->avctx, AV_LOG_WARNING,",
          "new_line_content": "                        channel_index = 2;",
          "content_same": false
        },
        {
          "line": 1930,
          "old_api": "ff_bswapdsp_init",
          "new_api": null,
          "old_text": "ff_bswapdsp_init(&s->bbdsp)",
          "new_text": null,
          "old_line_content": "    ff_bswapdsp_init(&s->bbdsp);",
          "new_line_content": "    s->avctx              = avctx;",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": "avpriv_get_trc_function_from_trc",
          "new_api": null,
          "old_text": "avpriv_get_trc_function_from_trc(s->apply_trc_type)",
          "new_text": null,
          "old_line_content": "    trc_func = avpriv_get_trc_function_from_trc(s->apply_trc_type);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1424,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": null,
          "old_text": "bytestream2_get_bytes_left(&ch_gb)",
          "new_text": null,
          "old_line_content": "                while (bytestream2_get_bytes_left(&ch_gb) > 0 &&",
          "new_line_content": "                               \"Unsupported channel %.256s.\\n\", ch_gb.buffer);",
          "content_same": false
        },
        {
          "line": 1425,
          "old_api": "bytestream2_get_byte",
          "new_api": null,
          "old_text": "bytestream2_get_byte(&ch_gb)",
          "new_text": null,
          "old_line_content": "                       bytestream2_get_byte(&ch_gb))",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 1936,
          "old_api": "exr_half2float",
          "new_api": null,
          "old_text": "exr_half2float(i)",
          "new_text": null,
          "old_line_content": "            t = exr_half2float(i);",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 1937,
          "old_api": "trc_func",
          "new_api": null,
          "old_text": "trc_func(t.f)",
          "new_text": null,
          "old_line_content": "            t.f = trc_func(t.f);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": "bytestream2_get_bytes_left",
          "new_api": null,
          "old_text": "bytestream2_get_bytes_left(&ch_gb)",
          "new_text": null,
          "old_line_content": "                if (bytestream2_get_bytes_left(&ch_gb) < 4) {",
          "new_line_content": "                /* skip until you get a 0 */",
          "content_same": false
        },
        {
          "line": 1943,
          "old_api": "exr_half2float",
          "new_api": null,
          "old_text": "exr_half2float(i)",
          "new_text": null,
          "old_line_content": "                s->gamma_table[i] = exr_half2float(i);",
          "new_line_content": "            s->gamma_table[i] = t;",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": "exr_half2float",
          "new_api": null,
          "old_text": "exr_half2float(i)",
          "new_text": null,
          "old_line_content": "                t = exr_half2float(i);",
          "new_line_content": "            for (i = 0; i < 65536; ++i) {",
          "content_same": false
        },
        {
          "line": 1436,
          "old_api": "avpriv_report_missing_feature",
          "new_api": null,
          "old_text": "avpriv_report_missing_feature(s->avctx, \"Pixel type %d\",\n                                                  current_pixel_type)",
          "new_text": null,
          "old_line_content": "                    avpriv_report_missing_feature(s->avctx, \"Pixel type %d\",",
          "new_line_content": "                    goto fail;",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": "bytestream2_skip",
          "new_api": null,
          "old_text": "bytestream2_skip(&ch_gb, 4)",
          "new_text": null,
          "old_line_content": "                bytestream2_skip(&ch_gb, 4);",
          "new_line_content": "                                                  current_pixel_type);",
          "content_same": false
        },
        {
          "line": 1443,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(&ch_gb)",
          "new_text": null,
          "old_line_content": "                xsub = bytestream2_get_le32(&ch_gb);",
          "new_line_content": "                    ret = AVERROR_PATCHWELCOME;",
          "content_same": false
        },
        {
          "line": 1444,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(&ch_gb)",
          "new_text": null,
          "old_line_content": "                ysub = bytestream2_get_le32(&ch_gb);",
          "new_line_content": "                    goto fail;",
          "content_same": false
        },
        {
          "line": 1960,
          "old_api": "av_mallocz_array",
          "new_api": null,
          "old_text": "av_mallocz_array(avctx->thread_count, sizeof(EXRThreadData))",
          "new_text": null,
          "old_line_content": "    s->thread_data = av_mallocz_array(avctx->thread_count, sizeof(EXRThreadData));",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1457,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR,\n                               \"RGB channels not of the same depth.\\n\")",
          "new_text": null,
          "old_line_content": "                        av_log(s->avctx, AV_LOG_ERROR,",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1973,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&td->uncompressed_data)",
          "new_text": null,
          "old_line_content": "        av_freep(&td->uncompressed_data);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1974,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&td->tmp)",
          "new_text": null,
          "old_line_content": "        av_freep(&td->tmp);",
          "new_line_content": "    EXRContext *s = avctx->priv_data;",
          "content_same": false
        },
        {
          "line": 1975,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&td->bitmap)",
          "new_text": null,
          "old_line_content": "        av_freep(&td->bitmap);",
          "new_line_content": "    int i;",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&td->lut)",
          "new_text": null,
          "old_line_content": "        av_freep(&td->lut);",
          "new_line_content": "    for (i = 0; i < avctx->thread_count; i++) {",
          "content_same": false
        },
        {
          "line": 1465,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_WARNING,\n                            \"Multiple channels with index %d.\\n\", channel_index)",
          "new_text": null,
          "old_line_content": "                    av_log(s->avctx, AV_LOG_WARNING,",
          "new_line_content": "                        goto fail;",
          "content_same": false
        },
        {
          "line": 1977,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&td->he)",
          "new_text": null,
          "old_line_content": "        av_freep(&td->he);",
          "new_line_content": "        EXRThreadData *td = &s->thread_data[i];",
          "content_same": false
        },
        {
          "line": 1473,
          "old_api": "av_realloc",
          "new_api": null,
          "old_text": "av_realloc(s->channels,\n                                         ++s->nb_channels * sizeof(EXRChannel))",
          "new_text": null,
          "old_line_content": "                s->channels = av_realloc(s->channels,",
          "new_line_content": "                        ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 1476,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "                    ret = AVERROR(ENOMEM);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1991,
          "old_api": "OFFSET",
          "new_api": null,
          "old_text": "OFFSET(layer)",
          "new_text": null,
          "old_line_content": "    { \"layer\", \"Set the decoding layer\", OFFSET(layer),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1993,
          "old_api": "OFFSET",
          "new_api": null,
          "old_text": "OFFSET(selected_part)",
          "new_text": null,
          "old_line_content": "    { \"part\",  \"Set the decoding part\", OFFSET(selected_part),",
          "new_line_content": "#define OFFSET(x) offsetof(EXRContext, x)",
          "content_same": false
        },
        {
          "line": 1995,
          "old_api": "OFFSET",
          "new_api": null,
          "old_text": "OFFSET(gamma)",
          "new_text": null,
          "old_line_content": "    { \"gamma\", \"Set the float gamma value when decoding\", OFFSET(gamma),",
          "new_line_content": "static const AVOption options[] = {",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": "OFFSET",
          "new_api": null,
          "old_text": "OFFSET(apply_trc_type)",
          "new_text": null,
          "old_line_content": "    { \"apply_trc\", \"color transfer characteristics to apply to EXR linear input\", OFFSET(apply_trc_type),",
          "new_line_content": "        AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, VD },",
          "content_same": false
        },
        {
          "line": 1494,
          "old_api": "FFMIN3",
          "new_api": null,
          "old_text": "FFMIN3(s->channel_offsets[0],\n                           s->channel_offsets[1],\n                           s->channel_offsets[2])",
          "new_text": null,
          "old_line_content": "                if (FFMIN3(s->channel_offsets[0],",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1498,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Missing red channel.\\n\")",
          "new_text": null,
          "old_line_content": "                        av_log(s->avctx, AV_LOG_ERROR, \"Missing red channel.\\n\");",
          "new_line_content": "            if (!s->is_luma) {/* if we expected to have at least 3 channels */",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Missing green channel.\\n\")",
          "new_text": null,
          "old_line_content": "                        av_log(s->avctx, AV_LOG_ERROR, \"Missing green channel.\\n\");",
          "new_line_content": "                           s->channel_offsets[1],",
          "content_same": false
        },
        {
          "line": 1502,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Missing blue channel.\\n\")",
          "new_text": null,
          "old_line_content": "                        av_log(s->avctx, AV_LOG_ERROR, \"Missing blue channel.\\n\");",
          "new_line_content": "                    if (s->channel_offsets[0] < 0)",
          "content_same": false
        },
        {
          "line": 1511,
          "old_api": "check_header_variable",
          "new_api": null,
          "old_text": "check_header_variable(s, \"dataWindow\", \"box2i\",\n                                                     31)",
          "new_text": null,
          "old_line_content": "        } else if ((var_size = check_header_variable(s, \"dataWindow\", \"box2i\",",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            xmin   = bytestream2_get_le32(gb);",
          "new_line_content": "            if (!var_size) {",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            ymin   = bytestream2_get_le32(gb);",
          "new_line_content": "                ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 1521,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            xmax   = bytestream2_get_le32(gb);",
          "new_line_content": "                goto fail;",
          "content_same": false
        },
        {
          "line": 1522,
          "old_api": "bytestream2_get_le32",
          "new_api": null,
          "old_text": "bytestream2_get_le32(gb)",
          "new_text": null,
          "old_line_content": "            ymax   = bytestream2_get_le32(gb);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"OpenEXR image\")",
          "new_text": null,
          "old_line_content": "    .long_name        = NULL_IF_CONFIG_SMALL(\"OpenEXR image\"),",
          "new_line_content": "    .version    = LIBAVUTIL_VERSION_INT,",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 35,
      "total_additions": 149,
      "total_deletions": 148,
      "total_api_changes": 332
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 332,
        "non_api_lines": 5,
        "non_api_line_numbers": [
          1133,
          1140,
          1141,
          1143,
          1144
        ]
      }
    },
    "api_calls_before": 321,
    "api_calls_after": 322,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 1,
      "total_diff_lines": 25
    }
  }
}