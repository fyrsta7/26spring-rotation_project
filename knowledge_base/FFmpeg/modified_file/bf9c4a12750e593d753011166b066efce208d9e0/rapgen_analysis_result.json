{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/bf9c4a12750e593d753011166b066efce208d9e0",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/bf9c4a12750e593d753011166b066efce208d9e0/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/bf9c4a12750e593d753011166b066efce208d9e0/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/bf9c4a12750e593d753011166b066efce208d9e0/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 461,
          "old_api": "get_bits",
          "new_api": "init_get_bits",
          "old_text": "get_bits(&gb, VQ_1ST_BITS)",
          "new_text": "init_get_bits(&gb, buf, 8*buf_size)",
          "old_line_content": "        quantizer_1st    = get_bits(&gb, VQ_1ST_BITS);",
          "new_line_content": "        init_get_bits(&gb, buf, 8*buf_size);",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "lsf_restore_from_previous",
          "new_api": "get_bits",
          "old_text": "lsf_restore_from_previous(ctx->lsfq, ctx->past_quantizer_outputs,\n                                      ctx->ma_predictor_prev)",
          "new_text": "get_bits(&gb, VQ_2ND_BITS)",
          "old_line_content": "            lsf_restore_from_previous(ctx->lsfq, ctx->past_quantizer_outputs,",
          "new_line_content": "        quantizer_2nd_hi = get_bits(&gb, VQ_2ND_BITS);",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "lsf_decode",
          "new_api": "lsf_restore_from_previous",
          "old_text": "lsf_decode(ctx->lsfq, ctx->past_quantizer_outputs,\n                       ma_predictor,\n                       quantizer_1st, quantizer_2nd_lo, quantizer_2nd_hi)",
          "new_text": "lsf_restore_from_previous(ctx->lsfq, ctx->past_quantizer_outputs,\n                                      ctx->ma_predictor_prev)",
          "old_line_content": "            lsf_decode(ctx->lsfq, ctx->past_quantizer_outputs,",
          "new_line_content": "            lsf_restore_from_previous(ctx->lsfq, ctx->past_quantizer_outputs,",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "get_bits",
          "new_api": "get_bits1",
          "old_text": "get_bits(&gb, format->gc_1st_index_bits)",
          "new_text": "get_bits1(&gb)",
          "old_line_content": "            gc_1st_index  = get_bits(&gb, format->gc_1st_index_bits);",
          "new_line_content": "                bad_pitch = av_parity(ac_index >> 2) == get_bits1(&gb);",
          "content_same": false
        },
        {
          "line": 512,
          "old_api": "av_clip",
          "new_api": "ff_acelp_decode_8bit_to_1st_delay3",
          "old_text": "av_clip(ctx->pitch_delay_int_prev - 5,\n                                              PITCH_DELAY_MIN, PITCH_DELAY_MAX - 9)",
          "new_text": "ff_acelp_decode_8bit_to_1st_delay3(ac_index)",
          "old_line_content": "                int pitch_delay_min = av_clip(ctx->pitch_delay_int_prev - 5,",
          "new_line_content": "                    pitch_delay_3x = ff_acelp_decode_8bit_to_1st_delay3(ac_index);",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": "ff_acelp_fc_pulse_per_track",
          "new_api": "memset",
          "old_text": "ff_acelp_fc_pulse_per_track(fc, ff_fc_4pulses_8bits_tracks_13,\n                                                ff_fc_4pulses_8bits_track_4,\n                                                fc_indexes, pulses_signs, 3, 3)",
          "new_text": "memset(fc, 0, sizeof(int16_t) * SUBFRAME_SIZE)",
          "old_line_content": "                    ff_acelp_fc_pulse_per_track(fc, ff_fc_4pulses_8bits_tracks_13,",
          "new_line_content": "            memset(fc, 0, sizeof(int16_t) * SUBFRAME_SIZE);",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "av_clip",
          "new_api": "ff_acelp_weighted_vector_sum",
          "old_text": "av_clip(ctx->past_gain_pitch[0], SHARP_MIN, SHARP_MAX)",
          "new_text": "ff_acelp_weighted_vector_sum(fc + pitch_delay_int[i],\n                                             fc + pitch_delay_int[i],\n                                             fc, 1 << 14,\n                                             av_clip(ctx->past_gain_pitch[0], SHARP_MIN, SHARP_MAX),\n                                             0, 14,\n                                             SUBFRAME_SIZE - pitch_delay_int[i])",
          "old_line_content": "                                             av_clip(ctx->past_gain_pitch[0], SHARP_MIN, SHARP_MAX),",
          "new_line_content": "                ff_acelp_weighted_vector_sum(fc + pitch_delay_int[i],",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "ff_acelp_interpolate",
          "new_api": "ff_acelp_update_past_gain",
          "old_text": "ff_acelp_interpolate(ctx->exc + i * SUBFRAME_SIZE,\n                                 ctx->exc + i * SUBFRAME_SIZE - pitch_delay_3x / 3,\n                                 ff_acelp_interp_filter, 6,\n                                 (pitch_delay_3x % 3) << 1,\n                                 10, SUBFRAME_SIZE)",
          "new_text": "ff_acelp_update_past_gain(ctx->quant_energy, gain_corr_factor, 2, frame_erasure)",
          "old_line_content": "            ff_acelp_interpolate(ctx->exc + i * SUBFRAME_SIZE,",
          "new_line_content": "            ff_acelp_update_past_gain(ctx->quant_energy, gain_corr_factor, 2, frame_erasure);",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": "g729d_get_new_exc",
          "new_api": "g729d_onset_decision",
          "old_text": "g729d_get_new_exc(exc_new, ctx->exc  + i * SUBFRAME_SIZE, fc, ctx->voice_decision, ctx->past_gain_code[0], SUBFRAME_SIZE)",
          "new_text": "g729d_onset_decision(ctx->onset, ctx->past_gain_code)",
          "old_line_content": "                g729d_get_new_exc(exc_new, ctx->exc  + i * SUBFRAME_SIZE, fc, ctx->voice_decision, ctx->past_gain_code[0], SUBFRAME_SIZE);",
          "new_line_content": "                ctx->onset = g729d_onset_decision(ctx->onset, ctx->past_gain_code);",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "ff_g729_postfilter",
          "new_api": "FFABS",
          "old_text": "ff_g729_postfilter(\n                    &s->adsp,\n                    &ctx->ht_prev_data,\n                    &is_periodic,\n                    &lp[i][0],\n                    pitch_delay_int[0],\n                    ctx->residual,\n                    ctx->res_filter_data,\n                    ctx->pos_filter_data,\n                    synth+10,\n                    SUBFRAME_SIZE)",
          "new_text": "FFABS(synth[j+10])",
          "old_line_content": "            ff_g729_postfilter(",
          "new_line_content": "                gain_before += FFABS(synth[j+10]);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 515,
          "old_api": null,
          "new_api": "av_clip",
          "old_text": null,
          "new_text": "av_clip(ctx->pitch_delay_int_prev - 5,\n                                              PITCH_DELAY_MIN, PITCH_DELAY_MAX - 9)",
          "old_line_content": "                if (packet_type == FORMAT_G729D_6K4) {",
          "new_line_content": "                int pitch_delay_min = av_clip(ctx->pitch_delay_int_prev - 5,",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": null,
          "new_api": "ff_acelp_decode_4bit_to_2nd_delay3",
          "old_text": null,
          "new_text": "ff_acelp_decode_4bit_to_2nd_delay3(ac_index, pitch_delay_min)",
          "old_line_content": "                }",
          "new_line_content": "                    pitch_delay_3x = ff_acelp_decode_4bit_to_2nd_delay3(ac_index, pitch_delay_min);",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": null,
          "new_api": "ff_audiodsp_init",
          "old_text": null,
          "new_text": "ff_audiodsp_init(&s->adsp)",
          "old_line_content": "    return 0;",
          "new_line_content": "    ff_audiodsp_init(&s->adsp);",
          "content_same": false
        },
        {
          "line": 521,
          "old_api": null,
          "new_api": "ff_acelp_decode_5_6_bit_to_2nd_delay3",
          "old_text": null,
          "new_text": "ff_acelp_decode_5_6_bit_to_2nd_delay3(ac_index, pitch_delay_min)",
          "old_line_content": "",
          "new_line_content": "                    pitch_delay_3x = ff_acelp_decode_5_6_bit_to_2nd_delay3(ac_index, pitch_delay_min);",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_WARNING, \"pitch_delay_int %d is too large\\n\", pitch_delay_int[i])",
          "old_line_content": "",
          "new_line_content": "                av_log(avctx, AV_LOG_WARNING, \"pitch_delay_int %d is too large\\n\", pitch_delay_int[i]);",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": null,
          "new_api": "g729d_voice_decision",
          "old_text": null,
          "new_text": "g729d_voice_decision(ctx->onset, ctx->voice_decision, ctx->past_gain_pitch)",
          "old_line_content": "",
          "new_line_content": "                ctx->voice_decision = g729d_voice_decision(ctx->onset, ctx->voice_decision, ctx->past_gain_pitch);",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": null,
          "new_api": "g729d_get_new_exc",
          "old_text": null,
          "new_text": "g729d_get_new_exc(exc_new, ctx->exc  + i * SUBFRAME_SIZE, fc, ctx->voice_decision, ctx->past_gain_code[0], SUBFRAME_SIZE)",
          "old_line_content": "                        synth+10,",
          "new_line_content": "                g729d_get_new_exc(exc_new, ctx->exc  + i * SUBFRAME_SIZE, fc, ctx->voice_decision, ctx->past_gain_code[0], SUBFRAME_SIZE);",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": null,
          "new_api": "ff_celp_lp_synthesis_filter",
          "old_text": null,
          "new_text": "ff_celp_lp_synthesis_filter(\n                        synth+10,\n                        &lp[i][1],\n                        exc_new,\n                        SUBFRAME_SIZE,\n                        10,\n                        0,\n                        0,\n                        0x800)",
          "old_line_content": "                        exc_new,",
          "new_line_content": "                ff_celp_lp_synthesis_filter(",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": null,
          "new_api": "av_mod_uintp2",
          "old_text": null,
          "new_text": "av_mod_uintp2(ctx->rand_value, format->fc_indexes_bits)",
          "old_line_content": "                pulses_signs = ctx->rand_value;",
          "new_line_content": "                fc_indexes   = av_mod_uintp2(ctx->rand_value, format->fc_indexes_bits);",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": null,
          "new_api": "g729_prng",
          "old_text": null,
          "new_text": "g729_prng(ctx->rand_value)",
          "old_line_content": "",
          "new_line_content": "                ctx->rand_value = g729_prng(ctx->rand_value);",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": null,
          "new_api": "ff_celp_lp_synthesis_filter",
          "old_text": null,
          "new_text": "ff_celp_lp_synthesis_filter(\n                        synth+10,\n                        &lp[i][1],\n                        ctx->exc  + i * SUBFRAME_SIZE,\n                        SUBFRAME_SIZE,\n                        10,\n                        0,\n                        0,\n                        0x800)",
          "old_line_content": "                        ctx->exc  + i * SUBFRAME_SIZE,",
          "new_line_content": "                ff_celp_lp_synthesis_filter(",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": null,
          "new_api": "ff_acelp_fc_pulse_per_track",
          "old_text": null,
          "new_text": "ff_acelp_fc_pulse_per_track(fc, ff_fc_4pulses_8bits_tracks_13,\n                                                ff_fc_4pulses_8bits_track_4,\n                                                fc_indexes, pulses_signs, 3, 3)",
          "old_line_content": "                    break;",
          "new_line_content": "                    ff_acelp_fc_pulse_per_track(fc, ff_fc_4pulses_8bits_tracks_13,",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": null,
          "new_api": "ff_acelp_fc_pulse_per_track",
          "old_text": null,
          "new_text": "ff_acelp_fc_pulse_per_track(fc, ff_fc_2pulses_9bits_track1_gray,\n                                                ff_fc_2pulses_9bits_track2_gray,\n                                                fc_indexes, pulses_signs, 1, 4)",
          "old_line_content": "                    break;",
          "new_line_content": "                    ff_acelp_fc_pulse_per_track(fc, ff_fc_2pulses_9bits_track1_gray,",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(ctx->syn_filter_data, synth+SUBFRAME_SIZE, 10 * sizeof(int16_t))",
          "old_line_content": "            gain_before = 0;",
          "new_line_content": "            memcpy(ctx->syn_filter_data, synth+SUBFRAME_SIZE, 10 * sizeof(int16_t));",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": null,
          "new_api": "ff_get_buffer",
          "old_text": null,
          "new_text": "ff_get_buffer(avctx, frame, 0)",
          "old_line_content": "    if (buf_size % ((G729_8K_BLOCK_SIZE + (avctx->codec_id == AV_CODEC_ID_ACELP_KELVIN)) * avctx->channels) == 0) {",
          "new_line_content": "    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": null,
          "new_api": "ff_g729_postfilter",
          "old_text": null,
          "new_text": "ff_g729_postfilter(\n                    &s->adsp,\n                    &ctx->ht_prev_data,\n                    &is_periodic,\n                    &lp[i][0],\n                    pitch_delay_int[0],\n                    ctx->residual,\n                    ctx->res_filter_data,\n                    ctx->pos_filter_data,\n                    synth+10,\n                    SUBFRAME_SIZE)",
          "old_line_content": "                    &is_periodic,",
          "new_line_content": "            ff_g729_postfilter(",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Packet type: %s\\n\", \"G.729 @ 8kbit/s\")",
          "old_line_content": "        format = &format_g729d_6k4;",
          "new_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Packet type: %s\\n\", \"G.729 @ 8kbit/s\");",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": null,
          "new_api": "av_clip",
          "old_text": null,
          "new_text": "av_clip(ctx->past_gain_pitch[0], SHARP_MIN, SHARP_MAX)",
          "old_line_content": "",
          "new_line_content": "                                             av_clip(ctx->past_gain_pitch[0], SHARP_MIN, SHARP_MAX),",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_DEBUG, \"Packet type: %s\\n\", \"G.729D @ 6.4kbit/s\")",
          "old_line_content": "        return AVERROR_INVALIDDATA;",
          "new_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Packet type: %s\\n\", \"G.729D @ 6.4kbit/s\");",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Packet size %d is unknown.\\n\", buf_size)",
          "old_line_content": "",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Packet size %d is unknown.\\n\", buf_size);",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": null,
          "new_api": "memmove",
          "old_text": null,
          "new_text": "memmove(ctx->past_gain_pitch+1, ctx->past_gain_pitch, 5 * sizeof(int16_t))",
          "old_line_content": "            if (frame_erasure) {",
          "new_line_content": "            memmove(ctx->past_gain_pitch+1, ctx->past_gain_pitch, 5 * sizeof(int16_t));",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": null,
          "new_api": "FFABS",
          "old_text": null,
          "new_text": "FFABS(synth[j+10])",
          "old_line_content": "                    gain_before,",
          "new_line_content": "                gain_after += FFABS(synth[j+10]);",
          "content_same": false
        },
        {
          "line": 707,
          "old_api": null,
          "new_api": "ff_g729_adaptive_gain_control",
          "old_text": null,
          "new_text": "ff_g729_adaptive_gain_control(\n                    gain_before,\n                    gain_after,\n                    synth+10,\n                    SUBFRAME_SIZE,\n                    ctx->gain_coeff)",
          "old_line_content": "                    synth+10,",
          "new_line_content": "            ctx->gain_coeff = ff_g729_adaptive_gain_control(",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": null,
          "new_api": "avpriv_request_sample",
          "old_text": null,
          "new_text": "avpriv_request_sample(avctx, \"First byte value %x for channel %d\", *buf, c)",
          "old_line_content": "",
          "new_line_content": "                avpriv_request_sample(avctx, \"First byte value %x for channel %d\", *buf, c);",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(ctx->pitch_delay_int_prev + 1, PITCH_DELAY_MAX)",
          "old_line_content": "            }",
          "new_line_content": "                ctx->pitch_delay_int_prev = FFMIN(ctx->pitch_delay_int_prev + 1, PITCH_DELAY_MAX);",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(gain_corr_factor, 1024)",
          "old_line_content": "    #endif",
          "new_line_content": "                    gain_corr_factor = FFMAX(gain_corr_factor, 1024);",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(&gb, VQ_1ST_BITS)",
          "old_line_content": "",
          "new_line_content": "        quantizer_1st    = get_bits(&gb, VQ_1ST_BITS);",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(&gb, VQ_2ND_BITS)",
          "old_line_content": "        if (frame_erasure) {",
          "new_line_content": "        quantizer_2nd_lo = get_bits(&gb, VQ_2ND_BITS);",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(synth+8, ctx->hpf_z, 2*sizeof(int16_t))",
          "old_line_content": "                    ctx->hpf_f,",
          "new_line_content": "            memcpy(synth+8, ctx->hpf_z, 2*sizeof(int16_t));",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "ff_acelp_high_pass_filter",
          "old_text": null,
          "new_text": "ff_acelp_high_pass_filter(\n                    out_frame + i*SUBFRAME_SIZE,\n                    ctx->hpf_f,\n                    synth+10,\n                    SUBFRAME_SIZE)",
          "old_line_content": "                    synth+10,",
          "new_line_content": "            ff_acelp_high_pass_filter(",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(ctx->hpf_z, synth+8+SUBFRAME_SIZE, 2*sizeof(int16_t))",
          "old_line_content": "        ctx->was_periodic = is_periodic;",
          "new_line_content": "            memcpy(ctx->hpf_z, synth+8+SUBFRAME_SIZE, 2*sizeof(int16_t));",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": null,
          "new_api": "lsf_decode",
          "old_text": null,
          "new_text": "lsf_decode(ctx->lsfq, ctx->past_quantizer_outputs,\n                       ma_predictor,\n                       quantizer_1st, quantizer_2nd_lo, quantizer_2nd_hi)",
          "old_line_content": "            ctx->ma_predictor_prev = ma_predictor;",
          "new_line_content": "            lsf_decode(ctx->lsfq, ctx->past_quantizer_outputs,",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": null,
          "new_api": "ff_acelp_decode_gain_code",
          "old_text": null,
          "new_text": "ff_acelp_decode_gain_code(&s->adsp, gain_corr_factor,\n                                                                   fc, MR_ENERGY,\n                                                                   ctx->quant_energy,\n                                                                   ma_prediction_coeff,\n                                                                   SUBFRAME_SIZE, 4)",
          "old_line_content": "                                                                   ma_prediction_coeff,",
          "new_line_content": "                ctx->past_gain_code[0] = ff_acelp_decode_gain_code(&s->adsp, gain_corr_factor,",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": null,
          "new_api": "memmove",
          "old_text": null,
          "new_text": "memmove(ctx->exc_base, ctx->exc_base + 2 * SUBFRAME_SIZE, (PITCH_DELAY_MAX+INTERPOL_LEN)*sizeof(int16_t))",
          "old_line_content": "        ctx++;",
          "new_line_content": "        memmove(ctx->exc_base, ctx->exc_base + 2 * SUBFRAME_SIZE, (PITCH_DELAY_MAX+INTERPOL_LEN)*sizeof(int16_t));",
          "content_same": false
        },
        {
          "line": 479,
          "old_api": null,
          "new_api": "memmove",
          "old_text": null,
          "new_text": "memmove(ctx->past_quantizer_outputs + 1, ctx->past_quantizer_outputs,\n                MA_NP * sizeof(int16_t*))",
          "old_line_content": "",
          "new_line_content": "        memmove(ctx->past_quantizer_outputs + 1, ctx->past_quantizer_outputs,",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Only mono and stereo are supported (requested channels: %d).\\n\", avctx->channels)",
          "old_line_content": "    avctx->sample_fmt = AV_SAMPLE_FMT_S16P;",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Only mono and stereo are supported (requested channels: %d).\\n\", avctx->channels);",
          "content_same": false
        },
        {
          "line": 354,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": null,
          "new_api": "ff_acelp_lsf2lsp",
          "old_text": null,
          "new_text": "ff_acelp_lsf2lsp(ctx->lsp[1], ctx->lsfq, 10)",
          "old_line_content": "",
          "new_line_content": "        ff_acelp_lsf2lsp(ctx->lsp[1], ctx->lsfq, 10);",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(&gb, format->gc_1st_index_bits)",
          "old_line_content": "            if (frame_erasure) {",
          "new_line_content": "            gc_1st_index  = get_bits(&gb, format->gc_1st_index_bits);",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": null,
          "new_api": "ff_acelp_lp_decode",
          "old_text": null,
          "new_text": "ff_acelp_lp_decode(&lp[0][0], &lp[1][0], ctx->lsp[1], ctx->lsp[0], 10)",
          "old_line_content": "",
          "new_line_content": "        ff_acelp_lp_decode(&lp[0][0], &lp[1][0], ctx->lsp[1], ctx->lsp[0], 10);",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&s->channel_context)",
          "old_line_content": "}",
          "new_line_content": "    av_freep(&s->channel_context);",
          "content_same": false
        },
        {
          "line": 362,
          "old_api": null,
          "new_api": "av_mallocz",
          "old_text": null,
          "new_text": "av_mallocz(sizeof(G729ChannelContext) * avctx->channels)",
          "old_line_content": "",
          "new_line_content": "    s->channel_context = av_mallocz(sizeof(G729ChannelContext) * avctx->channels);",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "        ctx->gain_coeff = 16384; // 1.0 in (1.14)",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"G.729\")",
          "old_line_content": "    .priv_data_size = sizeof(G729Context),",
          "new_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"G.729\"),",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": null,
          "new_api": "ff_acelp_interpolate",
          "old_text": null,
          "new_text": "ff_acelp_interpolate(ctx->exc + i * SUBFRAME_SIZE,\n                                 ctx->exc + i * SUBFRAME_SIZE - pitch_delay_3x / 3,\n                                 ff_acelp_interp_filter, 6,\n                                 (pitch_delay_3x % 3) << 1,\n                                 10, SUBFRAME_SIZE)",
          "old_line_content": "                                 (pitch_delay_3x % 3) << 1,",
          "new_line_content": "            ff_acelp_interpolate(ctx->exc + i * SUBFRAME_SIZE,",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(&gb, format->fc_signs_bits)",
          "old_line_content": "",
          "new_line_content": "            pulses_signs  = get_bits(&gb, format->fc_signs_bits);",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": null,
          "new_api": "ff_acelp_weighted_vector_sum",
          "old_text": null,
          "new_text": "ff_acelp_weighted_vector_sum(ctx->exc + i * SUBFRAME_SIZE,\n                                         ctx->exc + i * SUBFRAME_SIZE, fc,\n                                         (!ctx->was_periodic && frame_erasure) ? 0 : ctx->past_gain_pitch[0],\n                                         ( ctx->was_periodic && frame_erasure) ? 0 : ctx->past_gain_code[0],\n                                         1 << 13, 14, SUBFRAME_SIZE)",
          "old_line_content": "                                         ( ctx->was_periodic && frame_erasure) ? 0 : ctx->past_gain_code[0],",
          "new_line_content": "            ff_acelp_weighted_vector_sum(ctx->exc + i * SUBFRAME_SIZE,",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(&gb, format->gc_2nd_index_bits)",
          "old_line_content": "                pitch_delay_3x = 3 * ctx->pitch_delay_int_prev;",
          "new_line_content": "            gc_2nd_index  = get_bits(&gb, format->gc_2nd_index_bits);",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(ctx->lsp[0], lsp_init, 10 * sizeof(int16_t))",
          "old_line_content": "",
          "new_line_content": "        memcpy(ctx->lsp[0], lsp_init, 10 * sizeof(int16_t));",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"Sipro ACELP.KELVIN\")",
          "old_line_content": "    .priv_data_size = sizeof(G729Context),",
          "new_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"Sipro ACELP.KELVIN\"),",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(synth, ctx->syn_filter_data, 10 * sizeof(int16_t))",
          "old_line_content": "                synth+10,",
          "new_line_content": "            memcpy(synth, ctx->syn_filter_data, 10 * sizeof(int16_t));",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": null,
          "new_api": "ff_celp_lp_synthesis_filter",
          "old_text": null,
          "new_text": "ff_celp_lp_synthesis_filter(\n                synth+10,\n                &lp[i][1],\n                ctx->exc  + i * SUBFRAME_SIZE,\n                SUBFRAME_SIZE,\n                10,\n                1,\n                0,\n                0x800)",
          "old_line_content": "                ctx->exc  + i * SUBFRAME_SIZE,",
          "new_line_content": "            if (ff_celp_lp_synthesis_filter(",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 516,
          "old_api": "ff_acelp_decode_4bit_to_2nd_delay3",
          "new_api": null,
          "old_text": "ff_acelp_decode_4bit_to_2nd_delay3(ac_index, pitch_delay_min)",
          "new_text": null,
          "old_line_content": "                    pitch_delay_3x = ff_acelp_decode_4bit_to_2nd_delay3(ac_index, pitch_delay_min);",
          "new_line_content": "                                              PITCH_DELAY_MIN, PITCH_DELAY_MAX - 9);",
          "content_same": false
        },
        {
          "line": 390,
          "old_api": "ff_audiodsp_init",
          "new_api": null,
          "old_text": "ff_audiodsp_init(&s->adsp)",
          "new_text": null,
          "old_line_content": "    ff_audiodsp_init(&s->adsp);",
          "new_line_content": "        ctx++;",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": "ff_acelp_decode_5_6_bit_to_2nd_delay3",
          "new_api": null,
          "old_text": "ff_acelp_decode_5_6_bit_to_2nd_delay3(ac_index, pitch_delay_min)",
          "new_text": null,
          "old_line_content": "                    pitch_delay_3x = ff_acelp_decode_5_6_bit_to_2nd_delay3(ac_index, pitch_delay_min);",
          "new_line_content": "                if (packet_type == FORMAT_G729D_6K4) {",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": "g729d_onset_decision",
          "new_api": null,
          "old_text": "g729d_onset_decision(ctx->onset, ctx->past_gain_code)",
          "new_text": null,
          "old_line_content": "                ctx->onset = g729d_onset_decision(ctx->onset, ctx->past_gain_code);",
          "new_line_content": "            if (packet_type == FORMAT_G729D_6K4) {",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_WARNING, \"pitch_delay_int %d is too large\\n\", pitch_delay_int[i])",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_WARNING, \"pitch_delay_int %d is too large\\n\", pitch_delay_int[i]);",
          "new_line_content": "            /* Round pitch delay to nearest (used everywhere except ff_acelp_interpolate). */",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": "g729d_voice_decision",
          "new_api": null,
          "old_text": "g729d_voice_decision(ctx->onset, ctx->voice_decision, ctx->past_gain_pitch)",
          "new_text": null,
          "old_line_content": "                ctx->voice_decision = g729d_voice_decision(ctx->onset, ctx->voice_decision, ctx->past_gain_pitch);",
          "new_line_content": "                int16_t exc_new[SUBFRAME_SIZE];",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": "g729_prng",
          "new_api": null,
          "old_text": "g729_prng(ctx->rand_value)",
          "new_text": null,
          "old_line_content": "                ctx->rand_value = g729_prng(ctx->rand_value);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "av_mod_uintp2",
          "new_api": null,
          "old_text": "av_mod_uintp2(ctx->rand_value, format->fc_indexes_bits)",
          "new_text": null,
          "old_line_content": "                fc_indexes   = av_mod_uintp2(ctx->rand_value, format->fc_indexes_bits);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "ff_celp_lp_synthesis_filter",
          "new_api": null,
          "old_text": "ff_celp_lp_synthesis_filter(\n                        synth+10,\n                        &lp[i][1],\n                        exc_new,\n                        SUBFRAME_SIZE,\n                        10,\n                        0,\n                        0,\n                        0x800)",
          "new_text": null,
          "old_line_content": "                ff_celp_lp_synthesis_filter(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(fc, 0, sizeof(int16_t) * SUBFRAME_SIZE)",
          "new_text": null,
          "old_line_content": "            memset(fc, 0, sizeof(int16_t) * SUBFRAME_SIZE);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": "ff_celp_lp_synthesis_filter",
          "new_api": null,
          "old_text": "ff_celp_lp_synthesis_filter(\n                        synth+10,\n                        &lp[i][1],\n                        ctx->exc  + i * SUBFRAME_SIZE,\n                        SUBFRAME_SIZE,\n                        10,\n                        0,\n                        0,\n                        0x800)",
          "new_text": null,
          "old_line_content": "                ff_celp_lp_synthesis_filter(",
          "new_line_content": "                        0,",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": "ff_acelp_fc_pulse_per_track",
          "new_api": null,
          "old_text": "ff_acelp_fc_pulse_per_track(fc, ff_fc_2pulses_9bits_track1_gray,\n                                                ff_fc_2pulses_9bits_track2_gray,\n                                                fc_indexes, pulses_signs, 1, 4)",
          "new_text": null,
          "old_line_content": "                    ff_acelp_fc_pulse_per_track(fc, ff_fc_2pulses_9bits_track1_gray,",
          "new_line_content": "                                                fc_indexes, pulses_signs, 3, 3);",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(ctx->syn_filter_data, synth+SUBFRAME_SIZE, 10 * sizeof(int16_t))",
          "new_text": null,
          "old_line_content": "            memcpy(ctx->syn_filter_data, synth+SUBFRAME_SIZE, 10 * sizeof(int16_t));",
          "new_line_content": "                        0x800);",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": "ff_get_buffer",
          "new_api": null,
          "old_text": "ff_get_buffer(avctx, frame, 0)",
          "new_text": null,
          "old_line_content": "    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)",
          "new_line_content": "    AVFrame *frame = data;",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": "FFABS",
          "new_api": null,
          "old_text": "FFABS(synth[j+10])",
          "new_text": null,
          "old_line_content": "                gain_before += FFABS(synth[j+10]);",
          "new_line_content": "            /* Calculate gain of unfiltered signal for use in AGC. */",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Packet type: %s\\n\", \"G.729 @ 8kbit/s\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Packet type: %s\\n\", \"G.729 @ 8kbit/s\");",
          "new_line_content": "        //Reset voice decision",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": "ff_acelp_weighted_vector_sum",
          "new_api": null,
          "old_text": "ff_acelp_weighted_vector_sum(fc + pitch_delay_int[i],\n                                             fc + pitch_delay_int[i],\n                                             fc, 1 << 14,\n                                             av_clip(ctx->past_gain_pitch[0], SHARP_MIN, SHARP_MAX),\n                                             0, 14,\n                                             SUBFRAME_SIZE - pitch_delay_int[i])",
          "new_text": null,
          "old_line_content": "                ff_acelp_weighted_vector_sum(fc + pitch_delay_int[i],",
          "new_line_content": "                         \\ fc_v[i] + gain_pitch * fc_v[i-pitch_delay], i >= pitch_delay",
          "content_same": false
        },
        {
          "line": 437,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_DEBUG, \"Packet type: %s\\n\", \"G.729D @ 6.4kbit/s\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_DEBUG, \"Packet type: %s\\n\", \"G.729D @ 6.4kbit/s\");",
          "new_line_content": "    } else if (buf_size == G729D_6K4_BLOCK_SIZE * avctx->channels) {",
          "content_same": false
        },
        {
          "line": 439,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Packet size %d is unknown.\\n\", buf_size)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Packet size %d is unknown.\\n\", buf_size);",
          "new_line_content": "        format = &format_g729d_6k4;",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": "memmove",
          "new_api": null,
          "old_text": "memmove(ctx->past_gain_pitch+1, ctx->past_gain_pitch, 5 * sizeof(int16_t))",
          "new_text": null,
          "old_line_content": "            memmove(ctx->past_gain_pitch+1, ctx->past_gain_pitch, 5 * sizeof(int16_t));",
          "new_line_content": "                                             0, 14,",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": "FFABS",
          "new_api": null,
          "old_text": "FFABS(synth[j+10])",
          "new_text": null,
          "old_line_content": "                gain_after += FFABS(synth[j+10]);",
          "new_line_content": "            /* Calculate gain of filtered signal for use in AGC. */",
          "content_same": false
        },
        {
          "line": 704,
          "old_api": "ff_g729_adaptive_gain_control",
          "new_api": null,
          "old_text": "ff_g729_adaptive_gain_control(\n                    gain_before,\n                    gain_after,\n                    synth+10,\n                    SUBFRAME_SIZE,\n                    ctx->gain_coeff)",
          "new_text": null,
          "old_line_content": "            ctx->gain_coeff = ff_g729_adaptive_gain_control(",
          "new_line_content": "            for (j = 0; j < SUBFRAME_SIZE; j++)",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": "avpriv_request_sample",
          "new_api": null,
          "old_text": "avpriv_request_sample(avctx, \"First byte value %x for channel %d\", *buf, c)",
          "new_text": null,
          "old_line_content": "                avpriv_request_sample(avctx, \"First byte value %x for channel %d\", *buf, c);",
          "new_line_content": "        out_frame = (int16_t*)frame->data[c];",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(ctx->pitch_delay_int_prev + 1, PITCH_DELAY_MAX)",
          "new_text": null,
          "old_line_content": "                ctx->pitch_delay_int_prev = FFMIN(ctx->pitch_delay_int_prev + 1, PITCH_DELAY_MAX);",
          "new_line_content": "                    ctx->gain_coeff);",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": "init_get_bits",
          "new_api": null,
          "old_text": "init_get_bits(&gb, buf, 8*buf_size)",
          "new_text": null,
          "old_line_content": "        init_get_bits(&gb, buf, 8*buf_size);",
          "new_line_content": "            frame_erasure |= buf[i];",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(gain_corr_factor, 1024)",
          "new_text": null,
          "old_line_content": "                    gain_corr_factor = FFMAX(gain_corr_factor, 1024);",
          "new_line_content": "                    /* Without check below overflow can occur in ff_acelp_update_past_gain.",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(&gb, 1)",
          "new_text": null,
          "old_line_content": "        ma_predictor     = get_bits(&gb, 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(synth+8, ctx->hpf_z, 2*sizeof(int16_t))",
          "new_text": null,
          "old_line_content": "            memcpy(synth+8, ctx->hpf_z, 2*sizeof(int16_t));",
          "new_line_content": "                ctx->pitch_delay_int_prev = pitch_delay_int[i];",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(&gb, VQ_2ND_BITS)",
          "new_text": null,
          "old_line_content": "        quantizer_2nd_lo = get_bits(&gb, VQ_2ND_BITS);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": "ff_acelp_high_pass_filter",
          "new_api": null,
          "old_text": "ff_acelp_high_pass_filter(\n                    out_frame + i*SUBFRAME_SIZE,\n                    ctx->hpf_f,\n                    synth+10,\n                    SUBFRAME_SIZE)",
          "new_text": null,
          "old_line_content": "            ff_acelp_high_pass_filter(",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(ctx->hpf_z, synth+8+SUBFRAME_SIZE, 2*sizeof(int16_t))",
          "new_text": null,
          "old_line_content": "            memcpy(ctx->hpf_z, synth+8+SUBFRAME_SIZE, 2*sizeof(int16_t));",
          "new_line_content": "                    ctx->hpf_f,",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": "ff_acelp_decode_gain_code",
          "new_api": null,
          "old_text": "ff_acelp_decode_gain_code(&s->adsp, gain_corr_factor,\n                                                                   fc, MR_ENERGY,\n                                                                   ctx->quant_energy,\n                                                                   ma_prediction_coeff,\n                                                                   SUBFRAME_SIZE, 4)",
          "new_text": null,
          "old_line_content": "                ctx->past_gain_code[0] = ff_acelp_decode_gain_code(&s->adsp, gain_corr_factor,",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "memmove",
          "new_api": null,
          "old_text": "memmove(ctx->exc_base, ctx->exc_base + 2 * SUBFRAME_SIZE, (PITCH_DELAY_MAX+INTERPOL_LEN)*sizeof(int16_t))",
          "new_text": null,
          "old_line_content": "        memmove(ctx->exc_base, ctx->exc_base + 2 * SUBFRAME_SIZE, (PITCH_DELAY_MAX+INTERPOL_LEN)*sizeof(int16_t));",
          "new_line_content": "        ctx->was_periodic = is_periodic;",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": "memmove",
          "new_api": null,
          "old_text": "memmove(ctx->past_quantizer_outputs + 1, ctx->past_quantizer_outputs,\n                MA_NP * sizeof(int16_t*))",
          "new_text": null,
          "old_line_content": "        memmove(ctx->past_quantizer_outputs + 1, ctx->past_quantizer_outputs,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Only mono and stereo are supported (requested channels: %d).\\n\", avctx->channels)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Only mono and stereo are supported (requested channels: %d).\\n\", avctx->channels);",
          "new_line_content": "    int c,i,k;",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": "ff_acelp_lsf2lsp",
          "new_api": null,
          "old_text": "ff_acelp_lsf2lsp(ctx->lsp[1], ctx->lsfq, 10)",
          "new_text": null,
          "old_line_content": "        ff_acelp_lsf2lsp(ctx->lsp[1], ctx->lsfq, 10);",
          "new_line_content": "                MA_NP * sizeof(int16_t*));",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": "ff_acelp_lp_decode",
          "new_api": null,
          "old_text": "ff_acelp_lp_decode(&lp[0][0], &lp[1][0], ctx->lsp[1], ctx->lsp[0], 10)",
          "new_text": null,
          "old_line_content": "        ff_acelp_lp_decode(&lp[0][0], &lp[1][0], ctx->lsp[1], ctx->lsp[0], 10);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&s->channel_context)",
          "new_text": null,
          "old_line_content": "    av_freep(&s->channel_context);",
          "new_line_content": "static av_cold int decode_close(AVCodecContext *avctx)",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": "av_mallocz",
          "new_api": null,
          "old_text": "av_mallocz(sizeof(G729ChannelContext) * avctx->channels)",
          "new_text": null,
          "old_line_content": "    s->channel_context = av_mallocz(sizeof(G729ChannelContext) * avctx->channels);",
          "new_line_content": "    avctx->frame_size = SUBFRAME_SIZE << 1;",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        return AVERROR(ENOMEM);",
          "new_line_content": "    ctx =",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": "ff_acelp_update_past_gain",
          "new_api": null,
          "old_text": "ff_acelp_update_past_gain(ctx->quant_energy, gain_corr_factor, 2, frame_erasure)",
          "new_text": null,
          "old_line_content": "            ff_acelp_update_past_gain(ctx->quant_energy, gain_corr_factor, 2, frame_erasure);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"G.729\")",
          "new_text": null,
          "old_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"G.729\"),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(&gb, format->ac_index_bits[i])",
          "new_text": null,
          "old_line_content": "            ac_index      = get_bits(&gb, format->ac_index_bits[i]);",
          "new_line_content": "            uint8_t gc_1st_index;  ///< gain codebook (first stage) index",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(&gb)",
          "new_text": null,
          "old_line_content": "                bad_pitch = av_parity(ac_index >> 2) == get_bits1(&gb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(&gb, format->fc_signs_bits)",
          "new_text": null,
          "old_line_content": "            pulses_signs  = get_bits(&gb, format->fc_signs_bits);",
          "new_line_content": "            if (!i && format->parity_bit)",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "ff_acelp_weighted_vector_sum",
          "new_api": null,
          "old_text": "ff_acelp_weighted_vector_sum(ctx->exc + i * SUBFRAME_SIZE,\n                                         ctx->exc + i * SUBFRAME_SIZE, fc,\n                                         (!ctx->was_periodic && frame_erasure) ? 0 : ctx->past_gain_pitch[0],\n                                         ( ctx->was_periodic && frame_erasure) ? 0 : ctx->past_gain_code[0],\n                                         1 << 13, 14, SUBFRAME_SIZE)",
          "new_text": null,
          "old_line_content": "            ff_acelp_weighted_vector_sum(ctx->exc + i * SUBFRAME_SIZE,",
          "new_line_content": "                                 (pitch_delay_3x % 3) << 1,",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(ctx->lsp[0], lsp_init, 10 * sizeof(int16_t))",
          "new_text": null,
          "old_line_content": "        memcpy(ctx->lsp[0], lsp_init, 10 * sizeof(int16_t));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"Sipro ACELP.KELVIN\")",
          "new_text": null,
          "old_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"Sipro ACELP.KELVIN\"),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(synth, ctx->syn_filter_data, 10 * sizeof(int16_t))",
          "new_text": null,
          "old_line_content": "            memcpy(synth, ctx->syn_filter_data, 10 * sizeof(int16_t));",
          "new_line_content": "                                         ( ctx->was_periodic && frame_erasure) ? 0 : ctx->past_gain_code[0],",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": "ff_celp_lp_synthesis_filter",
          "new_api": null,
          "old_text": "ff_celp_lp_synthesis_filter(\n                synth+10,\n                &lp[i][1],\n                ctx->exc  + i * SUBFRAME_SIZE,\n                SUBFRAME_SIZE,\n                10,\n                1,\n                0,\n                0x800)",
          "new_text": null,
          "old_line_content": "            if (ff_celp_lp_synthesis_filter(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": "ff_acelp_decode_8bit_to_1st_delay3",
          "new_api": null,
          "old_text": "ff_acelp_decode_8bit_to_1st_delay3(ac_index)",
          "new_text": null,
          "old_line_content": "                    pitch_delay_3x = ff_acelp_decode_8bit_to_1st_delay3(ac_index);",
          "new_line_content": "                if (bad_pitch) {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 10,
      "total_additions": 52,
      "total_deletions": 52,
      "total_api_changes": 114
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 4,
        "api_related_lines": 114,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          340,
          341,
          342,
          335
        ]
      }
    },
    "api_calls_before": 70,
    "api_calls_after": 70,
    "diff_info": {
      "added_lines": 4,
      "removed_lines": 1,
      "total_diff_lines": 21
    }
  }
}