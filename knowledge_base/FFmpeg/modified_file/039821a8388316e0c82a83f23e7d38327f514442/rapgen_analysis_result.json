{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/039821a8388316e0c82a83f23e7d38327f514442",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/039821a8388316e0c82a83f23e7d38327f514442/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/039821a8388316e0c82a83f23e7d38327f514442/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/039821a8388316e0c82a83f23e7d38327f514442/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1563,
          "old_api": "av_log",
          "new_api": "parse_adts_frame_header",
          "old_text": "av_log(ac->avccontext, AV_LOG_ERROR, \"invalid sampling rate index %d\\n\", ac->m4ac.sampling_index)",
          "new_text": "parse_adts_frame_header(ac, &gb)",
          "old_line_content": "            av_log(ac->avccontext, AV_LOG_ERROR, \"invalid sampling rate index %d\\n\", ac->m4ac.sampling_index);",
          "new_line_content": "        if ((err = parse_adts_frame_header(ac, &gb)) < 0) {",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1536,
          "old_api": null,
          "new_api": "ff_aac_parse_header",
          "old_text": null,
          "new_text": "ff_aac_parse_header(gb, &hdr_info)",
          "old_line_content": "        ac->m4ac.sampling_index  = hdr_info.sampling_index;",
          "new_line_content": "    size = ff_aac_parse_header(gb, &hdr_info);",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&ac->che[type][i])",
          "old_line_content": "    return 0 ;",
          "new_line_content": "            av_freep(&ac->che[type][i]);",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": null,
          "new_api": "ff_mdct_end",
          "old_text": null,
          "new_text": "ff_mdct_end(&ac->mdct)",
          "old_line_content": "AVCodec aac_decoder = {",
          "new_line_content": "    ff_mdct_end(&ac->mdct);",
          "content_same": false
        },
        {
          "line": 1673,
          "old_api": null,
          "new_api": "ff_mdct_end",
          "old_text": null,
          "new_text": "ff_mdct_end(&ac->mdct_small)",
          "old_line_content": "    \"aac\",",
          "new_line_content": "    ff_mdct_end(&ac->mdct_small);",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": null,
          "new_api": "skip_bits",
          "old_text": null,
          "new_text": "skip_bits(gb, 16)",
          "old_line_content": "    return size;",
          "new_line_content": "            skip_bits(gb, 16);",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": null,
          "new_api": "ff_log_missing_feature",
          "old_text": null,
          "new_text": "ff_log_missing_feature(ac->avccontext, \"More than one AAC RDB per ADTS frame is\", 0)",
          "old_line_content": "",
          "new_line_content": "        ff_log_missing_feature(ac->avccontext, \"More than one AAC RDB per ADTS frame is\", 0);",
          "content_same": false
        },
        {
          "line": 1686,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"Advanced Audio Coding\")",
          "old_line_content": "",
          "new_line_content": "    .long_name = NULL_IF_CONFIG_SMALL(\"Advanced Audio Coding\"),",
          "content_same": false
        },
        {
          "line": 1560,
          "old_api": null,
          "new_api": "init_get_bits",
          "old_text": null,
          "new_text": "init_get_bits(&gb, buf, buf_size*8)",
          "old_line_content": "            return -1;",
          "new_line_content": "    init_get_bits(&gb, buf, buf_size*8);",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": null,
          "new_api": "show_bits",
          "old_text": null,
          "new_text": "show_bits(&gb, 12)",
          "old_line_content": "        if (ac->m4ac.sampling_index > 12) {",
          "new_line_content": "    if (show_bits(&gb, 12) == 0xfff) {",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avccontext, AV_LOG_ERROR, \"Error decoding AAC frame header.\\n\")",
          "old_line_content": "            return -1;",
          "new_line_content": "            av_log(avccontext, AV_LOG_ERROR, \"Error decoding AAC frame header.\\n\");",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(ac->avccontext, AV_LOG_ERROR, \"invalid sampling rate index %d\\n\", ac->m4ac.sampling_index)",
          "old_line_content": "    // parse",
          "new_line_content": "            av_log(ac->avccontext, AV_LOG_ERROR, \"invalid sampling rate index %d\\n\", ac->m4ac.sampling_index);",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(&gb, 3)",
          "old_line_content": "                !ac->che[TYPE_SCE][elem_id] && ac->che[TYPE_LFE][0]) {",
          "new_line_content": "    while ((elem_type = get_bits(&gb, 3)) != TYPE_END) {",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(&gb, 4)",
          "old_line_content": "            /* Some streams incorrectly code 5.1 audio as SCE[0] CPE[0] CPE[1] SCE[1]",
          "new_line_content": "        elem_id = get_bits(&gb, 4);",
          "content_same": false
        },
        {
          "line": 1587,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(ac->avccontext, AV_LOG_ERROR, \"channel element %d.%d is not allocated\\n\", elem_type, elem_id)",
          "old_line_content": "",
          "new_line_content": "            av_log(ac->avccontext, AV_LOG_ERROR, \"channel element %d.%d is not allocated\\n\", elem_type, elem_id);",
          "content_same": false
        },
        {
          "line": 1594,
          "old_api": null,
          "new_api": "decode_ics",
          "old_text": null,
          "new_text": "decode_ics(ac, &ac->che[TYPE_SCE][elem_id]->ch[0], &gb, 0, 0)",
          "old_line_content": "            break;",
          "new_line_content": "            err = decode_ics(ac, &ac->che[TYPE_SCE][elem_id]->ch[0], &gb, 0, 0);",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": null,
          "new_api": "decode_cpe",
          "old_text": null,
          "new_text": "decode_cpe(ac, &gb, elem_id)",
          "old_line_content": "            break;",
          "new_line_content": "            err = decode_cpe(ac, &gb, elem_id);",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": null,
          "new_api": "decode_cce",
          "old_text": null,
          "new_text": "decode_cce(ac, &gb, ac->che[TYPE_CCE][elem_id])",
          "old_line_content": "            break;",
          "new_line_content": "            err = decode_cce(ac, &gb, ac->che[TYPE_CCE][elem_id]);",
          "content_same": false
        },
        {
          "line": 1606,
          "old_api": null,
          "new_api": "decode_ics",
          "old_text": null,
          "new_text": "decode_ics(ac, &ac->che[TYPE_LFE][elem_id]->ch[0], &gb, 0, 0)",
          "old_line_content": "            err = 0;",
          "new_line_content": "            err = decode_ics(ac, &ac->che[TYPE_LFE][elem_id]->ch[0], &gb, 0, 0);",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": null,
          "new_api": "skip_data_stream_element",
          "old_text": null,
          "new_text": "skip_data_stream_element(&gb)",
          "old_line_content": "        {",
          "new_line_content": "            skip_data_stream_element(&gb);",
          "content_same": false
        },
        {
          "line": 1617,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]))",
          "old_line_content": "        }",
          "new_line_content": "            memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));",
          "content_same": false
        },
        {
          "line": 1618,
          "old_api": null,
          "new_api": "decode_pce",
          "old_text": null,
          "new_text": "decode_pce(ac, new_che_pos, &gb)",
          "old_line_content": "",
          "new_line_content": "            if((err = decode_pce(ac, new_che_pos, &gb)))",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": null,
          "new_api": "output_configure",
          "old_text": null,
          "new_text": "output_configure(ac, ac->che_pos, new_che_pos)",
          "old_line_content": "            if (elem_id == 15)",
          "new_line_content": "            err = output_configure(ac, ac->che_pos, new_che_pos);",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": null,
          "new_api": "apply_coupling_method",
          "old_text": null,
          "new_text": "apply_coupling_method(ac, &cc->ch[1], cce, index++)",
          "old_line_content": "    }",
          "new_line_content": "                        apply_coupling_method(ac, &cc->ch[1], cce, index++);",
          "content_same": false
        },
        {
          "line": 1626,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(&gb, 8)",
          "old_line_content": "",
          "new_line_content": "                elem_id += get_bits(&gb, 8) - 1;",
          "content_same": false
        },
        {
          "line": 1628,
          "old_api": null,
          "new_api": "decode_extension_payload",
          "old_text": null,
          "new_text": "decode_extension_payload(ac, &gb, elem_id)",
          "old_line_content": "            err = -1; /* should not happen, but keeps compiler happy */",
          "new_line_content": "                elem_id -= decode_extension_payload(ac, &gb, elem_id);",
          "content_same": false
        },
        {
          "line": 1641,
          "old_api": null,
          "new_api": "spectral_to_sample",
          "old_text": null,
          "new_text": "spectral_to_sample(ac)",
          "old_line_content": "        return buf_size;",
          "new_line_content": "    spectral_to_sample(ac);",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": null,
          "new_api": "apply_channel_coupling",
          "old_text": null,
          "new_text": "apply_channel_coupling(ac, che, type, i, BEFORE_TNS, apply_dependent_coupling)",
          "old_line_content": "                if(type <= TYPE_CPE)",
          "new_line_content": "                    apply_channel_coupling(ac, che, type, i, BEFORE_TNS, apply_dependent_coupling);",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": null,
          "new_api": "apply_tns",
          "old_text": null,
          "new_text": "apply_tns(che->ch[0].coeffs, &che->ch[0].tns, &che->ch[0].ics, 1)",
          "old_line_content": "                if(type != TYPE_CCE || che->coup.coupling_point == AFTER_IMDCT)",
          "new_line_content": "                    apply_tns(che->ch[0].coeffs, &che->ch[0].tns, &che->ch[0].ics, 1);",
          "content_same": false
        },
        {
          "line": 1517,
          "old_api": null,
          "new_api": "apply_tns",
          "old_text": null,
          "new_text": "apply_tns(che->ch[1].coeffs, &che->ch[1].tns, &che->ch[1].ics, 1)",
          "old_line_content": "                if(type == TYPE_CPE)",
          "new_line_content": "                    apply_tns(che->ch[1].coeffs, &che->ch[1].tns, &che->ch[1].ics, 1);",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": null,
          "new_api": "apply_channel_coupling",
          "old_text": null,
          "new_text": "apply_channel_coupling(ac, che, type, i, BETWEEN_TNS_AND_IMDCT, apply_dependent_coupling)",
          "old_line_content": "                if(type <= TYPE_CCE)",
          "new_line_content": "                    apply_channel_coupling(ac, che, type, i, BETWEEN_TNS_AND_IMDCT, apply_dependent_coupling);",
          "content_same": false
        },
        {
          "line": 1521,
          "old_api": null,
          "new_api": "imdct_and_windowing",
          "old_text": null,
          "new_text": "imdct_and_windowing(ac, &che->ch[0])",
          "old_line_content": "            }",
          "new_line_content": "                    imdct_and_windowing(ac, &che->ch[0]);",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avccontext, AV_LOG_ERROR,\n               \"Output buffer too small (%d) or trying to output too many samples (%d) for this frame.\\n\",\n               *data_size, data_size_tmp)",
          "old_line_content": "    *data_size = data_size_tmp;",
          "new_line_content": "        av_log(avccontext, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 1523,
          "old_api": null,
          "new_api": "imdct_and_windowing",
          "old_text": null,
          "new_text": "imdct_and_windowing(ac, &che->ch[1])",
          "old_line_content": "    }",
          "new_line_content": "                    imdct_and_windowing(ac, &che->ch[1]);",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": null,
          "new_api": "apply_channel_coupling",
          "old_text": null,
          "new_text": "apply_channel_coupling(ac, che, type, i, AFTER_IMDCT, apply_independent_coupling)",
          "old_line_content": "",
          "new_line_content": "                    apply_channel_coupling(ac, che, type, i, AFTER_IMDCT, apply_independent_coupling);",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": null,
          "new_api": "float_to_int16_interleave",
          "old_text": null,
          "new_text": "ac->dsp.float_to_int16_interleave(data, (const float **)ac->output_data, 1024, avccontext->channels)",
          "old_line_content": "static av_cold int aac_decode_close(AVCodecContext * avccontext) {",
          "new_line_content": "    ac->dsp.float_to_int16_interleave(data, (const float **)ac->output_data, 1024, avccontext->channels);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1664,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&ac->che[type][i])",
          "new_text": null,
          "old_line_content": "            av_freep(&ac->che[type][i]);",
          "new_line_content": "    AACContext * ac = avccontext->priv_data;",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": "ff_mdct_end",
          "new_api": null,
          "old_text": "ff_mdct_end(&ac->mdct)",
          "new_text": null,
          "old_line_content": "    ff_mdct_end(&ac->mdct);",
          "new_line_content": "    for (i = 0; i < MAX_ELEM_ID; i++) {",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": "ff_mdct_end",
          "new_api": null,
          "old_text": "ff_mdct_end(&ac->mdct_small)",
          "new_text": null,
          "old_line_content": "    ff_mdct_end(&ac->mdct_small);",
          "new_line_content": "        for(type = 0; type < 4; type++)",
          "content_same": false
        },
        {
          "line": 1541,
          "old_api": "skip_bits",
          "new_api": null,
          "old_text": "skip_bits(gb, 16)",
          "new_text": null,
          "old_line_content": "            skip_bits(gb, 16);",
          "new_line_content": "        ac->m4ac.sampling_index  = hdr_info.sampling_index;",
          "content_same": false
        },
        {
          "line": 1543,
          "old_api": "ff_log_missing_feature",
          "new_api": null,
          "old_text": "ff_log_missing_feature(ac->avccontext, \"More than one AAC RDB per ADTS frame is\", 0)",
          "new_text": null,
          "old_line_content": "        ff_log_missing_feature(ac->avccontext, \"More than one AAC RDB per ADTS frame is\", 0);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"Advanced Audio Coding\")",
          "new_text": null,
          "old_line_content": "    .long_name = NULL_IF_CONFIG_SMALL(\"Advanced Audio Coding\"),",
          "new_line_content": "    sizeof(AACContext),",
          "content_same": false
        },
        {
          "line": 1555,
          "old_api": "init_get_bits",
          "new_api": null,
          "old_text": "init_get_bits(&gb, buf, buf_size*8)",
          "new_text": null,
          "old_line_content": "    init_get_bits(&gb, buf, buf_size*8);",
          "new_line_content": "    AACContext * ac = avccontext->priv_data;",
          "content_same": false
        },
        {
          "line": 1557,
          "old_api": "show_bits",
          "new_api": null,
          "old_text": "show_bits(&gb, 12)",
          "new_text": null,
          "old_line_content": "    if (show_bits(&gb, 12) == 0xfff) {",
          "new_line_content": "    enum RawDataBlockType elem_type;",
          "content_same": false
        },
        {
          "line": 1558,
          "old_api": "parse_adts_frame_header",
          "new_api": null,
          "old_text": "parse_adts_frame_header(ac, &gb)",
          "new_text": null,
          "old_line_content": "        if ((err = parse_adts_frame_header(ac, &gb)) < 0) {",
          "new_line_content": "    int err, elem_id, data_size_tmp;",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avccontext, AV_LOG_ERROR, \"Error decoding AAC frame header.\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avccontext, AV_LOG_ERROR, \"Error decoding AAC frame header.\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1569,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(&gb, 3)",
          "new_text": null,
          "old_line_content": "    while ((elem_type = get_bits(&gb, 3)) != TYPE_END) {",
          "new_line_content": "            return -1;",
          "content_same": false
        },
        {
          "line": 1570,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(&gb, 4)",
          "new_text": null,
          "old_line_content": "        elem_id = get_bits(&gb, 4);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1582,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(ac->avccontext, AV_LOG_ERROR, \"channel element %d.%d is not allocated\\n\", elem_type, elem_id)",
          "new_text": null,
          "old_line_content": "            av_log(ac->avccontext, AV_LOG_ERROR, \"channel element %d.%d is not allocated\\n\", elem_type, elem_id);",
          "new_line_content": "               encountered such a stream, transfer the LFE[0] element to SCE[1] */",
          "content_same": false
        },
        {
          "line": 1589,
          "old_api": "decode_ics",
          "new_api": null,
          "old_text": "decode_ics(ac, &ac->che[TYPE_SCE][elem_id]->ch[0], &gb, 0, 0)",
          "new_text": null,
          "old_line_content": "            err = decode_ics(ac, &ac->che[TYPE_SCE][elem_id]->ch[0], &gb, 0, 0);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": "decode_cpe",
          "new_api": null,
          "old_text": "decode_cpe(ac, &gb, elem_id)",
          "new_text": null,
          "old_line_content": "            err = decode_cpe(ac, &gb, elem_id);",
          "new_line_content": "        case TYPE_SCE:",
          "content_same": false
        },
        {
          "line": 1597,
          "old_api": "decode_cce",
          "new_api": null,
          "old_text": "decode_cce(ac, &gb, ac->che[TYPE_CCE][elem_id])",
          "new_text": null,
          "old_line_content": "            err = decode_cce(ac, &gb, ac->che[TYPE_CCE][elem_id]);",
          "new_line_content": "        case TYPE_CPE:",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": "decode_ics",
          "new_api": null,
          "old_text": "decode_ics(ac, &ac->che[TYPE_LFE][elem_id]->ch[0], &gb, 0, 0)",
          "new_text": null,
          "old_line_content": "            err = decode_ics(ac, &ac->che[TYPE_LFE][elem_id]->ch[0], &gb, 0, 0);",
          "new_line_content": "        case TYPE_CCE:",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": "skip_data_stream_element",
          "new_api": null,
          "old_text": "skip_data_stream_element(&gb)",
          "new_text": null,
          "old_line_content": "            skip_data_stream_element(&gb);",
          "new_line_content": "        case TYPE_LFE:",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]))",
          "new_text": null,
          "old_line_content": "            memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": "decode_pce",
          "new_api": null,
          "old_text": "decode_pce(ac, new_che_pos, &gb)",
          "new_text": null,
          "old_line_content": "            if((err = decode_pce(ac, new_che_pos, &gb)))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1485,
          "old_api": "apply_coupling_method",
          "new_api": null,
          "old_text": "apply_coupling_method(ac, &cc->ch[0], cce, index)",
          "new_text": null,
          "old_line_content": "                        apply_coupling_method(ac, &cc->ch[0], cce, index);",
          "new_line_content": "            ChannelCoupling * coup = &cce->coup;",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": "output_configure",
          "new_api": null,
          "old_text": "output_configure(ac, ac->che_pos, new_che_pos)",
          "new_text": null,
          "old_line_content": "            err = output_configure(ac, ac->che_pos, new_che_pos);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(&gb, 8)",
          "new_text": null,
          "old_line_content": "                elem_id += get_bits(&gb, 8) - 1;",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 1623,
          "old_api": "decode_extension_payload",
          "new_api": null,
          "old_text": "decode_extension_payload(ac, &gb, elem_id)",
          "new_text": null,
          "old_line_content": "                elem_id -= decode_extension_payload(ac, &gb, elem_id);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1636,
          "old_api": "spectral_to_sample",
          "new_api": null,
          "old_text": "spectral_to_sample(ac)",
          "new_text": null,
          "old_line_content": "    spectral_to_sample(ac);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": "apply_channel_coupling",
          "new_api": null,
          "old_text": "apply_channel_coupling(ac, che, type, i, BEFORE_TNS, apply_dependent_coupling)",
          "new_text": null,
          "old_line_content": "                    apply_channel_coupling(ac, che, type, i, BEFORE_TNS, apply_dependent_coupling);",
          "new_line_content": "    for(type = 3; type >= 0; type--) {",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": "apply_tns",
          "new_api": null,
          "old_text": "apply_tns(che->ch[0].coeffs, &che->ch[0].tns, &che->ch[0].ics, 1)",
          "new_text": null,
          "old_line_content": "                    apply_tns(che->ch[0].coeffs, &che->ch[0].tns, &che->ch[0].ics, 1);",
          "new_line_content": "            ChannelElement *che = ac->che[type][i];",
          "content_same": false
        },
        {
          "line": 1512,
          "old_api": "apply_tns",
          "new_api": null,
          "old_text": "apply_tns(che->ch[1].coeffs, &che->ch[1].tns, &che->ch[1].ics, 1)",
          "new_text": null,
          "old_line_content": "                    apply_tns(che->ch[1].coeffs, &che->ch[1].tns, &che->ch[1].ics, 1);",
          "new_line_content": "                if(type <= TYPE_CPE)",
          "content_same": false
        },
        {
          "line": 1514,
          "old_api": "apply_channel_coupling",
          "new_api": null,
          "old_text": "apply_channel_coupling(ac, che, type, i, BETWEEN_TNS_AND_IMDCT, apply_dependent_coupling)",
          "new_text": null,
          "old_line_content": "                    apply_channel_coupling(ac, che, type, i, BETWEEN_TNS_AND_IMDCT, apply_dependent_coupling);",
          "new_line_content": "                if(che->ch[0].tns.present)",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": "imdct_and_windowing",
          "new_api": null,
          "old_text": "imdct_and_windowing(ac, &che->ch[0])",
          "new_text": null,
          "old_line_content": "                    imdct_and_windowing(ac, &che->ch[0]);",
          "new_line_content": "                if(che->ch[1].tns.present)",
          "content_same": false
        },
        {
          "line": 1646,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avccontext, AV_LOG_ERROR,\n               \"Output buffer too small (%d) or trying to output too many samples (%d) for this frame.\\n\",\n               *data_size, data_size_tmp)",
          "new_text": null,
          "old_line_content": "        av_log(avccontext, AV_LOG_ERROR,",
          "new_line_content": "        return buf_size;",
          "content_same": false
        },
        {
          "line": 1518,
          "old_api": "imdct_and_windowing",
          "new_api": null,
          "old_text": "imdct_and_windowing(ac, &che->ch[1])",
          "new_text": null,
          "old_line_content": "                    imdct_and_windowing(ac, &che->ch[1]);",
          "new_line_content": "                if(type <= TYPE_CPE)",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": "apply_channel_coupling",
          "new_api": null,
          "old_text": "apply_channel_coupling(ac, che, type, i, AFTER_IMDCT, apply_independent_coupling)",
          "new_text": null,
          "old_line_content": "                    apply_channel_coupling(ac, che, type, i, AFTER_IMDCT, apply_independent_coupling);",
          "new_line_content": "                if(type != TYPE_CCE || che->coup.coupling_point == AFTER_IMDCT)",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": "float_to_int16_interleave",
          "new_api": null,
          "old_text": "ac->dsp.float_to_int16_interleave(data, (const float **)ac->output_data, 1024, avccontext->channels)",
          "new_text": null,
          "old_line_content": "    ac->dsp.float_to_int16_interleave(data, (const float **)ac->output_data, 1024, avccontext->channels);",
          "new_line_content": "               *data_size, data_size_tmp);",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": "ff_aac_parse_header",
          "new_api": null,
          "old_text": "ff_aac_parse_header(gb, &hdr_info)",
          "new_text": null,
          "old_line_content": "    size = ff_aac_parse_header(gb, &hdr_info);",
          "new_line_content": "static int parse_adts_frame_header(AACContext * ac, GetBitContext * gb) {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 1,
      "total_additions": 35,
      "total_deletions": 35,
      "total_api_changes": 71
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 71,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          1459,
          1460,
          1461,
          1462,
          1463,
          1465
        ]
      }
    },
    "api_calls_before": 307,
    "api_calls_after": 307,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 1,
      "total_diff_lines": 20
    }
  }
}