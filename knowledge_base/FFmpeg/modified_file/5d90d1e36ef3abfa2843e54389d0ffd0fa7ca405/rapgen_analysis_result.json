{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/5d90d1e36ef3abfa2843e54389d0ffd0fa7ca405",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/5d90d1e36ef3abfa2843e54389d0ffd0fa7ca405/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/5d90d1e36ef3abfa2843e54389d0ffd0fa7ca405/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/5d90d1e36ef3abfa2843e54389d0ffd0fa7ca405/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 569,
          "old_api": "AVERROR",
          "new_api": "av_pix_fmt_desc_get",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "av_pix_fmt_desc_get(avctx->sw_pix_fmt)",
          "old_line_content": "                ret = AVERROR(ENOMEM);",
          "new_line_content": "            pixdesc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": "av_frame_free",
          "new_api": "av_hwframe_transfer_data",
          "old_text": "av_frame_free(&tmp_frame)",
          "new_text": "av_hwframe_transfer_data(frame, tmp_frame, 0)",
          "old_line_content": "                av_frame_free(&tmp_frame);",
          "new_line_content": "            ret = av_hwframe_transfer_data(frame, tmp_frame, 0);",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": "av_log",
          "new_api": "av_frame_free",
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"av_hwframe_transfer_data failed\\n\")",
          "new_text": "av_frame_free(&tmp_frame)",
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"av_hwframe_transfer_data failed\\n\");",
          "new_line_content": "            av_frame_free(&tmp_frame);",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "av_log",
          "new_api": "AVERROR",
          "old_text": "av_log(avctx, AV_LOG_TRACE, \"cuvid_decode_frame\\n\")",
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    av_log(avctx, AV_LOG_TRACE, \"cuvid_decode_frame\\n\");",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": "AVERROR",
          "new_api": "cuvid_decode_packet",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "cuvid_decode_packet(avctx, avpkt)",
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "        ret = cuvid_decode_packet(avctx, avpkt);",
          "content_same": false
        },
        {
          "line": 707,
          "old_api": "cuvidDestroyDecoder",
          "new_api": "av_buffer_unref",
          "old_text": "ctx->cvdl->cuvidDestroyDecoder(ctx->cudecoder)",
          "new_text": "av_buffer_unref(&ctx->hwframe)",
          "old_line_content": "        ctx->cvdl->cuvidDestroyDecoder(ctx->cudecoder);",
          "new_line_content": "    av_buffer_unref(&ctx->hwframe);",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": "av_buffer_unref",
          "new_api": "cuvid_free_functions",
          "old_text": "av_buffer_unref(&ctx->hwdevice)",
          "new_text": "cuvid_free_functions(&ctx->cvdl)",
          "old_line_content": "    av_buffer_unref(&ctx->hwdevice);",
          "new_line_content": "    cuvid_free_functions(&ctx->cvdl);",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": "cuvidGetDecoderCaps",
          "new_api": "av_log",
          "old_text": "ctx->cvdl->cuvidGetDecoderCaps(&ctx->caps8)",
          "new_text": "av_log(avctx, AV_LOG_VERBOSE, \"CUVID capabilities for %s:\\n\", avctx->codec->name)",
          "old_line_content": "    res8 = CHECK_CU(ctx->cvdl->cuvidGetDecoderCaps(&ctx->caps8));",
          "new_line_content": "    av_log(avctx, AV_LOG_VERBOSE, \"CUVID capabilities for %s:\\n\", avctx->codec->name);",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": "cuvidGetDecoderCaps",
          "new_api": "av_log",
          "old_text": "ctx->cvdl->cuvidGetDecoderCaps(&ctx->caps10)",
          "new_text": "av_log(avctx, AV_LOG_VERBOSE, \"8 bit: supported: %d, min_width: %d, max_width: %d, min_height: %d, max_height: %d\\n\",\n           ctx->caps8.bIsSupported, ctx->caps8.nMinWidth, ctx->caps8.nMaxWidth, ctx->caps8.nMinHeight, ctx->caps8.nMaxHeight)",
          "old_line_content": "    res10 = CHECK_CU(ctx->cvdl->cuvidGetDecoderCaps(&ctx->caps10));",
          "new_line_content": "    av_log(avctx, AV_LOG_VERBOSE, \"8 bit: supported: %d, min_width: %d, max_width: %d, min_height: %d, max_height: %d\\n\",",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Bit depth %d is not supported.\\n\", bit_depth)",
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Bit depth %d is not supported.\\n\", bit_depth);",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Video width %d not within range from %d to %d\\n\",\n               probed_width, caps->nMinWidth, caps->nMaxWidth)",
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Video width %d not within range from %d to %d\\n\",",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Video height %d not within range from %d to %d\\n\",\n               probed_height, caps->nMinHeight, caps->nMaxHeight)",
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Video height %d not within range from %d to %d\\n\",",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "AVERROR",
          "new_api": "sscanf",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "sscanf(ctx->crop_expr, \"%dx%dx%dx%d\",\n                                 &ctx->crop.top, &ctx->crop.bottom,\n                                 &ctx->crop.left, &ctx->crop.right)",
          "old_line_content": "        ret = AVERROR(EINVAL);",
          "new_line_content": "    if (ctx->crop_expr && sscanf(ctx->crop_expr, \"%dx%dx%dx%d\",",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": "sscanf",
          "new_api": "AVERROR",
          "old_text": "sscanf(ctx->crop_expr, \"%dx%dx%dx%d\",\n                                 &ctx->crop.top, &ctx->crop.bottom,\n                                 &ctx->crop.left, &ctx->crop.right)",
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    if (ctx->crop_expr && sscanf(ctx->crop_expr, \"%dx%dx%dx%d\",",
          "new_line_content": "        ret = AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": "AVERROR",
          "new_api": "cuvid_load_functions",
          "old_text": "AVERROR(EINVAL)",
          "new_text": "cuvid_load_functions(&ctx->cvdl, avctx)",
          "old_line_content": "        ret = AVERROR(EINVAL);",
          "new_line_content": "    ret = cuvid_load_functions(&ctx->cvdl, avctx);",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": "av_log",
          "new_api": "av_fifo_alloc",
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Failed loading nvcuvid.\\n\")",
          "new_text": "av_fifo_alloc(ctx->nb_surfaces * sizeof(CuvidParsedFrame))",
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Failed loading nvcuvid.\\n\");",
          "new_line_content": "    ctx->frame_queue = av_fifo_alloc(ctx->nb_surfaces * sizeof(CuvidParsedFrame));",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": "AVERROR",
          "new_api": "av_hwdevice_ctx_create",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "av_hwdevice_ctx_create(&ctx->hwdevice, AV_HWDEVICE_TYPE_CUDA, ctx->cu_gpu, NULL, 0)",
          "old_line_content": "                ret = AVERROR(ENOMEM);",
          "new_line_content": "            ret = av_hwdevice_ctx_create(&ctx->hwdevice, AV_HWDEVICE_TYPE_CUDA, ctx->cu_gpu, NULL, 0);",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": "av_bsf_alloc",
          "new_api": "av_bsf_free",
          "old_text": "av_bsf_alloc(bsf, &ctx->bsf)",
          "new_text": "av_bsf_free(&ctx->bsf)",
          "old_line_content": "        if (ret = av_bsf_alloc(bsf, &ctx->bsf)) {",
          "new_line_content": "            av_bsf_free(&ctx->bsf);",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "cuCtxPushCurrent",
          "new_api": "cuvid_test_capabilities",
          "old_text": "ctx->cudl->cuCtxPushCurrent(cuda_ctx)",
          "new_text": "cuvid_test_capabilities(avctx, &ctx->cuparseinfo,\n                                  probed_width,\n                                  probed_height,\n                                  probed_bit_depth)",
          "old_line_content": "    ret = CHECK_CU(ctx->cudl->cuCtxPushCurrent(cuda_ctx));",
          "new_line_content": "    ret = cuvid_test_capabilities(avctx, &ctx->cuparseinfo,",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": "cuCtxPushCurrent",
          "new_api": "av_fifo_freep",
          "old_text": "ctx->cudl->cuCtxPushCurrent(cuda_ctx)",
          "new_text": "av_fifo_freep(&ctx->frame_queue)",
          "old_line_content": "    ret = CHECK_CU(ctx->cudl->cuCtxPushCurrent(cuda_ctx));",
          "new_line_content": "    av_fifo_freep(&ctx->frame_queue);",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": "av_fifo_freep",
          "new_api": "av_log",
          "old_text": "av_fifo_freep(&ctx->frame_queue)",
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Failed to recreate frame queue on flush\\n\")",
          "old_line_content": "    av_fifo_freep(&ctx->frame_queue);",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Failed to recreate frame queue on flush\\n\");",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "cuvidDestroyVideoParser",
          "new_api": "cuvidCreateVideoParser",
          "old_text": "ctx->cvdl->cuvidDestroyVideoParser(ctx->cuparser)",
          "new_text": "ctx->cvdl->cuvidCreateVideoParser(&ctx->cuparser, &ctx->cuparseinfo)",
          "old_line_content": "        ctx->cvdl->cuvidDestroyVideoParser(ctx->cuparser);",
          "new_line_content": "    ret = CHECK_CU(ctx->cvdl->cuvidCreateVideoParser(&ctx->cuparser, &ctx->cuparseinfo));",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1028,
          "old_api": null,
          "new_api": "cuvidParseVideoData",
          "old_text": null,
          "new_text": "ctx->cvdl->cuvidParseVideoData(ctx->cuparser, &seq_pkt)",
          "old_line_content": "    seq_pkt.payload = ctx->cuparse_ext.raw_seqhdr_data;",
          "new_line_content": "        ret = CHECK_CU(ctx->cvdl->cuvidParseVideoData(ctx->cuparser, &seq_pkt));",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": null,
          "new_api": "cuCtxPopCurrent",
          "old_text": null,
          "new_text": "ctx->cudl->cuCtxPopCurrent(&dummy)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "    ret = CHECK_CU(ctx->cudl->cuCtxPopCurrent(&dummy));",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_WARNING, \"Invalid pkt_timebase, passing timestamps as-is.\\n\")",
          "old_line_content": "",
          "new_line_content": "        av_log(avctx, AV_LOG_WARNING, \"Invalid pkt_timebase, passing timestamps as-is.\\n\");",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": null,
          "new_api": "cuvid_decode_end",
          "old_text": null,
          "new_text": "cuvid_decode_end(avctx)",
          "old_line_content": "",
          "new_line_content": "    cuvid_decode_end(avctx);",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": null,
          "new_api": "cuCtxPushCurrent",
          "old_text": null,
          "new_text": "ctx->cudl->cuCtxPushCurrent(cuda_ctx)",
          "old_line_content": "    CUcontext dummy, cuda_ctx = device_hwctx->cuda_ctx;",
          "new_line_content": "    ret = CHECK_CU(ctx->cudl->cuCtxPushCurrent(cuda_ctx));",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": null,
          "new_api": "av_fifo_alloc",
          "old_text": null,
          "new_text": "av_fifo_alloc(ctx->nb_surfaces * sizeof(CuvidParsedFrame))",
          "old_line_content": "        goto error;",
          "new_line_content": "    ctx->frame_queue = av_fifo_alloc(ctx->nb_surfaces * sizeof(CuvidParsedFrame));",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": null,
          "new_api": "cuvidDestroyDecoder",
          "old_text": null,
          "new_text": "ctx->cvdl->cuvidDestroyDecoder(ctx->cudecoder)",
          "old_line_content": "        return;",
          "new_line_content": "        ctx->cvdl->cuvidDestroyDecoder(ctx->cudecoder);",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": null,
          "new_api": "av_frame_alloc",
          "old_text": null,
          "new_text": "av_frame_alloc()",
          "old_line_content": "                   avctx->pix_fmt == AV_PIX_FMT_P016      ||",
          "new_line_content": "            AVFrame *tmp_frame = av_frame_alloc();",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"av_frame_alloc failed\\n\")",
          "old_line_content": "                   avctx->pix_fmt == AV_PIX_FMT_YUV444P16) {",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"av_frame_alloc failed\\n\");",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "            unsigned int offset = 0;",
          "new_line_content": "                ret = AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": null,
          "new_api": "cuvidDestroyVideoParser",
          "old_text": null,
          "new_text": "ctx->cvdl->cuvidDestroyVideoParser(ctx->cuparser)",
          "old_line_content": "        ctx->cudecoder = NULL;",
          "new_line_content": "        ctx->cvdl->cuvidDestroyVideoParser(ctx->cuparser);",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "av_buffer_ref",
          "old_text": null,
          "new_text": "av_buffer_ref(ctx->hwframe)",
          "old_line_content": "",
          "new_line_content": "            tmp_frame->hw_frames_ctx = av_buffer_ref(ctx->hwframe);",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": null,
          "new_api": "cuvidParseVideoData",
          "old_text": null,
          "new_text": "ctx->cvdl->cuvidParseVideoData(ctx->cuparser, &seq_pkt)",
          "old_line_content": "    seq_pkt.payload = ctx->cuparse_ext.raw_seqhdr_data;",
          "new_line_content": "        ret = CHECK_CU(ctx->cvdl->cuvidParseVideoData(ctx->cuparser, &seq_pkt));",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": null,
          "new_api": "cuCtxPopCurrent",
          "old_text": null,
          "new_text": "ctx->cudl->cuCtxPopCurrent(&dummy)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "    ret = CHECK_CU(ctx->cudl->cuCtxPopCurrent(&dummy));",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": null,
          "new_api": "ff_get_buffer",
          "old_text": null,
          "new_text": "ff_get_buffer(avctx, frame, 0)",
          "old_line_content": "                tmp_frame->linesize[i] = pitch;",
          "new_line_content": "            ret = ff_get_buffer(avctx, frame, 0);",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"ff_get_buffer failed\\n\")",
          "old_line_content": "            }",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"ff_get_buffer failed\\n\");",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": null,
          "new_api": "av_frame_free",
          "old_text": null,
          "new_text": "av_frame_free(&tmp_frame)",
          "old_line_content": "",
          "new_line_content": "                av_frame_free(&tmp_frame);",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"CUDA reinit on flush failed\\n\")",
          "old_line_content": "    ctx->decoder_flushing = 0;",
          "new_line_content": "    av_log(avctx, AV_LOG_ERROR, \"CUDA reinit on flush failed\\n\");",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"av_hwframe_transfer_data failed\\n\")",
          "old_line_content": "            }",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"av_hwframe_transfer_data failed\\n\");",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": null,
          "new_api": "av_frame_free",
          "old_text": null,
          "new_text": "av_frame_free(&tmp_frame)",
          "old_line_content": "",
          "new_line_content": "                av_frame_free(&tmp_frame);",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": null,
          "new_api": "OFFSET",
          "old_text": null,
          "new_text": "OFFSET(deint_mode)",
          "old_line_content": "",
          "new_line_content": "    { \"deint\",    \"Set deinterlacing mode\", OFFSET(deint_mode), AV_OPT_TYPE_INT,   { .i64 = cudaVideoDeinterlaceMode_Weave    }, cudaVideoDeinterlaceMode_Weave, cudaVideoDeinterlaceMode_Adaptive, VD, \"deint\" },",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": null,
          "new_api": "OFFSET",
          "old_text": null,
          "new_text": "OFFSET(nb_surfaces)",
          "old_line_content": "    { \"weave\",    \"Weave deinterlacing (do nothing)\",        0, AV_OPT_TYPE_CONST, { .i64 = cudaVideoDeinterlaceMode_Weave    }, 0, 0, VD, \"deint\" },",
          "new_line_content": "    { \"surfaces\", \"Maximum surfaces to be used for decoding\", OFFSET(nb_surfaces), AV_OPT_TYPE_INT, { .i64 = 25 }, 0, INT_MAX, VD },",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": null,
          "new_api": "OFFSET",
          "old_text": null,
          "new_text": "OFFSET(drop_second_field)",
          "old_line_content": "    { \"bob\",      \"Bob deinterlacing\",                       0, AV_OPT_TYPE_CONST, { .i64 = cudaVideoDeinterlaceMode_Bob      }, 0, 0, VD, \"deint\" },",
          "new_line_content": "    { \"drop_second_field\", \"Drop second field when deinterlacing\", OFFSET(drop_second_field), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, VD },",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": null,
          "new_api": "OFFSET",
          "old_text": null,
          "new_text": "OFFSET(crop_expr)",
          "old_line_content": "    { \"adaptive\", \"Adaptive deinterlacing\",                  0, AV_OPT_TYPE_CONST, { .i64 = cudaVideoDeinterlaceMode_Adaptive }, 0, 0, VD, \"deint\" },",
          "new_line_content": "    { \"crop\",     \"Crop (top)x(bottom)x(left)x(right)\", OFFSET(crop_expr), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, VD },",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": null,
          "new_api": "av_rescale_q",
          "old_text": null,
          "new_text": "av_rescale_q(parsed_frame.dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase)",
          "old_line_content": "        frame->key_frame = ctx->key_frame[parsed_frame.dispinfo.picture_index];",
          "new_line_content": "            frame->pts = av_rescale_q(parsed_frame.dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase);",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EAGAIN)",
          "old_line_content": "            frame->top_field_first = parsed_frame.dispinfo.top_field_first;",
          "new_line_content": "        ret = AVERROR(EAGAIN);",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": null,
          "new_api": "cuvidUnmapVideoFrame",
          "old_text": null,
          "new_text": "ctx->cvdl->cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame)",
          "old_line_content": "    }",
          "new_line_content": "        eret = CHECK_CU(ctx->cvdl->cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame));",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": null,
          "new_api": "cuCtxPopCurrent",
          "old_text": null,
          "new_text": "ctx->cudl->cuCtxPopCurrent(&dummy)",
          "old_line_content": "error:",
          "new_line_content": "    eret = CHECK_CU(ctx->cudl->cuCtxPopCurrent(&dummy));",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": null,
          "new_api": "DEFINE_CUVID_CODEC",
          "old_text": null,
          "new_text": "DEFINE_CUVID_CODEC(hevc, HEVC)",
          "old_line_content": "        .wrapper_name   = \"cuvid\", \\",
          "new_line_content": "DEFINE_CUVID_CODEC(hevc, HEVC)",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_TRACE, \"cuvid_decode_frame\\n\")",
          "old_line_content": "    CuvidContext *ctx = avctx->priv_data;",
          "new_line_content": "    av_log(avctx, AV_LOG_TRACE, \"cuvid_decode_frame\\n\");",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Deinterlacing is not supported via the old API\\n\")",
          "old_line_content": "",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Deinterlacing is not supported via the old API\\n\");",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": null,
          "new_api": "cuvid_output_frame",
          "old_text": null,
          "new_text": "cuvid_output_frame(avctx, frame)",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "    ret = cuvid_output_frame(avctx, frame);",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EAGAIN)",
          "old_line_content": "            return ret;",
          "new_line_content": "    if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": null,
          "new_api": "av_fifo_freep",
          "old_text": null,
          "new_text": "av_fifo_freep(&ctx->frame_queue)",
          "old_line_content": "static av_cold int cuvid_decode_end(AVCodecContext *avctx)",
          "new_line_content": "    av_fifo_freep(&ctx->frame_queue);",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": null,
          "new_api": "av_bsf_free",
          "old_text": null,
          "new_text": "av_bsf_free(&ctx->bsf)",
          "old_line_content": "",
          "new_line_content": "        av_bsf_free(&ctx->bsf);",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": null,
          "new_api": "cuvidDestroyVideoParser",
          "old_text": null,
          "new_text": "ctx->cvdl->cuvidDestroyVideoParser(ctx->cuparser)",
          "old_line_content": "    if (ctx->bsf)",
          "new_line_content": "        ctx->cvdl->cuvidDestroyVideoParser(ctx->cuparser);",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": null,
          "new_api": "cuvidDestroyDecoder",
          "old_text": null,
          "new_text": "ctx->cvdl->cuvidDestroyDecoder(ctx->cudecoder)",
          "old_line_content": "    if (ctx->cuparser)",
          "new_line_content": "        ctx->cvdl->cuvidDestroyDecoder(ctx->cudecoder);",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": null,
          "new_api": "av_buffer_unref",
          "old_text": null,
          "new_text": "av_buffer_unref(&ctx->hwdevice)",
          "old_line_content": "",
          "new_line_content": "    av_buffer_unref(&ctx->hwdevice);",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&ctx->key_frame)",
          "old_line_content": "",
          "new_line_content": "    av_freep(&ctx->key_frame);",
          "content_same": false
        },
        {
          "line": 728,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_WARNING, \"Used Nvidia driver is too old to perform a capability check.\\n\")",
          "old_line_content": "    CUVIDDECODECAPS *caps;",
          "new_line_content": "        av_log(avctx, AV_LOG_WARNING, \"Used Nvidia driver is too old to perform a capability check.\\n\");",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_WARNING, \"The minimum required version is \"\n#if defined(_WIN32)",
          "old_line_content": "    int res8 = 0, res10 = 0, res12 = 0;",
          "new_line_content": "        av_log(avctx, AV_LOG_WARNING, \"The minimum required version is \"",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": null,
          "new_api": "defined",
          "old_text": null,
          "new_text": "defined(__CYGWIN__)",
          "old_line_content": "",
          "new_line_content": "#if defined(_WIN32) || defined(__CYGWIN__)",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": null,
          "new_api": "cuvidGetDecoderCaps",
          "old_text": null,
          "new_text": "ctx->cvdl->cuvidGetDecoderCaps(&ctx->caps8)",
          "old_line_content": "    ctx->caps8.nBitDepthMinus8 = 0;",
          "new_line_content": "    res8 = CHECK_CU(ctx->cvdl->cuvidGetDecoderCaps(&ctx->caps8));",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": null,
          "new_api": "cuvidGetDecoderCaps",
          "old_text": null,
          "new_text": "ctx->cvdl->cuvidGetDecoderCaps(&ctx->caps10)",
          "old_line_content": "    ctx->caps10.nBitDepthMinus8 = 2;",
          "new_line_content": "    res10 = CHECK_CU(ctx->cvdl->cuvidGetDecoderCaps(&ctx->caps10));",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": null,
          "new_api": "cuvidGetDecoderCaps",
          "old_text": null,
          "new_text": "ctx->cvdl->cuvidGetDecoderCaps(&ctx->caps12)",
          "old_line_content": "    ctx->caps12.nBitDepthMinus8 = 4;",
          "new_line_content": "    res12 = CHECK_CU(ctx->cvdl->cuvidGetDecoderCaps(&ctx->caps12));",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_VERBOSE, \"10 bit: supported: %d, min_width: %d, max_width: %d, min_height: %d, max_height: %d\\n\",\n           ctx->caps10.bIsSupported, ctx->caps10.nMinWidth, ctx->caps10.nMaxWidth, ctx->caps10.nMinHeight, ctx->caps10.nMaxHeight)",
          "old_line_content": "",
          "new_line_content": "    av_log(avctx, AV_LOG_VERBOSE, \"10 bit: supported: %d, min_width: %d, max_width: %d, min_height: %d, max_height: %d\\n\",",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Codec %s is not supported.\\n\", avctx->codec->name)",
          "old_line_content": "            return res8;",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Codec %s is not supported.\\n\", avctx->codec->name);",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    }",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "    }",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "",
          "new_line_content": "        return AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": null,
          "new_api": "av_pix_fmt_desc_get",
          "old_text": null,
          "new_text": "av_pix_fmt_desc_get(avctx->pix_fmt)",
          "old_line_content": "    int probed_width = avctx->coded_width ? avctx->coded_width : 1280;",
          "new_line_content": "    const AVPixFmtDescriptor *probe_desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": null,
          "new_api": "ff_get_format",
          "old_text": null,
          "new_text": "ff_get_format(avctx, pix_fmts)",
          "old_line_content": "    // Accelerated transcoding scenarios with 'ffmpeg' require that the",
          "new_line_content": "    ret = ff_get_format(avctx, pix_fmts);",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"ff_get_format failed: %d\\n\", ret)",
          "old_line_content": "    // pix_fmt for non-accelerated transcoding, do not need to be correct",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"ff_get_format failed: %d\\n\", ret);",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": null,
          "new_api": "sscanf",
          "old_text": null,
          "new_text": "sscanf(ctx->resize_expr, \"%dx%d\",\n                                   &ctx->resize.width, &ctx->resize.height)",
          "old_line_content": "        return ret;",
          "new_line_content": "    if (ctx->resize_expr && sscanf(ctx->resize_expr, \"%dx%d\",",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Invalid resize expressions\\n\")",
          "old_line_content": "    avctx->pix_fmt = ret;",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Invalid resize expressions\\n\");",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(EINVAL)",
          "old_line_content": "",
          "new_line_content": "        ret = AVERROR(EINVAL);",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Invalid cropping expressions\\n\")",
          "old_line_content": "",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Invalid cropping expressions\\n\");",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Failed loading nvcuvid.\\n\")",
          "old_line_content": "    }",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Failed loading nvcuvid.\\n\");",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    }",
          "new_line_content": "        ret = AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": null,
          "new_api": "av_buffer_ref",
          "old_text": null,
          "new_text": "av_buffer_ref(avctx->hw_frames_ctx)",
          "old_line_content": "        goto error;",
          "new_line_content": "        ctx->hwframe = av_buffer_ref(avctx->hw_frames_ctx);",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "",
          "new_line_content": "            ret = AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": null,
          "new_api": "av_buffer_ref",
          "old_text": null,
          "new_text": "av_buffer_ref(hwframe_ctx->device_ref)",
          "old_line_content": "        }",
          "new_line_content": "        ctx->hwdevice = av_buffer_ref(hwframe_ctx->device_ref);",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "        hwframe_ctx = (AVHWFramesContext*)ctx->hwframe->data;",
          "new_line_content": "            ret = AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": null,
          "new_api": "av_buffer_ref",
          "old_text": null,
          "new_text": "av_buffer_ref(avctx->hw_device_ctx)",
          "old_line_content": "            goto error;",
          "new_line_content": "            ctx->hwdevice = av_buffer_ref(avctx->hw_device_ctx);",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    } else {",
          "new_line_content": "                ret = AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": null,
          "new_api": "av_hwframe_ctx_alloc",
          "old_text": null,
          "new_text": "av_hwframe_ctx_alloc(ctx->hwdevice)",
          "old_line_content": "            if (ret < 0)",
          "new_line_content": "        ctx->hwframe = av_hwframe_ctx_alloc(ctx->hwdevice);",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"av_hwframe_ctx_alloc failed\\n\")",
          "old_line_content": "        }",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"av_hwframe_ctx_alloc failed\\n\");",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "",
          "new_line_content": "            ret = AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 910,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(&ctx->cuparseinfo, 0, sizeof(ctx->cuparseinfo))",
          "old_line_content": "",
          "new_line_content": "    memset(&ctx->cuparseinfo, 0, sizeof(ctx->cuparseinfo));",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(&ctx->cuparse_ext, 0, sizeof(ctx->cuparse_ext))",
          "old_line_content": "    cuda_ctx = device_hwctx->cuda_ctx;",
          "new_line_content": "    memset(&ctx->cuparse_ext, 0, sizeof(ctx->cuparse_ext));",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(&seq_pkt, 0, sizeof(seq_pkt))",
          "old_line_content": "    ctx->cudl = device_hwctx->internal->cuda_dl;",
          "new_line_content": "    memset(&seq_pkt, 0, sizeof(seq_pkt));",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Invalid CUVID codec!\\n\")",
          "old_line_content": "        ctx->cuparseinfo.CodecType = cudaVideoCodec_VC1;",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Invalid CUVID codec!\\n\");",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": null,
          "new_api": "av_bsf_get_by_name",
          "old_text": null,
          "new_text": "av_bsf_get_by_name(\"h264_mp4toannexb\")",
          "old_line_content": "    }",
          "new_line_content": "            bsf = av_bsf_get_by_name(\"h264_mp4toannexb\");",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": null,
          "new_api": "av_bsf_get_by_name",
          "old_text": null,
          "new_text": "av_bsf_get_by_name(\"hevc_mp4toannexb\")",
          "old_line_content": "    if (avctx->codec->id == AV_CODEC_ID_H264 || avctx->codec->id == AV_CODEC_ID_HEVC) {",
          "new_line_content": "            bsf = av_bsf_get_by_name(\"hevc_mp4toannexb\");",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": null,
          "new_api": "av_bsf_alloc",
          "old_text": null,
          "new_text": "av_bsf_alloc(bsf, &ctx->bsf)",
          "old_line_content": "        if (!bsf) {",
          "new_line_content": "        if (ret = av_bsf_alloc(bsf, &ctx->bsf)) {",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": null,
          "new_api": "av_bsf_init",
          "old_text": null,
          "new_text": "av_bsf_init(ctx->bsf)",
          "old_line_content": "        }",
          "new_line_content": "        if (((ret = avcodec_parameters_from_context(ctx->bsf->par_in, avctx)) < 0) || ((ret = av_bsf_init(ctx->bsf)) < 0)) {",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(ctx->cuparse_ext.raw_seqhdr_data,\n               ctx->bsf->par_out->extradata,\n               FFMIN(sizeof(ctx->cuparse_ext.raw_seqhdr_data), ctx->bsf->par_out->extradata_size))",
          "old_line_content": "            goto error;",
          "new_line_content": "        memcpy(ctx->cuparse_ext.raw_seqhdr_data,",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(sizeof(ctx->cuparse_ext.raw_seqhdr_data), ctx->bsf->par_out->extradata_size)",
          "old_line_content": "",
          "new_line_content": "               FFMIN(sizeof(ctx->cuparse_ext.raw_seqhdr_data), ctx->bsf->par_out->extradata_size));",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(ctx->cuparse_ext.raw_seqhdr_data,\n               avctx->extradata,\n               FFMIN(sizeof(ctx->cuparse_ext.raw_seqhdr_data), avctx->extradata_size))",
          "old_line_content": "               ctx->bsf->par_out->extradata,",
          "new_line_content": "        memcpy(ctx->cuparse_ext.raw_seqhdr_data,",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(sizeof(ctx->cuparse_ext.raw_seqhdr_data), avctx->extradata_size)",
          "old_line_content": "    } else if (avctx->extradata_size > 0) {",
          "new_line_content": "               FFMIN(sizeof(ctx->cuparse_ext.raw_seqhdr_data), avctx->extradata_size));",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": null,
          "new_api": "av_mallocz",
          "old_text": null,
          "new_text": "av_mallocz(ctx->nb_surfaces * sizeof(int))",
          "old_line_content": "               avctx->extradata,",
          "new_line_content": "    ctx->key_frame = av_mallocz(ctx->nb_surfaces * sizeof(int));",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    }",
          "new_line_content": "        ret = AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": null,
          "new_api": "cuCtxPushCurrent",
          "old_text": null,
          "new_text": "ctx->cudl->cuCtxPushCurrent(cuda_ctx)",
          "old_line_content": "    ctx->cuparseinfo.pfnSequenceCallback = cuvid_handle_video_sequence;",
          "new_line_content": "    ret = CHECK_CU(ctx->cudl->cuCtxPushCurrent(cuda_ctx));",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": null,
          "new_api": "cuvidCreateVideoParser",
          "old_text": null,
          "new_text": "ctx->cvdl->cuvidCreateVideoParser(&ctx->cuparser, &ctx->cuparseinfo)",
          "old_line_content": "                                  probed_bit_depth);",
          "new_line_content": "    ret = CHECK_CU(ctx->cvdl->cuvidCreateVideoParser(&ctx->cuparser, &ctx->cuparseinfo));",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1024,
          "old_api": "cuvidCreateVideoParser",
          "new_api": null,
          "old_text": "ctx->cvdl->cuvidCreateVideoParser(&ctx->cuparser, &ctx->cuparseinfo)",
          "new_text": null,
          "old_line_content": "    ret = CHECK_CU(ctx->cvdl->cuvidCreateVideoParser(&ctx->cuparser, &ctx->cuparseinfo));",
          "new_line_content": "    seq_pkt.payload = ctx->cuparse_ext.raw_seqhdr_data;",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": "cuvidParseVideoData",
          "new_api": null,
          "old_text": "ctx->cvdl->cuvidParseVideoData(ctx->cuparser, &seq_pkt)",
          "new_text": null,
          "old_line_content": "        ret = CHECK_CU(ctx->cvdl->cuvidParseVideoData(ctx->cuparser, &seq_pkt));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": "cuCtxPopCurrent",
          "new_api": null,
          "old_text": "ctx->cudl->cuCtxPopCurrent(&dummy)",
          "new_text": null,
          "old_line_content": "    ret = CHECK_CU(ctx->cudl->cuCtxPopCurrent(&dummy));",
          "new_line_content": "    ctx->prev_pts = INT64_MIN;",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_WARNING, \"Invalid pkt_timebase, passing timestamps as-is.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_WARNING, \"Invalid pkt_timebase, passing timestamps as-is.\\n\");",
          "new_line_content": "error:",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": "cuvid_decode_end",
          "new_api": null,
          "old_text": "cuvid_decode_end(avctx)",
          "new_text": null,
          "old_line_content": "    cuvid_decode_end(avctx);",
          "new_line_content": "static void cuvid_flush(AVCodecContext *avctx)",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": "av_fifo_alloc",
          "new_api": null,
          "old_text": "av_fifo_alloc(ctx->nb_surfaces * sizeof(CuvidParsedFrame))",
          "new_text": null,
          "old_line_content": "    ctx->frame_queue = av_fifo_alloc(ctx->nb_surfaces * sizeof(CuvidParsedFrame));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": "cuStreamSynchronize",
          "new_api": null,
          "old_text": "ctx->cudl->cuStreamSynchronize(device_hwctx->stream)",
          "new_text": null,
          "old_line_content": "            ret = CHECK_CU(ctx->cudl->cuStreamSynchronize(device_hwctx->stream));",
          "new_line_content": "                   avctx->pix_fmt == AV_PIX_FMT_P010      ||",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Failed to recreate frame queue on flush\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Failed to recreate frame queue on flush\\n\");",
          "new_line_content": "    if (ctx->cudecoder) {",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": "cuvidDestroyDecoder",
          "new_api": null,
          "old_text": "ctx->cvdl->cuvidDestroyDecoder(ctx->cudecoder)",
          "new_text": null,
          "old_line_content": "        ctx->cvdl->cuvidDestroyDecoder(ctx->cudecoder);",
          "new_line_content": "    if (ctx->cuparser) {",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": "av_frame_alloc",
          "new_api": null,
          "old_text": "av_frame_alloc()",
          "new_text": null,
          "old_line_content": "            AVFrame *tmp_frame = av_frame_alloc();",
          "new_line_content": "                goto error;",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"av_frame_alloc failed\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"av_frame_alloc failed\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": "cuvidCreateVideoParser",
          "new_api": null,
          "old_text": "ctx->cvdl->cuvidCreateVideoParser(&ctx->cuparser, &ctx->cuparseinfo)",
          "new_text": null,
          "old_line_content": "    ret = CHECK_CU(ctx->cvdl->cuvidCreateVideoParser(&ctx->cuparser, &ctx->cuparseinfo));",
          "new_line_content": "    seq_pkt.payload = ctx->cuparse_ext.raw_seqhdr_data;",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "av_pix_fmt_desc_get",
          "new_api": null,
          "old_text": "av_pix_fmt_desc_get(avctx->sw_pix_fmt)",
          "new_text": null,
          "old_line_content": "            pixdesc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);",
          "new_line_content": "            tmp_frame->width         = avctx->width;",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "av_buffer_ref",
          "new_api": null,
          "old_text": "av_buffer_ref(ctx->hwframe)",
          "new_text": null,
          "old_line_content": "            tmp_frame->hw_frames_ctx = av_buffer_ref(ctx->hwframe);",
          "new_line_content": "            /*",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": "cuvidParseVideoData",
          "new_api": null,
          "old_text": "ctx->cvdl->cuvidParseVideoData(ctx->cuparser, &seq_pkt)",
          "new_text": null,
          "old_line_content": "        ret = CHECK_CU(ctx->cvdl->cuvidParseVideoData(ctx->cuparser, &seq_pkt));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": "cuCtxPopCurrent",
          "new_api": null,
          "old_text": "ctx->cudl->cuCtxPopCurrent(&dummy)",
          "new_text": null,
          "old_line_content": "    ret = CHECK_CU(ctx->cudl->cuCtxPopCurrent(&dummy));",
          "new_line_content": "    ctx->prev_pts = INT64_MIN;",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": "ff_get_buffer",
          "new_api": null,
          "old_text": "ff_get_buffer(avctx, frame, 0)",
          "new_text": null,
          "old_line_content": "            ret = ff_get_buffer(avctx, frame, 0);",
          "new_line_content": "                goto error;",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"ff_get_buffer failed\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"ff_get_buffer failed\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"CUDA reinit on flush failed\\n\")",
          "new_text": null,
          "old_line_content": "    av_log(avctx, AV_LOG_ERROR, \"CUDA reinit on flush failed\\n\");",
          "new_line_content": "#define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": "av_hwframe_transfer_data",
          "new_api": null,
          "old_text": "av_hwframe_transfer_data(frame, tmp_frame, 0)",
          "new_text": null,
          "old_line_content": "            ret = av_hwframe_transfer_data(frame, tmp_frame, 0);",
          "new_line_content": "                goto error;",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": "av_frame_free",
          "new_api": null,
          "old_text": "av_frame_free(&tmp_frame)",
          "new_text": null,
          "old_line_content": "                av_frame_free(&tmp_frame);",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": "av_frame_free",
          "new_api": null,
          "old_text": "av_frame_free(&tmp_frame)",
          "new_text": null,
          "old_line_content": "            av_frame_free(&tmp_frame);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": "OFFSET",
          "new_api": null,
          "old_text": "OFFSET(nb_surfaces)",
          "new_text": null,
          "old_line_content": "    { \"surfaces\", \"Maximum surfaces to be used for decoding\", OFFSET(nb_surfaces), AV_OPT_TYPE_INT, { .i64 = 25 }, 0, INT_MAX, VD },",
          "new_line_content": "    { NULL }",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": "OFFSET",
          "new_api": null,
          "old_text": "OFFSET(drop_second_field)",
          "new_text": null,
          "old_line_content": "    { \"drop_second_field\", \"Drop second field when deinterlacing\", OFFSET(drop_second_field), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, VD },",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": "OFFSET",
          "new_api": null,
          "old_text": "OFFSET(crop_expr)",
          "new_text": null,
          "old_line_content": "    { \"crop\",     \"Crop (top)x(bottom)x(left)x(right)\", OFFSET(crop_expr), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, VD },",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": "OFFSET",
          "new_api": null,
          "old_text": "OFFSET(resize_expr)",
          "new_text": null,
          "old_line_content": "    { \"resize\",   \"Resize (width)x(height)\", OFFSET(resize_expr), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, VD },",
          "new_line_content": "static const AVCodecHWConfigInternal *cuvid_hw_configs[] = {",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": "av_rescale_q",
          "new_api": null,
          "old_text": "av_rescale_q(parsed_frame.dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase)",
          "new_text": null,
          "old_line_content": "            frame->pts = av_rescale_q(parsed_frame.dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase);",
          "new_line_content": "        if (parsed_frame.second_field) {",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EAGAIN)",
          "new_text": null,
          "old_line_content": "        ret = AVERROR(EAGAIN);",
          "new_line_content": "    if (mapped_frame)",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": "cuvidUnmapVideoFrame",
          "new_api": null,
          "old_text": "ctx->cvdl->cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame)",
          "new_text": null,
          "old_line_content": "        eret = CHECK_CU(ctx->cvdl->cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame));",
          "new_line_content": "    if (eret < 0)",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": "cuCtxPopCurrent",
          "new_api": null,
          "old_text": "ctx->cudl->cuCtxPopCurrent(&dummy)",
          "new_text": null,
          "old_line_content": "    eret = CHECK_CU(ctx->cudl->cuCtxPopCurrent(&dummy));",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Deinterlacing is not supported via the old API\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Deinterlacing is not supported via the old API\\n\");",
          "new_line_content": "    if (!ctx->decoder_flushing) {",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": "cuvid_decode_packet",
          "new_api": null,
          "old_text": "cuvid_decode_packet(avctx, avpkt)",
          "new_text": null,
          "old_line_content": "        ret = cuvid_decode_packet(avctx, avpkt);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": "cuvid_output_frame",
          "new_api": null,
          "old_text": "cuvid_output_frame(avctx, frame)",
          "new_text": null,
          "old_line_content": "    ret = cuvid_output_frame(avctx, frame);",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EAGAIN)",
          "new_text": null,
          "old_line_content": "    if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": "DEFINE_CUVID_CODEC",
          "new_api": null,
          "old_text": "DEFINE_CUVID_CODEC(vc1, VC1)",
          "new_text": null,
          "old_line_content": "DEFINE_CUVID_CODEC(vc1, VC1)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": "av_fifo_freep",
          "new_api": null,
          "old_text": "av_fifo_freep(&ctx->frame_queue)",
          "new_text": null,
          "old_line_content": "    av_fifo_freep(&ctx->frame_queue);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": "av_bsf_free",
          "new_api": null,
          "old_text": "av_bsf_free(&ctx->bsf)",
          "new_text": null,
          "old_line_content": "        av_bsf_free(&ctx->bsf);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 704,
          "old_api": "cuvidDestroyVideoParser",
          "new_api": null,
          "old_text": "ctx->cvdl->cuvidDestroyVideoParser(ctx->cuparser)",
          "new_text": null,
          "old_line_content": "        ctx->cvdl->cuvidDestroyVideoParser(ctx->cuparser);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "av_buffer_unref",
          "new_api": null,
          "old_text": "av_buffer_unref(&ctx->hwframe)",
          "new_text": null,
          "old_line_content": "    av_buffer_unref(&ctx->hwframe);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&ctx->key_frame)",
          "new_text": null,
          "old_line_content": "    av_freep(&ctx->key_frame);",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": "cuvid_free_functions",
          "new_api": null,
          "old_text": "cuvid_free_functions(&ctx->cvdl)",
          "new_text": null,
          "old_line_content": "    cuvid_free_functions(&ctx->cvdl);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_WARNING, \"Used Nvidia driver is too old to perform a capability check.\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_WARNING, \"Used Nvidia driver is too old to perform a capability check.\\n\");",
          "new_line_content": "#else",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_WARNING, \"The minimum required version is \"\n#if defined(_WIN32)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_WARNING, \"The minimum required version is \"",
          "new_line_content": "            \"378.13\"",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": "defined",
          "new_api": null,
          "old_text": "defined(__CYGWIN__)",
          "new_text": null,
          "old_line_content": "#if defined(_WIN32) || defined(__CYGWIN__)",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "cuvidGetDecoderCaps",
          "new_api": null,
          "old_text": "ctx->cvdl->cuvidGetDecoderCaps(&ctx->caps12)",
          "new_text": null,
          "old_line_content": "    res12 = CHECK_CU(ctx->cvdl->cuvidGetDecoderCaps(&ctx->caps12));",
          "new_line_content": "           ctx->caps8.bIsSupported, ctx->caps8.nMinWidth, ctx->caps8.nMaxWidth, ctx->caps8.nMinHeight, ctx->caps8.nMaxHeight);",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_VERBOSE, \"CUVID capabilities for %s:\\n\", avctx->codec->name)",
          "new_text": null,
          "old_line_content": "    av_log(avctx, AV_LOG_VERBOSE, \"CUVID capabilities for %s:\\n\", avctx->codec->name);",
          "new_line_content": "           ctx->caps10.bIsSupported, ctx->caps10.nMinWidth, ctx->caps10.nMaxWidth, ctx->caps10.nMinHeight, ctx->caps10.nMaxHeight);",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_VERBOSE, \"10 bit: supported: %d, min_width: %d, max_width: %d, min_height: %d, max_height: %d\\n\",\n           ctx->caps10.bIsSupported, ctx->caps10.nMinWidth, ctx->caps10.nMaxWidth, ctx->caps10.nMinHeight, ctx->caps10.nMaxHeight)",
          "new_text": null,
          "old_line_content": "    av_log(avctx, AV_LOG_VERBOSE, \"10 bit: supported: %d, min_width: %d, max_width: %d, min_height: %d, max_height: %d\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_VERBOSE, \"12 bit: supported: %d, min_width: %d, max_width: %d, min_height: %d, max_height: %d\\n\",\n           ctx->caps12.bIsSupported, ctx->caps12.nMinWidth, ctx->caps12.nMaxWidth, ctx->caps12.nMinHeight, ctx->caps12.nMaxHeight)",
          "new_text": null,
          "old_line_content": "    av_log(avctx, AV_LOG_VERBOSE, \"12 bit: supported: %d, min_width: %d, max_width: %d, min_height: %d, max_height: %d\\n\",",
          "new_line_content": "    case 10:",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Codec %s is not supported.\\n\", avctx->codec->name)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Codec %s is not supported.\\n\", avctx->codec->name);",
          "new_line_content": "    if (!caps->bIsSupported) {",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Bit depth %d is not supported.\\n\", bit_depth)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Bit depth %d is not supported.\\n\", bit_depth);",
          "new_line_content": "    if (probed_width > caps->nMaxWidth || probed_width < caps->nMinWidth) {",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Video width %d not within range from %d to %d\\n\",\n               probed_width, caps->nMinWidth, caps->nMaxWidth)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Video width %d not within range from %d to %d\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Video height %d not within range from %d to %d\\n\",\n               probed_height, caps->nMinHeight, caps->nMaxHeight)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Video height %d not within range from %d to %d\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "av_pix_fmt_desc_get",
          "new_api": null,
          "old_text": "av_pix_fmt_desc_get(avctx->pix_fmt)",
          "new_text": null,
          "old_line_content": "    const AVPixFmtDescriptor *probe_desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "new_line_content": "    // Accelerated transcoding scenarios with 'ffmpeg' require that the",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": "ff_get_format",
          "new_api": null,
          "old_text": "ff_get_format(avctx, pix_fmts)",
          "new_text": null,
          "old_line_content": "    ret = ff_get_format(avctx, pix_fmts);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"ff_get_format failed: %d\\n\", ret)",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"ff_get_format failed: %d\\n\", ret);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": "sscanf",
          "new_api": null,
          "old_text": "sscanf(ctx->resize_expr, \"%dx%d\",\n                                   &ctx->resize.width, &ctx->resize.height)",
          "new_text": null,
          "old_line_content": "    if (ctx->resize_expr && sscanf(ctx->resize_expr, \"%dx%d\",",
          "new_line_content": "        goto error;",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Invalid resize expressions\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Invalid resize expressions\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Invalid cropping expressions\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Invalid cropping expressions\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": "cuvid_load_functions",
          "new_api": null,
          "old_text": "cuvid_load_functions(&ctx->cvdl, avctx)",
          "new_text": null,
          "old_line_content": "    ret = cuvid_load_functions(&ctx->cvdl, avctx);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "av_fifo_alloc",
          "new_api": null,
          "old_text": "av_fifo_alloc(ctx->nb_surfaces * sizeof(CuvidParsedFrame))",
          "new_text": null,
          "old_line_content": "    ctx->frame_queue = av_fifo_alloc(ctx->nb_surfaces * sizeof(CuvidParsedFrame));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        ret = AVERROR(ENOMEM);",
          "new_line_content": "    if (avctx->hw_frames_ctx) {",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "av_buffer_ref",
          "new_api": null,
          "old_text": "av_buffer_ref(avctx->hw_frames_ctx)",
          "new_text": null,
          "old_line_content": "        ctx->hwframe = av_buffer_ref(avctx->hw_frames_ctx);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "            ret = AVERROR(ENOMEM);",
          "new_line_content": "        hwframe_ctx = (AVHWFramesContext*)ctx->hwframe->data;",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": "av_buffer_ref",
          "new_api": null,
          "old_text": "av_buffer_ref(hwframe_ctx->device_ref)",
          "new_text": null,
          "old_line_content": "        ctx->hwdevice = av_buffer_ref(hwframe_ctx->device_ref);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "            ret = AVERROR(ENOMEM);",
          "new_line_content": "        if (avctx->hw_device_ctx) {",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "av_buffer_ref",
          "new_api": null,
          "old_text": "av_buffer_ref(avctx->hw_device_ctx)",
          "new_text": null,
          "old_line_content": "            ctx->hwdevice = av_buffer_ref(avctx->hw_device_ctx);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": "av_hwdevice_ctx_create",
          "new_api": null,
          "old_text": "av_hwdevice_ctx_create(&ctx->hwdevice, AV_HWDEVICE_TYPE_CUDA, ctx->cu_gpu, NULL, 0)",
          "new_text": null,
          "old_line_content": "            ret = av_hwdevice_ctx_create(&ctx->hwdevice, AV_HWDEVICE_TYPE_CUDA, ctx->cu_gpu, NULL, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": "av_hwframe_ctx_alloc",
          "new_api": null,
          "old_text": "av_hwframe_ctx_alloc(ctx->hwdevice)",
          "new_text": null,
          "old_line_content": "        ctx->hwframe = av_hwframe_ctx_alloc(ctx->hwdevice);",
          "new_line_content": "            goto error;",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"av_hwframe_ctx_alloc failed\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"av_hwframe_ctx_alloc failed\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "            ret = AVERROR(ENOMEM);",
          "new_line_content": "        hwframe_ctx = (AVHWFramesContext*)ctx->hwframe->data;",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(&ctx->cuparseinfo, 0, sizeof(ctx->cuparseinfo))",
          "new_text": null,
          "old_line_content": "    memset(&ctx->cuparseinfo, 0, sizeof(ctx->cuparseinfo));",
          "new_line_content": "    ctx->cuparseinfo.pExtVideoInfo = &ctx->cuparse_ext;",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(&ctx->cuparse_ext, 0, sizeof(ctx->cuparse_ext))",
          "new_text": null,
          "old_line_content": "    memset(&ctx->cuparse_ext, 0, sizeof(ctx->cuparse_ext));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(&seq_pkt, 0, sizeof(seq_pkt))",
          "new_text": null,
          "old_line_content": "    memset(&seq_pkt, 0, sizeof(seq_pkt));",
          "new_line_content": "    switch (avctx->codec->id) {",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Invalid CUVID codec!\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Invalid CUVID codec!\\n\");",
          "new_line_content": "    if (avctx->codec->id == AV_CODEC_ID_H264 || avctx->codec->id == AV_CODEC_ID_HEVC) {",
          "content_same": false
        },
        {
          "line": 973,
          "old_api": "av_bsf_get_by_name",
          "new_api": null,
          "old_text": "av_bsf_get_by_name(\"h264_mp4toannexb\")",
          "new_text": null,
          "old_line_content": "            bsf = av_bsf_get_by_name(\"h264_mp4toannexb\");",
          "new_line_content": "        if (!bsf) {",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": "av_bsf_get_by_name",
          "new_api": null,
          "old_text": "av_bsf_get_by_name(\"hevc_mp4toannexb\")",
          "new_text": null,
          "old_line_content": "            bsf = av_bsf_get_by_name(\"hevc_mp4toannexb\");",
          "new_line_content": "            goto error;",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": "av_bsf_init",
          "new_api": null,
          "old_text": "av_bsf_init(ctx->bsf)",
          "new_text": null,
          "old_line_content": "        if (((ret = avcodec_parameters_from_context(ctx->bsf->par_in, avctx)) < 0) || ((ret = av_bsf_init(ctx->bsf)) < 0)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": "av_bsf_free",
          "new_api": null,
          "old_text": "av_bsf_free(&ctx->bsf)",
          "new_text": null,
          "old_line_content": "            av_bsf_free(&ctx->bsf);",
          "new_line_content": "        ctx->cuparse_ext.format.seqhdr_data_length = ctx->bsf->par_out->extradata_size;",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(ctx->cuparse_ext.raw_seqhdr_data,\n               ctx->bsf->par_out->extradata,\n               FFMIN(sizeof(ctx->cuparse_ext.raw_seqhdr_data), ctx->bsf->par_out->extradata_size))",
          "new_text": null,
          "old_line_content": "        memcpy(ctx->cuparse_ext.raw_seqhdr_data,",
          "new_line_content": "        ctx->cuparse_ext.format.seqhdr_data_length = avctx->extradata_size;",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(sizeof(ctx->cuparse_ext.raw_seqhdr_data), ctx->bsf->par_out->extradata_size)",
          "new_text": null,
          "old_line_content": "               FFMIN(sizeof(ctx->cuparse_ext.raw_seqhdr_data), ctx->bsf->par_out->extradata_size));",
          "new_line_content": "               avctx->extradata,",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(ctx->cuparse_ext.raw_seqhdr_data,\n               avctx->extradata,\n               FFMIN(sizeof(ctx->cuparse_ext.raw_seqhdr_data), avctx->extradata_size))",
          "new_text": null,
          "old_line_content": "        memcpy(ctx->cuparse_ext.raw_seqhdr_data,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(sizeof(ctx->cuparse_ext.raw_seqhdr_data), avctx->extradata_size)",
          "new_text": null,
          "old_line_content": "               FFMIN(sizeof(ctx->cuparse_ext.raw_seqhdr_data), avctx->extradata_size));",
          "new_line_content": "    if (!ctx->key_frame) {",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": "av_mallocz",
          "new_api": null,
          "old_text": "av_mallocz(ctx->nb_surfaces * sizeof(int))",
          "new_text": null,
          "old_line_content": "    ctx->key_frame = av_mallocz(ctx->nb_surfaces * sizeof(int));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "        ret = AVERROR(ENOMEM);",
          "new_line_content": "    ctx->cuparseinfo.ulMaxNumDecodeSurfaces = ctx->nb_surfaces;",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": "cuvid_test_capabilities",
          "new_api": null,
          "old_text": "cuvid_test_capabilities(avctx, &ctx->cuparseinfo,\n                                  probed_width,\n                                  probed_height,\n                                  probed_bit_depth)",
          "new_text": null,
          "old_line_content": "    ret = cuvid_test_capabilities(avctx, &ctx->cuparseinfo,",
          "new_line_content": "    if (ret < 0)",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 22,
      "total_additions": 85,
      "total_deletions": 86,
      "total_api_changes": 193
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 4,
        "api_related_lines": 193,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          556,
          558,
          559
        ]
      }
    },
    "api_calls_before": 220,
    "api_calls_after": 218,
    "diff_info": {
      "added_lines": 0,
      "removed_lines": 4,
      "total_diff_lines": 16
    }
  }
}