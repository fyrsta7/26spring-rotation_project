{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/2773920698beab30525bbd7249655f3223874d65",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/2773920698beab30525bbd7249655f3223874d65/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/2773920698beab30525bbd7249655f3223874d65/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/2773920698beab30525bbd7249655f3223874d65/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 737,
          "old_api": "IS_INTRA4x4",
          "new_api": "get_cabac_noinline",
          "old_text": "IS_INTRA4x4( s->current_picture.mb_type[mbb_xy] )",
          "new_text": "get_cabac_noinline( &h->cabac, state )",
          "old_line_content": "        if( h->slice_table[mbb_xy] == h->slice_num && !IS_INTRA4x4( s->current_picture.mb_type[mbb_xy] ) )",
          "new_line_content": "        if( get_cabac_noinline( &h->cabac, state ) == 0 )",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": "get_cabac_terminate",
          "new_api": "get_cabac_noinline",
          "old_text": "get_cabac_terminate( &h->cabac )",
          "new_text": "get_cabac_noinline( &h->cabac, &state[2+intra_slice] )",
          "old_line_content": "    if( get_cabac_terminate( &h->cabac ) )",
          "new_line_content": "        mb_type += 4 + 4 * get_cabac_noinline( &h->cabac, &state[2+intra_slice] );",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "IS_DIRECT",
          "new_api": "get_cabac_noinline",
          "old_text": "IS_DIRECT( s->current_picture.mb_type[mbb_xy] )",
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+3] )",
          "old_line_content": "        if( h->slice_table[mbb_xy] == h->slice_num && !IS_DIRECT( s->current_picture.mb_type[mbb_xy] ) )",
          "new_line_content": "        if( !get_cabac_noinline( &h->cabac, &h->cabac_state[27+3] ) ) {",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "get_cabac_noinline",
          "new_api": "decode_cabac_intra_mb_type",
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] )",
          "new_text": "decode_cabac_intra_mb_type(h, 32, 0)",
          "old_line_content": "        bits|= get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] ) << 2;",
          "new_line_content": "            return decode_cabac_intra_mb_type(h, 32, 0) + 23;",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": "decode_cabac_intra_mb_type",
          "new_api": "get_cabac_noinline",
          "old_text": "decode_cabac_intra_mb_type(h, 32, 0)",
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] )",
          "old_line_content": "            return decode_cabac_intra_mb_type(h, 32, 0) + 23;",
          "new_line_content": "        bits= ( bits<<1 ) | get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] );",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": "get_cabac_noinline",
          "new_api": "get_cabac",
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[11+ctx] )",
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[68] )",
          "old_line_content": "    return get_cabac_noinline( &h->cabac, &h->cabac_state[11+ctx] );",
          "new_line_content": "    if( get_cabac( &h->cabac, &h->cabac_state[68] ) )",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "get_cabac",
          "new_api": "get_cabac_noinline",
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[39] )",
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[399 + h->neighbor_transform_size] )",
          "old_line_content": "    type += 2*get_cabac( &h->cabac, &h->cabac_state[39] );",
          "new_line_content": "    return get_cabac_noinline( &h->cabac, &h->cabac_state[399 + h->neighbor_transform_size] );",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "abs",
          "new_api": "get_cabac",
          "old_text": "abs( h->mvd_cache[list][scan8[n] - 1][l] )",
          "new_text": "get_cabac(&h->cabac, &h->cabac_state[ctxbase+ctx])",
          "old_line_content": "    int amvd = abs( h->mvd_cache[list][scan8[n] - 1][l] ) +",
          "new_line_content": "    if(!get_cabac(&h->cabac, &h->cabac_state[ctxbase+ctx]))",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": "decode_significance_8x8_x86",
          "new_api": "DECODE_SIGNIFICANCE",
          "old_text": "decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index, sig_off)",
          "new_text": "DECODE_SIGNIFICANCE( max_coeff - 1, last, last )",
          "old_line_content": "        coeff_count= decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index, sig_off);",
          "new_line_content": "        DECODE_SIGNIFICANCE( max_coeff - 1, last, last );",
          "content_same": false
        },
        {
          "line": 1200,
          "old_api": "get_cabac",
          "new_api": "get_cabac_bypass",
          "old_text": "get_cabac( CC, ctx )",
          "new_text": "get_cabac_bypass( CC )",
          "old_line_content": "            while( coeff_abs < 15 && get_cabac( CC, ctx ) ) {",
          "new_line_content": "                while( get_cabac_bypass( CC ) ) {",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": "get_cabac_bypass",
          "new_api": "get_cabac_bypass_sign",
          "old_text": "get_cabac_bypass( CC )",
          "new_text": "get_cabac_bypass_sign( CC, -coeff_abs )",
          "old_line_content": "                    coeff_abs += coeff_abs + get_cabac_bypass( CC );",
          "new_line_content": "                block[j] = get_cabac_bypass_sign( CC, -coeff_abs );",
          "content_same": false
        },
        {
          "line": 1408,
          "old_api": "IS_INTRA",
          "new_api": "pred_intra_mode",
          "old_text": "IS_INTRA( mb_type )",
          "new_text": "pred_intra_mode( h, i )",
          "old_line_content": "    if( IS_INTRA( mb_type ) ) {",
          "new_line_content": "                    int pred = pred_intra_mode( h, i );",
          "content_same": false
        },
        {
          "line": 1410,
          "old_api": "IS_INTRA4x4",
          "new_api": "fill_rectangle",
          "old_text": "IS_INTRA4x4( mb_type )",
          "new_text": "fill_rectangle( &h->intra4x4_pred_mode_cache[ scan8[i] ], 2, 2, 8, mode, 1 )",
          "old_line_content": "        if( IS_INTRA4x4( mb_type ) ) {",
          "new_line_content": "                    fill_rectangle( &h->intra4x4_pred_mode_cache[ scan8[i] ], 2, 2, 8, mode, 1 );",
          "content_same": false
        },
        {
          "line": 1420,
          "old_api": "pred_intra_mode",
          "new_api": "ff_h264_write_back_intra_pred_mode",
          "old_text": "pred_intra_mode( h, i )",
          "new_text": "ff_h264_write_back_intra_pred_mode(h)",
          "old_line_content": "                    int pred = pred_intra_mode( h, i );",
          "new_line_content": "            ff_h264_write_back_intra_pred_mode(h);",
          "content_same": false
        },
        {
          "line": 1421,
          "old_api": "decode_cabac_mb_intra4x4_pred_mode",
          "new_api": "ff_h264_check_intra4x4_pred_mode",
          "old_text": "decode_cabac_mb_intra4x4_pred_mode( h, pred )",
          "new_text": "ff_h264_check_intra4x4_pred_mode(h)",
          "old_line_content": "                    h->intra4x4_pred_mode_cache[ scan8[i] ] = decode_cabac_mb_intra4x4_pred_mode( h, pred );",
          "new_line_content": "            if( ff_h264_check_intra4x4_pred_mode(h) < 0 ) return -1;",
          "content_same": false
        },
        {
          "line": 1445,
          "old_api": "decode_cabac_b_mb_sub_type",
          "new_api": "ff_h264_pred_direct_motion",
          "old_text": "decode_cabac_b_mb_sub_type( h )",
          "new_text": "ff_h264_pred_direct_motion(h, &mb_type)",
          "old_line_content": "                h->sub_mb_type[i] = decode_cabac_b_mb_sub_type( h );",
          "new_line_content": "                ff_h264_pred_direct_motion(h, &mb_type);",
          "content_same": false
        },
        {
          "line": 1458,
          "old_api": "IS_DIRECT",
          "new_api": "decode_cabac_p_mb_sub_type",
          "old_text": "IS_DIRECT(h->sub_mb_type[i])",
          "new_text": "decode_cabac_p_mb_sub_type( h )",
          "old_line_content": "                        if( IS_DIRECT(h->sub_mb_type[i]) )",
          "new_line_content": "                h->sub_mb_type[i] = decode_cabac_p_mb_sub_type( h );",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": "get_dct8x8_allowed",
          "new_api": "fill_rectangle",
          "old_text": "get_dct8x8_allowed(h)",
          "new_text": "fill_rectangle(h->mvd_cache[list][scan8[4*i]], 2, 2, 8, 0, 4)",
          "old_line_content": "            dct8x8_allowed = get_dct8x8_allowed(h);",
          "new_line_content": "                    fill_rectangle(h->mvd_cache[list][scan8[4*i]], 2, 2, 8, 0, 4);",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": "pred_motion",
          "new_api": "IS_SUB_8X8",
          "old_text": "pred_motion(h, index, block_width, list, h->ref_cache[list][ scan8[index] ], &mpx, &mpy)",
          "new_text": "IS_SUB_8X8(sub_mb_type)",
          "old_line_content": "                        pred_motion(h, index, block_width, list, h->ref_cache[list][ scan8[index] ], &mpx, &mpy);",
          "new_line_content": "                        if(IS_SUB_8X8(sub_mb_type)){",
          "content_same": false
        },
        {
          "line": 1526,
          "old_api": "IS_SUB_8X4",
          "new_api": "IS_SUB_4X8",
          "old_text": "IS_SUB_8X4(sub_mb_type)",
          "new_text": "IS_SUB_4X8(sub_mb_type)",
          "old_line_content": "                        }else if(IS_SUB_8X4(sub_mb_type)){",
          "new_line_content": "                        }else if(IS_SUB_4X8(sub_mb_type)){",
          "content_same": false
        },
        {
          "line": 1554,
          "old_api": "ff_h264_pred_direct_motion",
          "new_api": "IS_16X16",
          "old_text": "ff_h264_pred_direct_motion(h, &mb_type)",
          "new_text": "IS_16X16(mb_type)",
          "old_line_content": "        ff_h264_pred_direct_motion(h, &mb_type);",
          "new_line_content": "        if(IS_16X16(mb_type)){",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": "fill_rectangle",
          "new_api": "IS_DIR",
          "old_text": "fill_rectangle(h->mvd_cache[1][scan8[0]], 4, 4, 8, 0, 4)",
          "new_text": "IS_DIR(mb_type, 0, list)",
          "old_line_content": "        fill_rectangle(h->mvd_cache[1][scan8[0]], 4, 4, 8, 0, 4);",
          "new_line_content": "                if(IS_DIR(mb_type, 0, list)){",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": "fill_rectangle",
          "new_api": "pred_motion",
          "old_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, ref, 1)",
          "new_text": "pred_motion(h, 0, 4, list, h->ref_cache[list][ scan8[0] ], &mpx, &mpy)",
          "old_line_content": "                        fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, ref, 1);",
          "new_line_content": "                    pred_motion(h, 0, 4, list, h->ref_cache[list][ scan8[0] ], &mpx, &mpy);",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": "fill_rectangle",
          "new_api": "decode_cabac_mb_mvd",
          "old_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, (uint8_t)LIST_NOT_USED, 1)",
          "new_text": "decode_cabac_mb_mvd( h, list, 0, 0 )",
          "old_line_content": "                    fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, (uint8_t)LIST_NOT_USED, 1); //FIXME factorize and the other fill_rect below too",
          "new_line_content": "                    mx = mpx + decode_cabac_mb_mvd( h, list, 0, 0 );",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": "pred_motion",
          "new_api": "pack16to32",
          "old_text": "pred_motion(h, 0, 4, list, h->ref_cache[list][ scan8[0] ], &mpx, &mpy)",
          "new_text": "pack16to32(mx-mpx,my-mpy)",
          "old_line_content": "                    pred_motion(h, 0, 4, list, h->ref_cache[list][ scan8[0] ], &mpx, &mpy);",
          "new_line_content": "                    fill_rectangle(h->mvd_cache[list][ scan8[0] ], 4, 4, 8, pack16to32(mx-mpx,my-mpy), 4);",
          "content_same": false
        },
        {
          "line": 1581,
          "old_api": "decode_cabac_mb_mvd",
          "new_api": "fill_rectangle",
          "old_text": "decode_cabac_mb_mvd( h, list, 0, 1 )",
          "new_text": "fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, 0, 4)",
          "old_line_content": "                    my = mpy + decode_cabac_mb_mvd( h, list, 0, 1 );",
          "new_line_content": "                    fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, 0, 4);",
          "content_same": false
        },
        {
          "line": 1584,
          "old_api": "pack16to32",
          "new_api": "IS_16X8",
          "old_text": "pack16to32(mx-mpx,my-mpy)",
          "new_text": "IS_16X8(mb_type)",
          "old_line_content": "                    fill_rectangle(h->mvd_cache[list][ scan8[0] ], 4, 4, 8, pack16to32(mx-mpx,my-mpy), 4);",
          "new_line_content": "        else if(IS_16X8(mb_type)){",
          "content_same": false
        },
        {
          "line": 1587,
          "old_api": "fill_rectangle",
          "new_api": "IS_DIR",
          "old_text": "fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, 0, 4)",
          "new_text": "IS_DIR(mb_type, i, list)",
          "old_line_content": "                    fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, 0, 4);",
          "new_line_content": "                        if(IS_DIR(mb_type, i, list)){",
          "content_same": false
        },
        {
          "line": 1590,
          "old_api": "IS_16X8",
          "new_api": "decode_cabac_mb_ref",
          "old_text": "IS_16X8(mb_type)",
          "new_text": "decode_cabac_mb_ref( h, list, 8*i )",
          "old_line_content": "        else if(IS_16X8(mb_type)){",
          "new_line_content": "                                ref= decode_cabac_mb_ref( h, list, 8*i );",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": "fill_rectangle",
          "new_api": "pred_16x8_motion",
          "old_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, (LIST_NOT_USED&0xFF), 1)",
          "new_text": "pred_16x8_motion(h, 8*i, list, h->ref_cache[list][scan8[0] + 16*i], &mpx, &mpy)",
          "old_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, (LIST_NOT_USED&0xFF), 1);",
          "new_line_content": "                        pred_16x8_motion(h, 8*i, list, h->ref_cache[list][scan8[0] + 16*i], &mpx, &mpy);",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": "IS_DIR",
          "new_api": "pack16to32",
          "old_text": "IS_DIR(mb_type, i, list)",
          "new_text": "pack16to32(mx-mpx,my-mpy)",
          "old_line_content": "                    if(IS_DIR(mb_type, i, list)){",
          "new_line_content": "                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack16to32(mx-mpx,my-mpy), 4);",
          "content_same": false
        },
        {
          "line": 1611,
          "old_api": "pred_16x8_motion",
          "new_api": "pack16to32",
          "old_text": "pred_16x8_motion(h, 8*i, list, h->ref_cache[list][scan8[0] + 16*i], &mpx, &mpy)",
          "new_text": "pack16to32(mx,my)",
          "old_line_content": "                        pred_16x8_motion(h, 8*i, list, h->ref_cache[list][scan8[0] + 16*i], &mpx, &mpy);",
          "new_line_content": "                        fill_rectangle(h->mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack16to32(mx,my), 4);",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": "decode_cabac_mb_mvd",
          "new_api": "fill_rectangle",
          "old_text": "decode_cabac_mb_mvd( h, list, 8*i, 1 )",
          "new_text": "fill_rectangle(h->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 4)",
          "old_line_content": "                        my = mpy + decode_cabac_mb_mvd( h, list, 8*i, 1 );",
          "new_line_content": "                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 4);",
          "content_same": false
        },
        {
          "line": 1614,
          "old_api": "tprintf",
          "new_api": "fill_rectangle",
          "old_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "new_text": "fill_rectangle(h-> mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 4)",
          "old_line_content": "                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "new_line_content": "                        fill_rectangle(h-> mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 4);",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": "fill_rectangle",
          "new_api": "IS_8X16",
          "old_text": "fill_rectangle(h->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 4)",
          "new_text": "IS_8X16(mb_type)",
          "old_line_content": "                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 4);",
          "new_line_content": "            assert(IS_8X16(mb_type));",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": "IS_8X16",
          "new_api": "decode_cabac_mb_ref",
          "old_text": "IS_8X16(mb_type)",
          "new_text": "decode_cabac_mb_ref( h, list, 4*i )",
          "old_line_content": "            assert(IS_8X16(mb_type));",
          "new_line_content": "                                ref= decode_cabac_mb_ref( h, list, 4*i );",
          "content_same": false
        },
        {
          "line": 1640,
          "old_api": "fill_rectangle",
          "new_api": "pred_8x16_motion",
          "old_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, (LIST_NOT_USED&0xFF), 1)",
          "new_text": "pred_8x16_motion(h, i*4, list, h->ref_cache[list][ scan8[0] + 2*i ], &mpx, &mpy)",
          "old_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, (LIST_NOT_USED&0xFF), 1);",
          "new_line_content": "                        pred_8x16_motion(h, i*4, list, h->ref_cache[list][ scan8[0] + 2*i ], &mpx, &mpy);",
          "content_same": false
        },
        {
          "line": 1645,
          "old_api": "IS_DIR",
          "new_api": "pack16to32",
          "old_text": "IS_DIR(mb_type, i, list)",
          "new_text": "pack16to32(mx-mpx,my-mpy)",
          "old_line_content": "                    if(IS_DIR(mb_type, i, list)){",
          "new_line_content": "                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack16to32(mx-mpx,my-mpy), 4);",
          "content_same": false
        },
        {
          "line": 1646,
          "old_api": "pred_8x16_motion",
          "new_api": "pack16to32",
          "old_text": "pred_8x16_motion(h, i*4, list, h->ref_cache[list][ scan8[0] + 2*i ], &mpx, &mpy)",
          "new_text": "pack16to32(mx,my)",
          "old_line_content": "                        pred_8x16_motion(h, i*4, list, h->ref_cache[list][ scan8[0] + 2*i ], &mpx, &mpy);",
          "new_line_content": "                        fill_rectangle(h->mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack16to32(mx,my), 4);",
          "content_same": false
        },
        {
          "line": 1648,
          "old_api": "decode_cabac_mb_mvd",
          "new_api": "fill_rectangle",
          "old_text": "decode_cabac_mb_mvd( h, list, 4*i, 1 )",
          "new_text": "fill_rectangle(h->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 4)",
          "old_line_content": "                        my = mpy + decode_cabac_mb_mvd( h, list, 4*i, 1 );",
          "new_line_content": "                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 4);",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": "IS_INTER",
          "new_api": "decode_cabac_mb_cbp_luma",
          "old_text": "IS_INTER( mb_type )",
          "new_text": "decode_cabac_mb_cbp_luma( h )",
          "old_line_content": "   if( IS_INTER( mb_type ) ) {",
          "new_line_content": "        cbp  = decode_cabac_mb_cbp_luma( h );",
          "content_same": false
        },
        {
          "line": 1664,
          "old_api": "write_back_motion",
          "new_api": "decode_cabac_mb_cbp_chroma",
          "old_text": "write_back_motion( h, mb_type )",
          "new_text": "decode_cabac_mb_cbp_chroma( h )",
          "old_line_content": "        write_back_motion( h, mb_type );",
          "new_line_content": "            cbp |= decode_cabac_mb_cbp_chroma( h ) << 4;",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": "decode_cabac_mb_cbp_chroma",
          "new_api": "decode_cabac_mb_transform_size",
          "old_text": "decode_cabac_mb_cbp_chroma( h )",
          "new_text": "decode_cabac_mb_transform_size( h )",
          "old_line_content": "            cbp |= decode_cabac_mb_cbp_chroma( h ) << 4;",
          "new_line_content": "        if( decode_cabac_mb_transform_size( h ) )",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": "IS_INTRA",
          "new_api": "IS_INTRA16x16",
          "old_text": "IS_INTRA( mb_type )",
          "new_text": "IS_INTRA16x16( mb_type )",
          "old_line_content": "    if( dct8x8_allowed && (cbp&15) && !IS_INTRA( mb_type ) ) {",
          "new_line_content": "    if( cbp || IS_INTRA16x16( mb_type ) ) {",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "get_chroma_qp",
          "new_api": "decode_cabac_residual",
          "old_text": "get_chroma_qp(h, 0, s->qscale)",
          "new_text": "decode_cabac_residual( h, h->mb, 0, 0, dc_scan, NULL, 16)",
          "old_line_content": "        h->chroma_qp[0] = get_chroma_qp(h, 0, s->qscale);",
          "new_line_content": "            decode_cabac_residual( h, h->mb, 0, 0, dc_scan, NULL, 16);",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": "fill_rectangle",
          "new_api": "IS_8x8DCT",
          "old_text": "fill_rectangle(&h->non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1)",
          "new_text": "IS_8x8DCT(mb_type)",
          "old_line_content": "                fill_rectangle(&h->non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1);",
          "new_line_content": "                    if( IS_8x8DCT(mb_type) ) {",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1024,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(cat == 1 || cat == 2 || cat == 4)",
          "old_line_content": "            nzb = h-> top_cbp&0x100;",
          "new_line_content": "        assert(cat == 1 || cat == 2 || cat == 4);",
          "content_same": false
        },
        {
          "line": 1547,
          "old_api": null,
          "new_api": "IS_DIRECT",
          "old_text": null,
          "new_text": "IS_DIRECT(mb_type)",
          "old_line_content": "                    uint32_t *pd= (uint32_t *)&h->mvd_cache[list][ scan8[4*i] ][0];",
          "new_line_content": "    } else if( IS_DIRECT(mb_type) ) {",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": null,
          "new_api": "ff_h264_pred_direct_motion",
          "old_text": null,
          "new_text": "ff_h264_pred_direct_motion(h, &mb_type)",
          "old_line_content": "                    p[0] = p[1] = p[8] = p[9] = 0;",
          "new_line_content": "        ff_h264_pred_direct_motion(h, &mb_type);",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(h->mvd_cache[0][scan8[0]], 4, 4, 8, 0, 4)",
          "old_line_content": "                    pd[0]= pd[1]= pd[8]= pd[9]= 0;",
          "new_line_content": "        fill_rectangle(h->mvd_cache[0][scan8[0]], 4, 4, 8, 0, 4);",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": null,
          "new_api": "DECLARE_ASM_CONST",
          "old_text": null,
          "new_text": "DECLARE_ASM_CONST(1, uint8_t, last_coeff_flag_offset_8x8)",
          "old_line_content": "    if( nzb > 0 )",
          "new_line_content": "DECLARE_ASM_CONST(1, uint8_t, last_coeff_flag_offset_8x8)[63] = {",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(h->mvd_cache[1][scan8[0]], 4, 4, 8, 0, 4)",
          "old_line_content": "                }",
          "new_line_content": "        fill_rectangle(h->mvd_cache[1][scan8[0]], 4, 4, 8, 0, 4);",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": null,
          "new_api": "decode_cabac_mb_ref",
          "old_text": null,
          "new_text": "decode_cabac_mb_ref(h, list, 0)",
          "old_line_content": "        int list, mx, my, i, mpx, mpy;",
          "new_line_content": "                        ref= decode_cabac_mb_ref(h, list, 0);",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list])",
          "old_line_content": "            for(list=0; list<h->list_count; list++){",
          "new_line_content": "                            av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);",
          "content_same": false
        },
        {
          "line": 1566,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, ref, 1)",
          "old_line_content": "                        if(ref >= (unsigned)h->ref_count[list]){",
          "new_line_content": "                        fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, ref, 1);",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, (uint8_t)LIST_NOT_USED, 1)",
          "old_line_content": "                            return -1;",
          "new_line_content": "                    fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, (uint8_t)LIST_NOT_USED, 1); //FIXME factorize and the other fill_rect below too",
          "content_same": false
        },
        {
          "line": 1571,
          "old_api": null,
          "new_api": "IS_DIR",
          "old_text": null,
          "new_text": "IS_DIR(mb_type, 0, list)",
          "old_line_content": "                        ref=0;",
          "new_line_content": "                if(IS_DIR(mb_type, 0, list)){",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": null,
          "new_api": "decode_cabac_mb_mvd",
          "old_text": null,
          "new_text": "decode_cabac_mb_mvd( h, list, 0, 1 )",
          "old_line_content": "            }",
          "new_line_content": "                    my = mpy + decode_cabac_mb_mvd( h, list, 0, 1 );",
          "content_same": false
        },
        {
          "line": 1576,
          "old_api": null,
          "new_api": "tprintf",
          "old_text": null,
          "new_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "old_line_content": "            for(list=0; list<h->list_count; list++){",
          "new_line_content": "                    tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "content_same": false
        },
        {
          "line": 1579,
          "old_api": null,
          "new_api": "pack16to32",
          "old_text": null,
          "new_text": "pack16to32(mx,my)",
          "old_line_content": "",
          "new_line_content": "                    fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, pack16to32(mx,my), 4);",
          "content_same": false
        },
        {
          "line": 1592,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list])",
          "old_line_content": "                    for(i=0; i<2; i++){",
          "new_line_content": "                                    av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);",
          "content_same": false
        },
        {
          "line": 1597,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, ref, 1)",
          "old_line_content": "                                if(ref >= (unsigned)h->ref_count[list]){",
          "new_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, ref, 1);",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, (LIST_NOT_USED&0xFF), 1)",
          "old_line_content": "                                    return -1;",
          "new_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, (LIST_NOT_USED&0xFF), 1);",
          "content_same": false
        },
        {
          "line": 1604,
          "old_api": null,
          "new_api": "IS_DIR",
          "old_text": null,
          "new_text": "IS_DIR(mb_type, i, list)",
          "old_line_content": "                        }else",
          "new_line_content": "                    if(IS_DIR(mb_type, i, list)){",
          "content_same": false
        },
        {
          "line": 1606,
          "old_api": null,
          "new_api": "decode_cabac_mb_mvd",
          "old_text": null,
          "new_text": "decode_cabac_mb_mvd( h, list, 8*i, 0 )",
          "old_line_content": "                    }",
          "new_line_content": "                        mx = mpx + decode_cabac_mb_mvd( h, list, 8*i, 0 );",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": null,
          "new_api": "decode_cabac_mb_mvd",
          "old_text": null,
          "new_text": "decode_cabac_mb_mvd( h, list, 8*i, 1 )",
          "old_line_content": "            }",
          "new_line_content": "                        my = mpy + decode_cabac_mb_mvd( h, list, 8*i, 1 );",
          "content_same": false
        },
        {
          "line": 1608,
          "old_api": null,
          "new_api": "tprintf",
          "old_text": null,
          "new_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "old_line_content": "            for(list=0; list<h->list_count; list++){",
          "new_line_content": "                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "content_same": false
        },
        {
          "line": 1622,
          "old_api": null,
          "new_api": "IS_DIR",
          "old_text": null,
          "new_text": "IS_DIR(mb_type, i, list)",
          "old_line_content": "                }",
          "new_line_content": "                        if(IS_DIR(mb_type, i, list)){ //FIXME optimize",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": null,
          "new_api": "get_cabac_cbf_ctx",
          "old_text": null,
          "new_text": "get_cabac_cbf_ctx( h, cat, n, is_dc )",
          "old_line_content": "     *      4-> AC Chroma n = 16 + 4 * iCbCr + chroma4x4idx",
          "new_line_content": "        if( get_cabac( CC, &h->cabac_state[85 + get_cabac_cbf_ctx( h, cat, n, is_dc ) ] ) == 0 ) {",
          "content_same": false
        },
        {
          "line": 1627,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list])",
          "old_line_content": "                    for(i=0; i<2; i++){",
          "new_line_content": "                                    av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, ref, 1)",
          "old_line_content": "                                if(ref >= (unsigned)h->ref_count[list]){",
          "new_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, ref, 1);",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, (LIST_NOT_USED&0xFF), 1)",
          "old_line_content": "                                    return -1;",
          "new_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, (LIST_NOT_USED&0xFF), 1);",
          "content_same": false
        },
        {
          "line": 1639,
          "old_api": null,
          "new_api": "IS_DIR",
          "old_text": null,
          "new_text": "IS_DIR(mb_type, i, list)",
          "old_line_content": "                        }else",
          "new_line_content": "                    if(IS_DIR(mb_type, i, list)){",
          "content_same": false
        },
        {
          "line": 1641,
          "old_api": null,
          "new_api": "decode_cabac_mb_mvd",
          "old_text": null,
          "new_text": "decode_cabac_mb_mvd( h, list, 4*i, 0 )",
          "old_line_content": "                    }",
          "new_line_content": "                        mx = mpx + decode_cabac_mb_mvd( h, list, 4*i, 0 );",
          "content_same": false
        },
        {
          "line": 1642,
          "old_api": null,
          "new_api": "decode_cabac_mb_mvd",
          "old_text": null,
          "new_text": "decode_cabac_mb_mvd( h, list, 4*i, 1 )",
          "old_line_content": "            }",
          "new_line_content": "                        my = mpy + decode_cabac_mb_mvd( h, list, 4*i, 1 );",
          "content_same": false
        },
        {
          "line": 1644,
          "old_api": null,
          "new_api": "tprintf",
          "old_text": null,
          "new_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "old_line_content": "                for(i=0; i<2; i++){",
          "new_line_content": "                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "content_same": false
        },
        {
          "line": 1649,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(h-> mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 4)",
          "old_line_content": "",
          "new_line_content": "                        fill_rectangle(h-> mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 4);",
          "content_same": false
        },
        {
          "line": 1656,
          "old_api": null,
          "new_api": "IS_INTER",
          "old_text": null,
          "new_text": "IS_INTER( mb_type )",
          "old_line_content": "                    }",
          "new_line_content": "   if( IS_INTER( mb_type ) ) {",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": null,
          "new_api": "write_back_motion",
          "old_text": null,
          "new_text": "write_back_motion( h, mb_type )",
          "old_line_content": "            }",
          "new_line_content": "        write_back_motion( h, mb_type );",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": null,
          "new_api": "IS_INTRA16x16",
          "old_text": null,
          "new_text": "IS_INTRA16x16( mb_type )",
          "old_line_content": "",
          "new_line_content": "    if( !IS_INTRA16x16( mb_type ) ) {",
          "content_same": false
        },
        {
          "line": 1152,
          "old_api": null,
          "new_api": "decode_significance_8x8_x86",
          "old_text": null,
          "new_text": "decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index, sig_off)",
          "old_line_content": "        }\\",
          "new_line_content": "        coeff_count= decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index, sig_off);",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": null,
          "new_api": "decode_significance_x86",
          "old_text": null,
          "new_text": "decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index)",
          "old_line_content": "            index[coeff_count++] = last;\\",
          "new_line_content": "        coeff_count= decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index);",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": null,
          "new_api": "DECODE_SIGNIFICANCE",
          "old_text": null,
          "new_text": "DECODE_SIGNIFICANCE( 63, sig_off[last], last_coeff_flag_offset_8x8[last] )",
          "old_line_content": "        const uint8_t *sig_off = significant_coeff_flag_offset_8x8[MB_FIELD];",
          "new_line_content": "        DECODE_SIGNIFICANCE( 63, sig_off[last], last_coeff_flag_offset_8x8[last] );",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": null,
          "new_api": "IS_INTRA",
          "old_text": null,
          "new_text": "IS_INTRA( mb_type )",
          "old_line_content": "        if(CHROMA)",
          "new_line_content": "    if( dct8x8_allowed && (cbp&15) && !IS_INTRA( mb_type ) ) {",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(coeff_count > 0)",
          "old_line_content": "#else",
          "new_line_content": "    assert(coeff_count > 0);",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": null,
          "new_api": "IS_INTERLACED",
          "old_text": null,
          "new_text": "IS_INTERLACED(mb_type)",
          "old_line_content": "",
          "new_line_content": "        if(IS_INTERLACED(mb_type)){",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1)",
          "old_line_content": "        if( cat == 0 )",
          "new_line_content": "            fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1);",
          "content_same": false
        },
        {
          "line": 1172,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert( cat == 1 || cat == 2 || cat == 4 )",
          "old_line_content": "        else",
          "new_line_content": "            assert( cat == 1 || cat == 2 || cat == 4 );",
          "content_same": false
        },
        {
          "line": 1690,
          "old_api": null,
          "new_api": "decode_cabac_mb_dqp",
          "old_text": null,
          "new_text": "decode_cabac_mb_dqp( h )",
          "old_line_content": "        }else{",
          "new_line_content": "        h->last_qscale_diff = dqp = decode_cabac_mb_dqp( h );",
          "content_same": false
        },
        {
          "line": 1692,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(h->s.avctx, AV_LOG_ERROR, \"cabac decode of qscale diff failed at %d %d\\n\", s->mb_x, s->mb_y)",
          "old_line_content": "            scan= s->qscale ? h->zigzag_scan : h->zigzag_scan_q0;",
          "new_line_content": "            av_log(h->s.avctx, AV_LOG_ERROR, \"cabac decode of qscale diff failed at %d %d\\n\", s->mb_x, s->mb_y);",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( CC, ctx )",
          "old_line_content": "",
          "new_line_content": "        if( get_cabac( CC, ctx ) == 0 ) {",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": null,
          "new_api": "get_cabac_bypass_sign",
          "old_text": null,
          "new_text": "get_cabac_bypass_sign( CC, -1)",
          "old_line_content": "",
          "new_line_content": "                block[j] = get_cabac_bypass_sign( CC, -1);",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": null,
          "new_api": "get_cabac_bypass_sign",
          "old_text": null,
          "new_text": "get_cabac_bypass_sign( CC, -qmul[j])",
          "old_line_content": "",
          "new_line_content": "                block[j] = (get_cabac_bypass_sign( CC, -qmul[j]) + 32) >> 6;",
          "content_same": false
        },
        {
          "line": 1700,
          "old_api": null,
          "new_api": "get_chroma_qp",
          "old_text": null,
          "new_text": "get_chroma_qp(h, 0, s->qscale)",
          "old_line_content": "        }",
          "new_line_content": "        h->chroma_qp[0] = get_chroma_qp(h, 0, s->qscale);",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": null,
          "new_api": "get_chroma_qp",
          "old_text": null,
          "new_text": "get_chroma_qp(h, 1, s->qscale)",
          "old_line_content": "        s->qscale += dqp;",
          "new_line_content": "        h->chroma_qp[1] = get_chroma_qp(h, 1, s->qscale);",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": null,
          "new_api": "IS_INTRA16x16",
          "old_text": null,
          "new_text": "IS_INTRA16x16( mb_type )",
          "old_line_content": "            if(s->qscale<0) s->qscale+= 52;",
          "new_line_content": "        if( IS_INTRA16x16( mb_type ) ) {",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( CC, ctx )",
          "old_line_content": "            }",
          "new_line_content": "            while( coeff_abs < 15 && get_cabac( CC, ctx ) ) {",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&h->non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1)",
          "old_line_content": "                qmul = h->dequant4_coeff[0][s->qscale];",
          "new_line_content": "                fill_rectangle(&h->non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1);",
          "content_same": false
        },
        {
          "line": 1722,
          "old_api": null,
          "new_api": "decode_cabac_residual",
          "old_text": null,
          "new_text": "decode_cabac_residual(h, h->mb + 64*i8x8, 5, 4*i8x8,\n                            scan8x8, h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 64)",
          "old_line_content": "            }",
          "new_line_content": "                        decode_cabac_residual(h, h->mb + 64*i8x8, 5, 4*i8x8,",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": null,
          "new_api": "IS_INTRA",
          "old_text": null,
          "new_text": "IS_INTRA( mb_type )",
          "old_line_content": "        } else {",
          "new_line_content": "                            scan8x8, h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 64);",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": null,
          "new_api": "IS_INTRA",
          "old_text": null,
          "new_text": "IS_INTRA( mb_type )",
          "old_line_content": "            for( i8x8 = 0; i8x8 < 4; i8x8++ ) {",
          "new_line_content": "                        qmul = h->dequant4_coeff[IS_INTRA( mb_type ) ? 0:3][s->qscale];",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": null,
          "new_api": "get_cabac_bypass_sign",
          "old_text": null,
          "new_text": "get_cabac_bypass_sign( CC, -coeff_abs )",
          "old_line_content": "                coeff_abs+= 14;",
          "new_line_content": "                block[j] = (get_cabac_bypass_sign( CC, -coeff_abs ) * qmul[j] + 32) >> 6;",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": null,
          "new_api": "decode_cabac_residual",
          "old_text": null,
          "new_text": "decode_cabac_residual(h, h->mb + 16*index, 2, index, scan, qmul, 16)",
          "old_line_content": "                    } else {",
          "new_line_content": "                            decode_cabac_residual(h, h->mb + 16*index, 2, index, scan, qmul, 16);",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": null,
          "new_api": "decode_cabac_residual_internal",
          "old_text": null,
          "new_text": "decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 1)",
          "old_line_content": "#endif",
          "new_line_content": "    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 1);",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &(h->cabac_state+70)[ctx] )",
          "old_line_content": "        ctx += 1;",
          "new_line_content": "    return get_cabac_noinline( &h->cabac, &(h->cabac_state+70)[ctx] );",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": null,
          "new_api": "decode_cabac_residual_internal",
          "old_text": null,
          "new_text": "decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 0)",
          "old_line_content": "#if !CONFIG_SMALL",
          "new_line_content": "    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 0);",
          "content_same": false
        },
        {
          "line": 1745,
          "old_api": null,
          "new_api": "decode_cabac_residual",
          "old_text": null,
          "new_text": "decode_cabac_residual(h, h->mb + 256 + 16*4*c, 3, c, chroma_dc_scan, NULL, 4)",
          "old_line_content": "        }",
          "new_line_content": "                decode_cabac_residual(h, h->mb + 256 + 16*4*c, 3, c, chroma_dc_scan, NULL, 4);",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": null,
          "new_api": "decode_cabac_residual_dc",
          "old_text": null,
          "new_text": "decode_cabac_residual_dc(h, block, cat, n, scantable, qmul, max_coeff)",
          "old_line_content": "#endif",
          "new_line_content": "    if( cat == 0 || cat == 3 ) decode_cabac_residual_dc(h, block, cat, n, scantable, qmul, max_coeff);",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": null,
          "new_api": "IS_INTRA4x4",
          "old_text": null,
          "new_text": "IS_INTRA4x4( s->current_picture.mb_type[mba_xy] )",
          "old_line_content": "",
          "new_line_content": "        if( h->slice_table[mba_xy] == h->slice_num && !IS_INTRA4x4( s->current_picture.mb_type[mba_xy] ) )",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": null,
          "new_api": "decode_cabac_residual_nondc",
          "old_text": null,
          "new_text": "decode_cabac_residual_nondc(h, block, cat, n, scantable, qmul, max_coeff)",
          "old_line_content": "",
          "new_line_content": "    else decode_cabac_residual_nondc(h, block, cat, n, scantable, qmul, max_coeff);",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "IS_INTRA4x4",
          "old_text": null,
          "new_text": "IS_INTRA4x4( s->current_picture.mb_type[mbb_xy] )",
          "old_line_content": "        MpegEncContext * const s = &h->s;",
          "new_line_content": "        if( h->slice_table[mbb_xy] == h->slice_num && !IS_INTRA4x4( s->current_picture.mb_type[mbb_xy] ) )",
          "content_same": false
        },
        {
          "line": 1752,
          "old_api": null,
          "new_api": "IS_INTRA",
          "old_text": null,
          "new_text": "IS_INTRA( mb_type )",
          "old_line_content": "            }",
          "new_line_content": "                qmul = h->dequant4_coeff[c+1+(IS_INTRA( mb_type ) ? 0:3)][h->chroma_qp[c]];",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &state[ctx] )",
          "old_line_content": "        const int mbb_xy = h->top_mb_xy;",
          "new_line_content": "        if( get_cabac_noinline( &h->cabac, &state[ctx] ) == 0 )",
          "content_same": false
        },
        {
          "line": 1756,
          "old_api": null,
          "new_api": "decode_cabac_residual",
          "old_text": null,
          "new_text": "decode_cabac_residual(h, h->mb + 16*index, 4, index, scan + 1, qmul, 15)",
          "old_line_content": "            int c, i;",
          "new_line_content": "                    decode_cabac_residual(h, h->mb + 16*index, 4, index, scan + 1, qmul, 15);",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": null,
          "new_api": "get_cabac_terminate",
          "old_text": null,
          "new_text": "get_cabac_terminate( &h->cabac )",
          "old_line_content": "        state += 2;",
          "new_line_content": "    if( get_cabac_terminate( &h->cabac ) )",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": null,
          "new_api": "IS_INTERLACED",
          "old_text": null,
          "new_text": "IS_INTERLACED(s->current_picture.mb_type[top_pair_xy])",
          "old_line_content": "    const int mb_xy  = h->mb_xy;",
          "new_line_content": "        const int top_mb_field_flag  = IS_INTERLACED(s->current_picture.mb_type[top_pair_xy]);",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": null,
          "new_api": "IS_INTERLACED",
          "old_text": null,
          "new_text": "IS_INTERLACED(s->current_picture.mb_type[pair_xy-1])",
          "old_line_content": "    h->top_mb_xy     = mb_xy - s->mb_stride;",
          "new_line_content": "        const int left_mb_field_flag = IS_INTERLACED(s->current_picture.mb_type[pair_xy-1]);",
          "content_same": false
        },
        {
          "line": 1766,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1)",
          "old_line_content": "            uint8_t * const nnz= &h->non_zero_count_cache[0];",
          "new_line_content": "        fill_rectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1);",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &state[1] )",
          "old_line_content": "    }",
          "new_line_content": "    mb_type += 12 * get_cabac_noinline( &h->cabac, &state[1] ); /* cbp_luma != 0 */",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &state[2] )",
          "old_line_content": "",
          "new_line_content": "    if( get_cabac_noinline( &h->cabac, &state[2] ) ) /* cbp_chroma */",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &state[3+intra_slice] )",
          "old_line_content": "        return 25;  /* PCM */",
          "new_line_content": "    mb_type += 2 * get_cabac_noinline( &h->cabac, &state[3+intra_slice] );",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &state[3+2*intra_slice] )",
          "old_line_content": "",
          "new_line_content": "    mb_type += 1 * get_cabac_noinline( &h->cabac, &state[3+2*intra_slice] );",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": null,
          "new_api": "write_back_non_zero_count",
          "old_text": null,
          "new_text": "write_back_non_zero_count(h)",
          "old_line_content": "        nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] =",
          "new_line_content": "    write_back_non_zero_count(h);",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(h->slice_type_nos == FF_B_TYPE)",
          "old_line_content": "    MpegEncContext * const s = &h->s;",
          "new_line_content": "        assert(h->slice_type_nos == FF_B_TYPE);",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": null,
          "new_api": "IS_DIRECT",
          "old_text": null,
          "new_text": "IS_DIRECT( s->current_picture.mb_type[mba_xy] )",
          "old_line_content": "        const int mba_xy = h->left_mb_xy[0];",
          "new_line_content": "        if( h->slice_table[mba_xy] == h->slice_num && !IS_DIRECT( s->current_picture.mb_type[mba_xy] ) )",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": null,
          "new_api": "IS_DIRECT",
          "old_text": null,
          "new_text": "IS_DIRECT( s->current_picture.mb_type[mbb_xy] )",
          "old_line_content": "        int ctx = 0;",
          "new_line_content": "        if( h->slice_table[mbb_xy] == h->slice_num && !IS_DIRECT( s->current_picture.mb_type[mbb_xy] ) )",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+ctx] )",
          "old_line_content": "",
          "new_line_content": "        if( !get_cabac_noinline( &h->cabac, &h->cabac_state[27+ctx] ) )",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] )",
          "old_line_content": "            ctx++;",
          "new_line_content": "            return 1 + get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] ); /* B_L[01]_16x16 */",
          "content_same": false
        },
        {
          "line": 1283,
          "old_api": null,
          "new_api": "tprintf",
          "old_text": null,
          "new_text": "tprintf(s->avctx, \"pic:%d mb:%d/%d\\n\", h->frame_num, s->mb_x, s->mb_y)",
          "old_line_content": "    int mb_xy;",
          "new_line_content": "    tprintf(s->avctx, \"pic:%d mb:%d/%d\\n\", h->frame_num, s->mb_x, s->mb_y);",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+4] )",
          "old_line_content": "            return 0; /* B_Direct_16x16 */",
          "new_line_content": "        bits = get_cabac_noinline( &h->cabac, &h->cabac_state[27+4] ) << 3;",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] )",
          "old_line_content": "",
          "new_line_content": "        bits|= get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] ) << 2;",
          "content_same": false
        },
        {
          "line": 1288,
          "old_api": null,
          "new_api": "predict_field_decoding_flag",
          "old_text": null,
          "new_text": "predict_field_decoding_flag(h)",
          "old_line_content": "",
          "new_line_content": "            predict_field_decoding_flag(h);",
          "content_same": false
        },
        {
          "line": 1292,
          "old_api": null,
          "new_api": "decode_cabac_mb_skip",
          "old_text": null,
          "new_text": "decode_cabac_mb_skip( h, s->mb_x, s->mb_y )",
          "old_line_content": "        /* a skipped mb needs the aff flag from the following mb */",
          "new_line_content": "            skip = decode_cabac_mb_skip( h, s->mb_x, s->mb_y );",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": null,
          "new_api": "decode_cabac_mb_skip",
          "old_text": null,
          "new_text": "decode_cabac_mb_skip( h, s->mb_x, s->mb_y+1 )",
          "old_line_content": "        else",
          "new_line_content": "                h->next_mb_skipped = decode_cabac_mb_skip( h, s->mb_x, s->mb_y+1 );",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": null,
          "new_api": "decode_cabac_field_decoding_flag",
          "old_text": null,
          "new_text": "decode_cabac_field_decoding_flag(h)",
          "old_line_content": "        /* read skip flags */",
          "new_line_content": "                    h->mb_mbaff = h->mb_field_decoding_flag = decode_cabac_field_decoding_flag(h);",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": null,
          "new_api": "decode_mb_skip",
          "old_text": null,
          "new_text": "decode_mb_skip(h)",
          "old_line_content": "                s->current_picture.mb_type[mb_xy] = MB_TYPE_SKIP;",
          "new_line_content": "            decode_mb_skip(h);",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": null,
          "new_api": "IS_INTERLACED",
          "old_text": null,
          "new_text": "IS_INTERLACED( s->current_picture.mb_type[mba_xy] )",
          "old_line_content": "",
          "new_line_content": "            && MB_FIELD == !!IS_INTERLACED( s->current_picture.mb_type[mba_xy] ) )",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": null,
          "new_api": "decode_cabac_field_decoding_flag",
          "old_text": null,
          "new_text": "decode_cabac_field_decoding_flag(h)",
          "old_line_content": "",
          "new_line_content": "            h->mb_field_decoding_flag = decode_cabac_field_decoding_flag(h);",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": null,
          "new_api": "compute_mb_neighbors",
          "old_text": null,
          "new_text": "compute_mb_neighbors(h)",
          "old_line_content": "            h->mb_mbaff =",
          "new_line_content": "    compute_mb_neighbors(h);",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": null,
          "new_api": "decode_cabac_mb_type_b",
          "old_text": null,
          "new_text": "decode_cabac_mb_type_b( h )",
          "old_line_content": "",
          "new_line_content": "        mb_type = decode_cabac_mb_type_b( h );",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": null,
          "new_api": "IS_SKIP",
          "old_text": null,
          "new_text": "IS_SKIP( s->current_picture.mb_type[mba_xy] )",
          "old_line_content": "    }else{",
          "new_line_content": "    if( h->slice_table[mba_xy] == h->slice_num && !IS_SKIP( s->current_picture.mb_type[mba_xy] ))",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": null,
          "new_api": "IS_SKIP",
          "old_text": null,
          "new_text": "IS_SKIP( s->current_picture.mb_type[mbb_xy] )",
          "old_line_content": "        mba_xy = mb_xy - 1;",
          "new_line_content": "    if( h->slice_table[mbb_xy] == h->slice_num && !IS_SKIP( s->current_picture.mb_type[mbb_xy] ))",
          "content_same": false
        },
        {
          "line": 1332,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[14] )",
          "old_line_content": "            mb_type=         b_mb_type_info[mb_type].type;",
          "new_line_content": "        if( get_cabac_noinline( &h->cabac, &h->cabac_state[14] ) == 0 ) {",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[15] )",
          "old_line_content": "            mb_type -= 23;",
          "new_line_content": "            if( get_cabac_noinline( &h->cabac, &h->cabac_state[15] ) == 0 ) {",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[11+ctx] )",
          "old_line_content": "        ctx++;",
          "new_line_content": "    return get_cabac_noinline( &h->cabac, &h->cabac_state[11+ctx] );",
          "content_same": false
        },
        {
          "line": 1336,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[16] )",
          "old_line_content": "        }",
          "new_line_content": "                mb_type= 3 * get_cabac_noinline( &h->cabac, &h->cabac_state[16] );",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[17] )",
          "old_line_content": "            /* P-type */",
          "new_line_content": "                mb_type= 2 - get_cabac_noinline( &h->cabac, &h->cabac_state[17] );",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": null,
          "new_api": "decode_cabac_intra_mb_type",
          "old_text": null,
          "new_text": "decode_cabac_intra_mb_type(h, 17, 0)",
          "old_line_content": "                /* P_L0_D8x16, P_L0_D16x8 */",
          "new_line_content": "            mb_type= decode_cabac_intra_mb_type(h, 17, 0);",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[69] )",
          "old_line_content": "static int decode_cabac_mb_intra4x4_pred_mode( H264Context *h, int pred_mode ) {",
          "new_line_content": "    mode += 1 * get_cabac( &h->cabac, &h->cabac_state[69] );",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[69] )",
          "old_line_content": "    int mode = 0;",
          "new_line_content": "    mode += 2 * get_cabac( &h->cabac, &h->cabac_state[69] );",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[69] )",
          "old_line_content": "",
          "new_line_content": "    mode += 4 * get_cabac( &h->cabac, &h->cabac_state[69] );",
          "content_same": false
        },
        {
          "line": 1348,
          "old_api": null,
          "new_api": "decode_cabac_intra_mb_type",
          "old_text": null,
          "new_text": "decode_cabac_intra_mb_type(h, 3, 1)",
          "old_line_content": "            mb_type=         p_mb_type_info[mb_type].type;",
          "new_line_content": "        mb_type= decode_cabac_intra_mb_type(h, 3, 1);",
          "content_same": false
        },
        {
          "line": 1351,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(h->slice_type_nos == FF_I_TYPE)",
          "old_line_content": "            goto decode_intra_mb;",
          "new_line_content": "        assert(h->slice_type_nos == FF_I_TYPE);",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": null,
          "new_api": "IS_INTRA_PCM",
          "old_text": null,
          "new_text": "IS_INTRA_PCM(mb_type)",
          "old_line_content": "    }",
          "new_line_content": "    if(IS_INTRA_PCM(mb_type)) {",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[64+ctx] )",
          "old_line_content": "    if( h->slice_table[mba_xy] == h->slice_num && h->chroma_pred_mode_table[mba_xy] != 0 )",
          "new_line_content": "    if( get_cabac_noinline( &h->cabac, &h->cabac_state[64+ctx] ) == 0 )",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[64+3] )",
          "old_line_content": "    if( h->slice_table[mbb_xy] == h->slice_num && h->chroma_pred_mode_table[mbb_xy] != 0 )",
          "new_line_content": "    if( get_cabac_noinline( &h->cabac, &h->cabac_state[64+3] ) == 0 )",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[64+3] )",
          "old_line_content": "",
          "new_line_content": "    if( get_cabac_noinline( &h->cabac, &h->cabac_state[64+3] ) == 0 )",
          "content_same": false
        },
        {
          "line": 1376,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(h->mb, ptr, 256)",
          "old_line_content": "        if(h->cabac.low&0x1) ptr--;",
          "new_line_content": "        memcpy(h->mb, ptr, 256); ptr+=256;",
          "content_same": false
        },
        {
          "line": 1378,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(h->mb+128, ptr, 128)",
          "old_line_content": "            if(h->cabac.low&0x1FF) ptr--;",
          "new_line_content": "            memcpy(h->mb+128, ptr, 128); ptr+=128;",
          "content_same": false
        },
        {
          "line": 1381,
          "old_api": null,
          "new_api": "ff_init_cabac_decoder",
          "old_text": null,
          "new_text": "ff_init_cabac_decoder(&h->cabac, ptr, h->cabac.bytestream_end - ptr)",
          "old_line_content": "        // The pixels are stored in the same order as levels in h->mb array.",
          "new_line_content": "        ff_init_cabac_decoder(&h->cabac, ptr, h->cabac.bytestream_end - ptr);",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx])",
          "old_line_content": "    int cbp_b, cbp_a, ctx, cbp = 0;",
          "new_line_content": "    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx])",
          "old_line_content": "    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;",
          "new_line_content": "    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;",
          "content_same": false
        },
        {
          "line": 1389,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(h->non_zero_count[mb_xy], 16, 32)",
          "old_line_content": "        // All blocks are present",
          "new_line_content": "        memset(h->non_zero_count[mb_xy], 16, 32);",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx])",
          "old_line_content": "",
          "new_line_content": "    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;",
          "content_same": false
        },
        {
          "line": 1400,
          "old_api": null,
          "new_api": "fill_decode_caches",
          "old_text": null,
          "new_text": "fill_decode_caches(h, mb_type)",
          "old_line_content": "",
          "new_line_content": "    fill_decode_caches(h, mb_type);",
          "content_same": false
        },
        {
          "line": 1402,
          "old_api": null,
          "new_api": "IS_INTRA",
          "old_text": null,
          "new_text": "IS_INTRA( mb_type )",
          "old_line_content": "        h->ref_count[0] <<= 1;",
          "new_line_content": "    if( IS_INTRA( mb_type ) ) {",
          "content_same": false
        },
        {
          "line": 1404,
          "old_api": null,
          "new_api": "IS_INTRA4x4",
          "old_text": null,
          "new_text": "IS_INTRA4x4( mb_type )",
          "old_line_content": "    }",
          "new_line_content": "        if( IS_INTRA4x4( mb_type ) ) {",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": null,
          "new_api": "get_cabac_noinline",
          "old_text": null,
          "new_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[77 + ctx] )",
          "old_line_content": "    cbp_a = (h->left_cbp>>4)&0x03;",
          "new_line_content": "    if( get_cabac_noinline( &h->cabac, &h->cabac_state[77 + ctx] ) == 0 )",
          "content_same": false
        },
        {
          "line": 1405,
          "old_api": null,
          "new_api": "decode_cabac_mb_transform_size",
          "old_text": null,
          "new_text": "decode_cabac_mb_transform_size( h )",
          "old_line_content": "",
          "new_line_content": "            if( dct8x8_allowed && decode_cabac_mb_transform_size( h ) ) {",
          "content_same": false
        },
        {
          "line": 1409,
          "old_api": null,
          "new_api": "decode_cabac_mb_intra4x4_pred_mode",
          "old_text": null,
          "new_text": "decode_cabac_mb_intra4x4_pred_mode( h, pred )",
          "old_line_content": "        int i, pred_mode;",
          "new_line_content": "                    int mode = decode_cabac_mb_intra4x4_pred_mode( h, pred );",
          "content_same": false
        },
        {
          "line": 1423,
          "old_api": null,
          "new_api": "ff_h264_check_intra_pred_mode",
          "old_text": null,
          "new_text": "ff_h264_check_intra_pred_mode( h, h->intra16x16_pred_mode )",
          "old_line_content": "                //av_log( s->avctx, AV_LOG_ERROR, \"i4x4 pred=%d mode=%d\\n\", pred, h->intra4x4_pred_mode_cache[ scan8[i] ] );",
          "new_line_content": "            h->intra16x16_pred_mode= ff_h264_check_intra_pred_mode( h, h->intra16x16_pred_mode );",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": null,
          "new_api": "decode_cabac_mb_chroma_pre_mode",
          "old_text": null,
          "new_text": "decode_cabac_mb_chroma_pre_mode( h )",
          "old_line_content": "        } else {",
          "new_line_content": "            pred_mode                        = decode_cabac_mb_chroma_pre_mode( h );",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[21] )",
          "old_line_content": "    if( val&0x01 )",
          "new_line_content": "    if( get_cabac( &h->cabac, &h->cabac_state[21] ) )",
          "content_same": false
        },
        {
          "line": 1430,
          "old_api": null,
          "new_api": "ff_h264_check_intra_pred_mode",
          "old_text": null,
          "new_text": "ff_h264_check_intra_pred_mode( h, pred_mode )",
          "old_line_content": "            if( h->intra16x16_pred_mode < 0 ) return -1;",
          "new_line_content": "            pred_mode= ff_h264_check_intra_pred_mode( h, pred_mode );",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[22] )",
          "old_line_content": "    else",
          "new_line_content": "    if( !get_cabac( &h->cabac, &h->cabac_state[22] ) )",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[23] )",
          "old_line_content": "}",
          "new_line_content": "    if( get_cabac( &h->cabac, &h->cabac_state[23] ) )",
          "content_same": false
        },
        {
          "line": 1439,
          "old_api": null,
          "new_api": "decode_cabac_b_mb_sub_type",
          "old_text": null,
          "new_text": "decode_cabac_b_mb_sub_type( h )",
          "old_line_content": "        }",
          "new_line_content": "                h->sub_mb_type[i] = decode_cabac_b_mb_sub_type( h );",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[37] )",
          "old_line_content": "    return 3;       /* 4x4 */",
          "new_line_content": "    if( !get_cabac( &h->cabac, &h->cabac_state[37] ) )",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[39] )",
          "old_line_content": "}",
          "new_line_content": "        return 1 + get_cabac( &h->cabac, &h->cabac_state[39] ); /* B_L0_8x8, B_L1_8x8 */",
          "content_same": false
        },
        {
          "line": 1443,
          "old_api": null,
          "new_api": "IS_DIRECT",
          "old_text": null,
          "new_text": "IS_DIRECT(h->sub_mb_type[0] | h->sub_mb_type[1] |\n                          h->sub_mb_type[2] | h->sub_mb_type[3])",
          "old_line_content": "        if( h->slice_type_nos == FF_B_TYPE ) {",
          "new_line_content": "            if( IS_DIRECT(h->sub_mb_type[0] | h->sub_mb_type[1] |",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[38] )",
          "old_line_content": "    int type;",
          "new_line_content": "    if( get_cabac( &h->cabac, &h->cabac_state[38] ) ) {",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[39] )",
          "old_line_content": "        return 0;   /* B_Direct_8x8 */",
          "new_line_content": "            return 11 + get_cabac( &h->cabac, &h->cabac_state[39] ); /* B_L1_4x4, B_Bi_4x4 */",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[39] )",
          "old_line_content": "    type = 3;",
          "new_line_content": "    type += 2*get_cabac( &h->cabac, &h->cabac_state[39] );",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": null,
          "new_api": "IS_DIRECT",
          "old_text": null,
          "new_text": "IS_DIRECT(h->sub_mb_type[i])",
          "old_line_content": "                h->ref_cache[0][scan8[4]] =",
          "new_line_content": "                        if( IS_DIRECT(h->sub_mb_type[i]) )",
          "content_same": false
        },
        {
          "line": 1453,
          "old_api": null,
          "new_api": "fill_rectangle",
          "old_text": null,
          "new_text": "fill_rectangle( &h->direct_cache[scan8[4*i]], 2, 2, 8, 1, 1 )",
          "old_line_content": "                h->ref_cache[1][scan8[4]] =",
          "new_line_content": "                            fill_rectangle( &h->direct_cache[scan8[4*i]], 2, 2, 8, 1, 1 );",
          "content_same": false
        },
        {
          "line": 1466,
          "old_api": null,
          "new_api": "IS_DIRECT",
          "old_text": null,
          "new_text": "IS_DIRECT(h->sub_mb_type[i])",
          "old_line_content": "                h->sub_mb_type[i]=      p_sub_mb_type_info[ h->sub_mb_type[i] ].type;",
          "new_line_content": "                    if(IS_DIRECT(h->sub_mb_type[i])) continue;",
          "content_same": false
        },
        {
          "line": 1467,
          "old_api": null,
          "new_api": "IS_DIR",
          "old_text": null,
          "new_text": "IS_DIR(h->sub_mb_type[i], 0, list)",
          "old_line_content": "            }",
          "new_line_content": "                    if(IS_DIR(h->sub_mb_type[i], 0, list)){",
          "content_same": false
        },
        {
          "line": 1469,
          "old_api": null,
          "new_api": "decode_cabac_mb_ref",
          "old_text": null,
          "new_text": "decode_cabac_mb_ref( h, list, 4*i )",
          "old_line_content": "",
          "new_line_content": "                            ref[list][i] = decode_cabac_mb_ref( h, list, 4*i );",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref[list][i], h->ref_count[list])",
          "old_line_content": "                for( i = 0; i < 4; i++ ) {",
          "new_line_content": "                                av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref[list][i], h->ref_count[list]);",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[54+ctx] )",
          "old_line_content": "        if( refa > 0 )",
          "new_line_content": "    while( get_cabac( &h->cabac, &h->cabac_state[54+ctx] ) ) {",
          "content_same": false
        },
        {
          "line": 1485,
          "old_api": null,
          "new_api": "get_dct8x8_allowed",
          "old_text": null,
          "new_text": "get_dct8x8_allowed(h)",
          "old_line_content": "                                                       h->ref_cache[list][ scan8[4*i]+1 ]=",
          "new_line_content": "            dct8x8_allowed = get_dct8x8_allowed(h);",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": null,
          "new_api": "abs",
          "old_text": null,
          "new_text": "abs( h->mvd_cache[list][scan8[n] - 1][l] )",
          "old_line_content": "        }",
          "new_line_content": "    int amvd = abs( h->mvd_cache[list][scan8[n] - 1][l] ) +",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": null,
          "new_api": "abs",
          "old_text": null,
          "new_text": "abs( h->mvd_cache[list][scan8[n] - 8][l] )",
          "old_line_content": "    }",
          "new_line_content": "               abs( h->mvd_cache[list][scan8[n] - 8][l] );",
          "content_same": false
        },
        {
          "line": 1490,
          "old_api": null,
          "new_api": "IS_DIRECT",
          "old_text": null,
          "new_text": "IS_DIRECT(h->sub_mb_type[i])",
          "old_line_content": "        if(dct8x8_allowed)",
          "new_line_content": "                if(IS_DIRECT(h->sub_mb_type[i])){",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": null,
          "new_api": "IS_DIRECT",
          "old_text": null,
          "new_text": "IS_DIRECT(h->sub_mb_type[i])",
          "old_line_content": "                h->ref_cache[list][ scan8[4*i]   ]=h->ref_cache[list][ scan8[4*i]+1 ];",
          "new_line_content": "                if(IS_DIR(h->sub_mb_type[i], 0, list) && !IS_DIRECT(h->sub_mb_type[i])){",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": null,
          "new_api": "get_cabac",
          "old_text": null,
          "new_text": "get_cabac( &h->cabac, &h->cabac_state[ctxbase+ctx] )",
          "old_line_content": "",
          "new_line_content": "    while( mvd < 9 && get_cabac( &h->cabac, &h->cabac_state[ctxbase+ctx] ) ) {",
          "content_same": false
        },
        {
          "line": 1504,
          "old_api": null,
          "new_api": "pred_motion",
          "old_text": null,
          "new_text": "pred_motion(h, index, block_width, list, h->ref_cache[list][ scan8[index] ], &mpx, &mpy)",
          "old_line_content": "                    for(j=0; j<sub_partition_count[i]; j++){",
          "new_line_content": "                        pred_motion(h, index, block_width, list, h->ref_cache[list][ scan8[index] ], &mpx, &mpy);",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": null,
          "new_api": "decode_cabac_mb_mvd",
          "old_text": null,
          "new_text": "decode_cabac_mb_mvd( h, list, index, 0 )",
          "old_line_content": "                        int mx, my;",
          "new_line_content": "                        mx = mpx + decode_cabac_mb_mvd( h, list, index, 0 );",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": null,
          "new_api": "get_cabac_bypass",
          "old_text": null,
          "new_text": "get_cabac_bypass( &h->cabac )",
          "old_line_content": "        if( ctx < 6 )",
          "new_line_content": "        while( get_cabac_bypass( &h->cabac ) ) {",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": null,
          "new_api": "decode_cabac_mb_mvd",
          "old_text": null,
          "new_text": "decode_cabac_mb_mvd( h, list, index, 1 )",
          "old_line_content": "                        const int index= 4*i + block_width*j;",
          "new_line_content": "                        my = mpy + decode_cabac_mb_mvd( h, list, index, 1 );",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": null,
          "new_api": "tprintf",
          "old_text": null,
          "new_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "old_line_content": "                        int16_t (* mv_cache)[2]= &h->mv_cache[list][ scan8[index] ];",
          "new_line_content": "                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(h->s.avctx, AV_LOG_ERROR, \"overflow in decode_cabac_mb_mvd\\n\")",
          "old_line_content": "    if( mvd >= 9 ) {",
          "new_line_content": "                av_log(h->s.avctx, AV_LOG_ERROR, \"overflow in decode_cabac_mb_mvd\\n\");",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": null,
          "new_api": "get_cabac_bypass",
          "old_text": null,
          "new_text": "get_cabac_bypass( &h->cabac )",
          "old_line_content": "            if(k>24){",
          "new_line_content": "            if( get_cabac_bypass( &h->cabac ) )",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": null,
          "new_api": "get_cabac_bypass_sign",
          "old_text": null,
          "new_text": "get_cabac_bypass_sign( &h->cabac, -mvd )",
          "old_line_content": "        }",
          "new_line_content": "    return get_cabac_bypass_sign( &h->cabac, -mvd );",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": null,
          "new_api": "IS_SUB_8X4",
          "old_text": null,
          "new_text": "IS_SUB_8X4(sub_mb_type)",
          "old_line_content": "                            mv_cache[ 8 ][1]= mv_cache[ 9 ][1]= my;",
          "new_line_content": "                        }else if(IS_SUB_8X4(sub_mb_type)){",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1030,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(cat == 1 || cat == 2 || cat == 4)",
          "new_text": null,
          "old_line_content": "        assert(cat == 1 || cat == 2 || cat == 4);",
          "new_line_content": "        ctx++;",
          "content_same": false
        },
        {
          "line": 1553,
          "old_api": "IS_DIRECT",
          "new_api": null,
          "old_text": "IS_DIRECT(mb_type)",
          "new_text": null,
          "old_line_content": "    } else if( IS_DIRECT(mb_type) ) {",
          "new_line_content": "        int list, mx, my, i, mpx, mpy;",
          "content_same": false
        },
        {
          "line": 1555,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(h->mvd_cache[0][scan8[0]], 4, 4, 8, 0, 4)",
          "new_text": null,
          "old_line_content": "        fill_rectangle(h->mvd_cache[0][scan8[0]], 4, 4, 8, 0, 4);",
          "new_line_content": "            for(list=0; list<h->list_count; list++){",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": "DECLARE_ASM_CONST",
          "new_api": null,
          "old_text": "DECLARE_ASM_CONST(1, uint8_t, last_coeff_flag_offset_8x8)",
          "new_text": null,
          "old_line_content": "DECLARE_ASM_CONST(1, uint8_t, last_coeff_flag_offset_8x8)[63] = {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1560,
          "old_api": "IS_16X16",
          "new_api": null,
          "old_text": "IS_16X16(mb_type)",
          "new_text": null,
          "old_line_content": "        if(IS_16X16(mb_type)){",
          "new_line_content": "                        if(ref >= (unsigned)h->ref_count[list]){",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": "IS_DIR",
          "new_api": null,
          "old_text": "IS_DIR(mb_type, 0, list)",
          "new_text": null,
          "old_line_content": "                if(IS_DIR(mb_type, 0, list)){",
          "new_line_content": "                            return -1;",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": "decode_cabac_mb_ref",
          "new_api": null,
          "old_text": "decode_cabac_mb_ref(h, list, 0)",
          "new_text": null,
          "old_line_content": "                        ref= decode_cabac_mb_ref(h, list, 0);",
          "new_line_content": "                        ref=0;",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list])",
          "new_text": null,
          "old_line_content": "                            av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);",
          "new_line_content": "                }else",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": "IS_DIR",
          "new_api": null,
          "old_text": "IS_DIR(mb_type, 0, list)",
          "new_text": null,
          "old_line_content": "                if(IS_DIR(mb_type, 0, list)){",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": "decode_cabac_mb_mvd",
          "new_api": null,
          "old_text": "decode_cabac_mb_mvd( h, list, 0, 0 )",
          "new_text": null,
          "old_line_content": "                    mx = mpx + decode_cabac_mb_mvd( h, list, 0, 0 );",
          "new_line_content": "                }else",
          "content_same": false
        },
        {
          "line": 1582,
          "old_api": "tprintf",
          "new_api": null,
          "old_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "new_text": null,
          "old_line_content": "                    tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1585,
          "old_api": "pack16to32",
          "new_api": null,
          "old_text": "pack16to32(mx,my)",
          "new_text": null,
          "old_line_content": "                    fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, pack16to32(mx,my), 4);",
          "new_line_content": "            for(list=0; list<h->list_count; list++){",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": "IS_DIR",
          "new_api": null,
          "old_text": "IS_DIR(mb_type, i, list)",
          "new_text": null,
          "old_line_content": "                        if(IS_DIR(mb_type, i, list)){",
          "new_line_content": "                                    return -1;",
          "content_same": false
        },
        {
          "line": 1596,
          "old_api": "decode_cabac_mb_ref",
          "new_api": null,
          "old_text": "decode_cabac_mb_ref( h, list, 8*i )",
          "new_text": null,
          "old_line_content": "                                ref= decode_cabac_mb_ref( h, list, 8*i );",
          "new_line_content": "                                ref=0;",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list])",
          "new_text": null,
          "old_line_content": "                                    av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);",
          "new_line_content": "                        }else",
          "content_same": false
        },
        {
          "line": 1603,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, ref, 1)",
          "new_text": null,
          "old_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, ref, 1);",
          "new_line_content": "                for(i=0; i<2; i++){",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": "decode_cabac_mb_mvd",
          "new_api": null,
          "old_text": "decode_cabac_mb_mvd( h, list, 8*i, 0 )",
          "new_text": null,
          "old_line_content": "                        mx = mpx + decode_cabac_mb_mvd( h, list, 8*i, 0 );",
          "new_line_content": "                    }else{",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": "pack16to32",
          "new_api": null,
          "old_text": "pack16to32(mx-mpx,my-mpy)",
          "new_text": null,
          "old_line_content": "                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack16to32(mx-mpx,my-mpy), 4);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1617,
          "old_api": "pack16to32",
          "new_api": null,
          "old_text": "pack16to32(mx,my)",
          "new_text": null,
          "old_line_content": "                        fill_rectangle(h->mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack16to32(mx,my), 4);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(h-> mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 4)",
          "new_text": null,
          "old_line_content": "                        fill_rectangle(h-> mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 4);",
          "new_line_content": "            for(list=0; list<h->list_count; list++){",
          "content_same": false
        },
        {
          "line": 1628,
          "old_api": "IS_DIR",
          "new_api": null,
          "old_text": "IS_DIR(mb_type, i, list)",
          "new_text": null,
          "old_line_content": "                        if(IS_DIR(mb_type, i, list)){ //FIXME optimize",
          "new_line_content": "                                    return -1;",
          "content_same": false
        },
        {
          "line": 1631,
          "old_api": "decode_cabac_mb_ref",
          "new_api": null,
          "old_text": "decode_cabac_mb_ref( h, list, 4*i )",
          "new_text": null,
          "old_line_content": "                                ref= decode_cabac_mb_ref( h, list, 4*i );",
          "new_line_content": "                                ref=0;",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": "get_cabac_cbf_ctx",
          "new_api": null,
          "old_text": "get_cabac_cbf_ctx( h, cat, n, is_dc )",
          "new_text": null,
          "old_line_content": "        if( get_cabac( CC, &h->cabac_state[85 + get_cabac_cbf_ctx( h, cat, n, is_dc ) ] ) == 0 ) {",
          "new_line_content": "            h->cabac.low       = cc.low       ;",
          "content_same": false
        },
        {
          "line": 1633,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list])",
          "new_text": null,
          "old_line_content": "                                    av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);",
          "new_line_content": "                        }else",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, ref, 1)",
          "new_text": null,
          "old_line_content": "                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, ref, 1);",
          "new_line_content": "                for(i=0; i<2; i++){",
          "content_same": false
        },
        {
          "line": 1647,
          "old_api": "decode_cabac_mb_mvd",
          "new_api": null,
          "old_text": "decode_cabac_mb_mvd( h, list, 4*i, 0 )",
          "new_text": null,
          "old_line_content": "                        mx = mpx + decode_cabac_mb_mvd( h, list, 4*i, 0 );",
          "new_line_content": "                    }else{",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": "tprintf",
          "new_api": null,
          "old_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "new_text": null,
          "old_line_content": "                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": "pack16to32",
          "new_api": null,
          "old_text": "pack16to32(mx-mpx,my-mpy)",
          "new_text": null,
          "old_line_content": "                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack16to32(mx-mpx,my-mpy), 4);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1652,
          "old_api": "pack16to32",
          "new_api": null,
          "old_text": "pack16to32(mx,my)",
          "new_text": null,
          "old_line_content": "                        fill_rectangle(h->mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack16to32(mx,my), 4);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1654,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(h->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 4)",
          "new_text": null,
          "old_line_content": "                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 4);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(h-> mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 4)",
          "new_text": null,
          "old_line_content": "                        fill_rectangle(h-> mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 4);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": "IS_INTRA16x16",
          "new_api": null,
          "old_text": "IS_INTRA16x16( mb_type )",
          "new_text": null,
          "old_line_content": "    if( !IS_INTRA16x16( mb_type ) ) {",
          "new_line_content": "    h->cbp_table[mb_xy] = h->cbp = cbp;",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": "decode_cabac_mb_cbp_luma",
          "new_api": null,
          "old_text": "decode_cabac_mb_cbp_luma( h )",
          "new_text": null,
          "old_line_content": "        cbp  = decode_cabac_mb_cbp_luma( h );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": "decode_significance_x86",
          "new_api": null,
          "old_text": "decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index)",
          "new_text": null,
          "old_line_content": "        coeff_count= decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": "DECODE_SIGNIFICANCE",
          "new_api": null,
          "old_text": "DECODE_SIGNIFICANCE( 63, sig_off[last], last_coeff_flag_offset_8x8[last] )",
          "new_text": null,
          "old_line_content": "        DECODE_SIGNIFICANCE( 63, sig_off[last], last_coeff_flag_offset_8x8[last] );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "DECODE_SIGNIFICANCE",
          "new_api": null,
          "old_text": "DECODE_SIGNIFICANCE( max_coeff - 1, last, last )",
          "new_text": null,
          "old_line_content": "        DECODE_SIGNIFICANCE( max_coeff - 1, last, last );",
          "new_line_content": "        if( cat == 0 )",
          "content_same": false
        },
        {
          "line": 1676,
          "old_api": "decode_cabac_mb_transform_size",
          "new_api": null,
          "old_text": "decode_cabac_mb_transform_size( h )",
          "new_text": null,
          "old_line_content": "        if( decode_cabac_mb_transform_size( h ) )",
          "new_line_content": "        const uint8_t *scan, *scan8x8, *dc_scan;",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(coeff_count > 0)",
          "new_text": null,
          "old_line_content": "    assert(coeff_count > 0);",
          "new_line_content": "            h->cbp_table[h->mb_xy] |= 0x40 << n;",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": "IS_INTRA16x16",
          "new_api": null,
          "old_text": "IS_INTRA16x16( mb_type )",
          "new_text": null,
          "old_line_content": "    if( cbp || IS_INTRA16x16( mb_type ) ) {",
          "new_line_content": "            scan8x8= s->qscale ? h->field_scan8x8 : h->field_scan8x8_q0;",
          "content_same": false
        },
        {
          "line": 1686,
          "old_api": "IS_INTERLACED",
          "new_api": null,
          "old_text": "IS_INTERLACED(mb_type)",
          "new_text": null,
          "old_line_content": "        if(IS_INTERLACED(mb_type)){",
          "new_line_content": "            scan= s->qscale ? h->zigzag_scan : h->zigzag_scan_q0;",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1)",
          "new_text": null,
          "old_line_content": "            fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1178,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert( cat == 1 || cat == 2 || cat == 4 )",
          "new_text": null,
          "old_line_content": "            assert( cat == 1 || cat == 2 || cat == 4 );",
          "new_line_content": "        uint8_t *ctx = coeff_abs_level1_ctx[node_ctx] + abs_level_m1_ctx_base;",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": "decode_cabac_mb_dqp",
          "new_api": null,
          "old_text": "decode_cabac_mb_dqp( h )",
          "new_text": null,
          "old_line_content": "        h->last_qscale_diff = dqp = decode_cabac_mb_dqp( h );",
          "new_line_content": "        if(((unsigned)s->qscale) > 51){",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(h->s.avctx, AV_LOG_ERROR, \"cabac decode of qscale diff failed at %d %d\\n\", s->mb_x, s->mb_y)",
          "new_text": null,
          "old_line_content": "            av_log(h->s.avctx, AV_LOG_ERROR, \"cabac decode of qscale diff failed at %d %d\\n\", s->mb_x, s->mb_y);",
          "new_line_content": "            else            s->qscale-= 52;",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( CC, ctx )",
          "new_text": null,
          "old_line_content": "        if( get_cabac( CC, ctx ) == 0 ) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "get_cabac_bypass_sign",
          "new_api": null,
          "old_text": "get_cabac_bypass_sign( CC, -1)",
          "new_text": null,
          "old_line_content": "                block[j] = get_cabac_bypass_sign( CC, -1);",
          "new_line_content": "            ctx = coeff_abs_levelgt1_ctx[node_ctx] + abs_level_m1_ctx_base;",
          "content_same": false
        },
        {
          "line": 1193,
          "old_api": "get_cabac_bypass_sign",
          "new_api": null,
          "old_text": "get_cabac_bypass_sign( CC, -qmul[j])",
          "new_text": null,
          "old_line_content": "                block[j] = (get_cabac_bypass_sign( CC, -qmul[j]) + 32) >> 6;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": "get_chroma_qp",
          "new_api": null,
          "old_text": "get_chroma_qp(h, 1, s->qscale)",
          "new_text": null,
          "old_line_content": "        h->chroma_qp[1] = get_chroma_qp(h, 1, s->qscale);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": "IS_INTRA16x16",
          "new_api": null,
          "old_text": "IS_INTRA16x16( mb_type )",
          "new_text": null,
          "old_line_content": "        if( IS_INTRA16x16( mb_type ) ) {",
          "new_line_content": "                qmul = h->dequant4_coeff[0][s->qscale];",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": "decode_cabac_residual",
          "new_api": null,
          "old_text": "decode_cabac_residual(h, h->mb + 16*i, 1, i, scan + 1, qmul, 15)",
          "new_text": null,
          "old_line_content": "                    decode_cabac_residual(h, h->mb + 16*i, 1, i, scan + 1, qmul, 15);",
          "new_line_content": "            int i8x8, i4x4;",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": "IS_8x8DCT",
          "new_api": null,
          "old_text": "IS_8x8DCT(mb_type)",
          "new_text": null,
          "old_line_content": "                    if( IS_8x8DCT(mb_type) ) {",
          "new_line_content": "                            const int index = 4*i8x8 + i4x4;",
          "content_same": false
        },
        {
          "line": 1728,
          "old_api": "decode_cabac_residual",
          "new_api": null,
          "old_text": "decode_cabac_residual(h, h->mb + 64*i8x8, 5, 4*i8x8,\n                            scan8x8, h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 64)",
          "new_text": null,
          "old_line_content": "                        decode_cabac_residual(h, h->mb + 64*i8x8, 5, 4*i8x8,",
          "new_line_content": "                            //av_log( s->avctx, AV_LOG_ERROR, \"Luma4x4: %d\\n\", index );",
          "content_same": false
        },
        {
          "line": 1729,
          "old_api": "IS_INTRA",
          "new_api": null,
          "old_text": "IS_INTRA( mb_type )",
          "new_text": null,
          "old_line_content": "                            scan8x8, h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 64);",
          "new_line_content": "//START_TIMER",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": "get_cabac_bypass_sign",
          "new_api": null,
          "old_text": "get_cabac_bypass_sign( CC, -coeff_abs )",
          "new_text": null,
          "old_line_content": "                block[j] = get_cabac_bypass_sign( CC, -coeff_abs );",
          "new_line_content": "#ifdef CABAC_ON_STACK",
          "content_same": false
        },
        {
          "line": 1731,
          "old_api": "IS_INTRA",
          "new_api": null,
          "old_text": "IS_INTRA( mb_type )",
          "new_text": null,
          "old_line_content": "                        qmul = h->dequant4_coeff[IS_INTRA( mb_type ) ? 0:3][s->qscale];",
          "new_line_content": "//STOP_TIMER(\"decode_residual\")",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": "get_cabac_bypass_sign",
          "new_api": null,
          "old_text": "get_cabac_bypass_sign( CC, -coeff_abs )",
          "new_text": null,
          "old_line_content": "                block[j] = (get_cabac_bypass_sign( CC, -coeff_abs ) * qmul[j] + 32) >> 6;",
          "new_line_content": "            h->cabac.low       = cc.low       ;",
          "content_same": false
        },
        {
          "line": 1736,
          "old_api": "decode_cabac_residual",
          "new_api": null,
          "old_text": "decode_cabac_residual(h, h->mb + 16*index, 2, index, scan, qmul, 16)",
          "new_text": null,
          "old_line_content": "                            decode_cabac_residual(h, h->mb + 16*index, 2, index, scan, qmul, 16);",
          "new_line_content": "                    nnz[0] = nnz[1] = nnz[8] = nnz[9] = 0;",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": "IS_INTERLACED",
          "new_api": null,
          "old_text": "IS_INTERLACED( s->current_picture.mb_type[mba_xy] )",
          "new_text": null,
          "old_line_content": "    if( h->slice_table[mba_xy] == h->slice_num && IS_INTERLACED( s->current_picture.mb_type[mba_xy] ) ) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": "IS_INTERLACED",
          "new_api": null,
          "old_text": "IS_INTERLACED( s->current_picture.mb_type[mbb_xy] )",
          "new_text": null,
          "old_line_content": "    if( h->slice_table[mbb_xy] == h->slice_num && IS_INTERLACED( s->current_picture.mb_type[mbb_xy] ) ) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": "decode_cabac_residual_internal",
          "new_api": null,
          "old_text": "decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 1)",
          "new_text": null,
          "old_line_content": "    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 1);",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[70 + ctx] )",
          "new_text": null,
          "old_line_content": "    return get_cabac_noinline( &h->cabac, &h->cabac_state[70 + ctx] );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": "decode_cabac_residual",
          "new_api": null,
          "old_text": "decode_cabac_residual(h, h->mb + 256 + 16*4*c, 3, c, chroma_dc_scan, NULL, 4)",
          "new_text": null,
          "old_line_content": "                decode_cabac_residual(h, h->mb + 256 + 16*4*c, 3, c, chroma_dc_scan, NULL, 4);",
          "new_line_content": "            for( c = 0; c < 2; c++ ) {",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": "decode_cabac_residual_internal",
          "new_api": null,
          "old_text": "decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, cat == 0 || cat == 3)",
          "new_text": null,
          "old_line_content": "    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, cat == 0 || cat == 3);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": "decode_cabac_residual_dc",
          "new_api": null,
          "old_text": "decode_cabac_residual_dc(h, block, cat, n, scantable, qmul, max_coeff)",
          "new_text": null,
          "old_line_content": "    if( cat == 0 || cat == 3 ) decode_cabac_residual_dc(h, block, cat, n, scantable, qmul, max_coeff);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": "IS_INTRA4x4",
          "new_api": null,
          "old_text": "IS_INTRA4x4( s->current_picture.mb_type[mba_xy] )",
          "new_text": null,
          "old_line_content": "        if( h->slice_table[mba_xy] == h->slice_num && !IS_INTRA4x4( s->current_picture.mb_type[mba_xy] ) )",
          "new_line_content": "        state += 2;",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": "decode_cabac_residual_nondc",
          "new_api": null,
          "old_text": "decode_cabac_residual_nondc(h, block, cat, n, scantable, qmul, max_coeff)",
          "new_text": null,
          "old_line_content": "    else decode_cabac_residual_nondc(h, block, cat, n, scantable, qmul, max_coeff);",
          "new_line_content": "    MpegEncContext * const s = &h->s;",
          "content_same": false
        },
        {
          "line": 1758,
          "old_api": "IS_INTRA",
          "new_api": null,
          "old_text": "IS_INTRA( mb_type )",
          "new_text": null,
          "old_line_content": "                qmul = h->dequant4_coeff[c+1+(IS_INTRA( mb_type ) ? 0:3)][h->chroma_qp[c]];",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1762,
          "old_api": "decode_cabac_residual",
          "new_api": null,
          "old_text": "decode_cabac_residual(h, h->mb + 16*index, 4, index, scan + 1, qmul, 15)",
          "new_text": null,
          "old_line_content": "                    decode_cabac_residual(h, h->mb + 16*index, 4, index, scan + 1, qmul, 15);",
          "new_line_content": "            nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0;",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &state[ctx] )",
          "new_text": null,
          "old_line_content": "        if( get_cabac_noinline( &h->cabac, &state[ctx] ) == 0 )",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, state )",
          "new_text": null,
          "old_line_content": "        if( get_cabac_noinline( &h->cabac, state ) == 0 )",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": "IS_INTERLACED",
          "new_api": null,
          "old_text": "IS_INTERLACED(s->current_picture.mb_type[top_pair_xy])",
          "new_text": null,
          "old_line_content": "        const int top_mb_field_flag  = IS_INTERLACED(s->current_picture.mb_type[top_pair_xy]);",
          "new_line_content": "            h->top_mb_xy -= s->mb_stride;",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": "IS_INTERLACED",
          "new_api": null,
          "old_text": "IS_INTERLACED(s->current_picture.mb_type[pair_xy-1])",
          "new_text": null,
          "old_line_content": "        const int left_mb_field_flag = IS_INTERLACED(s->current_picture.mb_type[pair_xy-1]);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1772,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1)",
          "new_text": null,
          "old_line_content": "        fill_rectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1);",
          "new_line_content": "    s->current_picture.qscale_table[mb_xy]= s->qscale;",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &state[1] )",
          "new_text": null,
          "old_line_content": "    mb_type += 12 * get_cabac_noinline( &h->cabac, &state[1] ); /* cbp_luma != 0 */",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &state[2] )",
          "new_text": null,
          "old_line_content": "    if( get_cabac_noinline( &h->cabac, &state[2] ) ) /* cbp_chroma */",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &state[2+intra_slice] )",
          "new_text": null,
          "old_line_content": "        mb_type += 4 + 4 * get_cabac_noinline( &h->cabac, &state[2+intra_slice] );",
          "new_line_content": "static int decode_cabac_mb_type_b( H264Context *h ) {",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &state[3+intra_slice] )",
          "new_text": null,
          "old_line_content": "    mb_type += 2 * get_cabac_noinline( &h->cabac, &state[3+intra_slice] );",
          "new_line_content": "    MpegEncContext * const s = &h->s;",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &state[3+2*intra_slice] )",
          "new_text": null,
          "old_line_content": "    mb_type += 1 * get_cabac_noinline( &h->cabac, &state[3+2*intra_slice] );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1779,
          "old_api": "write_back_non_zero_count",
          "new_api": null,
          "old_text": "write_back_non_zero_count(h)",
          "new_text": null,
          "old_line_content": "    write_back_non_zero_count(h);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(h->slice_type_nos == FF_B_TYPE)",
          "new_text": null,
          "old_line_content": "        assert(h->slice_type_nos == FF_B_TYPE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": "IS_DIRECT",
          "new_api": null,
          "old_text": "IS_DIRECT( s->current_picture.mb_type[mba_xy] )",
          "new_text": null,
          "old_line_content": "        if( h->slice_table[mba_xy] == h->slice_num && !IS_DIRECT( s->current_picture.mb_type[mba_xy] ) )",
          "new_line_content": "            return 0; /* B_Direct_16x16 */",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+ctx] )",
          "new_text": null,
          "old_line_content": "        if( !get_cabac_noinline( &h->cabac, &h->cabac_state[27+ctx] ) )",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1289,
          "old_api": "tprintf",
          "new_api": null,
          "old_text": "tprintf(s->avctx, \"pic:%d mb:%d/%d\\n\", h->frame_num, s->mb_x, s->mb_y)",
          "new_text": null,
          "old_line_content": "    tprintf(s->avctx, \"pic:%d mb:%d/%d\\n\", h->frame_num, s->mb_x, s->mb_y);",
          "new_line_content": "        if( FRAME_MBAFF && (s->mb_y&1)==1 && h->prev_mb_skipped )",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+4] )",
          "new_text": null,
          "old_line_content": "        bits = get_cabac_noinline( &h->cabac, &h->cabac_state[27+4] ) << 3;",
          "new_line_content": "        else if( bits == 13 ) {",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] )",
          "new_text": null,
          "old_line_content": "        bits|= get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] ) << 1;",
          "new_line_content": "        } else if( bits == 14 )",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] )",
          "new_text": null,
          "old_line_content": "        bits|= get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] );",
          "new_line_content": "            return 11; /* B_L1_L0_8x16 */",
          "content_same": false
        },
        {
          "line": 1294,
          "old_api": "predict_field_decoding_flag",
          "new_api": null,
          "old_text": "predict_field_decoding_flag(h)",
          "new_text": null,
          "old_line_content": "            predict_field_decoding_flag(h);",
          "new_line_content": "        if( skip ) {",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": "decode_cabac_mb_skip",
          "new_api": null,
          "old_text": "decode_cabac_mb_skip( h, s->mb_x, s->mb_y )",
          "new_text": null,
          "old_line_content": "            skip = decode_cabac_mb_skip( h, s->mb_x, s->mb_y );",
          "new_line_content": "                if(!h->next_mb_skipped)",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": "decode_cabac_mb_skip",
          "new_api": null,
          "old_text": "decode_cabac_mb_skip( h, s->mb_x, s->mb_y+1 )",
          "new_text": null,
          "old_line_content": "                h->next_mb_skipped = decode_cabac_mb_skip( h, s->mb_x, s->mb_y+1 );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] )",
          "new_text": null,
          "old_line_content": "        bits= ( bits<<1 ) | get_cabac_noinline( &h->cabac, &h->cabac_state[27+5] );",
          "new_line_content": "    int mba_xy, mbb_xy;",
          "content_same": false
        },
        {
          "line": 1305,
          "old_api": "decode_cabac_field_decoding_flag",
          "new_api": null,
          "old_text": "decode_cabac_field_decoding_flag(h)",
          "new_text": null,
          "old_line_content": "                    h->mb_mbaff = h->mb_field_decoding_flag = decode_cabac_field_decoding_flag(h);",
          "new_line_content": "            h->chroma_pred_mode_table[mb_xy] = 0;",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": "decode_mb_skip",
          "new_api": null,
          "old_text": "decode_mb_skip(h)",
          "new_text": null,
          "old_line_content": "            decode_mb_skip(h);",
          "new_line_content": "            return 0;",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": "decode_cabac_field_decoding_flag",
          "new_api": null,
          "old_text": "decode_cabac_field_decoding_flag(h)",
          "new_text": null,
          "old_line_content": "            h->mb_field_decoding_flag = decode_cabac_field_decoding_flag(h);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "IS_INTERLACED",
          "new_api": null,
          "old_text": "IS_INTERLACED( s->current_picture.mb_type[mbb_xy] )",
          "new_text": null,
          "old_line_content": "                && IS_INTERLACED( s->current_picture.mb_type[mbb_xy] ) )",
          "new_line_content": "        mba_xy = mb_xy - 1;",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": "compute_mb_neighbors",
          "new_api": null,
          "old_text": "compute_mb_neighbors(h)",
          "new_text": null,
          "old_line_content": "    compute_mb_neighbors(h);",
          "new_line_content": "            mb_type=         b_mb_type_info[mb_type].type;",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": "decode_cabac_mb_type_b",
          "new_api": null,
          "old_text": "decode_cabac_mb_type_b( h )",
          "new_text": null,
          "old_line_content": "        mb_type = decode_cabac_mb_type_b( h );",
          "new_line_content": "            goto decode_intra_mb;",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": "IS_SKIP",
          "new_api": null,
          "old_text": "IS_SKIP( s->current_picture.mb_type[mba_xy] )",
          "new_text": null,
          "old_line_content": "    if( h->slice_table[mba_xy] == h->slice_num && !IS_SKIP( s->current_picture.mb_type[mba_xy] ))",
          "new_line_content": "        ctx += 13;",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": "IS_SKIP",
          "new_api": null,
          "old_text": "IS_SKIP( s->current_picture.mb_type[mbb_xy] )",
          "new_text": null,
          "old_line_content": "    if( h->slice_table[mbb_xy] == h->slice_num && !IS_SKIP( s->current_picture.mb_type[mbb_xy] ))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[14] )",
          "new_text": null,
          "old_line_content": "        if( get_cabac_noinline( &h->cabac, &h->cabac_state[14] ) == 0 ) {",
          "new_line_content": "                /* P_L0_D8x16, P_L0_D16x8 */",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[15] )",
          "new_text": null,
          "old_line_content": "            if( get_cabac_noinline( &h->cabac, &h->cabac_state[15] ) == 0 ) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1342,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[16] )",
          "new_text": null,
          "old_line_content": "                mb_type= 3 * get_cabac_noinline( &h->cabac, &h->cabac_state[16] );",
          "new_line_content": "            mb_type=         p_mb_type_info[mb_type].type;",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[17] )",
          "new_text": null,
          "old_line_content": "                mb_type= 2 - get_cabac_noinline( &h->cabac, &h->cabac_state[17] );",
          "new_line_content": "            goto decode_intra_mb;",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[68] )",
          "new_text": null,
          "old_line_content": "    if( get_cabac( &h->cabac, &h->cabac_state[68] ) )",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1350,
          "old_api": "decode_cabac_intra_mb_type",
          "new_api": null,
          "old_text": "decode_cabac_intra_mb_type(h, 17, 0)",
          "new_text": null,
          "old_line_content": "            mb_type= decode_cabac_intra_mb_type(h, 17, 0);",
          "new_line_content": "            mb_type--;",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[69] )",
          "new_text": null,
          "old_line_content": "    mode += 1 * get_cabac( &h->cabac, &h->cabac_state[69] );",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[69] )",
          "new_text": null,
          "old_line_content": "    mode += 2 * get_cabac( &h->cabac, &h->cabac_state[69] );",
          "new_line_content": "        return mode;",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[69] )",
          "new_text": null,
          "old_line_content": "    mode += 4 * get_cabac( &h->cabac, &h->cabac_state[69] );",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1354,
          "old_api": "decode_cabac_intra_mb_type",
          "new_api": null,
          "old_text": "decode_cabac_intra_mb_type(h, 3, 1)",
          "new_text": null,
          "old_line_content": "        mb_type= decode_cabac_intra_mb_type(h, 3, 1);",
          "new_line_content": "        cbp= i_mb_type_info[mb_type].cbp;",
          "content_same": false
        },
        {
          "line": 1357,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(h->slice_type_nos == FF_I_TYPE)",
          "new_text": null,
          "old_line_content": "        assert(h->slice_type_nos == FF_I_TYPE);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": "IS_INTRA_PCM",
          "new_api": null,
          "old_text": "IS_INTRA_PCM(mb_type)",
          "new_text": null,
          "old_line_content": "    if(IS_INTRA_PCM(mb_type)) {",
          "new_line_content": "        ptr= h->cabac.bytestream;",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[64+ctx] )",
          "new_text": null,
          "old_line_content": "    if( get_cabac_noinline( &h->cabac, &h->cabac_state[64+ctx] ) == 0 )",
          "new_line_content": "        return 2;",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[64+3] )",
          "new_text": null,
          "old_line_content": "    if( get_cabac_noinline( &h->cabac, &h->cabac_state[64+3] ) == 0 )",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[64+3] )",
          "new_text": null,
          "old_line_content": "    if( get_cabac_noinline( &h->cabac, &h->cabac_state[64+3] ) == 0 )",
          "new_line_content": "static int decode_cabac_mb_cbp_luma( H264Context *h) {",
          "content_same": false
        },
        {
          "line": 1382,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(h->mb, ptr, 256)",
          "new_text": null,
          "old_line_content": "        memcpy(h->mb, ptr, 256); ptr+=256;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1384,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(h->mb+128, ptr, 128)",
          "new_text": null,
          "old_line_content": "            memcpy(h->mb+128, ptr, 128); ptr+=128;",
          "new_line_content": "        h->cbp_table[mb_xy] = 0x1ef;",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": "ff_init_cabac_decoder",
          "new_api": null,
          "old_text": "ff_init_cabac_decoder(&h->cabac, ptr, h->cabac.bytestream_end - ptr)",
          "new_text": null,
          "old_line_content": "        ff_init_cabac_decoder(&h->cabac, ptr, h->cabac.bytestream_end - ptr);",
          "new_line_content": "        s->current_picture.qscale_table[mb_xy]= 0;",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx])",
          "new_text": null,
          "old_line_content": "    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1395,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(h->non_zero_count[mb_xy], 16, 32)",
          "new_text": null,
          "old_line_content": "        memset(h->non_zero_count[mb_xy], 16, 32);",
          "new_line_content": "    if(MB_MBAFF){",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx])",
          "new_text": null,
          "old_line_content": "    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;",
          "new_line_content": "    int ctx;",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx])",
          "new_text": null,
          "old_line_content": "    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1406,
          "old_api": "fill_decode_caches",
          "new_api": null,
          "old_text": "fill_decode_caches(h, mb_type)",
          "new_text": null,
          "old_line_content": "    fill_decode_caches(h, mb_type);",
          "new_line_content": "                mb_type |= MB_TYPE_8x8DCT;",
          "content_same": false
        },
        {
          "line": 1411,
          "old_api": "decode_cabac_mb_transform_size",
          "new_api": null,
          "old_text": "decode_cabac_mb_transform_size( h )",
          "new_text": null,
          "old_line_content": "            if( dct8x8_allowed && decode_cabac_mb_transform_size( h ) ) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1416,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle( &h->intra4x4_pred_mode_cache[ scan8[i] ], 2, 2, 8, mode, 1 )",
          "new_text": null,
          "old_line_content": "                    fill_rectangle( &h->intra4x4_pred_mode_cache[ scan8[i] ], 2, 2, 8, mode, 1 );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[60 + ctx] )",
          "new_text": null,
          "old_line_content": "    while( get_cabac_noinline( &h->cabac, &h->cabac_state[60 + ctx] ) ) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1426,
          "old_api": "ff_h264_write_back_intra_pred_mode",
          "new_api": null,
          "old_text": "ff_h264_write_back_intra_pred_mode(h)",
          "new_text": null,
          "old_line_content": "            ff_h264_write_back_intra_pred_mode(h);",
          "new_line_content": "        if(CHROMA){",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": "ff_h264_check_intra4x4_pred_mode",
          "new_api": null,
          "old_text": "ff_h264_check_intra4x4_pred_mode(h)",
          "new_text": null,
          "old_line_content": "            if( ff_h264_check_intra4x4_pred_mode(h) < 0 ) return -1;",
          "new_line_content": "            h->chroma_pred_mode_table[mb_xy] =",
          "content_same": false
        },
        {
          "line": 1429,
          "old_api": "ff_h264_check_intra_pred_mode",
          "new_api": null,
          "old_text": "ff_h264_check_intra_pred_mode( h, h->intra16x16_pred_mode )",
          "new_text": null,
          "old_line_content": "            h->intra16x16_pred_mode= ff_h264_check_intra_pred_mode( h, h->intra16x16_pred_mode );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": "decode_cabac_mb_chroma_pre_mode",
          "new_api": null,
          "old_text": "decode_cabac_mb_chroma_pre_mode( h )",
          "new_text": null,
          "old_line_content": "            pred_mode                        = decode_cabac_mb_chroma_pre_mode( h );",
          "new_line_content": "    } else if( partition_count == 4 ) {",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[21] )",
          "new_text": null,
          "old_line_content": "    if( get_cabac( &h->cabac, &h->cabac_state[21] ) )",
          "new_line_content": "    return 3;       /* 4x4 */",
          "content_same": false
        },
        {
          "line": 1436,
          "old_api": "ff_h264_check_intra_pred_mode",
          "new_api": null,
          "old_text": "ff_h264_check_intra_pred_mode( h, pred_mode )",
          "new_text": null,
          "old_line_content": "            pred_mode= ff_h264_check_intra_pred_mode( h, pred_mode );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[22] )",
          "new_text": null,
          "old_line_content": "    if( !get_cabac( &h->cabac, &h->cabac_state[22] ) )",
          "new_line_content": "static int decode_cabac_b_mb_sub_type( H264Context *h ) {",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[37] )",
          "new_text": null,
          "old_line_content": "    if( !get_cabac( &h->cabac, &h->cabac_state[37] ) )",
          "new_line_content": "        type += 4;",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[39] )",
          "new_text": null,
          "old_line_content": "        return 1 + get_cabac( &h->cabac, &h->cabac_state[39] ); /* B_L0_8x8, B_L1_8x8 */",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": "IS_DIRECT",
          "new_api": null,
          "old_text": "IS_DIRECT(h->sub_mb_type[0] | h->sub_mb_type[1] |\n                          h->sub_mb_type[2] | h->sub_mb_type[3])",
          "new_text": null,
          "old_line_content": "            if( IS_DIRECT(h->sub_mb_type[0] | h->sub_mb_type[1] |",
          "new_line_content": "                h->ref_cache[1][scan8[12]] = PART_NOT_AVAILABLE;",
          "content_same": false
        },
        {
          "line": 1451,
          "old_api": "ff_h264_pred_direct_motion",
          "new_api": null,
          "old_text": "ff_h264_pred_direct_motion(h, &mb_type)",
          "new_text": null,
          "old_line_content": "                ff_h264_pred_direct_motion(h, &mb_type);",
          "new_line_content": "                    for( i = 0; i < 4; i++ )",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[39] )",
          "new_text": null,
          "old_line_content": "        if( get_cabac( &h->cabac, &h->cabac_state[39] ) )",
          "new_line_content": "    return type;",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[39] )",
          "new_text": null,
          "old_line_content": "            return 11 + get_cabac( &h->cabac, &h->cabac_state[39] ); /* B_L1_4x4, B_Bi_4x4 */",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[39] )",
          "new_text": null,
          "old_line_content": "    type +=   get_cabac( &h->cabac, &h->cabac_state[39] );",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1459,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle( &h->direct_cache[scan8[4*i]], 2, 2, 8, 1, 1 )",
          "new_text": null,
          "old_line_content": "                            fill_rectangle( &h->direct_cache[scan8[4*i]], 2, 2, 8, 1, 1 );",
          "new_line_content": "                sub_partition_count[i]= p_sub_mb_type_info[ h->sub_mb_type[i] ].partition_count;",
          "content_same": false
        },
        {
          "line": 950,
          "old_api": "get_cabac_noinline",
          "new_api": null,
          "old_text": "get_cabac_noinline( &h->cabac, &h->cabac_state[399 + h->neighbor_transform_size] )",
          "new_text": null,
          "old_line_content": "    return get_cabac_noinline( &h->cabac, &h->cabac_state[399 + h->neighbor_transform_size] );",
          "new_line_content": "    int ref  = 0;",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": "decode_cabac_p_mb_sub_type",
          "new_api": null,
          "old_text": "decode_cabac_p_mb_sub_type( h )",
          "new_text": null,
          "old_line_content": "                h->sub_mb_type[i] = decode_cabac_p_mb_sub_type( h );",
          "new_line_content": "        for( list = 0; list < h->list_count; list++ ) {",
          "content_same": false
        },
        {
          "line": 1472,
          "old_api": "IS_DIRECT",
          "new_api": null,
          "old_text": "IS_DIRECT(h->sub_mb_type[i])",
          "new_text": null,
          "old_line_content": "                    if(IS_DIRECT(h->sub_mb_type[i])) continue;",
          "new_line_content": "                                return -1;",
          "content_same": false
        },
        {
          "line": 1473,
          "old_api": "IS_DIR",
          "new_api": null,
          "old_text": "IS_DIR(h->sub_mb_type[i], 0, list)",
          "new_text": null,
          "old_line_content": "                    if(IS_DIR(h->sub_mb_type[i], 0, list)){",
          "new_line_content": "                            }",
          "content_same": false
        },
        {
          "line": 1475,
          "old_api": "decode_cabac_mb_ref",
          "new_api": null,
          "old_text": "decode_cabac_mb_ref( h, list, 4*i )",
          "new_text": null,
          "old_line_content": "                            ref[list][i] = decode_cabac_mb_ref( h, list, 4*i );",
          "new_line_content": "                            ref[list][i] = 0;",
          "content_same": false
        },
        {
          "line": 1477,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref[list][i], h->ref_count[list])",
          "new_text": null,
          "old_line_content": "                                av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref[list][i], h->ref_count[list]);",
          "new_line_content": "                        ref[list][i] = -1;",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[54+ctx] )",
          "new_text": null,
          "old_line_content": "    while( get_cabac( &h->cabac, &h->cabac_state[54+ctx] ) ) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "abs",
          "new_api": null,
          "old_text": "abs( h->mvd_cache[list][scan8[n] - 8][l] )",
          "new_text": null,
          "old_line_content": "               abs( h->mvd_cache[list][scan8[n] - 8][l] );",
          "new_line_content": "        return 0;",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": "IS_DIRECT",
          "new_api": null,
          "old_text": "IS_DIRECT(h->sub_mb_type[i])",
          "new_text": null,
          "old_line_content": "                if(IS_DIRECT(h->sub_mb_type[i])){",
          "new_line_content": "                    const int sub_mb_type= h->sub_mb_type[i];",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": "fill_rectangle",
          "new_api": null,
          "old_text": "fill_rectangle(h->mvd_cache[list][scan8[4*i]], 2, 2, 8, 0, 4)",
          "new_text": null,
          "old_line_content": "                    fill_rectangle(h->mvd_cache[list][scan8[4*i]], 2, 2, 8, 0, 4);",
          "new_line_content": "                    const int block_width= (sub_mb_type & (MB_TYPE_16x16|MB_TYPE_16x8)) ? 2 : 1;",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac(&h->cabac, &h->cabac_state[ctxbase+ctx])",
          "new_text": null,
          "old_line_content": "    if(!get_cabac(&h->cabac, &h->cabac_state[ctxbase+ctx]))",
          "new_line_content": "        mvd++;",
          "content_same": false
        },
        {
          "line": 1501,
          "old_api": "IS_DIRECT",
          "new_api": null,
          "old_text": "IS_DIRECT(h->sub_mb_type[i])",
          "new_text": null,
          "old_line_content": "                if(IS_DIR(h->sub_mb_type[i], 0, list) && !IS_DIRECT(h->sub_mb_type[i])){",
          "new_line_content": "                        const int index= 4*i + block_width*j;",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": "get_cabac",
          "new_api": null,
          "old_text": "get_cabac( &h->cabac, &h->cabac_state[ctxbase+ctx] )",
          "new_text": null,
          "old_line_content": "    while( mvd < 9 && get_cabac( &h->cabac, &h->cabac_state[ctxbase+ctx] ) ) {",
          "new_line_content": "    if( mvd >= 9 ) {",
          "content_same": false
        },
        {
          "line": 1512,
          "old_api": "decode_cabac_mb_mvd",
          "new_api": null,
          "old_text": "decode_cabac_mb_mvd( h, list, index, 0 )",
          "new_text": null,
          "old_line_content": "                        mx = mpx + decode_cabac_mb_mvd( h, list, index, 0 );",
          "new_line_content": "                            mv_cache[ 8 ][0]= mv_cache[ 9 ][0]= mx;",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "get_cabac_bypass",
          "new_api": null,
          "old_text": "get_cabac_bypass( &h->cabac )",
          "new_text": null,
          "old_line_content": "        while( get_cabac_bypass( &h->cabac ) ) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": "decode_cabac_mb_mvd",
          "new_api": null,
          "old_text": "decode_cabac_mb_mvd( h, list, index, 1 )",
          "new_text": null,
          "old_line_content": "                        my = mpy + decode_cabac_mb_mvd( h, list, index, 1 );",
          "new_line_content": "                            mv_cache[ 1 ][1]=",
          "content_same": false
        },
        {
          "line": 1514,
          "old_api": "tprintf",
          "new_api": null,
          "old_text": "tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my)",
          "new_text": null,
          "old_line_content": "                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);",
          "new_line_content": "                            mv_cache[ 8 ][1]= mv_cache[ 9 ][1]= my;",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": "IS_SUB_8X8",
          "new_api": null,
          "old_text": "IS_SUB_8X8(sub_mb_type)",
          "new_text": null,
          "old_line_content": "                        if(IS_SUB_8X8(sub_mb_type)){",
          "new_line_content": "                            mvd_cache[ 1 ][0]=",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(h->s.avctx, AV_LOG_ERROR, \"overflow in decode_cabac_mb_mvd\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(h->s.avctx, AV_LOG_ERROR, \"overflow in decode_cabac_mb_mvd\\n\");",
          "new_line_content": "                mvd += 1 << k;",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": "get_cabac_bypass",
          "new_api": null,
          "old_text": "get_cabac_bypass( &h->cabac )",
          "new_text": null,
          "old_line_content": "            if( get_cabac_bypass( &h->cabac ) )",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": "get_cabac_bypass_sign",
          "new_api": null,
          "old_text": "get_cabac_bypass_sign( &h->cabac, -mvd )",
          "new_text": null,
          "old_line_content": "    return get_cabac_bypass_sign( &h->cabac, -mvd );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1532,
          "old_api": "IS_SUB_4X8",
          "new_api": null,
          "old_text": "IS_SUB_4X8(sub_mb_type)",
          "new_text": null,
          "old_line_content": "                        }else if(IS_SUB_4X8(sub_mb_type)){",
          "new_line_content": "                        }",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 46,
      "total_additions": 159,
      "total_deletions": 161,
      "total_api_changes": 366
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 13,
        "api_related_lines": 366,
        "non_api_lines": 9,
        "non_api_line_numbers": [
          709,
          710,
          711,
          712,
          714,
          715,
          718,
          720,
          721
        ]
      }
    },
    "api_calls_before": 232,
    "api_calls_after": 230,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 12,
      "total_diff_lines": 33
    }
  }
}