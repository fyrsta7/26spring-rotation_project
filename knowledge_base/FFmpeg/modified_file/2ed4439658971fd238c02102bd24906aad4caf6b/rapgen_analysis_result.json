{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/2ed4439658971fd238c02102bd24906aad4caf6b",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/2ed4439658971fd238c02102bd24906aad4caf6b/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/2ed4439658971fd238c02102bd24906aad4caf6b/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/2ed4439658971fd238c02102bd24906aad4caf6b/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 649,
          "old_api": "ff_imdct_half",
          "new_api": "memcpy",
          "old_text": "ff_imdct_half(&s->imdct_512, s->tmp_output, s->transform_coeffs[ch])",
          "new_text": "memcpy(s->delay[ch-1], s->tmp_output+128, 128*sizeof(float))",
          "old_line_content": "            ff_imdct_half(&s->imdct_512, s->tmp_output, s->transform_coeffs[ch]);",
          "new_line_content": "            memcpy(s->delay[ch-1], s->tmp_output+128, 128*sizeof(float));",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": "memset",
          "new_api": "memcpy",
          "old_text": "memset(s->delay[3], 0, channel_data_size)",
          "new_text": "memcpy(s->delay[2], s->delay[1], channel_data_size)",
          "old_line_content": "            memset(s->delay[3], 0, channel_data_size);",
          "new_line_content": "            memcpy(s->delay[2], s->delay[1], channel_data_size);",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": "get_bits1",
          "new_api": "av_log_missing_feature",
          "old_text": "get_bits1(gbc)",
          "new_text": "av_log_missing_feature(s->avctx, \"Spectral extension\", 1)",
          "old_line_content": "    if (s->eac3 && (!blk || get_bits1(gbc))) {",
          "new_line_content": "            av_log_missing_feature(s->avctx, \"Spectral extension\", 1);",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": "memset",
          "new_api": "get_bits1",
          "old_text": "memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS)",
          "new_text": "get_bits1(gbc)",
          "old_line_content": "        memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);",
          "new_line_content": "            s->cpl_in_use[blk] = get_bits1(gbc);",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": "get_bits1",
          "new_api": "av_log_missing_feature",
          "old_text": "get_bits1(gbc)",
          "new_text": "av_log_missing_feature(s->avctx, \"Enhanced coupling\", 1)",
          "old_line_content": "            if (s->eac3 && get_bits1(gbc)) {",
          "new_line_content": "                av_log_missing_feature(s->avctx, \"Enhanced coupling\", 1);",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": "get_bits",
          "new_api": "av_log",
          "old_text": "get_bits(gbc, 4)",
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"invalid coupling range (%d >= %d)\\n\",\n                       cpl_start_subband, cpl_end_subband)",
          "old_line_content": "            cpl_end_subband   = get_bits(gbc, 4) + 3;",
          "new_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"invalid coupling range (%d >= %d)\\n\",",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "get_bits1",
          "new_api": "av_log",
          "old_text": "get_bits1(gbc)",
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"new rematrixing strategy must be present in block 0\\n\")",
          "old_line_content": "                s->rematrixing_flags[bnd] = get_bits1(gbc);",
          "new_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new rematrixing strategy must be present in block 0\\n\");",
          "content_same": false
        },
        {
          "line": 968,
          "old_api": "get_bits",
          "new_api": "av_log",
          "old_text": "get_bits(gbc, 6)",
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"bandwidth code = %d > 60\\n\", bandwidth_code)",
          "old_line_content": "                int bandwidth_code = get_bits(gbc, 6);",
          "new_line_content": "                    av_log(s->avctx, AV_LOG_ERROR, \"bandwidth code = %d > 60\\n\", bandwidth_code);",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": "get_bits1",
          "new_api": "get_bits",
          "old_text": "get_bits1(gbc)",
          "new_text": "get_bits(gbc, 2)",
          "old_line_content": "        if (get_bits1(gbc)) {",
          "new_line_content": "            s->bit_alloc_params.fast_decay = ff_ac3_fast_decay_tab[get_bits(gbc, 2)] >> s->bit_alloc_params.sr_shift;",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": "get_bits",
          "new_api": "FFMAX",
          "old_text": "get_bits(gbc, 3)",
          "new_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "old_line_content": "            s->bit_alloc_params.floor  = ff_ac3_floor_tab[get_bits(gbc, 3)];",
          "new_line_content": "                bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": "FFMAX",
          "new_api": "av_log",
          "old_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"new bit allocation info must be present in block 0\\n\")",
          "old_line_content": "                bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "new_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new bit allocation info must be present in block 0\\n\");",
          "content_same": false
        },
        {
          "line": 1069,
          "old_api": "get_bits1",
          "new_api": "get_bits",
          "old_text": "get_bits1(gbc)",
          "new_text": "get_bits(gbc, 3)",
          "old_line_content": "        if (s->first_cpl_leak || get_bits1(gbc)) {",
          "new_line_content": "            int sl = get_bits(gbc, 3);",
          "content_same": false
        },
        {
          "line": 1091,
          "old_api": "get_bits",
          "new_api": "av_log",
          "old_text": "get_bits(gbc, 2)",
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"delta bit allocation strategy reserved\\n\")",
          "old_line_content": "            s->dba_mode[ch] = get_bits(gbc, 2);",
          "new_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"delta bit allocation strategy reserved\\n\");",
          "content_same": false
        },
        {
          "line": 1152,
          "old_api": "get_bits",
          "new_api": "skip_bits",
          "old_text": "get_bits(gbc, 9)",
          "new_text": "skip_bits(gbc, 8)",
          "old_line_content": "        int skipl = get_bits(gbc, 9);",
          "new_line_content": "            skip_bits(gbc, 8);",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": "ff_mdct_end",
          "new_api": "av_freep",
          "old_text": "ff_mdct_end(&s->imdct_256)",
          "new_text": "av_freep(&s->input_buffer)",
          "old_line_content": "    ff_mdct_end(&s->imdct_256);",
          "new_line_content": "    av_freep(&s->input_buffer);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1024,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 4)",
          "old_line_content": "                /* snr offset */",
          "new_line_content": "                    snr = (csnr + get_bits(gbc, 4)) << 2;",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(bit_alloc_stages[ch], 1)",
          "old_line_content": "                /* run at least last bit allocation stage if snr offset changes */",
          "new_line_content": "                    bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 1);",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 3)",
          "old_line_content": "                if (!s->eac3) {",
          "new_line_content": "                    s->fast_gain[ch] = ff_ac3_fast_gain_tab[get_bits(gbc, 3)];",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "old_line_content": "                    /* run last 2 bit allocation stages if fast gain changes */",
          "new_line_content": "                        bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"new snr offsets must be present in block 0\\n\")",
          "old_line_content": "            }",
          "new_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new snr offsets must be present in block 0\\n\");",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "",
          "new_line_content": "    if (s->fast_gain_syntax && get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1050,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 3)",
          "old_line_content": "        for (ch = !cpl_in_use; ch <= s->channels; ch++) {",
          "new_line_content": "            s->fast_gain[ch] = ff_ac3_fast_gain_tab[get_bits(gbc, 3)];",
          "content_same": false
        },
        {
          "line": 1053,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "old_line_content": "            /* run last 2 bit allocation stages if fast gain changes */",
          "new_line_content": "                bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "content_same": false
        },
        {
          "line": 1061,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "",
          "new_line_content": "    if (s->frame_type == EAC3_FRAME_TYPE_INDEPENDENT && get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": null,
          "new_api": "skip_bits",
          "old_text": null,
          "new_text": "skip_bits(gbc, 10)",
          "old_line_content": "    /* E-AC-3 to AC-3 converter SNR offset */",
          "new_line_content": "        skip_bits(gbc, 10); // skip converter snr offset",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    /* coupling leak information */",
          "new_line_content": "        if (s->first_cpl_leak || get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 3)",
          "old_line_content": "    if (cpl_in_use) {",
          "new_line_content": "            int fl = get_bits(gbc, 3);",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(bit_alloc_stages[CPL_CH], 2)",
          "old_line_content": "            if(blk && (fl != s->bit_alloc_params.cpl_fast_leak ||",
          "new_line_content": "                bit_alloc_stages[CPL_CH] = FFMAX(bit_alloc_stages[CPL_CH], 2);",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"new coupling leak info must be present in block 0\\n\")",
          "old_line_content": "            s->bit_alloc_params.cpl_slow_leak = sl;",
          "new_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new coupling leak info must be present in block 0\\n\");",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "",
          "new_line_content": "    if (s->dba_syntax && get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 2)",
          "old_line_content": "        /* delta bit allocation exists (strategy) */",
          "new_line_content": "            s->dba_mode[ch] = get_bits(gbc, 2);",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "old_line_content": "                return -1;",
          "new_line_content": "            bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 3)",
          "old_line_content": "        for (ch = !cpl_in_use; ch <= fbw_channels; ch++) {",
          "new_line_content": "                s->dba_nsegs[ch] = get_bits(gbc, 3);",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 4)",
          "old_line_content": "                for (seg = 0; seg <= s->dba_nsegs[ch]; seg++) {",
          "new_line_content": "                    s->dba_lengths[ch][seg] = get_bits(gbc, 4);",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": null,
          "new_api": "FFMAX",
          "old_text": null,
          "new_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "old_line_content": "                }",
          "new_line_content": "                bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": null,
          "new_api": "ff_ac3_bit_alloc_calc_psd",
          "old_text": null,
          "new_text": "ff_ac3_bit_alloc_calc_psd(s->dexps[ch],\n                                      s->start_freq[ch], s->end_freq[ch],\n                                      s->psd[ch], s->band_psd[ch])",
          "old_line_content": "        if(bit_alloc_stages[ch] > 2) {",
          "new_line_content": "            ff_ac3_bit_alloc_calc_psd(s->dexps[ch],",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(s->end_freq[1], s->end_freq[2])",
          "old_line_content": "",
          "new_line_content": "    end = FFMIN(s->end_freq[1], s->end_freq[2]);",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(end, ff_ac3_rematrix_band_tab[bnd+1])",
          "old_line_content": "        if(s->rematrixing_flags[bnd]) {",
          "new_line_content": "            bndend = FFMIN(end, ff_ac3_rematrix_band_tab[bnd+1]);",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": null,
          "new_api": "ff_ac3_bit_alloc_calc_mask",
          "old_text": null,
          "new_text": "ff_ac3_bit_alloc_calc_mask(&s->bit_alloc_params, s->band_psd[ch],\n                                           s->start_freq[ch], s->end_freq[ch],\n                                           s->fast_gain[ch], (ch == s->lfe_ch),\n                                           s->dba_mode[ch], s->dba_nsegs[ch],\n                                           s->dba_offsets[ch], s->dba_lengths[ch],\n                                           s->dba_values[ch], s->mask[ch])",
          "old_line_content": "            /* Compute excitation function, Compute masking curve, and",
          "new_line_content": "            if (ff_ac3_bit_alloc_calc_mask(&s->bit_alloc_params, s->band_psd[ch],",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"error in bit allocation\\n\")",
          "old_line_content": "                                           s->dba_offsets[ch], s->dba_lengths[ch],",
          "new_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"error in bit allocation\\n\");",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": null,
          "new_api": "ff_ac3_bit_alloc_calc_bap",
          "old_text": null,
          "new_text": "ff_ac3_bit_alloc_calc_bap(s->mask[ch], s->psd[ch],\n                                      s->start_freq[ch], s->end_freq[ch],\n                                      s->snr_offset[ch],\n                                      s->bit_alloc_params.floor,\n                                      bap_tab, s->bap[ch])",
          "old_line_content": "            const uint8_t *bap_tab = s->channel_uses_aht[ch] ?",
          "new_line_content": "            ff_ac3_bit_alloc_calc_bap(s->mask[ch], s->psd[ch],",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "",
          "new_line_content": "    if (s->skip_syntax && get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 9)",
          "old_line_content": "    /* unused dummy data */",
          "new_line_content": "        int skipl = get_bits(gbc, 9);",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": null,
          "new_api": "ff_imdct_half",
          "old_text": null,
          "new_text": "ff_imdct_half(&s->imdct_256, s->tmp_output, x)",
          "old_line_content": "            for(i=0; i<128; i++)",
          "new_line_content": "            ff_imdct_half(&s->imdct_256, s->tmp_output, x);",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": null,
          "new_api": "vector_fmul_window",
          "old_text": null,
          "new_text": "s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128)",
          "old_line_content": "                x[i] = s->transform_coeffs[ch][2*i];",
          "new_line_content": "            s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128);",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": null,
          "new_api": "ff_imdct_half",
          "old_text": null,
          "new_text": "ff_imdct_half(&s->imdct_256, s->delay[ch-1], x)",
          "old_line_content": "            for(i=0; i<128; i++)",
          "new_line_content": "            ff_imdct_half(&s->imdct_256, s->delay[ch-1], x);",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": null,
          "new_api": "decode_transform_coeffs",
          "old_text": null,
          "new_text": "decode_transform_coeffs(s, blk)",
          "old_line_content": "    /* unpack the transform coefficients",
          "new_line_content": "    decode_transform_coeffs(s, blk);",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": null,
          "new_api": "vector_fmul_window",
          "old_text": null,
          "new_text": "s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128)",
          "old_line_content": "        } else {",
          "new_line_content": "            s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128);",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": null,
          "new_api": "do_rematrixing",
          "old_text": null,
          "new_text": "do_rematrixing(s)",
          "old_line_content": "    /* recover coefficients if rematrixing is in use */",
          "new_line_content": "        do_rematrixing(s);",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": null,
          "new_api": "int32_to_float_fmul_scalar",
          "old_text": null,
          "new_text": "s->dsp.int32_to_float_fmul_scalar(s->transform_coeffs[ch], s->fixed_coeffs[ch], gain, 256)",
          "old_line_content": "            gain *= s->dynamic_range[0];",
          "new_line_content": "        s->dsp.int32_to_float_fmul_scalar(s->transform_coeffs[ch], s->fixed_coeffs[ch], gain, 256);",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": null,
          "new_api": "ac3_upmix_delay",
          "old_text": null,
          "new_text": "ac3_upmix_delay(s)",
          "old_line_content": "        if(s->downmixed) {",
          "new_line_content": "            ac3_upmix_delay(s);",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": null,
          "new_api": "do_imdct",
          "old_text": null,
          "new_text": "do_imdct(s, s->channels)",
          "old_line_content": "        }",
          "new_line_content": "        do_imdct(s, s->channels);",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": null,
          "new_api": "ac3_downmix",
          "old_text": null,
          "new_text": "s->dsp.ac3_downmix(s->output, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256)",
          "old_line_content": "",
          "new_line_content": "            s->dsp.ac3_downmix(s->output, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256);",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": null,
          "new_api": "ac3_downmix",
          "old_text": null,
          "new_text": "s->dsp.ac3_downmix(s->transform_coeffs+1, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256)",
          "old_line_content": "    } else {",
          "new_line_content": "            s->dsp.ac3_downmix(s->transform_coeffs+1, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256);",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(s->delay[1], s->delay[0], channel_data_size)",
          "old_line_content": "        case AC3_CHMODE_STEREO:",
          "new_line_content": "            memcpy(s->delay[1], s->delay[0], channel_data_size);",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": null,
          "new_api": "ac3_downmix",
          "old_text": null,
          "new_text": "s->dsp.ac3_downmix(s->delay, s->downmix_coeffs, s->out_channels, s->fbw_channels, 128)",
          "old_line_content": "        if(downmix_output && !s->downmixed) {",
          "new_line_content": "            s->dsp.ac3_downmix(s->delay, s->downmix_coeffs, s->out_channels, s->fbw_channels, 128);",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(s->delay[3], 0, channel_data_size)",
          "old_line_content": "            break;",
          "new_line_content": "            memset(s->delay[3], 0, channel_data_size);",
          "content_same": false
        },
        {
          "line": 1207,
          "old_api": null,
          "new_api": "do_imdct",
          "old_text": null,
          "new_text": "do_imdct(s, s->out_channels)",
          "old_line_content": "        }",
          "new_line_content": "        do_imdct(s, s->out_channels);",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(s->delay[4], 0, channel_data_size)",
          "old_line_content": "            break;",
          "new_line_content": "            memset(s->delay[4], 0, channel_data_size);",
          "content_same": false
        },
        {
          "line": 704,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(s->delay[1], 0, channel_data_size)",
          "old_line_content": "        case AC3_CHMODE_3F:",
          "new_line_content": "            memset(s->delay[1], 0, channel_data_size);",
          "content_same": false
        },
        {
          "line": 1231,
          "old_api": null,
          "new_api": "FFMIN",
          "old_text": null,
          "new_text": "FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE)",
          "old_line_content": "        /* copy input buffer to decoder context to avoid reading past the end",
          "new_line_content": "        memcpy(s->input_buffer, buf, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE));",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": null,
          "new_api": "init_get_bits",
          "old_text": null,
          "new_text": "init_get_bits(&s->gbc, s->input_buffer, buf_size * 8)",
          "old_line_content": "           of the buffer, which can be caused by a damaged input stream. */",
          "new_line_content": "        init_get_bits(&s->gbc, s->input_buffer, buf_size * 8);",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": null,
          "new_api": "parse_frame_header",
          "old_text": null,
          "new_text": "parse_frame_header(s)",
          "old_line_content": "    /* parse the syncinfo */",
          "new_line_content": "    err = parse_frame_header(s);",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"incomplete frame\\n\")",
          "old_line_content": "    /* check that reported frame size fits in input buffer */",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"incomplete frame\\n\");",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": null,
          "new_api": "av_crc_get_table",
          "old_text": null,
          "new_text": "av_crc_get_table(AV_CRC_16_ANSI)",
          "old_line_content": "    /* check for crc mismatch */",
          "new_line_content": "        if(av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, &buf[2], s->frame_size-2)) {",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "",
          "new_line_content": "    if (!eac3 || get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"frame CRC mismatch\\n\")",
          "old_line_content": "    if(err != AAC_AC3_PARSE_ERROR_FRAME_SIZE && avctx->error_recognition >= FF_ER_CAREFUL) {",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"frame CRC mismatch\\n\");",
          "content_same": false
        },
        {
          "line": 1258,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"frame sync error\\n\")",
          "old_line_content": "        switch(err) {",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"frame sync error\\n\");",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid bitstream id\\n\")",
          "old_line_content": "                return -1;",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid bitstream id\\n\");",
          "content_same": false
        },
        {
          "line": 1264,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid sample rate\\n\")",
          "old_line_content": "                break;",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid sample rate\\n\");",
          "content_same": false
        },
        {
          "line": 1267,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid frame size\\n\")",
          "old_line_content": "                break;",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid frame size\\n\");",
          "content_same": false
        },
        {
          "line": 1273,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"unsupported frame type : skipping frame\\n\")",
          "old_line_content": "                /* TODO: add support for substreams and dependent frames */",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"unsupported frame type : skipping frame\\n\");",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid frame type\\n\")",
          "old_line_content": "                    return s->frame_size;",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid frame type\\n\");",
          "content_same": false
        },
        {
          "line": 1280,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid header\\n\")",
          "old_line_content": "                break;",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid header\\n\");",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(band_sizes, bnd_sz, n_bands)",
          "old_line_content": "        *num_bands = n_bands;",
          "new_line_content": "        memcpy(band_sizes, bnd_sz, n_bands);",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(bit_alloc_stages, 0, AC3_MAX_CHANNELS)",
          "old_line_content": "    uint8_t bit_alloc_stages[AC3_MAX_CHANNELS];",
          "new_line_content": "    memset(bit_alloc_stages, 0, AC3_MAX_CHANNELS);",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    if (s->block_switch_syntax) {",
          "new_line_content": "            s->block_switch[ch] = get_bits1(gbc);",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": null,
          "new_api": "set_downmix_coeffs",
          "old_text": null,
          "new_text": "set_downmix_coeffs(s)",
          "old_line_content": "        if(s->channels != s->out_channels && !((s->output_mode & AC3_OUTPUT_LFEON) &&",
          "new_line_content": "            set_downmix_coeffs(s);",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    if (s->dither_flag_syntax) {",
          "new_line_content": "            s->dither_flag[ch] = get_bits1(gbc);",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": null,
          "new_api": "decode_audio_block",
          "old_text": null,
          "new_text": "decode_audio_block(s, blk)",
          "old_line_content": "        output[ch] = s->output[channel_map[ch]];",
          "new_line_content": "        if (!err && decode_audio_block(s, blk)) {",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"error decoding the audio block\\n\")",
          "old_line_content": "    for (blk = 0; blk < s->num_blocks; blk++) {",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"error decoding the audio block\\n\");",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    i = !(s->channel_mode);",
          "new_line_content": "        if(get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 8)",
          "old_line_content": "    do {",
          "new_line_content": "            s->dynamic_range[i] = ((dynamic_range_tab[get_bits(gbc, 8)]-1.0) *",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": null,
          "new_api": "float_to_int16_interleave",
          "old_text": null,
          "new_text": "s->dsp.float_to_int16_interleave(out_samples, output, 256, s->out_channels)",
          "old_line_content": "            err = 1;",
          "new_line_content": "        s->dsp.float_to_int16_interleave(out_samples, output, 256, s->out_channels);",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "",
          "new_line_content": "    if (s->eac3 && (!blk || get_bits1(gbc))) {",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    /* spectral extension strategy */",
          "new_line_content": "        if (get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1337,
          "old_api": null,
          "new_api": "ff_mdct_end",
          "old_text": null,
          "new_text": "ff_mdct_end(&s->imdct_512)",
          "old_line_content": "{",
          "new_line_content": "    ff_mdct_end(&s->imdct_512);",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": null,
          "new_api": "ff_mdct_end",
          "old_text": null,
          "new_text": "ff_mdct_end(&s->imdct_256)",
          "old_line_content": "    AC3DecodeContext *s = avctx->priv_data;",
          "new_line_content": "    ff_mdct_end(&s->imdct_256);",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "",
          "new_line_content": "    if (s->eac3 ? s->cpl_strategy_exists[blk] : get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS)",
          "old_line_content": "    /* coupling strategy */",
          "new_line_content": "        memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"coupling not allowed in mono or dual-mono\\n\")",
          "old_line_content": "",
          "new_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"coupling not allowed in mono or dual-mono\\n\");",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"ATSC A/52A (AC-3)\")",
          "old_line_content": "    .close = ac3_decode_end,",
          "new_line_content": "    .long_name = NULL_IF_CONFIG_SMALL(\"ATSC A/52A (AC-3)\"),",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "",
          "new_line_content": "            if (s->eac3 && get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1365,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"ATSC A/52B (AC-3, E-AC-3)\")",
          "old_line_content": "    .close = ac3_decode_end,",
          "new_line_content": "    .long_name = NULL_IF_CONFIG_SMALL(\"ATSC A/52B (AC-3, E-AC-3)\"),",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "            } else {",
          "new_line_content": "                    s->channel_in_cpl[ch] = get_bits1(gbc);",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "            /* phase flags in use */",
          "new_line_content": "                s->phase_flags_in_use = get_bits1(gbc);",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 4)",
          "old_line_content": "            /* coupling frequency range */",
          "new_line_content": "            cpl_start_subband = get_bits(gbc, 4);",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 4)",
          "old_line_content": "            /* TODO: modify coupling end freq if spectral extension is used */",
          "new_line_content": "            cpl_end_subband   = get_bits(gbc, 4) + 3;",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": null,
          "new_api": "decode_band_structure",
          "old_text": null,
          "new_text": "decode_band_structure(gbc, blk, s->eac3, 0, cpl_start_subband,\n                                  cpl_end_subband,\n                                  ff_eac3_default_cpl_band_struct,\n                                  &s->num_cpl_bands, s->cpl_band_sizes)",
          "old_line_content": "            s->end_freq[CPL_CH]   = cpl_end_subband   * 12 + 37;",
          "new_line_content": "            decode_band_structure(gbc, blk, s->eac3, 0, cpl_start_subband,",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"new coupling strategy must be present in block 0\\n\")",
          "old_line_content": "    } else if (!s->eac3) {",
          "new_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new coupling strategy must be present in block 0\\n\");",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "        for (ch = 1; ch <= fbw_channels; ch++) {",
          "new_line_content": "                if ((s->eac3 && s->first_cpl_coords[ch]) || get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 2)",
          "old_line_content": "                    s->first_cpl_coords[ch] = 0;",
          "new_line_content": "                    master_cpl_coord = 3 * get_bits(gbc, 2);",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 4)",
          "old_line_content": "                    for (bnd = 0; bnd < s->num_cpl_bands; bnd++) {",
          "new_line_content": "                        cpl_coord_mant = get_bits(gbc, 4);",
          "content_same": false
        },
        {
          "line": 919,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"new coupling coordinates must be present in block 0\\n\")",
          "old_line_content": "                    }",
          "new_line_content": "                    av_log(s->avctx, AV_LOG_ERROR, \"new coupling coordinates must be present in block 0\\n\");",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "        if (channel_mode == AC3_CHMODE_STEREO && cpl_coords_exist) {",
          "new_line_content": "                s->phase_flags[bnd] = s->phase_flags_in_use? get_bits1(gbc) : 0;",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    /* stereo rematrixing strategy and band structure */",
          "new_line_content": "        if ((s->eac3 && !blk) || get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "                s->num_rematrixing_bands -= 1 + (s->start_freq[CPL_CH] == 37);",
          "new_line_content": "                s->rematrixing_flags[bnd] = get_bits1(gbc);",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 2 - (ch == s->lfe_ch))",
          "old_line_content": "    for (ch = !cpl_in_use; ch <= s->channels; ch++) {",
          "new_line_content": "            s->exp_strategy[blk][ch] = get_bits(gbc, 2 - (ch == s->lfe_ch));",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 6)",
          "old_line_content": "                s->end_freq[ch] = s->start_freq[CPL_CH];",
          "new_line_content": "                int bandwidth_code = get_bits(gbc, 6);",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS)",
          "old_line_content": "            s->num_exp_groups[ch] = (s->end_freq[ch]+group_size-4) / group_size;",
          "new_line_content": "                memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 4)",
          "old_line_content": "    for (ch = !cpl_in_use; ch <= s->channels; ch++) {",
          "new_line_content": "            s->dexps[ch][0] = get_bits(gbc, 4) << !ch;",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": null,
          "new_api": "decode_exponents",
          "old_text": null,
          "new_text": "decode_exponents(gbc, s->exp_strategy[blk][ch],\n                                 s->num_exp_groups[ch], s->dexps[ch][0],\n                                 &s->dexps[ch][s->start_freq[ch]+!!ch])",
          "old_line_content": "        if (s->exp_strategy[blk][ch] != EXP_REUSE) {",
          "new_line_content": "            if (decode_exponents(gbc, s->exp_strategy[blk][ch],",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(s->avctx, AV_LOG_ERROR, \"exponent out-of-range\\n\")",
          "old_line_content": "                                 s->num_exp_groups[ch], s->dexps[ch][0],",
          "new_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"exponent out-of-range\\n\");",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": null,
          "new_api": "skip_bits",
          "old_text": null,
          "new_text": "skip_bits(gbc, 2)",
          "old_line_content": "            }",
          "new_line_content": "                skip_bits(gbc, 2); /* skip gainrng */",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    /* bit allocation information */",
          "new_line_content": "        if (get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 2)",
          "old_line_content": "    if (s->bit_allocation_syntax) {",
          "new_line_content": "            s->bit_alloc_params.slow_decay = ff_ac3_slow_decay_tab[get_bits(gbc, 2)] >> s->bit_alloc_params.sr_shift;",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gbc)",
          "old_line_content": "    /* signal-to-noise ratio offsets and fast gains (signal-to-mask ratios) */",
          "new_line_content": "        if(s->snr_offset_strategy && get_bits1(gbc)) {",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gbc, 6)",
          "old_line_content": "            int snr = 0;",
          "new_line_content": "            csnr = (get_bits(gbc, 6) - 15) << 4;",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1026,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 4)",
          "new_text": null,
          "old_line_content": "                    snr = (csnr + get_bits(gbc, 4)) << 2;",
          "new_line_content": "                if(blk && s->snr_offset[ch] != snr) {",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(bit_alloc_stages[ch], 1)",
          "new_text": null,
          "old_line_content": "                    bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 1);",
          "new_line_content": "                s->snr_offset[ch] = snr;",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 3)",
          "new_text": null,
          "old_line_content": "                    s->fast_gain[ch] = ff_ac3_fast_gain_tab[get_bits(gbc, 3)];",
          "new_line_content": "                    if(blk && prev != s->fast_gain[ch])",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "new_text": null,
          "old_line_content": "                        bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"new snr offsets must be present in block 0\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new snr offsets must be present in block 0\\n\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "    if (s->fast_gain_syntax && get_bits1(gbc)) {",
          "new_line_content": "            int prev = s->fast_gain[ch];",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 3)",
          "new_text": null,
          "old_line_content": "            s->fast_gain[ch] = ff_ac3_fast_gain_tab[get_bits(gbc, 3)];",
          "new_line_content": "            if(blk && prev != s->fast_gain[ch])",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "new_text": null,
          "old_line_content": "                bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "new_line_content": "    } else if (s->eac3 && !blk) {",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "    if (s->frame_type == EAC3_FRAME_TYPE_INDEPENDENT && get_bits1(gbc)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": "skip_bits",
          "new_api": null,
          "old_text": "skip_bits(gbc, 10)",
          "new_text": null,
          "old_line_content": "        skip_bits(gbc, 10); // skip converter snr offset",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 3)",
          "new_text": null,
          "old_line_content": "            int fl = get_bits(gbc, 3);",
          "new_line_content": "            /* run last 2 bit allocation stages for coupling channel if",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 3)",
          "new_text": null,
          "old_line_content": "            int sl = get_bits(gbc, 3);",
          "new_line_content": "               coupling leak changes */",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(bit_alloc_stages[CPL_CH], 2)",
          "new_text": null,
          "old_line_content": "                bit_alloc_stages[CPL_CH] = FFMAX(bit_alloc_stages[CPL_CH], 2);",
          "new_line_content": "            s->bit_alloc_params.cpl_fast_leak = fl;",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"new coupling leak info must be present in block 0\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new coupling leak info must be present in block 0\\n\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "    if (s->dba_syntax && get_bits1(gbc)) {",
          "new_line_content": "        for (ch = !cpl_in_use; ch <= fbw_channels; ch++) {",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"delta bit allocation strategy reserved\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"delta bit allocation strategy reserved\\n\");",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "new_text": null,
          "old_line_content": "            bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "new_line_content": "        /* channel delta offset, len and bit allocation */",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 4)",
          "new_text": null,
          "old_line_content": "                    s->dba_lengths[ch][seg] = get_bits(gbc, 4);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 3)",
          "new_text": null,
          "old_line_content": "                    s->dba_values[ch][seg] = get_bits(gbc, 3);",
          "new_line_content": "                /* run last 2 bit allocation stages if new dba values */",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": "FFMAX",
          "new_api": null,
          "old_text": "FFMAX(bit_alloc_stages[ch], 2)",
          "new_text": null,
          "old_line_content": "                bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(s->end_freq[1], s->end_freq[2])",
          "new_text": null,
          "old_line_content": "    end = FFMIN(s->end_freq[1], s->end_freq[2]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": "ff_ac3_bit_alloc_calc_psd",
          "new_api": null,
          "old_text": "ff_ac3_bit_alloc_calc_psd(s->dexps[ch],\n                                      s->start_freq[ch], s->end_freq[ch],\n                                      s->psd[ch], s->band_psd[ch])",
          "new_text": null,
          "old_line_content": "            ff_ac3_bit_alloc_calc_psd(s->dexps[ch],",
          "new_line_content": "                                      s->psd[ch], s->band_psd[ch]);",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(end, ff_ac3_rematrix_band_tab[bnd+1])",
          "new_text": null,
          "old_line_content": "            bndend = FFMIN(end, ff_ac3_rematrix_band_tab[bnd+1]);",
          "new_line_content": "            for(; i<bndend; i++) {",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": "ff_ac3_bit_alloc_calc_mask",
          "new_api": null,
          "old_text": "ff_ac3_bit_alloc_calc_mask(&s->bit_alloc_params, s->band_psd[ch],\n                                           s->start_freq[ch], s->end_freq[ch],\n                                           s->fast_gain[ch], (ch == s->lfe_ch),\n                                           s->dba_mode[ch], s->dba_nsegs[ch],\n                                           s->dba_offsets[ch], s->dba_lengths[ch],\n                                           s->dba_values[ch], s->mask[ch])",
          "new_text": null,
          "old_line_content": "            if (ff_ac3_bit_alloc_calc_mask(&s->bit_alloc_params, s->band_psd[ch],",
          "new_line_content": "                                           s->fast_gain[ch], (ch == s->lfe_ch),",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"error in bit allocation\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"error in bit allocation\\n\");",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": "ff_ac3_bit_alloc_calc_bap",
          "new_api": null,
          "old_text": "ff_ac3_bit_alloc_calc_bap(s->mask[ch], s->psd[ch],\n                                      s->start_freq[ch], s->end_freq[ch],\n                                      s->snr_offset[ch],\n                                      s->bit_alloc_params.floor,\n                                      bap_tab, s->bap[ch])",
          "new_text": null,
          "old_line_content": "            ff_ac3_bit_alloc_calc_bap(s->mask[ch], s->psd[ch],",
          "new_line_content": "                                      s->snr_offset[ch],",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "    if (s->skip_syntax && get_bits1(gbc)) {",
          "new_line_content": "        while(skipl--)",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": "skip_bits",
          "new_api": null,
          "old_text": "skip_bits(gbc, 8)",
          "new_text": null,
          "old_line_content": "            skip_bits(gbc, 8);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "ff_imdct_half",
          "new_api": null,
          "old_text": "ff_imdct_half(&s->imdct_256, s->tmp_output, x)",
          "new_text": null,
          "old_line_content": "            ff_imdct_half(&s->imdct_256, s->tmp_output, x);",
          "new_line_content": "            for(i=0; i<128; i++)",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": "vector_fmul_window",
          "new_api": null,
          "old_text": "s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128)",
          "new_text": null,
          "old_line_content": "            s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128);",
          "new_line_content": "                x[i] = s->transform_coeffs[ch][2*i+1];",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "decode_transform_coeffs",
          "new_api": null,
          "old_text": "decode_transform_coeffs(s, blk)",
          "new_text": null,
          "old_line_content": "    decode_transform_coeffs(s, blk);",
          "new_line_content": "    /* TODO: generate enhanced coupling coordinates and uncouple */",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "vector_fmul_window",
          "new_api": null,
          "old_text": "s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128)",
          "new_text": null,
          "old_line_content": "            s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, add_bias, 128);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(s->delay[ch-1], s->tmp_output+128, 128*sizeof(float))",
          "new_text": null,
          "old_line_content": "            memcpy(s->delay[ch-1], s->tmp_output+128, 128*sizeof(float));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": "do_rematrixing",
          "new_api": null,
          "old_text": "do_rematrixing(s)",
          "new_text": null,
          "old_line_content": "        do_rematrixing(s);",
          "new_line_content": "    /* apply scaling to coefficients (headroom, dynrng) */",
          "content_same": false
        },
        {
          "line": 1177,
          "old_api": "int32_to_float_fmul_scalar",
          "new_api": null,
          "old_text": "s->dsp.int32_to_float_fmul_scalar(s->transform_coeffs[ch], s->fixed_coeffs[ch], gain, 256)",
          "new_text": null,
          "old_line_content": "        s->dsp.int32_to_float_fmul_scalar(s->transform_coeffs[ch], s->fixed_coeffs[ch], gain, 256);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "ac3_upmix_delay",
          "new_api": null,
          "old_text": "ac3_upmix_delay(s)",
          "new_text": null,
          "old_line_content": "            ac3_upmix_delay(s);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": "do_imdct",
          "new_api": null,
          "old_text": "do_imdct(s, s->channels)",
          "new_text": null,
          "old_line_content": "        do_imdct(s, s->channels);",
          "new_line_content": "        if(downmix_output) {",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": "ac3_downmix",
          "new_api": null,
          "old_text": "s->dsp.ac3_downmix(s->output, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256)",
          "new_text": null,
          "old_line_content": "            s->dsp.ac3_downmix(s->output, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": "ac3_downmix",
          "new_api": null,
          "old_text": "s->dsp.ac3_downmix(s->transform_coeffs+1, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256)",
          "new_text": null,
          "old_line_content": "            s->dsp.ac3_downmix(s->transform_coeffs+1, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(s->delay[1], s->delay[0], channel_data_size)",
          "new_text": null,
          "old_line_content": "            memcpy(s->delay[1], s->delay[0], channel_data_size);",
          "new_line_content": "        case AC3_CHMODE_2F2R:",
          "content_same": false
        },
        {
          "line": 1206,
          "old_api": "ac3_downmix",
          "new_api": null,
          "old_text": "s->dsp.ac3_downmix(s->delay, s->downmix_coeffs, s->out_channels, s->fbw_channels, 128)",
          "new_text": null,
          "old_line_content": "            s->dsp.ac3_downmix(s->delay, s->downmix_coeffs, s->out_channels, s->fbw_channels, 128);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": "do_imdct",
          "new_api": null,
          "old_text": "do_imdct(s, s->out_channels)",
          "new_text": null,
          "old_line_content": "        do_imdct(s, s->out_channels);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(s->delay[2], 0, channel_data_size)",
          "new_text": null,
          "old_line_content": "            memset(s->delay[2], 0, channel_data_size);",
          "new_line_content": "        case AC3_CHMODE_3F2R:",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(s->delay[2], s->delay[1], channel_data_size)",
          "new_text": null,
          "old_line_content": "            memcpy(s->delay[2], s->delay[1], channel_data_size);",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(s->delay[1], 0, channel_data_size)",
          "new_text": null,
          "old_line_content": "            memset(s->delay[1], 0, channel_data_size);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": "FFMIN",
          "new_api": null,
          "old_text": "FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE)",
          "new_text": null,
          "old_line_content": "        memcpy(s->input_buffer, buf, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE));",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1236,
          "old_api": "init_get_bits",
          "new_api": null,
          "old_text": "init_get_bits(&s->gbc, buf, buf_size * 8)",
          "new_text": null,
          "old_line_content": "        init_get_bits(&s->gbc, buf, buf_size * 8);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": "parse_frame_header",
          "new_api": null,
          "old_text": "parse_frame_header(s)",
          "new_text": null,
          "old_line_content": "    err = parse_frame_header(s);",
          "new_line_content": "    /* check that reported frame size fits in input buffer */",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"incomplete frame\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"incomplete frame\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": "av_crc_get_table",
          "new_api": null,
          "old_text": "av_crc_get_table(AV_CRC_16_ANSI)",
          "new_text": null,
          "old_line_content": "        if(av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, &buf[2], s->frame_size-2)) {",
          "new_line_content": "            err = AAC_AC3_PARSE_ERROR_CRC;",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"frame CRC mismatch\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"frame CRC mismatch\\n\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "            coded_band_struct[subbnd] = get_bits1(gbc);",
          "new_line_content": "        band_struct = coded_band_struct;",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"frame sync error\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"frame sync error\\n\");",
          "new_line_content": "            case AAC_AC3_PARSE_ERROR_BSID:",
          "content_same": false
        },
        {
          "line": 1263,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid bitstream id\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid bitstream id\\n\");",
          "new_line_content": "            case AAC_AC3_PARSE_ERROR_SAMPLE_RATE:",
          "content_same": false
        },
        {
          "line": 1266,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid sample rate\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid sample rate\\n\");",
          "new_line_content": "            case AAC_AC3_PARSE_ERROR_FRAME_SIZE:",
          "content_same": false
        },
        {
          "line": 1269,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid frame size\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid frame size\\n\");",
          "new_line_content": "            case AAC_AC3_PARSE_ERROR_FRAME_TYPE:",
          "content_same": false
        },
        {
          "line": 1275,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"unsupported frame type : skipping frame\\n\")",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"unsupported frame type : skipping frame\\n\");",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid frame type\\n\")",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid frame type\\n\");",
          "new_line_content": "                break;",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid header\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"invalid header\\n\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(band_sizes, bnd_sz, n_bands)",
          "new_text": null,
          "old_line_content": "        memcpy(band_sizes, bnd_sz, n_bands);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(bit_alloc_stages, 0, AC3_MAX_CHANNELS)",
          "new_text": null,
          "old_line_content": "    memset(bit_alloc_stages, 0, AC3_MAX_CHANNELS);",
          "new_line_content": "    /* block switch flags */",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "            s->block_switch[ch] = get_bits1(gbc);",
          "new_line_content": "                different_transforms = 1;",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": "set_downmix_coeffs",
          "new_api": null,
          "old_text": "set_downmix_coeffs(s)",
          "new_text": null,
          "old_line_content": "            set_downmix_coeffs(s);",
          "new_line_content": "    } else if (!s->out_channels) {",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "            s->dither_flag[ch] = get_bits1(gbc);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1322,
          "old_api": "decode_audio_block",
          "new_api": null,
          "old_text": "decode_audio_block(s, blk)",
          "new_text": null,
          "old_line_content": "        if (!err && decode_audio_block(s, blk)) {",
          "new_line_content": "            err = 1;",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"error decoding the audio block\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"error decoding the audio block\\n\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "        if(get_bits1(gbc)) {",
          "new_line_content": "                                  s->avctx->drc_scale)+1.0;",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 8)",
          "new_text": null,
          "old_line_content": "            s->dynamic_range[i] = ((dynamic_range_tab[get_bits(gbc, 8)]-1.0) *",
          "new_line_content": "        } else if(blk == 0) {",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": "float_to_int16_interleave",
          "new_api": null,
          "old_text": "s->dsp.float_to_int16_interleave(out_samples, output, 256, s->out_channels)",
          "new_text": null,
          "old_line_content": "        s->dsp.float_to_int16_interleave(out_samples, output, 256, s->out_channels);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "        if (get_bits1(gbc)) {",
          "new_line_content": "            return -1;",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": "av_log_missing_feature",
          "new_api": null,
          "old_text": "av_log_missing_feature(s->avctx, \"Spectral extension\", 1)",
          "new_text": null,
          "old_line_content": "            av_log_missing_feature(s->avctx, \"Spectral extension\", 1);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": "ff_mdct_end",
          "new_api": null,
          "old_text": "ff_mdct_end(&s->imdct_512)",
          "new_text": null,
          "old_line_content": "    ff_mdct_end(&s->imdct_512);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1342,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&s->input_buffer)",
          "new_text": null,
          "old_line_content": "    av_freep(&s->input_buffer);",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "    if (s->eac3 ? s->cpl_strategy_exists[blk] : get_bits1(gbc)) {",
          "new_line_content": "        if (!s->eac3)",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "            s->cpl_in_use[blk] = get_bits1(gbc);",
          "new_line_content": "            /* coupling in use */",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"coupling not allowed in mono or dual-mono\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"coupling not allowed in mono or dual-mono\\n\");",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1355,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"ATSC A/52A (AC-3)\")",
          "new_text": null,
          "old_line_content": "    .long_name = NULL_IF_CONFIG_SMALL(\"ATSC A/52A (AC-3)\"),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": "av_log_missing_feature",
          "new_api": null,
          "old_text": "av_log_missing_feature(s->avctx, \"Enhanced coupling\", 1)",
          "new_text": null,
          "old_line_content": "                av_log_missing_feature(s->avctx, \"Enhanced coupling\", 1);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1367,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"ATSC A/52B (AC-3, E-AC-3)\")",
          "new_text": null,
          "old_line_content": "    .long_name = NULL_IF_CONFIG_SMALL(\"ATSC A/52B (AC-3, E-AC-3)\"),",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "                    s->channel_in_cpl[ch] = get_bits1(gbc);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "                s->phase_flags_in_use = get_bits1(gbc);",
          "new_line_content": "            /* coupling frequency range */",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 4)",
          "new_text": null,
          "old_line_content": "            cpl_start_subband = get_bits(gbc, 4);",
          "new_line_content": "            if (cpl_start_subband >= cpl_end_subband) {",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"invalid coupling range (%d >= %d)\\n\",\n                       cpl_start_subband, cpl_end_subband)",
          "new_text": null,
          "old_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"invalid coupling range (%d >= %d)\\n\",",
          "new_line_content": "                return -1;",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": "decode_band_structure",
          "new_api": null,
          "old_text": "decode_band_structure(gbc, blk, s->eac3, 0, cpl_start_subband,\n                                  cpl_end_subband,\n                                  ff_eac3_default_cpl_band_struct,\n                                  &s->num_cpl_bands, s->cpl_band_sizes)",
          "new_text": null,
          "old_line_content": "            decode_band_structure(gbc, blk, s->eac3, 0, cpl_start_subband,",
          "new_line_content": "                                  ff_eac3_default_cpl_band_struct,",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"new coupling strategy must be present in block 0\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new coupling strategy must be present in block 0\\n\");",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "                if ((s->eac3 && s->first_cpl_coords[ch]) || get_bits1(gbc)) {",
          "new_line_content": "                    s->first_cpl_coords[ch] = 0;",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 4)",
          "new_text": null,
          "old_line_content": "                        cpl_coord_exp = get_bits(gbc, 4);",
          "new_line_content": "                        if (cpl_coord_exp == 15)",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 4)",
          "new_text": null,
          "old_line_content": "                        cpl_coord_mant = get_bits(gbc, 4);",
          "new_line_content": "                            s->cpl_coords[ch][bnd] = cpl_coord_mant << 22;",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"new coupling coordinates must be present in block 0\\n\")",
          "new_text": null,
          "old_line_content": "                    av_log(s->avctx, AV_LOG_ERROR, \"new coupling coordinates must be present in block 0\\n\");",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "                s->phase_flags[bnd] = s->phase_flags_in_use? get_bits1(gbc) : 0;",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "        if ((s->eac3 && !blk) || get_bits1(gbc)) {",
          "new_line_content": "            if(cpl_in_use && s->start_freq[CPL_CH] <= 61)",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"new rematrixing strategy must be present in block 0\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new rematrixing strategy must be present in block 0\\n\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 2 - (ch == s->lfe_ch))",
          "new_text": null,
          "old_line_content": "            s->exp_strategy[blk][ch] = get_bits(gbc, 2 - (ch == s->lfe_ch));",
          "new_line_content": "            bit_alloc_stages[ch] = 3;",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"bandwidth code = %d > 60\\n\", bandwidth_code)",
          "new_text": null,
          "old_line_content": "                    av_log(s->avctx, AV_LOG_ERROR, \"bandwidth code = %d > 60\\n\", bandwidth_code);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS)",
          "new_text": null,
          "old_line_content": "                memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 4)",
          "new_text": null,
          "old_line_content": "            s->dexps[ch][0] = get_bits(gbc, 4) << !ch;",
          "new_line_content": "                                 s->num_exp_groups[ch], s->dexps[ch][0],",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": "decode_exponents",
          "new_api": null,
          "old_text": "decode_exponents(gbc, s->exp_strategy[blk][ch],\n                                 s->num_exp_groups[ch], s->dexps[ch][0],\n                                 &s->dexps[ch][s->start_freq[ch]+!!ch])",
          "new_text": null,
          "old_line_content": "            if (decode_exponents(gbc, s->exp_strategy[blk][ch],",
          "new_line_content": "                                 &s->dexps[ch][s->start_freq[ch]+!!ch])) {",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"exponent out-of-range\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(s->avctx, AV_LOG_ERROR, \"exponent out-of-range\\n\");",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": "skip_bits",
          "new_api": null,
          "old_text": "skip_bits(gbc, 2)",
          "new_text": null,
          "old_line_content": "                skip_bits(gbc, 2); /* skip gainrng */",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 2)",
          "new_text": null,
          "old_line_content": "            s->bit_alloc_params.db_per_bit = ff_ac3_db_per_bit_tab[get_bits(gbc, 2)];",
          "new_line_content": "            for(ch=!cpl_in_use; ch<=s->channels; ch++)",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(s->avctx, AV_LOG_ERROR, \"new bit allocation info must be present in block 0\\n\")",
          "new_text": null,
          "old_line_content": "            av_log(s->avctx, AV_LOG_ERROR, \"new bit allocation info must be present in block 0\\n\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gbc)",
          "new_text": null,
          "old_line_content": "        if(s->snr_offset_strategy && get_bits1(gbc)) {",
          "new_line_content": "            int csnr;",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gbc, 6)",
          "new_text": null,
          "old_line_content": "            csnr = (get_bits(gbc, 6) - 15) << 4;",
          "new_line_content": "                /* snr offset */",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 15,
      "total_additions": 103,
      "total_deletions": 103,
      "total_api_changes": 221
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 221,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          615,
          616,
          617,
          618,
          619,
          607
        ]
      }
    },
    "api_calls_before": 184,
    "api_calls_after": 184,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 5,
      "total_diff_lines": 27
    }
  }
}