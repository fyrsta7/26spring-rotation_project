{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/943a4581570728b4b1a2bf97e5601e24f3f80404",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/943a4581570728b4b1a2bf97e5601e24f3f80404/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/943a4581570728b4b1a2bf97e5601e24f3f80404/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/943a4581570728b4b1a2bf97e5601e24f3f80404/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 141,
          "old_api": "av_log",
          "new_api": "get_vlc2",
          "old_text": "av_log(NULL, AV_LOG_ERROR, \"Tree size exceeded!\\n\")",
          "new_text": "get_vlc2(gb, ctx->v1->table, SMKTREE_BITS, 3)",
          "old_line_content": "        av_log(NULL, AV_LOG_ERROR, \"Tree size exceeded!\\n\");",
          "new_line_content": "        i1 = ctx->v1->table ? get_vlc2(gb, ctx->v1->table, SMKTREE_BITS, 3) : 0;",
          "content_same": false
        },
        {
          "line": 202,
          "old_api": "av_malloc",
          "new_api": "get_bits1",
          "old_text": "av_malloc(256 * sizeof(h[i].values[0]))",
          "new_text": "get_bits1(gb)",
          "old_line_content": "        h[i].values  = av_malloc(256 * sizeof(h[i].values[0]));",
          "new_line_content": "        if (!get_bits1(gb)) {",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": "AVERROR",
          "new_api": "av_log",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "av_log(smk->avctx, AV_LOG_ERROR, \"Skipping %s bytes tree\\n\",\n                   i ? \"high\" : \"low\")",
          "old_line_content": "            err = AVERROR(ENOMEM);",
          "new_line_content": "            av_log(smk->avctx, AV_LOG_ERROR, \"Skipping %s bytes tree\\n\",",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": "smacker_decode_tree",
          "new_api": "init_vlc",
          "old_text": "smacker_decode_tree(gb, &h[i], 0, 0)",
          "new_text": "init_vlc(&vlc[i], SMKTREE_BITS, h[i].current,\n                           INIT_VLC_DEFAULT_SIZES(h[i].lengths),\n                           INIT_VLC_DEFAULT_SIZES(h[i].bits),\n                           INIT_VLC_LE)",
          "old_line_content": "        err = smacker_decode_tree(gb, &h[i], 0, 0);",
          "new_line_content": "            err = init_vlc(&vlc[i], SMKTREE_BITS, h[i].current,",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": "init_vlc",
          "new_api": "av_log",
          "old_text": "init_vlc(&vlc[i], SMKTREE_BITS, h[i].current,\n                           INIT_VLC_DEFAULT_SIZES(h[i].lengths),\n                           INIT_VLC_DEFAULT_SIZES(h[i].bits),\n                           INIT_VLC_LE)",
          "new_text": "av_log(smk->avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\")",
          "old_line_content": "            err = init_vlc(&vlc[i], SMKTREE_BITS, h[i].current,",
          "new_line_content": "                av_log(smk->avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\");",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": "AVERROR",
          "new_api": "smacker_decode_bigtree",
          "old_text": "AVERROR(ENOMEM)",
          "new_text": "smacker_decode_bigtree(gb, &huff, &ctx, 0)",
          "old_line_content": "        err = AVERROR(ENOMEM);",
          "new_line_content": "    err = smacker_decode_bigtree(gb, &huff, &ctx, 0);",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": "AV_RL32",
          "new_api": "init_get_bits8",
          "old_text": "AV_RL32(smk->avctx->extradata)",
          "new_text": "init_get_bits8(&gb, smk->avctx->extradata + 16, smk->avctx->extradata_size - 16)",
          "old_line_content": "    mmap_size = AV_RL32(smk->avctx->extradata);",
          "new_line_content": "    ret = init_get_bits8(&gb, smk->avctx->extradata + 16, smk->avctx->extradata_size - 16);",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": "get_bits1",
          "new_api": "AVERROR",
          "old_text": "get_bits1(&gb)",
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    if(!get_bits1(&gb)) {",
          "new_line_content": "            return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": "get_bits1",
          "new_api": "AVERROR",
          "old_text": "get_bits1(&gb)",
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    if(!get_bits1(&gb)) {",
          "new_line_content": "            return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": "get_bits1",
          "new_api": "AVERROR",
          "old_text": "get_bits1(&gb)",
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    if(!get_bits1(&gb)) {",
          "new_line_content": "            return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": "get_bits1",
          "new_api": "AVERROR",
          "old_text": "get_bits1(&gb)",
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "    if(!get_bits1(&gb)) {",
          "new_line_content": "            return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 388,
          "old_api": "ff_reget_buffer",
          "new_api": "bytestream2_init",
          "old_text": "ff_reget_buffer(avctx, smk->pic, 0)",
          "new_text": "bytestream2_init(&gb2, avpkt->data, avpkt->size)",
          "old_line_content": "    if ((ret = ff_reget_buffer(avctx, smk->pic, 0)) < 0)",
          "new_line_content": "    bytestream2_init(&gb2, avpkt->data, avpkt->size);",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": "bytestream2_get_be24u",
          "new_api": "last_reset",
          "old_text": "bytestream2_get_be24u(&gb2)",
          "new_text": "last_reset(smk->type_tbl, smk->type_last)",
          "old_line_content": "        *pal++ = 0xFFU << 24 | bytestream2_get_be24u(&gb2);",
          "new_line_content": "    last_reset(smk->type_tbl, smk->type_last);",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": "AV_WL16",
          "new_api": "smk_get_code",
          "old_text": "AV_WL16(out,pix)",
          "new_text": "smk_get_code(&gb, smk->full_tbl, smk->full_last)",
          "old_line_content": "                        AV_WL16(out,pix);",
          "new_line_content": "                    pix = smk_get_code(&gb, smk->full_tbl, smk->full_last);",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": "smk_get_code",
          "new_api": "AV_WL16",
          "old_text": "smk_get_code(&gb, smk->full_tbl, smk->full_last)",
          "new_text": "AV_WL16(out,pix1)",
          "old_line_content": "                        pix2 = smk_get_code(&gb, smk->full_tbl, smk->full_last);",
          "new_line_content": "                        AV_WL16(out,pix1);",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": "smk_get_code",
          "new_api": "AV_WL16",
          "old_text": "smk_get_code(&gb, smk->full_tbl, smk->full_last)",
          "new_text": "AV_WL16(out+2,pix2)",
          "old_line_content": "                        pix1 = smk_get_code(&gb, smk->full_tbl, smk->full_last);",
          "new_line_content": "                        AV_WL16(out+2,pix2);",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "av_freep",
          "new_api": "av_frame_free",
          "old_text": "av_freep(&smk->mmap_tbl)",
          "new_text": "av_frame_free(&smk->pic)",
          "old_line_content": "    av_freep(&smk->mmap_tbl);",
          "new_line_content": "    av_frame_free(&smk->pic);",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": "av_log",
          "new_api": "get_bits1",
          "old_text": "av_log(avctx, AV_LOG_INFO, \"Sound: no data\\n\")",
          "new_text": "get_bits1(&gb)",
          "old_line_content": "        av_log(avctx, AV_LOG_INFO, \"Sound: no data\\n\");",
          "new_line_content": "    bits = get_bits1(&gb);",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": "av_malloc",
          "new_api": "skip_bits1",
          "old_text": "av_malloc(256 * sizeof(h[i].values))",
          "new_text": "skip_bits1(&gb)",
          "old_line_content": "        h[i].values  = av_malloc(256 * sizeof(h[i].values));",
          "new_line_content": "        skip_bits1(&gb);",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": "skip_bits1",
          "new_api": "init_vlc",
          "old_text": "skip_bits1(&gb)",
          "new_text": "init_vlc(&vlc[i], SMKTREE_BITS, h[i].current,\n                    h[i].lengths, sizeof(int), sizeof(int),\n                    h[i].bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE)",
          "old_line_content": "        skip_bits1(&gb);",
          "new_line_content": "            ret = init_vlc(&vlc[i], SMKTREE_BITS, h[i].current,",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": "av_log",
          "new_api": "sign_extend",
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\")",
          "new_text": "sign_extend(val, 16)",
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\");",
          "new_line_content": "                pred[1] += (unsigned)sign_extend(val, 16);",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": "av_log",
          "new_api": "sign_extend",
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\")",
          "new_text": "sign_extend(val, 16)",
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\");",
          "new_line_content": "                pred[0] += (unsigned)sign_extend(val, 16);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 512,
          "old_api": null,
          "new_api": "av_frame_ref",
          "old_text": null,
          "new_text": "av_frame_ref(data, smk->pic)",
          "old_line_content": "            break;",
          "new_line_content": "    if ((ret = av_frame_ref(data, smk->pic)) < 0)",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&smk->mmap_tbl)",
          "old_line_content": "",
          "new_line_content": "    av_freep(&smk->mmap_tbl);",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&smk->mclr_tbl)",
          "old_line_content": "static av_cold int decode_end(AVCodecContext *avctx)",
          "new_line_content": "    av_freep(&smk->mclr_tbl);",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&smk->full_tbl)",
          "old_line_content": "{",
          "new_line_content": "    av_freep(&smk->full_tbl);",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": null,
          "new_api": "av_freep",
          "old_text": null,
          "new_text": "av_freep(&smk->type_tbl)",
          "old_line_content": "    SmackVContext * const smk = avctx->priv_data;",
          "new_line_content": "    av_freep(&smk->type_tbl);",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": null,
          "new_api": "av_frame_alloc",
          "old_text": null,
          "new_text": "av_frame_alloc()",
          "old_line_content": "",
          "new_line_content": "    c->pic = av_frame_alloc();",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "",
          "new_line_content": "        return AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Extradata missing!\\n\")",
          "old_line_content": "    if (!c->pic)",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Extradata missing!\\n\");",
          "content_same": false
        },
        {
          "line": 556,
          "old_api": null,
          "new_api": "decode_header_trees",
          "old_text": null,
          "new_text": "decode_header_trees(c)",
          "old_line_content": "    if(avctx->extradata_size < 16){",
          "new_line_content": "    ret = decode_header_trees(c);",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid number of channels\\n\")",
          "old_line_content": "",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"invalid number of channels\\n\");",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"packet is too small\\n\")",
          "old_line_content": "    int unp_size;",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"packet is too small\\n\");",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": null,
          "new_api": "AV_RL32",
          "old_text": null,
          "new_text": "AV_RL32(buf)",
          "old_line_content": "    if (buf_size <= 4) {",
          "new_line_content": "    unp_size = AV_RL32(buf);",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"packet is too big\\n\")",
          "old_line_content": "    }",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"packet is too big\\n\");",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": null,
          "new_api": "init_get_bits8",
          "old_text": null,
          "new_text": "init_get_bits8(&gb, buf + 4, buf_size - 4)",
          "old_line_content": "    if (unp_size > (1U<<24)) {",
          "new_line_content": "    if ((ret = init_get_bits8(&gb, buf + 4, buf_size - 4)) < 0)",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(&gb)",
          "old_line_content": "    }",
          "new_line_content": "    if(!get_bits1(&gb)){",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_INFO, \"Sound: no data\\n\")",
          "old_line_content": "",
          "new_line_content": "        av_log(avctx, AV_LOG_INFO, \"Sound: no data\\n\");",
          "content_same": false
        },
        {
          "line": 620,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"channels mismatch\\n\")",
          "old_line_content": "        return 1;",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"channels mismatch\\n\");",
          "content_same": false
        },
        {
          "line": 110,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gb, 8)",
          "old_line_content": "            hc->lengths[hc->current] = length;",
          "new_line_content": "        hc->values[hc->current] = get_bits(gb, 8);",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"sample format mismatch\\n\")",
          "old_line_content": "    if (stereo ^ (avctx->channels != 1)) {",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"sample format mismatch\\n\");",
          "content_same": false
        },
        {
          "line": 116,
          "old_api": null,
          "new_api": "smacker_decode_tree",
          "old_text": null,
          "new_text": "smacker_decode_tree(gb, hc, prefix, length)",
          "old_line_content": "        hc->current++;",
          "new_line_content": "        r = smacker_decode_tree(gb, hc, prefix, length);",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR,\n               \"The buffer does not contain an integer number of samples\\n\")",
          "old_line_content": "    }",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR,",
          "content_same": false
        },
        {
          "line": 119,
          "old_api": null,
          "new_api": "smacker_decode_tree",
          "old_text": null,
          "new_text": "smacker_decode_tree(gb, hc, prefix | (1U << (length - 1)), length)",
          "old_line_content": "        int r;",
          "new_line_content": "        return smacker_decode_tree(gb, hc, prefix | (1U << (length - 1)), length);",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": null,
          "new_api": "ff_get_buffer",
          "old_text": null,
          "new_text": "ff_get_buffer(avctx, frame, 0)",
          "old_line_content": "    if (unp_size % (avctx->channels * (bits + 1))) {",
          "new_line_content": "    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)",
          "content_same": false
        },
        {
          "line": 131,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(NULL, AV_LOG_ERROR, \"Maximum bigtree recursion level exceeded.\\n\")",
          "old_line_content": "static int smacker_decode_bigtree(GetBitContext *gb, HuffContext *hc,",
          "new_line_content": "        av_log(NULL, AV_LOG_ERROR, \"Maximum bigtree recursion level exceeded.\\n\");",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(256 * sizeof(h[i].bits))",
          "old_line_content": "",
          "new_line_content": "        h[i].bits    = av_malloc(256 * sizeof(h[i].bits));",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(256 * sizeof(h[i].lengths))",
          "old_line_content": "    // Initialize",
          "new_line_content": "        h[i].lengths = av_malloc(256 * sizeof(h[i].lengths));",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(256 * sizeof(h[i].values))",
          "old_line_content": "    for(i = 0; i < (1 << (bits + stereo)); i++) {",
          "new_line_content": "        h[i].values  = av_malloc(256 * sizeof(h[i].values));",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "        h[i].current = 0;",
          "new_line_content": "            ret = AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gb)",
          "old_line_content": "",
          "new_line_content": "    if(!get_bits1(gb)){ //Leaf",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": null,
          "new_api": "smacker_decode_tree",
          "old_text": null,
          "new_text": "smacker_decode_tree(&gb, &h[i], 0, 0)",
          "old_line_content": "        if (!h[i].bits || !h[i].lengths || !h[i].values) {",
          "new_line_content": "        if ((ret = smacker_decode_tree(&gb, &h[i], 0, 0)) < 0)",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": null,
          "new_api": "get_vlc2",
          "old_text": null,
          "new_text": "get_vlc2(gb, ctx->v2->table, SMKTREE_BITS, 3)",
          "old_line_content": "        return AVERROR_INVALIDDATA;",
          "new_line_content": "        i2 = ctx->v2->table ? get_vlc2(gb, ctx->v2->table, SMKTREE_BITS, 3) : 0;",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": null,
          "new_api": "skip_bits1",
          "old_text": null,
          "new_text": "skip_bits1(&gb)",
          "old_line_content": "            goto error;",
          "new_line_content": "        skip_bits1(&gb);",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\")",
          "old_line_content": "        if(h[i].current > 1) {",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\");",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(&gb, 16)",
          "old_line_content": "        }",
          "new_line_content": "            pred[i] = sign_extend(av_bswap16(get_bits(&gb, 16)), 16);",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": null,
          "new_api": "get_bits_left",
          "old_text": null,
          "new_text": "get_bits_left(&gb)",
          "old_line_content": "        for(i = stereo; i >= 0; i--)",
          "new_line_content": "            if (get_bits_left(&gb) < 0) {",
          "content_same": false
        },
        {
          "line": 163,
          "old_api": null,
          "new_api": "smacker_decode_bigtree",
          "old_text": null,
          "new_text": "smacker_decode_bigtree(gb, hc, ctx, length + 1)",
          "old_line_content": "        return 1;",
          "new_line_content": "        r = smacker_decode_bigtree(gb, hc, ctx, length + 1);",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": null,
          "new_api": "get_vlc2",
          "old_text": null,
          "new_text": "get_vlc2(&gb, vlc[2].table, SMKTREE_BITS, 3)",
          "old_line_content": "                ret = AVERROR_INVALIDDATA;",
          "new_line_content": "                    res = get_vlc2(&gb, vlc[2].table, SMKTREE_BITS, 3);",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\")",
          "old_line_content": "                if(vlc[2].table)",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\");",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": null,
          "new_api": "get_vlc2",
          "old_text": null,
          "new_text": "get_vlc2(&gb, vlc[3].table, SMKTREE_BITS, 3)",
          "old_line_content": "                    ret = AVERROR_INVALIDDATA;",
          "new_line_content": "                    res = get_vlc2(&gb, vlc[3].table, SMKTREE_BITS, 3);",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\")",
          "old_line_content": "                if(vlc[3].table)",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\");",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(smk->avctx, AV_LOG_ERROR, \"size too large\\n\")",
          "old_line_content": "    int escapes[3];",
          "new_line_content": "        av_log(smk->avctx, AV_LOG_ERROR, \"size too large\\n\");",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": null,
          "new_api": "get_vlc2",
          "old_text": null,
          "new_text": "get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3)",
          "old_line_content": "                val |= h[3].values[res] << 8;",
          "new_line_content": "                    res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3);",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\")",
          "old_line_content": "                if(vlc[0].table)",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\");",
          "content_same": false
        },
        {
          "line": 195,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(256 * sizeof(h[i].bits[0]))",
          "old_line_content": "    }",
          "new_line_content": "        h[i].bits    = av_malloc(256 * sizeof(h[i].bits[0]));",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(256 * sizeof(h[i].lengths[0]))",
          "old_line_content": "",
          "new_line_content": "        h[i].lengths = av_malloc(256 * sizeof(h[i].lengths[0]));",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(256 * sizeof(h[i].values[0]))",
          "old_line_content": "    for (int i = 0; i < 2; i++) {",
          "new_line_content": "        h[i].values  = av_malloc(256 * sizeof(h[i].values[0]));",
          "content_same": false
        },
        {
          "line": 199,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "        h[i].current = 0;",
          "new_line_content": "            err = AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": null,
          "new_api": "get_vlc2",
          "old_text": null,
          "new_text": "get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3)",
          "old_line_content": "                    ret = AVERROR_INVALIDDATA;",
          "new_line_content": "                    res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3);",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\")",
          "old_line_content": "                if(vlc[1].table)",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\");",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": null,
          "new_api": "smacker_decode_tree",
          "old_text": null,
          "new_text": "smacker_decode_tree(gb, &h[i], 0, 0)",
          "old_line_content": "            h[i].values[0] = 0;",
          "new_line_content": "        err = smacker_decode_tree(gb, &h[i], 0, 0);",
          "content_same": false
        },
        {
          "line": 211,
          "old_api": null,
          "new_api": "skip_bits1",
          "old_text": null,
          "new_text": "skip_bits1(gb)",
          "old_line_content": "            continue;",
          "new_line_content": "        skip_bits1(gb);",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": null,
          "new_api": "INIT_VLC_DEFAULT_SIZES",
          "old_text": null,
          "new_text": "INIT_VLC_DEFAULT_SIZES(h[i].lengths)",
          "old_line_content": "        if (err < 0)",
          "new_line_content": "                           INIT_VLC_DEFAULT_SIZES(h[i].lengths),",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": null,
          "new_api": "INIT_VLC_DEFAULT_SIZES",
          "old_text": null,
          "new_text": "INIT_VLC_DEFAULT_SIZES(h[i].bits)",
          "old_line_content": "            goto error;",
          "new_line_content": "                           INIT_VLC_DEFAULT_SIZES(h[i].bits),",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(&gb, 8)",
          "old_line_content": "                *samples++ = pred[0];",
          "new_line_content": "            pred[i] = get_bits(&gb, 8);",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": null,
          "new_api": "get_bits_left",
          "old_text": null,
          "new_text": "get_bits_left(&gb)",
          "old_line_content": "        for(i = stereo; i >= 0; i--)",
          "new_line_content": "            if (get_bits_left(&gb) < 0) {",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gb, 16)",
          "old_line_content": "                goto error;",
          "new_line_content": "    escapes[0]  = get_bits(gb, 16);",
          "content_same": false
        },
        {
          "line": 225,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gb, 16)",
          "old_line_content": "            }",
          "new_line_content": "    escapes[1]  = get_bits(gb, 16);",
          "content_same": false
        },
        {
          "line": 226,
          "old_api": null,
          "new_api": "get_bits",
          "old_text": null,
          "new_text": "get_bits(gb, 16)",
          "old_line_content": "        }",
          "new_line_content": "    escapes[2]  = get_bits(gb, 16);",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": null,
          "new_api": "get_vlc2",
          "old_text": null,
          "new_text": "get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3)",
          "old_line_content": "                ret = AVERROR_INVALIDDATA;",
          "new_line_content": "                    res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3);",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\")",
          "old_line_content": "                if(vlc[1].table)",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\");",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": null,
          "new_api": "sign_extend",
          "old_text": null,
          "new_text": "sign_extend(h[1].values[res], 8)",
          "old_line_content": "                if (res < 0) {",
          "new_line_content": "                pred[1] += sign_extend(h[1].values[res], 8);",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": null,
          "new_api": "get_vlc2",
          "old_text": null,
          "new_text": "get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3)",
          "old_line_content": "                }",
          "new_line_content": "                    res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3);",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\")",
          "old_line_content": "                if(vlc[0].table)",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\");",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": null,
          "new_api": "av_malloc_array",
          "old_text": null,
          "new_text": "av_malloc_array(huff.length + 3, sizeof(huff.values[0]))",
          "old_line_content": "    ctx.recode2 = h[1].values;",
          "new_line_content": "    huff.values = av_malloc_array(huff.length + 3, sizeof(huff.values[0]));",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": null,
          "new_api": "AVERROR",
          "old_text": null,
          "new_text": "AVERROR(ENOMEM)",
          "old_line_content": "",
          "new_line_content": "        err = AVERROR(ENOMEM);",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": null,
          "new_api": "sign_extend",
          "old_text": null,
          "new_text": "sign_extend(h[0].values[res], 8)",
          "old_line_content": "                if (res < 0) {",
          "new_line_content": "                pred[0] += sign_extend(h[0].values[res], 8);",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": null,
          "new_api": "skip_bits1",
          "old_text": null,
          "new_text": "skip_bits1(gb)",
          "old_line_content": "    *recodes = huff.values;",
          "new_line_content": "    skip_bits1(gb);",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": null,
          "new_api": "ff_free_vlc",
          "old_text": null,
          "new_text": "ff_free_vlc(&vlc[i])",
          "old_line_content": "    ret = buf_size;",
          "new_line_content": "            ff_free_vlc(&vlc[i]);",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(h[i].bits)",
          "old_line_content": "",
          "new_line_content": "        av_free(h[i].bits);",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(h[i].lengths)",
          "old_line_content": "error:",
          "new_line_content": "        av_free(h[i].lengths);",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(h[i].values)",
          "old_line_content": "    for(i = 0; i < 4; i++) {",
          "new_line_content": "        av_free(h[i].values);",
          "content_same": false
        },
        {
          "line": 260,
          "old_api": null,
          "new_api": "ff_free_vlc",
          "old_text": null,
          "new_text": "ff_free_vlc(&vlc[i])",
          "old_line_content": "",
          "new_line_content": "            ff_free_vlc(&vlc[i]);",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(h[i].bits)",
          "old_line_content": "    err = 0;",
          "new_line_content": "        av_free(h[i].bits);",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(h[i].lengths)",
          "old_line_content": "error:",
          "new_line_content": "        av_free(h[i].lengths);",
          "content_same": false
        },
        {
          "line": 263,
          "old_api": null,
          "new_api": "av_free",
          "old_text": null,
          "new_text": "av_free(h[i].values)",
          "old_line_content": "    for (int i = 0; i < 2; i++) {",
          "new_line_content": "        av_free(h[i].values);",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"Smacker video\")",
          "old_line_content": "    return ret;",
          "new_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"Smacker video\"),",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": null,
          "new_api": "AV_RL32",
          "old_text": null,
          "new_text": "AV_RL32(smk->avctx->extradata)",
          "old_line_content": "static int decode_header_trees(SmackVContext *smk) {",
          "new_line_content": "    mmap_size = AV_RL32(smk->avctx->extradata);",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": null,
          "new_api": "AV_RL32",
          "old_text": null,
          "new_text": "AV_RL32(smk->avctx->extradata + 4)",
          "old_line_content": "    GetBitContext gb;",
          "new_line_content": "    mclr_size = AV_RL32(smk->avctx->extradata + 4);",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": null,
          "new_api": "AV_RL32",
          "old_text": null,
          "new_text": "AV_RL32(smk->avctx->extradata + 8)",
          "old_line_content": "    int mmap_size, mclr_size, full_size, type_size, ret;",
          "new_line_content": "    full_size = AV_RL32(smk->avctx->extradata + 8);",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": null,
          "new_api": "AV_RL32",
          "old_text": null,
          "new_text": "AV_RL32(smk->avctx->extradata + 12)",
          "old_line_content": "    int skip = 0;",
          "new_line_content": "    type_size = AV_RL32(smk->avctx->extradata + 12);",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": null,
          "new_api": "NULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "NULL_IF_CONFIG_SMALL(\"Smacker audio\")",
          "old_line_content": "    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,",
          "new_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"Smacker audio\"),",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(&gb)",
          "old_line_content": "",
          "new_line_content": "    if(!get_bits1(&gb)) {",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(smk->avctx, AV_LOG_INFO, \"Skipping MMAP tree\\n\")",
          "old_line_content": "    if (ret < 0)",
          "new_line_content": "        av_log(smk->avctx, AV_LOG_INFO, \"Skipping MMAP tree\\n\");",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(sizeof(int) * 2)",
          "old_line_content": "        return ret;",
          "new_line_content": "        smk->mmap_tbl = av_malloc(sizeof(int) * 2);",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": null,
          "new_api": "smacker_decode_header_tree",
          "old_text": null,
          "new_text": "smacker_decode_header_tree(smk, &gb, &smk->mmap_tbl, smk->mmap_last, mmap_size)",
          "old_line_content": "        if (!smk->mmap_tbl)",
          "new_line_content": "        ret = smacker_decode_header_tree(smk, &gb, &smk->mmap_tbl, smk->mmap_last, mmap_size);",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(&gb)",
          "old_line_content": "    } else {",
          "new_line_content": "    if(!get_bits1(&gb)) {",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(smk->avctx, AV_LOG_INFO, \"Skipping MCLR tree\\n\")",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "        av_log(smk->avctx, AV_LOG_INFO, \"Skipping MCLR tree\\n\");",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(sizeof(int) * 2)",
          "old_line_content": "            return ret;",
          "new_line_content": "        smk->mclr_tbl = av_malloc(sizeof(int) * 2);",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": null,
          "new_api": "smacker_decode_header_tree",
          "old_text": null,
          "new_text": "smacker_decode_header_tree(smk, &gb, &smk->mclr_tbl, smk->mclr_last, mclr_size)",
          "old_line_content": "        if (!smk->mclr_tbl)",
          "new_line_content": "        ret = smacker_decode_header_tree(smk, &gb, &smk->mclr_tbl, smk->mclr_last, mclr_size);",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(&gb)",
          "old_line_content": "    } else {",
          "new_line_content": "    if(!get_bits1(&gb)) {",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(smk->avctx, AV_LOG_INFO, \"Skipping FULL tree\\n\")",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "        av_log(smk->avctx, AV_LOG_INFO, \"Skipping FULL tree\\n\");",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(sizeof(int) * 2)",
          "old_line_content": "            return ret;",
          "new_line_content": "        smk->full_tbl = av_malloc(sizeof(int) * 2);",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": null,
          "new_api": "smacker_decode_header_tree",
          "old_text": null,
          "new_text": "smacker_decode_header_tree(smk, &gb, &smk->full_tbl, smk->full_last, full_size)",
          "old_line_content": "        if (!smk->full_tbl)",
          "new_line_content": "        ret = smacker_decode_header_tree(smk, &gb, &smk->full_tbl, smk->full_last, full_size);",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(&gb)",
          "old_line_content": "    } else {",
          "new_line_content": "    if(!get_bits1(&gb)) {",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": null,
          "new_api": "av_log",
          "old_text": null,
          "new_text": "av_log(smk->avctx, AV_LOG_INFO, \"Skipping TYPE tree\\n\")",
          "old_line_content": "        if (ret < 0)",
          "new_line_content": "        av_log(smk->avctx, AV_LOG_INFO, \"Skipping TYPE tree\\n\");",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": null,
          "new_api": "av_malloc",
          "old_text": null,
          "new_text": "av_malloc(sizeof(int) * 2)",
          "old_line_content": "            return ret;",
          "new_line_content": "        smk->type_tbl = av_malloc(sizeof(int) * 2);",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": null,
          "new_api": "smacker_decode_header_tree",
          "old_text": null,
          "new_text": "smacker_decode_header_tree(smk, &gb, &smk->type_tbl, smk->type_last, type_size)",
          "old_line_content": "        if (!smk->type_tbl)",
          "new_line_content": "        ret = smacker_decode_header_tree(smk, &gb, &smk->type_tbl, smk->type_last, type_size);",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": null,
          "new_api": "register",
          "old_text": null,
          "new_text": "register",
          "old_line_content": "    recode[last[0]] = recode[last[1]] = recode[last[2]] = 0;",
          "new_line_content": "    register int *table = recode;",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": null,
          "new_api": "get_bits_left",
          "old_text": null,
          "new_text": "get_bits_left(gb)",
          "old_line_content": "static av_always_inline int smk_get_code(GetBitContext *gb, int *recode, int *last) {",
          "new_line_content": "        if (get_bits_left(gb) < 1)",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(gb)",
          "old_line_content": "    int v;",
          "new_line_content": "        if(get_bits1(gb))",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": null,
          "new_api": "ff_reget_buffer",
          "old_text": null,
          "new_text": "ff_reget_buffer(avctx, smk->pic, 0)",
          "old_line_content": "    int flags;",
          "new_line_content": "    if ((ret = ff_reget_buffer(avctx, smk->pic, 0)) < 0)",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": null,
          "new_api": "bytestream2_get_byteu",
          "old_text": null,
          "new_text": "bytestream2_get_byteu(&gb2)",
          "old_line_content": "        return ret;",
          "new_line_content": "    flags = bytestream2_get_byteu(&gb2);",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": null,
          "new_api": "bytestream2_get_be24u",
          "old_text": null,
          "new_text": "bytestream2_get_be24u(&gb2)",
          "old_line_content": "        smk->pic->pict_type = AV_PICTURE_TYPE_I;",
          "new_line_content": "        *pal++ = 0xFFU << 24 | bytestream2_get_be24u(&gb2);",
          "content_same": false
        },
        {
          "line": 400,
          "old_api": null,
          "new_api": "last_reset",
          "old_text": null,
          "new_text": "last_reset(smk->mmap_tbl, smk->mmap_last)",
          "old_line_content": "        smk->pic->pict_type = AV_PICTURE_TYPE_P;",
          "new_line_content": "    last_reset(smk->mmap_tbl, smk->mmap_last);",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": null,
          "new_api": "last_reset",
          "old_text": null,
          "new_text": "last_reset(smk->mclr_tbl, smk->mclr_last)",
          "old_line_content": "",
          "new_line_content": "    last_reset(smk->mclr_tbl, smk->mclr_last);",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": null,
          "new_api": "last_reset",
          "old_text": null,
          "new_text": "last_reset(smk->full_tbl, smk->full_last)",
          "old_line_content": "    for(i = 0; i < 256; i++)",
          "new_line_content": "    last_reset(smk->full_tbl, smk->full_last);",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": null,
          "new_api": "init_get_bits8",
          "old_text": null,
          "new_text": "init_get_bits8(&gb, avpkt->data + 769, avpkt->size - 769)",
          "old_line_content": "",
          "new_line_content": "    if ((ret = init_get_bits8(&gb, avpkt->data + 769, avpkt->size - 769)) < 0)",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": null,
          "new_api": "smk_get_code",
          "old_text": null,
          "new_text": "smk_get_code(&gb, smk->type_tbl, smk->type_last)",
          "old_line_content": "    stride = smk->pic->linesize[0];",
          "new_line_content": "        type = smk_get_code(&gb, smk->type_tbl, smk->type_last);",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": null,
          "new_api": "smk_get_code",
          "old_text": null,
          "new_text": "smk_get_code(&gb, smk->mclr_tbl, smk->mclr_last)",
          "old_line_content": "        switch(type & 3){",
          "new_line_content": "                clr = smk_get_code(&gb, smk->mclr_tbl, smk->mclr_last);",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": null,
          "new_api": "smk_get_code",
          "old_text": null,
          "new_text": "smk_get_code(&gb, smk->mmap_tbl, smk->mmap_last)",
          "old_line_content": "        case SMK_BLK_MONO:",
          "new_line_content": "                map = smk_get_code(&gb, smk->mmap_tbl, smk->mmap_last);",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": null,
          "new_api": "MKTAG",
          "old_text": null,
          "new_text": "MKTAG('S', 'M', 'K', '4')",
          "old_line_content": "                blk++;",
          "new_line_content": "            if(avctx->codec_tag == MKTAG('S', 'M', 'K', '4')) { // In case of Smacker v4 we have three modes",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(&gb)",
          "old_line_content": "            }",
          "new_line_content": "                if(get_bits1(&gb)) mode = 1;",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": null,
          "new_api": "get_bits1",
          "old_text": null,
          "new_text": "get_bits1(&gb)",
          "old_line_content": "            break;",
          "new_line_content": "                else if(get_bits1(&gb)) mode = 2;",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": null,
          "new_api": "smk_get_code",
          "old_text": null,
          "new_text": "smk_get_code(&gb, smk->full_tbl, smk->full_last)",
          "old_line_content": "            while(run-- && blk < blocks){",
          "new_line_content": "                        pix = smk_get_code(&gb, smk->full_tbl, smk->full_last);",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": null,
          "new_api": "AV_WL16",
          "old_text": null,
          "new_text": "AV_WL16(out+2,pix)",
          "old_line_content": "                out = smk->pic->data[0] + (blk / bw) * (stride * 4) + (blk % bw) * 4;",
          "new_line_content": "                        AV_WL16(out+2,pix);",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": null,
          "new_api": "smk_get_code",
          "old_text": null,
          "new_text": "smk_get_code(&gb, smk->full_tbl, smk->full_last)",
          "old_line_content": "                switch(mode){",
          "new_line_content": "                        pix = smk_get_code(&gb, smk->full_tbl, smk->full_last);",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": null,
          "new_api": "AV_WL16",
          "old_text": null,
          "new_text": "AV_WL16(out,pix)",
          "old_line_content": "                case 0:",
          "new_line_content": "                        AV_WL16(out,pix);",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": null,
          "new_api": "smk_get_code",
          "old_text": null,
          "new_text": "smk_get_code(&gb, smk->full_tbl, smk->full_last)",
          "old_line_content": "                    out[2] = out[3] = pix >> 8;",
          "new_line_content": "                    pix = smk_get_code(&gb, smk->full_tbl, smk->full_last);",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": null,
          "new_api": "smk_get_code",
          "old_text": null,
          "new_text": "smk_get_code(&gb, smk->full_tbl, smk->full_last)",
          "old_line_content": "                    out[2] = out[3] = pix >> 8;",
          "new_line_content": "                        pix2 = smk_get_code(&gb, smk->full_tbl, smk->full_last);",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": null,
          "new_api": "smk_get_code",
          "old_text": null,
          "new_text": "smk_get_code(&gb, smk->full_tbl, smk->full_last)",
          "old_line_content": "                    break;",
          "new_line_content": "                        pix1 = smk_get_code(&gb, smk->full_tbl, smk->full_last);",
          "content_same": false
        },
        {
          "line": 479,
          "old_api": null,
          "new_api": "AV_WL16",
          "old_text": null,
          "new_text": "AV_WL16(out,pix1)",
          "old_line_content": "                case 2:",
          "new_line_content": "                        AV_WL16(out,pix1);",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": null,
          "new_api": "AV_WL16",
          "old_text": null,
          "new_text": "AV_WL16(out+2,pix2)",
          "old_line_content": "                    for(i = 0; i < 2; i++) {",
          "new_line_content": "                        AV_WL16(out+2,pix2);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 517,
          "old_api": "av_frame_ref",
          "new_api": null,
          "old_text": "av_frame_ref(data, smk->pic)",
          "new_text": null,
          "old_line_content": "    if ((ret = av_frame_ref(data, smk->pic)) < 0)",
          "new_line_content": "    /* always report that the buffer was completely consumed */",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&smk->mclr_tbl)",
          "new_text": null,
          "old_line_content": "    av_freep(&smk->mclr_tbl);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&smk->full_tbl)",
          "new_text": null,
          "old_line_content": "    av_freep(&smk->full_tbl);",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "av_freep",
          "new_api": null,
          "old_text": "av_freep(&smk->type_tbl)",
          "new_text": null,
          "old_line_content": "    av_freep(&smk->type_tbl);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": "av_frame_free",
          "new_api": null,
          "old_text": "av_frame_free(&smk->pic)",
          "new_text": null,
          "old_line_content": "    av_frame_free(&smk->pic);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "av_frame_alloc",
          "new_api": null,
          "old_text": "av_frame_alloc()",
          "new_text": null,
          "old_line_content": "    c->pic = av_frame_alloc();",
          "new_line_content": "    if(avctx->extradata_size < 16){",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Extradata missing!\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Extradata missing!\\n\");",
          "new_line_content": "    if (ret < 0) {",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(EINVAL)",
          "new_text": null,
          "old_line_content": "        return AVERROR(EINVAL);",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": "decode_header_trees",
          "new_api": null,
          "old_text": "decode_header_trees(c)",
          "new_text": null,
          "old_line_content": "    ret = decode_header_trees(c);",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid number of channels\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"invalid number of channels\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"packet is too small\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"packet is too small\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": "AV_RL32",
          "new_api": null,
          "old_text": "AV_RL32(buf)",
          "new_text": null,
          "old_line_content": "    unp_size = AV_RL32(buf);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"packet is too big\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"packet is too big\\n\");",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": "init_get_bits8",
          "new_api": null,
          "old_text": "init_get_bits8(&gb, buf + 4, buf_size - 4)",
          "new_text": null,
          "old_line_content": "    if ((ret = init_get_bits8(&gb, buf + 4, buf_size - 4)) < 0)",
          "new_line_content": "        *got_frame_ptr = 0;",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(&gb)",
          "new_text": null,
          "old_line_content": "    stereo = get_bits1(&gb);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(&gb)",
          "new_text": null,
          "old_line_content": "    bits = get_bits1(&gb);",
          "new_line_content": "    if (bits == (avctx->sample_fmt == AV_SAMPLE_FMT_U8)) {",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"channels mismatch\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"channels mismatch\\n\");",
          "new_line_content": "        return AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 115,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gb, 8)",
          "new_text": null,
          "old_line_content": "        hc->values[hc->current] = get_bits(gb, 8);",
          "new_line_content": "        length++;",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"sample format mismatch\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"sample format mismatch\\n\");",
          "new_line_content": "    frame->nb_samples = unp_size / (avctx->channels * (bits + 1));",
          "content_same": false
        },
        {
          "line": 121,
          "old_api": "smacker_decode_tree",
          "new_api": null,
          "old_text": "smacker_decode_tree(gb, hc, prefix, length)",
          "new_text": null,
          "old_line_content": "        r = smacker_decode_tree(gb, hc, prefix, length);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR,\n               \"The buffer does not contain an integer number of samples\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR,",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 124,
          "old_api": "smacker_decode_tree",
          "new_api": null,
          "old_text": "smacker_decode_tree(gb, hc, prefix | (1U << (length - 1)), length)",
          "new_text": null,
          "old_line_content": "        return smacker_decode_tree(gb, hc, prefix | (1U << (length - 1)), length);",
          "new_line_content": " * Decode header tree",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": "ff_get_buffer",
          "new_api": null,
          "old_text": "ff_get_buffer(avctx, frame, 0)",
          "new_text": null,
          "old_line_content": "    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)",
          "new_line_content": "    // Initialize",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(256 * sizeof(h[i].bits))",
          "new_text": null,
          "old_line_content": "        h[i].bits    = av_malloc(256 * sizeof(h[i].bits));",
          "new_line_content": "            goto error;",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(256 * sizeof(h[i].lengths))",
          "new_text": null,
          "old_line_content": "        h[i].lengths = av_malloc(256 * sizeof(h[i].lengths));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "            ret = AVERROR(ENOMEM);",
          "new_line_content": "            goto error;",
          "content_same": false
        },
        {
          "line": 144,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gb)",
          "new_text": null,
          "old_line_content": "    if(!get_bits1(gb)){ //Leaf",
          "new_line_content": "            return AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": "smacker_decode_tree",
          "new_api": null,
          "old_text": "smacker_decode_tree(&gb, &h[i], 0, 0)",
          "new_text": null,
          "old_line_content": "        if ((ret = smacker_decode_tree(&gb, &h[i], 0, 0)) < 0)",
          "new_line_content": "                    h[i].lengths, sizeof(int), sizeof(int),",
          "content_same": false
        },
        {
          "line": 146,
          "old_api": "get_vlc2",
          "new_api": null,
          "old_text": "get_vlc2(gb, ctx->v1->table, SMKTREE_BITS, 3)",
          "new_text": null,
          "old_line_content": "        i1 = ctx->v1->table ? get_vlc2(gb, ctx->v1->table, SMKTREE_BITS, 3) : 0;",
          "new_line_content": "        if(val == ctx->escapes[0]) {",
          "content_same": false
        },
        {
          "line": 147,
          "old_api": "get_vlc2",
          "new_api": null,
          "old_text": "get_vlc2(gb, ctx->v2->table, SMKTREE_BITS, 3)",
          "new_text": null,
          "old_line_content": "        i2 = ctx->v2->table ? get_vlc2(gb, ctx->v2->table, SMKTREE_BITS, 3) : 0;",
          "new_line_content": "            ctx->last[0] = hc->current;",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": "skip_bits1",
          "new_api": null,
          "old_text": "skip_bits1(&gb)",
          "new_text": null,
          "old_line_content": "        skip_bits1(&gb);",
          "new_line_content": "            if (ret < 0) {",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": "init_vlc",
          "new_api": null,
          "old_text": "init_vlc(&vlc[i], SMKTREE_BITS, h[i].current,\n                    h[i].lengths, sizeof(int), sizeof(int),\n                    h[i].bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE)",
          "new_text": null,
          "old_line_content": "            ret = init_vlc(&vlc[i], SMKTREE_BITS, h[i].current,",
          "new_line_content": "                goto error;",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\");",
          "new_line_content": "    /* this codec relies on wraparound instead of clipping audio */",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(&gb, 16)",
          "new_text": null,
          "old_line_content": "            pred[i] = sign_extend(av_bswap16(get_bits(&gb, 16)), 16);",
          "new_line_content": "                ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": "get_bits_left",
          "new_api": null,
          "old_text": "get_bits_left(&gb)",
          "new_text": null,
          "old_line_content": "            if (get_bits_left(&gb) < 0) {",
          "new_line_content": "                if(vlc[2].table)",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": "get_vlc2",
          "new_api": null,
          "old_text": "get_vlc2(&gb, vlc[2].table, SMKTREE_BITS, 3)",
          "new_text": null,
          "old_line_content": "                    res = get_vlc2(&gb, vlc[2].table, SMKTREE_BITS, 3);",
          "new_line_content": "                    ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 173,
          "old_api": "smacker_decode_bigtree",
          "new_api": null,
          "old_text": "smacker_decode_bigtree(gb, hc, ctx, length + 1)",
          "new_text": null,
          "old_line_content": "        r_new = smacker_decode_bigtree(gb, hc, ctx, length + 1);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\")",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\");",
          "new_line_content": "                if(vlc[3].table)",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": "get_vlc2",
          "new_api": null,
          "old_text": "get_vlc2(&gb, vlc[3].table, SMKTREE_BITS, 3)",
          "new_text": null,
          "old_line_content": "                    res = get_vlc2(&gb, vlc[3].table, SMKTREE_BITS, 3);",
          "new_line_content": "                    ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": "sign_extend",
          "new_api": null,
          "old_text": "sign_extend(val, 16)",
          "new_text": null,
          "old_line_content": "                pred[1] += (unsigned)sign_extend(val, 16);",
          "new_line_content": "                else",
          "content_same": false
        },
        {
          "line": 193,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(smk->avctx, AV_LOG_ERROR, \"size too large\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(smk->avctx, AV_LOG_ERROR, \"size too large\\n\");",
          "new_line_content": "        h[i].length  = 256;",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": "get_vlc2",
          "new_api": null,
          "old_text": "get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3)",
          "new_text": null,
          "old_line_content": "                    res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3);",
          "new_line_content": "                    ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\")",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\");",
          "new_line_content": "                if(vlc[1].table)",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(256 * sizeof(h[i].bits[0]))",
          "new_text": null,
          "old_line_content": "        h[i].bits    = av_malloc(256 * sizeof(h[i].bits[0]));",
          "new_line_content": "            goto error;",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(256 * sizeof(h[i].lengths[0]))",
          "new_text": null,
          "old_line_content": "        h[i].lengths = av_malloc(256 * sizeof(h[i].lengths[0]));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": "get_vlc2",
          "new_api": null,
          "old_text": "get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3)",
          "new_text": null,
          "old_line_content": "                    res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3);",
          "new_line_content": "                    ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gb)",
          "new_text": null,
          "old_line_content": "        if (!get_bits1(gb)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 209,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(smk->avctx, AV_LOG_ERROR, \"Skipping %s bytes tree\\n\",\n                   i ? \"high\" : \"low\")",
          "new_text": null,
          "old_line_content": "            av_log(smk->avctx, AV_LOG_ERROR, \"Skipping %s bytes tree\\n\",",
          "new_line_content": "        if (err < 0)",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "sign_extend",
          "new_api": null,
          "old_text": "sign_extend(val, 16)",
          "new_text": null,
          "old_line_content": "                pred[0] += (unsigned)sign_extend(val, 16);",
          "new_line_content": "        for(i = stereo; i >= 0; i--)",
          "content_same": false
        },
        {
          "line": 216,
          "old_api": "skip_bits1",
          "new_api": null,
          "old_text": "skip_bits1(gb)",
          "new_text": null,
          "old_line_content": "        skip_bits1(gb);",
          "new_line_content": "                           INIT_VLC_LE);",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": "INIT_VLC_DEFAULT_SIZES",
          "new_api": null,
          "old_text": "INIT_VLC_DEFAULT_SIZES(h[i].lengths)",
          "new_text": null,
          "old_line_content": "                           INIT_VLC_DEFAULT_SIZES(h[i].lengths),",
          "new_line_content": "                goto error;",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": "INIT_VLC_DEFAULT_SIZES",
          "new_api": null,
          "old_text": "INIT_VLC_DEFAULT_SIZES(h[i].bits)",
          "new_text": null,
          "old_line_content": "                           INIT_VLC_DEFAULT_SIZES(h[i].bits),",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(&gb, 8)",
          "new_text": null,
          "old_line_content": "            pred[i] = get_bits(&gb, 8);",
          "new_line_content": "                ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(smk->avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\")",
          "new_text": null,
          "old_line_content": "                av_log(smk->avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": "get_bits_left",
          "new_api": null,
          "old_text": "get_bits_left(&gb)",
          "new_text": null,
          "old_line_content": "            if (get_bits_left(&gb) < 0) {",
          "new_line_content": "                if(vlc[1].table)",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gb, 16)",
          "new_text": null,
          "old_line_content": "    escapes[0]  = get_bits(gb, 16);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gb, 16)",
          "new_text": null,
          "old_line_content": "    escapes[1]  = get_bits(gb, 16);",
          "new_line_content": "    ctx.escapes[0] = escapes[0];",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": "get_bits",
          "new_api": null,
          "old_text": "get_bits(gb, 16)",
          "new_text": null,
          "old_line_content": "    escapes[2]  = get_bits(gb, 16);",
          "new_line_content": "    ctx.escapes[1] = escapes[1];",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "get_vlc2",
          "new_api": null,
          "old_text": "get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3)",
          "new_text": null,
          "old_line_content": "                    res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3);",
          "new_line_content": "                    ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\")",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\");",
          "new_line_content": "                *samples8++ = pred[1];",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": "sign_extend",
          "new_api": null,
          "old_text": "sign_extend(h[1].values[res], 8)",
          "new_text": null,
          "old_line_content": "                pred[1] += sign_extend(h[1].values[res], 8);",
          "new_line_content": "                else",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "get_vlc2",
          "new_api": null,
          "old_text": "get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3)",
          "new_text": null,
          "old_line_content": "                    res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3);",
          "new_line_content": "                    ret = AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\")",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"invalid vlc\\n\");",
          "new_line_content": "                *samples8++ = pred[0];",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": "av_malloc_array",
          "new_api": null,
          "old_text": "av_malloc_array(huff.length + 3, sizeof(huff.values[0]))",
          "new_text": null,
          "old_line_content": "    huff.values = av_malloc_array(huff.length + 3, sizeof(huff.values[0]));",
          "new_line_content": "    *recodes = huff.values;",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "sign_extend",
          "new_api": null,
          "old_text": "sign_extend(h[0].values[res], 8)",
          "new_text": null,
          "old_line_content": "                pred[0] += sign_extend(h[0].values[res], 8);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 253,
          "old_api": "smacker_decode_bigtree",
          "new_api": null,
          "old_text": "smacker_decode_bigtree(gb, &huff, &ctx, 0)",
          "new_text": null,
          "old_line_content": "    err = smacker_decode_bigtree(gb, &huff, &ctx, 0);",
          "new_line_content": "    if(ctx.last[1] == -1) ctx.last[1] = huff.current++;",
          "content_same": false
        },
        {
          "line": 256,
          "old_api": "skip_bits1",
          "new_api": null,
          "old_text": "skip_bits1(gb)",
          "new_text": null,
          "old_line_content": "    skip_bits1(gb);",
          "new_line_content": "    err = 0;",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "ff_free_vlc",
          "new_api": null,
          "old_text": "ff_free_vlc(&vlc[i])",
          "new_text": null,
          "old_line_content": "            ff_free_vlc(&vlc[i]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(h[i].bits)",
          "new_text": null,
          "old_line_content": "        av_free(h[i].bits);",
          "new_line_content": "    return ret;",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(h[i].lengths)",
          "new_text": null,
          "old_line_content": "        av_free(h[i].lengths);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(h[i].values)",
          "new_text": null,
          "old_line_content": "        av_free(h[i].values);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": "ff_free_vlc",
          "new_api": null,
          "old_text": "ff_free_vlc(&vlc[i])",
          "new_text": null,
          "old_line_content": "            ff_free_vlc(&vlc[i]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(h[i].bits)",
          "new_text": null,
          "old_line_content": "        av_free(h[i].bits);",
          "new_line_content": "    return err;",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(h[i].lengths)",
          "new_text": null,
          "old_line_content": "        av_free(h[i].lengths);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": "av_free",
          "new_api": null,
          "old_text": "av_free(h[i].values)",
          "new_text": null,
          "old_line_content": "        av_free(h[i].values);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"Smacker video\")",
          "new_text": null,
          "old_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"Smacker video\"),",
          "new_line_content": "    .close          = decode_end,",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": "AV_RL32",
          "new_api": null,
          "old_text": "AV_RL32(smk->avctx->extradata + 4)",
          "new_text": null,
          "old_line_content": "    mclr_size = AV_RL32(smk->avctx->extradata + 4);",
          "new_line_content": "    if (ret < 0)",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": "AV_RL32",
          "new_api": null,
          "old_text": "AV_RL32(smk->avctx->extradata + 8)",
          "new_text": null,
          "old_line_content": "    full_size = AV_RL32(smk->avctx->extradata + 8);",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": "AV_RL32",
          "new_api": null,
          "old_text": "AV_RL32(smk->avctx->extradata + 12)",
          "new_text": null,
          "old_line_content": "    type_size = AV_RL32(smk->avctx->extradata + 12);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "init_get_bits8",
          "new_api": null,
          "old_text": "init_get_bits8(&gb, smk->avctx->extradata + 16, smk->avctx->extradata_size - 16)",
          "new_text": null,
          "old_line_content": "    ret = init_get_bits8(&gb, smk->avctx->extradata + 16, smk->avctx->extradata_size - 16);",
          "new_line_content": "        skip ++;",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "NULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "NULL_IF_CONFIG_SMALL(\"Smacker audio\")",
          "new_text": null,
          "old_line_content": "    .long_name      = NULL_IF_CONFIG_SMALL(\"Smacker audio\"),",
          "new_line_content": "    .capabilities   = AV_CODEC_CAP_DR1,",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(smk->avctx, AV_LOG_INFO, \"Skipping MMAP tree\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(smk->avctx, AV_LOG_INFO, \"Skipping MMAP tree\\n\");",
          "new_line_content": "        smk->mmap_last[0] = smk->mmap_last[1] = smk->mmap_last[2] = 1;",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(sizeof(int) * 2)",
          "new_text": null,
          "old_line_content": "        smk->mmap_tbl = av_malloc(sizeof(int) * 2);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 293,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "            return AVERROR(ENOMEM);",
          "new_line_content": "        if (ret < 0)",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": "smacker_decode_header_tree",
          "new_api": null,
          "old_text": "smacker_decode_header_tree(smk, &gb, &smk->mmap_tbl, smk->mmap_last, mmap_size)",
          "new_text": null,
          "old_line_content": "        ret = smacker_decode_header_tree(smk, &gb, &smk->mmap_tbl, smk->mmap_last, mmap_size);",
          "new_line_content": "        skip ++;",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(smk->avctx, AV_LOG_INFO, \"Skipping MCLR tree\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(smk->avctx, AV_LOG_INFO, \"Skipping MCLR tree\\n\");",
          "new_line_content": "        smk->mclr_last[0] = smk->mclr_last[1] = smk->mclr_last[2] = 1;",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(sizeof(int) * 2)",
          "new_text": null,
          "old_line_content": "        smk->mclr_tbl = av_malloc(sizeof(int) * 2);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "            return AVERROR(ENOMEM);",
          "new_line_content": "        if (ret < 0)",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "smacker_decode_header_tree",
          "new_api": null,
          "old_text": "smacker_decode_header_tree(smk, &gb, &smk->mclr_tbl, smk->mclr_last, mclr_size)",
          "new_text": null,
          "old_line_content": "        ret = smacker_decode_header_tree(smk, &gb, &smk->mclr_tbl, smk->mclr_last, mclr_size);",
          "new_line_content": "        skip ++;",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(smk->avctx, AV_LOG_INFO, \"Skipping FULL tree\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(smk->avctx, AV_LOG_INFO, \"Skipping FULL tree\\n\");",
          "new_line_content": "        smk->full_last[0] = smk->full_last[1] = smk->full_last[2] = 1;",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(sizeof(int) * 2)",
          "new_text": null,
          "old_line_content": "        smk->full_tbl = av_malloc(sizeof(int) * 2);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "            return AVERROR(ENOMEM);",
          "new_line_content": "        if (ret < 0)",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": "smacker_decode_header_tree",
          "new_api": null,
          "old_text": "smacker_decode_header_tree(smk, &gb, &smk->full_tbl, smk->full_last, full_size)",
          "new_text": null,
          "old_line_content": "        ret = smacker_decode_header_tree(smk, &gb, &smk->full_tbl, smk->full_last, full_size);",
          "new_line_content": "        skip ++;",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": "av_log",
          "new_api": null,
          "old_text": "av_log(smk->avctx, AV_LOG_INFO, \"Skipping TYPE tree\\n\")",
          "new_text": null,
          "old_line_content": "        av_log(smk->avctx, AV_LOG_INFO, \"Skipping TYPE tree\\n\");",
          "new_line_content": "        smk->type_last[0] = smk->type_last[1] = smk->type_last[2] = 1;",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": "av_malloc",
          "new_api": null,
          "old_text": "av_malloc(sizeof(int) * 2)",
          "new_text": null,
          "old_line_content": "        smk->type_tbl = av_malloc(sizeof(int) * 2);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": "AVERROR",
          "new_api": null,
          "old_text": "AVERROR(ENOMEM)",
          "new_text": null,
          "old_line_content": "            return AVERROR(ENOMEM);",
          "new_line_content": "        if (ret < 0)",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": "smacker_decode_header_tree",
          "new_api": null,
          "old_text": "smacker_decode_header_tree(smk, &gb, &smk->type_tbl, smk->type_last, type_size)",
          "new_text": null,
          "old_line_content": "        ret = smacker_decode_header_tree(smk, &gb, &smk->type_tbl, smk->type_last, type_size);",
          "new_line_content": "        return AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 352,
          "old_api": "register",
          "new_api": null,
          "old_text": "register",
          "new_text": null,
          "old_line_content": "    register int *table = recode;",
          "new_line_content": "            return AVERROR_INVALIDDATA;",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": "get_bits_left",
          "new_api": null,
          "old_text": "get_bits_left(gb)",
          "new_text": null,
          "old_line_content": "        if (get_bits_left(gb) < 1)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(gb)",
          "new_text": null,
          "old_line_content": "        if(get_bits1(gb))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": "bytestream2_init",
          "new_api": null,
          "old_text": "bytestream2_init(&gb2, avpkt->data, avpkt->size)",
          "new_text": null,
          "old_line_content": "    bytestream2_init(&gb2, avpkt->data, avpkt->size);",
          "new_line_content": "        smk->pic->pict_type = AV_PICTURE_TYPE_I;",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": "bytestream2_get_byteu",
          "new_api": null,
          "old_text": "bytestream2_get_byteu(&gb2)",
          "new_text": null,
          "old_line_content": "    flags = bytestream2_get_byteu(&gb2);",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": "last_reset",
          "new_api": null,
          "old_text": "last_reset(smk->mmap_tbl, smk->mmap_last)",
          "new_text": null,
          "old_line_content": "    last_reset(smk->mmap_tbl, smk->mmap_last);",
          "new_line_content": "        return ret;",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": "last_reset",
          "new_api": null,
          "old_text": "last_reset(smk->mclr_tbl, smk->mclr_last)",
          "new_text": null,
          "old_line_content": "    last_reset(smk->mclr_tbl, smk->mclr_last);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": "last_reset",
          "new_api": null,
          "old_text": "last_reset(smk->full_tbl, smk->full_last)",
          "new_text": null,
          "old_line_content": "    last_reset(smk->full_tbl, smk->full_last);",
          "new_line_content": "    blk = 0;",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": "last_reset",
          "new_api": null,
          "old_text": "last_reset(smk->type_tbl, smk->type_last)",
          "new_text": null,
          "old_line_content": "    last_reset(smk->type_tbl, smk->type_last);",
          "new_line_content": "    bw = avctx->width >> 2;",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": "init_get_bits8",
          "new_api": null,
          "old_text": "init_get_bits8(&gb, avpkt->data + 769, avpkt->size - 769)",
          "new_text": null,
          "old_line_content": "    if ((ret = init_get_bits8(&gb, avpkt->data + 769, avpkt->size - 769)) < 0)",
          "new_line_content": "    bh = avctx->height >> 2;",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": "smk_get_code",
          "new_api": null,
          "old_text": "smk_get_code(&gb, smk->type_tbl, smk->type_last)",
          "new_text": null,
          "old_line_content": "        type = smk_get_code(&gb, smk->type_tbl, smk->type_last);",
          "new_line_content": "        case SMK_BLK_MONO:",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": "smk_get_code",
          "new_api": null,
          "old_text": "smk_get_code(&gb, smk->mclr_tbl, smk->mclr_last)",
          "new_text": null,
          "old_line_content": "                clr = smk_get_code(&gb, smk->mclr_tbl, smk->mclr_last);",
          "new_line_content": "                for(i = 0; i < 4; i++) {",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": "smk_get_code",
          "new_api": null,
          "old_text": "smk_get_code(&gb, smk->mmap_tbl, smk->mmap_last)",
          "new_text": null,
          "old_line_content": "                map = smk_get_code(&gb, smk->mmap_tbl, smk->mmap_last);",
          "new_line_content": "                    if(map & 1) out[0] = hi; else out[0] = lo;",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": "MKTAG",
          "new_api": null,
          "old_text": "MKTAG('S', 'M', 'K', '4')",
          "new_text": null,
          "old_line_content": "            if(avctx->codec_tag == MKTAG('S', 'M', 'K', '4')) { // In case of Smacker v4 we have three modes",
          "new_line_content": "                out = smk->pic->data[0] + (blk / bw) * (stride * 4) + (blk % bw) * 4;",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(&gb)",
          "new_text": null,
          "old_line_content": "                if(get_bits1(&gb)) mode = 1;",
          "new_line_content": "                switch(mode){",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": "get_bits1",
          "new_api": null,
          "old_text": "get_bits1(&gb)",
          "new_text": null,
          "old_line_content": "                else if(get_bits1(&gb)) mode = 2;",
          "new_line_content": "                case 0:",
          "content_same": false
        },
        {
          "line": 457,
          "old_api": "smk_get_code",
          "new_api": null,
          "old_text": "smk_get_code(&gb, smk->full_tbl, smk->full_last)",
          "new_text": null,
          "old_line_content": "                        pix = smk_get_code(&gb, smk->full_tbl, smk->full_last);",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": "AV_WL16",
          "new_api": null,
          "old_text": "AV_WL16(out+2,pix)",
          "new_text": null,
          "old_line_content": "                        AV_WL16(out+2,pix);",
          "new_line_content": "                    break;",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "smk_get_code",
          "new_api": null,
          "old_text": "smk_get_code(&gb, smk->full_tbl, smk->full_last)",
          "new_text": null,
          "old_line_content": "                        pix = smk_get_code(&gb, smk->full_tbl, smk->full_last);",
          "new_line_content": "                case 1:",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": "smk_get_code",
          "new_api": null,
          "old_text": "smk_get_code(&gb, smk->full_tbl, smk->full_last)",
          "new_text": null,
          "old_line_content": "                    pix = smk_get_code(&gb, smk->full_tbl, smk->full_last);",
          "new_line_content": "                    out[2] = out[3] = pix >> 8;",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": "smk_get_code",
          "new_api": null,
          "old_text": "smk_get_code(&gb, smk->full_tbl, smk->full_last)",
          "new_text": null,
          "old_line_content": "                    pix = smk_get_code(&gb, smk->full_tbl, smk->full_last);",
          "new_line_content": "                    out[2] = out[3] = pix >> 8;",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "AV_WL16",
          "new_api": null,
          "old_text": "AV_WL16(out,pix1)",
          "new_text": null,
          "old_line_content": "                        AV_WL16(out,pix1);",
          "new_line_content": "                        out += stride;",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": "AV_WL16",
          "new_api": null,
          "old_text": "AV_WL16(out+2,pix2)",
          "new_text": null,
          "old_line_content": "                        AV_WL16(out+2,pix2);",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "AV_WL16",
          "new_api": null,
          "old_text": "AV_WL16(out,pix1)",
          "new_text": null,
          "old_line_content": "                        AV_WL16(out,pix1);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": "AV_WL16",
          "new_api": null,
          "old_text": "AV_WL16(out+2,pix2)",
          "new_text": null,
          "old_line_content": "                        AV_WL16(out+2,pix2);",
          "new_line_content": "                blk++;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 22,
      "total_additions": 122,
      "total_deletions": 122,
      "total_api_changes": 266
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 7,
        "api_related_lines": 266,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          108,
          109,
          111,
          112,
          113,
          114
        ]
      }
    },
    "api_calls_before": 153,
    "api_calls_after": 153,
    "diff_info": {
      "added_lines": 2,
      "removed_lines": 7,
      "total_diff_lines": 21
    }
  }
}