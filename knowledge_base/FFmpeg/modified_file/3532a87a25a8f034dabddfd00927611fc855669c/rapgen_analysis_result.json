{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/3532a87a25a8f034dabddfd00927611fc855669c",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/3532a87a25a8f034dabddfd00927611fc855669c/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/3532a87a25a8f034dabddfd00927611fc855669c/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/FFmpeg/modified_file/3532a87a25a8f034dabddfd00927611fc855669c/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 132,
          "old_api": "trcmp",
          "new_api": "et_header_variable_length",
          "old_text": "trcmp(*buf, value_type))",
          "new_text": "et_header_variable_length(buf, buf_end);",
          "old_line_content": "        if (!strcmp(*buf, value_type)) {",
          "new_line_content": "            *variable_buffer_data_size = get_header_variable_length(buf, buf_end);",
          "content_same": false
        },
        {
          "line": 134,
          "old_api": "et_header_variable_length",
          "new_api": "v_log",
          "old_text": "et_header_variable_length(buf, buf_end);",
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "old_line_content": "            *variable_buffer_data_size = get_header_variable_length(buf, buf_end);",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "content_same": false
        },
        {
          "line": 182,
          "old_api": "ytestream_get_le32",
          "new_api": "v_log",
          "old_text": "ytestream_get_le32(&buf);",
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"Wrong magic number %d\\n\", magic_number);",
          "old_line_content": "    magic_number = bytestream_get_le32(&buf);",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Wrong magic number %d\\n\", magic_number);",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": "ytestream_get_le32",
          "new_api": "v_log",
          "old_text": "ytestream_get_le32(&buf);",
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"Tile based images are not supported\\n\");",
          "old_line_content": "    version_flag = bytestream_get_le32(&buf);",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Tile based images are not supported\\n\");",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": "ytestream_get_le32",
          "new_api": "v_log",
          "old_text": "ytestream_get_le32(&buf);",
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"Unknown color format\\n\");",
          "old_line_content": "                current_bits_per_color_id = bytestream_get_le32(&buf);",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"Unknown color format\\n\");",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": "et_header_variable_length",
          "new_api": "v_log",
          "old_text": "et_header_variable_length(&buf, buf_end);",
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "old_line_content": "            variable_buffer_data_size = get_header_variable_length(&buf, buf_end);",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 128,
          "old_api": null,
          "new_api": "trcmp",
          "old_text": null,
          "new_text": "trcmp(*buf, value_name))",
          "old_line_content": "                                              unsigned int *variable_buffer_data_size)",
          "new_line_content": "    if (buf_end - *buf >= minimum_length && !strcmp(*buf, value_name)) {",
          "content_same": false
        },
        {
          "line": 129,
          "old_api": null,
          "new_api": "trlen",
          "old_text": null,
          "new_text": "trlen(value_name)+",
          "old_line_content": "{",
          "new_line_content": "        *buf += strlen(value_name)+1;",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": null,
          "new_api": "v_log",
          "old_text": null,
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "old_line_content": "",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "content_same": false
        },
        {
          "line": 260,
          "old_api": null,
          "new_api": "heck_header_variable",
          "old_text": null,
          "new_text": "heck_header_variable(avctx, &buf, buf_end, \"dataWindow\", \"box2i\", 31, &variable_buffer_data_size) ",
          "old_line_content": "",
          "new_line_content": "        if (check_header_variable(avctx, &buf, buf_end, \"dataWindow\", \"box2i\", 31, &variable_buffer_data_size) >= 0) {",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": null,
          "new_api": "V_RL32",
          "old_text": null,
          "new_text": "V_RL32(buf);",
          "old_line_content": "                return -1;",
          "new_line_content": "            xmin = AV_RL32(buf);",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": null,
          "new_api": "V_RL32",
          "old_text": null,
          "new_text": "V_RL32(buf + 4);",
          "old_line_content": "",
          "new_line_content": "            ymin = AV_RL32(buf + 4);",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": null,
          "new_api": "emset",
          "old_text": null,
          "new_text": "emset(ptr, 0, avctx->width * 6);",
          "old_line_content": "    // Zero out the start if ymin is not 0",
          "new_line_content": "        memset(ptr, 0, avctx->width * 6);",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": null,
          "new_api": "trlen",
          "old_text": null,
          "new_text": "trlen(value_name)+",
          "old_line_content": "            return 1;",
          "new_line_content": "        *buf -= strlen(value_name)+1;",
          "content_same": false
        },
        {
          "line": 140,
          "old_api": null,
          "new_api": "v_log",
          "old_text": null,
          "new_text": "v_log(avctx, AV_LOG_WARNING, \"Unknown data type for header variable %s\\n\", value_name);",
          "old_line_content": "        }",
          "new_line_content": "        av_log(avctx, AV_LOG_WARNING, \"Unknown data type for header variable %s\\n\", value_name);",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": null,
          "new_api": "heck_header_variable",
          "old_text": null,
          "new_text": "heck_header_variable(avctx, &buf, buf_end, \"displayWindow\", \"box2i\", 34, &variable_buffer_data_size) ",
          "old_line_content": "",
          "new_line_content": "        if (check_header_variable(avctx, &buf, buf_end, \"displayWindow\", \"box2i\", 34, &variable_buffer_data_size) >= 0) {",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": null,
          "new_api": "ytestream_get_le64",
          "old_text": null,
          "new_text": "ytestream_get_le64(&buf) ",
          "old_line_content": "            /* Read the lineoffset from the line offset table and add 8 bytes",
          "new_line_content": "            const uint64_t line_offset = bytestream_get_le64(&buf) + 8;",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": null,
          "new_api": "v_log",
          "old_text": null,
          "new_text": "v_log(avctx, AV_LOG_WARNING, \"Line offset for line %d is out of reach setting it to black\\n\", y);",
          "old_line_content": "            if (line_offset > avpkt->size - xdelta * current_channel_offset) {",
          "new_line_content": "                av_log(avctx, AV_LOG_WARNING, \"Line offset for line %d is out of reach setting it to black\\n\", y);",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": null,
          "new_api": "emset",
          "old_text": null,
          "new_text": "emset(ptr_x, 0, avctx->width * 6);",
          "old_line_content": "                // Line offset is probably wrong and not inside the buffer",
          "new_line_content": "                memset(ptr_x, 0, avctx->width * 6);",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "V_RL32",
          "old_text": null,
          "new_text": "V_RL32(buf + 8) ",
          "old_line_content": "                return -1;",
          "new_line_content": "            w = AV_RL32(buf + 8) + 1;",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": null,
          "new_api": "V_RL32",
          "old_text": null,
          "new_text": "V_RL32(buf + 12) ",
          "old_line_content": "",
          "new_line_content": "            h = AV_RL32(buf + 12) + 1;",
          "content_same": false
        },
        {
          "line": 415,
          "old_api": null,
          "new_api": "emset",
          "old_text": null,
          "new_text": "emset(ptr_x, 0, xmin * 6);",
          "old_line_content": "",
          "new_line_content": "                memset(ptr_x, 0, xmin * 6);",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": null,
          "new_api": "heck_header_variable",
          "old_text": null,
          "new_text": "heck_header_variable(avctx, &buf, buf_end, \"lineOrder\", \"lineOrder\", 25, &variable_buffer_data_size) ",
          "old_line_content": "",
          "new_line_content": "        if (check_header_variable(avctx, &buf, buf_end, \"lineOrder\", \"lineOrder\", 25, &variable_buffer_data_size) >= 0) {",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": null,
          "new_api": "v_log",
          "old_text": null,
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"Doesn't support this line order : %d\\n\", *buf);",
          "old_line_content": "",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"Doesn't support this line order : %d\\n\", *buf);",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": null,
          "new_api": "ytestream_get_le32",
          "old_text": null,
          "new_text": "ytestream_get_le32(&red_channel_buffer))",
          "old_line_content": "                    // 32-bit",
          "new_line_content": "                        *ptr_x++ = exr_flt2uint(bytestream_get_le32(&red_channel_buffer));",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": null,
          "new_api": "ytestream_get_le32",
          "old_text": null,
          "new_text": "ytestream_get_le32(&green_channel_buffer))",
          "old_line_content": "                    for (x = 0; x < xdelta; x++) {",
          "new_line_content": "                        *ptr_x++ = exr_flt2uint(bytestream_get_le32(&green_channel_buffer));",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": null,
          "new_api": "ytestream_get_le16",
          "old_text": null,
          "new_text": "ytestream_get_le16(&red_channel_buffer))",
          "old_line_content": "                    // 16-bit",
          "new_line_content": "                        *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&red_channel_buffer));",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": null,
          "new_api": "ytestream_get_le16",
          "old_text": null,
          "new_text": "ytestream_get_le16(&green_channel_buffer))",
          "old_line_content": "                    for (x = 0; x < xdelta; x++) {",
          "new_line_content": "                        *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&green_channel_buffer));",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": null,
          "new_api": "heck_header_variable",
          "old_text": null,
          "new_text": "heck_header_variable(avctx, &buf, buf_end, \"compression\", \"compression\", 29, &variable_buffer_data_size) ",
          "old_line_content": "",
          "new_line_content": "        if (check_header_variable(avctx, &buf, buf_end, \"compression\", \"compression\", 29, &variable_buffer_data_size) >= 0) {",
          "content_same": false
        },
        {
          "line": 176,
          "old_api": null,
          "new_api": "v_log",
          "old_text": null,
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"Too short header to parse\\n\");",
          "old_line_content": "",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Too short header to parse\\n\");",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": null,
          "new_api": "emset",
          "old_text": null,
          "new_text": "emset(ptr_x, 0, (avctx->width - (xmax + 1)) * 6);",
          "old_line_content": "",
          "new_line_content": "                memset(ptr_x, 0, (avctx->width - (xmax + 1)) * 6);",
          "content_same": false
        },
        {
          "line": 180,
          "old_api": null,
          "new_api": "ytestream_get_le32",
          "old_text": null,
          "new_text": "ytestream_get_le32(&buf);",
          "old_line_content": "    }",
          "new_line_content": "    magic_number = bytestream_get_le32(&buf);",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": null,
          "new_api": "ytestream_get_le32",
          "old_text": null,
          "new_text": "ytestream_get_le32(&buf);",
          "old_line_content": "    }",
          "new_line_content": "    version_flag = bytestream_get_le32(&buf);",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": null,
          "new_api": "v_log",
          "old_text": null,
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"This type of compression is not supported\\n\");",
          "old_line_content": "            case EXR_B44:",
          "new_line_content": "                av_log(avctx, AV_LOG_ERROR, \"This type of compression is not supported\\n\");",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": null,
          "new_api": "emset",
          "old_text": null,
          "new_text": "emset(ptr, 0, avctx->width * 6);",
          "old_line_content": "    // Zero out the end if ymax+1 is not h",
          "new_line_content": "        memset(ptr, 0, avctx->width * 6);",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": null,
          "new_api": "heck_header_variable",
          "old_text": null,
          "new_text": "heck_header_variable(avctx, &buf, buf_end, \"channels\", \"chlist\", 38, &variable_buffer_data_size) ",
          "old_line_content": "        unsigned int variable_buffer_data_size;",
          "new_line_content": "        if (check_header_variable(avctx, &buf, buf_end, \"channels\", \"chlist\", 38, &variable_buffer_data_size) >= 0) {",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": null,
          "new_api": "v_log",
          "old_text": null,
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "old_line_content": "        // Check if there is enough bytes for a header",
          "new_line_content": "            av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": null,
          "new_api": "vcodec_get_frame_defaults",
          "old_text": null,
          "new_text": "vcodec_get_frame_defaults(&s->picture);",
          "old_line_content": "{",
          "new_line_content": "    avcodec_get_frame_defaults(&s->picture);",
          "content_same": false
        },
        {
          "line": 206,
          "old_api": null,
          "new_api": "trcmp",
          "old_text": null,
          "new_text": "trcmp(buf, \"R\"))",
          "old_line_content": "                int channel_index = -1;",
          "new_line_content": "                if (!strcmp(buf, \"R\"))",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": null,
          "new_api": "et_header_variable_length",
          "old_text": null,
          "new_text": "et_header_variable_length(&buf, buf_end);",
          "old_line_content": "        // Skip variable length",
          "new_line_content": "            variable_buffer_data_size = get_header_variable_length(&buf, buf_end);",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": null,
          "new_api": "release_buffer",
          "old_text": null,
          "new_text": "vctx->release_buffer(avctx, &s->picture);",
          "old_line_content": "    EXRContext *s = avctx->priv_data;",
          "new_line_content": "        avctx->release_buffer(avctx, &s->picture);",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": null,
          "new_api": "ytestream_get_byte",
          "old_text": null,
          "new_text": "ytestream_get_byte(&buf) ",
          "old_line_content": "                    channel_index = 2;",
          "new_line_content": "                while (bytestream_get_byte(&buf) && buf < channel_list_end)",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": null,
          "new_api": "v_log",
          "old_text": null,
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "old_line_content": "",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": null,
          "new_api": "v_log",
          "old_text": null,
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"Missing red channel\\n\");",
          "old_line_content": "                       s->channel_offsets[2]) < 0) {",
          "new_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"Missing red channel\\n\");",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": null,
          "new_api": "ytestream_get_le32",
          "old_text": null,
          "new_text": "ytestream_get_le32(&buf);",
          "old_line_content": "                }",
          "new_line_content": "                current_bits_per_color_id = bytestream_get_le32(&buf);",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": null,
          "new_api": "v_log",
          "old_text": null,
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"Incomplete frame\\n\");",
          "old_line_content": "",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Incomplete frame\\n\");",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": null,
          "new_api": "ULL_IF_CONFIG_SMALL",
          "old_text": null,
          "new_text": "ULL_IF_CONFIG_SMALL(\"OpenEXR image\"),",
          "old_line_content": "    .close              = decode_end,",
          "new_line_content": "    .long_name          = NULL_IF_CONFIG_SMALL(\"OpenEXR image\"),",
          "content_same": false
        },
        {
          "line": 100,
          "old_api": null,
          "new_api": "ytestream_get_le32",
          "old_text": null,
          "new_text": "ytestream_get_le32(buf);",
          "old_line_content": "                                               const uint8_t *buf_end)",
          "new_line_content": "    unsigned int variable_buffer_data_size = bytestream_get_le32(buf);",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": null,
          "new_api": "v_log",
          "old_text": null,
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"RGB channels not of the same depth\\n\");",
          "old_line_content": "                if (channel_index >= 0) {",
          "new_line_content": "                        av_log(avctx, AV_LOG_ERROR, \"RGB channels not of the same depth\\n\");",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": null,
          "new_api": "v_log_missing_feature",
          "old_text": null,
          "new_text": "v_log_missing_feature(avctx, \"8-bit OpenEXR\", 1);",
          "old_line_content": "    // 8-bit",
          "new_line_content": "        av_log_missing_feature(avctx, \"8-bit OpenEXR\", 1);",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": null,
          "new_api": "v_log",
          "old_text": null,
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"Unknown color format : %d\\n\", s->bits_per_color_id);",
          "old_line_content": "        return -1;",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Unknown color format : %d\\n\", s->bits_per_color_id);",
          "content_same": false
        },
        {
          "line": 369,
          "old_api": null,
          "new_api": "release_buffer",
          "old_text": null,
          "new_text": "vctx->release_buffer(avctx, &s->picture);",
          "old_line_content": "",
          "new_line_content": "        avctx->release_buffer(avctx, &s->picture);",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": null,
          "new_api": "v_image_check_size",
          "old_text": null,
          "new_text": "v_image_check_size(w, h, 0, avctx))",
          "old_line_content": "    if (s->picture.data[0])",
          "new_line_content": "    if (av_image_check_size(w, h, 0, avctx))",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": null,
          "new_api": "FMIN3",
          "old_text": null,
          "new_text": "FMIN3(s->channel_offsets[0],\n                       s->channel_offsets[1],\n                       s->channel_offsets[2]) ",
          "old_line_content": "             * are causing an overflow  */",
          "new_line_content": "            if (FFMIN3(s->channel_offsets[0],",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": null,
          "new_api": "v_log",
          "old_text": null,
          "new_text": "v_log(avctx, AV_LOG_ERROR, \"Wrong sizing or missing size information\\n\");",
          "old_line_content": "    // Verify the xmin, xmax, ymin, ymax and xdelta before setting the actual image size",
          "new_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Wrong sizing or missing size information\\n\");",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": null,
          "new_api": "vcodec_set_dimensions",
          "old_text": null,
          "new_text": "vcodec_set_dimensions(avctx, w, h);",
          "old_line_content": "",
          "new_line_content": "        avcodec_set_dimensions(avctx, w, h);",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": null,
          "new_api": "get_buffer",
          "old_text": null,
          "new_text": "vctx->get_buffer(avctx, p) ",
          "old_line_content": "    }",
          "new_line_content": "    if (avctx->get_buffer(avctx, p) < 0) {",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 385,
          "old_api": "get_buffer",
          "new_api": null,
          "old_text": "vctx->get_buffer(avctx, p) ",
          "new_text": null,
          "old_line_content": "    if (avctx->get_buffer(avctx, p) < 0) {",
          "new_line_content": "        return -1;",
          "content_same": false
        },
        {
          "line": 386,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 133,
          "old_api": "trlen",
          "new_api": null,
          "old_text": "trlen(value_type)+",
          "new_text": null,
          "old_line_content": "            *buf += strlen(value_type)+1;",
          "new_line_content": "            if (!*variable_buffer_data_size)",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": "heck_header_variable",
          "new_api": null,
          "old_text": "heck_header_variable(avctx, &buf, buf_end, \"dataWindow\", \"box2i\", 31, &variable_buffer_data_size) ",
          "new_text": null,
          "old_line_content": "        if (check_header_variable(avctx, &buf, buf_end, \"dataWindow\", \"box2i\", 31, &variable_buffer_data_size) >= 0) {",
          "new_line_content": "                return -1;",
          "content_same": false
        },
        {
          "line": 136,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "new_line_content": "                return -1;",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": "emset",
          "new_api": null,
          "old_text": "emset(ptr, 0, avctx->width * 6);",
          "new_text": null,
          "old_line_content": "        memset(ptr, 0, avctx->width * 6);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": "V_RL32",
          "new_api": null,
          "old_text": "V_RL32(buf + 8);",
          "new_text": null,
          "old_line_content": "            xmax = AV_RL32(buf + 8);",
          "new_line_content": "            xdelta = (xmax-xmin) + 1;",
          "content_same": false
        },
        {
          "line": 141,
          "old_api": "trlen",
          "new_api": null,
          "old_text": "trlen(value_name)+",
          "new_text": null,
          "old_line_content": "        *buf -= strlen(value_name)+1;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_WARNING, \"Unknown data type for header variable %s\\n\", value_name);",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_WARNING, \"Unknown data type for header variable %s\\n\", value_name);",
          "new_line_content": "    return -1;",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": "V_RL32",
          "new_api": null,
          "old_text": "V_RL32(buf + 12);",
          "new_text": null,
          "old_line_content": "            ymax = AV_RL32(buf + 12);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": "heck_header_variable",
          "new_api": null,
          "old_text": "heck_header_variable(avctx, &buf, buf_end, \"displayWindow\", \"box2i\", 34, &variable_buffer_data_size) ",
          "new_text": null,
          "old_line_content": "        if (check_header_variable(avctx, &buf, buf_end, \"displayWindow\", \"box2i\", 34, &variable_buffer_data_size) >= 0) {",
          "new_line_content": "                return -1;",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": "ytestream_get_le64",
          "new_api": null,
          "old_text": "ytestream_get_le64(&buf) ",
          "new_text": null,
          "old_line_content": "            const uint64_t line_offset = bytestream_get_le64(&buf) + 8;",
          "new_line_content": "            if (line_offset > avpkt->size - xdelta * current_channel_offset) {",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_WARNING, \"Line offset for line %d is out of reach setting it to black\\n\", y);",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_WARNING, \"Line offset for line %d is out of reach setting it to black\\n\", y);",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "emset",
          "new_api": null,
          "old_text": "emset(ptr_x, 0, avctx->width * 6);",
          "new_text": null,
          "old_line_content": "                memset(ptr_x, 0, avctx->width * 6);",
          "new_line_content": "                const uint8_t *red_channel_buffer   = avpkt->data + line_offset + xdelta * s->channel_offsets[0];",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": "V_RL32",
          "new_api": null,
          "old_text": "V_RL32(buf + 8) ",
          "new_text": null,
          "old_line_content": "            w = AV_RL32(buf + 8) + 1;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": "V_RL32",
          "new_api": null,
          "old_text": "V_RL32(buf + 12) ",
          "new_text": null,
          "old_line_content": "            h = AV_RL32(buf + 12) + 1;",
          "new_line_content": "            buf += variable_buffer_data_size;",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "heck_header_variable",
          "new_api": null,
          "old_text": "heck_header_variable(avctx, &buf, buf_end, \"lineOrder\", \"lineOrder\", 25, &variable_buffer_data_size) ",
          "new_text": null,
          "old_line_content": "        if (check_header_variable(avctx, &buf, buf_end, \"lineOrder\", \"lineOrder\", 25, &variable_buffer_data_size) >= 0) {",
          "new_line_content": "                return -1;",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": "emset",
          "new_api": null,
          "old_text": "emset(ptr_x, 0, xmin * 6);",
          "new_text": null,
          "old_line_content": "                memset(ptr_x, 0, xmin * 6);",
          "new_line_content": "                if (s->bits_per_color_id == 2) {",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"Doesn't support this line order : %d\\n\", *buf);",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"Doesn't support this line order : %d\\n\", *buf);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": "ytestream_get_le32",
          "new_api": null,
          "old_text": "ytestream_get_le32(&green_channel_buffer))",
          "new_text": null,
          "old_line_content": "                        *ptr_x++ = exr_flt2uint(bytestream_get_le32(&green_channel_buffer));",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": "ytestream_get_le32",
          "new_api": null,
          "old_text": "ytestream_get_le32(&blue_channel_buffer))",
          "new_text": null,
          "old_line_content": "                        *ptr_x++ = exr_flt2uint(bytestream_get_le32(&blue_channel_buffer));",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": "ytestream_get_le16",
          "new_api": null,
          "old_text": "ytestream_get_le16(&green_channel_buffer))",
          "new_text": null,
          "old_line_content": "                        *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&green_channel_buffer));",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": "heck_header_variable",
          "new_api": null,
          "old_text": "heck_header_variable(avctx, &buf, buf_end, \"compression\", \"compression\", 29, &variable_buffer_data_size) ",
          "new_text": null,
          "old_line_content": "        if (check_header_variable(avctx, &buf, buf_end, \"compression\", \"compression\", 29, &variable_buffer_data_size) >= 0) {",
          "new_line_content": "                return -1;",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": "ytestream_get_le16",
          "new_api": null,
          "old_text": "ytestream_get_le16(&blue_channel_buffer))",
          "new_text": null,
          "old_line_content": "                        *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&blue_channel_buffer));",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 178,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"Too short header to parse\\n\");",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Too short header to parse\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": "emset",
          "new_api": null,
          "old_text": "emset(ptr_x, 0, (avctx->width - (xmax + 1)) * 6);",
          "new_text": null,
          "old_line_content": "                memset(ptr_x, 0, (avctx->width - (xmax + 1)) * 6);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"Wrong magic number %d\\n\", magic_number);",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Wrong magic number %d\\n\", magic_number);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"This type of compression is not supported\\n\");",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"This type of compression is not supported\\n\");",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"Tile based images are not supported\\n\");",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Tile based images are not supported\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": "emset",
          "new_api": null,
          "old_text": "emset(ptr, 0, avctx->width * 6);",
          "new_text": null,
          "old_line_content": "        memset(ptr, 0, avctx->width * 6);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 198,
          "old_api": "heck_header_variable",
          "new_api": null,
          "old_text": "heck_header_variable(avctx, &buf, buf_end, \"channels\", \"chlist\", 38, &variable_buffer_data_size) ",
          "new_text": null,
          "old_line_content": "        if (check_header_variable(avctx, &buf, buf_end, \"channels\", \"chlist\", 38, &variable_buffer_data_size) >= 0) {",
          "new_line_content": "            if (!variable_buffer_data_size)",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "new_text": null,
          "old_line_content": "            av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": "vcodec_get_frame_defaults",
          "new_api": null,
          "old_text": "vcodec_get_frame_defaults(&s->picture);",
          "new_text": null,
          "old_line_content": "    avcodec_get_frame_defaults(&s->picture);",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 212,
          "old_api": "trcmp",
          "new_api": null,
          "old_text": "trcmp(buf, \"B\"))",
          "new_text": null,
          "old_line_content": "                if (!strcmp(buf, \"B\"))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "release_buffer",
          "new_api": null,
          "old_text": "vctx->release_buffer(avctx, &s->picture);",
          "new_text": null,
          "old_line_content": "        avctx->release_buffer(avctx, &s->picture);",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": "ytestream_get_byte",
          "new_api": null,
          "old_text": "ytestream_get_byte(&buf) ",
          "new_text": null,
          "old_line_content": "                while (bytestream_get_byte(&buf) && buf < channel_list_end)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "new_text": null,
          "old_line_content": "                av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"Incomplete frame\\n\");",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Incomplete frame\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 225,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"Unknown color format\\n\");",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"Unknown color format\\n\");",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": "ULL_IF_CONFIG_SMALL",
          "new_api": null,
          "old_text": "ULL_IF_CONFIG_SMALL(\"OpenEXR image\"),",
          "new_text": null,
          "old_line_content": "    .long_name          = NULL_IF_CONFIG_SMALL(\"OpenEXR image\"),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 102,
          "old_api": "ytestream_get_le32",
          "new_api": null,
          "old_text": "ytestream_get_le32(buf);",
          "new_text": null,
          "old_line_content": "    unsigned int variable_buffer_data_size = bytestream_get_le32(buf);",
          "new_line_content": "        return 0;",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"RGB channels not of the same depth\\n\");",
          "new_text": null,
          "old_line_content": "                        av_log(avctx, AV_LOG_ERROR, \"RGB channels not of the same depth\\n\");",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": "v_log_missing_feature",
          "new_api": null,
          "old_text": "v_log_missing_feature(avctx, \"8-bit OpenEXR\", 1);",
          "new_text": null,
          "old_line_content": "        av_log_missing_feature(avctx, \"8-bit OpenEXR\", 1);",
          "new_line_content": "    default:",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"Unknown color format : %d\\n\", s->bits_per_color_id);",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Unknown color format : %d\\n\", s->bits_per_color_id);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": "release_buffer",
          "new_api": null,
          "old_text": "vctx->release_buffer(avctx, &s->picture);",
          "new_text": null,
          "old_line_content": "        avctx->release_buffer(avctx, &s->picture);",
          "new_line_content": "        return -1;",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "v_image_check_size",
          "new_api": null,
          "old_text": "v_image_check_size(w, h, 0, avctx))",
          "new_text": null,
          "old_line_content": "    if (av_image_check_size(w, h, 0, avctx))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": "FMIN3",
          "new_api": null,
          "old_text": "FMIN3(s->channel_offsets[0],\n                       s->channel_offsets[1],\n                       s->channel_offsets[2]) ",
          "new_text": null,
          "old_line_content": "            if (FFMIN3(s->channel_offsets[0],",
          "new_line_content": "                       s->channel_offsets[2]) < 0) {",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"Wrong sizing or missing size information\\n\");",
          "new_text": null,
          "old_line_content": "        av_log(avctx, AV_LOG_ERROR, \"Wrong sizing or missing size information\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 253,
          "old_api": "v_log",
          "new_api": null,
          "old_text": "v_log(avctx, AV_LOG_ERROR, \"Missing blue channel\\n\");",
          "new_text": null,
          "old_line_content": "                    av_log(avctx, AV_LOG_ERROR, \"Missing blue channel\\n\");",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": "vcodec_set_dimensions",
          "new_api": null,
          "old_text": "vcodec_set_dimensions(avctx, w, h);",
          "new_text": null,
          "old_line_content": "        avcodec_set_dimensions(avctx, w, h);",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 6,
      "total_additions": 51,
      "total_deletions": 51,
      "total_api_changes": 108
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 108,
        "non_api_lines": 8,
        "non_api_line_numbers": [
          80,
          81,
          82,
          83,
          84,
          85,
          86,
          88
        ]
      }
    },
    "api_calls_before": 73,
    "api_calls_after": 73,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 8,
      "total_diff_lines": 27
    }
  }
}