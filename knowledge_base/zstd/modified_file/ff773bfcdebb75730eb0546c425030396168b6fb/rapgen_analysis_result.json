{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/zstd/modified_file/ff773bfcdebb75730eb0546c425030396168b6fb",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/zstd/modified_file/ff773bfcdebb75730eb0546c425030396168b6fb/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/zstd/modified_file/ff773bfcdebb75730eb0546c425030396168b6fb/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/zstd/modified_file/ff773bfcdebb75730eb0546c425030396168b6fb/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 90,
          "old_api": "ERROR",
          "new_api": "MEM_readLE32",
          "old_text": "ERROR(tableLog_tooLarge)",
          "new_text": "MEM_readLE32(ip)",
          "old_line_content": "    if (nbBits > FSE_TABLELOG_ABSOLUTE_MAX) return ERROR(tableLog_tooLarge);",
          "new_line_content": "    bitStream = MEM_readLE32(ip);",
          "content_same": false
        },
        {
          "line": 157,
          "old_api": "ERROR",
          "new_api": "MEM_readLE32",
          "old_text": "ERROR(corruption_detected)",
          "new_text": "MEM_readLE32(ip)",
          "old_line_content": "    if (remaining != 1) return ERROR(corruption_detected);",
          "new_line_content": "            bitStream = MEM_readLE32(ip) >> (bitCount & 31);",
          "content_same": false
        },
        {
          "line": 203,
          "old_api": "FSE_DTABLE_SIZE_U32",
          "new_api": "FSE_isError",
          "old_text": "FSE_DTABLE_SIZE_U32(6)",
          "new_text": "FSE_isError(oSize)",
          "old_line_content": "        FSE_DTable fseWorkspace[FSE_DTABLE_SIZE_U32(6)];  /* 6 is max possible tableLog for HUF header (maybe even 5, to be tested) */",
          "new_line_content": "        if (FSE_isError(oSize)) return oSize;",
          "content_same": false
        },
        {
          "line": 210,
          "old_api": "memset",
          "new_api": "ERROR",
          "old_text": "memset(rankStats, 0, (HUF_TABLELOG_MAX + 1) * sizeof(U32))",
          "new_text": "ERROR(corruption_detected)",
          "old_line_content": "    memset(rankStats, 0, (HUF_TABLELOG_MAX + 1) * sizeof(U32));",
          "new_line_content": "            if (huffWeight[n] >= HUF_TABLELOG_MAX) return ERROR(corruption_detected);",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": "ERROR",
          "new_api": "BIT_highbit32",
          "old_text": "ERROR(corruption_detected)",
          "new_text": "BIT_highbit32(weightTotal)",
          "old_line_content": "    if (weightTotal == 0) return ERROR(corruption_detected);",
          "new_line_content": "    {   U32 const tableLog = BIT_highbit32(weightTotal) + 1;",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": "ERROR",
          "new_api": "U32)(oSize+1)",
          "old_text": "ERROR(corruption_detected)",
          "new_text": "U32)(oSize+1)",
          "old_line_content": "    if ((rankStats[1] < 2) || (rankStats[1] & 1)) return ERROR(corruption_detected);   /* by construction : at least 2 elts of rank 1, must be even */",
          "new_line_content": "    *nbSymbolsPtr = (U32)(oSize+1);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 159,
          "old_api": null,
          "new_api": "ERROR",
          "old_text": null,
          "new_text": "ERROR(corruption_detected)",
          "old_line_content": "    /* zeroise the rest */",
          "new_line_content": "    if (remaining != 1) return ERROR(corruption_detected);",
          "content_same": false
        },
        {
          "line": 160,
          "old_api": null,
          "new_api": "ERROR",
          "old_text": null,
          "new_text": "ERROR(corruption_detected)",
          "old_line_content": "    {   unsigned symbNb = charnum;",
          "new_line_content": "    if (bitCount > 32) return ERROR(corruption_detected);",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": null,
          "new_api": "ERROR",
          "old_text": null,
          "new_text": "ERROR(srcSize_wrong)",
          "old_line_content": "    size_t iSize;",
          "new_line_content": "    if (!srcSize) return ERROR(srcSize_wrong);",
          "content_same": false
        },
        {
          "line": 191,
          "old_api": null,
          "new_api": "ERROR",
          "old_text": null,
          "new_text": "ERROR(srcSize_wrong)",
          "old_line_content": "    if (iSize >= 128) {  /* special header */",
          "new_line_content": "        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": null,
          "new_api": "ERROR",
          "old_text": null,
          "new_text": "ERROR(corruption_detected)",
          "old_line_content": "        oSize = iSize - 127;",
          "new_line_content": "        if (oSize >= hwSize) return ERROR(corruption_detected);",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": null,
          "new_api": "FSE_DTABLE_SIZE_U32",
          "old_text": null,
          "new_text": "FSE_DTABLE_SIZE_U32(6)",
          "old_line_content": "                huffWeight[n+1] = ip[n/2] & 15;",
          "new_line_content": "        FSE_DTable fseWorkspace[FSE_DTABLE_SIZE_U32(6)];  /* 6 is max possible tableLog for HUF header (maybe even 5, to be tested) */",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": null,
          "new_api": "ERROR",
          "old_text": null,
          "new_text": "ERROR(srcSize_wrong)",
          "old_line_content": "    }   }   }",
          "new_line_content": "        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);",
          "content_same": false
        },
        {
          "line": 202,
          "old_api": null,
          "new_api": "FSE_decompress_wksp",
          "old_text": null,
          "new_text": "FSE_decompress_wksp(huffWeight, hwSize-1, ip+1, iSize, fseWorkspace, 6)",
          "old_line_content": "    else  {   /* header compressed with FSE (normal case) */",
          "new_line_content": "        oSize = FSE_decompress_wksp(huffWeight, hwSize-1, ip+1, iSize, fseWorkspace, 6);   /* max (hwSize-1) values decoded, as last one is implied */",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(rankStats, 0, (HUF_TABLELOG_MAX + 1) * sizeof(U32))",
          "old_line_content": "    }",
          "new_line_content": "    memset(rankStats, 0, (HUF_TABLELOG_MAX + 1) * sizeof(U32));",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": null,
          "new_api": "ERROR",
          "old_text": null,
          "new_text": "ERROR(corruption_detected)",
          "old_line_content": "            rankStats[huffWeight[n]]++;",
          "new_line_content": "    if (weightTotal == 0) return ERROR(corruption_detected);",
          "content_same": false
        },
        {
          "line": 89,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(normalizedCounter, 0, (*maxSVPtr+1) * sizeof(normalizedCounter[0]))",
          "old_line_content": "    nbBits = (bitStream & 0xF) + FSE_MIN_TABLELOG;   /* extract tableLog */",
          "new_line_content": "    memset(normalizedCounter, 0, (*maxSVPtr+1) * sizeof(normalizedCounter[0]));   /* all symbols not present in NCount have a frequency of 0 */",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": null,
          "new_api": "ERROR",
          "old_text": null,
          "new_text": "ERROR(corruption_detected)",
          "old_line_content": "",
          "new_line_content": "        if (tableLog > HUF_TABLELOG_MAX) return ERROR(corruption_detected);",
          "content_same": false
        },
        {
          "line": 92,
          "old_api": null,
          "new_api": "ERROR",
          "old_text": null,
          "new_text": "ERROR(tableLog_tooLarge)",
          "old_line_content": "    bitCount = 4;",
          "new_line_content": "    if (nbBits > FSE_TABLELOG_ABSOLUTE_MAX) return ERROR(tableLog_tooLarge);",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": null,
          "new_api": "BIT_highbit32",
          "old_text": null,
          "new_text": "BIT_highbit32(rest)",
          "old_line_content": "        /* determine last weight */",
          "new_line_content": "            U32 const verif = 1 << BIT_highbit32(rest);",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": null,
          "new_api": "BIT_highbit32",
          "old_text": null,
          "new_text": "BIT_highbit32(rest)",
          "old_line_content": "        {   U32 const total = 1 << tableLog;",
          "new_line_content": "            U32 const lastWeight = BIT_highbit32(rest) + 1;",
          "content_same": false
        },
        {
          "line": 225,
          "old_api": null,
          "new_api": "ERROR",
          "old_text": null,
          "new_text": "ERROR(corruption_detected)",
          "old_line_content": "            U32 const rest = total - weightTotal;",
          "new_line_content": "            if (verif != rest) return ERROR(corruption_detected);    /* last value must be a clean power of 2 */",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": null,
          "new_api": "ERROR",
          "old_text": null,
          "new_text": "ERROR(corruption_detected)",
          "old_line_content": "    }   }",
          "new_line_content": "    if ((rankStats[1] < 2) || (rankStats[1] & 1)) return ERROR(corruption_detected);   /* by construction : at least 2 elts of rank 1, must be even */",
          "content_same": false
        },
        {
          "line": 107,
          "old_api": null,
          "new_api": "MEM_readLE32",
          "old_text": null,
          "new_text": "MEM_readLE32(ip)",
          "old_line_content": "                    bitStream >>= 16;",
          "new_line_content": "                    bitStream = MEM_readLE32(ip) >> bitCount;",
          "content_same": false
        },
        {
          "line": 119,
          "old_api": null,
          "new_api": "ERROR",
          "old_text": null,
          "new_text": "ERROR(maxSymbolValue_tooSmall)",
          "old_line_content": "            if ((ip <= iend-7) || (ip + (bitCount>>3) <= iend-4)) {",
          "new_line_content": "            if (n0 > *maxSVPtr) return ERROR(maxSymbolValue_tooSmall);",
          "content_same": false
        },
        {
          "line": 122,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert((bitCount >> 3) <= 3)",
          "old_line_content": "                bitCount &= 7;",
          "new_line_content": "                assert((bitCount >> 3) <= 3); /* For first condition to work */",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": null,
          "new_api": "MEM_readLE32",
          "old_text": null,
          "new_text": "MEM_readLE32(ip)",
          "old_line_content": "                bitStream >>= 2;",
          "new_line_content": "                bitStream = MEM_readLE32(ip) >> bitCount;",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 155,
          "old_api": "MEM_readLE32",
          "new_api": null,
          "old_text": "MEM_readLE32(ip)",
          "new_text": null,
          "old_line_content": "            bitStream = MEM_readLE32(ip) >> (bitCount & 31);",
          "new_line_content": "                ip = iend - 4;",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": "ERROR",
          "new_api": null,
          "old_text": "ERROR(corruption_detected)",
          "new_text": null,
          "old_line_content": "    if (bitCount > 32) return ERROR(corruption_detected);",
          "new_line_content": "    }   }   /* while ((remaining>1) & (charnum<=*maxSVPtr)) */",
          "content_same": false
        },
        {
          "line": 187,
          "old_api": "ERROR",
          "new_api": null,
          "old_text": "ERROR(srcSize_wrong)",
          "new_text": null,
          "old_line_content": "    if (!srcSize) return ERROR(srcSize_wrong);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 194,
          "old_api": "ERROR",
          "new_api": null,
          "old_text": "ERROR(srcSize_wrong)",
          "new_text": null,
          "old_line_content": "        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);",
          "new_line_content": "        {   U32 n;",
          "content_same": false
        },
        {
          "line": 195,
          "old_api": "ERROR",
          "new_api": null,
          "old_text": "ERROR(corruption_detected)",
          "new_text": null,
          "old_line_content": "        if (oSize >= hwSize) return ERROR(corruption_detected);",
          "new_line_content": "            for (n=0; n<oSize; n+=2) {",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": "ERROR",
          "new_api": null,
          "old_text": "ERROR(srcSize_wrong)",
          "new_text": null,
          "old_line_content": "        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 205,
          "old_api": "FSE_decompress_wksp",
          "new_api": null,
          "old_text": "FSE_decompress_wksp(huffWeight, hwSize-1, ip+1, iSize, fseWorkspace, 6)",
          "new_text": null,
          "old_line_content": "        oSize = FSE_decompress_wksp(huffWeight, hwSize-1, ip+1, iSize, fseWorkspace, 6);   /* max (hwSize-1) values decoded, as last one is implied */",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 206,
          "old_api": "FSE_isError",
          "new_api": null,
          "old_text": "FSE_isError(oSize)",
          "new_text": null,
          "old_line_content": "        if (FSE_isError(oSize)) return oSize;",
          "new_line_content": "    /* collect weight stats */",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": "ERROR",
          "new_api": null,
          "old_text": "ERROR(corruption_detected)",
          "new_text": null,
          "old_line_content": "            if (huffWeight[n] >= HUF_TABLELOG_MAX) return ERROR(corruption_detected);",
          "new_line_content": "    }   }",
          "content_same": false
        },
        {
          "line": 88,
          "old_api": "MEM_readLE32",
          "new_api": null,
          "old_text": "MEM_readLE32(ip)",
          "new_text": null,
          "old_line_content": "    bitStream = MEM_readLE32(ip);",
          "new_line_content": "    /* init */",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": "BIT_highbit32",
          "new_api": null,
          "old_text": "BIT_highbit32(weightTotal)",
          "new_text": null,
          "old_line_content": "    {   U32 const tableLog = BIT_highbit32(weightTotal) + 1;",
          "new_line_content": "        /* determine last weight */",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": "ERROR",
          "new_api": null,
          "old_text": "ERROR(corruption_detected)",
          "new_text": null,
          "old_line_content": "        if (tableLog > HUF_TABLELOG_MAX) return ERROR(corruption_detected);",
          "new_line_content": "        {   U32 const total = 1 << tableLog;",
          "content_same": false
        },
        {
          "line": 226,
          "old_api": "BIT_highbit32",
          "new_api": null,
          "old_text": "BIT_highbit32(rest)",
          "new_text": null,
          "old_line_content": "            U32 const verif = 1 << BIT_highbit32(rest);",
          "new_line_content": "            huffWeight[oSize] = (BYTE)lastWeight;",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": "BIT_highbit32",
          "new_api": null,
          "old_text": "BIT_highbit32(rest)",
          "new_text": null,
          "old_line_content": "            U32 const lastWeight = BIT_highbit32(rest) + 1;",
          "new_line_content": "            rankStats[lastWeight]++;",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": "ERROR",
          "new_api": null,
          "old_text": "ERROR(corruption_detected)",
          "new_text": null,
          "old_line_content": "            if (verif != rest) return ERROR(corruption_detected);    /* last value must be a clean power of 2 */",
          "new_line_content": "    }   }",
          "content_same": false
        },
        {
          "line": 105,
          "old_api": "MEM_readLE32",
          "new_api": null,
          "old_text": "MEM_readLE32(ip)",
          "new_text": null,
          "old_line_content": "                    bitStream = MEM_readLE32(ip) >> bitCount;",
          "new_line_content": "                if (ip < iend-5) {",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": "U32)(oSize+1)",
          "new_api": null,
          "old_text": "U32)(oSize+1)",
          "new_text": null,
          "old_line_content": "    *nbSymbolsPtr = (U32)(oSize+1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 117,
          "old_api": "ERROR",
          "new_api": null,
          "old_text": "ERROR(maxSymbolValue_tooSmall)",
          "new_text": null,
          "old_line_content": "            if (n0 > *maxSVPtr) return ERROR(maxSymbolValue_tooSmall);",
          "new_line_content": "            n0 += bitStream & 3;",
          "content_same": false
        },
        {
          "line": 120,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert((bitCount >> 3) <= 3)",
          "new_text": null,
          "old_line_content": "                assert((bitCount >> 3) <= 3); /* For first condition to work */",
          "new_line_content": "            while (charnum < n0) normalizedCounter[charnum++] = 0;",
          "content_same": false
        },
        {
          "line": 123,
          "old_api": "MEM_readLE32",
          "new_api": null,
          "old_text": "MEM_readLE32(ip)",
          "new_text": null,
          "old_line_content": "                bitStream = MEM_readLE32(ip) >> bitCount;",
          "new_line_content": "                ip += bitCount>>3;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 6,
      "total_additions": 21,
      "total_deletions": 20,
      "total_api_changes": 47
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 7,
        "api_related_lines": 47,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          161,
          162,
          163
        ]
      }
    },
    "api_calls_before": 36,
    "api_calls_after": 37,
    "diff_info": {
      "added_lines": 2,
      "removed_lines": 5,
      "total_diff_lines": 26
    }
  }
}