{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/flatbuffers/modified_file/640b525e830f84060f0d43923e4fffdb40d5676a",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/flatbuffers/modified_file/640b525e830f84060f0d43923e4fffdb40d5676a/before.h",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/flatbuffers/modified_file/640b525e830f84060f0d43923e4fffdb40d5676a/after.h",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/flatbuffers/modified_file/640b525e830f84060f0d43923e4fffdb40d5676a/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1061,
          "old_api": "PushElement",
          "new_api": "reinterpret_cast<const uint8_t *>(v)",
          "old_text": "PushElement(v[--i])",
          "new_text": "reinterpret_cast<const uint8_t *>(v)",
          "old_line_content": "      PushElement(v[--i]);",
          "new_line_content": "      PushBytes(reinterpret_cast<const uint8_t *>(v), len);",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": "EndVector",
          "new_api": "NotNested",
          "old_text": "EndVector(len)",
          "new_text": "NotNested()",
          "old_line_content": "    auto vec_end = EndVector(len);",
          "new_line_content": "    NotNested();",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": "data_at",
          "new_api": "StartVector",
          "old_text": "buf_.data_at(vec_start)",
          "new_text": "StartVector(len, elemsize)",
          "old_line_content": "    *buf = buf_.data_at(vec_start);",
          "new_line_content": "    StartVector(len, elemsize);",
          "content_same": false
        },
        {
          "line": 1266,
          "old_api": "NotNested",
          "new_api": "FlatBufferBuilder",
          "old_text": "NotNested()",
          "new_text": "FlatBufferBuilder(const FlatBufferBuilder &)",
          "old_line_content": "    NotNested();",
          "new_line_content": "  FlatBufferBuilder(const FlatBufferBuilder &);",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": "ReferTo",
          "new_api": "strlen",
          "old_text": "ReferTo(root)",
          "new_text": "strlen(file_identifier)",
          "old_line_content": "    PushElement(ReferTo(root));  // Location of root.",
          "new_line_content": "      assert(strlen(file_identifier) == kFileIdentifierLength);",
          "content_same": false
        },
        {
          "line": 1336,
          "old_api": "const_cast<void *>(buf)",
          "new_api": "reinterpret_cast<uoffset_t *>(buf)",
          "old_text": "const_cast<void *>(buf)",
          "new_text": "reinterpret_cast<uoffset_t *>(buf)",
          "old_line_content": "  return GetMutableRoot<T>(const_cast<void *>(buf));",
          "new_line_content": "    EndianScalar(*reinterpret_cast<uoffset_t *>(buf)));",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": "reinterpret_cast<const uint8_t *>(buf)",
          "new_api": "const_cast<void *>(buf)",
          "old_text": "reinterpret_cast<const uint8_t *>(buf)",
          "new_text": "const_cast<void *>(buf)",
          "old_line_content": "  return GetRoot<T>(reinterpret_cast<const uint8_t *>(buf) + sizeof(uoffset_t));",
          "new_line_content": "  return GetMutableRoot<T>(const_cast<void *>(buf));",
          "content_same": false
        },
        {
          "line": 1394,
          "old_api": "Check",
          "new_api": "reinterpret_cast<const uint8_t *>(elem)",
          "old_text": "Check(elem_len <= (size_t) (end_ - buf_) &&\n                 elem >= buf_ &&\n                 elem <= end_ - elem_len)",
          "new_text": "reinterpret_cast<const uint8_t *>(elem)",
          "old_line_content": "    return Check(elem_len <= (size_t) (end_ - buf_) &&",
          "new_line_content": "      auto upper_bound = reinterpret_cast<const uint8_t *>(elem) + elem_len;",
          "content_same": false
        },
        {
          "line": 1444,
          "old_api": "Verify",
          "new_api": "Check",
          "old_text": "Verify(vec, byte_size)",
          "new_text": "Check(size < max_elems)",
          "old_line_content": "    return Verify(vec, byte_size);",
          "new_line_content": "    if (!Check(size < max_elems))",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": "Verify<uoffset_t>(buf_)",
          "new_api": "VerifyBufferFromStart<T>(identifier, buf_)",
          "old_text": "Verify<uoffset_t>(buf_)",
          "new_text": "VerifyBufferFromStart<T>(identifier, buf_)",
          "old_line_content": "    return Verify<uoffset_t>(buf_) &&",
          "new_line_content": "    return VerifyBufferFromStart<T>(identifier, buf_);",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": "verifier.VerifyBuffer<T>(nullptr)",
          "new_api": "flatbuffers::GetRoot<T>(buf)",
          "old_text": "verifier.VerifyBuffer<T>(nullptr)",
          "new_text": "flatbuffers::GetRoot<T>(buf)",
          "old_line_content": "    return verifier.VerifyBuffer<T>(nullptr);",
          "new_line_content": "  const T *GetRoot() const { return flatbuffers::GetRoot<T>(buf); }",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": "reinterpret_cast<T>(&data_[o])",
          "new_api": "ReadScalar<T>(&data_[o])",
          "old_text": "reinterpret_cast<T>(&data_[o])",
          "new_text": "ReadScalar<T>(&data_[o])",
          "old_line_content": "    return reinterpret_cast<T>(&data_[o]);",
          "new_line_content": "    return ReadScalar<T>(&data_[o]);",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": "GetOptionalFieldOffset",
          "new_api": "ReadScalar<voffset_t>(vtable + field)",
          "old_text": "GetOptionalFieldOffset(field)",
          "new_text": "ReadScalar<voffset_t>(vtable + field)",
          "old_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "new_line_content": "    return field < vtsize ? ReadScalar<voffset_t>(vtable + field) : 0;",
          "content_same": false
        },
        {
          "line": 1604,
          "old_api": "GetOptionalFieldOffset",
          "new_api": "ReadScalar<T>(data_ + field_offset)",
          "old_text": "GetOptionalFieldOffset(field)",
          "new_text": "ReadScalar<T>(data_ + field_offset)",
          "old_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "new_line_content": "    return field_offset ? ReadScalar<T>(data_ + field_offset) : defaultval;",
          "content_same": false
        },
        {
          "line": 1611,
          "old_api": "const_cast<Table *>(this)->GetPointer<P>(field)",
          "new_api": "ReadScalar<uoffset_t>(p)",
          "old_text": "const_cast<Table *>(this)->GetPointer<P>(field)",
          "new_text": "ReadScalar<uoffset_t>(p)",
          "old_line_content": "    return const_cast<Table *>(this)->GetPointer<P>(field);",
          "new_line_content": "      ? reinterpret_cast<P>(p + ReadScalar<uoffset_t>(p))",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": "GetOptionalFieldOffset",
          "new_api": "const_cast<Table *>(this)->GetPointer<P>(field)",
          "old_text": "GetOptionalFieldOffset(field)",
          "new_text": "const_cast<Table *>(this)->GetPointer<P>(field)",
          "old_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "new_line_content": "    return const_cast<Table *>(this)->GetPointer<P>(field);",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": "GetOptionalFieldOffset",
          "new_api": "reinterpret_cast<P>(p)",
          "old_text": "GetOptionalFieldOffset(field)",
          "new_text": "reinterpret_cast<P>(p)",
          "old_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "new_line_content": "    return field_offset ? reinterpret_cast<P>(p) : nullptr;",
          "content_same": false
        },
        {
          "line": 1640,
          "old_api": "GetAddressOf",
          "new_api": "GetOptionalFieldOffset",
          "old_text": "const_cast<Table *>(this)->GetAddressOf(field)",
          "new_text": "GetOptionalFieldOffset(field)",
          "old_line_content": "    return const_cast<Table *>(this)->GetAddressOf(field);",
          "new_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "content_same": false
        },
        {
          "line": 1644,
          "old_api": "GetOptionalFieldOffset",
          "new_api": "GetAddressOf",
          "old_text": "GetOptionalFieldOffset(field)",
          "new_text": "const_cast<Table *>(this)->GetAddressOf(field)",
          "old_line_content": "    return GetOptionalFieldOffset(field) != 0;",
          "new_line_content": "    return const_cast<Table *>(this)->GetAddressOf(field);",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": "verifier.Verify<voffset_t>(vtable)",
          "new_api": "verifier.Verify<soffset_t>(data_)",
          "old_text": "verifier.Verify<voffset_t>(vtable)",
          "new_text": "verifier.Verify<soffset_t>(data_)",
          "old_line_content": "           verifier.Verify<voffset_t>(vtable) &&",
          "new_line_content": "    if (!verifier.Verify<soffset_t>(data_)) return false;",
          "content_same": false
        },
        {
          "line": 1656,
          "old_api": "ReadScalar<voffset_t>(vtable)",
          "new_api": "GetVTable",
          "old_text": "ReadScalar<voffset_t>(vtable)",
          "new_text": "GetVTable()",
          "old_line_content": "           (ReadScalar<voffset_t>(vtable) & (sizeof(voffset_t) - 1)) == 0 &&",
          "new_line_content": "    auto vtable = GetVTable();",
          "content_same": false
        },
        {
          "line": 1697,
          "old_api": "reinterpret_cast<const uint8_t *>(\n            reinterpret_cast<uintptr_t>(start) & ~(sizeof(uoffset_t) - 1))",
          "new_api": "GetVTable",
          "old_text": "reinterpret_cast<const uint8_t *>(\n            reinterpret_cast<uintptr_t>(start) & ~(sizeof(uoffset_t) - 1))",
          "new_text": "table->GetVTable()",
          "old_line_content": "  start = reinterpret_cast<const uint8_t *>(",
          "new_line_content": "  auto vtable = table->GetVTable();",
          "content_same": false
        },
        {
          "line": 1815,
          "old_api": "FLATBUFFERS_STRING",
          "new_api": "__attribute__",
          "old_text": "FLATBUFFERS_STRING(FLATBUFFERS_VERSION_MINOR)",
          "new_text": "__attribute__((weak))",
          "old_line_content": "  FLATBUFFERS_STRING(FLATBUFFERS_VERSION_MINOR) \".\"",
          "new_line_content": "extern volatile __attribute__((weak)) const char *flatbuffer_version_string;",
          "content_same": false
        },
        {
          "line": 1816,
          "old_api": "FLATBUFFERS_STRING",
          "new_api": "__attribute__",
          "old_text": "FLATBUFFERS_STRING(FLATBUFFERS_VERSION_REVISION)",
          "new_text": "__attribute__((weak))",
          "old_line_content": "  FLATBUFFERS_STRING(FLATBUFFERS_VERSION_REVISION);",
          "new_line_content": "volatile __attribute__((weak)) const char *flatbuffer_version_string =",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1547,
          "old_api": null,
          "new_api": "free",
          "old_text": null,
          "new_text": "free(buf)",
          "old_line_content": "  bool Verify() {",
          "new_line_content": "  ~BufferRef() { if (must_free) free(buf); }",
          "content_same": false
        },
        {
          "line": 1553,
          "old_api": null,
          "new_api": "verifier.VerifyBuffer<T>(nullptr)",
          "old_text": null,
          "new_text": "verifier.VerifyBuffer<T>(nullptr)",
          "old_line_content": "  uoffset_t len;",
          "new_line_content": "    return verifier.VerifyBuffer<T>(nullptr);",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": null,
          "new_api": "reinterpret_cast<T>(&data_[o])",
          "old_text": null,
          "new_text": "reinterpret_cast<T>(&data_[o])",
          "old_line_content": "  uint8_t *GetAddressOf(uoffset_t o) { return &data_[o]; }",
          "new_line_content": "    return reinterpret_cast<T>(&data_[o]);",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": null,
          "new_api": "PushElement",
          "old_text": null,
          "new_text": "PushElement(v[--i])",
          "old_line_content": "  }",
          "new_line_content": "        PushElement(v[--i]);",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": null,
          "new_api": "EndVector",
          "old_text": null,
          "new_text": "EndVector(len)",
          "old_line_content": "  /// @tparam T The data type of the `std::vector` elements.",
          "new_line_content": "    return Offset<Vector<T>>(EndVector(len));",
          "content_same": false
        },
        {
          "line": 1587,
          "old_api": null,
          "new_api": "ReadScalar<soffset_t>(data_)",
          "old_text": null,
          "new_text": "ReadScalar<soffset_t>(data_)",
          "old_line_content": "  // if the field was not present.",
          "new_line_content": "    return data_ - ReadScalar<soffset_t>(data_);",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "v.size()",
          "old_line_content": "  // an array. Instead, read elements manually.",
          "new_line_content": "    return CreateVector(data(v), v.size());",
          "content_same": false
        },
        {
          "line": 1594,
          "old_api": null,
          "new_api": "GetVTable",
          "old_text": null,
          "new_text": "GetVTable()",
          "old_line_content": "    // data, so it's the same as if the offset was 0 (not present).",
          "new_line_content": "    auto vtable = GetVTable();",
          "content_same": false
        },
        {
          "line": 1596,
          "old_api": null,
          "new_api": "ReadScalar<voffset_t>(vtable)",
          "old_text": null,
          "new_text": "ReadScalar<voffset_t>(vtable)",
          "old_line_content": "  }",
          "new_line_content": "    auto vtsize = ReadScalar<voffset_t>(vtable);",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "v.size()",
          "old_line_content": "  }",
          "new_line_content": "    for (auto i = v.size(); i > 0; ) {",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": null,
          "new_api": "static_cast<uint8_t>(v[--i])",
          "old_text": null,
          "new_text": "static_cast<uint8_t>(v[--i])",
          "old_line_content": "",
          "new_line_content": "      PushElement(static_cast<uint8_t>(v[--i]));",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "v.size()",
          "old_line_content": "  /// @brief Serialize values returned by a function into a FlatBuffer `vector`.",
          "new_line_content": "    return Offset<Vector<uint8_t>>(EndVector(v.size()));",
          "content_same": false
        },
        {
          "line": 1603,
          "old_api": null,
          "new_api": "GetOptionalFieldOffset",
          "old_text": null,
          "new_text": "GetOptionalFieldOffset(field)",
          "old_line_content": "  template<typename P> P GetPointer(voffset_t field) {",
          "new_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "content_same": false
        },
        {
          "line": 1608,
          "old_api": null,
          "new_api": "GetOptionalFieldOffset",
          "old_text": null,
          "new_text": "GetOptionalFieldOffset(field)",
          "old_line_content": "      : nullptr;",
          "new_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": null,
          "new_api": "f",
          "old_text": null,
          "new_text": "f(i)",
          "old_line_content": "",
          "new_line_content": "    for (size_t i = 0; i < vector_size; i++) elems[i] = f(i);",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": null,
          "new_api": "CreateVector",
          "old_text": null,
          "new_text": "CreateVector(elems)",
          "old_line_content": "  /// @brief Serialize a `std::vector<std::string>` into a FlatBuffer `vector`.",
          "new_line_content": "    return CreateVector(elems);",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": null,
          "new_api": "GetOptionalFieldOffset",
          "old_text": null,
          "new_text": "GetOptionalFieldOffset(field)",
          "old_line_content": "",
          "new_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": null,
          "new_api": "const_cast<uint8_t *>(data_ + field_offset)",
          "old_text": null,
          "new_text": "const_cast<uint8_t *>(data_ + field_offset)",
          "old_line_content": "  template<typename T> bool SetField(voffset_t field, T val) {",
          "new_line_content": "    auto p = const_cast<uint8_t *>(data_ + field_offset);",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": null,
          "new_api": "GetOptionalFieldOffset",
          "old_text": null,
          "new_text": "GetOptionalFieldOffset(field)",
          "old_line_content": "  }",
          "new_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "v.size()",
          "old_line_content": "",
          "new_line_content": "    std::vector<Offset<String>> offsets(v.size());",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": null,
          "new_api": "CreateString",
          "old_text": null,
          "new_text": "CreateString(v[i])",
          "old_line_content": "  /// @brief Serialize an array of structs into a FlatBuffer `vector`.",
          "new_line_content": "    for (size_t i = 0; i < v.size(); i++) offsets[i] = CreateString(v[i]);",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": null,
          "new_api": "CreateVector",
          "old_text": null,
          "new_text": "CreateVector(offsets)",
          "old_line_content": "  /// @tparam T The data type of the struct array elements.",
          "new_line_content": "    return CreateVector(offsets);",
          "content_same": false
        },
        {
          "line": 1627,
          "old_api": null,
          "new_api": "WriteScalar",
          "old_text": null,
          "new_text": "WriteScalar(data_ + field_offset, val)",
          "old_line_content": "  bool SetPointer(voffset_t field, const uint8_t *val) {",
          "new_line_content": "    WriteScalar(data_ + field_offset, val);",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": null,
          "new_api": "GetOptionalFieldOffset",
          "old_text": null,
          "new_text": "GetOptionalFieldOffset(field)",
          "old_line_content": "    return true;",
          "new_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": null,
          "new_api": "WriteScalar",
          "old_text": null,
          "new_text": "WriteScalar(data_ + field_offset,\n                static_cast<uoffset_t>(val - (data_ + field_offset)))",
          "old_line_content": "",
          "new_line_content": "    WriteScalar(data_ + field_offset,",
          "content_same": false
        },
        {
          "line": 1635,
          "old_api": null,
          "new_api": "static_cast<uoffset_t>(val - (data_ + field_offset))",
          "old_text": null,
          "new_text": "static_cast<uoffset_t>(val - (data_ + field_offset))",
          "old_line_content": "  uint8_t *GetAddressOf(voffset_t field) {",
          "new_line_content": "                static_cast<uoffset_t>(val - (data_ + field_offset)));",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": null,
          "new_api": "AlignOf<T>()",
          "old_text": null,
          "new_text": "AlignOf<T>()",
          "old_line_content": "",
          "new_line_content": "    StartVector(len * sizeof(T) / AlignOf<T>(), AlignOf<T>());",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": null,
          "new_api": "reinterpret_cast<const uint8_t *>(v)",
          "old_text": null,
          "new_text": "reinterpret_cast<const uint8_t *>(v)",
          "old_line_content": "  #ifndef FLATBUFFERS_CPP98_STL",
          "new_line_content": "    PushBytes(reinterpret_cast<const uint8_t *>(v), sizeof(T) * len);",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": null,
          "new_api": "EndVector",
          "old_text": null,
          "new_text": "EndVector(len)",
          "old_line_content": "  /// @brief Serialize an array of structs into a FlatBuffer `vector`.",
          "new_line_content": "    return Offset<Vector<const T *>>(EndVector(len));",
          "content_same": false
        },
        {
          "line": 1648,
          "old_api": null,
          "new_api": "GetOptionalFieldOffset",
          "old_text": null,
          "new_text": "GetOptionalFieldOffset(field)",
          "old_line_content": "  // Call this once per table, followed by VerifyField once per field.",
          "new_line_content": "    return GetOptionalFieldOffset(field) != 0;",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": null,
          "new_api": "AlignOf<T>()",
          "old_text": null,
          "new_text": "AlignOf<T>()",
          "old_line_content": "      structs++;",
          "new_line_content": "    StartVector(vector_size * sizeof(T) / AlignOf<T>(), AlignOf<T>());",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": null,
          "new_api": "make_space",
          "old_text": null,
          "new_text": "buf_.make_space(vector_size * sizeof(T))",
          "old_line_content": "    }",
          "new_line_content": "    T *structs = reinterpret_cast<T *>(buf_.make_space(vector_size * sizeof(T)));",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": null,
          "new_api": "VerifyComplexity",
          "old_text": null,
          "new_text": "verifier.VerifyComplexity()",
          "old_line_content": "  }",
          "new_line_content": "    return verifier.VerifyComplexity() &&",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": null,
          "new_api": "filler",
          "old_text": null,
          "new_text": "filler(i, structs)",
          "old_line_content": "  }",
          "new_line_content": "      filler(i, structs);",
          "content_same": false
        },
        {
          "line": 1659,
          "old_api": null,
          "new_api": "verifier.Verify<voffset_t>(vtable)",
          "old_text": null,
          "new_text": "verifier.Verify<voffset_t>(vtable)",
          "old_line_content": "",
          "new_line_content": "           verifier.Verify<voffset_t>(vtable) &&",
          "content_same": false
        },
        {
          "line": 1660,
          "old_api": null,
          "new_api": "ReadScalar<voffset_t>(vtable)",
          "old_text": null,
          "new_text": "ReadScalar<voffset_t>(vtable)",
          "old_line_content": "  // Verify a particular field.",
          "new_line_content": "           (ReadScalar<voffset_t>(vtable) & (sizeof(voffset_t) - 1)) == 0 &&",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": null,
          "new_api": "EndVector",
          "old_text": null,
          "new_text": "EndVector(vector_size)",
          "old_line_content": "  /// @brief Serialize a `std::vector` of structs into a FlatBuffer `vector`.",
          "new_line_content": "    return Offset<Vector<const T *>>(EndVector(vector_size));",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": null,
          "new_api": "ReadScalar<voffset_t>(vtable)",
          "old_text": null,
          "new_text": "ReadScalar<voffset_t>(vtable)",
          "old_line_content": "  template<typename T> bool VerifyField(const Verifier &verifier,",
          "new_line_content": "           verifier.Verify(vtable, ReadScalar<voffset_t>(vtable));",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": null,
          "new_api": "GetOptionalFieldOffset",
          "old_text": null,
          "new_text": "GetOptionalFieldOffset(field)",
          "old_line_content": "",
          "new_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": null,
          "new_api": "verifier.Verify<T>(data_ + field_offset)",
          "old_text": null,
          "new_text": "verifier.Verify<T>(data_ + field_offset)",
          "old_line_content": "  template<typename T> bool VerifyFieldRequired(const Verifier &verifier,",
          "new_line_content": "    return !field_offset || verifier.Verify<T>(data_ + field_offset);",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "v.size()",
          "old_line_content": "  template<typename T>",
          "new_line_content": "    return CreateVectorOfStructs(data(v), v.size());",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": null,
          "new_api": "GetOptionalFieldOffset",
          "old_text": null,
          "new_text": "GetOptionalFieldOffset(field)",
          "old_line_content": "",
          "new_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": null,
          "new_api": "Check",
          "old_text": null,
          "new_text": "verifier.Check(field_offset != 0)",
          "old_line_content": " private:",
          "new_line_content": "    return verifier.Check(field_offset != 0) &&",
          "content_same": false
        },
        {
          "line": 1679,
          "old_api": null,
          "new_api": "verifier.Verify<T>(data_ + field_offset)",
          "old_text": null,
          "new_text": "verifier.Verify<T>(data_ + field_offset)",
          "old_line_content": "  // private constructor & copy constructor: you obtain instances of this",
          "new_line_content": "           verifier.Verify<T>(data_ + field_offset);",
          "content_same": false
        },
        {
          "line": 1171,
          "old_api": null,
          "new_api": "data_at",
          "old_text": null,
          "new_text": "buf_.data_at(a.o)",
          "old_line_content": "    vector_downward& buf_;",
          "new_line_content": "      auto table_a = reinterpret_cast<T *>(buf_.data_at(a.o));",
          "content_same": false
        },
        {
          "line": 1172,
          "old_api": null,
          "new_api": "data_at",
          "old_text": null,
          "new_text": "buf_.data_at(b.o)",
          "old_line_content": "",
          "new_line_content": "      auto table_b = reinterpret_cast<T *>(buf_.data_at(b.o));",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": null,
          "new_api": "KeyCompareLessThan",
          "old_text": null,
          "new_text": "table_a->KeyCompareLessThan(table_b)",
          "old_line_content": "  private:",
          "new_line_content": "      return table_a->KeyCompareLessThan(table_b);",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": null,
          "new_api": "reinterpret_cast<const Table *>(root)",
          "old_text": null,
          "new_text": "reinterpret_cast<const Table *>(root)",
          "old_line_content": "  // Align to at least sizeof(uoffset_t).",
          "new_line_content": "  auto table = reinterpret_cast<const Table *>(root);",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": null,
          "new_api": "reinterpret_cast<const uint8_t *>(root)",
          "old_text": null,
          "new_text": "reinterpret_cast<const uint8_t *>(root)",
          "old_line_content": "  // Additionally, there may be a file_identifier in the buffer, and the root",
          "new_line_content": "  auto start = std::min(vtable, reinterpret_cast<const uint8_t *>(root));",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": null,
          "new_api": "reinterpret_cast<const uint8_t *>(\n            reinterpret_cast<uintptr_t>(start) & ~(sizeof(uoffset_t) - 1))",
          "old_text": null,
          "new_text": "reinterpret_cast<const uint8_t *>(\n            reinterpret_cast<uintptr_t>(start) & ~(sizeof(uoffset_t) - 1))",
          "old_line_content": "  // sizeof(uoffset_t) and FLATBUFFERS_MAX_ALIGNMENT (see \"force_align\").",
          "new_line_content": "  start = reinterpret_cast<const uint8_t *>(",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": null,
          "new_api": "reinterpret_cast<uintptr_t>(start)",
          "old_text": null,
          "new_text": "reinterpret_cast<uintptr_t>(start)",
          "old_line_content": "  // Sadly, the exact alignment is only known when constructing the buffer,",
          "new_line_content": "            reinterpret_cast<uintptr_t>(start) & ~(sizeof(uoffset_t) - 1));",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": null,
          "new_api": "TableKeyComparator<T>(buf_)",
          "old_text": null,
          "new_text": "TableKeyComparator<T>(buf_)",
          "old_line_content": "  /// @brief Serialize an array of `table` offsets as a `vector` in the buffer",
          "new_line_content": "    std::sort(v, v + len, TableKeyComparator<T>(buf_));",
          "content_same": false
        },
        {
          "line": 1193,
          "old_api": null,
          "new_api": "CreateVector",
          "old_text": null,
          "new_text": "CreateVector(v, len)",
          "old_line_content": "  /// in sorted order.",
          "new_line_content": "    return CreateVector(v, len);",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "v->size()",
          "old_line_content": "  /// Write the data any time later to the returned buffer pointer `buf`.",
          "new_line_content": "    return CreateVectorOfSortedTables(data(*v), v->size());",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": null,
          "new_api": "ReadScalar<uoffset_t>(start)",
          "old_text": null,
          "new_text": "ReadScalar<uoffset_t>(start)",
          "old_line_content": "  // or the buffer is corrupt.",
          "new_line_content": "      if (ReadScalar<uoffset_t>(start) + start ==",
          "content_same": false
        },
        {
          "line": 1719,
          "old_api": null,
          "new_api": "reinterpret_cast<const uint8_t *>(root)",
          "old_text": null,
          "new_text": "reinterpret_cast<const uint8_t *>(root)",
          "old_line_content": "  // Assert, because calling this function with bad data may cause reads",
          "new_line_content": "          reinterpret_cast<const uint8_t *>(root)) return start;",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(false)",
          "old_line_content": "// Base class for native objects (FlatBuffer data de-serialized into native",
          "new_line_content": "  assert(false);",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": null,
          "new_api": "make_space",
          "old_text": null,
          "new_text": "buf_.make_space(len * elemsize)",
          "old_line_content": "    return vec_end;",
          "new_line_content": "    buf_.make_space(len * elemsize);",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": null,
          "new_api": "GetSize",
          "old_text": null,
          "new_text": "GetSize()",
          "old_line_content": "  }",
          "new_line_content": "    auto vec_start = GetSize();",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": null,
          "new_api": "EndVector",
          "old_text": null,
          "new_text": "EndVector(len)",
          "old_line_content": "",
          "new_line_content": "    auto vec_end = EndVector(len);",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": null,
          "new_api": "data_at",
          "old_text": null,
          "new_text": "buf_.data_at(vec_start)",
          "old_line_content": "  /// @brief Specialized version of `CreateVector` for non-copying use cases.",
          "new_line_content": "    *buf = buf_.data_at(vec_start);",
          "content_same": false
        },
        {
          "line": 1236,
          "old_api": null,
          "new_api": "CreateUninitializedVector",
          "old_text": null,
          "new_text": "CreateUninitializedVector(len, sizeof(T),\n                                     reinterpret_cast<uint8_t **>(buf))",
          "old_line_content": "  /// @brief The length of a FlatBuffer file header.",
          "new_line_content": "    return CreateUninitializedVector(len, sizeof(T),",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": null,
          "new_api": "reinterpret_cast<uint8_t **>(buf)",
          "old_text": null,
          "new_text": "reinterpret_cast<uint8_t **>(buf)",
          "old_line_content": "  static const size_t kFileIdentifierLength = 4;",
          "new_line_content": "                                     reinterpret_cast<uint8_t **>(buf));",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": null,
          "new_api": "Finish",
          "old_text": null,
          "new_text": "Finish(root.o, file_identifier, false)",
          "old_line_content": "  /// buffer following the size field). These buffers are NOT compatible",
          "new_line_content": "    Finish(root.o, file_identifier, false);",
          "content_same": false
        },
        {
          "line": 1762,
          "old_api": null,
          "new_api": "CheckField",
          "old_text": null,
          "new_text": "reinterpret_cast<const Table *>(table)->CheckField(field)",
          "old_line_content": "// (in the generated C++ code)",
          "new_line_content": "  return reinterpret_cast<const Table *>(table)->CheckField(field);",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(*p, name)",
          "old_line_content": "",
          "new_line_content": "    if (!strcmp(*p, name))",
          "content_same": false
        },
        {
          "line": 1771,
          "old_api": null,
          "new_api": "static_cast<int>(p - names)",
          "old_text": null,
          "new_text": "static_cast<int>(p - names)",
          "old_line_content": "// These macros allow us to layout a struct with a guarantee that they'll end",
          "new_line_content": "      return static_cast<int>(p - names);",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": null,
          "new_api": "Finish",
          "old_text": null,
          "new_text": "Finish(root.o, file_identifier, true)",
          "old_line_content": "  // You shouldn't really be copying instances of this class.",
          "new_line_content": "    Finish(root.o, file_identifier, true);",
          "content_same": false
        },
        {
          "line": 1270,
          "old_api": null,
          "new_api": "NotNested",
          "old_text": null,
          "new_text": "NotNested()",
          "old_line_content": "             (file_identifier ? kFileIdentifierLength : 0),",
          "new_line_content": "    NotNested();",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": null,
          "new_api": "PreAlign",
          "old_text": null,
          "new_text": "PreAlign((size_prefix ? sizeof(uoffset_t) : 0) +\n             sizeof(uoffset_t) +\n             (file_identifier ? kFileIdentifierLength : 0),\n             minalign_)",
          "old_line_content": "    if (file_identifier) {",
          "new_line_content": "    PreAlign((size_prefix ? sizeof(uoffset_t) : 0) +",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": null,
          "new_api": "reinterpret_cast<const uint8_t *>(file_identifier)",
          "old_text": null,
          "new_text": "reinterpret_cast<const uint8_t *>(file_identifier)",
          "old_line_content": "    if (size_prefix) {",
          "new_line_content": "      PushBytes(reinterpret_cast<const uint8_t *>(file_identifier),",
          "content_same": false
        },
        {
          "line": 1281,
          "old_api": null,
          "new_api": "ReferTo",
          "old_text": null,
          "new_text": "ReferTo(root)",
          "old_line_content": "    finished = true;",
          "new_line_content": "    PushElement(ReferTo(root));  // Location of root.",
          "content_same": false
        },
        {
          "line": 1283,
          "old_api": null,
          "new_api": "GetSize",
          "old_text": null,
          "new_text": "GetSize()",
          "old_line_content": "",
          "new_line_content": "      PushElement(GetSize());",
          "content_same": false
        },
        {
          "line": 1818,
          "old_api": null,
          "new_api": "FLATBUFFERS_STRING",
          "old_text": null,
          "new_text": "FLATBUFFERS_STRING(FLATBUFFERS_VERSION_MAJOR)",
          "old_line_content": "#endif  // !defined(_WIN32) && !defined(__CYGWIN__)",
          "new_line_content": "  FLATBUFFERS_STRING(FLATBUFFERS_VERSION_MAJOR) \".\"",
          "content_same": false
        },
        {
          "line": 1819,
          "old_api": null,
          "new_api": "FLATBUFFERS_STRING",
          "old_text": null,
          "new_text": "FLATBUFFERS_STRING(FLATBUFFERS_VERSION_MINOR)",
          "old_line_content": "",
          "new_line_content": "  FLATBUFFERS_STRING(FLATBUFFERS_VERSION_MINOR) \".\"",
          "content_same": false
        },
        {
          "line": 1820,
          "old_api": null,
          "new_api": "FLATBUFFERS_STRING",
          "old_text": null,
          "new_text": "FLATBUFFERS_STRING(FLATBUFFERS_VERSION_REVISION)",
          "old_line_content": "#define DEFINE_BITMASK_OPERATORS(E, T)\\",
          "new_line_content": "  FLATBUFFERS_STRING(FLATBUFFERS_VERSION_REVISION);",
          "content_same": false
        },
        {
          "line": 1317,
          "old_api": null,
          "new_api": "data_at",
          "old_text": null,
          "new_text": "buf_->data_at(a.o)",
          "old_line_content": "    }",
          "new_line_content": "      auto stra = reinterpret_cast<const String *>(buf_->data_at(a.o));",
          "content_same": false
        },
        {
          "line": 1318,
          "old_api": null,
          "new_api": "data_at",
          "old_text": null,
          "new_text": "buf_->data_at(b.o)",
          "old_line_content": "    const vector_downward *buf_;",
          "new_line_content": "      auto strb = reinterpret_cast<const String *>(buf_->data_at(b.o));",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "strb->c_str()",
          "old_line_content": "  };",
          "new_line_content": "      return strncmp(stra->c_str(), strb->c_str(),",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "strb->size()",
          "old_line_content": "",
          "new_line_content": "                     std::min(stra->size(), strb->size()) + 1) < 0;",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": null,
          "new_api": "EndianCheck",
          "old_text": null,
          "new_text": "EndianCheck()",
          "old_line_content": "",
          "new_line_content": "  EndianCheck();",
          "content_same": false
        },
        {
          "line": 1335,
          "old_api": null,
          "new_api": "reinterpret_cast<uint8_t *>(buf)",
          "old_text": null,
          "new_text": "reinterpret_cast<uint8_t *>(buf)",
          "old_line_content": "template<typename T> const T *GetRoot(const void *buf) {",
          "new_line_content": "  return reinterpret_cast<T *>(reinterpret_cast<uint8_t *>(buf) +",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": null,
          "new_api": "reinterpret_cast<const uint8_t *>(buf)",
          "old_text": null,
          "new_text": "reinterpret_cast<const uint8_t *>(buf)",
          "old_line_content": "/// @warning Creating new objects will lead to reallocations and invalidates",
          "new_line_content": "  return GetRoot<T>(reinterpret_cast<const uint8_t *>(buf) + sizeof(uoffset_t));",
          "content_same": false
        },
        {
          "line": 1352,
          "old_api": null,
          "new_api": "GetCurrentBufferPointer",
          "old_text": null,
          "new_text": "fbb.GetCurrentBufferPointer()",
          "old_line_content": "template<typename T> const T *GetTemporaryPointer(FlatBufferBuilder &fbb,",
          "new_line_content": "  return reinterpret_cast<T *>(fbb.GetCurrentBufferPointer() +",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": null,
          "new_api": "GetSize",
          "old_text": null,
          "new_text": "fbb.GetSize()",
          "old_line_content": "                                                  Offset<T> offset) {",
          "new_line_content": "    fbb.GetSize() - offset.o);",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": null,
          "new_api": "GetMutableTemporaryPointer<T>(fbb, offset)",
          "old_text": null,
          "new_text": "GetMutableTemporaryPointer<T>(fbb, offset)",
          "old_line_content": "inline bool BufferHasIdentifier(const void *buf, const char *identifier) {",
          "new_line_content": "  return GetMutableTemporaryPointer<T>(fbb, offset);",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": null,
          "new_api": "reinterpret_cast<const char *>(buf)",
          "old_text": null,
          "new_text": "reinterpret_cast<const char *>(buf)",
          "old_line_content": "// Helper class to verify the integrity of a FlatBuffer",
          "new_line_content": "  return strncmp(reinterpret_cast<const char *>(buf) + sizeof(uoffset_t),",
          "content_same": false
        },
        {
          "line": 1372,
          "old_api": null,
          "new_api": "max_depth_",
          "old_text": null,
          "new_text": "max_depth_(_max_depth)",
          "old_line_content": "    #endif",
          "new_line_content": "    : buf_(buf), end_(buf + buf_len), depth_(0), max_depth_(_max_depth),",
          "content_same": false
        },
        {
          "line": 1373,
          "old_api": null,
          "new_api": "max_tables_",
          "old_text": null,
          "new_text": "max_tables_(_max_tables)",
          "old_line_content": "    {}",
          "new_line_content": "      num_tables_(0), max_tables_(_max_tables)",
          "content_same": false
        },
        {
          "line": 1375,
          "old_api": null,
          "new_api": "upper_bound_",
          "old_text": null,
          "new_text": "upper_bound_(buf)",
          "old_line_content": "  // Central location where any verification failures register.",
          "new_line_content": "        , upper_bound_(buf)",
          "content_same": false
        },
        {
          "line": 1382,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(ok)",
          "old_line_content": "        upper_bound_ = buf_;",
          "new_line_content": "      assert(ok);",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": null,
          "new_api": "Check",
          "old_text": null,
          "new_text": "Check(elem_len <= (size_t) (end_ - buf_) &&\n                 elem >= buf_ &&\n                 elem <= end_ - elem_len)",
          "old_line_content": "",
          "new_line_content": "    return Check(elem_len <= (size_t) (end_ - buf_) &&",
          "content_same": false
        },
        {
          "line": 1405,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "Verify(elem, sizeof(T))",
          "old_line_content": "  template<typename T> bool VerifyTable(const T *table) {",
          "new_line_content": "    return Verify(elem, sizeof(T));",
          "content_same": false
        },
        {
          "line": 1410,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "table->Verify(*this)",
          "old_line_content": "  template<typename T> bool Verify(const Vector<T> *vec) const {",
          "new_line_content": "    return !table || table->Verify(*this);",
          "content_same": false
        },
        {
          "line": 1417,
          "old_api": null,
          "new_api": "reinterpret_cast<const uint8_t *>(vec)",
          "old_text": null,
          "new_text": "reinterpret_cast<const uint8_t *>(vec)",
          "old_line_content": "  // Verify a pointer (may be NULL) of a vector to struct.",
          "new_line_content": "           VerifyVector(reinterpret_cast<const uint8_t *>(vec), sizeof(T),",
          "content_same": false
        },
        {
          "line": 1423,
          "old_api": null,
          "new_api": "reinterpret_cast<const Vector<T> *>(vec)",
          "old_text": null,
          "new_text": "reinterpret_cast<const Vector<T> *>(vec)",
          "old_line_content": "  bool Verify(const String *str) const {",
          "new_line_content": "    return Verify(reinterpret_cast<const Vector<T> *>(vec));",
          "content_same": false
        },
        {
          "line": 1430,
          "old_api": null,
          "new_api": "reinterpret_cast<const uint8_t *>(str)",
          "old_text": null,
          "new_text": "reinterpret_cast<const uint8_t *>(str)",
          "old_line_content": "",
          "new_line_content": "           (VerifyVector(reinterpret_cast<const uint8_t *>(str), 1, &end) &&",
          "content_same": false
        },
        {
          "line": 1431,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "Verify(end, 1)",
          "old_line_content": "  // Common code between vectors and strings.",
          "new_line_content": "            Verify(end, 1) &&      // Must have terminator",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": null,
          "new_api": "Check",
          "old_text": null,
          "new_text": "Check(*end == '\\0')",
          "old_line_content": "  bool VerifyVector(const uint8_t *vec, size_t elem_size,",
          "new_line_content": "            Check(*end == '\\0'));  // Terminating byte must be 0.",
          "content_same": false
        },
        {
          "line": 1439,
          "old_api": null,
          "new_api": "Verify<uoffset_t>(vec)",
          "old_text": null,
          "new_text": "Verify<uoffset_t>(vec)",
          "old_line_content": "    auto max_elems = FLATBUFFERS_MAX_BUFFER_SIZE / elem_size;",
          "new_line_content": "    if (!Verify<uoffset_t>(vec)) return false;",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": null,
          "new_api": "ReadScalar<uoffset_t>(vec)",
          "old_text": null,
          "new_text": "ReadScalar<uoffset_t>(vec)",
          "old_line_content": "    auto byte_size = sizeof(size) + elem_size * size;",
          "new_line_content": "    auto size = ReadScalar<uoffset_t>(vec);",
          "content_same": false
        },
        {
          "line": 1448,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "Verify(vec, byte_size)",
          "old_line_content": "  bool VerifyVectorOfStrings(const Vector<Offset<String>> *vec) const {",
          "new_line_content": "    return Verify(vec, byte_size);",
          "content_same": false
        },
        {
          "line": 1454,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vec->size()",
          "old_line_content": "      return true;",
          "new_line_content": "        for (uoffset_t i = 0; i < vec->size(); i++) {",
          "content_same": false
        },
        {
          "line": 1455,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "vec->Get(i)",
          "old_line_content": "  }",
          "new_line_content": "          if (!Verify(vec->Get(i))) return false;",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vec->size()",
          "old_line_content": "    return true;",
          "new_line_content": "      for (uoffset_t i = 0; i < vec->size(); i++) {",
          "content_same": false
        },
        {
          "line": 1465,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "vec->Get(i)->Verify(*this)",
          "old_line_content": "  }",
          "new_line_content": "        if (!vec->Get(i)->Verify(*this)) return false;",
          "content_same": false
        },
        {
          "line": 1475,
          "old_api": null,
          "new_api": "BufferHasIdentifier",
          "old_text": null,
          "new_text": "BufferHasIdentifier(start, identifier)",
          "old_line_content": "    // Call T::Verify, which must be in the generated code for this type.",
          "new_line_content": "         !BufferHasIdentifier(start, identifier))) {",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": null,
          "new_api": "Verify<uoffset_t>(start)",
          "old_text": null,
          "new_text": "Verify<uoffset_t>(start)",
          "old_line_content": "          && GetComputedSize()",
          "new_line_content": "    return Verify<uoffset_t>(start) &&",
          "content_same": false
        },
        {
          "line": 1481,
          "old_api": null,
          "new_api": "ReadScalar<uoffset_t>(start)",
          "old_text": null,
          "new_text": "ReadScalar<uoffset_t>(start)",
          "old_line_content": "        #endif",
          "new_line_content": "      reinterpret_cast<const T *>(start + ReadScalar<uoffset_t>(start))->",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": null,
          "new_api": "Verify<uoffset_t>(buf_)",
          "old_text": null,
          "new_text": "Verify<uoffset_t>(buf_)",
          "old_line_content": "",
          "new_line_content": "    return Verify<uoffset_t>(buf_) &&",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": null,
          "new_api": "ReadScalar<uoffset_t>(buf_)",
          "old_text": null,
          "new_text": "ReadScalar<uoffset_t>(buf_)",
          "old_line_content": "  // Called at the start of a table to increase counters measuring data",
          "new_line_content": "           ReadScalar<uoffset_t>(buf_) == end_ - buf_ - sizeof(uoffset_t) &&",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": null,
          "new_api": "VerifyBufferFromStart<T>(identifier, buf_ + sizeof(uoffset_t))",
          "old_text": null,
          "new_text": "VerifyBufferFromStart<T>(identifier, buf_ + sizeof(uoffset_t))",
          "old_line_content": "  // structure depth and amount, and possibly bails out with false if",
          "new_line_content": "           VerifyBufferFromStart<T>(identifier, buf_ + sizeof(uoffset_t));",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": null,
          "new_api": "Check",
          "old_text": null,
          "new_text": "Check(depth_ <= max_depth_ && num_tables_ <= max_tables_)",
          "old_line_content": "  bool EndTable() {",
          "new_line_content": "    return Check(depth_ <= max_depth_ && num_tables_ <= max_tables_);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1543,
          "old_api": "free",
          "new_api": null,
          "old_text": "free(buf)",
          "new_text": null,
          "old_line_content": "  ~BufferRef() { if (must_free) free(buf); }",
          "new_line_content": "  BufferRef() : buf(nullptr), len(0), must_free(false) {}",
          "content_same": false
        },
        {
          "line": 1545,
          "old_api": "flatbuffers::GetRoot<T>(buf)",
          "new_api": null,
          "old_text": "flatbuffers::GetRoot<T>(buf)",
          "new_text": null,
          "old_line_content": "  const T *GetRoot() const { return flatbuffers::GetRoot<T>(buf); }",
          "new_line_content": "    : buf(_buf), len(_len), must_free(false) {}",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": "ReadScalar<T>(&data_[o])",
          "new_api": null,
          "old_text": "ReadScalar<T>(&data_[o])",
          "new_text": null,
          "old_line_content": "    return ReadScalar<T>(&data_[o]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "EndVector",
          "new_api": null,
          "old_text": "EndVector(len)",
          "new_text": null,
          "old_line_content": "    return Offset<Vector<T>>(EndVector(len));",
          "new_line_content": "      for (auto i = len; i > 0; ) {",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": "ReadScalar<soffset_t>(data_)",
          "new_api": null,
          "old_text": "ReadScalar<soffset_t>(data_)",
          "new_text": null,
          "old_line_content": "    return data_ - ReadScalar<soffset_t>(data_);",
          "new_line_content": "// omitted and added at will, but uses an extra indirection to read.",
          "content_same": false
        },
        {
          "line": 1073,
          "old_api": "size",
          "new_api": null,
          "old_text": "v.size()",
          "new_text": null,
          "old_line_content": "    return CreateVector(data(v), v.size());",
          "new_line_content": "  /// buffer as a `vector`.",
          "content_same": false
        },
        {
          "line": 1590,
          "old_api": "GetVTable",
          "new_api": null,
          "old_text": "GetVTable()",
          "new_text": null,
          "old_line_content": "    auto vtable = GetVTable();",
          "new_line_content": "  // This gets the field offset for any of the functions below it, or 0",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "size",
          "new_api": null,
          "old_text": "v.size()",
          "new_text": null,
          "old_line_content": "    StartVector(v.size(), sizeof(uint8_t));",
          "new_line_content": "  // vector<bool> may be implemented using a bit-set, so we can't access it as",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "size",
          "new_api": null,
          "old_text": "v.size()",
          "new_text": null,
          "old_line_content": "    for (auto i = v.size(); i > 0; ) {",
          "new_line_content": "  // an array. Instead, read elements manually.",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "static_cast<uint8_t>(v[--i])",
          "new_api": null,
          "old_text": "static_cast<uint8_t>(v[--i])",
          "new_text": null,
          "old_line_content": "      PushElement(static_cast<uint8_t>(v[--i]));",
          "new_line_content": "  // Background: https://isocpp.org/blog/2012/11/on-vectorbool",
          "content_same": false
        },
        {
          "line": 1592,
          "old_api": "ReadScalar<voffset_t>(vtable)",
          "new_api": null,
          "old_text": "ReadScalar<voffset_t>(vtable)",
          "new_text": null,
          "old_line_content": "    auto vtsize = ReadScalar<voffset_t>(vtable);",
          "new_line_content": "  voffset_t GetOptionalFieldOffset(voffset_t field) const {",
          "content_same": false
        },
        {
          "line": 1595,
          "old_api": "ReadScalar<voffset_t>(vtable + field)",
          "new_api": null,
          "old_text": "ReadScalar<voffset_t>(vtable + field)",
          "new_text": null,
          "old_line_content": "    return field < vtsize ? ReadScalar<voffset_t>(vtable + field) : 0;",
          "new_line_content": "    // The first element is the size of the vtable (fields + type id + itself).",
          "content_same": false
        },
        {
          "line": 1600,
          "old_api": "ReadScalar<T>(data_ + field_offset)",
          "new_api": null,
          "old_text": "ReadScalar<T>(data_ + field_offset)",
          "new_text": null,
          "old_line_content": "    return field_offset ? ReadScalar<T>(data_ + field_offset) : defaultval;",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": "ReadScalar<uoffset_t>(p)",
          "new_api": null,
          "old_text": "ReadScalar<uoffset_t>(p)",
          "new_text": null,
          "old_line_content": "      ? reinterpret_cast<P>(p + ReadScalar<uoffset_t>(p))",
          "new_line_content": "  template<typename P> P GetPointer(voffset_t field) {",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": "f",
          "new_api": null,
          "old_text": "f(i)",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < vector_size; i++) elems[i] = f(i);",
          "new_line_content": "  /// where the vector is stored.",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": "CreateVector",
          "new_api": null,
          "old_text": "CreateVector(elems)",
          "new_text": null,
          "old_line_content": "    return CreateVector(elems);",
          "new_line_content": "  template<typename T> Offset<Vector<T>> CreateVector(size_t vector_size,",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": "const_cast<uint8_t *>(data_ + field_offset)",
          "new_api": null,
          "old_text": "const_cast<uint8_t *>(data_ + field_offset)",
          "new_text": null,
          "old_line_content": "    auto p = const_cast<uint8_t *>(data_ + field_offset);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1617,
          "old_api": "reinterpret_cast<P>(p)",
          "new_api": null,
          "old_text": "reinterpret_cast<P>(p)",
          "new_text": null,
          "old_line_content": "    return field_offset ? reinterpret_cast<P>(p) : nullptr;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": "size",
          "new_api": null,
          "old_text": "v.size()",
          "new_text": null,
          "old_line_content": "    std::vector<Offset<String>> offsets(v.size());",
          "new_line_content": "  /// @return Returns a typed `Offset` into the serialized data indicating",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": "CreateString",
          "new_api": null,
          "old_text": "CreateString(v[i])",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < v.size(); i++) offsets[i] = CreateString(v[i]);",
          "new_line_content": "  /// where the vector is stored.",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": "CreateVector",
          "new_api": null,
          "old_text": "CreateVector(offsets)",
          "new_text": null,
          "old_line_content": "    return CreateVector(offsets);",
          "new_line_content": "  Offset<Vector<Offset<String>>> CreateVectorOfStrings(",
          "content_same": false
        },
        {
          "line": 1623,
          "old_api": "WriteScalar",
          "new_api": null,
          "old_text": "WriteScalar(data_ + field_offset, val)",
          "new_text": null,
          "old_line_content": "    WriteScalar(data_ + field_offset, val);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1628,
          "old_api": "GetOptionalFieldOffset",
          "new_api": null,
          "old_text": "GetOptionalFieldOffset(field)",
          "new_text": null,
          "old_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 1630,
          "old_api": "WriteScalar",
          "new_api": null,
          "old_text": "WriteScalar(data_ + field_offset,\n                static_cast<uoffset_t>(val - (data_ + field_offset)))",
          "new_text": null,
          "old_line_content": "    WriteScalar(data_ + field_offset,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1631,
          "old_api": "static_cast<uoffset_t>(val - (data_ + field_offset))",
          "new_api": null,
          "old_text": "static_cast<uoffset_t>(val - (data_ + field_offset))",
          "new_text": null,
          "old_line_content": "                static_cast<uoffset_t>(val - (data_ + field_offset)));",
          "new_line_content": "  bool SetPointer(voffset_t field, const uint8_t *val) {",
          "content_same": false
        },
        {
          "line": 1636,
          "old_api": "GetOptionalFieldOffset",
          "new_api": null,
          "old_text": "GetOptionalFieldOffset(field)",
          "new_text": null,
          "old_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": "AlignOf<T>()",
          "new_api": null,
          "old_text": "AlignOf<T>()",
          "new_text": null,
          "old_line_content": "    StartVector(len * sizeof(T) / AlignOf<T>(), AlignOf<T>());",
          "new_line_content": "  /// @return Returns a typed `Offset` into the serialized data indicating",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": "reinterpret_cast<const uint8_t *>(v)",
          "new_api": null,
          "old_text": "reinterpret_cast<const uint8_t *>(v)",
          "new_text": null,
          "old_line_content": "    PushBytes(reinterpret_cast<const uint8_t *>(v), sizeof(T) * len);",
          "new_line_content": "  /// where the vector is stored.",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": "EndVector",
          "new_api": null,
          "old_text": "EndVector(len)",
          "new_text": null,
          "old_line_content": "    return Offset<Vector<const T *>>(EndVector(len));",
          "new_line_content": "  template<typename T> Offset<Vector<const T *>> CreateVectorOfStructs(",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": "verifier.Verify<soffset_t>(data_)",
          "new_api": null,
          "old_text": "verifier.Verify<soffset_t>(data_)",
          "new_text": null,
          "old_line_content": "    if (!verifier.Verify<soffset_t>(data_)) return false;",
          "new_line_content": "  // Verify the vtable of this table.",
          "content_same": false
        },
        {
          "line": 1652,
          "old_api": "GetVTable",
          "new_api": null,
          "old_text": "GetVTable()",
          "new_text": null,
          "old_line_content": "    auto vtable = GetVTable();",
          "new_line_content": "  // Call this once per table, followed by VerifyField once per field.",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "AlignOf<T>()",
          "new_api": null,
          "old_text": "AlignOf<T>()",
          "new_text": null,
          "old_line_content": "    StartVector(vector_size * sizeof(T) / AlignOf<T>(), AlignOf<T>());",
          "new_line_content": "  /// This is mostly useful when flatbuffers are generated with mutation",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": "make_space",
          "new_api": null,
          "old_text": "buf_.make_space(vector_size * sizeof(T))",
          "new_text": null,
          "old_line_content": "    T *structs = reinterpret_cast<T *>(buf_.make_space(vector_size * sizeof(T)));",
          "new_line_content": "  /// accessors.",
          "content_same": false
        },
        {
          "line": 1654,
          "old_api": "VerifyComplexity",
          "new_api": null,
          "old_text": "verifier.VerifyComplexity()",
          "new_text": null,
          "old_line_content": "    return verifier.VerifyComplexity() &&",
          "new_line_content": "    // Check the vtable offset.",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": "filler",
          "new_api": null,
          "old_text": "filler(i, structs)",
          "new_text": null,
          "old_line_content": "      filler(i, structs);",
          "new_line_content": "      size_t vector_size, const std::function<void(size_t i, T *)> &filler) {",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": "ReadScalar<voffset_t>(vtable)",
          "new_api": null,
          "old_text": "ReadScalar<voffset_t>(vtable)",
          "new_text": null,
          "old_line_content": "           verifier.Verify(vtable, ReadScalar<voffset_t>(vtable));",
          "new_line_content": "    // Check the vtable size field, then check vtable fits in its entirety.",
          "content_same": false
        },
        {
          "line": 1147,
          "old_api": "EndVector",
          "new_api": null,
          "old_text": "EndVector(vector_size)",
          "new_text": null,
          "old_line_content": "    return Offset<Vector<const T *>>(EndVector(vector_size));",
          "new_line_content": "    for (size_t i = 0; i < vector_size; i++) {",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": "GetOptionalFieldOffset",
          "new_api": null,
          "old_text": "GetOptionalFieldOffset(field)",
          "new_text": null,
          "old_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "new_line_content": "  template<typename T> bool VerifyField(const Verifier &verifier,",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": "verifier.Verify<T>(data_ + field_offset)",
          "new_api": null,
          "old_text": "verifier.Verify<T>(data_ + field_offset)",
          "new_text": null,
          "old_line_content": "    return !field_offset || verifier.Verify<T>(data_ + field_offset);",
          "new_line_content": "    // Calling GetOptionalFieldOffset should be safe now thanks to",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "size",
          "new_api": null,
          "old_text": "v.size()",
          "new_text": null,
          "old_line_content": "    return CreateVectorOfStructs(data(v), v.size());",
          "new_line_content": "  /// @return Returns a typed `Offset` into the serialized data indicating",
          "content_same": false
        },
        {
          "line": 1673,
          "old_api": "GetOptionalFieldOffset",
          "new_api": null,
          "old_text": "GetOptionalFieldOffset(field)",
          "new_text": null,
          "old_line_content": "    auto field_offset = GetOptionalFieldOffset(field);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": "Check",
          "new_api": null,
          "old_text": "verifier.Check(field_offset != 0)",
          "new_text": null,
          "old_line_content": "    return verifier.Check(field_offset != 0) &&",
          "new_line_content": "  // VerifyField for required fields.",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": "verifier.Verify<T>(data_ + field_offset)",
          "new_api": null,
          "old_text": "verifier.Verify<T>(data_ + field_offset)",
          "new_text": null,
          "old_line_content": "           verifier.Verify<T>(data_ + field_offset);",
          "new_line_content": "  template<typename T> bool VerifyFieldRequired(const Verifier &verifier,",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": "data_at",
          "new_api": null,
          "old_text": "buf_.data_at(a.o)",
          "new_text": null,
          "old_line_content": "      auto table_a = reinterpret_cast<T *>(buf_.data_at(a.o));",
          "new_line_content": "  template<typename T>",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": "data_at",
          "new_api": null,
          "old_text": "buf_.data_at(b.o)",
          "new_text": null,
          "old_line_content": "      auto table_b = reinterpret_cast<T *>(buf_.data_at(b.o));",
          "new_line_content": "  struct TableKeyComparator {",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": "KeyCompareLessThan",
          "new_api": null,
          "old_text": "table_a->KeyCompareLessThan(table_b)",
          "new_text": null,
          "old_line_content": "      return table_a->KeyCompareLessThan(table_b);",
          "new_line_content": "  TableKeyComparator(vector_downward& buf) : buf_(buf) {}",
          "content_same": false
        },
        {
          "line": 1692,
          "old_api": "reinterpret_cast<const Table *>(root)",
          "new_api": null,
          "old_text": "reinterpret_cast<const Table *>(root)",
          "new_text": null,
          "old_line_content": "  auto table = reinterpret_cast<const Table *>(root);",
          "new_line_content": "/// it is the opposite transformation of GetRoot().",
          "content_same": false
        },
        {
          "line": 1693,
          "old_api": "GetVTable",
          "new_api": null,
          "old_text": "table->GetVTable()",
          "new_text": null,
          "old_line_content": "  auto vtable = table->GetVTable();",
          "new_line_content": "/// This may be useful if you want to pass on a root and have the recipient",
          "content_same": false
        },
        {
          "line": 1695,
          "old_api": "reinterpret_cast<const uint8_t *>(root)",
          "new_api": null,
          "old_text": "reinterpret_cast<const uint8_t *>(root)",
          "new_text": null,
          "old_line_content": "  auto start = std::min(vtable, reinterpret_cast<const uint8_t *>(root));",
          "new_line_content": "inline const uint8_t *GetBufferStartFromRootPointer(const void *root) {",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": "reinterpret_cast<uintptr_t>(start)",
          "new_api": null,
          "old_text": "reinterpret_cast<uintptr_t>(start)",
          "new_text": null,
          "old_line_content": "            reinterpret_cast<uintptr_t>(start) & ~(sizeof(uoffset_t) - 1));",
          "new_line_content": "  // Either the vtable is before the root or after the root.",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": "TableKeyComparator<T>(buf_)",
          "new_api": null,
          "old_text": "TableKeyComparator<T>(buf_)",
          "new_text": null,
          "old_line_content": "    std::sort(v, v + len, TableKeyComparator<T>(buf_));",
          "new_line_content": "  /// @return Returns a typed `Offset` into the serialized data indicating",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": "CreateVector",
          "new_api": null,
          "old_text": "CreateVector(v, len)",
          "new_text": null,
          "old_line_content": "    return CreateVector(v, len);",
          "new_line_content": "  /// where the vector is stored.",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": "size",
          "new_api": null,
          "old_text": "v->size()",
          "new_text": null,
          "old_line_content": "    return CreateVectorOfSortedTables(data(*v), v->size());",
          "new_line_content": "  /// @return Returns a typed `Offset` into the serialized data indicating",
          "content_same": false
        },
        {
          "line": 1714,
          "old_api": "ReadScalar<uoffset_t>(start)",
          "new_api": null,
          "old_text": "ReadScalar<uoffset_t>(start)",
          "new_text": null,
          "old_line_content": "      if (ReadScalar<uoffset_t>(start) + start ==",
          "new_line_content": "  for (auto possible_roots = FLATBUFFERS_MAX_ALIGNMENT / sizeof(uoffset_t) + 1;",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": "reinterpret_cast<const uint8_t *>(root)",
          "new_api": null,
          "old_text": "reinterpret_cast<const uint8_t *>(root)",
          "new_text": null,
          "old_line_content": "          reinterpret_cast<const uint8_t *>(root)) return start;",
          "new_line_content": "       possible_roots;",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(false)",
          "new_text": null,
          "old_line_content": "  assert(false);",
          "new_line_content": "  // We didn't find the root, either the \"root\" passed isn't really a root,",
          "content_same": false
        },
        {
          "line": 1213,
          "old_api": "NotNested",
          "new_api": null,
          "old_text": "NotNested()",
          "new_text": null,
          "old_line_content": "    NotNested();",
          "new_line_content": "  /// written to at a later time to serialize the data into a `vector`",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": "StartVector",
          "new_api": null,
          "old_text": "StartVector(len, elemsize)",
          "new_text": null,
          "old_line_content": "    StartVector(len, elemsize);",
          "new_line_content": "  /// in the buffer.",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": "make_space",
          "new_api": null,
          "old_text": "buf_.make_space(len * elemsize)",
          "new_text": null,
          "old_line_content": "    buf_.make_space(len * elemsize);",
          "new_line_content": "  uoffset_t CreateUninitializedVector(size_t len, size_t elemsize,",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": "GetSize",
          "new_api": null,
          "old_text": "GetSize()",
          "new_text": null,
          "old_line_content": "    auto vec_start = GetSize();",
          "new_line_content": "                                      uint8_t **buf) {",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": "CreateUninitializedVector",
          "new_api": null,
          "old_text": "CreateUninitializedVector(len, sizeof(T),\n                                     reinterpret_cast<uint8_t **>(buf))",
          "new_text": null,
          "old_line_content": "    return CreateUninitializedVector(len, sizeof(T),",
          "new_line_content": "  /// written to at a later time to serialize the data into a `vector`",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": "reinterpret_cast<uint8_t **>(buf)",
          "new_api": null,
          "old_text": "reinterpret_cast<uint8_t **>(buf)",
          "new_text": null,
          "old_line_content": "                                     reinterpret_cast<uint8_t **>(buf));",
          "new_line_content": "  /// in the buffer.",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "Finish",
          "new_api": null,
          "old_text": "Finish(root.o, file_identifier, false)",
          "new_text": null,
          "old_line_content": "    Finish(root.o, file_identifier, false);",
          "new_line_content": "  /// will be prefixed with a standard FlatBuffers file header.",
          "content_same": false
        },
        {
          "line": 1758,
          "old_api": "CheckField",
          "new_api": null,
          "old_text": "reinterpret_cast<const Table *>(table)->CheckField(field)",
          "new_text": null,
          "old_line_content": "  return reinterpret_cast<const Table *>(table)->CheckField(field);",
          "new_line_content": "// value, since they're not stored in the buffer (unless force_defaults was",
          "content_same": false
        },
        {
          "line": 1766,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(*p, name)",
          "new_text": null,
          "old_line_content": "    if (!strcmp(*p, name))",
          "new_line_content": "// (in the generated C++ code)",
          "content_same": false
        },
        {
          "line": 1767,
          "old_api": "static_cast<int>(p - names)",
          "new_api": null,
          "old_text": "static_cast<int>(p - names)",
          "new_text": null,
          "old_line_content": "      return static_cast<int>(p - names);",
          "new_line_content": "// names must be NULL terminated.",
          "content_same": false
        },
        {
          "line": 1257,
          "old_api": "Finish",
          "new_api": null,
          "old_text": "Finish(root.o, file_identifier, true)",
          "new_text": null,
          "old_line_content": "    Finish(root.o, file_identifier, true);",
          "new_line_content": "  /// size pre-fixed buffer is aligned.",
          "content_same": false
        },
        {
          "line": 1262,
          "old_api": "FlatBufferBuilder",
          "new_api": null,
          "old_text": "FlatBufferBuilder(const FlatBufferBuilder &)",
          "new_text": null,
          "old_line_content": "  FlatBufferBuilder(const FlatBufferBuilder &);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1268,
          "old_api": "PreAlign",
          "new_api": null,
          "old_text": "PreAlign((size_prefix ? sizeof(uoffset_t) : 0) +\n             sizeof(uoffset_t) +\n             (file_identifier ? kFileIdentifierLength : 0),\n             minalign_)",
          "new_text": null,
          "old_line_content": "    PreAlign((size_prefix ? sizeof(uoffset_t) : 0) +",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1273,
          "old_api": "strlen",
          "new_api": null,
          "old_text": "strlen(file_identifier)",
          "new_text": null,
          "old_line_content": "      assert(strlen(file_identifier) == kFileIdentifierLength);",
          "new_line_content": "             sizeof(uoffset_t) +",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": "reinterpret_cast<const uint8_t *>(file_identifier)",
          "new_api": null,
          "old_text": "reinterpret_cast<const uint8_t *>(file_identifier)",
          "new_text": null,
          "old_line_content": "      PushBytes(reinterpret_cast<const uint8_t *>(file_identifier),",
          "new_line_content": "             (file_identifier ? kFileIdentifierLength : 0),",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": "GetSize",
          "new_api": null,
          "old_text": "GetSize()",
          "new_text": null,
          "old_line_content": "      PushElement(GetSize());",
          "new_line_content": "                kFileIdentifierLength);",
          "content_same": false
        },
        {
          "line": 1811,
          "old_api": "__attribute__",
          "new_api": null,
          "old_text": "__attribute__((weak))",
          "new_text": null,
          "old_line_content": "extern volatile __attribute__((weak)) const char *flatbuffer_version_string;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1812,
          "old_api": "__attribute__",
          "new_api": null,
          "old_text": "__attribute__((weak))",
          "new_text": null,
          "old_line_content": "volatile __attribute__((weak)) const char *flatbuffer_version_string =",
          "new_line_content": "// Weak linkage is culled by VS & doesn't work on cygwin.",
          "content_same": false
        },
        {
          "line": 1814,
          "old_api": "FLATBUFFERS_STRING",
          "new_api": null,
          "old_text": "FLATBUFFERS_STRING(FLATBUFFERS_VERSION_MAJOR)",
          "new_text": null,
          "old_line_content": "  FLATBUFFERS_STRING(FLATBUFFERS_VERSION_MAJOR) \".\"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": "data_at",
          "new_api": null,
          "old_text": "buf_->data_at(a.o)",
          "new_text": null,
          "old_line_content": "      auto stra = reinterpret_cast<const String *>(buf_->data_at(a.o));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": "data_at",
          "new_api": null,
          "old_text": "buf_->data_at(b.o)",
          "new_text": null,
          "old_line_content": "      auto strb = reinterpret_cast<const String *>(buf_->data_at(b.o));",
          "new_line_content": "  struct StringOffsetCompare {",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "strb->c_str()",
          "new_text": null,
          "old_line_content": "      return strncmp(stra->c_str(), strb->c_str(),",
          "new_line_content": "    StringOffsetCompare(const vector_downward &buf) : buf_(&buf) {}",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": "size",
          "new_api": null,
          "old_text": "strb->size()",
          "new_text": null,
          "old_line_content": "                     std::min(stra->size(), strb->size()) + 1) < 0;",
          "new_line_content": "    bool operator() (const Offset<String> &a, const Offset<String> &b) const {",
          "content_same": false
        },
        {
          "line": 1330,
          "old_api": "EndianCheck",
          "new_api": null,
          "old_text": "EndianCheck()",
          "new_text": null,
          "old_line_content": "  EndianCheck();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1331,
          "old_api": "reinterpret_cast<uint8_t *>(buf)",
          "new_api": null,
          "old_text": "reinterpret_cast<uint8_t *>(buf)",
          "new_text": null,
          "old_line_content": "  return reinterpret_cast<T *>(reinterpret_cast<uint8_t *>(buf) +",
          "new_line_content": "/// @cond FLATBUFFERS_INTERNAL",
          "content_same": false
        },
        {
          "line": 1332,
          "old_api": "reinterpret_cast<uoffset_t *>(buf)",
          "new_api": null,
          "old_text": "reinterpret_cast<uoffset_t *>(buf)",
          "new_text": null,
          "old_line_content": "    EndianScalar(*reinterpret_cast<uoffset_t *>(buf)));",
          "new_line_content": "// Helpers to get a typed pointer to the root object contained in the buffer.",
          "content_same": false
        },
        {
          "line": 1348,
          "old_api": "GetCurrentBufferPointer",
          "new_api": null,
          "old_text": "fbb.GetCurrentBufferPointer()",
          "new_text": null,
          "old_line_content": "  return reinterpret_cast<T *>(fbb.GetCurrentBufferPointer() +",
          "new_line_content": "/// @warning Creating new objects will lead to reallocations and invalidates",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": "GetSize",
          "new_api": null,
          "old_text": "fbb.GetSize()",
          "new_text": null,
          "old_line_content": "    fbb.GetSize() - offset.o);",
          "new_line_content": "/// the pointer!",
          "content_same": false
        },
        {
          "line": 1354,
          "old_api": "GetMutableTemporaryPointer<T>(fbb, offset)",
          "new_api": null,
          "old_text": "GetMutableTemporaryPointer<T>(fbb, offset)",
          "new_text": null,
          "old_line_content": "  return GetMutableTemporaryPointer<T>(fbb, offset);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1359,
          "old_api": "reinterpret_cast<const char *>(buf)",
          "new_api": null,
          "old_text": "reinterpret_cast<const char *>(buf)",
          "new_text": null,
          "old_line_content": "  return strncmp(reinterpret_cast<const char *>(buf) + sizeof(uoffset_t),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": "max_depth_",
          "new_api": null,
          "old_text": "max_depth_(_max_depth)",
          "new_text": null,
          "old_line_content": "    : buf_(buf), end_(buf + buf_len), depth_(0), max_depth_(_max_depth),",
          "new_line_content": "class Verifier FLATBUFFERS_FINAL_CLASS {",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": "max_tables_",
          "new_api": null,
          "old_text": "max_tables_(_max_tables)",
          "new_text": null,
          "old_line_content": "      num_tables_(0), max_tables_(_max_tables)",
          "new_line_content": " public:",
          "content_same": false
        },
        {
          "line": 1371,
          "old_api": "upper_bound_",
          "new_api": null,
          "old_text": "upper_bound_(buf)",
          "new_text": null,
          "old_line_content": "        , upper_bound_(buf)",
          "new_line_content": "           size_t _max_tables = 1000000)",
          "content_same": false
        },
        {
          "line": 1378,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(ok)",
          "new_text": null,
          "old_line_content": "      assert(ok);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": "reinterpret_cast<const uint8_t *>(elem)",
          "new_api": null,
          "old_text": "reinterpret_cast<const uint8_t *>(elem)",
          "new_text": null,
          "old_line_content": "      auto upper_bound = reinterpret_cast<const uint8_t *>(elem) + elem_len;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1401,
          "old_api": "Verify",
          "new_api": null,
          "old_text": "Verify(elem, sizeof(T))",
          "new_text": null,
          "old_line_content": "    return Verify(elem, sizeof(T));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1406,
          "old_api": "Verify",
          "new_api": null,
          "old_text": "table->Verify(*this)",
          "new_text": null,
          "old_line_content": "    return !table || table->Verify(*this);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": "reinterpret_cast<const uint8_t *>(vec)",
          "new_api": null,
          "old_text": "reinterpret_cast<const uint8_t *>(vec)",
          "new_text": null,
          "old_line_content": "           VerifyVector(reinterpret_cast<const uint8_t *>(vec), sizeof(T),",
          "new_line_content": "  // Verify a pointer (may be NULL) of any vector type.",
          "content_same": false
        },
        {
          "line": 1419,
          "old_api": "reinterpret_cast<const Vector<T> *>(vec)",
          "new_api": null,
          "old_text": "reinterpret_cast<const Vector<T> *>(vec)",
          "new_text": null,
          "old_line_content": "    return Verify(reinterpret_cast<const Vector<T> *>(vec));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1426,
          "old_api": "reinterpret_cast<const uint8_t *>(str)",
          "new_api": null,
          "old_text": "reinterpret_cast<const uint8_t *>(str)",
          "new_text": null,
          "old_line_content": "           (VerifyVector(reinterpret_cast<const uint8_t *>(str), 1, &end) &&",
          "new_line_content": "  // Verify a pointer (may be NULL) to string.",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": "Verify",
          "new_api": null,
          "old_text": "Verify(end, 1)",
          "new_text": null,
          "old_line_content": "            Verify(end, 1) &&      // Must have terminator",
          "new_line_content": "  bool Verify(const String *str) const {",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": "Check",
          "new_api": null,
          "old_text": "Check(*end == '\\0')",
          "new_text": null,
          "old_line_content": "            Check(*end == '\\0'));  // Terminating byte must be 0.",
          "new_line_content": "    const uint8_t *end;",
          "content_same": false
        },
        {
          "line": 1435,
          "old_api": "Verify<uoffset_t>(vec)",
          "new_api": null,
          "old_text": "Verify<uoffset_t>(vec)",
          "new_text": null,
          "old_line_content": "    if (!Verify<uoffset_t>(vec)) return false;",
          "new_line_content": "  // Common code between vectors and strings.",
          "content_same": false
        },
        {
          "line": 1438,
          "old_api": "ReadScalar<uoffset_t>(vec)",
          "new_api": null,
          "old_text": "ReadScalar<uoffset_t>(vec)",
          "new_text": null,
          "old_line_content": "    auto size = ReadScalar<uoffset_t>(vec);",
          "new_line_content": "    // Check we can read the size field.",
          "content_same": false
        },
        {
          "line": 1440,
          "old_api": "Check",
          "new_api": null,
          "old_text": "Check(size < max_elems)",
          "new_text": null,
          "old_line_content": "    if (!Check(size < max_elems))",
          "new_line_content": "    // Check the whole array. If this is a string, the byte past the array",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": "size",
          "new_api": null,
          "old_text": "vec->size()",
          "new_text": null,
          "old_line_content": "        for (uoffset_t i = 0; i < vec->size(); i++) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1451,
          "old_api": "Get",
          "new_api": null,
          "old_text": "vec->Get(i)",
          "new_text": null,
          "old_line_content": "          if (!Verify(vec->Get(i))) return false;",
          "new_line_content": "  // Special case for string contents, after the above has been called.",
          "content_same": false
        },
        {
          "line": 1460,
          "old_api": "size",
          "new_api": null,
          "old_text": "vec->size()",
          "new_text": null,
          "old_line_content": "      for (uoffset_t i = 0; i < vec->size(); i++) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": "Get",
          "new_api": null,
          "old_text": "vec->Get(i)->Verify(*this)",
          "new_text": null,
          "old_line_content": "        if (!vec->Get(i)->Verify(*this)) return false;",
          "new_line_content": "  // Special case for table contents, after the above has been called.",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": "BufferHasIdentifier",
          "new_api": null,
          "old_text": "BufferHasIdentifier(start, identifier)",
          "new_text": null,
          "old_line_content": "         !BufferHasIdentifier(start, identifier))) {",
          "new_line_content": "  template<typename T> bool VerifyBufferFromStart(const char *identifier,",
          "content_same": false
        },
        {
          "line": 1476,
          "old_api": "Verify<uoffset_t>(start)",
          "new_api": null,
          "old_text": "Verify<uoffset_t>(start)",
          "new_text": null,
          "old_line_content": "    return Verify<uoffset_t>(start) &&",
          "new_line_content": "      return false;",
          "content_same": false
        },
        {
          "line": 1477,
          "old_api": "ReadScalar<uoffset_t>(start)",
          "new_api": null,
          "old_text": "ReadScalar<uoffset_t>(start)",
          "new_text": null,
          "old_line_content": "      reinterpret_cast<const T *>(start + ReadScalar<uoffset_t>(start))->",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": "VerifyBufferFromStart<T>(identifier, buf_)",
          "new_api": null,
          "old_text": "VerifyBufferFromStart<T>(identifier, buf_)",
          "new_text": null,
          "old_line_content": "    return VerifyBufferFromStart<T>(identifier, buf_);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": "ReadScalar<uoffset_t>(buf_)",
          "new_api": null,
          "old_text": "ReadScalar<uoffset_t>(buf_)",
          "new_text": null,
          "old_line_content": "           ReadScalar<uoffset_t>(buf_) == end_ - buf_ - sizeof(uoffset_t) &&",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": "VerifyBufferFromStart<T>(identifier, buf_ + sizeof(uoffset_t))",
          "new_api": null,
          "old_text": "VerifyBufferFromStart<T>(identifier, buf_ + sizeof(uoffset_t))",
          "new_text": null,
          "old_line_content": "           VerifyBufferFromStart<T>(identifier, buf_ + sizeof(uoffset_t));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1503,
          "old_api": "Check",
          "new_api": null,
          "old_text": "Check(depth_ <= max_depth_ && num_tables_ <= max_tables_)",
          "new_text": null,
          "old_line_content": "    return Check(depth_ <= max_depth_ && num_tables_ <= max_tables_);",
          "new_line_content": "  // with EndTable().",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 24,
      "total_additions": 113,
      "total_deletions": 112,
      "total_api_changes": 249
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 249,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          1065,
          1060,
          1062
        ]
      }
    },
    "api_calls_before": 462,
    "api_calls_after": 464,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 2,
      "total_diff_lines": 20
    }
  }
}