{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/redis/modified_file/8f7bf2841a4a793a02a01d5c4c887a7770aa5e45",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/redis/modified_file/8f7bf2841a4a793a02a01d5c4c887a7770aa5e45/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/redis/modified_file/8f7bf2841a4a793a02a01d5c4c887a7770aa5e45/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/redis/modified_file/8f7bf2841a4a793a02a01d5c4c887a7770aa5e45/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1365,
          "old_api": "strcasecmp",
          "new_api": "ntohl",
          "old_text": "strcasecmp(node->ip,g->ip)",
          "new_text": "ntohl(g->pong_received)",
          "old_line_content": "                (strcasecmp(node->ip,g->ip) ||",
          "new_line_content": "                uint32_t pongtime = ntohl(g->pong_received);",
          "content_same": false
        },
        {
          "line": 1384,
          "old_api": "clusterBlacklistExists",
          "new_api": "ntohs",
          "old_text": "clusterBlacklistExists(g->nodename)",
          "new_text": "ntohs(g->port)",
          "old_line_content": "                !clusterBlacklistExists(g->nodename))",
          "new_line_content": "                node->port = ntohs(g->port);",
          "content_same": false
        },
        {
          "line": 1436,
          "old_api": "strcmp",
          "new_api": "ntohs",
          "old_text": "strcmp(ip,node->ip)",
          "new_text": "ntohs(hdr->port)",
          "old_line_content": "        strcmp(ip,node->ip) == 0) return 0;",
          "new_line_content": "    int port = ntohs(hdr->port);",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": "nodeIsSlave",
          "new_api": "strcmp",
          "old_text": "nodeIsSlave(myself)",
          "new_text": "strcmp(ip,node->ip)",
          "old_line_content": "    if (nodeIsSlave(myself) && myself->slaveof == node)",
          "new_line_content": "        strcmp(ip,node->ip) == 0) return 0;",
          "content_same": false
        },
        {
          "line": 1570,
          "old_api": "delKeysInSlot",
          "new_api": "clusterSetMaster",
          "old_text": "delKeysInSlot(dirty_slots[j])",
          "new_text": "clusterSetMaster(sender)",
          "old_line_content": "            delKeysInSlot(dirty_slots[j]);",
          "new_line_content": "        clusterSetMaster(sender);",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": "ntohu64",
          "new_api": "nodeInHandshake",
          "old_text": "ntohu64(hdr->offset)",
          "new_text": "nodeInHandshake(sender)",
          "old_line_content": "        sender->repl_offset = ntohu64(hdr->offset);",
          "new_line_content": "    if (sender && !nodeInHandshake(sender)) {",
          "content_same": false
        },
        {
          "line": 1712,
          "old_api": "createClusterNode",
          "new_api": "serverLog",
          "old_text": "createClusterNode(NULL,CLUSTER_NODE_HANDSHAKE)",
          "new_text": "serverLog(LL_WARNING,\"IP address for this node updated to %s\",\n                    myself->ip)",
          "old_line_content": "            node = createClusterNode(NULL,CLUSTER_NODE_HANDSHAKE);",
          "new_line_content": "                serverLog(LL_WARNING,\"IP address for this node updated to %s\",",
          "content_same": false
        },
        {
          "line": 1714,
          "old_api": "ntohs",
          "new_api": "clusterDoBeforeSleep",
          "old_text": "ntohs(hdr->port)",
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG)",
          "old_line_content": "            node->port = ntohs(hdr->port);",
          "new_line_content": "                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": "clusterSendPing",
          "new_api": "ntohs",
          "old_text": "clusterSendPing(link,CLUSTERMSG_TYPE_PONG)",
          "new_text": "ntohs(hdr->port)",
          "old_line_content": "        clusterSendPing(link,CLUSTERMSG_TYPE_PONG);",
          "new_line_content": "            node->port = ntohs(hdr->port);",
          "content_same": false
        },
        {
          "line": 1747,
          "old_api": "clusterDoBeforeSleep",
          "new_api": "serverLog",
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                                             CLUSTER_TODO_UPDATE_STATE)",
          "new_text": "serverLog(LL_DEBUG,\"%s packet received: %p\",\n            type == CLUSTERMSG_TYPE_PING ? \"ping\" : \"pong\",\n            (void*)link->node)",
          "old_line_content": "                        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "new_line_content": "        serverLog(LL_DEBUG,\"%s packet received: %p\",",
          "content_same": false
        },
        {
          "line": 1758,
          "old_api": "clusterRenameNode",
          "new_api": "nodeUpdateAddressIfNeeded",
          "old_text": "clusterRenameNode(link->node, hdr->sender)",
          "new_text": "nodeUpdateAddressIfNeeded(sender,link,hdr)",
          "old_line_content": "                clusterRenameNode(link->node, hdr->sender);",
          "new_line_content": "                    if (nodeUpdateAddressIfNeeded(sender,link,hdr))",
          "content_same": false
        },
        {
          "line": 1772,
          "old_api": "mstime",
          "new_api": "serverLog",
          "old_text": "mstime()",
          "new_text": "serverLog(LL_DEBUG,\"Handshake with node %.40s completed.\",\n                    link->node->name)",
          "old_line_content": "                    (int)(mstime()-(link->node->ctime)),",
          "new_line_content": "                serverLog(LL_DEBUG,\"Handshake with node %.40s completed.\",",
          "content_same": false
        },
        {
          "line": 1808,
          "old_api": "nodeFailed",
          "new_api": "mstime",
          "old_text": "nodeFailed(link->node)",
          "new_text": "mstime()",
          "old_line_content": "            } else if (nodeFailed(link->node)) {",
          "new_line_content": "            link->node->pong_received = mstime();",
          "content_same": false
        },
        {
          "line": 1819,
          "old_api": "clusterSetNodeAsMaster",
          "new_api": "clusterDoBeforeSleep",
          "old_text": "clusterSetNodeAsMaster(sender)",
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                                     CLUSTER_TODO_UPDATE_STATE)",
          "old_line_content": "                clusterSetNodeAsMaster(sender);",
          "new_line_content": "                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "content_same": false
        },
        {
          "line": 1822,
          "old_api": "clusterLookupNode",
          "new_api": "clearNodeFailureIfNeeded",
          "old_text": "clusterLookupNode(hdr->slaveof)",
          "new_text": "clearNodeFailureIfNeeded(link->node)",
          "old_line_content": "                clusterNode *master = clusterLookupNode(hdr->slaveof);",
          "new_line_content": "                clearNodeFailureIfNeeded(link->node);",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": "clusterDoBeforeSleep",
          "new_api": "clusterSetNodeAsMaster",
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                                         CLUSTER_TODO_UPDATE_STATE)",
          "new_text": "clusterSetNodeAsMaster(sender)",
          "old_line_content": "                    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "new_line_content": "                clusterSetNodeAsMaster(sender);",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": "clusterNodeRemoveSlave",
          "new_api": "clusterDelNodeSlots",
          "old_text": "clusterNodeRemoveSlave(sender->slaveof,sender)",
          "new_text": "clusterDelNodeSlots(sender)",
          "old_line_content": "                        clusterNodeRemoveSlave(sender->slaveof,sender);",
          "new_line_content": "                    clusterDelNodeSlots(sender);",
          "content_same": false
        },
        {
          "line": 1938,
          "old_api": "serverLog",
          "new_api": "clusterHandleConfigEpochCollision",
          "old_text": "serverLog(LL_NOTICE,\n                    \"FAIL message received from %.40s about %.40s\",\n                    hdr->sender, hdr->data.fail.about.nodename)",
          "new_text": "clusterHandleConfigEpochCollision(sender)",
          "old_line_content": "                serverLog(LL_NOTICE,",
          "new_line_content": "            clusterHandleConfigEpochCollision(sender);",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": "mstime",
          "new_api": "clusterProcessGossipSection",
          "old_text": "mstime()",
          "new_text": "clusterProcessGossipSection(hdr,link)",
          "old_line_content": "                failing->fail_time = mstime();",
          "new_line_content": "        if (sender) clusterProcessGossipSection(hdr,link);",
          "content_same": false
        },
        {
          "line": 1961,
          "old_api": "ntohl",
          "new_api": "serverLog",
          "old_text": "ntohl(hdr->data.publish.msg.channel_len)",
          "new_text": "serverLog(LL_NOTICE,\n                \"Ignoring FAIL message from unknown node %.40s about %.40s\",\n                hdr->sender, hdr->data.fail.about.nodename)",
          "old_line_content": "            channel_len = ntohl(hdr->data.publish.msg.channel_len);",
          "new_line_content": "            serverLog(LL_NOTICE,",
          "content_same": false
        },
        {
          "line": 1974,
          "old_api": "clusterSendFailoverAuthIfNeeded",
          "new_api": "ntohl",
          "old_text": "clusterSendFailoverAuthIfNeeded(sender,hdr)",
          "new_text": "ntohl(hdr->data.publish.msg.channel_len)",
          "old_line_content": "        clusterSendFailoverAuthIfNeeded(sender,hdr);",
          "new_line_content": "            channel_len = ntohl(hdr->data.publish.msg.channel_len);",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": "clusterSetNodeAsMaster",
          "new_api": "serverLog",
          "old_text": "clusterSetNodeAsMaster(n)",
          "new_text": "serverLog(LL_WARNING,\"Manual failover requested by slave %.40s.\",\n            sender->name)",
          "old_line_content": "        if (nodeIsSlave(n)) clusterSetNodeAsMaster(n);",
          "new_line_content": "        serverLog(LL_WARNING,\"Manual failover requested by slave %.40s.\",",
          "content_same": false
        },
        {
          "line": 2068,
          "old_api": "UNUSED",
          "new_api": "sdslen",
          "old_text": "UNUSED(el)",
          "new_text": "sdslen(link->sndbuf)",
          "old_line_content": "    UNUSED(el);",
          "new_line_content": "    if (sdslen(link->sndbuf) == 0)",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": "UNUSED",
          "new_api": "aeDeleteFileEvent",
          "old_text": "UNUSED(mask)",
          "new_text": "aeDeleteFileEvent(server.el, link->fd, AE_WRITABLE)",
          "old_line_content": "    UNUSED(mask);",
          "new_line_content": "        aeDeleteFileEvent(server.el, link->fd, AE_WRITABLE);",
          "content_same": false
        },
        {
          "line": 2097,
          "old_api": "read",
          "new_api": "ntohl",
          "old_text": "read(fd,buf,readlen)",
          "new_text": "ntohl(hdr->totlen)",
          "old_line_content": "        nread = read(fd,buf,readlen);",
          "new_line_content": "                    ntohl(hdr->totlen) < CLUSTERMSG_MIN_LEN)",
          "content_same": false
        },
        {
          "line": 2102,
          "old_api": "serverLog",
          "new_api": "handleLinkIOError",
          "old_text": "serverLog(LL_DEBUG,\"I/O error reading from node link: %s\",\n                (nread == 0) ? \"connection closed\" : strerror(errno))",
          "new_text": "handleLinkIOError(link)",
          "old_line_content": "            serverLog(LL_DEBUG,\"I/O error reading from node link: %s\",",
          "new_line_content": "                    handleLinkIOError(link);",
          "content_same": false
        },
        {
          "line": 2115,
          "old_api": "clusterProcessPacket",
          "new_api": "serverLog",
          "old_text": "clusterProcessPacket(link)",
          "new_text": "serverLog(LL_DEBUG,\"I/O error reading from node link: %s\",\n                (nread == 0) ? \"connection closed\" : strerror(errno))",
          "old_line_content": "            if (clusterProcessPacket(link)) {",
          "new_line_content": "            serverLog(LL_DEBUG,\"I/O error reading from node link: %s\",",
          "content_same": false
        },
        {
          "line": 2116,
          "old_api": "sdsfree",
          "new_api": "strerror",
          "old_text": "sdsfree(link->rcvbuf)",
          "new_text": "strerror(errno)",
          "old_line_content": "                sdsfree(link->rcvbuf);",
          "new_line_content": "                (nread == 0) ? \"connection closed\" : strerror(errno));",
          "content_same": false
        },
        {
          "line": 2117,
          "old_api": "sdsempty",
          "new_api": "handleLinkIOError",
          "old_text": "sdsempty()",
          "new_text": "handleLinkIOError(link)",
          "old_line_content": "                link->rcvbuf = sdsempty();",
          "new_line_content": "            handleLinkIOError(link);",
          "content_same": false
        },
        {
          "line": 2194,
          "old_api": "strncpy",
          "new_api": "htons",
          "old_text": "strncpy(hdr->myip,server.cluster_announce_ip,NET_IP_STR_LEN)",
          "new_text": "htons(CLUSTER_PROTO_VER)",
          "old_line_content": "        strncpy(hdr->myip,server.cluster_announce_ip,NET_IP_STR_LEN);",
          "new_line_content": "    hdr->ver = htons(CLUSTER_PROTO_VER);",
          "content_same": false
        },
        {
          "line": 2205,
          "old_api": "memcpy",
          "new_api": "memset",
          "old_text": "memcpy(hdr->myslots,master->slots,sizeof(hdr->myslots))",
          "new_text": "memset(hdr->myip,0,NET_IP_STR_LEN)",
          "old_line_content": "    memcpy(hdr->myslots,master->slots,sizeof(hdr->myslots));",
          "new_line_content": "    memset(hdr->myip,0,NET_IP_STR_LEN);",
          "content_same": false
        },
        {
          "line": 2219,
          "old_api": "nodeIsSlave",
          "new_api": "memset",
          "old_text": "nodeIsSlave(myself)",
          "new_text": "memset(hdr->slaveof,0,CLUSTER_NAMELEN)",
          "old_line_content": "    if (nodeIsSlave(myself))",
          "new_line_content": "    memset(hdr->slaveof,0,CLUSTER_NAMELEN);",
          "content_same": false
        },
        {
          "line": 2223,
          "old_api": "htonu64",
          "new_api": "htons",
          "old_text": "htonu64(offset)",
          "new_text": "htons(announced_cport)",
          "old_line_content": "    hdr->offset = htonu64(offset);",
          "new_line_content": "    hdr->cport = htons(announced_cport);",
          "content_same": false
        },
        {
          "line": 2346,
          "old_api": "htons",
          "new_api": "memcmp",
          "old_text": "htons(this->cport)",
          "new_text": "memcmp(hdr->data.ping.gossip[j].nodename,this->name,\n                    CLUSTER_NAMELEN)",
          "old_line_content": "        gossip->cport = htons(this->cport);",
          "new_line_content": "            if (memcmp(hdr->data.ping.gossip[j].nodename,this->name,",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": "htons",
          "new_api": "htonl",
          "old_text": "htons(gossipcount)",
          "new_text": "htonl(this->pong_received)",
          "old_line_content": "    hdr->count = htons(gossipcount);",
          "new_line_content": "        gossip->pong_received = htonl(this->pong_received);",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": "htonl",
          "new_api": "memcpy",
          "old_text": "htonl(totlen)",
          "new_text": "memcpy(gossip->ip,this->ip,sizeof(this->ip))",
          "old_line_content": "    hdr->totlen = htonl(totlen);",
          "new_line_content": "        memcpy(gossip->ip,this->ip,sizeof(this->ip));",
          "content_same": false
        },
        {
          "line": 2358,
          "old_api": "clusterSendMessage",
          "new_api": "htons",
          "old_text": "clusterSendMessage(link,buf,totlen)",
          "new_text": "htons(this->port)",
          "old_line_content": "    clusterSendMessage(link,buf,totlen);",
          "new_line_content": "        gossip->port = htons(this->port);",
          "content_same": false
        },
        {
          "line": 2359,
          "old_api": "zfree",
          "new_api": "htons",
          "old_text": "zfree(buf)",
          "new_text": "htons(this->cport)",
          "old_line_content": "    zfree(buf);",
          "new_line_content": "        gossip->cport = htons(this->cport);",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": "dictReleaseIterator",
          "new_api": "dictNext",
          "old_text": "dictReleaseIterator(di)",
          "new_text": "dictNext(di)",
          "old_line_content": "    dictReleaseIterator(di);",
          "new_line_content": "    while((de = dictNext(di)) != NULL) {",
          "content_same": false
        },
        {
          "line": 2409,
          "old_api": "getDecodedObject",
          "new_api": "dictReleaseIterator",
          "old_text": "getDecodedObject(message)",
          "new_text": "dictReleaseIterator(di)",
          "old_line_content": "    message = getDecodedObject(message);",
          "new_line_content": "    dictReleaseIterator(di);",
          "content_same": false
        },
        {
          "line": 2426,
          "old_api": "memcpy",
          "new_api": "clusterBuildMessageHdr",
          "old_text": "memcpy(payload,hdr,sizeof(*hdr))",
          "new_text": "clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_PUBLISH)",
          "old_line_content": "        memcpy(payload,hdr,sizeof(*hdr));",
          "new_line_content": "    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_PUBLISH);",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": "sdslen",
          "new_api": "htonl",
          "old_text": "sdslen(channel->ptr)",
          "new_text": "htonl(channel_len)",
          "old_line_content": "    memcpy(hdr->data.publish.msg.bulk_data+sdslen(channel->ptr),",
          "new_line_content": "    hdr->data.publish.msg.channel_len = htonl(channel_len);",
          "content_same": false
        },
        {
          "line": 2431,
          "old_api": "sdslen",
          "new_api": "htonl",
          "old_text": "sdslen(message->ptr)",
          "new_text": "htonl(message_len)",
          "old_line_content": "        message->ptr,sdslen(message->ptr));",
          "new_line_content": "    hdr->data.publish.msg.message_len = htonl(message_len);",
          "content_same": false
        },
        {
          "line": 2438,
          "old_api": "decrRefCount",
          "new_api": "zmalloc",
          "old_text": "decrRefCount(channel)",
          "new_text": "zmalloc(totlen)",
          "old_line_content": "    decrRefCount(channel);",
          "new_line_content": "        payload = zmalloc(totlen);",
          "content_same": false
        },
        {
          "line": 2439,
          "old_api": "decrRefCount",
          "new_api": "memcpy",
          "old_text": "decrRefCount(message)",
          "new_text": "memcpy(payload,hdr,sizeof(*hdr))",
          "old_line_content": "    decrRefCount(message);",
          "new_line_content": "        memcpy(payload,hdr,sizeof(*hdr));",
          "content_same": false
        },
        {
          "line": 2452,
          "old_api": "clusterBuildMessageHdr",
          "new_api": "decrRefCount",
          "old_text": "clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAIL)",
          "new_text": "decrRefCount(message)",
          "old_line_content": "    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAIL);",
          "new_line_content": "    decrRefCount(message);",
          "content_same": false
        },
        {
          "line": 2453,
          "old_api": "memcpy",
          "new_api": "zfree",
          "old_text": "memcpy(hdr->data.fail.about.nodename,nodename,CLUSTER_NAMELEN)",
          "new_text": "zfree(payload)",
          "old_line_content": "    memcpy(hdr->data.fail.about.nodename,nodename,CLUSTER_NAMELEN);",
          "new_line_content": "    if (payload != buf) zfree(payload);",
          "content_same": false
        },
        {
          "line": 2467,
          "old_api": "htonu64",
          "new_api": "ntohl",
          "old_text": "htonu64(node->configEpoch)",
          "new_text": "ntohl(hdr->totlen)",
          "old_line_content": "    hdr->data.update.nodecfg.configEpoch = htonu64(node->configEpoch);",
          "new_line_content": "    clusterBroadcastMessage(buf,ntohl(hdr->totlen));",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": "clusterSendPublish",
          "new_api": "htonu64",
          "old_text": "clusterSendPublish(NULL, channel, message)",
          "new_text": "htonu64(node->configEpoch)",
          "old_line_content": "    clusterSendPublish(NULL, channel, message);",
          "new_line_content": "    hdr->data.update.nodecfg.configEpoch = htonu64(node->configEpoch);",
          "content_same": false
        },
        {
          "line": 2518,
          "old_api": "clusterSendMessage",
          "new_api": "clusterBroadcastMessage",
          "old_text": "clusterSendMessage(node->link,buf,totlen)",
          "new_text": "clusterBroadcastMessage(buf,totlen)",
          "old_line_content": "    clusterSendMessage(node->link,buf,totlen);",
          "new_line_content": "    clusterBroadcastMessage(buf,totlen);",
          "content_same": false
        },
        {
          "line": 2577,
          "old_api": "nodeIsMaster",
          "new_api": "serverLog",
          "old_text": "nodeIsMaster(node)",
          "new_text": "serverLog(LL_WARNING,\n                \"Failover auth denied to %.40s: already voted for epoch %llu\",\n                node->name,\n                (unsigned long long) server.cluster->currentEpoch)",
          "old_line_content": "        if (nodeIsMaster(node)) {",
          "new_line_content": "        serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": "serverLog",
          "new_api": "nodeFailed",
          "old_text": "serverLog(LL_WARNING,\n                \"Failover auth denied to %.40s: \"\n                \"can't vote about this master before %lld milliseconds\",\n                node->name,\n                (long long) ((server.cluster_node_timeout*2)-\n                             (mstime() - node->slaveof->voted_time)))",
          "new_text": "nodeFailed(master)",
          "old_line_content": "        serverLog(LL_WARNING,",
          "new_line_content": "        } else if (!nodeFailed(master)) {",
          "content_same": false
        },
        {
          "line": 2611,
          "old_api": "bitmapTestBit",
          "new_api": "serverLog",
          "old_text": "bitmapTestBit(claimed_slots, j)",
          "new_text": "serverLog(LL_WARNING,\n                \"Failover auth denied to %.40s: \"\n                \"can't vote about this master before %lld milliseconds\",\n                node->name,\n                (long long) ((server.cluster_node_timeout*2)-\n                             (mstime() - node->slaveof->voted_time)))",
          "old_line_content": "        if (bitmapTestBit(claimed_slots, j) == 0) continue;",
          "new_line_content": "        serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 2739,
          "old_api": "nodeIsMaster",
          "new_api": "serverLog",
          "old_text": "nodeIsMaster(myself)",
          "new_text": "serverLog(LL_WARNING,\"Currently unable to failover: %s\", msg)",
          "old_line_content": "    if (nodeIsMaster(myself) || oldmaster == NULL) return;",
          "new_line_content": "    serverLog(LL_WARNING,\"Currently unable to failover: %s\", msg);",
          "content_same": false
        },
        {
          "line": 2755,
          "old_api": "clusterSaveConfigOrDie",
          "new_api": "clusterSetNodeAsMaster",
          "old_text": "clusterSaveConfigOrDie(1)",
          "new_text": "clusterSetNodeAsMaster(myself)",
          "old_line_content": "    clusterSaveConfigOrDie(1);",
          "new_line_content": "    clusterSetNodeAsMaster(myself);",
          "content_same": false
        },
        {
          "line": 2762,
          "old_api": "resetManualFailover",
          "new_api": "clusterAddSlot",
          "old_text": "resetManualFailover()",
          "new_text": "clusterAddSlot(myself,j)",
          "old_line_content": "    resetManualFailover();",
          "new_line_content": "            clusterAddSlot(myself,j);",
          "content_same": false
        },
        {
          "line": 2775,
          "old_api": "mstime",
          "new_api": "resetManualFailover",
          "old_text": "mstime()",
          "new_text": "resetManualFailover()",
          "old_line_content": "    mstime_t auth_age = mstime() - server.cluster->failover_auth_time;",
          "new_line_content": "    resetManualFailover();",
          "content_same": false
        },
        {
          "line": 2848,
          "old_api": "clusterGetSlaveRank",
          "new_api": "clusterLogCantFailover",
          "old_text": "clusterGetSlaveRank()",
          "new_text": "clusterLogCantFailover(CLUSTER_CANT_FAILOVER_DATA_AGE)",
          "old_line_content": "        server.cluster->failover_auth_rank = clusterGetSlaveRank();",
          "new_line_content": "            clusterLogCantFailover(CLUSTER_CANT_FAILOVER_DATA_AGE);",
          "content_same": false
        },
        {
          "line": 2893,
          "old_api": "mstime",
          "new_api": "clusterGetSlaveRank",
          "old_text": "mstime()",
          "new_text": "clusterGetSlaveRank()",
          "old_line_content": "    if (mstime() < server.cluster->failover_auth_time) {",
          "new_line_content": "        int newrank = clusterGetSlaveRank();",
          "content_same": false
        },
        {
          "line": 3008,
          "old_api": "clusterCountNonFailingSlaves",
          "new_api": "dictGetSafeIterator",
          "old_text": "clusterCountNonFailingSlaves(node)",
          "new_text": "dictGetSafeIterator(server.cluster->nodes)",
          "old_line_content": "        if (nodeIsMaster(node)) okslaves = clusterCountNonFailingSlaves(node);",
          "new_line_content": "    di = dictGetSafeIterator(server.cluster->nodes);",
          "content_same": false
        },
        {
          "line": 3099,
          "old_api": "serverLog",
          "new_api": "clientsArePaused",
          "old_text": "serverLog(LL_WARNING,\"Manual failover timed out.\")",
          "new_text": "clientsArePaused()",
          "old_line_content": "        serverLog(LL_WARNING,\"Manual failover timed out.\");",
          "new_line_content": "    if (server.cluster->mf_end && clientsArePaused()) {",
          "content_same": false
        },
        {
          "line": 3264,
          "old_api": "serverLog",
          "new_api": "dictGetRandomKey",
          "old_text": "serverLog(LL_DEBUG,\"Pinging node %.40s\", min_pong_node->name)",
          "new_text": "dictGetRandomKey(server.cluster->nodes)",
          "old_line_content": "            serverLog(LL_DEBUG,\"Pinging node %.40s\", min_pong_node->name);",
          "new_line_content": "            de = dictGetRandomKey(server.cluster->nodes);",
          "content_same": false
        },
        {
          "line": 3265,
          "old_api": "clusterSendPing",
          "new_api": "dictGetVal",
          "old_text": "clusterSendPing(min_pong_node->link, CLUSTERMSG_TYPE_PING)",
          "new_text": "dictGetVal(de)",
          "old_line_content": "            clusterSendPing(min_pong_node->link, CLUSTERMSG_TYPE_PING);",
          "new_line_content": "            clusterNode *this = dictGetVal(de);",
          "content_same": false
        },
        {
          "line": 3278,
          "old_api": "dictGetSafeIterator",
          "new_api": "clusterSendPing",
          "old_text": "dictGetSafeIterator(server.cluster->nodes)",
          "new_text": "clusterSendPing(min_pong_node->link, CLUSTERMSG_TYPE_PING)",
          "old_line_content": "    di = dictGetSafeIterator(server.cluster->nodes);",
          "new_line_content": "            clusterSendPing(min_pong_node->link, CLUSTERMSG_TYPE_PING);",
          "content_same": false
        },
        {
          "line": 3291,
          "old_api": "clusterCountNonFailingSlaves",
          "new_api": "dictGetSafeIterator",
          "old_text": "clusterCountNonFailingSlaves(node)",
          "new_text": "dictGetSafeIterator(server.cluster->nodes)",
          "old_line_content": "            int okslaves = clusterCountNonFailingSlaves(node);",
          "new_line_content": "    di = dictGetSafeIterator(server.cluster->nodes);",
          "content_same": false
        },
        {
          "line": 3381,
          "old_api": "clusterHandleSlaveFailover",
          "new_api": "nodeIsSlave",
          "old_text": "clusterHandleSlaveFailover()",
          "new_text": "nodeIsSlave(myself)",
          "old_line_content": "        clusterHandleSlaveFailover();",
          "new_line_content": "    if (nodeIsSlave(myself) &&",
          "content_same": false
        },
        {
          "line": 3392,
          "old_api": "clusterUpdateState",
          "new_api": "nodeIsSlave",
          "old_text": "clusterUpdateState()",
          "new_text": "nodeIsSlave(myself)",
          "old_line_content": "        clusterUpdateState();",
          "new_line_content": "    if (nodeIsSlave(myself)) {",
          "content_same": false
        },
        {
          "line": 3472,
          "old_api": "bitmapSetBit",
          "new_api": "dictNext",
          "old_text": "bitmapSetBit(n->slots,slot)",
          "new_text": "dictNext(di)",
          "old_line_content": "    bitmapSetBit(n->slots,slot);",
          "new_line_content": "    while((de = dictNext(di)) != NULL) {",
          "content_same": false
        },
        {
          "line": 3745,
          "old_api": "replicationSetMaster",
          "new_api": "serverAssert",
          "old_text": "replicationSetMaster(n->ip, n->port)",
          "new_text": "serverAssert(n != myself)",
          "old_line_content": "    replicationSetMaster(n->ip, n->port);",
          "new_line_content": "    serverAssert(n != myself);",
          "content_same": false
        },
        {
          "line": 3746,
          "old_api": "resetManualFailover",
          "new_api": "serverAssert",
          "old_text": "resetManualFailover()",
          "new_text": "serverAssert(myself->numslots == 0)",
          "old_line_content": "    resetManualFailover();",
          "new_line_content": "    serverAssert(myself->numslots == 0);",
          "content_same": false
        },
        {
          "line": 3793,
          "old_api": "sdsempty",
          "new_api": "sdsIncrLen",
          "old_text": "sdsempty()",
          "new_text": "sdsIncrLen(ci,-1)",
          "old_line_content": "    ci = sdscatprintf(sdsempty(),\"%.40s %s:%d@%d \",",
          "new_line_content": "    sdsIncrLen(ci,-1); /* Remove trailing comma. */",
          "content_same": false
        },
        {
          "line": 3806,
          "old_api": "sdscatlen",
          "new_api": "sdsempty",
          "old_text": "sdscatlen(ci,\" - \",3)",
          "new_text": "sdsempty()",
          "old_line_content": "        ci = sdscatlen(ci,\" - \",3);",
          "new_line_content": "    ci = sdscatprintf(sdsempty(),\"%.40s %s:%d@%d \",",
          "content_same": false
        },
        {
          "line": 3956,
          "old_api": "addReplyLongLong",
          "new_api": "clusterNodeGetSlotBit",
          "old_text": "addReplyLongLong(c, start)",
          "new_text": "clusterNodeGetSlotBit(node,j)",
          "old_line_content": "                    addReplyLongLong(c, start);",
          "new_line_content": "            if ((bit = clusterNodeGetSlotBit(node,j)) != 0) {",
          "content_same": false
        },
        {
          "line": 3977,
          "old_api": "addReplyBulkCBuffer",
          "new_api": "addReplyMultiBulkLen",
          "old_text": "addReplyBulkCBuffer(c, node->slaves[i]->name, CLUSTER_NAMELEN)",
          "new_text": "addReplyMultiBulkLen(c, 3)",
          "old_line_content": "                    addReplyBulkCBuffer(c, node->slaves[i]->name, CLUSTER_NAMELEN);",
          "new_line_content": "                addReplyMultiBulkLen(c, 3);",
          "content_same": false
        },
        {
          "line": 3980,
          "old_api": "setDeferredMultiBulkLength",
          "new_api": "addReplyBulkCBuffer",
          "old_text": "setDeferredMultiBulkLength(c, nested_replylen, nested_elements)",
          "new_text": "addReplyBulkCBuffer(c, node->name, CLUSTER_NAMELEN)",
          "old_line_content": "                setDeferredMultiBulkLength(c, nested_replylen, nested_elements);",
          "new_line_content": "                addReplyBulkCBuffer(c, node->name, CLUSTER_NAMELEN);",
          "content_same": false
        },
        {
          "line": 3986,
          "old_api": "setDeferredMultiBulkLength",
          "new_api": "nodeFailed",
          "old_text": "setDeferredMultiBulkLength(c, slot_replylen, num_masters)",
          "new_text": "nodeFailed(node->slaves[i])",
          "old_line_content": "    setDeferredMultiBulkLength(c, slot_replylen, num_masters);",
          "new_line_content": "                    if (nodeFailed(node->slaves[i])) continue;",
          "content_same": false
        },
        {
          "line": 3999,
          "old_api": "getLongLongFromObject",
          "new_api": "setDeferredMultiBulkLength",
          "old_text": "getLongLongFromObject(c->argv[3], &port)",
          "new_text": "setDeferredMultiBulkLength(c, slot_replylen, num_masters)",
          "old_line_content": "        if (getLongLongFromObject(c->argv[3], &port) != C_OK) {",
          "new_line_content": "    setDeferredMultiBulkLength(c, slot_replylen, num_masters);",
          "content_same": false
        },
        {
          "line": 4028,
          "old_api": "createObject",
          "new_api": "clusterStartHandshake",
          "old_text": "createObject(OBJ_STRING,ci)",
          "new_text": "clusterStartHandshake(c->argv[2]->ptr,port,cport)",
          "old_line_content": "        o = createObject(OBJ_STRING,ci);",
          "new_line_content": "        if (clusterStartHandshake(c->argv[2]->ptr,port,cport) == 0 &&",
          "content_same": false
        },
        {
          "line": 4031,
          "old_api": "strcasecmp",
          "new_api": "addReplyErrorFormat",
          "old_text": "strcasecmp(c->argv[1]->ptr,\"myid\")",
          "new_text": "addReplyErrorFormat(c,\"Invalid node address specified: %s:%s\",\n                            (char*)c->argv[2]->ptr, (char*)c->argv[3]->ptr)",
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"myid\") && c->argc == 2) {",
          "new_line_content": "            addReplyErrorFormat(c,\"Invalid node address specified: %s:%s\",",
          "content_same": false
        },
        {
          "line": 4034,
          "old_api": "strcasecmp",
          "new_api": "addReply",
          "old_text": "strcasecmp(c->argv[1]->ptr,\"slots\")",
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"slots\") && c->argc == 2) {",
          "new_line_content": "            addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 4036,
          "old_api": "clusterReplyMultiBulkSlots",
          "new_api": "strcasecmp",
          "old_text": "clusterReplyMultiBulkSlots(c)",
          "new_text": "strcasecmp(c->argv[1]->ptr,\"nodes\")",
          "old_line_content": "        clusterReplyMultiBulkSlots(c);",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"nodes\") && c->argc == 2) {",
          "content_same": false
        },
        {
          "line": 4039,
          "old_api": "dictSize",
          "new_api": "clusterGenNodesDescription",
          "old_text": "dictSize(server.db[0].dict)",
          "new_text": "clusterGenNodesDescription(0)",
          "old_line_content": "        if (dictSize(server.db[0].dict) != 0) {",
          "new_line_content": "        sds ci = clusterGenNodesDescription(0);",
          "content_same": false
        },
        {
          "line": 4043,
          "old_api": "clusterDelNodeSlots",
          "new_api": "decrRefCount",
          "old_text": "clusterDelNodeSlots(myself)",
          "new_text": "decrRefCount(o)",
          "old_line_content": "        clusterDelNodeSlots(myself);",
          "new_line_content": "        decrRefCount(o);",
          "content_same": false
        },
        {
          "line": 4044,
          "old_api": "clusterDoBeforeSleep",
          "new_api": "strcasecmp",
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG)",
          "new_text": "strcasecmp(c->argv[1]->ptr,\"myid\")",
          "old_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"myid\") && c->argc == 2) {",
          "content_same": false
        },
        {
          "line": 4046,
          "old_api": "strcasecmp",
          "new_api": "addReplyBulkCBuffer",
          "old_text": "strcasecmp(c->argv[1]->ptr,\"addslots\")",
          "new_text": "addReplyBulkCBuffer(c,myself->name, CLUSTER_NAMELEN)",
          "old_line_content": "    } else if ((!strcasecmp(c->argv[1]->ptr,\"addslots\") ||",
          "new_line_content": "        addReplyBulkCBuffer(c,myself->name, CLUSTER_NAMELEN);",
          "content_same": false
        },
        {
          "line": 4052,
          "old_api": "zmalloc",
          "new_api": "dictSize",
          "old_text": "zmalloc(CLUSTER_SLOTS)",
          "new_text": "dictSize(server.db[0].dict)",
          "old_line_content": "        unsigned char *slots = zmalloc(CLUSTER_SLOTS);",
          "new_line_content": "        if (dictSize(server.db[0].dict) != 0) {",
          "content_same": false
        },
        {
          "line": 4053,
          "old_api": "strcasecmp",
          "new_api": "addReplyError",
          "old_text": "strcasecmp(c->argv[1]->ptr,\"delslots\")",
          "new_text": "addReplyError(c,\"DB must be empty to perform CLUSTER FLUSHSLOTS.\")",
          "old_line_content": "        int del = !strcasecmp(c->argv[1]->ptr,\"delslots\");",
          "new_line_content": "            addReplyError(c,\"DB must be empty to perform CLUSTER FLUSHSLOTS.\");",
          "content_same": false
        },
        {
          "line": 4059,
          "old_api": "getSlotOrReply",
          "new_api": "strcasecmp",
          "old_text": "getSlotOrReply(c,c->argv[j])",
          "new_text": "strcasecmp(c->argv[1]->ptr,\"addslots\")",
          "old_line_content": "            if ((slot = getSlotOrReply(c,c->argv[j])) == -1) {",
          "new_line_content": "    } else if ((!strcasecmp(c->argv[1]->ptr,\"addslots\") ||",
          "content_same": false
        },
        {
          "line": 4060,
          "old_api": "zfree",
          "new_api": "strcasecmp",
          "old_text": "zfree(slots)",
          "new_text": "strcasecmp(c->argv[1]->ptr,\"delslots\")",
          "old_line_content": "                zfree(slots);",
          "new_line_content": "               !strcasecmp(c->argv[1]->ptr,\"delslots\")) && c->argc >= 3)",
          "content_same": false
        },
        {
          "line": 4065,
          "old_api": "zfree",
          "new_api": "zmalloc",
          "old_text": "zfree(slots)",
          "new_text": "zmalloc(CLUSTER_SLOTS)",
          "old_line_content": "                zfree(slots);",
          "new_line_content": "        unsigned char *slots = zmalloc(CLUSTER_SLOTS);",
          "content_same": false
        },
        {
          "line": 4068,
          "old_api": "addReplyErrorFormat",
          "new_api": "memset",
          "old_text": "addReplyErrorFormat(c,\"Slot %d is already busy\", slot)",
          "new_text": "memset(slots,0,CLUSTER_SLOTS)",
          "old_line_content": "                addReplyErrorFormat(c,\"Slot %d is already busy\", slot);",
          "new_line_content": "        memset(slots,0,CLUSTER_SLOTS);",
          "content_same": false
        },
        {
          "line": 4073,
          "old_api": "addReplyErrorFormat",
          "new_api": "zfree",
          "old_text": "addReplyErrorFormat(c,\"Slot %d specified multiple times\",\n                    (int)slot)",
          "new_text": "zfree(slots)",
          "old_line_content": "                addReplyErrorFormat(c,\"Slot %d specified multiple times\",",
          "new_line_content": "                zfree(slots);",
          "content_same": false
        },
        {
          "line": 4088,
          "old_api": "clusterDelSlot",
          "new_api": "zfree",
          "old_text": "clusterDelSlot(j)",
          "new_text": "zfree(slots)",
          "old_line_content": "                retval = del ? clusterDelSlot(j) :",
          "new_line_content": "                zfree(slots);",
          "content_same": false
        },
        {
          "line": 4109,
          "old_api": "getSlotOrReply",
          "new_api": "strcasecmp",
          "old_text": "getSlotOrReply(c,c->argv[2])",
          "new_text": "strcasecmp(c->argv[1]->ptr,\"setslot\")",
          "old_line_content": "        if ((slot = getSlotOrReply(c,c->argv[2])) == -1) return;",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"setslot\") && c->argc >= 4) {",
          "content_same": false
        },
        {
          "line": 4117,
          "old_api": "addReplyErrorFormat",
          "new_api": "nodeIsSlave",
          "old_text": "addReplyErrorFormat(c,\"I don't know about node %s\",\n                    (char*)c->argv[4]->ptr)",
          "new_text": "nodeIsSlave(myself)",
          "old_line_content": "                addReplyErrorFormat(c,\"I don't know about node %s\",",
          "new_line_content": "        if (nodeIsSlave(myself)) {",
          "content_same": false
        },
        {
          "line": 4122,
          "old_api": "strcasecmp",
          "new_api": "getSlotOrReply",
          "old_text": "strcasecmp(c->argv[3]->ptr,\"importing\")",
          "new_text": "getSlotOrReply(c,c->argv[2])",
          "old_line_content": "        } else if (!strcasecmp(c->argv[3]->ptr,\"importing\") && c->argc == 5) {",
          "new_line_content": "        if ((slot = getSlotOrReply(c,c->argv[2])) == -1) return;",
          "content_same": false
        },
        {
          "line": 4124,
          "old_api": "addReplyErrorFormat",
          "new_api": "strcasecmp",
          "old_text": "addReplyErrorFormat(c,\n                    \"I'm already the owner of hash slot %u\",slot)",
          "new_text": "strcasecmp(c->argv[3]->ptr,\"migrating\")",
          "old_line_content": "                addReplyErrorFormat(c,",
          "new_line_content": "        if (!strcasecmp(c->argv[3]->ptr,\"migrating\") && c->argc == 5) {",
          "content_same": false
        },
        {
          "line": 4129,
          "old_api": "addReplyErrorFormat",
          "new_api": "clusterLookupNode",
          "old_text": "addReplyErrorFormat(c,\"I don't know about node %s\",\n                    (char*)c->argv[3]->ptr)",
          "new_text": "clusterLookupNode(c->argv[4]->ptr)",
          "old_line_content": "                addReplyErrorFormat(c,\"I don't know about node %s\",",
          "new_line_content": "            if ((n = clusterLookupNode(c->argv[4]->ptr)) == NULL) {",
          "content_same": false
        },
        {
          "line": 4151,
          "old_api": "addReplyErrorFormat",
          "new_api": "strcasecmp",
          "old_text": "addReplyErrorFormat(c,\n                        \"Can't assign hashslot %d to a different node \"\n                        \"while I still hold keys for this hash slot.\", slot)",
          "new_text": "strcasecmp(c->argv[3]->ptr,\"node\")",
          "old_line_content": "                    addReplyErrorFormat(c,",
          "new_line_content": "        } else if (!strcasecmp(c->argv[3]->ptr,\"node\") && c->argc == 5) {",
          "content_same": false
        },
        {
          "line": 4191,
          "old_api": "clusterDoBeforeSleep",
          "new_api": "clusterBumpConfigEpochWithoutConsensus",
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_UPDATE_STATE)",
          "new_text": "clusterBumpConfigEpochWithoutConsensus()",
          "old_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_UPDATE_STATE);",
          "new_line_content": "                if (clusterBumpConfigEpochWithoutConsensus() == C_OK) {",
          "content_same": false
        },
        {
          "line": 4192,
          "old_api": "addReply",
          "new_api": "serverLog",
          "old_text": "addReply(c,shared.ok)",
          "new_text": "serverLog(LL_WARNING,\n                        \"configEpoch updated after importing slot %d\", slot)",
          "old_line_content": "        addReply(c,shared.ok);",
          "new_line_content": "                    serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 4200,
          "old_api": "strcasecmp",
          "new_api": "addReplyError",
          "old_text": "strcasecmp(c->argv[1]->ptr,\"info\")",
          "new_text": "addReplyError(c,\n                \"Invalid CLUSTER SETSLOT action or number of arguments\")",
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"info\") && c->argc == 2) {",
          "new_line_content": "            addReplyError(c,",
          "content_same": false
        },
        {
          "line": 4212,
          "old_api": "nodeFailed",
          "new_api": "addReplySds",
          "old_text": "nodeFailed(n)",
          "new_text": "addReplySds(c,reply)",
          "old_line_content": "            if (nodeFailed(n)) {",
          "new_line_content": "        addReplySds(c,reply);",
          "content_same": false
        },
        {
          "line": 4252,
          "old_api": "sdscatprintf",
          "new_api": "dictSize",
          "old_text": "sdscatprintf(info,\n                \"cluster_stats_messages_%s_sent:%lld\\r\\n\",\n                clusterGetMessageTypeString(i),\n                server.cluster->stats_bus_messages_sent[i])",
          "new_text": "dictSize(server.cluster->nodes)",
          "old_line_content": "            info = sdscatprintf(info,",
          "new_line_content": "            dictSize(server.cluster->nodes),",
          "content_same": false
        },
        {
          "line": 4265,
          "old_api": "clusterGetMessageTypeString",
          "new_api": "sdscatprintf",
          "old_text": "clusterGetMessageTypeString(i)",
          "new_text": "sdscatprintf(info,\n                \"cluster_stats_messages_%s_sent:%lld\\r\\n\",\n                clusterGetMessageTypeString(i),\n                server.cluster->stats_bus_messages_sent[i])",
          "old_line_content": "                clusterGetMessageTypeString(i),",
          "new_line_content": "            info = sdscatprintf(info,",
          "content_same": false
        },
        {
          "line": 4276,
          "old_api": "strcasecmp",
          "new_api": "sdscatprintf",
          "old_text": "strcasecmp(c->argv[1]->ptr,\"saveconfig\")",
          "new_text": "sdscatprintf(info,\n                \"cluster_stats_messages_%s_received:%lld\\r\\n\",\n                clusterGetMessageTypeString(i),\n                server.cluster->stats_bus_messages_received[i])",
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"saveconfig\") && c->argc == 2) {",
          "new_line_content": "            info = sdscatprintf(info,",
          "content_same": false
        },
        {
          "line": 4288,
          "old_api": "sdslen",
          "new_api": "addReply",
          "old_text": "sdslen(key)",
          "new_text": "addReply(c,shared.crlf)",
          "old_line_content": "        addReplyLongLong(c,keyHashSlot(key,sdslen(key)));",
          "new_line_content": "        addReply(c,shared.crlf);",
          "content_same": false
        },
        {
          "line": 4293,
          "old_api": "getLongLongFromObjectOrReply",
          "new_api": "addReply",
          "old_text": "getLongLongFromObjectOrReply(c,c->argv[2],&slot,NULL)",
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": "        if (getLongLongFromObjectOrReply(c,c->argv[2],&slot,NULL) != C_OK)",
          "new_line_content": "            addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 4296,
          "old_api": "addReplyError",
          "new_api": "strerror",
          "old_text": "addReplyError(c,\"Invalid slot\")",
          "new_text": "strerror(errno)",
          "old_line_content": "            addReplyError(c,\"Invalid slot\");",
          "new_line_content": "                strerror(errno));",
          "content_same": false
        },
        {
          "line": 4312,
          "old_api": "addReplyError",
          "new_api": "countKeysInSlot",
          "old_text": "addReplyError(c,\"Invalid slot or number of keys\")",
          "new_text": "countKeysInSlot(slot)",
          "old_line_content": "            addReplyError(c,\"Invalid slot or number of keys\");",
          "new_line_content": "        addReplyLongLong(c,countKeysInSlot(slot));",
          "content_same": false
        },
        {
          "line": 4321,
          "old_api": "decrRefCount",
          "new_api": "getLongLongFromObjectOrReply",
          "old_text": "decrRefCount(keys[j])",
          "new_text": "getLongLongFromObjectOrReply(c,c->argv[3],&maxkeys,NULL)",
          "old_line_content": "            decrRefCount(keys[j]);",
          "new_line_content": "        if (getLongLongFromObjectOrReply(c,c->argv[3],&maxkeys,NULL)",
          "content_same": false
        },
        {
          "line": 4329,
          "old_api": "addReplyErrorFormat",
          "new_api": "zmalloc",
          "old_text": "addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr)",
          "new_text": "zmalloc(sizeof(robj*)*maxkeys)",
          "old_line_content": "            addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr);",
          "new_line_content": "        keys = zmalloc(sizeof(robj*)*maxkeys);",
          "content_same": false
        },
        {
          "line": 4334,
          "old_api": "nodeIsSlave",
          "new_api": "decrRefCount",
          "old_text": "nodeIsSlave(myself)",
          "new_text": "decrRefCount(keys[j])",
          "old_line_content": "        } else if (nodeIsSlave(myself) && myself->slaveof == n) {",
          "new_line_content": "            decrRefCount(keys[j]);",
          "content_same": false
        },
        {
          "line": 4339,
          "old_api": "clusterDelNode",
          "new_api": "clusterLookupNode",
          "old_text": "clusterDelNode(n)",
          "new_text": "clusterLookupNode(c->argv[2]->ptr)",
          "old_line_content": "        clusterDelNode(n);",
          "new_line_content": "        clusterNode *n = clusterLookupNode(c->argv[2]->ptr);",
          "content_same": false
        },
        {
          "line": 4342,
          "old_api": "addReply",
          "new_api": "addReplyErrorFormat",
          "old_text": "addReply(c,shared.ok)",
          "new_text": "addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr)",
          "old_line_content": "        addReply(c,shared.ok);",
          "new_line_content": "            addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr);",
          "content_same": false
        },
        {
          "line": 4345,
          "old_api": "clusterLookupNode",
          "new_api": "addReplyError",
          "old_text": "clusterLookupNode(c->argv[2]->ptr)",
          "new_text": "addReplyError(c,\"I tried hard but I can't forget myself...\")",
          "old_line_content": "        clusterNode *n = clusterLookupNode(c->argv[2]->ptr);",
          "new_line_content": "            addReplyError(c,\"I tried hard but I can't forget myself...\");",
          "content_same": false
        },
        {
          "line": 4355,
          "old_api": "addReplyError",
          "new_api": "addReply",
          "old_text": "addReplyError(c,\"Can't replicate myself\")",
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": "            addReplyError(c,\"Can't replicate myself\");",
          "new_line_content": "        addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 4368,
          "old_api": "nodeIsMaster",
          "new_api": "addReplyError",
          "old_text": "nodeIsMaster(myself)",
          "new_text": "addReplyError(c,\"Can't replicate myself\")",
          "old_line_content": "        if (nodeIsMaster(myself) &&",
          "new_line_content": "            addReplyError(c,\"Can't replicate myself\");",
          "content_same": false
        },
        {
          "line": 4382,
          "old_api": "clusterLookupNode",
          "new_api": "dictSize",
          "old_text": "clusterLookupNode(c->argv[2]->ptr)",
          "new_text": "dictSize(server.db[0].dict)",
          "old_line_content": "        clusterNode *n = clusterLookupNode(c->argv[2]->ptr);",
          "new_line_content": "            (myself->numslots != 0 || dictSize(server.db[0].dict) != 0)) {",
          "content_same": false
        },
        {
          "line": 4391,
          "old_api": "nodeIsSlave",
          "new_api": "clusterDoBeforeSleep",
          "old_text": "nodeIsSlave(n)",
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG)",
          "old_line_content": "        if (nodeIsSlave(n)) {",
          "new_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);",
          "content_same": false
        },
        {
          "line": 4392,
          "old_api": "addReplyError",
          "new_api": "addReply",
          "old_text": "addReplyError(c,\"The specified node is not a master\")",
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": "            addReplyError(c,\"The specified node is not a master\");",
          "new_line_content": "        addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 4400,
          "old_api": "sdsfree",
          "new_api": "addReplyErrorFormat",
          "old_text": "sdsfree(ni)",
          "new_text": "addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr)",
          "old_line_content": "            sdsfree(ni);",
          "new_line_content": "            addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr);",
          "content_same": false
        },
        {
          "line": 4409,
          "old_api": "addReplyErrorFormat",
          "new_api": "addReplyMultiBulkLen",
          "old_text": "addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr)",
          "new_text": "addReplyMultiBulkLen(c,n->numslaves)",
          "old_line_content": "            addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr);",
          "new_line_content": "        addReplyMultiBulkLen(c,n->numslaves);",
          "content_same": false
        },
        {
          "line": 4412,
          "old_api": "clusterNodeFailureReportsCount",
          "new_api": "addReplyBulkCString",
          "old_text": "clusterNodeFailureReportsCount(n)",
          "new_text": "addReplyBulkCString(c,ni)",
          "old_line_content": "            addReplyLongLong(c,clusterNodeFailureReportsCount(n));",
          "new_line_content": "            addReplyBulkCString(c,ni);",
          "content_same": false
        },
        {
          "line": 4427,
          "old_api": "addReply",
          "new_api": "strcasecmp",
          "old_text": "addReply(c,shared.syntaxerr)",
          "new_text": "strcasecmp(c->argv[1]->ptr,\"failover\")",
          "old_line_content": "                addReply(c,shared.syntaxerr);",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"failover\") &&",
          "content_same": false
        },
        {
          "line": 4434,
          "old_api": "addReplyError",
          "new_api": "strcasecmp",
          "old_text": "addReplyError(c,\"You should send CLUSTER FAILOVER to a slave\")",
          "new_text": "strcasecmp(c->argv[2]->ptr,\"force\")",
          "old_line_content": "            addReplyError(c,\"You should send CLUSTER FAILOVER to a slave\");",
          "new_line_content": "            if (!strcasecmp(c->argv[2]->ptr,\"force\")) {",
          "content_same": false
        },
        {
          "line": 4440,
          "old_api": "nodeFailed",
          "new_api": "addReply",
          "old_text": "nodeFailed(myself->slaveof)",
          "new_text": "addReply(c,shared.syntaxerr)",
          "old_line_content": "                   (nodeFailed(myself->slaveof) ||",
          "new_line_content": "                addReply(c,shared.syntaxerr);",
          "content_same": false
        },
        {
          "line": 4447,
          "old_api": "resetManualFailover",
          "new_api": "addReplyError",
          "old_text": "resetManualFailover()",
          "new_text": "addReplyError(c,\"You should send CLUSTER FAILOVER to a slave\")",
          "old_line_content": "        resetManualFailover();",
          "new_line_content": "            addReplyError(c,\"You should send CLUSTER FAILOVER to a slave\");",
          "content_same": false
        },
        {
          "line": 4456,
          "old_api": "clusterBumpConfigEpochWithoutConsensus",
          "new_api": "addReplyError",
          "old_text": "clusterBumpConfigEpochWithoutConsensus()",
          "new_text": "addReplyError(c,\"Master is down or failed, \"\n                            \"please use CLUSTER FAILOVER FORCE\")",
          "old_line_content": "            clusterBumpConfigEpochWithoutConsensus();",
          "new_line_content": "            addReplyError(c,\"Master is down or failed, \"",
          "content_same": false
        },
        {
          "line": 4468,
          "old_api": "addReply",
          "new_api": "serverLog",
          "old_text": "addReply(c,shared.ok)",
          "new_text": "serverLog(LL_WARNING,\"Taking over the master (user request).\")",
          "old_line_content": "        addReply(c,shared.ok);",
          "new_line_content": "            serverLog(LL_WARNING,\"Taking over the master (user request).\");",
          "content_same": false
        },
        {
          "line": 4469,
          "old_api": "strcasecmp",
          "new_api": "clusterBumpConfigEpochWithoutConsensus",
          "old_text": "strcasecmp(c->argv[1]->ptr,\"set-config-epoch\")",
          "new_text": "clusterBumpConfigEpochWithoutConsensus()",
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"set-config-epoch\") && c->argc == 3)",
          "new_line_content": "            clusterBumpConfigEpochWithoutConsensus();",
          "content_same": false
        },
        {
          "line": 4505,
          "old_api": "strcasecmp",
          "new_api": "serverLog",
          "old_text": "strcasecmp(c->argv[1]->ptr,\"reset\")",
          "new_text": "serverLog(LL_WARNING,\n                \"configEpoch set to %llu via CLUSTER SET-CONFIG-EPOCH\",\n                (unsigned long long) myself->configEpoch)",
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"reset\") &&",
          "new_line_content": "            serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 4518,
          "old_api": "addReply",
          "new_api": "strcasecmp",
          "old_text": "addReply(c,shared.syntaxerr)",
          "new_text": "strcasecmp(c->argv[1]->ptr,\"reset\")",
          "old_line_content": "                addReply(c,shared.syntaxerr);",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"reset\") &&",
          "content_same": false
        },
        {
          "line": 4526,
          "old_api": "addReplyError",
          "new_api": "strcasecmp",
          "old_text": "addReplyError(c,\"CLUSTER RESET can't be called with \"\n                            \"master nodes containing keys\")",
          "new_text": "strcasecmp(c->argv[2]->ptr,\"hard\")",
          "old_line_content": "            addReplyError(c,\"CLUSTER RESET can't be called with \"",
          "new_line_content": "            if (!strcasecmp(c->argv[2]->ptr,\"hard\")) {",
          "content_same": false
        },
        {
          "line": 4563,
          "old_api": "sdscatlen",
          "new_api": "rdbSaveObjectType",
          "old_text": "sdscatlen(payload->io.buffer.ptr,buf,2)",
          "new_text": "rdbSaveObjectType(payload,o)",
          "old_line_content": "    payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,buf,2);",
          "new_line_content": "    serverAssert(rdbSaveObjectType(payload,o));",
          "content_same": false
        },
        {
          "line": 4603,
          "old_api": "lookupKeyRead",
          "new_api": "crc64",
          "old_text": "lookupKeyRead(c->db,c->argv[1])",
          "new_text": "crc64(0,p,len-8)",
          "old_line_content": "    if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {",
          "new_line_content": "    crc = crc64(0,p,len-8);",
          "content_same": false
        },
        {
          "line": 4604,
          "old_api": "addReply",
          "new_api": "memrev64ifbe",
          "old_text": "addReply(c,shared.nullbulk)",
          "new_text": "memrev64ifbe(&crc)",
          "old_line_content": "        addReply(c,shared.nullbulk);",
          "new_line_content": "    memrev64ifbe(&crc);",
          "content_same": false
        },
        {
          "line": 4627,
          "old_api": "strcasecmp",
          "new_api": "decrRefCount",
          "old_text": "strcasecmp(c->argv[j]->ptr,\"replace\")",
          "new_text": "decrRefCount(dumpobj)",
          "old_line_content": "        if (!strcasecmp(c->argv[j]->ptr,\"replace\")) {",
          "new_line_content": "    decrRefCount(dumpobj);",
          "content_same": false
        },
        {
          "line": 4650,
          "old_api": "sdslen",
          "new_api": "addReply",
          "old_text": "sdslen(c->argv[3]->ptr)",
          "new_text": "addReply(c,shared.busykeyerr)",
          "old_line_content": "    if (verifyDumpPayload(c->argv[3]->ptr,sdslen(c->argv[3]->ptr)) == C_ERR)",
          "new_line_content": "        addReply(c,shared.busykeyerr);",
          "content_same": false
        },
        {
          "line": 4658,
          "old_api": "rdbLoadObject",
          "new_api": "addReplyError",
          "old_text": "rdbLoadObject(type,&payload)",
          "new_text": "addReplyError(c,\"Invalid TTL value, must be >= 0\")",
          "old_line_content": "        ((obj = rdbLoadObject(type,&payload)) == NULL))",
          "new_line_content": "        addReplyError(c,\"Invalid TTL value, must be >= 0\");",
          "content_same": false
        },
        {
          "line": 4665,
          "old_api": "dbDelete",
          "new_api": "addReplyError",
          "old_text": "dbDelete(c->db,c->argv[1])",
          "new_text": "addReplyError(c,\"DUMP payload version or checksum are wrong\")",
          "old_line_content": "    if (replace) dbDelete(c->db,c->argv[1]);",
          "new_line_content": "        addReplyError(c,\"DUMP payload version or checksum are wrong\");",
          "content_same": false
        },
        {
          "line": 4669,
          "old_api": "mstime",
          "new_api": "rioInitWithBuffer",
          "old_text": "mstime()",
          "new_text": "rioInitWithBuffer(&payload,c->argv[3]->ptr)",
          "old_line_content": "    if (ttl) setExpire(c,c->db,c->argv[1],mstime()+ttl);",
          "new_line_content": "    rioInitWithBuffer(&payload,c->argv[3]->ptr);",
          "content_same": false
        },
        {
          "line": 4670,
          "old_api": "signalModifiedKey",
          "new_api": "rdbLoadObjectType",
          "old_text": "signalModifiedKey(c->db,c->argv[1])",
          "new_text": "rdbLoadObjectType(&payload)",
          "old_line_content": "    signalModifiedKey(c->db,c->argv[1]);",
          "new_line_content": "    if (((type = rdbLoadObjectType(&payload)) == -1) ||",
          "content_same": false
        },
        {
          "line": 4671,
          "old_api": "addReply",
          "new_api": "rdbLoadObject",
          "old_text": "addReply(c,shared.ok)",
          "new_text": "rdbLoadObject(type,&payload)",
          "old_line_content": "    addReply(c,shared.ok);",
          "new_line_content": "        ((obj = rdbLoadObject(type,&payload)) == NULL))",
          "content_same": false
        },
        {
          "line": 4720,
          "old_api": "dictGetRandomKey",
          "new_api": "sdslen",
          "old_text": "dictGetRandomKey(server.migrate_cached_sockets)",
          "new_text": "sdslen(host->ptr)",
          "old_line_content": "        dictEntry *de = dictGetRandomKey(server.migrate_cached_sockets);",
          "new_line_content": "    name = sdscatlen(name,host->ptr,sdslen(host->ptr));",
          "content_same": false
        },
        {
          "line": 4721,
          "old_api": "dictGetVal",
          "new_api": "sdscatlen",
          "old_text": "dictGetVal(de)",
          "new_text": "sdscatlen(name,\":\",1)",
          "old_line_content": "        cs = dictGetVal(de);",
          "new_line_content": "    name = sdscatlen(name,\":\",1);",
          "content_same": false
        },
        {
          "line": 4722,
          "old_api": "close",
          "new_api": "sdslen",
          "old_text": "close(cs->fd)",
          "new_text": "sdslen(port->ptr)",
          "old_line_content": "        close(cs->fd);",
          "new_line_content": "    name = sdscatlen(name,port->ptr,sdslen(port->ptr));",
          "content_same": false
        },
        {
          "line": 4723,
          "old_api": "zfree",
          "new_api": "dictFetchValue",
          "old_text": "zfree(cs)",
          "new_text": "dictFetchValue(server.migrate_cached_sockets,name)",
          "old_line_content": "        zfree(cs);",
          "new_line_content": "    cs = dictFetchValue(server.migrate_cached_sockets,name);",
          "content_same": false
        },
        {
          "line": 4731,
          "old_api": "sdsfree",
          "new_api": "dictSize",
          "old_text": "sdsfree(name)",
          "new_text": "dictSize(server.migrate_cached_sockets)",
          "old_line_content": "        sdsfree(name);",
          "new_line_content": "    if (dictSize(server.migrate_cached_sockets) == MIGRATE_SOCKET_CACHE_ITEMS) {",
          "content_same": false
        },
        {
          "line": 4736,
          "old_api": "anetEnableTcpNoDelay",
          "new_api": "zfree",
          "old_text": "anetEnableTcpNoDelay(server.neterr,fd)",
          "new_text": "zfree(cs)",
          "old_line_content": "    anetEnableTcpNoDelay(server.neterr,fd);",
          "new_line_content": "        zfree(cs);",
          "content_same": false
        },
        {
          "line": 4741,
          "old_api": "addReplySds",
          "new_api": "anetTcpNonBlockConnect",
          "old_text": "addReplySds(c,\n            sdsnew(\"-IOERR error or timeout connecting to the client\\r\\n\"))",
          "new_text": "anetTcpNonBlockConnect(server.neterr,c->argv[1]->ptr,\n                                atoi(c->argv[2]->ptr))",
          "old_line_content": "        addReplySds(c,",
          "new_line_content": "    fd = anetTcpNonBlockConnect(server.neterr,c->argv[1]->ptr,",
          "content_same": false
        },
        {
          "line": 4742,
          "old_api": "sdsnew",
          "new_api": "atoi",
          "old_text": "sdsnew(\"-IOERR error or timeout connecting to the client\\r\\n\")",
          "new_text": "atoi(c->argv[2]->ptr)",
          "old_line_content": "            sdsnew(\"-IOERR error or timeout connecting to the client\\r\\n\"));",
          "new_line_content": "                                atoi(c->argv[2]->ptr));",
          "content_same": false
        },
        {
          "line": 4752,
          "old_api": "dictAdd",
          "new_api": "aeWait",
          "old_text": "dictAdd(server.migrate_cached_sockets,name,cs)",
          "new_text": "aeWait(fd,AE_WRITABLE,timeout)",
          "old_line_content": "    dictAdd(server.migrate_cached_sockets,name,cs);",
          "new_line_content": "    if ((aeWait(fd,AE_WRITABLE,timeout) & AE_WRITABLE) == 0) {",
          "content_same": false
        },
        {
          "line": 4761,
          "old_api": "sdslen",
          "new_api": "zmalloc",
          "old_text": "sdslen(host->ptr)",
          "new_text": "zmalloc(sizeof(*cs))",
          "old_line_content": "    name = sdscatlen(name,host->ptr,sdslen(host->ptr));",
          "new_line_content": "    cs = zmalloc(sizeof(*cs));",
          "content_same": false
        },
        {
          "line": 4771,
          "old_api": "zfree",
          "new_api": "sdsempty",
          "old_text": "zfree(cs)",
          "new_text": "sdsempty()",
          "old_line_content": "    zfree(cs);",
          "new_line_content": "    sds name = sdsempty();",
          "content_same": false
        },
        {
          "line": 4777,
          "old_api": "dictGetSafeIterator",
          "new_api": "dictFetchValue",
          "old_text": "dictGetSafeIterator(server.migrate_cached_sockets)",
          "new_text": "dictFetchValue(server.migrate_cached_sockets,name)",
          "old_line_content": "    dictIterator *di = dictGetSafeIterator(server.migrate_cached_sockets);",
          "new_line_content": "    cs = dictFetchValue(server.migrate_cached_sockets,name);",
          "content_same": false
        },
        {
          "line": 4784,
          "old_api": "close",
          "new_api": "zfree",
          "old_text": "close(cs->fd)",
          "new_text": "zfree(cs)",
          "old_line_content": "            close(cs->fd);",
          "new_line_content": "    zfree(cs);",
          "content_same": false
        },
        {
          "line": 4785,
          "old_api": "zfree",
          "new_api": "dictDelete",
          "old_text": "zfree(cs)",
          "new_text": "dictDelete(server.migrate_cached_sockets,name)",
          "old_line_content": "            zfree(cs);",
          "new_line_content": "    dictDelete(server.migrate_cached_sockets,name);",
          "content_same": false
        },
        {
          "line": 4786,
          "old_api": "dictGetKey",
          "new_api": "sdsfree",
          "old_text": "dictGetKey(de)",
          "new_text": "sdsfree(name)",
          "old_line_content": "            dictDelete(server.migrate_cached_sockets,dictGetKey(de));",
          "new_line_content": "    sdsfree(name);",
          "content_same": false
        },
        {
          "line": 4835,
          "old_api": "addReply",
          "new_api": "strcasecmp",
          "old_text": "addReply(c,shared.syntaxerr)",
          "new_text": "strcasecmp(c->argv[j]->ptr,\"replace\")",
          "old_line_content": "            addReply(c,shared.syntaxerr);",
          "new_line_content": "        } else if (!strcasecmp(c->argv[j]->ptr,\"replace\")) {",
          "content_same": false
        },
        {
          "line": 4854,
          "old_api": "zrealloc",
          "new_api": "getLongFromObjectOrReply",
          "old_text": "zrealloc(kv,sizeof(robj*)*num_keys)",
          "new_text": "getLongFromObjectOrReply(c,c->argv[5],&timeout,NULL)",
          "old_line_content": "    kv = zrealloc(kv,sizeof(robj*)*num_keys);",
          "new_line_content": "    if (getLongFromObjectOrReply(c,c->argv[5],&timeout,NULL) != C_OK ||",
          "content_same": false
        },
        {
          "line": 4866,
          "old_api": "sdsnew",
          "new_api": "zrealloc",
          "old_text": "sdsnew(\"+NOKEY\\r\\n\")",
          "new_text": "zrealloc(ov,sizeof(robj*)*num_keys)",
          "old_line_content": "        addReplySds(c,sdsnew(\"+NOKEY\\r\\n\"));",
          "new_line_content": "    ov = zrealloc(ov,sizeof(robj*)*num_keys);",
          "content_same": false
        },
        {
          "line": 4887,
          "old_api": "rioWriteBulkLongLong",
          "new_api": "migrateGetSocket",
          "old_text": "rioWriteBulkLongLong(&cmd,dbid)",
          "new_text": "migrateGetSocket(c,c->argv[1],c->argv[2],timeout)",
          "old_line_content": "        serverAssertWithInfo(c,NULL,rioWriteBulkLongLong(&cmd,dbid));",
          "new_line_content": "    cs = migrateGetSocket(c,c->argv[1],c->argv[2],timeout);",
          "content_same": false
        },
        {
          "line": 4893,
          "old_api": "getExpire",
          "new_api": "sdsempty",
          "old_text": "getExpire(c->db,kv[j])",
          "new_text": "sdsempty()",
          "old_line_content": "        long long expireat = getExpire(c->db,kv[j]);",
          "new_line_content": "    rioInitWithBuffer(&cmd,sdsempty());",
          "content_same": false
        },
        {
          "line": 4899,
          "old_api": "rioWriteBulkCount",
          "new_api": "rioWriteBulkString",
          "old_text": "rioWriteBulkCount(&cmd,'*',replace ? 5 : 4)",
          "new_text": "rioWriteBulkString(&cmd,\"SELECT\",6)",
          "old_line_content": "        serverAssertWithInfo(c,NULL,rioWriteBulkCount(&cmd,'*',replace ? 5 : 4));",
          "new_line_content": "        serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,\"SELECT\",6));",
          "content_same": false
        },
        {
          "line": 4906,
          "old_api": "rioWriteBulkString",
          "new_api": "getExpire",
          "old_text": "rioWriteBulkString(&cmd,kv[j]->ptr,\n                sdslen(kv[j]->ptr))",
          "new_text": "getExpire(c->db,kv[j])",
          "old_line_content": "        serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,kv[j]->ptr,",
          "new_line_content": "        long long expireat = getExpire(c->db,kv[j]);",
          "content_same": false
        },
        {
          "line": 4912,
          "old_api": "createDumpPayload",
          "new_api": "rioWriteBulkCount",
          "old_text": "createDumpPayload(&payload,ov[j])",
          "new_text": "rioWriteBulkCount(&cmd,'*',replace ? 5 : 4)",
          "old_line_content": "        createDumpPayload(&payload,ov[j]);",
          "new_line_content": "        serverAssertWithInfo(c,NULL,rioWriteBulkCount(&cmd,'*',replace ? 5 : 4));",
          "content_same": false
        },
        {
          "line": 4914,
          "old_api": "rioWriteBulkString",
          "new_api": "serverAssertWithInfo",
          "old_text": "rioWriteBulkString(&cmd,payload.io.buffer.ptr,\n                               sdslen(payload.io.buffer.ptr))",
          "new_text": "serverAssertWithInfo(c,NULL,\n                rioWriteBulkString(&cmd,\"RESTORE-ASKING\",14))",
          "old_line_content": "            rioWriteBulkString(&cmd,payload.io.buffer.ptr,",
          "new_line_content": "            serverAssertWithInfo(c,NULL,",
          "content_same": false
        },
        {
          "line": 4915,
          "old_api": "sdslen",
          "new_api": "rioWriteBulkString",
          "old_text": "sdslen(payload.io.buffer.ptr)",
          "new_text": "rioWriteBulkString(&cmd,\"RESTORE-ASKING\",14)",
          "old_line_content": "                               sdslen(payload.io.buffer.ptr)));",
          "new_line_content": "                rioWriteBulkString(&cmd,\"RESTORE-ASKING\",14));",
          "content_same": false
        },
        {
          "line": 4921,
          "old_api": "rioWriteBulkString",
          "new_api": "rioWriteBulkLongLong",
          "old_text": "rioWriteBulkString(&cmd,\"REPLACE\",7)",
          "new_text": "rioWriteBulkLongLong(&cmd,ttl)",
          "old_line_content": "            serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,\"REPLACE\",7));",
          "new_line_content": "        serverAssertWithInfo(c,NULL,rioWriteBulkLongLong(&cmd,ttl));",
          "content_same": false
        },
        {
          "line": 4946,
          "old_api": "syncReadLine",
          "new_api": "syncWrite",
          "old_text": "syncReadLine(cs->fd, buf1, sizeof(buf1), timeout)",
          "new_text": "syncWrite(cs->fd,buf+pos,towrite,timeout)",
          "old_line_content": "    if (select && syncReadLine(cs->fd, buf1, sizeof(buf1), timeout) <= 0)",
          "new_line_content": "            nwritten = syncWrite(cs->fd,buf+pos,towrite,timeout);",
          "content_same": false
        },
        {
          "line": 4978,
          "old_api": "incrRefCount",
          "new_api": "addReplyErrorFormat",
          "old_text": "incrRefCount(kv[j])",
          "new_text": "addReplyErrorFormat(c,\"Target instance replied with error: %s\",\n                    (select && buf1[0] == '-') ? buf1+1 : buf2+1)",
          "old_line_content": "                incrRefCount(kv[j]);",
          "new_line_content": "                addReplyErrorFormat(c,\"Target instance replied with error: %s\",",
          "content_same": false
        },
        {
          "line": 5008,
          "old_api": "zfree",
          "new_api": "migrateCloseSocket",
          "old_text": "zfree(newargv)",
          "new_text": "migrateCloseSocket(c->argv[1],c->argv[2])",
          "old_line_content": "            zfree(newargv);",
          "new_line_content": "    if (socket_error) migrateCloseSocket(c->argv[1],c->argv[2]);",
          "content_same": false
        },
        {
          "line": 5064,
          "old_api": "addReplySds",
          "new_api": "migrateCloseSocket",
          "old_text": "addReplySds(c,\n        sdscatprintf(sdsempty(),\n            \"-IOERR error or timeout %s to target instance\\r\\n\",\n            write_error ? \"writing\" : \"reading\"))",
          "new_text": "migrateCloseSocket(c->argv[1],c->argv[2])",
          "old_line_content": "    addReplySds(c,",
          "new_line_content": "    if (!argv_rewritten) migrateCloseSocket(c->argv[1],c->argv[2]);",
          "content_same": false
        },
        {
          "line": 5065,
          "old_api": "sdsempty",
          "new_api": "zfree",
          "old_text": "sdsempty()",
          "new_text": "zfree(newargv)",
          "old_line_content": "        sdscatprintf(sdsempty(),",
          "new_line_content": "    zfree(newargv);",
          "content_same": false
        },
        {
          "line": 5323,
          "old_api": "sdsempty",
          "new_api": "sdsnew",
          "old_text": "sdsempty()",
          "new_text": "sdsnew(\"-CROSSSLOT Keys in request don't hash to the same slot\\r\\n\")",
          "old_line_content": "        addReplySds(c,sdscatprintf(sdsempty(),",
          "new_line_content": "        addReplySds(c,sdsnew(\"-CROSSSLOT Keys in request don't hash to the same slot\\r\\n\"));",
          "content_same": false
        },
        {
          "line": 5328,
          "old_api": "serverPanic",
          "new_api": "sdsnew",
          "old_text": "serverPanic(\"getNodeByQuery() unknown error.\")",
          "new_text": "sdsnew(\"-TRYAGAIN Multiple keys request during rehashing of slot\\r\\n\")",
          "old_line_content": "        serverPanic(\"getNodeByQuery() unknown error.\");",
          "new_line_content": "        addReplySds(c,sdsnew(\"-TRYAGAIN Multiple keys request during rehashing of slot\\r\\n\"));",
          "content_same": false
        },
        {
          "line": 5367,
          "old_api": "clusterRedirectClient",
          "new_api": "dictGetIterator",
          "old_text": "clusterRedirectClient(c,NULL,0,\n                        CLUSTER_REDIR_DOWN_UNBOUND)",
          "new_text": "dictGetIterator(c->bpop.keys)",
          "old_line_content": "                    clusterRedirectClient(c,NULL,0,",
          "new_line_content": "        di = dictGetIterator(c->bpop.keys);",
          "content_same": false
        },
        {
          "line": 5370,
          "old_api": "clusterRedirectClient",
          "new_api": "sdslen",
          "old_text": "clusterRedirectClient(c,node,slot,\n                        CLUSTER_REDIR_MOVED)",
          "new_text": "sdslen(key->ptr)",
          "old_line_content": "                    clusterRedirectClient(c,node,slot,",
          "new_line_content": "            int slot = keyHashSlot((char*)key->ptr, sdslen(key->ptr));",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2048,
          "old_api": null,
          "new_api": "freeClusterLink",
          "old_text": null,
          "new_text": "freeClusterLink(link)",
          "old_line_content": "    if (nwritten <= 0) {",
          "new_line_content": "    freeClusterLink(link);",
          "content_same": false
        },
        {
          "line": 4101,
          "old_api": null,
          "new_api": "clusterDelSlot",
          "old_text": null,
          "new_text": "clusterDelSlot(j)",
          "old_line_content": "        int slot;",
          "new_line_content": "                retval = del ? clusterDelSlot(j) :",
          "content_same": false
        },
        {
          "line": 4102,
          "old_api": null,
          "new_api": "clusterAddSlot",
          "old_text": null,
          "new_text": "clusterAddSlot(myself,j)",
          "old_line_content": "        clusterNode *n;",
          "new_line_content": "                               clusterAddSlot(myself,j);",
          "content_same": false
        },
        {
          "line": 4103,
          "old_api": null,
          "new_api": "serverAssertWithInfo",
          "old_text": null,
          "new_text": "serverAssertWithInfo(c,NULL,retval == C_OK)",
          "old_line_content": "",
          "new_line_content": "                serverAssertWithInfo(c,NULL,retval == C_OK);",
          "content_same": false
        },
        {
          "line": 2057,
          "old_api": null,
          "new_api": "UNUSED",
          "old_text": null,
          "new_text": "UNUSED(el)",
          "old_line_content": "}",
          "new_line_content": "    UNUSED(el);",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": null,
          "new_api": "UNUSED",
          "old_text": null,
          "new_text": "UNUSED(mask)",
          "old_line_content": "",
          "new_line_content": "    UNUSED(mask);",
          "content_same": false
        },
        {
          "line": 4106,
          "old_api": null,
          "new_api": "zfree",
          "old_text": null,
          "new_text": "zfree(slots)",
          "old_line_content": "            return;",
          "new_line_content": "        zfree(slots);",
          "content_same": false
        },
        {
          "line": 2060,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(link->sndbuf)",
          "old_line_content": " * full length of the packet. When a whole packet is in memory this function",
          "new_line_content": "    nwritten = write(fd, link->sndbuf, sdslen(link->sndbuf));",
          "content_same": false
        },
        {
          "line": 4107,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG)",
          "old_line_content": "        }",
          "new_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_DEBUG,\"I/O error writing to node link: %s\",\n            strerror(errno))",
          "old_line_content": "void clusterReadHandler(aeEventLoop *el, int fd, void *privdata, int mask) {",
          "new_line_content": "        serverLog(LL_DEBUG,\"I/O error writing to node link: %s\",",
          "content_same": false
        },
        {
          "line": 2063,
          "old_api": null,
          "new_api": "strerror",
          "old_text": null,
          "new_text": "strerror(errno)",
          "old_line_content": "    char buf[sizeof(clusterMsg)];",
          "new_line_content": "            strerror(errno));",
          "content_same": false
        },
        {
          "line": 2064,
          "old_api": null,
          "new_api": "handleLinkIOError",
          "old_text": null,
          "new_text": "handleLinkIOError(link)",
          "old_line_content": "    ssize_t nread;",
          "new_line_content": "        handleLinkIOError(link);",
          "content_same": false
        },
        {
          "line": 4108,
          "old_api": null,
          "new_api": "addReply",
          "old_text": null,
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": "",
          "new_line_content": "        addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 2067,
          "old_api": null,
          "new_api": "sdsrange",
          "old_text": null,
          "new_text": "sdsrange(link->sndbuf,nwritten,-1)",
          "old_line_content": "    unsigned int readlen, rcvbuflen;",
          "new_line_content": "    sdsrange(link->sndbuf,nwritten,-1);",
          "content_same": false
        },
        {
          "line": 4118,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"Please use SETSLOT only with masters.\")",
          "old_line_content": "                    (char*)c->argv[4]->ptr);",
          "new_line_content": "            addReplyError(c,\"Please use SETSLOT only with masters.\");",
          "content_same": false
        },
        {
          "line": 4126,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\"I'm not the owner of hash slot %u\",slot)",
          "old_line_content": "                return;",
          "new_line_content": "                addReplyErrorFormat(c,\"I'm not the owner of hash slot %u\",slot);",
          "content_same": false
        },
        {
          "line": 2081,
          "old_api": null,
          "new_api": "UNUSED",
          "old_text": null,
          "new_text": "UNUSED(el)",
          "old_line_content": "                /* Perform some sanity check on the message signature",
          "new_line_content": "    UNUSED(el);",
          "content_same": false
        },
        {
          "line": 2082,
          "old_api": null,
          "new_api": "UNUSED",
          "old_text": null,
          "new_text": "UNUSED(mask)",
          "old_line_content": "                 * and length. */",
          "new_line_content": "    UNUSED(mask);",
          "content_same": false
        },
        {
          "line": 4130,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\"I don't know about node %s\",\n                    (char*)c->argv[4]->ptr)",
          "old_line_content": "                    (char*)c->argv[3]->ptr);",
          "new_line_content": "                addReplyErrorFormat(c,\"I don't know about node %s\",",
          "content_same": false
        },
        {
          "line": 2085,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(link->rcvbuf)",
          "old_line_content": "                {",
          "new_line_content": "        rcvbuflen = sdslen(link->rcvbuf);",
          "content_same": false
        },
        {
          "line": 4135,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[3]->ptr,\"importing\")",
          "old_line_content": "            /* CLUSTER SETSLOT <SLOT> STABLE */",
          "new_line_content": "        } else if (!strcasecmp(c->argv[3]->ptr,\"importing\") && c->argc == 5) {",
          "content_same": false
        },
        {
          "line": 4137,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\n                    \"I'm already the owner of hash slot %u\",slot)",
          "old_line_content": "            server.cluster->migrating_slots_to[slot] = NULL;",
          "new_line_content": "                addReplyErrorFormat(c,",
          "content_same": false
        },
        {
          "line": 4141,
          "old_api": null,
          "new_api": "clusterLookupNode",
          "old_text": null,
          "new_text": "clusterLookupNode(c->argv[4]->ptr)",
          "old_line_content": "",
          "new_line_content": "            if ((n = clusterLookupNode(c->argv[4]->ptr)) == NULL) {",
          "content_same": false
        },
        {
          "line": 4142,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\"I don't know about node %s\",\n                    (char*)c->argv[3]->ptr)",
          "old_line_content": "            if (!n) {",
          "new_line_content": "                addReplyErrorFormat(c,\"I don't know about node %s\",",
          "content_same": false
        },
        {
          "line": 2096,
          "old_api": null,
          "new_api": "memcmp",
          "old_text": null,
          "new_text": "memcmp(hdr->sig,\"RCmb\",4)",
          "old_line_content": "",
          "new_line_content": "                if (memcmp(hdr->sig,\"RCmb\",4) != 0 ||",
          "content_same": false
        },
        {
          "line": 2099,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\n                        \"Bad message length or signature received \"\n                        \"from Cluster bus.\")",
          "old_line_content": "",
          "new_line_content": "                    serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 4147,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[3]->ptr,\"stable\")",
          "old_line_content": "            /* If this hash slot was served by 'myself' before to switch",
          "new_line_content": "        } else if (!strcasecmp(c->argv[3]->ptr,\"stable\") && c->argc == 4) {",
          "content_same": false
        },
        {
          "line": 4153,
          "old_api": null,
          "new_api": "clusterLookupNode",
          "old_text": null,
          "new_text": "clusterLookupNode(c->argv[4]->ptr)",
          "old_line_content": "                        \"while I still hold keys for this hash slot.\", slot);",
          "new_line_content": "            clusterNode *n = clusterLookupNode(c->argv[4]->ptr);",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": null,
          "new_api": "ntohl",
          "old_text": null,
          "new_text": "ntohl(hdr->totlen)",
          "old_line_content": "        } else {",
          "new_line_content": "            readlen = ntohl(hdr->totlen) - rcvbuflen;",
          "content_same": false
        },
        {
          "line": 4156,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\"Unknown node %s\",\n                    (char*)c->argv[4]->ptr)",
          "old_line_content": "            }",
          "new_line_content": "                addReplyErrorFormat(c,\"Unknown node %s\",",
          "content_same": false
        },
        {
          "line": 2110,
          "old_api": null,
          "new_api": "read",
          "old_text": null,
          "new_text": "read(fd,buf,readlen)",
          "old_line_content": "            rcvbuflen += nread;",
          "new_line_content": "        nread = read(fd,buf,readlen);",
          "content_same": false
        },
        {
          "line": 4163,
          "old_api": null,
          "new_api": "countKeysInSlot",
          "old_text": null,
          "new_text": "countKeysInSlot(slot)",
          "old_line_content": "",
          "new_line_content": "                if (countKeysInSlot(slot) != 0) {",
          "content_same": false
        },
        {
          "line": 4164,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\n                        \"Can't assign hashslot %d to a different node \"\n                        \"while I still hold keys for this hash slot.\", slot)",
          "old_line_content": "            /* If this node was importing this slot, assigning the slot to",
          "new_line_content": "                    addReplyErrorFormat(c,",
          "content_same": false
        },
        {
          "line": 2121,
          "old_api": null,
          "new_api": "sdscatlen",
          "old_text": null,
          "new_text": "sdscatlen(link->rcvbuf,buf,nread)",
          "old_line_content": "        }",
          "new_line_content": "            link->rcvbuf = sdscatlen(link->rcvbuf,buf,nread);",
          "content_same": false
        },
        {
          "line": 4173,
          "old_api": null,
          "new_api": "countKeysInSlot",
          "old_text": null,
          "new_text": "countKeysInSlot(slot)",
          "old_line_content": "                 * Note that if this ever results in a collision with another",
          "new_line_content": "            if (countKeysInSlot(slot) == 0 &&",
          "content_same": false
        },
        {
          "line": 2127,
          "old_api": null,
          "new_api": "ntohl",
          "old_text": null,
          "new_text": "ntohl(hdr->totlen)",
          "old_line_content": " * It is guaranteed that this function will never have as a side effect",
          "new_line_content": "        if (rcvbuflen >= 8 && rcvbuflen == ntohl(hdr->totlen)) {",
          "content_same": false
        },
        {
          "line": 2128,
          "old_api": null,
          "new_api": "clusterProcessPacket",
          "old_text": null,
          "new_text": "clusterProcessPacket(link)",
          "old_line_content": " * the link to be invalidated, so it is safe to call this function",
          "new_line_content": "            if (clusterProcessPacket(link)) {",
          "content_same": false
        },
        {
          "line": 2129,
          "old_api": null,
          "new_api": "sdsfree",
          "old_text": null,
          "new_text": "sdsfree(link->rcvbuf)",
          "old_line_content": " * from event handlers that will do stuff with the same link later. */",
          "new_line_content": "                sdsfree(link->rcvbuf);",
          "content_same": false
        },
        {
          "line": 2130,
          "old_api": null,
          "new_api": "sdsempty",
          "old_text": null,
          "new_text": "sdsempty()",
          "old_line_content": "void clusterSendMessage(clusterLink *link, unsigned char *msg, size_t msglen) {",
          "new_line_content": "                link->rcvbuf = sdsempty();",
          "content_same": false
        },
        {
          "line": 2144,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(link->sndbuf)",
          "old_line_content": "/* Send a message to all the nodes that are part of the cluster having",
          "new_line_content": "    if (sdslen(link->sndbuf) == 0 && msglen != 0)",
          "content_same": false
        },
        {
          "line": 2145,
          "old_api": null,
          "new_api": "aeCreateFileEvent",
          "old_text": null,
          "new_text": "aeCreateFileEvent(server.el,link->fd,AE_WRITABLE,\n                    clusterWriteHandler,link)",
          "old_line_content": " * a connected link.",
          "new_line_content": "        aeCreateFileEvent(server.el,link->fd,AE_WRITABLE,",
          "content_same": false
        },
        {
          "line": 2148,
          "old_api": null,
          "new_api": "sdscatlen",
          "old_text": null,
          "new_text": "sdscatlen(link->sndbuf, msg, msglen)",
          "old_line_content": " * some node->link to be invalidated, so it is safe to call this function",
          "new_line_content": "    link->sndbuf = sdscatlen(link->sndbuf, msg, msglen);",
          "content_same": false
        },
        {
          "line": 4197,
          "old_api": null,
          "new_api": "clusterDelSlot",
          "old_text": null,
          "new_text": "clusterDelSlot(slot)",
          "old_line_content": "                (retval == C_OK) ? \"BUMPED\" : \"STILL\",",
          "new_line_content": "            clusterDelSlot(slot);",
          "content_same": false
        },
        {
          "line": 4198,
          "old_api": null,
          "new_api": "clusterAddSlot",
          "old_text": null,
          "new_text": "clusterAddSlot(n,slot)",
          "old_line_content": "                (unsigned long long) myself->configEpoch);",
          "new_line_content": "            clusterAddSlot(n,slot);",
          "content_same": false
        },
        {
          "line": 2152,
          "old_api": null,
          "new_api": "ntohs",
          "old_text": null,
          "new_text": "ntohs(hdr->type)",
          "old_line_content": "    dictEntry *de;",
          "new_line_content": "    uint16_t type = ntohs(hdr->type);",
          "content_same": false
        },
        {
          "line": 4204,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_UPDATE_STATE)",
          "old_line_content": "        uint64_t myepoch;",
          "new_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_UPDATE_STATE);",
          "content_same": false
        },
        {
          "line": 4205,
          "old_api": null,
          "new_api": "addReply",
          "old_text": null,
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": "        int j;",
          "new_line_content": "        addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 4206,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[1]->ptr,\"bumpepoch\")",
          "old_line_content": "",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"bumpepoch\") && c->argc == 2) {",
          "content_same": false
        },
        {
          "line": 4208,
          "old_api": null,
          "new_api": "clusterBumpConfigEpochWithoutConsensus",
          "old_text": null,
          "new_text": "clusterBumpConfigEpochWithoutConsensus()",
          "old_line_content": "            clusterNode *n = server.cluster->slots[j];",
          "new_line_content": "        int retval = clusterBumpConfigEpochWithoutConsensus();",
          "content_same": false
        },
        {
          "line": 4209,
          "old_api": null,
          "new_api": "sdsempty",
          "old_text": null,
          "new_text": "sdsempty()",
          "old_line_content": "",
          "new_line_content": "        sds reply = sdscatprintf(sdsempty(),\"+%s %llu\\r\\n\",",
          "content_same": false
        },
        {
          "line": 4213,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[1]->ptr,\"info\")",
          "old_line_content": "                slots_fail++;",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"info\") && c->argc == 2) {",
          "content_same": false
        },
        {
          "line": 2167,
          "old_api": null,
          "new_api": "dictGetSafeIterator",
          "old_text": null,
          "new_text": "dictGetSafeIterator(server.cluster->nodes)",
          "old_line_content": " * sizeof(clusterMsg) in bytes. */",
          "new_line_content": "    di = dictGetSafeIterator(server.cluster->nodes);",
          "content_same": false
        },
        {
          "line": 2168,
          "old_api": null,
          "new_api": "dictNext",
          "old_text": null,
          "new_text": "dictNext(di)",
          "old_line_content": "void clusterBuildMessageHdr(clusterMsg *hdr, int type) {",
          "new_line_content": "    while((de = dictNext(di)) != NULL) {",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": null,
          "new_api": "dictGetVal",
          "old_text": null,
          "new_text": "dictGetVal(de)",
          "old_line_content": "    int totlen = 0;",
          "new_line_content": "        clusterNode *node = dictGetVal(de);",
          "content_same": false
        },
        {
          "line": 2174,
          "old_api": null,
          "new_api": "clusterSendMessage",
          "old_text": null,
          "new_text": "clusterSendMessage(node->link,buf,len)",
          "old_line_content": "     * If this node is a slave we send the master's information instead (the",
          "new_line_content": "        clusterSendMessage(node->link,buf,len);",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": null,
          "new_api": "dictReleaseIterator",
          "old_text": null,
          "new_text": "dictReleaseIterator(di)",
          "old_line_content": "     * in charge for this slots. */",
          "new_line_content": "    dictReleaseIterator(di);",
          "content_same": false
        },
        {
          "line": 4225,
          "old_api": null,
          "new_api": "nodeFailed",
          "old_text": null,
          "new_text": "nodeFailed(n)",
          "old_line_content": "            \"cluster_state:%s\\r\\n\"",
          "new_line_content": "            if (nodeFailed(n)) {",
          "content_same": false
        },
        {
          "line": 4227,
          "old_api": null,
          "new_api": "nodeTimedOut",
          "old_text": null,
          "new_text": "nodeTimedOut(n)",
          "old_line_content": "            \"cluster_slots_ok:%d\\r\\n\"",
          "new_line_content": "            } else if (nodeTimedOut(n)) {",
          "content_same": false
        },
        {
          "line": 4234,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(myself)",
          "old_line_content": "            , statestr[server.cluster->state],",
          "new_line_content": "        myepoch = (nodeIsSlave(myself) && myself->slaveof) ?",
          "content_same": false
        },
        {
          "line": 4237,
          "old_api": null,
          "new_api": "sdsempty",
          "old_text": null,
          "new_text": "sdsempty()",
          "old_line_content": "            slots_pfail,",
          "new_line_content": "        sds info = sdscatprintf(sdsempty(),",
          "content_same": false
        },
        {
          "line": 2190,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(myself)",
          "old_line_content": "     * packets to use the specified address for this node. Otherwise if the",
          "new_line_content": "    master = (nodeIsSlave(myself) && myself->slaveof) ?",
          "content_same": false
        },
        {
          "line": 2193,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(hdr,0,sizeof(*hdr))",
          "old_line_content": "    if (server.cluster_announce_ip) {",
          "new_line_content": "    memset(hdr,0,sizeof(*hdr));",
          "content_same": false
        },
        {
          "line": 2199,
          "old_api": null,
          "new_api": "htons",
          "old_text": null,
          "new_text": "htons(type)",
          "old_line_content": "    int announced_port = server.cluster_announce_port ?",
          "new_line_content": "    hdr->type = htons(type);",
          "content_same": false
        },
        {
          "line": 2200,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(hdr->sender,myself->name,CLUSTER_NAMELEN)",
          "old_line_content": "                         server.cluster_announce_port : server.port;",
          "new_line_content": "    memcpy(hdr->sender,myself->name,CLUSTER_NAMELEN);",
          "content_same": false
        },
        {
          "line": 2207,
          "old_api": null,
          "new_api": "strncpy",
          "old_text": null,
          "new_text": "strncpy(hdr->myip,server.cluster_announce_ip,NET_IP_STR_LEN)",
          "old_line_content": "    if (myself->slaveof != NULL)",
          "new_line_content": "        strncpy(hdr->myip,server.cluster_announce_ip,NET_IP_STR_LEN);",
          "content_same": false
        },
        {
          "line": 2218,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(hdr->myslots,master->slots,sizeof(hdr->myslots))",
          "old_line_content": "    /* Set the replication offset. */",
          "new_line_content": "    memcpy(hdr->myslots,master->slots,sizeof(hdr->myslots));",
          "content_same": false
        },
        {
          "line": 4267,
          "old_api": null,
          "new_api": "clusterGetMessageTypeString",
          "old_text": null,
          "new_text": "clusterGetMessageTypeString(i)",
          "old_line_content": "        }",
          "new_line_content": "                clusterGetMessageTypeString(i),",
          "content_same": false
        },
        {
          "line": 2221,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(hdr->slaveof,myself->slaveof->name, CLUSTER_NAMELEN)",
          "old_line_content": "    else",
          "new_line_content": "        memcpy(hdr->slaveof,myself->slaveof->name, CLUSTER_NAMELEN);",
          "content_same": false
        },
        {
          "line": 2222,
          "old_api": null,
          "new_api": "htons",
          "old_text": null,
          "new_text": "htons(announced_port)",
          "old_line_content": "        offset = server.master_repl_offset;",
          "new_line_content": "    hdr->port = htons(announced_port);",
          "content_same": false
        },
        {
          "line": 4270,
          "old_api": null,
          "new_api": "sdscatprintf",
          "old_text": null,
          "new_text": "sdscatprintf(info,\n            \"cluster_stats_messages_sent:%lld\\r\\n\", tot_msg_sent)",
          "old_line_content": "",
          "new_line_content": "        info = sdscatprintf(info,",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": null,
          "new_api": "htons",
          "old_text": null,
          "new_text": "htons(myself->flags)",
          "old_line_content": "",
          "new_line_content": "    hdr->flags = htons(myself->flags);",
          "content_same": false
        },
        {
          "line": 2228,
          "old_api": null,
          "new_api": "htonu64",
          "old_text": null,
          "new_text": "htonu64(server.cluster->currentEpoch)",
          "old_line_content": "",
          "new_line_content": "    hdr->currentEpoch = htonu64(server.cluster->currentEpoch);",
          "content_same": false
        },
        {
          "line": 2229,
          "old_api": null,
          "new_api": "htonu64",
          "old_text": null,
          "new_text": "htonu64(master->configEpoch)",
          "old_line_content": "    /* Compute the message length for certain messages. For other messages",
          "new_line_content": "    hdr->configEpoch = htonu64(master->configEpoch);",
          "content_same": false
        },
        {
          "line": 4278,
          "old_api": null,
          "new_api": "clusterGetMessageTypeString",
          "old_text": null,
          "new_text": "clusterGetMessageTypeString(i)",
          "old_line_content": "",
          "new_line_content": "                clusterGetMessageTypeString(i),",
          "content_same": false
        },
        {
          "line": 2232,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(myself)",
          "old_line_content": "        totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);",
          "new_line_content": "    if (nodeIsSlave(myself))",
          "content_same": false
        },
        {
          "line": 2233,
          "old_api": null,
          "new_api": "replicationGetSlaveOffset",
          "old_text": null,
          "new_text": "replicationGetSlaveOffset()",
          "old_line_content": "        totlen += sizeof(clusterMsgDataFail);",
          "new_line_content": "        offset = replicationGetSlaveOffset();",
          "content_same": false
        },
        {
          "line": 4281,
          "old_api": null,
          "new_api": "sdscatprintf",
          "old_text": null,
          "new_text": "sdscatprintf(info,\n            \"cluster_stats_messages_received:%lld\\r\\n\", tot_msg_received)",
          "old_line_content": "        else",
          "new_line_content": "        info = sdscatprintf(info,",
          "content_same": false
        },
        {
          "line": 2236,
          "old_api": null,
          "new_api": "htonu64",
          "old_text": null,
          "new_text": "htonu64(offset)",
          "old_line_content": "        totlen += sizeof(clusterMsgDataUpdate);",
          "new_line_content": "    hdr->offset = htonu64(offset);",
          "content_same": false
        },
        {
          "line": 4285,
          "old_api": null,
          "new_api": "sdsempty",
          "old_text": null,
          "new_text": "sdsempty()",
          "old_line_content": "        /* CLUSTER KEYSLOT <key> */",
          "new_line_content": "        addReplySds(c,sdscatprintf(sdsempty(),\"$%lu\\r\\n\",",
          "content_same": false
        },
        {
          "line": 4286,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(info)",
          "old_line_content": "        sds key = c->argv[2]->ptr;",
          "new_line_content": "            (unsigned long)sdslen(info)));",
          "content_same": false
        },
        {
          "line": 2239,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(myself)",
          "old_line_content": "    /* For PING, PONG, and MEET, fixing the totlen field is up to the caller. */",
          "new_line_content": "    if (nodeIsMaster(myself) && server.cluster->mf_end)",
          "content_same": false
        },
        {
          "line": 4287,
          "old_api": null,
          "new_api": "addReplySds",
          "old_text": null,
          "new_text": "addReplySds(c,info)",
          "old_line_content": "",
          "new_line_content": "        addReplySds(c,info);",
          "content_same": false
        },
        {
          "line": 4290,
          "old_api": null,
          "new_api": "clusterSaveConfig",
          "old_text": null,
          "new_text": "clusterSaveConfig(1)",
          "old_line_content": "        /* CLUSTER COUNTKEYSINSLOT <slot> */",
          "new_line_content": "        int retval = clusterSaveConfig(1);",
          "content_same": false
        },
        {
          "line": 4295,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\"error saving the cluster node config: %s\",\n                strerror(errno))",
          "old_line_content": "        if (slot < 0 || slot >= CLUSTER_SLOTS) {",
          "new_line_content": "            addReplyErrorFormat(c,\"error saving the cluster node config: %s\",",
          "content_same": false
        },
        {
          "line": 4297,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[1]->ptr,\"keyslot\")",
          "old_line_content": "            return;",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"keyslot\") && c->argc == 3) {",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": null,
          "new_api": "htonl",
          "old_text": null,
          "new_text": "htonl(totlen)",
          "old_line_content": "     * nodes available minus two (ourself and the node we are sending the",
          "new_line_content": "    hdr->totlen = htonl(totlen);",
          "content_same": false
        },
        {
          "line": 4301,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(key)",
          "old_line_content": "        /* CLUSTER GETKEYSINSLOT <slot> <count> */",
          "new_line_content": "        addReplyLongLong(c,keyHashSlot(key,sdslen(key)));",
          "content_same": false
        },
        {
          "line": 4302,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[1]->ptr,\"countkeysinslot\")",
          "old_line_content": "        long long maxkeys, slot;",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"countkeysinslot\") && c->argc == 3) {",
          "content_same": false
        },
        {
          "line": 4309,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"Invalid slot\")",
          "old_line_content": "            != C_OK)",
          "new_line_content": "            addReplyError(c,\"Invalid slot\");",
          "content_same": false
        },
        {
          "line": 4313,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[1]->ptr,\"getkeysinslot\")",
          "old_line_content": "            return;",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"getkeysinslot\") && c->argc == 4) {",
          "content_same": false
        },
        {
          "line": 2267,
          "old_api": null,
          "new_api": "dictSize",
          "old_text": null,
          "new_text": "dictSize(server.cluster->nodes)",
          "old_line_content": "     * PROB * GOSSIP_ENTRIES_PER_PACKET * TOTAL_PACKETS:",
          "new_line_content": "    int freshnodes = dictSize(server.cluster->nodes)-2;",
          "content_same": false
        },
        {
          "line": 4319,
          "old_api": null,
          "new_api": "getLongLongFromObjectOrReply",
          "old_text": null,
          "new_text": "getLongLongFromObjectOrReply(c,c->argv[2],&slot,NULL)",
          "old_line_content": "        for (j = 0; j < numkeys; j++) {",
          "new_line_content": "        if (getLongLongFromObjectOrReply(c,c->argv[2],&slot,NULL) != C_OK)",
          "content_same": false
        },
        {
          "line": 4325,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"Invalid slot or number of keys\")",
          "old_line_content": "        /* CLUSTER FORGET <NODE ID> */",
          "new_line_content": "            addReplyError(c,\"Invalid slot or number of keys\");",
          "content_same": false
        },
        {
          "line": 4330,
          "old_api": null,
          "new_api": "getKeysInSlot",
          "old_text": null,
          "new_text": "getKeysInSlot(slot, keys, maxkeys)",
          "old_line_content": "            return;",
          "new_line_content": "        numkeys = getKeysInSlot(slot, keys, maxkeys);",
          "content_same": false
        },
        {
          "line": 4331,
          "old_api": null,
          "new_api": "addReplyMultiBulkLen",
          "old_text": null,
          "new_text": "addReplyMultiBulkLen(c,numkeys)",
          "old_line_content": "        } else if (n == myself) {",
          "new_line_content": "        addReplyMultiBulkLen(c,numkeys);",
          "content_same": false
        },
        {
          "line": 4333,
          "old_api": null,
          "new_api": "addReplyBulk",
          "old_text": null,
          "new_text": "addReplyBulk(c,keys[j])",
          "old_line_content": "            return;",
          "new_line_content": "            addReplyBulk(c,keys[j]);",
          "content_same": false
        },
        {
          "line": 4336,
          "old_api": null,
          "new_api": "zfree",
          "old_text": null,
          "new_text": "zfree(keys)",
          "old_line_content": "            return;",
          "new_line_content": "        zfree(keys);",
          "content_same": false
        },
        {
          "line": 4337,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[1]->ptr,\"forget\")",
          "old_line_content": "        }",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"forget\") && c->argc == 3) {",
          "content_same": false
        },
        {
          "line": 2295,
          "old_api": null,
          "new_api": "dictSize",
          "old_text": null,
          "new_text": "dictSize(server.cluster->nodes)",
          "old_line_content": "    hdr = (clusterMsg*) buf;",
          "new_line_content": "    wanted = floor(dictSize(server.cluster->nodes)/10);",
          "content_same": false
        },
        {
          "line": 4347,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(myself)",
          "old_line_content": "        /* Lookup the specified node in our table. */",
          "new_line_content": "        } else if (nodeIsSlave(myself) && myself->slaveof == n) {",
          "content_same": false
        },
        {
          "line": 4348,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"Can't forget my master!\")",
          "old_line_content": "        if (!n) {",
          "new_line_content": "            addReplyError(c,\"Can't forget my master!\");",
          "content_same": false
        },
        {
          "line": 4351,
          "old_api": null,
          "new_api": "clusterBlacklistAddNode",
          "old_text": null,
          "new_text": "clusterBlacklistAddNode(n)",
          "old_line_content": "        }",
          "new_line_content": "        clusterBlacklistAddNode(n);",
          "content_same": false
        },
        {
          "line": 4352,
          "old_api": null,
          "new_api": "clusterDelNode",
          "old_text": null,
          "new_text": "clusterDelNode(n)",
          "old_line_content": "",
          "new_line_content": "        clusterDelNode(n);",
          "content_same": false
        },
        {
          "line": 4353,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|\n                             CLUSTER_TODO_SAVE_CONFIG)",
          "old_line_content": "        /* I can't replicate myself. */",
          "new_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|",
          "content_same": false
        },
        {
          "line": 2307,
          "old_api": null,
          "new_api": "zcalloc",
          "old_text": null,
          "new_text": "zcalloc(totlen)",
          "old_line_content": "        clusterMsgDataGossip *gossip;",
          "new_line_content": "    buf = zcalloc(totlen);",
          "content_same": false
        },
        {
          "line": 4356,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[1]->ptr,\"replicate\")",
          "old_line_content": "            return;",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"replicate\") && c->argc == 3) {",
          "content_same": false
        },
        {
          "line": 4358,
          "old_api": null,
          "new_api": "clusterLookupNode",
          "old_text": null,
          "new_text": "clusterLookupNode(c->argv[2]->ptr)",
          "old_line_content": "",
          "new_line_content": "        clusterNode *n = clusterLookupNode(c->argv[2]->ptr);",
          "content_same": false
        },
        {
          "line": 2312,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "        if (this == myself) continue;",
          "new_line_content": "        link->node->ping_sent = mstime();",
          "content_same": false
        },
        {
          "line": 2313,
          "old_api": null,
          "new_api": "clusterBuildMessageHdr",
          "old_text": null,
          "new_text": "clusterBuildMessageHdr(hdr,type)",
          "old_line_content": "",
          "new_line_content": "    clusterBuildMessageHdr(hdr,type);",
          "content_same": false
        },
        {
          "line": 4362,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr)",
          "old_line_content": "            return;",
          "new_line_content": "            addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr);",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": null,
          "new_api": "dictGetRandomKey",
          "old_text": null,
          "new_text": "dictGetRandomKey(server.cluster->nodes)",
          "old_line_content": "",
          "new_line_content": "        dictEntry *de = dictGetRandomKey(server.cluster->nodes);",
          "content_same": false
        },
        {
          "line": 2319,
          "old_api": null,
          "new_api": "dictGetVal",
          "old_text": null,
          "new_text": "dictGetVal(de)",
          "old_line_content": "        /* In the gossip section don't include:",
          "new_line_content": "        clusterNode *this = dictGetVal(de);",
          "content_same": false
        },
        {
          "line": 4373,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(n)",
          "old_line_content": "            return;",
          "new_line_content": "        if (nodeIsSlave(n)) {",
          "content_same": false
        },
        {
          "line": 4374,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"I can only replicate a master, not a slave.\")",
          "old_line_content": "        }",
          "new_line_content": "            addReplyError(c,\"I can only replicate a master, not a slave.\");",
          "content_same": false
        },
        {
          "line": 4381,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(myself)",
          "old_line_content": "        /* CLUSTER SLAVES <NODE ID> */",
          "new_line_content": "        if (nodeIsMaster(myself) &&",
          "content_same": false
        },
        {
          "line": 4383,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\n                \"To set a master the node must be empty and \"\n                \"without assigned slots.\")",
          "old_line_content": "        int j;",
          "new_line_content": "            addReplyError(c,",
          "content_same": false
        },
        {
          "line": 4390,
          "old_api": null,
          "new_api": "clusterSetMaster",
          "old_text": null,
          "new_text": "clusterSetMaster(n)",
          "old_line_content": "",
          "new_line_content": "        clusterSetMaster(n);",
          "content_same": false
        },
        {
          "line": 4393,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[1]->ptr,\"slaves\")",
          "old_line_content": "            return;",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"slaves\") && c->argc == 3) {",
          "content_same": false
        },
        {
          "line": 4395,
          "old_api": null,
          "new_api": "clusterLookupNode",
          "old_text": null,
          "new_text": "clusterLookupNode(c->argv[2]->ptr)",
          "old_line_content": "",
          "new_line_content": "        clusterNode *n = clusterLookupNode(c->argv[2]->ptr);",
          "content_same": false
        },
        {
          "line": 2354,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(gossip->nodename,this->name,CLUSTER_NAMELEN)",
          "old_line_content": "    totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);",
          "new_line_content": "        memcpy(gossip->nodename,this->name,CLUSTER_NAMELEN);",
          "content_same": false
        },
        {
          "line": 2355,
          "old_api": null,
          "new_api": "htonl",
          "old_text": null,
          "new_text": "htonl(this->ping_sent)",
          "old_line_content": "    totlen += (sizeof(clusterMsgDataGossip)*gossipcount);",
          "new_line_content": "        gossip->ping_sent = htonl(this->ping_sent);",
          "content_same": false
        },
        {
          "line": 4404,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(n)",
          "old_line_content": "    {",
          "new_line_content": "        if (nodeIsSlave(n)) {",
          "content_same": false
        },
        {
          "line": 4405,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"The specified node is not a master\")",
          "old_line_content": "        /* CLUSTER COUNT-FAILURE-REPORTS <NODE ID> */",
          "new_line_content": "            addReplyError(c,\"The specified node is not a master\");",
          "content_same": false
        },
        {
          "line": 2360,
          "old_api": null,
          "new_api": "htons",
          "old_text": null,
          "new_text": "htons(this->flags)",
          "old_line_content": "}",
          "new_line_content": "        gossip->flags = htons(this->flags);",
          "content_same": false
        },
        {
          "line": 4411,
          "old_api": null,
          "new_api": "clusterGenNodeDescription",
          "old_text": null,
          "new_text": "clusterGenNodeDescription(n->slaves[j])",
          "old_line_content": "        } else {",
          "new_line_content": "            sds ni = clusterGenNodeDescription(n->slaves[j]);",
          "content_same": false
        },
        {
          "line": 4413,
          "old_api": null,
          "new_api": "sdsfree",
          "old_text": null,
          "new_text": "sdsfree(ni)",
          "old_line_content": "        }",
          "new_line_content": "            sdsfree(ni);",
          "content_same": false
        },
        {
          "line": 4415,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[1]->ptr,\"count-failure-reports\")",
          "old_line_content": "               (c->argc == 2 || c->argc == 3))",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"count-failure-reports\") &&",
          "content_same": false
        },
        {
          "line": 2369,
          "old_api": null,
          "new_api": "htons",
          "old_text": null,
          "new_text": "htons(gossipcount)",
          "old_line_content": " *",
          "new_line_content": "    hdr->count = htons(gossipcount);",
          "content_same": false
        },
        {
          "line": 2370,
          "old_api": null,
          "new_api": "htonl",
          "old_text": null,
          "new_text": "htonl(totlen)",
          "old_line_content": " * The 'target' argument specifies the receiving instances using the",
          "new_line_content": "    hdr->totlen = htonl(totlen);",
          "content_same": false
        },
        {
          "line": 2371,
          "old_api": null,
          "new_api": "clusterSendMessage",
          "old_text": null,
          "new_text": "clusterSendMessage(link,buf,totlen)",
          "old_line_content": " * defines below:",
          "new_line_content": "    clusterSendMessage(link,buf,totlen);",
          "content_same": false
        },
        {
          "line": 2372,
          "old_api": null,
          "new_api": "zfree",
          "old_text": null,
          "new_text": "zfree(buf)",
          "old_line_content": " *",
          "new_line_content": "    zfree(buf);",
          "content_same": false
        },
        {
          "line": 4419,
          "old_api": null,
          "new_api": "clusterLookupNode",
          "old_text": null,
          "new_text": "clusterLookupNode(c->argv[2]->ptr)",
          "old_line_content": "",
          "new_line_content": "        clusterNode *n = clusterLookupNode(c->argv[2]->ptr);",
          "content_same": false
        },
        {
          "line": 4422,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr)",
          "old_line_content": "                force = 1;",
          "new_line_content": "            addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr);",
          "content_same": false
        },
        {
          "line": 4425,
          "old_api": null,
          "new_api": "clusterNodeFailureReportsCount",
          "old_text": null,
          "new_text": "clusterNodeFailureReportsCount(n)",
          "old_line_content": "                force = 1; /* Takeover also implies force. */",
          "new_line_content": "            addReplyLongLong(c,clusterNodeFailureReportsCount(n));",
          "content_same": false
        },
        {
          "line": 4436,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[2]->ptr,\"takeover\")",
          "old_line_content": "        } else if (myself->slaveof == NULL) {",
          "new_line_content": "            } else if (!strcasecmp(c->argv[2]->ptr,\"takeover\")) {",
          "content_same": false
        },
        {
          "line": 2395,
          "old_api": null,
          "new_api": "dictGetSafeIterator",
          "old_text": null,
          "new_text": "dictGetSafeIterator(server.cluster->nodes)",
          "old_line_content": "    }",
          "new_line_content": "    di = dictGetSafeIterator(server.cluster->nodes);",
          "content_same": false
        },
        {
          "line": 2397,
          "old_api": null,
          "new_api": "dictGetVal",
          "old_text": null,
          "new_text": "dictGetVal(de)",
          "old_line_content": "}",
          "new_line_content": "        clusterNode *node = dictGetVal(de);",
          "content_same": false
        },
        {
          "line": 4446,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(myself)",
          "old_line_content": "        }",
          "new_line_content": "        if (nodeIsMaster(myself)) {",
          "content_same": false
        },
        {
          "line": 2400,
          "old_api": null,
          "new_api": "nodeInHandshake",
          "old_text": null,
          "new_text": "nodeInHandshake(node)",
          "old_line_content": " *",
          "new_line_content": "        if (node == myself || nodeInHandshake(node)) continue;",
          "content_same": false
        },
        {
          "line": 4450,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"I'm a slave but my master is unknown to me\")",
          "old_line_content": "        if (takeover) {",
          "new_line_content": "            addReplyError(c,\"I'm a slave but my master is unknown to me\");",
          "content_same": false
        },
        {
          "line": 2403,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(node)",
          "old_line_content": "    unsigned char buf[sizeof(clusterMsg)], *payload;",
          "new_line_content": "                nodeIsSlave(node) && node->slaveof &&",
          "content_same": false
        },
        {
          "line": 4453,
          "old_api": null,
          "new_api": "nodeFailed",
          "old_text": null,
          "new_text": "nodeFailed(myself->slaveof)",
          "old_line_content": "             * consensus, claims the master's slots, and broadcast the new",
          "new_line_content": "                   (nodeFailed(myself->slaveof) ||",
          "content_same": false
        },
        {
          "line": 2407,
          "old_api": null,
          "new_api": "clusterSendPing",
          "old_text": null,
          "new_text": "clusterSendPing(node->link,CLUSTERMSG_TYPE_PONG)",
          "old_line_content": "",
          "new_line_content": "        clusterSendPing(node->link,CLUSTERMSG_TYPE_PONG);",
          "content_same": false
        },
        {
          "line": 4460,
          "old_api": null,
          "new_api": "resetManualFailover",
          "old_text": null,
          "new_text": "resetManualFailover()",
          "old_line_content": "             * master to agree about the offset. We just failover taking over",
          "new_line_content": "        resetManualFailover();",
          "content_same": false
        },
        {
          "line": 4461,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "             * it without coordination. */",
          "new_line_content": "        server.cluster->mf_end = mstime() + CLUSTER_MF_TIMEOUT;",
          "content_same": false
        },
        {
          "line": 2421,
          "old_api": null,
          "new_api": "getDecodedObject",
          "old_text": null,
          "new_text": "getDecodedObject(channel)",
          "old_line_content": "    /* Try to use the local buffer if possible */",
          "new_line_content": "    channel = getDecodedObject(channel);",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": null,
          "new_api": "getDecodedObject",
          "old_text": null,
          "new_text": "getDecodedObject(message)",
          "old_line_content": "    if (totlen < sizeof(buf)) {",
          "new_line_content": "    message = getDecodedObject(message);",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(channel->ptr)",
          "old_line_content": "        payload = buf;",
          "new_line_content": "    channel_len = sdslen(channel->ptr);",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(message->ptr)",
          "old_line_content": "    } else {",
          "new_line_content": "    message_len = sdslen(message->ptr);",
          "content_same": false
        },
        {
          "line": 4470,
          "old_api": null,
          "new_api": "clusterFailoverReplaceYourMaster",
          "old_text": null,
          "new_text": "clusterFailoverReplaceYourMaster()",
          "old_line_content": "    {",
          "new_line_content": "            clusterFailoverReplaceYourMaster();",
          "content_same": false
        },
        {
          "line": 4475,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\"Forced failover user request accepted.\")",
          "old_line_content": "         * This happens at cluster creation time to start with a cluster where",
          "new_line_content": "            serverLog(LL_WARNING,\"Forced failover user request accepted.\");",
          "content_same": false
        },
        {
          "line": 4478,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\"Manual failover user request accepted.\")",
          "old_line_content": "        long long epoch;",
          "new_line_content": "            serverLog(LL_WARNING,\"Manual failover user request accepted.\");",
          "content_same": false
        },
        {
          "line": 4479,
          "old_api": null,
          "new_api": "clusterSendMFStart",
          "old_text": null,
          "new_text": "clusterSendMFStart(myself->slaveof)",
          "old_line_content": "",
          "new_line_content": "            clusterSendMFStart(myself->slaveof);",
          "content_same": false
        },
        {
          "line": 2432,
          "old_api": null,
          "new_api": "htonl",
          "old_text": null,
          "new_text": "htonl(totlen)",
          "old_line_content": "",
          "new_line_content": "    hdr->totlen = htonl(totlen);",
          "content_same": false
        },
        {
          "line": 4481,
          "old_api": null,
          "new_api": "addReply",
          "old_text": null,
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": "            return;",
          "new_line_content": "        addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 4482,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[1]->ptr,\"set-config-epoch\")",
          "old_line_content": "",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"set-config-epoch\") && c->argc == 3)",
          "content_same": false
        },
        {
          "line": 2442,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(channel->ptr)",
          "old_line_content": "",
          "new_line_content": "    memcpy(hdr->data.publish.msg.bulk_data,channel->ptr,sdslen(channel->ptr));",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(channel->ptr)",
          "old_line_content": "/* Send a FAIL message to all the nodes we are able to contact.",
          "new_line_content": "    memcpy(hdr->data.publish.msg.bulk_data+sdslen(channel->ptr),",
          "content_same": false
        },
        {
          "line": 2444,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(message->ptr)",
          "old_line_content": " * The FAIL message is sent when we detect that a node is failing",
          "new_line_content": "        message->ptr,sdslen(message->ptr));",
          "content_same": false
        },
        {
          "line": 4493,
          "old_api": null,
          "new_api": "getLongLongFromObjectOrReply",
          "old_text": null,
          "new_text": "getLongLongFromObjectOrReply(c,c->argv[2],&epoch,NULL)",
          "old_line_content": "                \"configEpoch set to %llu via CLUSTER SET-CONFIG-EPOCH\",",
          "new_line_content": "        if (getLongLongFromObjectOrReply(c,c->argv[2],&epoch,NULL) != C_OK)",
          "content_same": false
        },
        {
          "line": 2447,
          "old_api": null,
          "new_api": "clusterSendMessage",
          "old_text": null,
          "new_text": "clusterSendMessage(link,payload,totlen)",
          "old_line_content": " * nodes to do the same ASAP. */",
          "new_line_content": "        clusterSendMessage(link,payload,totlen);",
          "content_same": false
        },
        {
          "line": 2449,
          "old_api": null,
          "new_api": "clusterBroadcastMessage",
          "old_text": null,
          "new_text": "clusterBroadcastMessage(payload,totlen)",
          "old_line_content": "    unsigned char buf[sizeof(clusterMsg)];",
          "new_line_content": "        clusterBroadcastMessage(payload,totlen);",
          "content_same": false
        },
        {
          "line": 4497,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\"Invalid config epoch specified: %lld\",epoch)",
          "old_line_content": "                server.cluster->currentEpoch = epoch;",
          "new_line_content": "            addReplyErrorFormat(c,\"Invalid config epoch specified: %lld\",epoch);",
          "content_same": false
        },
        {
          "line": 2451,
          "old_api": null,
          "new_api": "decrRefCount",
          "old_text": null,
          "new_text": "decrRefCount(channel)",
          "old_line_content": "",
          "new_line_content": "    decrRefCount(channel);",
          "content_same": false
        },
        {
          "line": 4498,
          "old_api": null,
          "new_api": "dictSize",
          "old_text": null,
          "new_text": "dictSize(server.cluster->nodes)",
          "old_line_content": "            /* No need to fsync the config here since in the unlucky event",
          "new_line_content": "        } else if (dictSize(server.cluster->nodes) > 1) {",
          "content_same": false
        },
        {
          "line": 4499,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"The user can assign a config epoch only when the \"\n                            \"node does not know any other node.\")",
          "old_line_content": "             * of a failure to persist the config, the conflict resolution code",
          "new_line_content": "            addReplyError(c,\"The user can assign a config epoch only when the \"",
          "content_same": false
        },
        {
          "line": 4502,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"Node config epoch is already non-zero\")",
          "old_line_content": "                                 CLUSTER_TODO_SAVE_CONFIG);",
          "new_line_content": "            addReplyError(c,\"Node config epoch is already non-zero\");",
          "content_same": false
        },
        {
          "line": 4514,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|\n                                 CLUSTER_TODO_SAVE_CONFIG)",
          "old_line_content": "                hard = 1;",
          "new_line_content": "            clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|",
          "content_same": false
        },
        {
          "line": 4516,
          "old_api": null,
          "new_api": "addReply",
          "old_text": null,
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": "                hard = 0;",
          "new_line_content": "            addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 2478,
          "old_api": null,
          "new_api": "clusterBuildMessageHdr",
          "old_text": null,
          "new_text": "clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_UPDATE)",
          "old_line_content": " * -------------------------------------------------------------------------- */",
          "new_line_content": "    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_UPDATE);",
          "content_same": false
        },
        {
          "line": 2479,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(hdr->data.update.nodecfg.nodename,node->name,CLUSTER_NAMELEN)",
          "old_line_content": "void clusterPropagatePublish(robj *channel, robj *message) {",
          "new_line_content": "    memcpy(hdr->data.update.nodecfg.nodename,node->name,CLUSTER_NAMELEN);",
          "content_same": false
        },
        {
          "line": 4528,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[2]->ptr,\"soft\")",
          "old_line_content": "            return;",
          "new_line_content": "            } else if (!strcasecmp(c->argv[2]->ptr,\"soft\")) {",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(hdr->data.update.nodecfg.slots,node->slots,sizeof(node->slots))",
          "old_line_content": "}",
          "new_line_content": "    memcpy(hdr->data.update.nodecfg.slots,node->slots,sizeof(node->slots));",
          "content_same": false
        },
        {
          "line": 2482,
          "old_api": null,
          "new_api": "ntohl",
          "old_text": null,
          "new_text": "ntohl(hdr->totlen)",
          "old_line_content": "",
          "new_line_content": "    clusterSendMessage(link,buf,ntohl(hdr->totlen));",
          "content_same": false
        },
        {
          "line": 4538,
          "old_api": null,
          "new_api": "dictSize",
          "old_text": null,
          "new_text": "dictSize(c->db->dict)",
          "old_line_content": " * DUMP, RESTORE and MIGRATE commands",
          "new_line_content": "        if (nodeIsMaster(myself) && dictSize(c->db->dict) != 0) {",
          "content_same": false
        },
        {
          "line": 4539,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"CLUSTER RESET can't be called with \"\n                            \"master nodes containing keys\")",
          "old_line_content": " * -------------------------------------------------------------------------- */",
          "new_line_content": "            addReplyError(c,\"CLUSTER RESET can't be called with \"",
          "content_same": false
        },
        {
          "line": 2493,
          "old_api": null,
          "new_api": "clusterSendPublish",
          "old_text": null,
          "new_text": "clusterSendPublish(NULL, channel, message)",
          "old_line_content": "void clusterRequestFailoverAuth(void) {",
          "new_line_content": "    clusterSendPublish(NULL, channel, message);",
          "content_same": false
        },
        {
          "line": 4543,
          "old_api": null,
          "new_api": "clusterReset",
          "old_text": null,
          "new_text": "clusterReset(hard)",
          "old_line_content": "void createDumpPayload(rio *payload, robj *o) {",
          "new_line_content": "        clusterReset(hard);",
          "content_same": false
        },
        {
          "line": 4544,
          "old_api": null,
          "new_api": "addReply",
          "old_text": null,
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": "    unsigned char buf[2];",
          "new_line_content": "        addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 4546,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"Wrong CLUSTER subcommand or number of arguments\")",
          "old_line_content": "",
          "new_line_content": "        addReplyError(c,\"Wrong CLUSTER subcommand or number of arguments\");",
          "content_same": false
        },
        {
          "line": 2511,
          "old_api": null,
          "new_api": "clusterBuildMessageHdr",
          "old_text": null,
          "new_text": "clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST)",
          "old_line_content": "    clusterMsg *hdr = (clusterMsg*) buf;",
          "new_line_content": "    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST);",
          "content_same": false
        },
        {
          "line": 4562,
          "old_api": null,
          "new_api": "sdsempty",
          "old_text": null,
          "new_text": "sdsempty()",
          "old_line_content": "    buf[1] = (RDB_VERSION >> 8) & 0xff;",
          "new_line_content": "    rioInitWithBuffer(payload,sdsempty());",
          "content_same": false
        },
        {
          "line": 4564,
          "old_api": null,
          "new_api": "rdbSaveObject",
          "old_text": null,
          "new_text": "rdbSaveObject(payload,o)",
          "old_line_content": "",
          "new_line_content": "    serverAssert(rdbSaveObject(payload,o));",
          "content_same": false
        },
        {
          "line": 4576,
          "old_api": null,
          "new_api": "sdscatlen",
          "old_text": null,
          "new_text": "sdscatlen(payload->io.buffer.ptr,buf,2)",
          "old_line_content": "int verifyDumpPayload(unsigned char *p, size_t len) {",
          "new_line_content": "    payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,buf,2);",
          "content_same": false
        },
        {
          "line": 4579,
          "old_api": null,
          "new_api": "crc64",
          "old_text": null,
          "new_text": "crc64(0,(unsigned char*)payload->io.buffer.ptr,\n                sdslen(payload->io.buffer.ptr))",
          "old_line_content": "    uint64_t crc;",
          "new_line_content": "    crc = crc64(0,(unsigned char*)payload->io.buffer.ptr,",
          "content_same": false
        },
        {
          "line": 4580,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(payload->io.buffer.ptr)",
          "old_line_content": "",
          "new_line_content": "                sdslen(payload->io.buffer.ptr));",
          "content_same": false
        },
        {
          "line": 4581,
          "old_api": null,
          "new_api": "memrev64ifbe",
          "old_text": null,
          "new_text": "memrev64ifbe(&crc)",
          "old_line_content": "    /* At least 2 bytes of RDB version and 8 of CRC64 should be present. */",
          "new_line_content": "    memrev64ifbe(&crc);",
          "content_same": false
        },
        {
          "line": 4582,
          "old_api": null,
          "new_api": "sdscatlen",
          "old_text": null,
          "new_text": "sdscatlen(payload->io.buffer.ptr,&crc,8)",
          "old_line_content": "    if (len < 10) return C_ERR;",
          "new_line_content": "    payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,&crc,8);",
          "content_same": false
        },
        {
          "line": 2541,
          "old_api": null,
          "new_api": "clusterBuildMessageHdr",
          "old_text": null,
          "new_text": "clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_MFSTART)",
          "old_line_content": "    int j;",
          "new_line_content": "    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_MFSTART);",
          "content_same": false
        },
        {
          "line": 2543,
          "old_api": null,
          "new_api": "htonl",
          "old_text": null,
          "new_text": "htonl(totlen)",
          "old_line_content": "    /* IF we are not a master serving at least 1 slot, we don't have the",
          "new_line_content": "    hdr->totlen = htonl(totlen);",
          "content_same": false
        },
        {
          "line": 2544,
          "old_api": null,
          "new_api": "clusterSendMessage",
          "old_text": null,
          "new_text": "clusterSendMessage(node->link,buf,totlen)",
          "old_line_content": "     * right to vote, as the cluster size in Redis Cluster is the number",
          "new_line_content": "    clusterSendMessage(node->link,buf,totlen);",
          "content_same": false
        },
        {
          "line": 2550,
          "old_api": null,
          "new_api": "ntohu64",
          "old_text": null,
          "new_text": "ntohu64(request->currentEpoch)",
          "old_line_content": "     * Note that it is impossible for it to actually be greater since",
          "new_line_content": "    uint64_t requestCurrentEpoch = ntohu64(request->currentEpoch);",
          "content_same": false
        },
        {
          "line": 2551,
          "old_api": null,
          "new_api": "ntohu64",
          "old_text": null,
          "new_text": "ntohu64(request->configEpoch)",
          "old_line_content": "     * our currentEpoch was updated as a side effect of receiving this",
          "new_line_content": "    uint64_t requestConfigEpoch = ntohu64(request->configEpoch);",
          "content_same": false
        },
        {
          "line": 4605,
          "old_api": null,
          "new_api": "memcmp",
          "old_text": null,
          "new_text": "memcmp(&crc,footer+2,8)",
          "old_line_content": "        return;",
          "new_line_content": "    return (memcmp(&crc,footer+2,8) == 0) ? C_OK : C_ERR;",
          "content_same": false
        },
        {
          "line": 2560,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(myself)",
          "old_line_content": "    }",
          "new_line_content": "    if (nodeIsSlave(myself) || myself->numslots == 0) return;",
          "content_same": false
        },
        {
          "line": 2567,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\n            \"Failover auth denied to %.40s: reqEpoch (%llu) < curEpoch(%llu)\",\n            node->name,\n            (unsigned long long) requestCurrentEpoch,\n            (unsigned long long) server.cluster->currentEpoch)",
          "old_line_content": "                (unsigned long long) server.cluster->currentEpoch);",
          "new_line_content": "        serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 4616,
          "old_api": null,
          "new_api": "lookupKeyRead",
          "old_text": null,
          "new_text": "lookupKeyRead(c->db,c->argv[1])",
          "old_line_content": "}",
          "new_line_content": "    if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {",
          "content_same": false
        },
        {
          "line": 4617,
          "old_api": null,
          "new_api": "addReply",
          "old_text": null,
          "new_text": "addReply(c,shared.nullbulk)",
          "old_line_content": "",
          "new_line_content": "        addReply(c,shared.nullbulk);",
          "content_same": false
        },
        {
          "line": 4622,
          "old_api": null,
          "new_api": "createDumpPayload",
          "old_text": null,
          "new_text": "createDumpPayload(&payload,o)",
          "old_line_content": "    int j, type, replace = 0;",
          "new_line_content": "    createDumpPayload(&payload,o);",
          "content_same": false
        },
        {
          "line": 4625,
          "old_api": null,
          "new_api": "createObject",
          "old_text": null,
          "new_text": "createObject(OBJ_STRING,payload.io.buffer.ptr)",
          "old_line_content": "    /* Parse additional options */",
          "new_line_content": "    dumpobj = createObject(OBJ_STRING,payload.io.buffer.ptr);",
          "content_same": false
        },
        {
          "line": 4626,
          "old_api": null,
          "new_api": "addReplyBulk",
          "old_text": null,
          "new_text": "addReplyBulk(c,dumpobj)",
          "old_line_content": "    for (j = 4; j < c->argc; j++) {",
          "new_line_content": "    addReplyBulk(c,dumpobj);",
          "content_same": false
        },
        {
          "line": 2587,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(node)",
          "old_line_content": "                    \"Failover auth denied to %.40s: its master is up\",",
          "new_line_content": "    if (nodeIsMaster(node) || master == NULL ||",
          "content_same": false
        },
        {
          "line": 2588,
          "old_api": null,
          "new_api": "nodeFailed",
          "old_text": null,
          "new_text": "nodeFailed(master)",
          "old_line_content": "                    node->name);",
          "new_line_content": "        (!nodeFailed(master) && !force_ack))",
          "content_same": false
        },
        {
          "line": 2590,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(node)",
          "old_line_content": "        return;",
          "new_line_content": "        if (nodeIsMaster(node)) {",
          "content_same": false
        },
        {
          "line": 2591,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\n                    \"Failover auth denied to %.40s: it is a master node\",\n                    node->name)",
          "old_line_content": "    }",
          "new_line_content": "            serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 4640,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[j]->ptr,\"replace\")",
          "old_line_content": "",
          "new_line_content": "        if (!strcasecmp(c->argv[j]->ptr,\"replace\")) {",
          "content_same": false
        },
        {
          "line": 2595,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\n                    \"Failover auth denied to %.40s: I don't know its master\",\n                    node->name)",
          "old_line_content": "     * of the algorithm but makes the base case more linear. */",
          "new_line_content": "            serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 4643,
          "old_api": null,
          "new_api": "addReply",
          "old_text": null,
          "new_text": "addReply(c,shared.syntaxerr)",
          "old_line_content": "        return;",
          "new_line_content": "            addReply(c,shared.syntaxerr);",
          "content_same": false
        },
        {
          "line": 2599,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\n                    \"Failover auth denied to %.40s: its master is up\",\n                    node->name)",
          "old_line_content": "                \"Failover auth denied to %.40s: \"",
          "new_line_content": "            serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 4649,
          "old_api": null,
          "new_api": "lookupKeyWrite",
          "old_text": null,
          "new_text": "lookupKeyWrite(c->db,c->argv[1])",
          "old_line_content": "    /* Verify RDB version and data checksum. */",
          "new_line_content": "    if (!replace && lookupKeyWrite(c->db,c->argv[1]) != NULL) {",
          "content_same": false
        },
        {
          "line": 4655,
          "old_api": null,
          "new_api": "getLongLongFromObjectOrReply",
          "old_text": null,
          "new_text": "getLongLongFromObjectOrReply(c,c->argv[2],&ttl,NULL)",
          "old_line_content": "",
          "new_line_content": "    if (getLongLongFromObjectOrReply(c,c->argv[2],&ttl,NULL) != C_OK) {",
          "content_same": false
        },
        {
          "line": 2609,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "     * slots in the current configuration. */",
          "new_line_content": "    if (mstime() - node->slaveof->voted_time < server.cluster_node_timeout * 2)",
          "content_same": false
        },
        {
          "line": 4663,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(c->argv[3]->ptr)",
          "old_line_content": "",
          "new_line_content": "    if (verifyDumpPayload(c->argv[3]->ptr,sdslen(c->argv[3]->ptr)) == C_ERR)",
          "content_same": false
        },
        {
          "line": 2616,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "        }",
          "new_line_content": "                             (mstime() - node->slaveof->voted_time)));",
          "content_same": false
        },
        {
          "line": 2624,
          "old_api": null,
          "new_api": "bitmapTestBit",
          "old_text": null,
          "new_text": "bitmapTestBit(claimed_slots, j)",
          "old_line_content": "                (unsigned long long) server.cluster->slots[j]->configEpoch,",
          "new_line_content": "        if (bitmapTestBit(claimed_slots, j) == 0) continue;",
          "content_same": false
        },
        {
          "line": 4673,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"Bad data format\")",
          "old_line_content": "}",
          "new_line_content": "        addReplyError(c,\"Bad data format\");",
          "content_same": false
        },
        {
          "line": 4678,
          "old_api": null,
          "new_api": "dbDelete",
          "old_text": null,
          "new_text": "dbDelete(c->db,c->argv[1])",
          "old_line_content": " * to this instance in recent time.",
          "new_line_content": "    if (replace) dbDelete(c->db,c->argv[1]);",
          "content_same": false
        },
        {
          "line": 4681,
          "old_api": null,
          "new_api": "dbAdd",
          "old_text": null,
          "new_text": "dbAdd(c->db,c->argv[1],obj)",
          "old_line_content": "#define MIGRATE_SOCKET_CACHE_ITEMS 64 /* max num of items in the cache. */",
          "new_line_content": "    dbAdd(c->db,c->argv[1],obj);",
          "content_same": false
        },
        {
          "line": 4682,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "#define MIGRATE_SOCKET_CACHE_TTL 10 /* close cached sockets after 10 sec. */",
          "new_line_content": "    if (ttl) setExpire(c,c->db,c->argv[1],mstime()+ttl);",
          "content_same": false
        },
        {
          "line": 4683,
          "old_api": null,
          "new_api": "signalModifiedKey",
          "old_text": null,
          "new_text": "signalModifiedKey(c->db,c->argv[1])",
          "old_line_content": "",
          "new_line_content": "    signalModifiedKey(c->db,c->argv[1]);",
          "content_same": false
        },
        {
          "line": 4684,
          "old_api": null,
          "new_api": "addReply",
          "old_text": null,
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": "typedef struct migrateCachedSocket {",
          "new_line_content": "    addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 2643,
          "old_api": null,
          "new_api": "clusterSendFailoverAuth",
          "old_text": null,
          "new_text": "clusterSendFailoverAuth(node)",
          "old_line_content": " * replication offset, and so forth. Note that because how the rank is computed",
          "new_line_content": "    clusterSendFailoverAuth(node);",
          "content_same": false
        },
        {
          "line": 2645,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": " *",
          "new_line_content": "    node->slaveof->voted_time = mstime();",
          "content_same": false
        },
        {
          "line": 2646,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING, \"Failover auth granted to %.40s for epoch %llu\",\n        node->name, (unsigned long long) server.cluster->currentEpoch)",
          "old_line_content": " * The slave rank is used to add a delay to start an election in order to",
          "new_line_content": "    serverLog(LL_WARNING, \"Failover auth granted to %.40s for epoch %llu\",",
          "content_same": false
        },
        {
          "line": 2667,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(myself)",
          "old_line_content": " * not the conditions, but since the failover function is called again and",
          "new_line_content": "    serverAssert(nodeIsSlave(myself));",
          "content_same": false
        },
        {
          "line": 4716,
          "old_api": null,
          "new_api": "sdsempty",
          "old_text": null,
          "new_text": "sdsempty()",
          "old_line_content": "",
          "new_line_content": "    sds name = sdsempty();",
          "content_same": false
        },
        {
          "line": 2671,
          "old_api": null,
          "new_api": "replicationGetSlaveOffset",
          "old_text": null,
          "new_text": "replicationGetSlaveOffset()",
          "old_line_content": " * true:",
          "new_line_content": "    myoffset = replicationGetSlaveOffset();",
          "content_same": false
        },
        {
          "line": 4725,
          "old_api": null,
          "new_api": "sdsfree",
          "old_text": null,
          "new_text": "sdsfree(name)",
          "old_line_content": "    }",
          "new_line_content": "        sdsfree(name);",
          "content_same": false
        },
        {
          "line": 4733,
          "old_api": null,
          "new_api": "dictGetRandomKey",
          "old_text": null,
          "new_text": "dictGetRandomKey(server.migrate_cached_sockets)",
          "old_line_content": "            server.neterr);",
          "new_line_content": "        dictEntry *de = dictGetRandomKey(server.migrate_cached_sockets);",
          "content_same": false
        },
        {
          "line": 4734,
          "old_api": null,
          "new_api": "dictGetVal",
          "old_text": null,
          "new_text": "dictGetVal(de)",
          "old_line_content": "        return NULL;",
          "new_line_content": "        cs = dictGetVal(de);",
          "content_same": false
        },
        {
          "line": 4735,
          "old_api": null,
          "new_api": "close",
          "old_text": null,
          "new_text": "close(cs->fd)",
          "old_line_content": "    }",
          "new_line_content": "        close(cs->fd);",
          "content_same": false
        },
        {
          "line": 4737,
          "old_api": null,
          "new_api": "dictGetKey",
          "old_text": null,
          "new_text": "dictGetKey(de)",
          "old_line_content": "",
          "new_line_content": "        dictDelete(server.migrate_cached_sockets,dictGetKey(de));",
          "content_same": false
        },
        {
          "line": 4744,
          "old_api": null,
          "new_api": "sdsfree",
          "old_text": null,
          "new_text": "sdsfree(name)",
          "old_line_content": "        return NULL;",
          "new_line_content": "        sdsfree(name);",
          "content_same": false
        },
        {
          "line": 4745,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\"Can't connect to target node: %s\",\n            server.neterr)",
          "old_line_content": "    }",
          "new_line_content": "        addReplyErrorFormat(c,\"Can't connect to target node: %s\",",
          "content_same": false
        },
        {
          "line": 4749,
          "old_api": null,
          "new_api": "anetEnableTcpNoDelay",
          "old_text": null,
          "new_text": "anetEnableTcpNoDelay(server.neterr,fd)",
          "old_line_content": "    cs->fd = fd;",
          "new_line_content": "    anetEnableTcpNoDelay(server.neterr,fd);",
          "content_same": false
        },
        {
          "line": 4753,
          "old_api": null,
          "new_api": "sdsfree",
          "old_text": null,
          "new_text": "sdsfree(name)",
          "old_line_content": "    return cs;",
          "new_line_content": "        sdsfree(name);",
          "content_same": false
        },
        {
          "line": 4754,
          "old_api": null,
          "new_api": "addReplySds",
          "old_text": null,
          "new_text": "addReplySds(c,\n            sdsnew(\"-IOERR error or timeout connecting to the client\\r\\n\"))",
          "old_line_content": "}",
          "new_line_content": "        addReplySds(c,",
          "content_same": false
        },
        {
          "line": 2707,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(NULL)",
          "old_line_content": "    case CLUSTER_CANT_FAILOVER_DATA_AGE:",
          "new_line_content": "        time(NULL)-lastlog_time < CLUSTER_CANT_FAILOVER_RELOG_PERIOD)",
          "content_same": false
        },
        {
          "line": 4755,
          "old_api": null,
          "new_api": "sdsnew",
          "old_text": null,
          "new_text": "sdsnew(\"-IOERR error or timeout connecting to the client\\r\\n\")",
          "old_line_content": "",
          "new_line_content": "            sdsnew(\"-IOERR error or timeout connecting to the client\\r\\n\"));",
          "content_same": false
        },
        {
          "line": 4756,
          "old_api": null,
          "new_api": "close",
          "old_text": null,
          "new_text": "close(fd)",
          "old_line_content": "/* Free a migrate cached connection. */",
          "new_line_content": "        close(fd);",
          "content_same": false
        },
        {
          "line": 2716,
          "old_api": null,
          "new_api": "nodeFailed",
          "old_text": null,
          "new_text": "nodeFailed(myself->slaveof)",
          "old_line_content": "        msg = \"Failover attempt expired.\";",
          "new_line_content": "        nodeFailed(myself->slaveof) &&",
          "content_same": false
        },
        {
          "line": 2717,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "        break;",
          "new_line_content": "        (mstime() - myself->slaveof->fail_time) < nolog_fail_time) return;",
          "content_same": false
        },
        {
          "line": 4765,
          "old_api": null,
          "new_api": "dictAdd",
          "old_text": null,
          "new_text": "dictAdd(server.migrate_cached_sockets,name,cs)",
          "old_line_content": "    if (!cs) {",
          "new_line_content": "    dictAdd(server.migrate_cached_sockets,name,cs);",
          "content_same": false
        },
        {
          "line": 4774,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(host->ptr)",
          "old_line_content": "}",
          "new_line_content": "    name = sdscatlen(name,host->ptr,sdslen(host->ptr));",
          "content_same": false
        },
        {
          "line": 4775,
          "old_api": null,
          "new_api": "sdscatlen",
          "old_text": null,
          "new_text": "sdscatlen(name,\":\",1)",
          "old_line_content": "",
          "new_line_content": "    name = sdscatlen(name,\":\",1);",
          "content_same": false
        },
        {
          "line": 4776,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(port->ptr)",
          "old_line_content": "void migrateCloseTimedoutSockets(void) {",
          "new_line_content": "    name = sdscatlen(name,port->ptr,sdslen(port->ptr));",
          "content_same": false
        },
        {
          "line": 4779,
          "old_api": null,
          "new_api": "sdsfree",
          "old_text": null,
          "new_text": "sdsfree(name)",
          "old_line_content": "",
          "new_line_content": "        sdsfree(name);",
          "content_same": false
        },
        {
          "line": 4783,
          "old_api": null,
          "new_api": "close",
          "old_text": null,
          "new_text": "close(cs->fd)",
          "old_line_content": "        if ((server.unixtime - cs->last_use_time) > MIGRATE_SOCKET_CACHE_TTL) {",
          "new_line_content": "    close(cs->fd);",
          "content_same": false
        },
        {
          "line": 2738,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(NULL)",
          "old_line_content": "",
          "new_line_content": "    lastlog_time = time(NULL);",
          "content_same": false
        },
        {
          "line": 4790,
          "old_api": null,
          "new_api": "dictGetSafeIterator",
          "old_text": null,
          "new_text": "dictGetSafeIterator(server.migrate_cached_sockets)",
          "old_line_content": "}",
          "new_line_content": "    dictIterator *di = dictGetSafeIterator(server.migrate_cached_sockets);",
          "content_same": false
        },
        {
          "line": 4793,
          "old_api": null,
          "new_api": "dictNext",
          "old_text": null,
          "new_text": "dictNext(di)",
          "old_line_content": " *",
          "new_line_content": "    while((de = dictNext(di)) != NULL) {",
          "content_same": false
        },
        {
          "line": 4794,
          "old_api": null,
          "new_api": "dictGetVal",
          "old_text": null,
          "new_text": "dictGetVal(de)",
          "old_line_content": " * On in the multiple keys form:",
          "new_line_content": "        migrateCachedSocket *cs = dictGetVal(de);",
          "content_same": false
        },
        {
          "line": 4797,
          "old_api": null,
          "new_api": "close",
          "old_text": null,
          "new_text": "close(cs->fd)",
          "old_line_content": "void migrateCommand(client *c) {",
          "new_line_content": "            close(cs->fd);",
          "content_same": false
        },
        {
          "line": 4798,
          "old_api": null,
          "new_api": "zfree",
          "old_text": null,
          "new_text": "zfree(cs)",
          "old_line_content": "    migrateCachedSocket *cs;",
          "new_line_content": "            zfree(cs);",
          "content_same": false
        },
        {
          "line": 4799,
          "old_api": null,
          "new_api": "dictGetKey",
          "old_text": null,
          "new_text": "dictGetKey(de)",
          "old_line_content": "    int copy, replace, j;",
          "new_line_content": "            dictDelete(server.migrate_cached_sockets,dictGetKey(de));",
          "content_same": false
        },
        {
          "line": 2752,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(myself)",
          "old_line_content": "",
          "new_line_content": "    if (nodeIsMaster(myself) || oldmaster == NULL) return;",
          "content_same": false
        },
        {
          "line": 4802,
          "old_api": null,
          "new_api": "dictReleaseIterator",
          "old_text": null,
          "new_text": "dictReleaseIterator(di)",
          "old_line_content": "    robj **ov = NULL; /* Objects to migrate. */",
          "new_line_content": "    dictReleaseIterator(di);",
          "content_same": false
        },
        {
          "line": 2756,
          "old_api": null,
          "new_api": "replicationUnsetMaster",
          "old_text": null,
          "new_text": "replicationUnsetMaster()",
          "old_line_content": "",
          "new_line_content": "    replicationUnsetMaster();",
          "content_same": false
        },
        {
          "line": 2760,
          "old_api": null,
          "new_api": "clusterNodeGetSlotBit",
          "old_text": null,
          "new_text": "clusterNodeGetSlotBit(oldmaster,j)",
          "old_line_content": "",
          "new_line_content": "        if (clusterNodeGetSlotBit(oldmaster,j)) {",
          "content_same": false
        },
        {
          "line": 2761,
          "old_api": null,
          "new_api": "clusterDelSlot",
          "old_text": null,
          "new_text": "clusterDelSlot(j)",
          "old_line_content": "    /* 5) If there was a manual failover in progress, clear the state. */",
          "new_line_content": "            clusterDelSlot(j);",
          "content_same": false
        },
        {
          "line": 2767,
          "old_api": null,
          "new_api": "clusterUpdateState",
          "old_text": null,
          "new_text": "clusterUpdateState()",
          "old_line_content": " *",
          "new_line_content": "    clusterUpdateState();",
          "content_same": false
        },
        {
          "line": 2768,
          "old_api": null,
          "new_api": "clusterSaveConfigOrDie",
          "old_text": null,
          "new_text": "clusterSaveConfigOrDie(1)",
          "old_line_content": " * The gaol of this function is:",
          "new_line_content": "    clusterSaveConfigOrDie(1);",
          "content_same": false
        },
        {
          "line": 2772,
          "old_api": null,
          "new_api": "clusterBroadcastPong",
          "old_text": null,
          "new_text": "clusterBroadcastPong(CLUSTER_BROADCAST_ALL)",
          "old_line_content": " */",
          "new_line_content": "    clusterBroadcastPong(CLUSTER_BROADCAST_ALL);",
          "content_same": false
        },
        {
          "line": 4833,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[j]->ptr,\"copy\")",
          "old_line_content": "            break; /* All the remaining args are keys. */",
          "new_line_content": "        if (!strcasecmp(c->argv[j]->ptr,\"copy\")) {",
          "content_same": false
        },
        {
          "line": 2788,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "     * Retry is two times the Timeout.",
          "new_line_content": "    mstime_t auth_age = mstime() - server.cluster->failover_auth_time;",
          "content_same": false
        },
        {
          "line": 4837,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[j]->ptr,\"keys\")",
          "old_line_content": "        }",
          "new_line_content": "        } else if (!strcasecmp(c->argv[j]->ptr,\"keys\")) {",
          "content_same": false
        },
        {
          "line": 4838,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(c->argv[3]->ptr)",
          "old_line_content": "    }",
          "new_line_content": "            if (sdslen(c->argv[3]->ptr) != 0) {",
          "content_same": false
        },
        {
          "line": 4839,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\n                    \"When using MIGRATE KEYS option, the key argument\"\n                    \" must be set to the empty string\")",
          "old_line_content": "",
          "new_line_content": "                addReplyError(c,",
          "content_same": false
        },
        {
          "line": 4848,
          "old_api": null,
          "new_api": "addReply",
          "old_text": null,
          "new_text": "addReply(c,shared.syntaxerr)",
          "old_line_content": "    /* Check if the keys are here. If at least one key is to migrate, do it",
          "new_line_content": "            addReply(c,shared.syntaxerr);",
          "content_same": false
        },
        {
          "line": 4855,
          "old_api": null,
          "new_api": "getLongFromObjectOrReply",
          "old_text": null,
          "new_text": "getLongFromObjectOrReply(c,c->argv[4],&dbid,NULL)",
          "old_line_content": "    int oi = 0;",
          "new_line_content": "        getLongFromObjectOrReply(c,c->argv[4],&dbid,NULL) != C_OK)",
          "content_same": false
        },
        {
          "line": 2812,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(myself)",
          "old_line_content": "    if (server.repl_state == REPL_STATE_CONNECTED) {",
          "new_line_content": "    if (nodeIsMaster(myself) ||",
          "content_same": false
        },
        {
          "line": 2814,
          "old_api": null,
          "new_api": "nodeFailed",
          "old_text": null,
          "new_text": "nodeFailed(myself->slaveof)",
          "old_line_content": "                   * 1000;",
          "new_line_content": "        (!nodeFailed(myself->slaveof) && !manual_failover) ||",
          "content_same": false
        },
        {
          "line": 4867,
          "old_api": null,
          "new_api": "zrealloc",
          "old_text": null,
          "new_text": "zrealloc(kv,sizeof(robj*)*num_keys)",
          "old_line_content": "        return;",
          "new_line_content": "    kv = zrealloc(kv,sizeof(robj*)*num_keys);",
          "content_same": false
        },
        {
          "line": 4871,
          "old_api": null,
          "new_api": "lookupKeyRead",
          "old_text": null,
          "new_text": "lookupKeyRead(c->db,c->argv[first_key+j])",
          "old_line_content": "    write_error = 0;",
          "new_line_content": "        if ((ov[oi] = lookupKeyRead(c->db,c->argv[first_key+j])) != NULL) {",
          "content_same": false
        },
        {
          "line": 2826,
          "old_api": null,
          "new_api": "mstime_t)(server.unixtime - server.master->lastinteraction)",
          "old_text": null,
          "new_text": "mstime_t)(server.unixtime - server.master->lastinteraction)",
          "old_line_content": "     * factor configured by the user.",
          "new_line_content": "        data_age = (mstime_t)(server.unixtime - server.master->lastinteraction)",
          "content_same": false
        },
        {
          "line": 2829,
          "old_api": null,
          "new_api": "mstime_t)(server.unixtime - server.repl_down_since)",
          "old_text": null,
          "new_text": "mstime_t)(server.unixtime - server.repl_down_since)",
          "old_line_content": "    if (server.cluster_slave_validity_factor &&",
          "new_line_content": "        data_age = (mstime_t)(server.unixtime - server.repl_down_since) * 1000;",
          "content_same": false
        },
        {
          "line": 4878,
          "old_api": null,
          "new_api": "zfree",
          "old_text": null,
          "new_text": "zfree(kv)",
          "old_line_content": "    }",
          "new_line_content": "        zfree(ov); zfree(kv);",
          "content_same": false
        },
        {
          "line": 4879,
          "old_api": null,
          "new_api": "sdsnew",
          "old_text": null,
          "new_text": "sdsnew(\"+NOKEY\\r\\n\")",
          "old_line_content": "",
          "new_line_content": "        addReplySds(c,sdsnew(\"+NOKEY\\r\\n\"));",
          "content_same": false
        },
        {
          "line": 4889,
          "old_api": null,
          "new_api": "zfree",
          "old_text": null,
          "new_text": "zfree(kv)",
          "old_line_content": "",
          "new_line_content": "        zfree(ov); zfree(kv);",
          "content_same": false
        },
        {
          "line": 4898,
          "old_api": null,
          "new_api": "rioWriteBulkCount",
          "old_text": null,
          "new_text": "rioWriteBulkCount(&cmd,'*',2)",
          "old_line_content": "        }",
          "new_line_content": "        serverAssertWithInfo(c,NULL,rioWriteBulkCount(&cmd,'*',2));",
          "content_same": false
        },
        {
          "line": 4900,
          "old_api": null,
          "new_api": "rioWriteBulkLongLong",
          "old_text": null,
          "new_text": "rioWriteBulkLongLong(&cmd,dbid)",
          "old_line_content": "        if (server.cluster_enabled)",
          "new_line_content": "        serverAssertWithInfo(c,NULL,rioWriteBulkLongLong(&cmd,dbid));",
          "content_same": false
        },
        {
          "line": 2858,
          "old_api": null,
          "new_api": "random",
          "old_text": null,
          "new_text": "random()",
          "old_line_content": "        }",
          "new_line_content": "            random() % 500; /* Random delay between 0 and 500 milliseconds. */",
          "content_same": false
        },
        {
          "line": 2861,
          "old_api": null,
          "new_api": "clusterGetSlaveRank",
          "old_text": null,
          "new_text": "clusterGetSlaveRank()",
          "old_line_content": "            \"(rank #%d, offset %lld).\",",
          "new_line_content": "        server.cluster->failover_auth_rank = clusterGetSlaveRank();",
          "content_same": false
        },
        {
          "line": 4909,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "",
          "new_line_content": "            ttl = expireat-mstime();",
          "content_same": false
        },
        {
          "line": 2869,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "        return;",
          "new_line_content": "            server.cluster->failover_auth_time = mstime();",
          "content_same": false
        },
        {
          "line": 4917,
          "old_api": null,
          "new_api": "rioWriteBulkString",
          "old_text": null,
          "new_text": "rioWriteBulkString(&cmd,\"RESTORE\",7)",
          "old_line_content": "",
          "new_line_content": "            serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,\"RESTORE\",7));",
          "content_same": false
        },
        {
          "line": 4918,
          "old_api": null,
          "new_api": "sdsEncodedObject",
          "old_text": null,
          "new_text": "sdsEncodedObject(kv[j])",
          "old_line_content": "        /* Add the REPLACE option to the RESTORE command if it was specified",
          "new_line_content": "        serverAssertWithInfo(c,NULL,sdsEncodedObject(kv[j]));",
          "content_same": false
        },
        {
          "line": 2872,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\n            \"Start of election delayed for %lld milliseconds \"\n            \"(rank #%d, offset %lld).\",\n            server.cluster->failover_auth_time - mstime(),\n            server.cluster->failover_auth_rank,\n            replicationGetSlaveOffset())",
          "old_line_content": "    /* It is possible that we received more updated offsets from other",
          "new_line_content": "        serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 4919,
          "old_api": null,
          "new_api": "rioWriteBulkString",
          "old_text": null,
          "new_text": "rioWriteBulkString(&cmd,kv[j]->ptr,\n                sdslen(kv[j]->ptr))",
          "old_line_content": "         * as a MIGRATE option. */",
          "new_line_content": "        serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,kv[j]->ptr,",
          "content_same": false
        },
        {
          "line": 4920,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(kv[j]->ptr)",
          "old_line_content": "        if (replace)",
          "new_line_content": "                sdslen(kv[j]->ptr)));",
          "content_same": false
        },
        {
          "line": 2875,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "     *",
          "new_line_content": "            server.cluster->failover_auth_time - mstime(),",
          "content_same": false
        },
        {
          "line": 2877,
          "old_api": null,
          "new_api": "replicationGetSlaveOffset",
          "old_text": null,
          "new_text": "replicationGetSlaveOffset()",
          "old_line_content": "    if (server.cluster->failover_auth_sent == 0 &&",
          "new_line_content": "            replicationGetSlaveOffset());",
          "content_same": false
        },
        {
          "line": 4925,
          "old_api": null,
          "new_api": "createDumpPayload",
          "old_text": null,
          "new_text": "createDumpPayload(&payload,ov[j])",
          "old_line_content": "    errno = 0;",
          "new_line_content": "        createDumpPayload(&payload,ov[j]);",
          "content_same": false
        },
        {
          "line": 4927,
          "old_api": null,
          "new_api": "rioWriteBulkString",
          "old_text": null,
          "new_text": "rioWriteBulkString(&cmd,payload.io.buffer.ptr,\n                               sdslen(payload.io.buffer.ptr))",
          "old_line_content": "        sds buf = cmd.io.buffer.ptr;",
          "new_line_content": "            rioWriteBulkString(&cmd,payload.io.buffer.ptr,",
          "content_same": false
        },
        {
          "line": 4928,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(payload.io.buffer.ptr)",
          "old_line_content": "        size_t pos = 0, towrite;",
          "new_line_content": "                               sdslen(payload.io.buffer.ptr)));",
          "content_same": false
        },
        {
          "line": 4926,
          "old_api": null,
          "new_api": "serverAssertWithInfo",
          "old_text": null,
          "new_text": "serverAssertWithInfo(c,NULL,\n            rioWriteBulkString(&cmd,payload.io.buffer.ptr,\n                               sdslen(payload.io.buffer.ptr)))",
          "old_line_content": "    {",
          "new_line_content": "        serverAssertWithInfo(c,NULL,",
          "content_same": false
        },
        {
          "line": 2881,
          "old_api": null,
          "new_api": "clusterBroadcastPong",
          "old_text": null,
          "new_text": "clusterBroadcastPong(CLUSTER_BROADCAST_LOCAL_SLAVES)",
          "old_line_content": "        if (newrank > server.cluster->failover_auth_rank) {",
          "new_line_content": "        clusterBroadcastPong(CLUSTER_BROADCAST_LOCAL_SLAVES);",
          "content_same": false
        },
        {
          "line": 4929,
          "old_api": null,
          "new_api": "sdsfree",
          "old_text": null,
          "new_text": "sdsfree(payload.io.buffer.ptr)",
          "old_line_content": "        int nwritten = 0;",
          "new_line_content": "        sdsfree(payload.io.buffer.ptr);",
          "content_same": false
        },
        {
          "line": 4934,
          "old_api": null,
          "new_api": "rioWriteBulkString",
          "old_text": null,
          "new_text": "rioWriteBulkString(&cmd,\"REPLACE\",7)",
          "old_line_content": "            if (nwritten != (signed)towrite) {",
          "new_line_content": "            serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,\"REPLACE\",7));",
          "content_same": false
        },
        {
          "line": 4944,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(buf)",
          "old_line_content": "",
          "new_line_content": "        while ((towrite = sdslen(buf)-pos) > 0) {",
          "content_same": false
        },
        {
          "line": 2899,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\n                \"Slave rank updated to #%d, added %lld milliseconds of delay.\",\n                newrank, added_delay)",
          "old_line_content": "    if (auth_age > auth_timeout) {",
          "new_line_content": "            serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 2906,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "        server.cluster->currentEpoch++;",
          "new_line_content": "    if (mstime() < server.cluster->failover_auth_time) {",
          "content_same": false
        },
        {
          "line": 2907,
          "old_api": null,
          "new_api": "clusterLogCantFailover",
          "old_text": null,
          "new_text": "clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_DELAY)",
          "old_line_content": "        server.cluster->failover_auth_epoch = server.cluster->currentEpoch;",
          "new_line_content": "        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_DELAY);",
          "content_same": false
        },
        {
          "line": 4959,
          "old_api": null,
          "new_api": "syncReadLine",
          "old_text": null,
          "new_text": "syncReadLine(cs->fd, buf1, sizeof(buf1), timeout)",
          "old_line_content": "            break;",
          "new_line_content": "    if (select && syncReadLine(cs->fd, buf1, sizeof(buf1), timeout) <= 0)",
          "content_same": false
        },
        {
          "line": 2913,
          "old_api": null,
          "new_api": "clusterLogCantFailover",
          "old_text": null,
          "new_text": "clusterLogCantFailover(CLUSTER_CANT_FAILOVER_EXPIRED)",
          "old_line_content": "                             CLUSTER_TODO_UPDATE_STATE|",
          "new_line_content": "        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_EXPIRED);",
          "content_same": false
        },
        {
          "line": 4967,
          "old_api": null,
          "new_api": "zmalloc",
          "old_text": null,
          "new_text": "zmalloc(sizeof(robj*)*(num_keys+1))",
          "old_line_content": "                error_from_target = 1;",
          "new_line_content": "    if (!copy) newargv = zmalloc(sizeof(robj*)*(num_keys+1));",
          "content_same": false
        },
        {
          "line": 2921,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\"Starting a failover election for epoch %llu.\",\n            (unsigned long long) server.cluster->currentEpoch)",
          "old_line_content": "",
          "new_line_content": "        serverLog(LL_WARNING,\"Starting a failover election for epoch %llu.\",",
          "content_same": false
        },
        {
          "line": 4970,
          "old_api": null,
          "new_api": "syncReadLine",
          "old_text": null,
          "new_text": "syncReadLine(cs->fd, buf2, sizeof(buf2), timeout)",
          "old_line_content": "            if (!copy) {",
          "new_line_content": "        if (syncReadLine(cs->fd, buf2, sizeof(buf2), timeout) <= 0) {",
          "content_same": false
        },
        {
          "line": 2923,
          "old_api": null,
          "new_api": "clusterRequestFailoverAuth",
          "old_text": null,
          "new_text": "clusterRequestFailoverAuth()",
          "old_line_content": "            \"Failover election won: I'm the new master.\");",
          "new_line_content": "        clusterRequestFailoverAuth();",
          "content_same": false
        },
        {
          "line": 2925,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                             CLUSTER_TODO_UPDATE_STATE|\n                             CLUSTER_TODO_FSYNC_CONFIG)",
          "old_line_content": "        /* Update my configEpoch to the epoch of the election. */",
          "new_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "content_same": false
        },
        {
          "line": 2935,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\n            \"Failover election won: I'm the new master.\")",
          "old_line_content": "    } else {",
          "new_line_content": "        serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 4985,
          "old_api": null,
          "new_api": "dbDelete",
          "old_text": null,
          "new_text": "dbDelete(c->db,kv[j])",
          "old_line_content": "     * and we failed to read the first reply (j == 0 test). */",
          "new_line_content": "                dbDelete(c->db,kv[j]);",
          "content_same": false
        },
        {
          "line": 4986,
          "old_api": null,
          "new_api": "signalModifiedKey",
          "old_text": null,
          "new_text": "signalModifiedKey(c->db,kv[j])",
          "old_line_content": "    if (!error_from_target && socket_error && j == 0 && may_retry &&",
          "new_line_content": "                signalModifiedKey(c->db,kv[j]);",
          "content_same": false
        },
        {
          "line": 2941,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\n                \"configEpoch set to %llu after successful failover\",\n                (unsigned long long) myself->configEpoch)",
          "old_line_content": " * CLUSTER slave migration",
          "new_line_content": "            serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 4991,
          "old_api": null,
          "new_api": "incrRefCount",
          "old_text": null,
          "new_text": "incrRefCount(kv[j])",
          "old_line_content": "",
          "new_line_content": "                incrRefCount(kv[j]);",
          "content_same": false
        },
        {
          "line": 2947,
          "old_api": null,
          "new_api": "clusterFailoverReplaceYourMaster",
          "old_text": null,
          "new_text": "clusterFailoverReplaceYourMaster()",
          "old_line_content": "",
          "new_line_content": "        clusterFailoverReplaceYourMaster();",
          "content_same": false
        },
        {
          "line": 2949,
          "old_api": null,
          "new_api": "clusterLogCantFailover",
          "old_text": null,
          "new_text": "clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES)",
          "old_line_content": " * to a different (orphaned) master. It is called by the clusterCron() function",
          "new_line_content": "        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES);",
          "content_same": false
        },
        {
          "line": 5015,
          "old_api": null,
          "new_api": "createStringObject",
          "old_text": null,
          "new_text": "createStringObject(\"DEL\",3)",
          "old_line_content": "     * already queue a different error reported by the destination server. */",
          "new_line_content": "            newargv[0] = createStringObject(\"DEL\",3);",
          "content_same": false
        },
        {
          "line": 5017,
          "old_api": null,
          "new_api": "replaceClientCommandVector",
          "old_text": null,
          "new_text": "replaceClientCommandVector(c,del_idx,newargv)",
          "old_line_content": "        may_retry = 0;",
          "new_line_content": "            replaceClientCommandVector(c,del_idx,newargv);",
          "content_same": false
        },
        {
          "line": 5021,
          "old_api": null,
          "new_api": "zfree",
          "old_text": null,
          "new_text": "zfree(newargv)",
          "old_line_content": "    if (!error_from_target) {",
          "new_line_content": "            zfree(newargv);",
          "content_same": false
        },
        {
          "line": 2993,
          "old_api": null,
          "new_api": "nodeFailed",
          "old_text": null,
          "new_text": "nodeFailed(mymaster->slaves[j])",
          "old_line_content": "     * happen, and harmless when happens. */",
          "new_line_content": "        if (!nodeFailed(mymaster->slaves[j]) &&",
          "content_same": false
        },
        {
          "line": 2994,
          "old_api": null,
          "new_api": "nodeTimedOut",
          "old_text": null,
          "new_text": "nodeTimedOut(mymaster->slaves[j])",
          "old_line_content": "    candidate = myself;",
          "new_line_content": "            !nodeTimedOut(mymaster->slaves[j])) okslaves++;",
          "content_same": false
        },
        {
          "line": 5042,
          "old_api": null,
          "new_api": "addReply",
          "old_text": null,
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": "socket_err:",
          "new_line_content": "        addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 5048,
          "old_api": null,
          "new_api": "sdsfree",
          "old_text": null,
          "new_text": "sdsfree(cmd.io.buffer.ptr)",
          "old_line_content": "     * we already closed the socket earlier. While migrateCloseSocket()",
          "new_line_content": "    sdsfree(cmd.io.buffer.ptr);",
          "content_same": false
        },
        {
          "line": 5049,
          "old_api": null,
          "new_api": "zfree",
          "old_text": null,
          "new_text": "zfree(newargv)",
          "old_line_content": "     * is idempotent, the host/port arguments are now gone, so don't do it",
          "new_line_content": "    zfree(ov); zfree(kv); zfree(newargv);",
          "content_same": false
        },
        {
          "line": 3009,
          "old_api": null,
          "new_api": "dictNext",
          "old_text": null,
          "new_text": "dictNext(di)",
          "old_line_content": "        if (okslaves > 0) is_orphaned = 0;",
          "new_line_content": "    while((de = dictNext(di)) != NULL) {",
          "content_same": false
        },
        {
          "line": 3010,
          "old_api": null,
          "new_api": "dictGetVal",
          "old_text": null,
          "new_text": "dictGetVal(de)",
          "old_line_content": "",
          "new_line_content": "        clusterNode *node = dictGetVal(de);",
          "content_same": false
        },
        {
          "line": 5058,
          "old_api": null,
          "new_api": "sdsfree",
          "old_text": null,
          "new_text": "sdsfree(cmd.io.buffer.ptr)",
          "old_line_content": "        may_retry = 0;",
          "new_line_content": "    sdsfree(cmd.io.buffer.ptr);",
          "content_same": false
        },
        {
          "line": 3017,
          "old_api": null,
          "new_api": "nodeFailed",
          "old_text": null,
          "new_text": "nodeFailed(node)",
          "old_line_content": "        } else {",
          "new_line_content": "        if (nodeIsSlave(node) || nodeFailed(node)) is_orphaned = 0;",
          "content_same": false
        },
        {
          "line": 3021,
          "old_api": null,
          "new_api": "clusterCountNonFailingSlaves",
          "old_text": null,
          "new_text": "clusterCountNonFailingSlaves(node)",
          "old_line_content": "        /* Check if I'm the slave candidate for the migration: attached",
          "new_line_content": "        if (nodeIsMaster(node)) okslaves = clusterCountNonFailingSlaves(node);",
          "content_same": false
        },
        {
          "line": 5076,
          "old_api": null,
          "new_api": "zfree",
          "old_text": null,
          "new_text": "zfree(kv)",
          "old_line_content": " * The client should issue ASKING before to actually send the command to",
          "new_line_content": "    zfree(ov); zfree(kv);",
          "content_same": false
        },
        {
          "line": 3029,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "                {",
          "new_line_content": "            if (!node->orphaned_time) node->orphaned_time = mstime();",
          "content_same": false
        },
        {
          "line": 5077,
          "old_api": null,
          "new_api": "addReplySds",
          "old_text": null,
          "new_text": "addReplySds(c,\n        sdscatprintf(sdsempty(),\n            \"-IOERR error or timeout %s to target instance\\r\\n\",\n            write_error ? \"writing\" : \"reading\"))",
          "old_line_content": " * the target instance. See the Redis Cluster specification for more",
          "new_line_content": "    addReplySds(c,",
          "content_same": false
        },
        {
          "line": 5078,
          "old_api": null,
          "new_api": "sdsempty",
          "old_text": null,
          "new_text": "sdsempty()",
          "old_line_content": " * information. */",
          "new_line_content": "        sdscatprintf(sdsempty(),",
          "content_same": false
        },
        {
          "line": 3039,
          "old_api": null,
          "new_api": "memcmp",
          "old_text": null,
          "new_text": "memcmp(node->slaves[j]->name,\n                           candidate->name,\n                           CLUSTER_NAMELEN)",
          "old_line_content": "     * couple of seconds, so that during failovers, we give some time to",
          "new_line_content": "                if (memcmp(node->slaves[j]->name,",
          "content_same": false
        },
        {
          "line": 5094,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"This instance has cluster support disabled\")",
          "old_line_content": "        return;",
          "new_line_content": "        addReplyError(c,\"This instance has cluster support disabled\");",
          "content_same": false
        },
        {
          "line": 3048,
          "old_api": null,
          "new_api": "dictReleaseIterator",
          "old_text": null,
          "new_text": "dictReleaseIterator(di)",
          "old_line_content": "    }",
          "new_line_content": "    dictReleaseIterator(di);",
          "content_same": false
        },
        {
          "line": 5098,
          "old_api": null,
          "new_api": "addReply",
          "old_text": null,
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": "}",
          "new_line_content": "    addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 3056,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": " *    setting mf_end to the millisecond unix time at which we'll abort the",
          "new_line_content": "        (mstime()-target->orphaned_time) > CLUSTER_SLAVE_MIGRATION_DELAY)",
          "content_same": false
        },
        {
          "line": 3058,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\"Migrating to orphaned master %.40s\",\n            target->name)",
          "old_line_content": " * 2) Slave sends a MFSTART message to the master requesting to pause clients",
          "new_line_content": "        serverLog(LL_WARNING,\"Migrating to orphaned master %.40s\",",
          "content_same": false
        },
        {
          "line": 5106,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"This instance has cluster support disabled\")",
          "old_line_content": "/* Return the pointer to the cluster node that is able to serve the command.",
          "new_line_content": "        addReplyError(c,\"This instance has cluster support disabled\");",
          "content_same": false
        },
        {
          "line": 3060,
          "old_api": null,
          "new_api": "clusterSetMaster",
          "old_text": null,
          "new_text": "clusterSetMaster(target)",
          "old_line_content": " *    When master is paused for manual failover, it also starts to flag",
          "new_line_content": "        clusterSetMaster(target);",
          "content_same": false
        },
        {
          "line": 5110,
          "old_api": null,
          "new_api": "addReply",
          "old_text": null,
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": " * 2) Multiple keys in the same hash slot, while the slot is stable (no",
          "new_line_content": "    addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 5116,
          "old_api": null,
          "new_api": "addReply",
          "old_text": null,
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": " * 'error_code', which will be set to CLUSTER_REDIR_ASK or",
          "new_line_content": "    addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 3101,
          "old_api": null,
          "new_api": "clientsArePaused",
          "old_text": null,
          "new_text": "clientsArePaused()",
          "old_line_content": "    }",
          "new_line_content": "        clientsArePaused(); /* Just use the side effect of the function. */",
          "content_same": false
        },
        {
          "line": 3111,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "     * next steps are performed by clusterHandleSlaveFailover(). */",
          "new_line_content": "    if (server.cluster->mf_end && server.cluster->mf_end < mstime()) {",
          "content_same": false
        },
        {
          "line": 3112,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\"Manual failover timed out.\")",
          "old_line_content": "    if (server.cluster->mf_can_start) return;",
          "new_line_content": "        serverLog(LL_WARNING,\"Manual failover timed out.\");",
          "content_same": false
        },
        {
          "line": 3113,
          "old_api": null,
          "new_api": "resetManualFailover",
          "old_text": null,
          "new_text": "resetManualFailover()",
          "old_line_content": "",
          "new_line_content": "        resetManualFailover();",
          "content_same": false
        },
        {
          "line": 3129,
          "old_api": null,
          "new_api": "replicationGetSlaveOffset",
          "old_text": null,
          "new_text": "replicationGetSlaveOffset()",
          "old_line_content": "",
          "new_line_content": "    if (server.cluster->mf_master_offset == replicationGetSlaveOffset()) {",
          "content_same": false
        },
        {
          "line": 3133,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\n            \"All master replication stream processed, \"\n            \"manual failover can start.\")",
          "old_line_content": "    dictEntry *de;",
          "new_line_content": "        serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 5192,
          "old_api": null,
          "new_api": "getKeysFromCommand",
          "old_text": null,
          "new_text": "getKeysFromCommand(mcmd,margv,margc,&numkeys)",
          "old_line_content": "                /* Error: If a slot is not served, we are in \"cluster down\"",
          "new_line_content": "        keyindex = getKeysFromCommand(mcmd,margv,margc,&numkeys);",
          "content_same": false
        },
        {
          "line": 5195,
          "old_api": null,
          "new_api": "keyHashSlot",
          "old_text": null,
          "new_text": "keyHashSlot((char*)thiskey->ptr,\n                                       sdslen(thiskey->ptr))",
          "old_line_content": "                 * error to the client. */",
          "new_line_content": "            int thisslot = keyHashSlot((char*)thiskey->ptr,",
          "content_same": false
        },
        {
          "line": 5196,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(thiskey->ptr)",
          "old_line_content": "                if (n == NULL) {",
          "new_line_content": "                                       sdslen(thiskey->ptr));",
          "content_same": false
        },
        {
          "line": 3151,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "        int changed = 0;",
          "new_line_content": "    mstime_t min_pong = 0, now = mstime();",
          "content_same": false
        },
        {
          "line": 5210,
          "old_api": null,
          "new_api": "getKeysFreeResult",
          "old_text": null,
          "new_text": "getKeysFreeResult(keyindex)",
          "old_line_content": "                {",
          "new_line_content": "                    getKeysFreeResult(keyindex);",
          "content_same": false
        },
        {
          "line": 3168,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(prev_ip,curr_ip)",
          "old_line_content": "    }",
          "new_line_content": "        if (prev_ip && curr_ip && strcmp(prev_ip,curr_ip)) changed = 1;",
          "content_same": false
        },
        {
          "line": 3172,
          "old_api": null,
          "new_api": "zstrdup",
          "old_text": null,
          "new_text": "zstrdup(prev_ip)",
          "old_line_content": "     * just the NODE_TIMEOUT value, but when NODE_TIMEOUT is too small we use",
          "new_line_content": "            if (prev_ip) prev_ip = zstrdup(prev_ip);",
          "content_same": false
        },
        {
          "line": 3175,
          "old_api": null,
          "new_api": "strncpy",
          "old_text": null,
          "new_text": "strncpy(myself->ip,server.cluster_announce_ip,NET_IP_STR_LEN)",
          "old_line_content": "    if (handshake_timeout < 1000) handshake_timeout = 1000;",
          "new_line_content": "                strncpy(myself->ip,server.cluster_announce_ip,NET_IP_STR_LEN);",
          "content_same": false
        },
        {
          "line": 5231,
          "old_api": null,
          "new_api": "equalStringObjects",
          "old_text": null,
          "new_text": "equalStringObjects(firstkey,thiskey)",
          "old_line_content": "            }",
          "new_line_content": "                if (!equalStringObjects(firstkey,thiskey)) {",
          "content_same": false
        },
        {
          "line": 5234,
          "old_api": null,
          "new_api": "getKeysFreeResult",
          "old_text": null,
          "new_text": "getKeysFreeResult(keyindex)",
          "old_line_content": "            if ((migrating_slot || importing_slot) &&",
          "new_line_content": "                        getKeysFreeResult(keyindex);",
          "content_same": false
        },
        {
          "line": 3191,
          "old_api": null,
          "new_api": "dictGetSafeIterator",
          "old_text": null,
          "new_text": "dictGetSafeIterator(server.cluster->nodes)",
          "old_line_content": "        if (node->link == NULL) {",
          "new_line_content": "    di = dictGetSafeIterator(server.cluster->nodes);",
          "content_same": false
        },
        {
          "line": 3192,
          "old_api": null,
          "new_api": "dictNext",
          "old_text": null,
          "new_text": "dictNext(di)",
          "old_line_content": "            int fd;",
          "new_line_content": "    while((de = dictNext(di)) != NULL) {",
          "content_same": false
        },
        {
          "line": 3193,
          "old_api": null,
          "new_api": "dictGetVal",
          "old_text": null,
          "new_text": "dictGetVal(de)",
          "old_line_content": "            mstime_t old_ping_sent;",
          "new_line_content": "        clusterNode *node = dictGetVal(de);",
          "content_same": false
        },
        {
          "line": 3199,
          "old_api": null,
          "new_api": "nodeInHandshake",
          "old_text": null,
          "new_text": "nodeInHandshake(node)",
          "old_line_content": "                /* We got a synchronous error from connect before",
          "new_line_content": "        if (nodeInHandshake(node) && now - node->ctime > handshake_timeout) {",
          "content_same": false
        },
        {
          "line": 3200,
          "old_api": null,
          "new_api": "clusterDelNode",
          "old_text": null,
          "new_text": "clusterDelNode(node)",
          "old_line_content": "                 * clusterSendPing() had a chance to be called.",
          "new_line_content": "            clusterDelNode(node);",
          "content_same": false
        },
        {
          "line": 5248,
          "old_api": null,
          "new_api": "lookupKeyRead",
          "old_text": null,
          "new_text": "lookupKeyRead(&server.db[0],thiskey)",
          "old_line_content": "    if (server.cluster->state != CLUSTER_OK) {",
          "new_line_content": "                lookupKeyRead(&server.db[0],thiskey) == NULL)",
          "content_same": false
        },
        {
          "line": 5253,
          "old_api": null,
          "new_api": "getKeysFreeResult",
          "old_text": null,
          "new_text": "getKeysFreeResult(keyindex)",
          "old_line_content": "    /* Return the hashslot by reference. */",
          "new_line_content": "        getKeysFreeResult(keyindex);",
          "content_same": false
        },
        {
          "line": 3209,
          "old_api": null,
          "new_api": "anetTcpNonBlockBindConnect",
          "old_text": null,
          "new_text": "anetTcpNonBlockBindConnect(server.neterr, node->ip,\n                node->cport, NET_FIRST_BIND_ADDR)",
          "old_line_content": "            }",
          "new_line_content": "            fd = anetTcpNonBlockBindConnect(server.neterr, node->ip,",
          "content_same": false
        },
        {
          "line": 3217,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "             *",
          "new_line_content": "                if (node->ping_sent == 0) node->ping_sent = mstime();",
          "content_same": false
        },
        {
          "line": 3218,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_DEBUG, \"Unable to connect to \"\n                    \"Cluster Node [%s]:%d -> %s\", node->ip,\n                    node->cport, server.neterr)",
          "old_line_content": "             * If the node is flagged as MEET, we send a MEET message instead",
          "new_line_content": "                serverLog(LL_DEBUG, \"Unable to connect to \"",
          "content_same": false
        },
        {
          "line": 3223,
          "old_api": null,
          "new_api": "createClusterLink",
          "old_text": null,
          "new_text": "createClusterLink(node)",
          "old_line_content": "                    CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);",
          "new_line_content": "            link = createClusterLink(node);",
          "content_same": false
        },
        {
          "line": 3226,
          "old_api": null,
          "new_api": "aeCreateFileEvent",
          "old_text": null,
          "new_text": "aeCreateFileEvent(server.el,link->fd,AE_READABLE,\n                    clusterReadHandler,link)",
          "old_line_content": "                 * disconnected, we want to restore the ping time, otherwise",
          "new_line_content": "            aeCreateFileEvent(server.el,link->fd,AE_READABLE,",
          "content_same": false
        },
        {
          "line": 3235,
          "old_api": null,
          "new_api": "clusterSendPing",
          "old_text": null,
          "new_text": "clusterSendPing(link, node->flags & CLUSTER_NODE_MEET ?\n                    CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING)",
          "old_line_content": "            node->flags &= ~CLUSTER_NODE_MEET;",
          "new_line_content": "            clusterSendPing(link, node->flags & CLUSTER_NODE_MEET ?",
          "content_same": false
        },
        {
          "line": 3250,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_DEBUG,\"Connecting with Node %.40s at %s:%d\",\n                    node->name, node->ip, node->cport)",
          "old_line_content": "        for (j = 0; j < 5; j++) {",
          "new_line_content": "            serverLog(LL_DEBUG,\"Connecting with Node %.40s at %s:%d\",",
          "content_same": false
        },
        {
          "line": 3254,
          "old_api": null,
          "new_api": "dictReleaseIterator",
          "old_text": null,
          "new_text": "dictReleaseIterator(di)",
          "old_line_content": "            /* Don't ping nodes disconnected or with a ping currently active. */",
          "new_line_content": "    dictReleaseIterator(di);",
          "content_same": false
        },
        {
          "line": 5302,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(myself)",
          "old_line_content": " * that should be set to one of CLUSTER_REDIR_* macros.",
          "new_line_content": "        nodeIsSlave(myself) &&",
          "content_same": false
        },
        {
          "line": 3277,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_DEBUG,\"Pinging node %.40s\", min_pong_node->name)",
          "old_line_content": "    this_slaves = 0;",
          "new_line_content": "            serverLog(LL_DEBUG,\"Pinging node %.40s\", min_pong_node->name);",
          "content_same": false
        },
        {
          "line": 5330,
          "old_api": null,
          "new_api": "sdsnew",
          "old_text": null,
          "new_text": "sdsnew(\"-CLUSTERDOWN The cluster is down\\r\\n\")",
          "old_line_content": "}",
          "new_line_content": "        addReplySds(c,sdsnew(\"-CLUSTERDOWN The cluster is down\\r\\n\"));",
          "content_same": false
        },
        {
          "line": 5332,
          "old_api": null,
          "new_api": "sdsnew",
          "old_text": null,
          "new_text": "sdsnew(\"-CLUSTERDOWN Hash slot not served\\r\\n\")",
          "old_line_content": "/* This function is called by the function processing clients incrementally",
          "new_line_content": "        addReplySds(c,sdsnew(\"-CLUSTERDOWN Hash slot not served\\r\\n\"));",
          "content_same": false
        },
        {
          "line": 5336,
          "old_api": null,
          "new_api": "sdsempty",
          "old_text": null,
          "new_text": "sdsempty()",
          "old_line_content": " * 2) The master migrates the hash slot elsewhere or turns into a slave.",
          "new_line_content": "        addReplySds(c,sdscatprintf(sdsempty(),",
          "content_same": false
        },
        {
          "line": 3292,
          "old_api": null,
          "new_api": "dictNext",
          "old_text": null,
          "new_text": "dictNext(di)",
          "old_line_content": "",
          "new_line_content": "    while((de = dictNext(di)) != NULL) {",
          "content_same": false
        },
        {
          "line": 3293,
          "old_api": null,
          "new_api": "dictGetVal",
          "old_text": null,
          "new_text": "dictGetVal(de)",
          "old_line_content": "            /* A master is orphaned if it is serving a non-zero number of",
          "new_line_content": "        clusterNode *node = dictGetVal(de);",
          "content_same": false
        },
        {
          "line": 3294,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "             * slots, have no working slaves, but used to have at least one",
          "new_line_content": "        now = mstime(); /* Use an updated time at every iteration. */",
          "content_same": false
        },
        {
          "line": 5341,
          "old_api": null,
          "new_api": "serverPanic",
          "old_text": null,
          "new_text": "serverPanic(\"getNodeByQuery() unknown error.\")",
          "old_line_content": " * longer handles, the client is sent a redirection error, and the function",
          "new_line_content": "        serverPanic(\"getNodeByQuery() unknown error.\");",
          "content_same": false
        },
        {
          "line": 3303,
          "old_api": null,
          "new_api": "nodeFailed",
          "old_text": null,
          "new_text": "nodeFailed(node)",
          "old_line_content": "                this_slaves = okslaves;",
          "new_line_content": "        if (nodeIsSlave(myself) && nodeIsMaster(node) && !nodeFailed(node)) {",
          "content_same": false
        },
        {
          "line": 3304,
          "old_api": null,
          "new_api": "clusterCountNonFailingSlaves",
          "old_text": null,
          "new_text": "clusterCountNonFailingSlaves(node)",
          "old_line_content": "        }",
          "new_line_content": "            int okslaves = clusterCountNonFailingSlaves(node);",
          "content_same": false
        },
        {
          "line": 3315,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(myself)",
          "old_line_content": "            now - node->ping_sent > server.cluster_node_timeout/2)",
          "new_line_content": "            if (nodeIsSlave(myself) && myself->slaveof == node)",
          "content_same": false
        },
        {
          "line": 5363,
          "old_api": null,
          "new_api": "clusterRedirectClient",
          "old_text": null,
          "new_text": "clusterRedirectClient(c,NULL,0,CLUSTER_REDIR_DOWN_STATE)",
          "old_line_content": "            if (node != myself &&",
          "new_line_content": "            clusterRedirectClient(c,NULL,0,CLUSTER_REDIR_DOWN_STATE);",
          "content_same": false
        },
        {
          "line": 5368,
          "old_api": null,
          "new_api": "dictNext",
          "old_text": null,
          "new_text": "dictNext(di)",
          "old_line_content": "                        CLUSTER_REDIR_DOWN_UNBOUND);",
          "new_line_content": "        while((de = dictNext(di)) != NULL) {",
          "content_same": false
        },
        {
          "line": 5369,
          "old_api": null,
          "new_api": "dictGetKey",
          "old_text": null,
          "new_text": "dictGetKey(de)",
          "old_line_content": "                } else {",
          "new_line_content": "            robj *key = dictGetKey(de);",
          "content_same": false
        },
        {
          "line": 3331,
          "old_api": null,
          "new_api": "freeClusterLink",
          "old_text": null,
          "new_text": "freeClusterLink(node->link)",
          "old_line_content": "        }",
          "new_line_content": "            freeClusterLink(node->link);",
          "content_same": false
        },
        {
          "line": 5380,
          "old_api": null,
          "new_api": "clusterRedirectClient",
          "old_text": null,
          "new_text": "clusterRedirectClient(c,NULL,0,\n                        CLUSTER_REDIR_DOWN_UNBOUND)",
          "old_line_content": "",
          "new_line_content": "                    clusterRedirectClient(c,NULL,0,",
          "content_same": false
        },
        {
          "line": 5383,
          "old_api": null,
          "new_api": "clusterRedirectClient",
          "old_text": null,
          "new_text": "clusterRedirectClient(c,node,slot,\n                        CLUSTER_REDIR_MOVED)",
          "old_line_content": "",
          "new_line_content": "                    clusterRedirectClient(c,node,slot,",
          "content_same": false
        },
        {
          "line": 5389,
          "old_api": null,
          "new_api": "dictReleaseIterator",
          "old_text": null,
          "new_text": "dictReleaseIterator(di)",
          "old_line_content": "",
          "new_line_content": "        dictReleaseIterator(di);",
          "content_same": false
        },
        {
          "line": 3342,
          "old_api": null,
          "new_api": "clusterSendPing",
          "old_text": null,
          "new_text": "clusterSendPing(node->link, CLUSTERMSG_TYPE_PING)",
          "old_line_content": "        }",
          "new_line_content": "            clusterSendPing(node->link, CLUSTERMSG_TYPE_PING);",
          "content_same": false
        },
        {
          "line": 3349,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(myself)",
          "old_line_content": "         * code at all. */",
          "new_line_content": "            nodeIsMaster(myself) &&",
          "content_same": false
        },
        {
          "line": 3353,
          "old_api": null,
          "new_api": "clusterSendPing",
          "old_text": null,
          "new_text": "clusterSendPing(node->link, CLUSTERMSG_TYPE_PING)",
          "old_line_content": "            /* Timeout reached. Set the node as possibly failing if it is",
          "new_line_content": "            clusterSendPing(node->link, CLUSTERMSG_TYPE_PING);",
          "content_same": false
        },
        {
          "line": 3369,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_DEBUG,\"*** NODE %.40s possibly failing\",\n                    node->name)",
          "old_line_content": "        server.masterhost == NULL &&",
          "new_line_content": "                serverLog(LL_DEBUG,\"*** NODE %.40s possibly failing\",",
          "content_same": false
        },
        {
          "line": 3376,
          "old_api": null,
          "new_api": "dictReleaseIterator",
          "old_text": null,
          "new_text": "dictReleaseIterator(di)",
          "old_line_content": "    /* Abourt a manual failover if the timeout is reached. */",
          "new_line_content": "    dictReleaseIterator(di);",
          "content_same": false
        },
        {
          "line": 3384,
          "old_api": null,
          "new_api": "nodeHasAddr",
          "old_text": null,
          "new_text": "nodeHasAddr(myself->slaveof)",
          "old_line_content": "         * the orphaned masters. Note that it does not make sense to try",
          "new_line_content": "        nodeHasAddr(myself->slaveof))",
          "content_same": false
        },
        {
          "line": 3386,
          "old_api": null,
          "new_api": "replicationSetMaster",
          "old_text": null,
          "new_text": "replicationSetMaster(myself->slaveof->ip, myself->slaveof->port)",
          "old_line_content": "         * slaves. */",
          "new_line_content": "        replicationSetMaster(myself->slaveof->ip, myself->slaveof->port);",
          "content_same": false
        },
        {
          "line": 3390,
          "old_api": null,
          "new_api": "manualFailoverCheckTimeout",
          "old_text": null,
          "new_text": "manualFailoverCheckTimeout()",
          "old_line_content": "",
          "new_line_content": "    manualFailoverCheckTimeout();",
          "content_same": false
        },
        {
          "line": 3393,
          "old_api": null,
          "new_api": "clusterHandleManualFailover",
          "old_text": null,
          "new_text": "clusterHandleManualFailover()",
          "old_line_content": "}",
          "new_line_content": "        clusterHandleManualFailover();",
          "content_same": false
        },
        {
          "line": 3394,
          "old_api": null,
          "new_api": "clusterHandleSlaveFailover",
          "old_text": null,
          "new_text": "clusterHandleSlaveFailover()",
          "old_line_content": "",
          "new_line_content": "        clusterHandleSlaveFailover();",
          "content_same": false
        },
        {
          "line": 3401,
          "old_api": null,
          "new_api": "clusterHandleSlaveMigration",
          "old_text": null,
          "new_text": "clusterHandleSlaveMigration(max_slaves)",
          "old_line_content": "    /* Handle failover, this is needed when it is likely that there is already",
          "new_line_content": "            clusterHandleSlaveMigration(max_slaves);",
          "content_same": false
        },
        {
          "line": 3405,
          "old_api": null,
          "new_api": "clusterUpdateState",
          "old_text": null,
          "new_text": "clusterUpdateState()",
          "old_line_content": "",
          "new_line_content": "        clusterUpdateState();",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": null,
          "new_api": "clusterNodeFailureReportsCount",
          "old_text": null,
          "new_text": "clusterNodeFailureReportsCount(node)",
          "old_line_content": "                !(flags & CLUSTER_NODE_NOADDR) &&",
          "new_line_content": "                clusterNodeFailureReportsCount(node) == 0)",
          "content_same": false
        },
        {
          "line": 3417,
          "old_api": null,
          "new_api": "clusterHandleSlaveFailover",
          "old_text": null,
          "new_text": "clusterHandleSlaveFailover()",
          "old_line_content": "    /* Reset our flags (not strictly needed since every single function",
          "new_line_content": "        clusterHandleSlaveFailover();",
          "content_same": false
        },
        {
          "line": 3421,
          "old_api": null,
          "new_api": "clusterUpdateState",
          "old_text": null,
          "new_text": "clusterUpdateState()",
          "old_line_content": "",
          "new_line_content": "        clusterUpdateState();",
          "content_same": false
        },
        {
          "line": 1378,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(node->ip,g->ip)",
          "old_line_content": "             *",
          "new_line_content": "                (strcasecmp(node->ip,g->ip) ||",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": null,
          "new_api": "ntohs",
          "old_text": null,
          "new_text": "ntohs(g->port)",
          "old_line_content": "             * Note that we require that the sender of this gossip message",
          "new_line_content": "                 node->port != ntohs(g->port) ||",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": null,
          "new_api": "ntohs",
          "old_text": null,
          "new_text": "ntohs(g->cport)",
          "old_line_content": "             * is a well known node in our cluster, otherwise we risk",
          "new_line_content": "                 node->cport != ntohs(g->cport)))",
          "content_same": false
        },
        {
          "line": 3427,
          "old_api": null,
          "new_api": "clusterSaveConfigOrDie",
          "old_text": null,
          "new_text": "clusterSaveConfigOrDie(fsync)",
          "old_line_content": " * Slots management",
          "new_line_content": "        clusterSaveConfigOrDie(fsync);",
          "content_same": false
        },
        {
          "line": 1382,
          "old_api": null,
          "new_api": "freeClusterLink",
          "old_text": null,
          "new_text": "freeClusterLink(node->link)",
          "old_line_content": "            if (sender &&",
          "new_line_content": "                if (node->link) freeClusterLink(node->link);",
          "content_same": false
        },
        {
          "line": 1383,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(node->ip,g->ip,NET_IP_STR_LEN)",
          "old_line_content": "                !(flags & CLUSTER_NODE_NOADDR) &&",
          "new_line_content": "                memcpy(node->ip,g->ip,NET_IP_STR_LEN);",
          "content_same": false
        },
        {
          "line": 1385,
          "old_api": null,
          "new_api": "ntohs",
          "old_text": null,
          "new_text": "ntohs(g->cport)",
          "old_line_content": "            {",
          "new_line_content": "                node->cport = ntohs(g->cport);",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": null,
          "new_api": "clusterBlacklistExists",
          "old_text": null,
          "new_text": "clusterBlacklistExists(g->nodename)",
          "old_line_content": " * the IP from the socket peer address. */",
          "new_line_content": "                !clusterBlacklistExists(g->nodename))",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": null,
          "new_api": "ntohs",
          "old_text": null,
          "new_text": "ntohs(g->cport)",
          "old_line_content": "    if (announced_ip[0] != '\\0') {",
          "new_line_content": "                clusterStartHandshake(g->ip,ntohs(g->port),ntohs(g->cport));",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(buf,announced_ip,NET_IP_STR_LEN)",
          "old_line_content": " *",
          "new_line_content": "        memcpy(buf,announced_ip,NET_IP_STR_LEN);",
          "content_same": false
        },
        {
          "line": 1416,
          "old_api": null,
          "new_api": "anetPeerToString",
          "old_text": null,
          "new_text": "anetPeerToString(link->fd, buf, NET_IP_STR_LEN, NULL)",
          "old_line_content": " *",
          "new_line_content": "        anetPeerToString(link->fd, buf, NET_IP_STR_LEN, NULL);",
          "content_same": false
        },
        {
          "line": 3469,
          "old_api": null,
          "new_api": "dictGetSafeIterator",
          "old_text": null,
          "new_text": "dictGetSafeIterator(server.cluster->nodes)",
          "old_line_content": "/* Set the slot bit and return the old value. */",
          "new_line_content": "    dictIterator *di = dictGetSafeIterator(server.cluster->nodes);",
          "content_same": false
        },
        {
          "line": 3473,
          "old_api": null,
          "new_api": "dictGetVal",
          "old_text": null,
          "new_text": "dictGetVal(de)",
          "old_line_content": "    if (!old) {",
          "new_line_content": "        clusterNode *node = dictGetVal(de);",
          "content_same": false
        },
        {
          "line": 3475,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(node)",
          "old_line_content": "        /* When a master gets its first slot, even if it has no slaves,",
          "new_line_content": "        if (nodeIsSlave(node)) continue;",
          "content_same": false
        },
        {
          "line": 3478,
          "old_api": null,
          "new_api": "dictReleaseIterator",
          "old_text": null,
          "new_text": "dictReleaseIterator(di)",
          "old_line_content": "         * the other masters has slaves right now.",
          "new_line_content": "    dictReleaseIterator(di);",
          "content_same": false
        },
        {
          "line": 3484,
          "old_api": null,
          "new_api": "bitmapTestBit",
          "old_text": null,
          "new_text": "bitmapTestBit(n->slots,slot)",
          "old_line_content": "         * However new masters with slots assigned are considered valid",
          "new_line_content": "    int old = bitmapTestBit(n->slots,slot);",
          "content_same": false
        },
        {
          "line": 1437,
          "old_api": null,
          "new_api": "ntohs",
          "old_text": null,
          "new_text": "ntohs(hdr->cport)",
          "old_line_content": "",
          "new_line_content": "    int cport = ntohs(hdr->cport);",
          "content_same": false
        },
        {
          "line": 3485,
          "old_api": null,
          "new_api": "bitmapSetBit",
          "old_text": null,
          "new_text": "bitmapSetBit(n->slots,slot)",
          "old_line_content": "         * migration tagets if the rest of the cluster is not a slave-less.",
          "new_line_content": "    bitmapSetBit(n->slots,slot);",
          "content_same": false
        },
        {
          "line": 1447,
          "old_api": null,
          "new_api": "nodeIp2String",
          "old_text": null,
          "new_text": "nodeIp2String(ip,link,hdr->myip)",
          "old_line_content": "    /* Check if this is our master and we have to change the",
          "new_line_content": "    nodeIp2String(ip,link,hdr->myip);",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(node->ip,ip,sizeof(ip))",
          "old_line_content": "}",
          "new_line_content": "    memcpy(node->ip,ip,sizeof(ip));",
          "content_same": false
        },
        {
          "line": 3501,
          "old_api": null,
          "new_api": "clusterMastersHaveSlaves",
          "old_text": null,
          "new_text": "clusterMastersHaveSlaves()",
          "old_line_content": "",
          "new_line_content": "        if (n->numslots == 1 && clusterMastersHaveSlaves())",
          "content_same": false
        },
        {
          "line": 1455,
          "old_api": null,
          "new_api": "freeClusterLink",
          "old_text": null,
          "new_text": "freeClusterLink(node->link)",
          "old_line_content": " * a node that we believed to be a slave is now acting as master in order to",
          "new_line_content": "    if (node->link) freeClusterLink(node->link);",
          "content_same": false
        },
        {
          "line": 1457,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\"Address updated for node %.40s, now %s:%d\",\n        node->name, node->ip, node->port)",
          "old_line_content": "void clusterSetNodeAsMaster(clusterNode *n) {",
          "new_line_content": "    serverLog(LL_WARNING,\"Address updated for node %.40s, now %s:%d\",",
          "content_same": false
        },
        {
          "line": 3509,
          "old_api": null,
          "new_api": "bitmapTestBit",
          "old_text": null,
          "new_text": "bitmapTestBit(n->slots,slot)",
          "old_line_content": " * If the slot is already assigned to another instance this is considered",
          "new_line_content": "    int old = bitmapTestBit(n->slots,slot);",
          "content_same": false
        },
        {
          "line": 1462,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(myself)",
          "old_line_content": "        if (n != myself) n->flags |= CLUSTER_NODE_MIGRATE_TO;",
          "new_line_content": "    if (nodeIsSlave(myself) && myself->slaveof == node)",
          "content_same": false
        },
        {
          "line": 1463,
          "old_api": null,
          "new_api": "replicationSetMaster",
          "old_text": null,
          "new_text": "replicationSetMaster(node->ip, node->port)",
          "old_line_content": "    }",
          "new_line_content": "        replicationSetMaster(node->ip, node->port);",
          "content_same": false
        },
        {
          "line": 3510,
          "old_api": null,
          "new_api": "bitmapClearBit",
          "old_text": null,
          "new_text": "bitmapClearBit(n->slots,slot)",
          "old_line_content": " * an error and C_ERR is returned. */",
          "new_line_content": "    bitmapClearBit(n->slots,slot);",
          "content_same": false
        },
        {
          "line": 3517,
          "old_api": null,
          "new_api": "bitmapTestBit",
          "old_text": null,
          "new_text": "bitmapTestBit(n->slots,slot)",
          "old_line_content": "",
          "new_line_content": "    return bitmapTestBit(n->slots,slot);",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(n)",
          "old_line_content": "}",
          "new_line_content": "    if (nodeIsMaster(n)) return;",
          "content_same": false
        },
        {
          "line": 1474,
          "old_api": null,
          "new_api": "clusterNodeRemoveSlave",
          "old_text": null,
          "new_text": "clusterNodeRemoveSlave(n->slaveof,n)",
          "old_line_content": " * PING, PONG or UPDATE packet. What we receive is a node, a configEpoch of the",
          "new_line_content": "        clusterNodeRemoveSlave(n->slaveof,n);",
          "content_same": false
        },
        {
          "line": 3526,
          "old_api": null,
          "new_api": "clusterNodeSetSlotBit",
          "old_text": null,
          "new_text": "clusterNodeSetSlotBit(n,slot)",
          "old_line_content": "    server.cluster->slots[slot] = NULL;",
          "new_line_content": "    clusterNodeSetSlotBit(n,slot);",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                         CLUSTER_TODO_UPDATE_STATE)",
          "old_line_content": " * Sometimes it is not actually the \"Sender\" of the information, like in the",
          "new_line_content": "    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "content_same": false
        },
        {
          "line": 3538,
          "old_api": null,
          "new_api": "clusterNodeClearSlotBit",
          "old_text": null,
          "new_text": "clusterNodeClearSlotBit(n,slot)",
          "old_line_content": "    }",
          "new_line_content": "    serverAssert(clusterNodeClearSlotBit(n,slot) == 1);",
          "content_same": false
        },
        {
          "line": 3549,
          "old_api": null,
          "new_api": "clusterDelSlot",
          "old_text": null,
          "new_text": "clusterDelSlot(j)",
          "old_line_content": "}",
          "new_line_content": "        if (clusterNodeGetSlotBit(node,j)) clusterDelSlot(j);",
          "content_same": false
        },
        {
          "line": 3558,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(server.cluster->migrating_slots_to,0,\n        sizeof(server.cluster->migrating_slots_to))",
          "old_line_content": " * than the network latency. */",
          "new_line_content": "    memset(server.cluster->migrating_slots_to,0,",
          "content_same": false
        },
        {
          "line": 3560,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(server.cluster->importing_slots_from,0,\n        sizeof(server.cluster->importing_slots_from))",
          "old_line_content": "#define CLUSTER_MIN_REJOIN_DELAY 500",
          "new_line_content": "    memset(server.cluster->importing_slots_from,0,",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(myself)",
          "old_line_content": "             * manually via redis-trib (example: a resharding is in progress",
          "new_line_content": "    curmaster = nodeIsMaster(myself) ? myself : myself->slaveof;",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\"Discarding UPDATE message about myself.\")",
          "old_line_content": "            if (server.cluster->importing_slots_from[j]) continue;",
          "new_line_content": "        serverLog(LL_WARNING,\"Discarding UPDATE message about myself.\");",
          "content_same": false
        },
        {
          "line": 1521,
          "old_api": null,
          "new_api": "bitmapTestBit",
          "old_text": null,
          "new_text": "bitmapTestBit(slots,j)",
          "old_line_content": "             * 2) We are not currently importing the slot. */",
          "new_line_content": "        if (bitmapTestBit(slots,j)) {",
          "content_same": false
        },
        {
          "line": 1541,
          "old_api": null,
          "new_api": "countKeysInSlot",
          "old_text": null,
          "new_text": "countKeysInSlot(j)",
          "old_line_content": "                                     CLUSTER_TODO_FSYNC_CONFIG);",
          "new_line_content": "                    countKeysInSlot(j) &&",
          "content_same": false
        },
        {
          "line": 3590,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "                server.cluster->slots[j]->flags & (CLUSTER_NODE_FAIL))",
          "new_line_content": "    if (first_call_time == 0) first_call_time = mstime();",
          "content_same": false
        },
        {
          "line": 3591,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(myself)",
          "old_line_content": "            {",
          "new_line_content": "    if (nodeIsMaster(myself) &&",
          "content_same": false
        },
        {
          "line": 3593,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "                break;",
          "new_line_content": "        mstime() - first_call_time < CLUSTER_WRITABLE_DELAY) return;",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": null,
          "new_api": "clusterDelSlot",
          "old_text": null,
          "new_text": "clusterDelSlot(j)",
          "old_line_content": "     *    master.",
          "new_line_content": "                clusterDelSlot(j);",
          "content_same": false
        },
        {
          "line": 1551,
          "old_api": null,
          "new_api": "clusterAddSlot",
          "old_text": null,
          "new_text": "clusterAddSlot(sender,j)",
          "old_line_content": "     * 2) We are a slave and our master is left without slots. We need",
          "new_line_content": "                clusterAddSlot(sender,j);",
          "content_same": false
        },
        {
          "line": 1552,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                                     CLUSTER_TODO_UPDATE_STATE|\n                                     CLUSTER_TODO_FSYNC_CONFIG)",
          "old_line_content": "     *    to replicate to the new slots owner. */",
          "new_line_content": "                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\n            \"Configuration change detected. Reconfiguring myself \"\n            \"as a replica of %.40s\", sender->name)",
          "old_line_content": "         * In order to maintain a consistent state between keys and slots",
          "new_line_content": "        serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 1571,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                             CLUSTER_TODO_UPDATE_STATE|\n                             CLUSTER_TODO_FSYNC_CONFIG)",
          "old_line_content": "    }",
          "new_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "content_same": false
        },
        {
          "line": 3621,
          "old_api": null,
          "new_api": "dictGetSafeIterator",
          "old_text": null,
          "new_text": "dictGetSafeIterator(server.cluster->nodes)",
          "old_line_content": "    /* If we are in a minority partition, change the cluster state",
          "new_line_content": "        di = dictGetSafeIterator(server.cluster->nodes);",
          "content_same": false
        },
        {
          "line": 3622,
          "old_api": null,
          "new_api": "dictNext",
          "old_text": null,
          "new_text": "dictNext(di)",
          "old_line_content": "     * to FAIL. */",
          "new_line_content": "        while((de = dictNext(di)) != NULL) {",
          "content_same": false
        },
        {
          "line": 3623,
          "old_api": null,
          "new_api": "dictGetVal",
          "old_text": null,
          "new_text": "dictGetVal(de)",
          "old_line_content": "    {",
          "new_line_content": "            clusterNode *node = dictGetVal(de);",
          "content_same": false
        },
        {
          "line": 3625,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(node)",
          "old_line_content": "",
          "new_line_content": "            if (nodeIsMaster(node) && node->numslots) {",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": null,
          "new_api": "delKeysInSlot",
          "old_text": null,
          "new_text": "delKeysInSlot(dirty_slots[j])",
          "old_line_content": "int clusterProcessPacket(clusterLink *link) {",
          "new_line_content": "            delKeysInSlot(dirty_slots[j]);",
          "content_same": false
        },
        {
          "line": 3631,
          "old_api": null,
          "new_api": "dictReleaseIterator",
          "old_text": null,
          "new_text": "dictReleaseIterator(di)",
          "old_line_content": "",
          "new_line_content": "        dictReleaseIterator(di);",
          "content_same": false
        },
        {
          "line": 3641,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "            rejoin_delay = CLUSTER_MAX_REJOIN_DELAY;",
          "new_line_content": "            among_minority_time = mstime();",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": null,
          "new_api": "ntohl",
          "old_text": null,
          "new_text": "ntohl(hdr->totlen)",
          "old_line_content": "        /* Can't handle messages of different versions. */",
          "new_line_content": "    uint32_t totlen = ntohl(hdr->totlen);",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": null,
          "new_api": "ntohs",
          "old_text": null,
          "new_text": "ntohs(hdr->type)",
          "old_line_content": "        return 1;",
          "new_line_content": "    uint16_t type = ntohs(hdr->type);",
          "content_same": false
        },
        {
          "line": 1603,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_DEBUG,\"--- Processing packet of type %d, %lu bytes\",\n        type, (unsigned long) totlen)",
          "old_line_content": "    uint64_t senderCurrentEpoch = 0, senderConfigEpoch = 0;",
          "new_line_content": "    serverLog(LL_DEBUG,\"--- Processing packet of type %d, %lu bytes\",",
          "content_same": false
        },
        {
          "line": 1608,
          "old_api": null,
          "new_api": "sdslen",
          "old_text": null,
          "new_text": "sdslen(link->rcvbuf)",
          "old_line_content": "    {",
          "new_line_content": "    if (totlen > sdslen(link->rcvbuf)) return 1;",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": null,
          "new_api": "ntohs",
          "old_text": null,
          "new_text": "ntohs(hdr->ver)",
          "old_line_content": "        uint32_t explen; /* expected length of this packet */",
          "new_line_content": "    if (ntohs(hdr->ver) != CLUSTER_PROTO_VER) {",
          "content_same": false
        },
        {
          "line": 3659,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(myself)",
          "old_line_content": "/* This function is called after the node startup in order to verify that data",
          "new_line_content": "            nodeIsMaster(myself) &&",
          "content_same": false
        },
        {
          "line": 3660,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": " * loaded from disk is in agreement with the cluster configuration:",
          "new_line_content": "            mstime() - among_minority_time < rejoin_delay)",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": null,
          "new_api": "ntohs",
          "old_text": null,
          "new_text": "ntohs(hdr->flags)",
          "old_line_content": "    } else if (type == CLUSTERMSG_TYPE_FAIL) {",
          "new_line_content": "    uint16_t flags = ntohs(hdr->flags);",
          "content_same": false
        },
        {
          "line": 3666,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\"Cluster state changed: %s\",\n            new_state == CLUSTER_OK ? \"ok\" : \"fail\")",
          "old_line_content": " *    B) If according to our config other nodes are already in charge for",
          "new_line_content": "        serverLog(LL_WARNING,\"Cluster state changed: %s\",",
          "content_same": false
        },
        {
          "line": 1622,
          "old_api": null,
          "new_api": "ntohs",
          "old_text": null,
          "new_text": "ntohs(hdr->count)",
          "old_line_content": "",
          "new_line_content": "        uint16_t count = ntohs(hdr->count);",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": null,
          "new_api": "ntohl",
          "old_text": null,
          "new_text": "ntohl(hdr->data.publish.msg.channel_len)",
          "old_line_content": "        explen += sizeof(clusterMsgDataUpdate);",
          "new_line_content": "                ntohl(hdr->data.publish.msg.channel_len) +",
          "content_same": false
        },
        {
          "line": 1639,
          "old_api": null,
          "new_api": "ntohl",
          "old_text": null,
          "new_text": "ntohl(hdr->data.publish.msg.message_len)",
          "old_line_content": "        if (totlen != explen) return 1;",
          "new_line_content": "                ntohl(hdr->data.publish.msg.message_len);",
          "content_same": false
        },
        {
          "line": 3700,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(myself)",
          "old_line_content": "         * sense. */",
          "new_line_content": "    if (nodeIsSlave(myself)) return C_OK;",
          "content_same": false
        },
        {
          "line": 1656,
          "old_api": null,
          "new_api": "clusterLookupNode",
          "old_text": null,
          "new_text": "clusterLookupNode(hdr->sender)",
          "old_line_content": "        /* Update the replication offset info for this node. */",
          "new_line_content": "    sender = clusterLookupNode(hdr->sender);",
          "content_same": false
        },
        {
          "line": 3704,
          "old_api": null,
          "new_api": "dictSize",
          "old_text": null,
          "new_text": "dictSize(server.db[j].dict)",
          "old_line_content": "        /* If we are here data and cluster config don't agree, and we have",
          "new_line_content": "        if (dictSize(server.db[j].dict)) return C_ERR;",
          "content_same": false
        },
        {
          "line": 1659,
          "old_api": null,
          "new_api": "ntohu64",
          "old_text": null,
          "new_text": "ntohu64(hdr->currentEpoch)",
          "old_line_content": "        /* If we are a slave performing a manual failover and our master",
          "new_line_content": "        senderCurrentEpoch = ntohu64(hdr->currentEpoch);",
          "content_same": false
        },
        {
          "line": 1660,
          "old_api": null,
          "new_api": "ntohu64",
          "old_text": null,
          "new_text": "ntohu64(hdr->configEpoch)",
          "old_line_content": "         * sent its offset while already paused, populate the MF state. */",
          "new_line_content": "        senderConfigEpoch = ntohu64(hdr->configEpoch);",
          "content_same": false
        },
        {
          "line": 3710,
          "old_api": null,
          "new_api": "countKeysInSlot",
          "old_text": null,
          "new_text": "countKeysInSlot(j)",
          "old_line_content": "        if (server.cluster->slots[j] == NULL) {",
          "new_line_content": "        if (!countKeysInSlot(j)) continue; /* No keys in this slot. */",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                                 CLUSTER_TODO_FSYNC_CONFIG)",
          "old_line_content": "        {",
          "new_line_content": "            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": null,
          "new_api": "ntohu64",
          "old_text": null,
          "new_text": "ntohu64(hdr->offset)",
          "old_line_content": "                \"master manual failover: %lld\",",
          "new_line_content": "        sender->repl_offset = ntohu64(hdr->offset);",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "                server.cluster->mf_master_offset);",
          "new_line_content": "        sender->repl_offset_time = mstime();",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": null,
          "new_api": "nodeIsSlave",
          "old_text": null,
          "new_text": "nodeIsSlave(myself)",
          "old_line_content": "    /* Initial processing of PING and MEET requests replying with a PONG. */",
          "new_line_content": "            nodeIsSlave(myself) &&",
          "content_same": false
        },
        {
          "line": 3724,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING, \"I have keys for unassigned slot %d. \"\n                                    \"Taking responsibility for it.\",j)",
          "old_line_content": "",
          "new_line_content": "            serverLog(LL_WARNING, \"I have keys for unassigned slot %d. \"",
          "content_same": false
        },
        {
          "line": 3726,
          "old_api": null,
          "new_api": "clusterAddSlot",
          "old_text": null,
          "new_text": "clusterAddSlot(myself,j)",
          "old_line_content": " * SLAVE nodes handling",
          "new_line_content": "            clusterAddSlot(myself,j);",
          "content_same": false
        },
        {
          "line": 3728,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING, \"I have keys for slot %d, but the slot is \"\n                                    \"assigned to another node. \"\n                                    \"Setting it to importing state.\",j)",
          "old_line_content": "",
          "new_line_content": "            serverLog(LL_WARNING, \"I have keys for slot %d, but the slot is \"",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\n                \"Received replication offset for paused \"\n                \"master manual failover: %lld\",\n                server.cluster->mf_master_offset)",
          "old_line_content": "         * MEET messages on handshakes, when the cluster joins, or",
          "new_line_content": "            serverLog(LL_WARNING,",
          "content_same": false
        },
        {
          "line": 3734,
          "old_api": null,
          "new_api": "clusterSaveConfigOrDie",
          "old_text": null,
          "new_text": "clusterSaveConfigOrDie(1)",
          "old_line_content": "",
          "new_line_content": "    if (update_config) clusterSaveConfigOrDie(1);",
          "content_same": false
        },
        {
          "line": 1690,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_DEBUG,\"Ping packet received: %p\", (void*)link->node)",
          "old_line_content": "        if ((type == CLUSTERMSG_TYPE_MEET || myself->ip[0] == '\\0') &&",
          "new_line_content": "        serverLog(LL_DEBUG,\"Ping packet received: %p\", (void*)link->node);",
          "content_same": false
        },
        {
          "line": 3748,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(myself)",
          "old_line_content": "",
          "new_line_content": "    if (nodeIsMaster(myself)) {",
          "content_same": false
        },
        {
          "line": 3751,
          "old_api": null,
          "new_api": "clusterCloseAllSlots",
          "old_text": null,
          "new_text": "clusterCloseAllSlots()",
          "old_line_content": " * -------------------------------------------------------------------------- */",
          "new_line_content": "        clusterCloseAllSlots();",
          "content_same": false
        },
        {
          "line": 3754,
          "old_api": null,
          "new_api": "clusterNodeRemoveSlave",
          "old_text": null,
          "new_text": "clusterNodeRemoveSlave(myself->slaveof,myself)",
          "old_line_content": "    uint16_t flag;",
          "new_line_content": "            clusterNodeRemoveSlave(myself->slaveof,myself);",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": null,
          "new_api": "anetSockName",
          "old_text": null,
          "new_text": "anetSockName(link->fd,ip,sizeof(ip),NULL)",
          "old_line_content": "         * resolved when we'll receive PONGs from the node. */",
          "new_line_content": "            if (anetSockName(link->fd,ip,sizeof(ip),NULL) != -1 &&",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(ip,myself->ip)",
          "old_line_content": "        if (!sender && type == CLUSTERMSG_TYPE_MEET) {",
          "new_line_content": "                strcmp(ip,myself->ip))",
          "content_same": false
        },
        {
          "line": 3757,
          "old_api": null,
          "new_api": "clusterNodeAddSlave",
          "old_text": null,
          "new_text": "clusterNodeAddSlave(n,myself)",
          "old_line_content": "",
          "new_line_content": "    clusterNodeAddSlave(n,myself);",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(myself->ip,ip,NET_IP_STR_LEN)",
          "old_line_content": "",
          "new_line_content": "                memcpy(myself->ip,ip,NET_IP_STR_LEN);",
          "content_same": false
        },
        {
          "line": 3758,
          "old_api": null,
          "new_api": "replicationSetMaster",
          "old_text": null,
          "new_text": "replicationSetMaster(n->ip, n->port)",
          "old_line_content": "static struct redisNodeFlags redisNodeFlagsTable[] = {",
          "new_line_content": "    replicationSetMaster(n->ip, n->port);",
          "content_same": false
        },
        {
          "line": 3759,
          "old_api": null,
          "new_api": "resetManualFailover",
          "old_text": null,
          "new_text": "resetManualFailover()",
          "old_line_content": "    {CLUSTER_NODE_MYSELF,       \"myself,\"},",
          "new_line_content": "    resetManualFailover();",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": null,
          "new_api": "createClusterNode",
          "old_text": null,
          "new_text": "createClusterNode(NULL,CLUSTER_NODE_HANDSHAKE)",
          "old_line_content": "",
          "new_line_content": "            node = createClusterNode(NULL,CLUSTER_NODE_HANDSHAKE);",
          "content_same": false
        },
        {
          "line": 1726,
          "old_api": null,
          "new_api": "nodeIp2String",
          "old_text": null,
          "new_text": "nodeIp2String(node->ip,link,hdr->myip)",
          "old_line_content": "        /* Anyway reply with a PONG */",
          "new_line_content": "            nodeIp2String(node->ip,link,hdr->myip);",
          "content_same": false
        },
        {
          "line": 1728,
          "old_api": null,
          "new_api": "ntohs",
          "old_text": null,
          "new_text": "ntohs(hdr->cport)",
          "old_line_content": "    }",
          "new_line_content": "            node->cport = ntohs(hdr->cport);",
          "content_same": false
        },
        {
          "line": 1729,
          "old_api": null,
          "new_api": "clusterAddNode",
          "old_text": null,
          "new_text": "clusterAddNode(node)",
          "old_line_content": "",
          "new_line_content": "            clusterAddNode(node);",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG)",
          "old_line_content": "    /* PING, PONG, MEET: process config information. */",
          "new_line_content": "            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);",
          "content_same": false
        },
        {
          "line": 1737,
          "old_api": null,
          "new_api": "clusterProcessGossipSection",
          "old_text": null,
          "new_text": "clusterProcessGossipSection(hdr,link)",
          "old_line_content": "        if (link->node) {",
          "new_line_content": "            clusterProcessGossipSection(hdr,link);",
          "content_same": false
        },
        {
          "line": 3785,
          "old_api": null,
          "new_api": "sdscat",
          "old_text": null,
          "new_text": "sdscat(ci,\"noflags,\")",
          "old_line_content": " * See clusterGenNodesDescription() top comment for more information.",
          "new_line_content": "        ci = sdscat(ci,\"noflags,\");",
          "content_same": false
        },
        {
          "line": 1740,
          "old_api": null,
          "new_api": "clusterSendPing",
          "old_text": null,
          "new_text": "clusterSendPing(link,CLUSTERMSG_TYPE_PONG)",
          "old_line_content": "                 * IP/port of the node with the new one. */",
          "new_line_content": "        clusterSendPing(link,CLUSTERMSG_TYPE_PONG);",
          "content_same": false
        },
        {
          "line": 3790,
          "old_api": null,
          "new_api": "sdscat",
          "old_text": null,
          "new_text": "sdscat(ci, nodeflag->name)",
          "old_line_content": "    sds ci;",
          "new_line_content": "            if (flags & nodeflag->flag) ci = sdscat(ci, nodeflag->name);",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": null,
          "new_api": "nodeInHandshake",
          "old_text": null,
          "new_text": "nodeInHandshake(link->node)",
          "old_line_content": "                     * cause the link to be freed as well. */",
          "new_line_content": "            if (nodeInHandshake(link->node)) {",
          "content_same": false
        },
        {
          "line": 1755,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_VERBOSE,\n                        \"Handshake: we already know node %.40s, \"\n                        \"updating the address if needed.\", sender->name)",
          "old_line_content": "",
          "new_line_content": "                    serverLog(LL_VERBOSE,",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                                             CLUSTER_TODO_UPDATE_STATE)",
          "old_line_content": "                    link->node->name);",
          "new_line_content": "                        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "content_same": false
        },
        {
          "line": 1765,
          "old_api": null,
          "new_api": "clusterDelNode",
          "old_text": null,
          "new_text": "clusterDelNode(link->node)",
          "old_line_content": "                        CLUSTER_NAMELEN) != 0)",
          "new_line_content": "                    clusterDelNode(link->node);",
          "content_same": false
        },
        {
          "line": 3813,
          "old_api": null,
          "new_api": "representClusterNodeFlags",
          "old_text": null,
          "new_text": "representClusterNodeFlags(ci, node->flags)",
          "old_line_content": "        (node->link || node->flags & CLUSTER_NODE_MYSELF) ?",
          "new_line_content": "    ci = representClusterNodeFlags(ci, node->flags);",
          "content_same": false
        },
        {
          "line": 3817,
          "old_api": null,
          "new_api": "sdscatprintf",
          "old_text": null,
          "new_text": "sdscatprintf(ci,\" %.40s \",node->slaveof->name)",
          "old_line_content": "    start = -1;",
          "new_line_content": "        ci = sdscatprintf(ci,\" %.40s \",node->slaveof->name);",
          "content_same": false
        },
        {
          "line": 1771,
          "old_api": null,
          "new_api": "clusterRenameNode",
          "old_text": null,
          "new_text": "clusterRenameNode(link->node, hdr->sender)",
          "old_line_content": "                    link->node->name,",
          "new_line_content": "                clusterRenameNode(link->node, hdr->sender);",
          "content_same": false
        },
        {
          "line": 3819,
          "old_api": null,
          "new_api": "sdscatlen",
          "old_text": null,
          "new_text": "sdscatlen(ci,\" - \",3)",
          "old_line_content": "        int bit;",
          "new_line_content": "        ci = sdscatlen(ci,\" - \",3);",
          "content_same": false
        },
        {
          "line": 3822,
          "old_api": null,
          "new_api": "sdscatprintf",
          "old_text": null,
          "new_text": "sdscatprintf(ci,\"%lld %lld %llu %s\",\n        (long long) node->ping_sent,\n        (long long) node->pong_received,\n        (unsigned long long) node->configEpoch,\n        (node->link || node->flags & CLUSTER_NODE_MYSELF) ?\n                    \"connected\" : \"disconnected\")",
          "old_line_content": "            if (start == -1) start = j;",
          "new_line_content": "    ci = sdscatprintf(ci,\"%lld %lld %llu %s\",",
          "content_same": false
        },
        {
          "line": 1776,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG)",
          "old_line_content": "                link->node->port = 0;",
          "new_line_content": "                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": null,
          "new_api": "memcmp",
          "old_text": null,
          "new_text": "memcmp(link->node->name,hdr->sender,\n                        CLUSTER_NAMELEN)",
          "old_line_content": "                link->node->cport = 0;",
          "new_line_content": "            } else if (memcmp(link->node->name,hdr->sender,",
          "content_same": false
        },
        {
          "line": 1783,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_DEBUG,\"PONG contains mismatching sender ID. About node %.40s added %d ms ago, having flags %d\",\n                    link->node->name,\n                    (int)(mstime()-(link->node->ctime)),\n                    link->node->flags)",
          "old_line_content": "",
          "new_line_content": "                serverLog(LL_DEBUG,\"PONG contains mismatching sender ID. About node %.40s added %d ms ago, having flags %d\",",
          "content_same": false
        },
        {
          "line": 1785,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "        if (sender && type == CLUSTERMSG_TYPE_PING &&",
          "new_line_content": "                    (int)(mstime()-(link->node->ctime)),",
          "content_same": false
        },
        {
          "line": 3834,
          "old_api": null,
          "new_api": "clusterNodeGetSlotBit",
          "old_text": null,
          "new_text": "clusterNodeGetSlotBit(node,j)",
          "old_line_content": "    }",
          "new_line_content": "        if ((bit = clusterNodeGetSlotBit(node,j)) != 0) {",
          "content_same": false
        },
        {
          "line": 1791,
          "old_api": null,
          "new_api": "freeClusterLink",
          "old_text": null,
          "new_text": "freeClusterLink(link)",
          "old_line_content": "        }",
          "new_line_content": "                freeClusterLink(link);",
          "content_same": false
        },
        {
          "line": 1792,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG)",
          "old_line_content": "",
          "new_line_content": "                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);",
          "content_same": false
        },
        {
          "line": 3841,
          "old_api": null,
          "new_api": "sdscatprintf",
          "old_text": null,
          "new_text": "sdscatprintf(ci,\" %d\",start)",
          "old_line_content": "            if (server.cluster->migrating_slots_to[j]) {",
          "new_line_content": "                ci = sdscatprintf(ci,\" %d\",start);",
          "content_same": false
        },
        {
          "line": 3843,
          "old_api": null,
          "new_api": "sdscatprintf",
          "old_text": null,
          "new_text": "sdscatprintf(ci,\" %d-%d\",start,j-1)",
          "old_line_content": "                    server.cluster->migrating_slots_to[j]->name);",
          "new_line_content": "                ci = sdscatprintf(ci,\" %d-%d\",start,j-1);",
          "content_same": false
        },
        {
          "line": 1799,
          "old_api": null,
          "new_api": "nodeInHandshake",
          "old_text": null,
          "new_text": "nodeInHandshake(sender)",
          "old_line_content": "             * help if it is momentary (that is, if it does not",
          "new_line_content": "            !nodeInHandshake(sender) &&",
          "content_same": false
        },
        {
          "line": 1800,
          "old_api": null,
          "new_api": "nodeUpdateAddressIfNeeded",
          "old_text": null,
          "new_text": "nodeUpdateAddressIfNeeded(sender,link,hdr)",
          "old_line_content": "             * turn into a FAIL state).",
          "new_line_content": "            nodeUpdateAddressIfNeeded(sender,link,hdr))",
          "content_same": false
        },
        {
          "line": 1802,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                                 CLUSTER_TODO_UPDATE_STATE)",
          "old_line_content": "             * The FAIL condition is also reversible under specific",
          "new_line_content": "            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "content_same": false
        },
        {
          "line": 3855,
          "old_api": null,
          "new_api": "sdscatprintf",
          "old_text": null,
          "new_text": "sdscatprintf(ci,\" [%d->-%.40s]\",j,\n                    server.cluster->migrating_slots_to[j]->name)",
          "old_line_content": " * representation (it is up to the caller to free it).",
          "new_line_content": "                ci = sdscatprintf(ci,\" [%d->-%.40s]\",j,",
          "content_same": false
        },
        {
          "line": 3858,
          "old_api": null,
          "new_api": "sdscatprintf",
          "old_text": null,
          "new_text": "sdscatprintf(ci,\" [%d-<-%.40s]\",j,\n                    server.cluster->importing_slots_from[j]->name)",
          "old_line_content": " * \"filter\" are excluded from the output, so using zero as a filter will",
          "new_line_content": "                ci = sdscatprintf(ci,\" [%d-<-%.40s]\",j,",
          "content_same": false
        },
        {
          "line": 1817,
          "old_api": null,
          "new_api": "nodeTimedOut",
          "old_text": null,
          "new_text": "nodeTimedOut(link->node)",
          "old_line_content": "            {",
          "new_line_content": "            if (nodeTimedOut(link->node)) {",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": null,
          "new_api": "nodeFailed",
          "old_text": null,
          "new_text": "nodeFailed(link->node)",
          "old_line_content": "                /* Node is a slave. */",
          "new_line_content": "            } else if (nodeFailed(link->node)) {",
          "content_same": false
        },
        {
          "line": 1828,
          "old_api": null,
          "new_api": "memcmp",
          "old_text": null,
          "new_text": "memcmp(hdr->slaveof,CLUSTER_NODE_NULL_NAME,\n                sizeof(hdr->slaveof))",
          "old_line_content": "                                       CLUSTER_NODE_MIGRATE_TO);",
          "new_line_content": "            if (!memcmp(hdr->slaveof,CLUSTER_NODE_NULL_NAME,",
          "content_same": false
        },
        {
          "line": 3879,
          "old_api": null,
          "new_api": "sdsempty",
          "old_text": null,
          "new_text": "sdsempty()",
          "old_line_content": "    }",
          "new_line_content": "    sds ci = sdsempty(), ni;",
          "content_same": false
        },
        {
          "line": 1835,
          "old_api": null,
          "new_api": "clusterLookupNode",
          "old_text": null,
          "new_text": "clusterLookupNode(hdr->slaveof)",
          "old_line_content": "",
          "new_line_content": "                clusterNode *master = clusterLookupNode(hdr->slaveof);",
          "content_same": false
        },
        {
          "line": 3883,
          "old_api": null,
          "new_api": "dictGetSafeIterator",
          "old_text": null,
          "new_text": "dictGetSafeIterator(server.cluster->nodes)",
          "old_line_content": "",
          "new_line_content": "    di = dictGetSafeIterator(server.cluster->nodes);",
          "content_same": false
        },
        {
          "line": 1837,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(sender)",
          "old_line_content": "                if (master && sender->slaveof != master) {",
          "new_line_content": "                if (nodeIsMaster(sender)) {",
          "content_same": false
        },
        {
          "line": 3884,
          "old_api": null,
          "new_api": "dictNext",
          "old_text": null,
          "new_text": "dictNext(di)",
          "old_line_content": "/* -----------------------------------------------------------------------------",
          "new_line_content": "    while((de = dictNext(di)) != NULL) {",
          "content_same": false
        },
        {
          "line": 3885,
          "old_api": null,
          "new_api": "dictGetVal",
          "old_text": null,
          "new_text": "dictGetVal(de)",
          "old_line_content": " * CLUSTER command",
          "new_line_content": "        clusterNode *node = dictGetVal(de);",
          "content_same": false
        },
        {
          "line": 3888,
          "old_api": null,
          "new_api": "clusterGenNodeDescription",
          "old_text": null,
          "new_text": "clusterGenNodeDescription(node)",
          "old_line_content": "const char *clusterGetMessageTypeString(int type) {",
          "new_line_content": "        ni = clusterGenNodeDescription(node);",
          "content_same": false
        },
        {
          "line": 3889,
          "old_api": null,
          "new_api": "sdscatsds",
          "old_text": null,
          "new_text": "sdscatsds(ci,ni)",
          "old_line_content": "    switch(type) {",
          "new_line_content": "        ci = sdscatsds(ci,ni);",
          "content_same": false
        },
        {
          "line": 3890,
          "old_api": null,
          "new_api": "sdsfree",
          "old_text": null,
          "new_text": "sdsfree(ni)",
          "old_line_content": "    case CLUSTERMSG_TYPE_PING: return \"ping\";",
          "new_line_content": "        sdsfree(ni);",
          "content_same": false
        },
        {
          "line": 3891,
          "old_api": null,
          "new_api": "sdscatlen",
          "old_text": null,
          "new_text": "sdscatlen(ci,\"\\n\",1)",
          "old_line_content": "    case CLUSTERMSG_TYPE_PONG: return \"pong\";",
          "new_line_content": "        ci = sdscatlen(ci,\"\\n\",1);",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                                         CLUSTER_TODO_UPDATE_STATE)",
          "old_line_content": "                }",
          "new_line_content": "                    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "content_same": false
        },
        {
          "line": 3893,
          "old_api": null,
          "new_api": "dictReleaseIterator",
          "old_text": null,
          "new_text": "dictReleaseIterator(di)",
          "old_line_content": "    case CLUSTERMSG_TYPE_FAIL: return \"fail\";",
          "new_line_content": "    dictReleaseIterator(di);",
          "content_same": false
        },
        {
          "line": 1852,
          "old_api": null,
          "new_api": "clusterNodeRemoveSlave",
          "old_text": null,
          "new_text": "clusterNodeRemoveSlave(sender->slaveof,sender)",
          "old_line_content": "         * so that CLUSTER_NODE_MASTER flag will be set. */",
          "new_line_content": "                        clusterNodeRemoveSlave(sender->slaveof,sender);",
          "content_same": false
        },
        {
          "line": 1853,
          "old_api": null,
          "new_api": "clusterNodeAddSlave",
          "old_text": null,
          "new_text": "clusterNodeAddSlave(master,sender)",
          "old_line_content": "",
          "new_line_content": "                    clusterNodeAddSlave(master,sender);",
          "content_same": false
        },
        {
          "line": 1857,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG)",
          "old_line_content": "         * checks later. */",
          "new_line_content": "                    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);",
          "content_same": false
        },
        {
          "line": 3919,
          "old_api": null,
          "new_api": "getLongLongFromObject",
          "old_text": null,
          "new_text": "getLongLongFromObject(o,&slot)",
          "old_line_content": "     *               2) master port",
          "new_line_content": "    if (getLongLongFromObject(o,&slot) != C_OK ||",
          "content_same": false
        },
        {
          "line": 3922,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"Invalid or out of range slot\")",
          "old_line_content": "     *               2) replica port",
          "new_line_content": "        addReplyError(c,\"Invalid or out of range slot\");",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(sender)",
          "old_line_content": "        /* 2) We also check for the reverse condition, that is, the sender",
          "new_line_content": "            sender_master = nodeIsMaster(sender) ? sender : sender->slaveof;",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": null,
          "new_api": "memcmp",
          "old_text": null,
          "new_text": "memcmp(sender_master->slots,\n                        hdr->myslots,sizeof(hdr->myslots))",
          "old_line_content": "         *    greater configEpoch. If this happens we inform the sender.",
          "new_line_content": "                dirty_slots = memcmp(sender_master->slots,",
          "content_same": false
        },
        {
          "line": 1885,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(sender)",
          "old_line_content": "         * A is partitioned away, B gets promoted.",
          "new_line_content": "        if (sender && nodeIsMaster(sender) && dirty_slots)",
          "content_same": false
        },
        {
          "line": 1886,
          "old_api": null,
          "new_api": "clusterUpdateSlotsConfigWith",
          "old_text": null,
          "new_text": "clusterUpdateSlotsConfigWith(sender,senderConfigEpoch,hdr->myslots)",
          "old_line_content": "         * B is partitioned away, and A returns available.",
          "new_line_content": "            clusterUpdateSlotsConfigWith(sender,senderConfigEpoch,hdr->myslots);",
          "content_same": false
        },
        {
          "line": 3941,
          "old_api": null,
          "new_api": "addDeferredMultiBulkLength",
          "old_text": null,
          "new_text": "addDeferredMultiBulkLength(c)",
          "old_line_content": "            int bit, i;",
          "new_line_content": "    void *slot_replylen = addDeferredMultiBulkLength(c);",
          "content_same": false
        },
        {
          "line": 3944,
          "old_api": null,
          "new_api": "dictGetSafeIterator",
          "old_text": null,
          "new_text": "dictGetSafeIterator(server.cluster->nodes)",
          "old_line_content": "                if (start == -1) start = j;",
          "new_line_content": "    dictIterator *di = dictGetSafeIterator(server.cluster->nodes);",
          "content_same": false
        },
        {
          "line": 3945,
          "old_api": null,
          "new_api": "dictNext",
          "old_text": null,
          "new_text": "dictNext(di)",
          "old_line_content": "            }",
          "new_line_content": "    while((de = dictNext(di)) != NULL) {",
          "content_same": false
        },
        {
          "line": 3946,
          "old_api": null,
          "new_api": "dictGetVal",
          "old_text": null,
          "new_text": "dictGetVal(de)",
          "old_line_content": "            if (start != -1 && (!bit || j == CLUSTER_SLOTS-1)) {",
          "new_line_content": "        clusterNode *node = dictGetVal(de);",
          "content_same": false
        },
        {
          "line": 3951,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(node)",
          "old_line_content": "",
          "new_line_content": "        if (!nodeIsMaster(node) || node->numslots == 0) continue;",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": null,
          "new_api": "bitmapTestBit",
          "old_text": null,
          "new_text": "bitmapTestBit(hdr->myslots,j)",
          "old_line_content": "                        /* TODO: instead of exiting the loop send every other",
          "new_line_content": "                if (bitmapTestBit(hdr->myslots,j)) {",
          "content_same": false
        },
        {
          "line": 3961,
          "old_api": null,
          "new_api": "addDeferredMultiBulkLength",
          "old_text": null,
          "new_text": "addDeferredMultiBulkLength(c)",
          "old_line_content": "                start = -1;",
          "new_line_content": "                void *nested_replylen = addDeferredMultiBulkLength(c);",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_VERBOSE,\n                            \"Node %.40s has old slots configuration, sending \"\n                            \"an UPDATE message about %.40s\",\n                                sender->name, server.cluster->slots[j]->name)",
          "old_line_content": "            }",
          "new_line_content": "                        serverLog(LL_VERBOSE,",
          "content_same": false
        },
        {
          "line": 1920,
          "old_api": null,
          "new_api": "clusterSendUpdate",
          "old_text": null,
          "new_text": "clusterSendUpdate(sender->link,\n                            server.cluster->slots[j])",
          "old_line_content": "         * the problem. */",
          "new_line_content": "                        clusterSendUpdate(sender->link,",
          "content_same": false
        },
        {
          "line": 3968,
          "old_api": null,
          "new_api": "addReplyLongLong",
          "old_text": null,
          "new_text": "addReplyLongLong(c, start)",
          "old_line_content": "",
          "new_line_content": "                    addReplyLongLong(c, start); /* only one slot; low==high */",
          "content_same": false
        },
        {
          "line": 3969,
          "old_api": null,
          "new_api": "addReplyLongLong",
          "old_text": null,
          "new_text": "addReplyLongLong(c, start)",
          "old_line_content": "                /* Remaining nodes in reply are replicas for slot range */",
          "new_line_content": "                    addReplyLongLong(c, start);",
          "content_same": false
        },
        {
          "line": 3971,
          "old_api": null,
          "new_api": "addReplyLongLong",
          "old_text": null,
          "new_text": "addReplyLongLong(c, start)",
          "old_line_content": "                    /* This loop is copy/pasted from clusterGenNodeDescription()",
          "new_line_content": "                    addReplyLongLong(c, start); /* low */",
          "content_same": false
        },
        {
          "line": 3972,
          "old_api": null,
          "new_api": "addReplyLongLong",
          "old_text": null,
          "new_text": "addReplyLongLong(c, j-1)",
          "old_line_content": "                     * with modifications for per-slot node aggregation */",
          "new_line_content": "                    addReplyLongLong(c, j-1);   /* high */",
          "content_same": false
        },
        {
          "line": 3978,
          "old_api": null,
          "new_api": "addReplyBulkCString",
          "old_text": null,
          "new_text": "addReplyBulkCString(c, node->ip)",
          "old_line_content": "                    nested_elements++;",
          "new_line_content": "                addReplyBulkCString(c, node->ip);",
          "content_same": false
        },
        {
          "line": 3979,
          "old_api": null,
          "new_api": "addReplyLongLong",
          "old_text": null,
          "new_text": "addReplyLongLong(c, node->port)",
          "old_line_content": "                }",
          "new_line_content": "                addReplyLongLong(c, node->port);",
          "content_same": false
        },
        {
          "line": 1935,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(sender)",
          "old_line_content": "            if (failing &&",
          "new_line_content": "            nodeIsMaster(myself) && nodeIsMaster(sender) &&",
          "content_same": false
        },
        {
          "line": 3987,
          "old_api": null,
          "new_api": "addReplyMultiBulkLen",
          "old_text": null,
          "new_text": "addReplyMultiBulkLen(c, 3)",
          "old_line_content": "}",
          "new_line_content": "                    addReplyMultiBulkLen(c, 3);",
          "content_same": false
        },
        {
          "line": 3988,
          "old_api": null,
          "new_api": "addReplyBulkCString",
          "old_text": null,
          "new_text": "addReplyBulkCString(c, node->slaves[i]->ip)",
          "old_line_content": "",
          "new_line_content": "                    addReplyBulkCString(c, node->slaves[i]->ip);",
          "content_same": false
        },
        {
          "line": 3989,
          "old_api": null,
          "new_api": "addReplyLongLong",
          "old_text": null,
          "new_text": "addReplyLongLong(c, node->slaves[i]->port)",
          "old_line_content": "void clusterCommand(client *c) {",
          "new_line_content": "                    addReplyLongLong(c, node->slaves[i]->port);",
          "content_same": false
        },
        {
          "line": 3990,
          "old_api": null,
          "new_api": "addReplyBulkCBuffer",
          "old_text": null,
          "new_text": "addReplyBulkCBuffer(c, node->slaves[i]->name, CLUSTER_NAMELEN)",
          "old_line_content": "    if (server.cluster_enabled == 0) {",
          "new_line_content": "                    addReplyBulkCBuffer(c, node->slaves[i]->name, CLUSTER_NAMELEN);",
          "content_same": false
        },
        {
          "line": 3993,
          "old_api": null,
          "new_api": "setDeferredMultiBulkLength",
          "old_text": null,
          "new_text": "setDeferredMultiBulkLength(c, nested_replylen, nested_elements)",
          "old_line_content": "    }",
          "new_line_content": "                setDeferredMultiBulkLength(c, nested_replylen, nested_elements);",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": null,
          "new_api": "clusterLookupNode",
          "old_text": null,
          "new_text": "clusterLookupNode(hdr->data.fail.about.nodename)",
          "old_line_content": "        } else {",
          "new_line_content": "            failing = clusterLookupNode(hdr->data.fail.about.nodename);",
          "content_same": false
        },
        {
          "line": 3998,
          "old_api": null,
          "new_api": "dictReleaseIterator",
          "old_text": null,
          "new_text": "dictReleaseIterator(di)",
          "old_line_content": "",
          "new_line_content": "    dictReleaseIterator(di);",
          "content_same": false
        },
        {
          "line": 1951,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_NOTICE,\n                    \"FAIL message received from %.40s about %.40s\",\n                    hdr->sender, hdr->data.fail.about.nodename)",
          "old_line_content": "        }",
          "new_line_content": "                serverLog(LL_NOTICE,",
          "content_same": false
        },
        {
          "line": 1955,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "",
          "new_line_content": "                failing->fail_time = mstime();",
          "content_same": false
        },
        {
          "line": 4004,
          "old_api": null,
          "new_api": "addReplyError",
          "old_text": null,
          "new_text": "addReplyError(c,\"This instance has cluster support disabled\")",
          "old_line_content": "",
          "new_line_content": "        addReplyError(c,\"This instance has cluster support disabled\");",
          "content_same": false
        },
        {
          "line": 1957,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                                     CLUSTER_TODO_UPDATE_STATE)",
          "old_line_content": "         * Pub/Sub subscribers. */",
          "new_line_content": "                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "content_same": false
        },
        {
          "line": 4008,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[1]->ptr,\"meet\")",
          "old_line_content": "                                    (char*)c->argv[4]->ptr);",
          "new_line_content": "    if (!strcasecmp(c->argv[1]->ptr,\"meet\") && (c->argc == 4 || c->argc == 5)) {",
          "content_same": false
        },
        {
          "line": 4012,
          "old_api": null,
          "new_api": "getLongLongFromObject",
          "old_text": null,
          "new_text": "getLongLongFromObject(c->argv[3], &port)",
          "old_line_content": "            cport = port + CLUSTER_PORT_INCR;",
          "new_line_content": "        if (getLongLongFromObject(c->argv[3], &port) != C_OK) {",
          "content_same": false
        },
        {
          "line": 4013,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\"Invalid TCP base port specified: %s\",\n                                (char*)c->argv[3]->ptr)",
          "old_line_content": "        }",
          "new_line_content": "            addReplyErrorFormat(c,\"Invalid TCP base port specified: %s\",",
          "content_same": false
        },
        {
          "line": 1971,
          "old_api": null,
          "new_api": "dictSize",
          "old_text": null,
          "new_text": "dictSize(server.pubsub_channels)",
          "old_line_content": "        }",
          "new_line_content": "        if (dictSize(server.pubsub_channels) ||",
          "content_same": false
        },
        {
          "line": 1972,
          "old_api": null,
          "new_api": "listLength",
          "old_text": null,
          "new_text": "listLength(server.pubsub_patterns)",
          "old_line_content": "    } else if (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST) {",
          "new_line_content": "           listLength(server.pubsub_patterns))",
          "content_same": false
        },
        {
          "line": 4019,
          "old_api": null,
          "new_api": "getLongLongFromObject",
          "old_text": null,
          "new_text": "getLongLongFromObject(c->argv[4], &cport)",
          "old_line_content": "                            (char*)c->argv[2]->ptr, (char*)c->argv[3]->ptr);",
          "new_line_content": "            if (getLongLongFromObject(c->argv[4], &cport) != C_OK) {",
          "content_same": false
        },
        {
          "line": 4020,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\"Invalid TCP bus port specified: %s\",\n                                    (char*)c->argv[4]->ptr)",
          "old_line_content": "        } else {",
          "new_line_content": "                addReplyErrorFormat(c,\"Invalid TCP bus port specified: %s\",",
          "content_same": false
        },
        {
          "line": 1975,
          "old_api": null,
          "new_api": "ntohl",
          "old_text": null,
          "new_text": "ntohl(hdr->data.publish.msg.message_len)",
          "old_line_content": "    } else if (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK) {",
          "new_line_content": "            message_len = ntohl(hdr->data.publish.msg.message_len);",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": null,
          "new_api": "createStringObject",
          "old_text": null,
          "new_text": "createStringObject(\n                        (char*)hdr->data.publish.msg.bulk_data,channel_len)",
          "old_line_content": "        if (!sender) return 1;  /* We don't know that node. */",
          "new_line_content": "            channel = createStringObject(",
          "content_same": false
        },
        {
          "line": 1978,
          "old_api": null,
          "new_api": "createStringObject",
          "old_text": null,
          "new_text": "createStringObject(\n                        (char*)hdr->data.publish.msg.bulk_data+channel_len,\n                        message_len)",
          "old_line_content": "         * a non zero number of slots, and its currentEpoch is greater or",
          "new_line_content": "            message = createStringObject(",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": null,
          "new_api": "pubsubPublishMessage",
          "old_text": null,
          "new_text": "pubsubPublishMessage(channel,message)",
          "old_line_content": "            senderCurrentEpoch >= server.cluster->failover_auth_epoch)",
          "new_line_content": "            pubsubPublishMessage(channel,message);",
          "content_same": false
        },
        {
          "line": 1982,
          "old_api": null,
          "new_api": "decrRefCount",
          "old_text": null,
          "new_text": "decrRefCount(channel)",
          "old_line_content": "        {",
          "new_line_content": "            decrRefCount(channel);",
          "content_same": false
        },
        {
          "line": 1983,
          "old_api": null,
          "new_api": "decrRefCount",
          "old_text": null,
          "new_text": "decrRefCount(message)",
          "old_line_content": "            server.cluster->failover_auth_count++;",
          "new_line_content": "            decrRefCount(message);",
          "content_same": false
        },
        {
          "line": 1987,
          "old_api": null,
          "new_api": "clusterSendFailoverAuthIfNeeded",
          "old_text": null,
          "new_text": "clusterSendFailoverAuthIfNeeded(sender,hdr)",
          "old_line_content": "        }",
          "new_line_content": "        clusterSendFailoverAuthIfNeeded(sender,hdr);",
          "content_same": false
        },
        {
          "line": 1993,
          "old_api": null,
          "new_api": "nodeIsMaster",
          "old_text": null,
          "new_text": "nodeIsMaster(sender)",
          "old_line_content": "         * accordingly. */",
          "new_line_content": "        if (nodeIsMaster(sender) && sender->numslots > 0 &&",
          "content_same": false
        },
        {
          "line": 4041,
          "old_api": null,
          "new_api": "createObject",
          "old_text": null,
          "new_text": "createObject(OBJ_STRING,ci)",
          "old_line_content": "            return;",
          "new_line_content": "        o = createObject(OBJ_STRING,ci);",
          "content_same": false
        },
        {
          "line": 4042,
          "old_api": null,
          "new_api": "addReplyBulk",
          "old_text": null,
          "new_text": "addReplyBulk(c,o)",
          "old_line_content": "        }",
          "new_line_content": "        addReplyBulk(c,o);",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER)",
          "old_line_content": "            sender->name);",
          "new_line_content": "            clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);",
          "content_same": false
        },
        {
          "line": 4049,
          "old_api": null,
          "new_api": "clusterReplyMultiBulkSlots",
          "old_text": null,
          "new_text": "clusterReplyMultiBulkSlots(c)",
          "old_line_content": "        /* CLUSTER ADDSLOTS <slot> [slot] ... */",
          "new_line_content": "        clusterReplyMultiBulkSlots(c);",
          "content_same": false
        },
        {
          "line": 4050,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[1]->ptr,\"flushslots\")",
          "old_line_content": "        /* CLUSTER DELSLOTS <slot> [slot] ... */",
          "new_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"flushslots\") && c->argc == 2) {",
          "content_same": false
        },
        {
          "line": 2007,
          "old_api": null,
          "new_api": "resetManualFailover",
          "old_text": null,
          "new_text": "resetManualFailover()",
          "old_line_content": "        if (!n) return 1;   /* We don't know the reported node. */",
          "new_line_content": "        resetManualFailover();",
          "content_same": false
        },
        {
          "line": 2008,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "        if (n->configEpoch >= reportedConfigEpoch) return 1; /* Nothing new. */",
          "new_line_content": "        server.cluster->mf_end = mstime() + CLUSTER_MF_TIMEOUT;",
          "content_same": false
        },
        {
          "line": 4056,
          "old_api": null,
          "new_api": "clusterDelNodeSlots",
          "old_text": null,
          "new_text": "clusterDelNodeSlots(myself)",
          "old_line_content": "        /* Check that all the arguments are parseable and that all the",
          "new_line_content": "        clusterDelNodeSlots(myself);",
          "content_same": false
        },
        {
          "line": 2010,
          "old_api": null,
          "new_api": "mstime",
          "old_text": null,
          "new_text": "mstime()",
          "old_line_content": "        /* If in our current config the node is a slave, set it as a master. */",
          "new_line_content": "        pauseClients(mstime()+(CLUSTER_MF_TIMEOUT*2));",
          "content_same": false
        },
        {
          "line": 4057,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG)",
          "old_line_content": "         * slots are not already busy. */",
          "new_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);",
          "content_same": false
        },
        {
          "line": 4058,
          "old_api": null,
          "new_api": "addReply",
          "old_text": null,
          "new_text": "addReply(c,shared.ok)",
          "old_line_content": "        for (j = 2; j < c->argc; j++) {",
          "new_line_content": "        addReply(c,shared.ok);",
          "content_same": false
        },
        {
          "line": 2016,
          "old_api": null,
          "new_api": "ntohu64",
          "old_text": null,
          "new_text": "ntohu64(hdr->data.update.nodecfg.configEpoch)",
          "old_line_content": "                             CLUSTER_TODO_FSYNC_CONFIG);",
          "new_line_content": "                    ntohu64(hdr->data.update.nodecfg.configEpoch);",
          "content_same": false
        },
        {
          "line": 4066,
          "old_api": null,
          "new_api": "strcasecmp",
          "old_text": null,
          "new_text": "strcasecmp(c->argv[1]->ptr,\"delslots\")",
          "old_line_content": "                return;",
          "new_line_content": "        int del = !strcasecmp(c->argv[1]->ptr,\"delslots\");",
          "content_same": false
        },
        {
          "line": 2019,
          "old_api": null,
          "new_api": "clusterLookupNode",
          "old_text": null,
          "new_text": "clusterLookupNode(hdr->data.update.nodecfg.nodename)",
          "old_line_content": "         * config accordingly. */",
          "new_line_content": "        n = clusterLookupNode(hdr->data.update.nodecfg.nodename);",
          "content_same": false
        },
        {
          "line": 2024,
          "old_api": null,
          "new_api": "clusterSetNodeAsMaster",
          "old_text": null,
          "new_text": "clusterSetNodeAsMaster(n)",
          "old_line_content": "    }",
          "new_line_content": "        if (nodeIsSlave(n)) clusterSetNodeAsMaster(n);",
          "content_same": false
        },
        {
          "line": 4072,
          "old_api": null,
          "new_api": "getSlotOrReply",
          "old_text": null,
          "new_text": "getSlotOrReply(c,c->argv[j])",
          "old_line_content": "            if (slots[slot]++ == 1) {",
          "new_line_content": "            if ((slot = getSlotOrReply(c,c->argv[j])) == -1) {",
          "content_same": false
        },
        {
          "line": 2028,
          "old_api": null,
          "new_api": "clusterDoBeforeSleep",
          "old_text": null,
          "new_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                             CLUSTER_TODO_FSYNC_CONFIG)",
          "old_line_content": "/* This function is called when we detect the link with this node is lost.",
          "new_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "content_same": false
        },
        {
          "line": 4077,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\"Slot %d is already unassigned\", slot)",
          "old_line_content": "            }",
          "new_line_content": "                addReplyErrorFormat(c,\"Slot %d is already unassigned\", slot);",
          "content_same": false
        },
        {
          "line": 4078,
          "old_api": null,
          "new_api": "zfree",
          "old_text": null,
          "new_text": "zfree(slots)",
          "old_line_content": "        }",
          "new_line_content": "                zfree(slots);",
          "content_same": false
        },
        {
          "line": 2033,
          "old_api": null,
          "new_api": "clusterUpdateSlotsConfigWith",
          "old_text": null,
          "new_text": "clusterUpdateSlotsConfigWith(n,reportedConfigEpoch,\n            hdr->data.update.nodecfg.slots)",
          "old_line_content": "   completely free the node on error. */",
          "new_line_content": "        clusterUpdateSlotsConfigWith(n,reportedConfigEpoch,",
          "content_same": false
        },
        {
          "line": 4081,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\"Slot %d is already busy\", slot)",
          "old_line_content": "                int retval;",
          "new_line_content": "                addReplyErrorFormat(c,\"Slot %d is already busy\", slot);",
          "content_same": false
        },
        {
          "line": 4082,
          "old_api": null,
          "new_api": "zfree",
          "old_text": null,
          "new_text": "zfree(slots)",
          "old_line_content": "",
          "new_line_content": "                zfree(slots);",
          "content_same": false
        },
        {
          "line": 2036,
          "old_api": null,
          "new_api": "serverLog",
          "old_text": null,
          "new_text": "serverLog(LL_WARNING,\"Received unknown packet type: %d\", type)",
          "old_line_content": "}",
          "new_line_content": "        serverLog(LL_WARNING,\"Received unknown packet type: %d\", type);",
          "content_same": false
        },
        {
          "line": 4086,
          "old_api": null,
          "new_api": "addReplyErrorFormat",
          "old_text": null,
          "new_text": "addReplyErrorFormat(c,\"Slot %d specified multiple times\",\n                    (int)slot)",
          "old_line_content": "                    server.cluster->importing_slots_from[j] = NULL;",
          "new_line_content": "                addReplyErrorFormat(c,\"Slot %d specified multiple times\",",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 4096,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[1]->ptr,\"setslot\")",
          "new_text": null,
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"setslot\") && c->argc >= 4) {",
          "new_line_content": "                /* If this slot was set as importing we can clear this",
          "content_same": false
        },
        {
          "line": 2049,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_DEBUG,\"I/O error writing to node link: %s\",\n            strerror(errno))",
          "new_text": null,
          "old_line_content": "        serverLog(LL_DEBUG,\"I/O error writing to node link: %s\",",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2050,
          "old_api": "strerror",
          "new_api": null,
          "old_text": "strerror(errno)",
          "new_text": null,
          "old_line_content": "            strerror(errno));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2051,
          "old_api": "handleLinkIOError",
          "new_api": null,
          "old_text": "handleLinkIOError(link)",
          "new_text": null,
          "old_line_content": "        handleLinkIOError(link);",
          "new_line_content": "/* Send data. This is handled using a trivial send buffer that gets",
          "content_same": false
        },
        {
          "line": 2054,
          "old_api": "sdsrange",
          "new_api": null,
          "old_text": "sdsrange(link->sndbuf,nwritten,-1)",
          "new_text": null,
          "old_line_content": "    sdsrange(link->sndbuf,nwritten,-1);",
          "new_line_content": "void clusterWriteHandler(aeEventLoop *el, int fd, void *privdata, int mask) {",
          "content_same": false
        },
        {
          "line": 2055,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(link->sndbuf)",
          "new_text": null,
          "old_line_content": "    if (sdslen(link->sndbuf) == 0)",
          "new_line_content": "    clusterLink *link = (clusterLink*) privdata;",
          "content_same": false
        },
        {
          "line": 2056,
          "old_api": "aeDeleteFileEvent",
          "new_api": null,
          "old_text": "aeDeleteFileEvent(server.el, link->fd, AE_WRITABLE)",
          "new_text": null,
          "old_line_content": "        aeDeleteFileEvent(server.el, link->fd, AE_WRITABLE);",
          "new_line_content": "    ssize_t nwritten;",
          "content_same": false
        },
        {
          "line": 4104,
          "old_api": "nodeIsSlave",
          "new_api": null,
          "old_text": "nodeIsSlave(myself)",
          "new_text": null,
          "old_line_content": "        if (nodeIsSlave(myself)) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 4105,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"Please use SETSLOT only with masters.\")",
          "new_text": null,
          "old_line_content": "            addReplyError(c,\"Please use SETSLOT only with masters.\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 4111,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[3]->ptr,\"migrating\")",
          "new_text": null,
          "old_line_content": "        if (!strcasecmp(c->argv[3]->ptr,\"migrating\") && c->argc == 5) {",
          "new_line_content": "        /* SETSLOT 10 IMPORTING <node ID> */",
          "content_same": false
        },
        {
          "line": 4113,
          "old_api": "addReplyErrorFormat",
          "new_api": null,
          "old_text": "addReplyErrorFormat(c,\"I'm not the owner of hash slot %u\",slot)",
          "new_text": null,
          "old_line_content": "                addReplyErrorFormat(c,\"I'm not the owner of hash slot %u\",slot);",
          "new_line_content": "        /* SETSLOT 10 NODE <node ID> */",
          "content_same": false
        },
        {
          "line": 4116,
          "old_api": "clusterLookupNode",
          "new_api": null,
          "old_text": "clusterLookupNode(c->argv[4]->ptr)",
          "new_text": null,
          "old_line_content": "            if ((n = clusterLookupNode(c->argv[4]->ptr)) == NULL) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2072,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(link->rcvbuf)",
          "new_text": null,
          "old_line_content": "        rcvbuflen = sdslen(link->rcvbuf);",
          "new_line_content": "/* Read data. Try to read the first field of the header first to check the",
          "content_same": false
        },
        {
          "line": 4128,
          "old_api": "clusterLookupNode",
          "new_api": null,
          "old_text": "clusterLookupNode(c->argv[4]->ptr)",
          "new_text": null,
          "old_line_content": "            if ((n = clusterLookupNode(c->argv[4]->ptr)) == NULL) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2083,
          "old_api": "memcmp",
          "new_api": null,
          "old_text": "memcmp(hdr->sig,\"RCmb\",4)",
          "new_text": null,
          "old_line_content": "                if (memcmp(hdr->sig,\"RCmb\",4) != 0 ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2084,
          "old_api": "ntohl",
          "new_api": null,
          "old_text": "ntohl(hdr->totlen)",
          "new_text": null,
          "old_line_content": "                    ntohl(hdr->totlen) < CLUSTERMSG_MIN_LEN)",
          "new_line_content": "    while(1) { /* Read as long as there is data to read. */",
          "content_same": false
        },
        {
          "line": 2086,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n                        \"Bad message length or signature received \"\n                        \"from Cluster bus.\")",
          "new_text": null,
          "old_line_content": "                    serverLog(LL_WARNING,",
          "new_line_content": "        if (rcvbuflen < 8) {",
          "content_same": false
        },
        {
          "line": 4134,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[3]->ptr,\"stable\")",
          "new_text": null,
          "old_line_content": "        } else if (!strcasecmp(c->argv[3]->ptr,\"stable\") && c->argc == 4) {",
          "new_line_content": "            server.cluster->migrating_slots_to[slot] = n;",
          "content_same": false
        },
        {
          "line": 2089,
          "old_api": "handleLinkIOError",
          "new_api": null,
          "old_text": "handleLinkIOError(link)",
          "new_text": null,
          "old_line_content": "                    handleLinkIOError(link);",
          "new_line_content": "            readlen = 8 - rcvbuflen;",
          "content_same": false
        },
        {
          "line": 4138,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[3]->ptr,\"node\")",
          "new_text": null,
          "old_line_content": "        } else if (!strcasecmp(c->argv[3]->ptr,\"node\") && c->argc == 5) {",
          "new_line_content": "                    \"I'm already the owner of hash slot %u\",slot);",
          "content_same": false
        },
        {
          "line": 4140,
          "old_api": "clusterLookupNode",
          "new_api": null,
          "old_text": "clusterLookupNode(c->argv[4]->ptr)",
          "new_text": null,
          "old_line_content": "            clusterNode *n = clusterLookupNode(c->argv[4]->ptr);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2093,
          "old_api": "ntohl",
          "new_api": null,
          "old_text": "ntohl(hdr->totlen)",
          "new_text": null,
          "old_line_content": "            readlen = ntohl(hdr->totlen) - rcvbuflen;",
          "new_line_content": "            if (rcvbuflen == 8) {",
          "content_same": false
        },
        {
          "line": 4143,
          "old_api": "addReplyErrorFormat",
          "new_api": null,
          "old_text": "addReplyErrorFormat(c,\"Unknown node %s\",\n                    (char*)c->argv[4]->ptr)",
          "new_text": null,
          "old_line_content": "                addReplyErrorFormat(c,\"Unknown node %s\",",
          "new_line_content": "                    (char*)c->argv[3]->ptr);",
          "content_same": false
        },
        {
          "line": 2045,
          "old_api": "UNUSED",
          "new_api": null,
          "old_text": "UNUSED(mask)",
          "new_text": null,
          "old_line_content": "    UNUSED(mask);",
          "new_line_content": "   Instead if the node is a temporary node used to accept a query, we",
          "content_same": false
        },
        {
          "line": 4150,
          "old_api": "countKeysInSlot",
          "new_api": null,
          "old_text": "countKeysInSlot(slot)",
          "new_text": null,
          "old_line_content": "                if (countKeysInSlot(slot) != 0) {",
          "new_line_content": "            server.cluster->migrating_slots_to[slot] = NULL;",
          "content_same": false
        },
        {
          "line": 2103,
          "old_api": "strerror",
          "new_api": null,
          "old_text": "strerror(errno)",
          "new_text": null,
          "old_line_content": "                (nread == 0) ? \"connection closed\" : strerror(errno));",
          "new_line_content": "                    return;",
          "content_same": false
        },
        {
          "line": 2104,
          "old_api": "handleLinkIOError",
          "new_api": null,
          "old_text": "handleLinkIOError(link)",
          "new_text": null,
          "old_line_content": "            handleLinkIOError(link);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 2047,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(link->sndbuf)",
          "new_text": null,
          "old_line_content": "    nwritten = write(fd, link->sndbuf, sdslen(link->sndbuf));",
          "new_line_content": "void handleLinkIOError(clusterLink *link) {",
          "content_same": false
        },
        {
          "line": 2108,
          "old_api": "sdscatlen",
          "new_api": null,
          "old_text": "sdscatlen(link->rcvbuf,buf,nread)",
          "new_text": null,
          "old_line_content": "            link->rcvbuf = sdscatlen(link->rcvbuf,buf,nread);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 4160,
          "old_api": "countKeysInSlot",
          "new_api": null,
          "old_text": "countKeysInSlot(slot)",
          "new_text": null,
          "old_line_content": "            if (countKeysInSlot(slot) == 0 &&",
          "new_line_content": "            /* If this hash slot was served by 'myself' before to switch",
          "content_same": false
        },
        {
          "line": 2114,
          "old_api": "ntohl",
          "new_api": null,
          "old_text": "ntohl(hdr->totlen)",
          "new_text": null,
          "old_line_content": "        if (rcvbuflen >= 8 && rcvbuflen == ntohl(hdr->totlen)) {",
          "new_line_content": "            /* I/O error... */",
          "content_same": false
        },
        {
          "line": 4178,
          "old_api": "clusterBumpConfigEpochWithoutConsensus",
          "new_api": null,
          "old_text": "clusterBumpConfigEpochWithoutConsensus()",
          "new_text": null,
          "old_line_content": "                if (clusterBumpConfigEpochWithoutConsensus() == C_OK) {",
          "new_line_content": "             * itself also clears the importing status. */",
          "content_same": false
        },
        {
          "line": 2131,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(link->sndbuf)",
          "new_text": null,
          "old_line_content": "    if (sdslen(link->sndbuf) == 0 && msglen != 0)",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 2132,
          "old_api": "aeCreateFileEvent",
          "new_api": null,
          "old_text": "aeCreateFileEvent(server.el,link->fd,AE_WRITABLE,\n                    clusterWriteHandler,link)",
          "new_text": null,
          "old_line_content": "        aeCreateFileEvent(server.el,link->fd,AE_WRITABLE,",
          "new_line_content": "                return; /* Link no longer valid. */",
          "content_same": false
        },
        {
          "line": 4179,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n                        \"configEpoch updated after importing slot %d\", slot)",
          "new_text": null,
          "old_line_content": "                    serverLog(LL_WARNING,",
          "new_line_content": "            if (n == myself &&",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": "sdscatlen",
          "new_api": null,
          "old_text": "sdscatlen(link->sndbuf, msg, msglen)",
          "new_text": null,
          "old_line_content": "    link->sndbuf = sdscatlen(link->sndbuf, msg, msglen);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4184,
          "old_api": "clusterDelSlot",
          "new_api": null,
          "old_text": "clusterDelSlot(slot)",
          "new_text": null,
          "old_line_content": "            clusterDelSlot(slot);",
          "new_line_content": "                 * by the cluster.",
          "content_same": false
        },
        {
          "line": 4185,
          "old_api": "clusterAddSlot",
          "new_api": null,
          "old_text": "clusterAddSlot(n,slot)",
          "new_text": null,
          "old_line_content": "            clusterAddSlot(n,slot);",
          "new_line_content": "                 *",
          "content_same": false
        },
        {
          "line": 2139,
          "old_api": "ntohs",
          "new_api": null,
          "old_text": "ntohs(hdr->type)",
          "new_text": null,
          "old_line_content": "    uint16_t type = ntohs(hdr->type);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 4187,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\n                \"Invalid CLUSTER SETSLOT action or number of arguments\")",
          "new_text": null,
          "old_line_content": "            addReplyError(c,",
          "new_line_content": "                 * node getting the same configEpoch, for example because a",
          "content_same": false
        },
        {
          "line": 4193,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[1]->ptr,\"bumpepoch\")",
          "new_text": null,
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"bumpepoch\") && c->argc == 2) {",
          "new_line_content": "                        \"configEpoch updated after importing slot %d\", slot);",
          "content_same": false
        },
        {
          "line": 4195,
          "old_api": "clusterBumpConfigEpochWithoutConsensus",
          "new_api": null,
          "old_text": "clusterBumpConfigEpochWithoutConsensus()",
          "new_text": null,
          "old_line_content": "        int retval = clusterBumpConfigEpochWithoutConsensus();",
          "new_line_content": "                server.cluster->importing_slots_from[slot] = NULL;",
          "content_same": false
        },
        {
          "line": 4196,
          "old_api": "sdsempty",
          "new_api": null,
          "old_text": "sdsempty()",
          "new_text": null,
          "old_line_content": "        sds reply = sdscatprintf(sdsempty(),\"+%s %llu\\r\\n\",",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 4199,
          "old_api": "addReplySds",
          "new_api": null,
          "old_text": "addReplySds(c,reply)",
          "new_text": null,
          "old_line_content": "        addReplySds(c,reply);",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 2154,
          "old_api": "dictGetSafeIterator",
          "new_api": null,
          "old_text": "dictGetSafeIterator(server.cluster->nodes)",
          "new_text": null,
          "old_line_content": "    di = dictGetSafeIterator(server.cluster->nodes);",
          "new_line_content": "        server.cluster->stats_bus_messages_sent[type]++;",
          "content_same": false
        },
        {
          "line": 2155,
          "old_api": "dictNext",
          "new_api": null,
          "old_text": "dictNext(di)",
          "new_text": null,
          "old_line_content": "    while((de = dictNext(di)) != NULL) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2156,
          "old_api": "dictGetVal",
          "new_api": null,
          "old_text": "dictGetVal(de)",
          "new_text": null,
          "old_line_content": "        clusterNode *node = dictGetVal(de);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2161,
          "old_api": "clusterSendMessage",
          "new_api": null,
          "old_text": "clusterSendMessage(node->link,buf,len)",
          "new_text": null,
          "old_line_content": "        clusterSendMessage(node->link,buf,len);",
          "new_line_content": " * some node->link to be invalidated, so it is safe to call this function",
          "content_same": false
        },
        {
          "line": 2163,
          "old_api": "dictReleaseIterator",
          "new_api": null,
          "old_text": "dictReleaseIterator(di)",
          "new_text": null,
          "old_line_content": "    dictReleaseIterator(di);",
          "new_line_content": "void clusterBroadcastMessage(void *buf, size_t len) {",
          "content_same": false
        },
        {
          "line": 4214,
          "old_api": "nodeTimedOut",
          "new_api": null,
          "old_text": "nodeTimedOut(n)",
          "new_text": null,
          "old_line_content": "            } else if (nodeTimedOut(n)) {",
          "new_line_content": "        /* CLUSTER INFO */",
          "content_same": false
        },
        {
          "line": 4221,
          "old_api": "nodeIsSlave",
          "new_api": null,
          "old_text": "nodeIsSlave(myself)",
          "new_text": null,
          "old_line_content": "        myepoch = (nodeIsSlave(myself) && myself->slaveof) ?",
          "new_line_content": "            clusterNode *n = server.cluster->slots[j];",
          "content_same": false
        },
        {
          "line": 4224,
          "old_api": "sdsempty",
          "new_api": null,
          "old_text": "sdsempty()",
          "new_text": null,
          "old_line_content": "        sds info = sdscatprintf(sdsempty(),",
          "new_line_content": "            slots_assigned++;",
          "content_same": false
        },
        {
          "line": 2177,
          "old_api": "nodeIsSlave",
          "new_api": null,
          "old_text": "nodeIsSlave(myself)",
          "new_text": null,
          "old_line_content": "    master = (nodeIsSlave(myself) && myself->slaveof) ?",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2180,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(hdr,0,sizeof(*hdr))",
          "new_text": null,
          "old_line_content": "    memset(hdr,0,sizeof(*hdr));",
          "new_line_content": " * sizeof(clusterMsg) in bytes. */",
          "content_same": false
        },
        {
          "line": 2181,
          "old_api": "htons",
          "new_api": null,
          "old_text": "htons(CLUSTER_PROTO_VER)",
          "new_text": null,
          "old_line_content": "    hdr->ver = htons(CLUSTER_PROTO_VER);",
          "new_line_content": "void clusterBuildMessageHdr(clusterMsg *hdr, int type) {",
          "content_same": false
        },
        {
          "line": 2186,
          "old_api": "htons",
          "new_api": null,
          "old_text": "htons(type)",
          "new_text": null,
          "old_line_content": "    hdr->type = htons(type);",
          "new_line_content": "    /* If this node is a master, we send its slots bitmap and configEpoch.",
          "content_same": false
        },
        {
          "line": 2187,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(hdr->sender,myself->name,CLUSTER_NAMELEN)",
          "new_text": null,
          "old_line_content": "    memcpy(hdr->sender,myself->name,CLUSTER_NAMELEN);",
          "new_line_content": "     * If this node is a slave we send the master's information instead (the",
          "content_same": false
        },
        {
          "line": 4239,
          "old_api": "dictSize",
          "new_api": null,
          "old_text": "dictSize(server.cluster->nodes)",
          "new_text": null,
          "old_line_content": "            dictSize(server.cluster->nodes),",
          "new_line_content": "            \"cluster_slots_assigned:%d\\r\\n\"",
          "content_same": false
        },
        {
          "line": 2192,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(hdr->myip,0,NET_IP_STR_LEN)",
          "new_text": null,
          "old_line_content": "    memset(hdr->myip,0,NET_IP_STR_LEN);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2206,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(hdr->slaveof,0,CLUSTER_NAMELEN)",
          "new_text": null,
          "old_line_content": "    memset(hdr->slaveof,0,CLUSTER_NAMELEN);",
          "new_line_content": "    if (server.cluster_announce_ip) {",
          "content_same": false
        },
        {
          "line": 4254,
          "old_api": "clusterGetMessageTypeString",
          "new_api": null,
          "old_text": "clusterGetMessageTypeString(i)",
          "new_text": null,
          "old_line_content": "                clusterGetMessageTypeString(i),",
          "new_line_content": "            (unsigned long long) server.cluster->currentEpoch,",
          "content_same": false
        },
        {
          "line": 2208,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(hdr->slaveof,myself->slaveof->name, CLUSTER_NAMELEN)",
          "new_text": null,
          "old_line_content": "        memcpy(hdr->slaveof,myself->slaveof->name, CLUSTER_NAMELEN);",
          "new_line_content": "        hdr->myip[NET_IP_STR_LEN-1] = '\\0';",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": "htons",
          "new_api": null,
          "old_text": "htons(announced_port)",
          "new_text": null,
          "old_line_content": "    hdr->port = htons(announced_port);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2210,
          "old_api": "htons",
          "new_api": null,
          "old_text": "htons(announced_cport)",
          "new_text": null,
          "old_line_content": "    hdr->cport = htons(announced_cport);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2211,
          "old_api": "htons",
          "new_api": null,
          "old_text": "htons(myself->flags)",
          "new_text": null,
          "old_line_content": "    hdr->flags = htons(myself->flags);",
          "new_line_content": "    /* Handle cluster-announce-port as well. */",
          "content_same": false
        },
        {
          "line": 4257,
          "old_api": "sdscatprintf",
          "new_api": null,
          "old_text": "sdscatprintf(info,\n            \"cluster_stats_messages_sent:%lld\\r\\n\", tot_msg_sent)",
          "new_text": null,
          "old_line_content": "        info = sdscatprintf(info,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2215,
          "old_api": "htonu64",
          "new_api": null,
          "old_text": "htonu64(server.cluster->currentEpoch)",
          "new_text": null,
          "old_line_content": "    hdr->currentEpoch = htonu64(server.cluster->currentEpoch);",
          "new_line_content": "                          server.cluster_announce_bus_port :",
          "content_same": false
        },
        {
          "line": 2216,
          "old_api": "htonu64",
          "new_api": null,
          "old_text": "htonu64(master->configEpoch)",
          "new_text": null,
          "old_line_content": "    hdr->configEpoch = htonu64(master->configEpoch);",
          "new_line_content": "                          (server.port + CLUSTER_PORT_INCR);",
          "content_same": false
        },
        {
          "line": 4263,
          "old_api": "sdscatprintf",
          "new_api": null,
          "old_text": "sdscatprintf(info,\n                \"cluster_stats_messages_%s_received:%lld\\r\\n\",\n                clusterGetMessageTypeString(i),\n                server.cluster->stats_bus_messages_received[i])",
          "new_text": null,
          "old_line_content": "            info = sdscatprintf(info,",
          "new_line_content": "            if (server.cluster->stats_bus_messages_sent[i] == 0) continue;",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": "replicationGetSlaveOffset",
          "new_api": null,
          "old_text": "replicationGetSlaveOffset()",
          "new_text": null,
          "old_line_content": "        offset = replicationGetSlaveOffset();",
          "new_line_content": "    if (myself->slaveof != NULL)",
          "content_same": false
        },
        {
          "line": 4268,
          "old_api": "sdscatprintf",
          "new_api": null,
          "old_text": "sdscatprintf(info,\n            \"cluster_stats_messages_received:%lld\\r\\n\", tot_msg_received)",
          "new_text": null,
          "old_line_content": "        info = sdscatprintf(info,",
          "new_line_content": "                server.cluster->stats_bus_messages_sent[i]);",
          "content_same": false
        },
        {
          "line": 4272,
          "old_api": "sdsempty",
          "new_api": null,
          "old_text": "sdsempty()",
          "new_text": null,
          "old_line_content": "        addReplySds(c,sdscatprintf(sdsempty(),\"$%lu\\r\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4273,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(info)",
          "new_text": null,
          "old_line_content": "            (unsigned long)sdslen(info)));",
          "new_line_content": "        for (int i = 0; i < CLUSTERMSG_TYPE_COUNT; i++) {",
          "content_same": false
        },
        {
          "line": 2226,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(myself)",
          "new_text": null,
          "old_line_content": "    if (nodeIsMaster(myself) && server.cluster->mf_end)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4274,
          "old_api": "addReplySds",
          "new_api": null,
          "old_text": "addReplySds(c,info)",
          "new_text": null,
          "old_line_content": "        addReplySds(c,info);",
          "new_line_content": "            if (server.cluster->stats_bus_messages_received[i] == 0) continue;",
          "content_same": false
        },
        {
          "line": 4275,
          "old_api": "addReply",
          "new_api": null,
          "old_text": "addReply(c,shared.crlf)",
          "new_text": null,
          "old_line_content": "        addReply(c,shared.crlf);",
          "new_line_content": "            tot_msg_received += server.cluster->stats_bus_messages_received[i];",
          "content_same": false
        },
        {
          "line": 4277,
          "old_api": "clusterSaveConfig",
          "new_api": null,
          "old_text": "clusterSaveConfig(1)",
          "new_text": null,
          "old_line_content": "        int retval = clusterSaveConfig(1);",
          "new_line_content": "                \"cluster_stats_messages_%s_received:%lld\\r\\n\",",
          "content_same": false
        },
        {
          "line": 4280,
          "old_api": "addReply",
          "new_api": null,
          "old_text": "addReply(c,shared.ok)",
          "new_text": null,
          "old_line_content": "            addReply(c,shared.ok);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 4282,
          "old_api": "addReplyErrorFormat",
          "new_api": null,
          "old_text": "addReplyErrorFormat(c,\"error saving the cluster node config: %s\",\n                strerror(errno))",
          "new_text": null,
          "old_line_content": "            addReplyErrorFormat(c,\"error saving the cluster node config: %s\",",
          "new_line_content": "            \"cluster_stats_messages_received:%lld\\r\\n\", tot_msg_received);",
          "content_same": false
        },
        {
          "line": 4283,
          "old_api": "strerror",
          "new_api": null,
          "old_text": "strerror(errno)",
          "new_text": null,
          "old_line_content": "                strerror(errno));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4284,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[1]->ptr,\"keyslot\")",
          "new_text": null,
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"keyslot\") && c->argc == 3) {",
          "new_line_content": "        /* Produce the reply protocol. */",
          "content_same": false
        },
        {
          "line": 2238,
          "old_api": "htonl",
          "new_api": null,
          "old_text": "htonl(totlen)",
          "new_text": null,
          "old_line_content": "    hdr->totlen = htonl(totlen);",
          "new_line_content": "    /* Set the message flags. */",
          "content_same": false
        },
        {
          "line": 4299,
          "old_api": "countKeysInSlot",
          "new_api": null,
          "old_text": "countKeysInSlot(slot)",
          "new_text": null,
          "old_line_content": "        addReplyLongLong(c,countKeysInSlot(slot));",
          "new_line_content": "        sds key = c->argv[2]->ptr;",
          "content_same": false
        },
        {
          "line": 4300,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[1]->ptr,\"getkeysinslot\")",
          "new_text": null,
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"getkeysinslot\") && c->argc == 4) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2254,
          "old_api": "dictSize",
          "new_api": null,
          "old_text": "dictSize(server.cluster->nodes)",
          "new_text": null,
          "old_line_content": "    int freshnodes = dictSize(server.cluster->nodes)-2;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4308,
          "old_api": "getLongLongFromObjectOrReply",
          "new_api": null,
          "old_text": "getLongLongFromObjectOrReply(c,c->argv[3],&maxkeys,NULL)",
          "new_text": null,
          "old_line_content": "        if (getLongLongFromObjectOrReply(c,c->argv[3],&maxkeys,NULL)",
          "new_line_content": "        if (slot < 0 || slot >= CLUSTER_SLOTS) {",
          "content_same": false
        },
        {
          "line": 4316,
          "old_api": "zmalloc",
          "new_api": null,
          "old_text": "zmalloc(sizeof(robj*)*maxkeys)",
          "new_text": null,
          "old_line_content": "        keys = zmalloc(sizeof(robj*)*maxkeys);",
          "new_line_content": "        unsigned int numkeys, j;",
          "content_same": false
        },
        {
          "line": 4317,
          "old_api": "getKeysInSlot",
          "new_api": null,
          "old_text": "getKeysInSlot(slot, keys, maxkeys)",
          "new_text": null,
          "old_line_content": "        numkeys = getKeysInSlot(slot, keys, maxkeys);",
          "new_line_content": "        robj **keys;",
          "content_same": false
        },
        {
          "line": 4318,
          "old_api": "addReplyMultiBulkLen",
          "new_api": null,
          "old_text": "addReplyMultiBulkLen(c,numkeys)",
          "new_text": null,
          "old_line_content": "        addReplyMultiBulkLen(c,numkeys);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4320,
          "old_api": "addReplyBulk",
          "new_api": null,
          "old_text": "addReplyBulk(c,keys[j])",
          "new_text": null,
          "old_line_content": "            addReplyBulk(c,keys[j]);",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 4323,
          "old_api": "zfree",
          "new_api": null,
          "old_text": "zfree(keys)",
          "new_text": null,
          "old_line_content": "        zfree(keys);",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 4324,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[1]->ptr,\"forget\")",
          "new_text": null,
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"forget\") && c->argc == 3) {",
          "new_line_content": "        if (slot < 0 || slot >= CLUSTER_SLOTS || maxkeys < 0) {",
          "content_same": false
        },
        {
          "line": 4326,
          "old_api": "clusterLookupNode",
          "new_api": null,
          "old_text": "clusterLookupNode(c->argv[2]->ptr)",
          "new_text": null,
          "old_line_content": "        clusterNode *n = clusterLookupNode(c->argv[2]->ptr);",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 2282,
          "old_api": "dictSize",
          "new_api": null,
          "old_text": "dictSize(server.cluster->nodes)",
          "new_text": null,
          "old_line_content": "    wanted = floor(dictSize(server.cluster->nodes)/10);",
          "new_line_content": "     * PROB = probability of being featured in a single gossip entry,",
          "content_same": false
        },
        {
          "line": 4332,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"I tried hard but I can't forget myself...\")",
          "new_text": null,
          "old_line_content": "            addReplyError(c,\"I tried hard but I can't forget myself...\");",
          "new_line_content": "        for (j = 0; j < numkeys; j++) {",
          "content_same": false
        },
        {
          "line": 4335,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"Can't forget my master!\")",
          "new_text": null,
          "old_line_content": "            addReplyError(c,\"Can't forget my master!\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 4338,
          "old_api": "clusterBlacklistAddNode",
          "new_api": null,
          "old_text": "clusterBlacklistAddNode(n)",
          "new_text": null,
          "old_line_content": "        clusterBlacklistAddNode(n);",
          "new_line_content": "        /* CLUSTER FORGET <NODE ID> */",
          "content_same": false
        },
        {
          "line": 4340,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|\n                             CLUSTER_TODO_SAVE_CONFIG)",
          "new_text": null,
          "old_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2294,
          "old_api": "zcalloc",
          "new_api": null,
          "old_text": "zcalloc(totlen)",
          "new_text": null,
          "old_line_content": "    buf = zcalloc(totlen);",
          "new_line_content": "     * 10% of the total nodes we have. */",
          "content_same": false
        },
        {
          "line": 4343,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[1]->ptr,\"replicate\")",
          "new_text": null,
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"replicate\") && c->argc == 3) {",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "        link->node->ping_sent = mstime();",
          "new_line_content": "    /* Compute the maxium totlen to allocate our buffer. We'll fix the totlen",
          "content_same": false
        },
        {
          "line": 2300,
          "old_api": "clusterBuildMessageHdr",
          "new_api": null,
          "old_text": "clusterBuildMessageHdr(hdr,type)",
          "new_text": null,
          "old_line_content": "    clusterBuildMessageHdr(hdr,type);",
          "new_line_content": "     * later according to the number of gossip sections we really were able",
          "content_same": false
        },
        {
          "line": 4349,
          "old_api": "addReplyErrorFormat",
          "new_api": null,
          "old_text": "addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr)",
          "new_text": null,
          "old_line_content": "            addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr);",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 2305,
          "old_api": "dictGetRandomKey",
          "new_api": null,
          "old_text": "dictGetRandomKey(server.cluster->nodes)",
          "new_text": null,
          "old_line_content": "        dictEntry *de = dictGetRandomKey(server.cluster->nodes);",
          "new_line_content": "     * sizeof(clusterMsg) or more. */",
          "content_same": false
        },
        {
          "line": 2306,
          "old_api": "dictGetVal",
          "new_api": null,
          "old_text": "dictGetVal(de)",
          "new_text": null,
          "old_line_content": "        clusterNode *this = dictGetVal(de);",
          "new_line_content": "    if (totlen < (int)sizeof(clusterMsg)) totlen = sizeof(clusterMsg);",
          "content_same": false
        },
        {
          "line": 4360,
          "old_api": "nodeIsSlave",
          "new_api": null,
          "old_text": "nodeIsSlave(n)",
          "new_text": null,
          "old_line_content": "        if (nodeIsSlave(n)) {",
          "new_line_content": "        /* Lookup the specified node in our table. */",
          "content_same": false
        },
        {
          "line": 4361,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"I can only replicate a master, not a slave.\")",
          "new_text": null,
          "old_line_content": "            addReplyError(c,\"I can only replicate a master, not a slave.\");",
          "new_line_content": "        if (!n) {",
          "content_same": false
        },
        {
          "line": 4369,
          "old_api": "dictSize",
          "new_api": null,
          "old_text": "dictSize(server.db[0].dict)",
          "new_text": null,
          "old_line_content": "            (myself->numslots != 0 || dictSize(server.db[0].dict) != 0)) {",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 4370,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\n                \"To set a master the node must be empty and \"\n                \"without assigned slots.\")",
          "new_text": null,
          "old_line_content": "            addReplyError(c,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 4377,
          "old_api": "clusterSetMaster",
          "new_api": null,
          "old_text": "clusterSetMaster(n)",
          "new_text": null,
          "old_line_content": "        clusterSetMaster(n);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4378,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG)",
          "new_text": null,
          "old_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);",
          "new_line_content": "        /* If the instance is currently a master, it should have no assigned",
          "content_same": false
        },
        {
          "line": 4379,
          "old_api": "addReply",
          "new_api": null,
          "old_text": "addReply(c,shared.ok)",
          "new_text": null,
          "old_line_content": "        addReply(c,shared.ok);",
          "new_line_content": "         * slots nor keys to accept to replicate some other node.",
          "content_same": false
        },
        {
          "line": 4380,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[1]->ptr,\"slaves\")",
          "new_text": null,
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"slaves\") && c->argc == 3) {",
          "new_line_content": "         * Slaves can switch to another master without issues. */",
          "content_same": false
        },
        {
          "line": 2333,
          "old_api": "memcmp",
          "new_api": null,
          "old_text": "memcmp(hdr->data.ping.gossip[j].nodename,this->name,\n                    CLUSTER_NAMELEN)",
          "new_text": null,
          "old_line_content": "            if (memcmp(hdr->data.ping.gossip[j].nodename,this->name,",
          "new_line_content": "         * 1) Nodes in HANDSHAKE state.",
          "content_same": false
        },
        {
          "line": 4387,
          "old_api": "addReplyErrorFormat",
          "new_api": null,
          "old_text": "addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr)",
          "new_text": null,
          "old_line_content": "            addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[2]->ptr);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2341,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(gossip->nodename,this->name,CLUSTER_NAMELEN)",
          "new_text": null,
          "old_line_content": "        memcpy(gossip->nodename,this->name,CLUSTER_NAMELEN);",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 2342,
          "old_api": "htonl",
          "new_api": null,
          "old_text": "htonl(this->ping_sent)",
          "new_text": null,
          "old_line_content": "        gossip->ping_sent = htonl(this->ping_sent);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2343,
          "old_api": "htonl",
          "new_api": null,
          "old_text": "htonl(this->pong_received)",
          "new_text": null,
          "old_line_content": "        gossip->pong_received = htonl(this->pong_received);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2344,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(gossip->ip,this->ip,sizeof(this->ip))",
          "new_text": null,
          "old_line_content": "        memcpy(gossip->ip,this->ip,sizeof(this->ip));",
          "new_line_content": "        /* Check if we already added this node */",
          "content_same": false
        },
        {
          "line": 2345,
          "old_api": "htons",
          "new_api": null,
          "old_text": "htons(this->port)",
          "new_text": null,
          "old_line_content": "        gossip->port = htons(this->port);",
          "new_line_content": "        for (j = 0; j < gossipcount; j++) {",
          "content_same": false
        },
        {
          "line": 2347,
          "old_api": "htons",
          "new_api": null,
          "old_text": "htons(this->flags)",
          "new_text": null,
          "old_line_content": "        gossip->flags = htons(this->flags);",
          "new_line_content": "                    CLUSTER_NAMELEN) == 0) break;",
          "content_same": false
        },
        {
          "line": 4396,
          "old_api": "addReplyMultiBulkLen",
          "new_api": null,
          "old_text": "addReplyMultiBulkLen(c,n->numslaves)",
          "new_text": null,
          "old_line_content": "        addReplyMultiBulkLen(c,n->numslaves);",
          "new_line_content": "        int j;",
          "content_same": false
        },
        {
          "line": 4398,
          "old_api": "clusterGenNodeDescription",
          "new_api": null,
          "old_text": "clusterGenNodeDescription(n->slaves[j])",
          "new_text": null,
          "old_line_content": "            sds ni = clusterGenNodeDescription(n->slaves[j]);",
          "new_line_content": "        /* Lookup the specified node in our table. */",
          "content_same": false
        },
        {
          "line": 4399,
          "old_api": "addReplyBulkCString",
          "new_api": null,
          "old_text": "addReplyBulkCString(c,ni)",
          "new_text": null,
          "old_line_content": "            addReplyBulkCString(c,ni);",
          "new_line_content": "        if (!n) {",
          "content_same": false
        },
        {
          "line": 4402,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[1]->ptr,\"count-failure-reports\")",
          "new_text": null,
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"count-failure-reports\") &&",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 4406,
          "old_api": "clusterLookupNode",
          "new_api": null,
          "old_text": "clusterLookupNode(c->argv[2]->ptr)",
          "new_text": null,
          "old_line_content": "        clusterNode *n = clusterLookupNode(c->argv[2]->ptr);",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 4414,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[1]->ptr,\"failover\")",
          "new_text": null,
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"failover\") &&",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 4421,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[2]->ptr,\"force\")",
          "new_text": null,
          "old_line_content": "            if (!strcasecmp(c->argv[2]->ptr,\"force\")) {",
          "new_line_content": "        if (!n) {",
          "content_same": false
        },
        {
          "line": 4423,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[2]->ptr,\"takeover\")",
          "new_text": null,
          "old_line_content": "            } else if (!strcasecmp(c->argv[2]->ptr,\"takeover\")) {",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": "dictGetSafeIterator",
          "new_api": null,
          "old_text": "dictGetSafeIterator(server.cluster->nodes)",
          "new_text": null,
          "old_line_content": "    di = dictGetSafeIterator(server.cluster->nodes);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 2383,
          "old_api": "dictNext",
          "new_api": null,
          "old_text": "dictNext(di)",
          "new_text": null,
          "old_line_content": "    while((de = dictNext(di)) != NULL) {",
          "new_line_content": " * The 'target' argument specifies the receiving instances using the",
          "content_same": false
        },
        {
          "line": 2384,
          "old_api": "dictGetVal",
          "new_api": null,
          "old_text": "dictGetVal(de)",
          "new_text": null,
          "old_line_content": "        clusterNode *node = dictGetVal(de);",
          "new_line_content": " * defines below:",
          "content_same": false
        },
        {
          "line": 4433,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(myself)",
          "new_text": null,
          "old_line_content": "        if (nodeIsMaster(myself)) {",
          "new_line_content": "        if (c->argc == 3) {",
          "content_same": false
        },
        {
          "line": 2387,
          "old_api": "nodeInHandshake",
          "new_api": null,
          "old_text": "nodeInHandshake(node)",
          "new_text": null,
          "old_line_content": "        if (node == myself || nodeInHandshake(node)) continue;",
          "new_line_content": " * CLUSTER_BROADCAST_LOCAL_SLAVES -> All slaves in my master-slaves ring.",
          "content_same": false
        },
        {
          "line": 4437,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"I'm a slave but my master is unknown to me\")",
          "new_text": null,
          "old_line_content": "            addReplyError(c,\"I'm a slave but my master is unknown to me\");",
          "new_line_content": "                takeover = 1;",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": "nodeIsSlave",
          "new_api": null,
          "old_text": "nodeIsSlave(node)",
          "new_text": null,
          "old_line_content": "                nodeIsSlave(node) && node->slaveof &&",
          "new_line_content": "#define CLUSTER_BROADCAST_LOCAL_SLAVES 1",
          "content_same": false
        },
        {
          "line": 2394,
          "old_api": "clusterSendPing",
          "new_api": null,
          "old_text": "clusterSendPing(node->link,CLUSTERMSG_TYPE_PONG)",
          "new_text": null,
          "old_line_content": "        clusterSendPing(node->link,CLUSTERMSG_TYPE_PONG);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4443,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"Master is down or failed, \"\n                            \"please use CLUSTER FAILOVER FORCE\")",
          "new_text": null,
          "old_line_content": "            addReplyError(c,\"Master is down or failed, \"",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 4448,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "        server.cluster->mf_end = mstime() + CLUSTER_MF_TIMEOUT;",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 4455,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\"Taking over the master (user request).\")",
          "new_text": null,
          "old_line_content": "            serverLog(LL_WARNING,\"Taking over the master (user request).\");",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2408,
          "old_api": "getDecodedObject",
          "new_api": null,
          "old_text": "getDecodedObject(channel)",
          "new_text": null,
          "old_line_content": "    channel = getDecodedObject(channel);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4457,
          "old_api": "clusterFailoverReplaceYourMaster",
          "new_api": null,
          "old_text": "clusterFailoverReplaceYourMaster()",
          "new_text": null,
          "old_line_content": "            clusterFailoverReplaceYourMaster();",
          "new_line_content": "                            \"please use CLUSTER FAILOVER FORCE\");",
          "content_same": false
        },
        {
          "line": 2410,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(channel->ptr)",
          "new_text": null,
          "old_line_content": "    channel_len = sdslen(channel->ptr);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(message->ptr)",
          "new_text": null,
          "old_line_content": "    message_len = sdslen(message->ptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2413,
          "old_api": "clusterBuildMessageHdr",
          "new_api": null,
          "old_text": "clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_PUBLISH)",
          "new_text": null,
          "old_line_content": "    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_PUBLISH);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 4462,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\"Forced failover user request accepted.\")",
          "new_text": null,
          "old_line_content": "            serverLog(LL_WARNING,\"Forced failover user request accepted.\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2417,
          "old_api": "htonl",
          "new_api": null,
          "old_text": "htonl(channel_len)",
          "new_text": null,
          "old_line_content": "    hdr->data.publish.msg.channel_len = htonl(channel_len);",
          "new_line_content": "    clusterMsg *hdr = (clusterMsg*) buf;",
          "content_same": false
        },
        {
          "line": 2418,
          "old_api": "htonl",
          "new_api": null,
          "old_text": "htonl(message_len)",
          "new_text": null,
          "old_line_content": "    hdr->data.publish.msg.message_len = htonl(message_len);",
          "new_line_content": "    uint32_t totlen;",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": "htonl",
          "new_api": null,
          "old_text": "htonl(totlen)",
          "new_text": null,
          "old_line_content": "    hdr->totlen = htonl(totlen);",
          "new_line_content": "    uint32_t channel_len, message_len;",
          "content_same": false
        },
        {
          "line": 4465,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\"Manual failover user request accepted.\")",
          "new_text": null,
          "old_line_content": "            serverLog(LL_WARNING,\"Manual failover user request accepted.\");",
          "new_line_content": "             * generates a new configuration epoch for this node without",
          "content_same": false
        },
        {
          "line": 4466,
          "old_api": "clusterSendMFStart",
          "new_api": null,
          "old_text": "clusterSendMFStart(myself->slaveof)",
          "new_text": null,
          "old_line_content": "            clusterSendMFStart(myself->slaveof);",
          "new_line_content": "             * consensus, claims the master's slots, and broadcast the new",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": "zmalloc",
          "new_api": null,
          "old_text": "zmalloc(totlen)",
          "new_text": null,
          "old_line_content": "        payload = zmalloc(totlen);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(channel->ptr)",
          "new_text": null,
          "old_line_content": "    memcpy(hdr->data.publish.msg.bulk_data,channel->ptr,sdslen(channel->ptr));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4480,
          "old_api": "getLongLongFromObjectOrReply",
          "new_api": null,
          "old_text": "getLongLongFromObjectOrReply(c,c->argv[2],&epoch,NULL)",
          "new_text": null,
          "old_line_content": "        if (getLongLongFromObjectOrReply(c,c->argv[2],&epoch,NULL) != C_OK)",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2434,
          "old_api": "clusterSendMessage",
          "new_api": null,
          "old_text": "clusterSendMessage(link,payload,totlen)",
          "new_text": null,
          "old_line_content": "        clusterSendMessage(link,payload,totlen);",
          "new_line_content": "    /* Try to use the local buffer if possible */",
          "content_same": false
        },
        {
          "line": 2436,
          "old_api": "clusterBroadcastMessage",
          "new_api": null,
          "old_text": "clusterBroadcastMessage(payload,totlen)",
          "new_text": null,
          "old_line_content": "        clusterBroadcastMessage(payload,totlen);",
          "new_line_content": "        payload = buf;",
          "content_same": false
        },
        {
          "line": 4484,
          "old_api": "addReplyErrorFormat",
          "new_api": null,
          "old_text": "addReplyErrorFormat(c,\"Invalid config epoch specified: %lld\",epoch)",
          "new_text": null,
          "old_line_content": "            addReplyErrorFormat(c,\"Invalid config epoch specified: %lld\",epoch);",
          "new_line_content": "        /* CLUSTER SET-CONFIG-EPOCH <epoch>",
          "content_same": false
        },
        {
          "line": 4485,
          "old_api": "dictSize",
          "new_api": null,
          "old_text": "dictSize(server.cluster->nodes)",
          "new_text": null,
          "old_line_content": "        } else if (dictSize(server.cluster->nodes) > 1) {",
          "new_line_content": "         *",
          "content_same": false
        },
        {
          "line": 4486,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"The user can assign a config epoch only when the \"\n                            \"node does not know any other node.\")",
          "new_text": null,
          "old_line_content": "            addReplyError(c,\"The user can assign a config epoch only when the \"",
          "new_line_content": "         * The user is allowed to set the config epoch only when a node is",
          "content_same": false
        },
        {
          "line": 2440,
          "old_api": "zfree",
          "new_api": null,
          "old_text": "zfree(payload)",
          "new_text": null,
          "old_line_content": "    if (payload != buf) zfree(payload);",
          "new_line_content": "        hdr = (clusterMsg*) payload;",
          "content_same": false
        },
        {
          "line": 4489,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"Node config epoch is already non-zero\")",
          "new_text": null,
          "old_line_content": "            addReplyError(c,\"Node config epoch is already non-zero\");",
          "new_line_content": "         * every node has a different node ID, without to rely on the conflicts",
          "content_same": false
        },
        {
          "line": 4492,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n                \"configEpoch set to %llu via CLUSTER SET-CONFIG-EPOCH\",\n                (unsigned long long) myself->configEpoch)",
          "new_text": null,
          "old_line_content": "            serverLog(LL_WARNING,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4501,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|\n                                 CLUSTER_TODO_SAVE_CONFIG)",
          "new_text": null,
          "old_line_content": "            clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|",
          "new_line_content": "        } else if (myself->configEpoch != 0) {",
          "content_same": false
        },
        {
          "line": 2454,
          "old_api": "ntohl",
          "new_api": null,
          "old_text": "ntohl(hdr->totlen)",
          "new_text": null,
          "old_line_content": "    clusterBroadcastMessage(buf,ntohl(hdr->totlen));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 4503,
          "old_api": "addReply",
          "new_api": null,
          "old_text": "addReply(c,shared.ok)",
          "new_text": null,
          "old_line_content": "            addReply(c,shared.ok);",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 4513,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[2]->ptr,\"hard\")",
          "new_text": null,
          "old_line_content": "            if (!strcasecmp(c->argv[2]->ptr,\"hard\")) {",
          "new_line_content": "             * will assign an unique config to this node. */",
          "content_same": false
        },
        {
          "line": 4515,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[2]->ptr,\"soft\")",
          "new_text": null,
          "old_line_content": "            } else if (!strcasecmp(c->argv[2]->ptr,\"soft\")) {",
          "new_line_content": "                                 CLUSTER_TODO_SAVE_CONFIG);",
          "content_same": false
        },
        {
          "line": 2468,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(hdr->data.update.nodecfg.slots,node->slots,sizeof(node->slots))",
          "new_text": null,
          "old_line_content": "    memcpy(hdr->data.update.nodecfg.slots,node->slots,sizeof(node->slots));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2469,
          "old_api": "ntohl",
          "new_api": null,
          "old_text": "ntohl(hdr->totlen)",
          "new_text": null,
          "old_line_content": "    clusterSendMessage(link,buf,ntohl(hdr->totlen));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4525,
          "old_api": "dictSize",
          "new_api": null,
          "old_text": "dictSize(c->db->dict)",
          "new_text": null,
          "old_line_content": "        if (nodeIsMaster(myself) && dictSize(c->db->dict) != 0) {",
          "new_line_content": "        if (c->argc == 3) {",
          "content_same": false
        },
        {
          "line": 4530,
          "old_api": "clusterReset",
          "new_api": null,
          "old_text": "clusterReset(hard)",
          "new_text": null,
          "old_line_content": "        clusterReset(hard);",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 4533,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"Wrong CLUSTER subcommand or number of arguments\")",
          "new_text": null,
          "old_line_content": "        addReplyError(c,\"Wrong CLUSTER subcommand or number of arguments\");",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2498,
          "old_api": "clusterBuildMessageHdr",
          "new_api": null,
          "old_text": "clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST)",
          "new_text": null,
          "old_line_content": "    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST);",
          "new_line_content": " * -------------------------------------------------------------------------- */",
          "content_same": false
        },
        {
          "line": 4549,
          "old_api": "sdsempty",
          "new_api": null,
          "old_text": "sdsempty()",
          "new_text": null,
          "old_line_content": "    rioInitWithBuffer(payload,sdsempty());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4550,
          "old_api": "rdbSaveObjectType",
          "new_api": null,
          "old_text": "rdbSaveObjectType(payload,o)",
          "new_text": null,
          "old_line_content": "    serverAssert(rdbSaveObjectType(payload,o));",
          "new_line_content": "/* -----------------------------------------------------------------------------",
          "content_same": false
        },
        {
          "line": 4551,
          "old_api": "rdbSaveObject",
          "new_api": null,
          "old_text": "rdbSaveObject(payload,o)",
          "new_text": null,
          "old_line_content": "    serverAssert(rdbSaveObject(payload,o));",
          "new_line_content": " * DUMP, RESTORE and MIGRATE commands",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": "htonl",
          "new_api": null,
          "old_text": "htonl(totlen)",
          "new_text": null,
          "old_line_content": "    hdr->totlen = htonl(totlen);",
          "new_line_content": " * Note that we send the failover request to everybody, master and slave nodes,",
          "content_same": false
        },
        {
          "line": 2505,
          "old_api": "clusterBroadcastMessage",
          "new_api": null,
          "old_text": "clusterBroadcastMessage(buf,totlen)",
          "new_text": null,
          "old_line_content": "    clusterBroadcastMessage(buf,totlen);",
          "new_line_content": " * but only the masters are supposed to reply to our query. */",
          "content_same": false
        },
        {
          "line": 2515,
          "old_api": "clusterBuildMessageHdr",
          "new_api": null,
          "old_text": "clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK)",
          "new_text": null,
          "old_line_content": "    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK);",
          "new_line_content": "    if (server.cluster->mf_end) hdr->mflags[0] |= CLUSTERMSG_FLAG0_FORCEACK;",
          "content_same": false
        },
        {
          "line": 4566,
          "old_api": "crc64",
          "new_api": null,
          "old_text": "crc64(0,(unsigned char*)payload->io.buffer.ptr,\n                sdslen(payload->io.buffer.ptr))",
          "new_text": null,
          "old_line_content": "    crc = crc64(0,(unsigned char*)payload->io.buffer.ptr,",
          "new_line_content": "    /* Write the footer, this is how it looks like:",
          "content_same": false
        },
        {
          "line": 4567,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(payload->io.buffer.ptr)",
          "new_text": null,
          "old_line_content": "                sdslen(payload->io.buffer.ptr));",
          "new_line_content": "     * ----------------+---------------------+---------------+",
          "content_same": false
        },
        {
          "line": 4568,
          "old_api": "memrev64ifbe",
          "new_api": null,
          "old_text": "memrev64ifbe(&crc)",
          "new_text": null,
          "old_line_content": "    memrev64ifbe(&crc);",
          "new_line_content": "     * ... RDB payload | 2 bytes RDB version | 8 bytes CRC64 |",
          "content_same": false
        },
        {
          "line": 4569,
          "old_api": "sdscatlen",
          "new_api": null,
          "old_text": "sdscatlen(payload->io.buffer.ptr,&crc,8)",
          "new_text": null,
          "old_line_content": "    payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,&crc,8);",
          "new_line_content": "     * ----------------+---------------------+---------------+",
          "content_same": false
        },
        {
          "line": 2537,
          "old_api": "ntohu64",
          "new_api": null,
          "old_text": "ntohu64(request->currentEpoch)",
          "new_text": null,
          "old_line_content": "    uint64_t requestCurrentEpoch = ntohu64(request->currentEpoch);",
          "new_line_content": "    clusterMsg *hdr = (clusterMsg*) buf;",
          "content_same": false
        },
        {
          "line": 2538,
          "old_api": "ntohu64",
          "new_api": null,
          "old_text": "ntohu64(request->configEpoch)",
          "new_text": null,
          "old_line_content": "    uint64_t requestConfigEpoch = ntohu64(request->configEpoch);",
          "new_line_content": "    uint32_t totlen;",
          "content_same": false
        },
        {
          "line": 4590,
          "old_api": "crc64",
          "new_api": null,
          "old_text": "crc64(0,p,len-8)",
          "new_text": null,
          "old_line_content": "    crc = crc64(0,p,len-8);",
          "new_line_content": "    unsigned char *footer;",
          "content_same": false
        },
        {
          "line": 4591,
          "old_api": "memrev64ifbe",
          "new_api": null,
          "old_text": "memrev64ifbe(&crc)",
          "new_text": null,
          "old_line_content": "    memrev64ifbe(&crc);",
          "new_line_content": "    uint16_t rdbver;",
          "content_same": false
        },
        {
          "line": 4592,
          "old_api": "memcmp",
          "new_api": null,
          "old_text": "memcmp(&crc,footer+2,8)",
          "new_text": null,
          "old_line_content": "    return (memcmp(&crc,footer+2,8) == 0) ? C_OK : C_ERR;",
          "new_line_content": "    uint64_t crc;",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": "nodeIsSlave",
          "new_api": null,
          "old_text": "nodeIsSlave(myself)",
          "new_text": null,
          "old_line_content": "    if (nodeIsSlave(myself) || myself->numslots == 0) return;",
          "new_line_content": "/* Vote for the node asking for our vote if there are the conditions. */",
          "content_same": false
        },
        {
          "line": 2554,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n            \"Failover auth denied to %.40s: reqEpoch (%llu) < curEpoch(%llu)\",\n            node->name,\n            (unsigned long long) requestCurrentEpoch,\n            (unsigned long long) server.cluster->currentEpoch)",
          "new_text": null,
          "old_line_content": "        serverLog(LL_WARNING,",
          "new_line_content": "    int j;",
          "content_same": false
        },
        {
          "line": 4609,
          "old_api": "createDumpPayload",
          "new_api": null,
          "old_text": "createDumpPayload(&payload,o)",
          "new_text": null,
          "old_line_content": "    createDumpPayload(&payload,o);",
          "new_line_content": " * DUMP is actually not used by Redis Cluster but it is the obvious",
          "content_same": false
        },
        {
          "line": 2564,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n                \"Failover auth denied to %.40s: already voted for epoch %llu\",\n                node->name,\n                (unsigned long long) server.cluster->currentEpoch)",
          "new_text": null,
          "old_line_content": "        serverLog(LL_WARNING,",
          "new_line_content": "     * our currentEpoch was updated as a side effect of receiving this",
          "content_same": false
        },
        {
          "line": 4612,
          "old_api": "createObject",
          "new_api": null,
          "old_text": "createObject(OBJ_STRING,payload.io.buffer.ptr)",
          "new_text": null,
          "old_line_content": "    dumpobj = createObject(OBJ_STRING,payload.io.buffer.ptr);",
          "new_line_content": "    robj *o, *dumpobj;",
          "content_same": false
        },
        {
          "line": 4613,
          "old_api": "addReplyBulk",
          "new_api": null,
          "old_text": "addReplyBulk(c,dumpobj)",
          "new_text": null,
          "old_line_content": "    addReplyBulk(c,dumpobj);",
          "new_line_content": "    rio payload;",
          "content_same": false
        },
        {
          "line": 4614,
          "old_api": "decrRefCount",
          "new_api": null,
          "old_text": "decrRefCount(dumpobj)",
          "new_text": null,
          "old_line_content": "    decrRefCount(dumpobj);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2574,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(node)",
          "new_text": null,
          "old_line_content": "    if (nodeIsMaster(node) || master == NULL ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2575,
          "old_api": "nodeFailed",
          "new_api": null,
          "old_text": "nodeFailed(master)",
          "new_text": null,
          "old_line_content": "        (!nodeFailed(master) && !force_ack))",
          "new_line_content": "    /* I already voted for this epoch? Return ASAP. */",
          "content_same": false
        },
        {
          "line": 2578,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n                    \"Failover auth denied to %.40s: it is a master node\",\n                    node->name)",
          "new_text": null,
          "old_line_content": "            serverLog(LL_WARNING,",
          "new_line_content": "                \"Failover auth denied to %.40s: already voted for epoch %llu\",",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n                    \"Failover auth denied to %.40s: I don't know its master\",\n                    node->name)",
          "new_text": null,
          "old_line_content": "            serverLog(LL_WARNING,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4630,
          "old_api": "addReply",
          "new_api": null,
          "old_text": "addReply(c,shared.syntaxerr)",
          "new_text": null,
          "old_line_content": "            addReply(c,shared.syntaxerr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2585,
          "old_api": "nodeFailed",
          "new_api": null,
          "old_text": "nodeFailed(master)",
          "new_text": null,
          "old_line_content": "        } else if (!nodeFailed(master)) {",
          "new_line_content": "     * The master can be non failing if the request is flagged",
          "content_same": false
        },
        {
          "line": 2586,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n                    \"Failover auth denied to %.40s: its master is up\",\n                    node->name)",
          "new_text": null,
          "old_line_content": "            serverLog(LL_WARNING,",
          "new_line_content": "     * with CLUSTERMSG_FLAG0_FORCEACK (manual failover). */",
          "content_same": false
        },
        {
          "line": 4636,
          "old_api": "lookupKeyWrite",
          "new_api": null,
          "old_text": "lookupKeyWrite(c->db,c->argv[1])",
          "new_text": null,
          "old_line_content": "    if (!replace && lookupKeyWrite(c->db,c->argv[1]) != NULL) {",
          "new_line_content": "    robj *obj;",
          "content_same": false
        },
        {
          "line": 4637,
          "old_api": "addReply",
          "new_api": null,
          "old_text": "addReply(c,shared.busykeyerr)",
          "new_text": null,
          "old_line_content": "        addReply(c,shared.busykeyerr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4642,
          "old_api": "getLongLongFromObjectOrReply",
          "new_api": null,
          "old_text": "getLongLongFromObjectOrReply(c,c->argv[2],&ttl,NULL)",
          "new_text": null,
          "old_line_content": "    if (getLongLongFromObjectOrReply(c,c->argv[2],&ttl,NULL) != C_OK) {",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 2596,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "    if (mstime() - node->slaveof->voted_time < server.cluster_node_timeout * 2)",
          "new_line_content": "                    \"Failover auth denied to %.40s: I don't know its master\",",
          "content_same": false
        },
        {
          "line": 4645,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"Invalid TTL value, must be >= 0\")",
          "new_text": null,
          "old_line_content": "        addReplyError(c,\"Invalid TTL value, must be >= 0\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "                             (mstime() - node->slaveof->voted_time)));",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 4652,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"DUMP payload version or checksum are wrong\")",
          "new_text": null,
          "old_line_content": "        addReplyError(c,\"DUMP payload version or checksum are wrong\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4656,
          "old_api": "rioInitWithBuffer",
          "new_api": null,
          "old_text": "rioInitWithBuffer(&payload,c->argv[3]->ptr)",
          "new_text": null,
          "old_line_content": "    rioInitWithBuffer(&payload,c->argv[3]->ptr);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 4657,
          "old_api": "rdbLoadObjectType",
          "new_api": null,
          "old_text": "rdbLoadObjectType(&payload)",
          "new_text": null,
          "old_line_content": "    if (((type = rdbLoadObjectType(&payload)) == -1) ||",
          "new_line_content": "    } else if (ttl < 0) {",
          "content_same": false
        },
        {
          "line": 4660,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"Bad data format\")",
          "new_text": null,
          "old_line_content": "        addReplyError(c,\"Bad data format\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2620,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n                \"Failover auth denied to %.40s: \"\n                \"slot %d epoch (%llu) > reqEpoch (%llu)\",\n                node->name, j,\n                (unsigned long long) server.cluster->slots[j]->configEpoch,\n                (unsigned long long) requestConfigEpoch)",
          "new_text": null,
          "old_line_content": "        serverLog(LL_WARNING,",
          "new_line_content": "    /* The slave requesting the vote must have a configEpoch for the claimed",
          "content_same": false
        },
        {
          "line": 4668,
          "old_api": "dbAdd",
          "new_api": null,
          "old_text": "dbAdd(c->db,c->argv[1],obj)",
          "new_text": null,
          "old_line_content": "    dbAdd(c->db,c->argv[1],obj);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2630,
          "old_api": "clusterSendFailoverAuth",
          "new_api": null,
          "old_text": "clusterSendFailoverAuth(node)",
          "new_text": null,
          "old_line_content": "    clusterSendFailoverAuth(node);",
          "new_line_content": "        /* If we reached this point we found a slot that in our current slots",
          "content_same": false
        },
        {
          "line": 2632,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "    node->slaveof->voted_time = mstime();",
          "new_line_content": "         * by the slave requesting our vote. Refuse to vote for this slave. */",
          "content_same": false
        },
        {
          "line": 2654,
          "old_api": "nodeIsSlave",
          "new_api": null,
          "old_text": "nodeIsSlave(myself)",
          "new_text": null,
          "old_line_content": "    serverAssert(nodeIsSlave(myself));",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 4703,
          "old_api": "sdsempty",
          "new_api": null,
          "old_text": "sdsempty()",
          "new_text": null,
          "old_line_content": "    sds name = sdsempty();",
          "new_line_content": "/* Return a migrateCachedSocket containing a TCP socket connected with the",
          "content_same": false
        },
        {
          "line": 2658,
          "old_api": "replicationGetSlaveOffset",
          "new_api": null,
          "old_text": "replicationGetSlaveOffset()",
          "new_text": null,
          "old_line_content": "    myoffset = replicationGetSlaveOffset();",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 4707,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(host->ptr)",
          "new_text": null,
          "old_line_content": "    name = sdscatlen(name,host->ptr,sdslen(host->ptr));",
          "new_line_content": " * connection can't be established. In this case -1 is returned.",
          "content_same": false
        },
        {
          "line": 4708,
          "old_api": "sdscatlen",
          "new_api": null,
          "old_text": "sdscatlen(name,\":\",1)",
          "new_text": null,
          "old_line_content": "    name = sdscatlen(name,\":\",1);",
          "new_line_content": " * Otherwise on success the socket is returned, and the caller should not",
          "content_same": false
        },
        {
          "line": 4709,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(port->ptr)",
          "new_text": null,
          "old_line_content": "    name = sdscatlen(name,port->ptr,sdslen(port->ptr));",
          "new_line_content": " * attempt to free it after usage.",
          "content_same": false
        },
        {
          "line": 4710,
          "old_api": "dictFetchValue",
          "new_api": null,
          "old_text": "dictFetchValue(server.migrate_cached_sockets,name)",
          "new_text": null,
          "old_line_content": "    cs = dictFetchValue(server.migrate_cached_sockets,name);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 4712,
          "old_api": "sdsfree",
          "new_api": null,
          "old_text": "sdsfree(name)",
          "new_text": null,
          "old_line_content": "        sdsfree(name);",
          "new_line_content": " * should be called so that the connection will be created from scratch",
          "content_same": false
        },
        {
          "line": 4718,
          "old_api": "dictSize",
          "new_api": null,
          "old_text": "dictSize(server.migrate_cached_sockets)",
          "new_text": null,
          "old_line_content": "    if (dictSize(server.migrate_cached_sockets) == MIGRATE_SOCKET_CACHE_ITEMS) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4724,
          "old_api": "dictGetKey",
          "new_api": null,
          "old_text": "dictGetKey(de)",
          "new_text": null,
          "old_line_content": "        dictDelete(server.migrate_cached_sockets,dictGetKey(de));",
          "new_line_content": "    if (cs) {",
          "content_same": false
        },
        {
          "line": 4728,
          "old_api": "anetTcpNonBlockConnect",
          "new_api": null,
          "old_text": "anetTcpNonBlockConnect(server.neterr,c->argv[1]->ptr,\n                                atoi(c->argv[2]->ptr))",
          "new_text": null,
          "old_line_content": "    fd = anetTcpNonBlockConnect(server.neterr,c->argv[1]->ptr,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4729,
          "old_api": "atoi",
          "new_api": null,
          "old_text": "atoi(c->argv[2]->ptr)",
          "new_text": null,
          "old_line_content": "                                atoi(c->argv[2]->ptr));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4732,
          "old_api": "addReplyErrorFormat",
          "new_api": null,
          "old_text": "addReplyErrorFormat(c,\"Can't connect to target node: %s\",\n            server.neterr)",
          "new_text": null,
          "old_line_content": "        addReplyErrorFormat(c,\"Can't connect to target node: %s\",",
          "new_line_content": "        /* Too many items, drop one at random. */",
          "content_same": false
        },
        {
          "line": 4739,
          "old_api": "aeWait",
          "new_api": null,
          "old_text": "aeWait(fd,AE_WRITABLE,timeout)",
          "new_text": null,
          "old_line_content": "    if ((aeWait(fd,AE_WRITABLE,timeout) & AE_WRITABLE) == 0) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4740,
          "old_api": "sdsfree",
          "new_api": null,
          "old_text": "sdsfree(name)",
          "new_text": null,
          "old_line_content": "        sdsfree(name);",
          "new_line_content": "    /* Create the socket */",
          "content_same": false
        },
        {
          "line": 2694,
          "old_api": "time",
          "new_api": null,
          "old_text": "time(NULL)",
          "new_text": null,
          "old_line_content": "        time(NULL)-lastlog_time < CLUSTER_CANT_FAILOVER_RELOG_PERIOD)",
          "new_line_content": " *    failover starts in a reasonable time.",
          "content_same": false
        },
        {
          "line": 4743,
          "old_api": "close",
          "new_api": null,
          "old_text": "close(fd)",
          "new_text": null,
          "old_line_content": "        close(fd);",
          "new_line_content": "    if (fd == -1) {",
          "content_same": false
        },
        {
          "line": 4748,
          "old_api": "zmalloc",
          "new_api": null,
          "old_text": "zmalloc(sizeof(*cs))",
          "new_text": null,
          "old_line_content": "    cs = zmalloc(sizeof(*cs));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2703,
          "old_api": "nodeFailed",
          "new_api": null,
          "old_text": "nodeFailed(myself->slaveof)",
          "new_text": null,
          "old_line_content": "        nodeFailed(myself->slaveof) &&",
          "new_line_content": "    mstime_t nolog_fail_time = server.cluster_node_timeout + 5000;",
          "content_same": false
        },
        {
          "line": 2704,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "        (mstime() - myself->slaveof->fail_time) < nolog_fail_time) return;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4758,
          "old_api": "sdsempty",
          "new_api": null,
          "old_text": "sdsempty()",
          "new_text": null,
          "old_line_content": "    sds name = sdsempty();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4762,
          "old_api": "sdscatlen",
          "new_api": null,
          "old_text": "sdscatlen(name,\":\",1)",
          "new_text": null,
          "old_line_content": "    name = sdscatlen(name,\":\",1);",
          "new_line_content": "    cs->fd = fd;",
          "content_same": false
        },
        {
          "line": 4763,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(port->ptr)",
          "new_text": null,
          "old_line_content": "    name = sdscatlen(name,port->ptr,sdslen(port->ptr));",
          "new_line_content": "    cs->last_dbid = -1;",
          "content_same": false
        },
        {
          "line": 4764,
          "old_api": "dictFetchValue",
          "new_api": null,
          "old_text": "dictFetchValue(server.migrate_cached_sockets,name)",
          "new_text": null,
          "old_line_content": "    cs = dictFetchValue(server.migrate_cached_sockets,name);",
          "new_line_content": "    cs->last_use_time = server.unixtime;",
          "content_same": false
        },
        {
          "line": 4766,
          "old_api": "sdsfree",
          "new_api": null,
          "old_text": "sdsfree(name)",
          "new_text": null,
          "old_line_content": "        sdsfree(name);",
          "new_line_content": "    return cs;",
          "content_same": false
        },
        {
          "line": 4770,
          "old_api": "close",
          "new_api": null,
          "old_text": "close(cs->fd)",
          "new_text": null,
          "old_line_content": "    close(cs->fd);",
          "new_line_content": "void migrateCloseSocket(robj *host, robj *port) {",
          "content_same": false
        },
        {
          "line": 4772,
          "old_api": "dictDelete",
          "new_api": null,
          "old_text": "dictDelete(server.migrate_cached_sockets,name)",
          "new_text": null,
          "old_line_content": "    dictDelete(server.migrate_cached_sockets,name);",
          "new_line_content": "    migrateCachedSocket *cs;",
          "content_same": false
        },
        {
          "line": 2725,
          "old_api": "time",
          "new_api": null,
          "old_text": "time(NULL)",
          "new_text": null,
          "old_line_content": "    lastlog_time = time(NULL);",
          "new_line_content": "    case CLUSTER_CANT_FAILOVER_WAITING_DELAY:",
          "content_same": false
        },
        {
          "line": 2726,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\"Currently unable to failover: %s\", msg)",
          "new_text": null,
          "old_line_content": "    serverLog(LL_WARNING,\"Currently unable to failover: %s\", msg);",
          "new_line_content": "        msg = \"Waiting the delay before I can start a new failover.\";",
          "content_same": false
        },
        {
          "line": 4773,
          "old_api": "sdsfree",
          "new_api": null,
          "old_text": "sdsfree(name)",
          "new_text": null,
          "old_line_content": "    sdsfree(name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4780,
          "old_api": "dictNext",
          "new_api": null,
          "old_text": "dictNext(di)",
          "new_text": null,
          "old_line_content": "    while((de = dictNext(di)) != NULL) {",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 4781,
          "old_api": "dictGetVal",
          "new_api": null,
          "old_text": "dictGetVal(de)",
          "new_text": null,
          "old_line_content": "        migrateCachedSocket *cs = dictGetVal(de);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4789,
          "old_api": "dictReleaseIterator",
          "new_api": null,
          "old_text": "dictReleaseIterator(di)",
          "new_text": null,
          "old_line_content": "    dictReleaseIterator(di);",
          "new_line_content": "void migrateCloseTimedoutSockets(void) {",
          "content_same": false
        },
        {
          "line": 2742,
          "old_api": "clusterSetNodeAsMaster",
          "new_api": null,
          "old_text": "clusterSetNodeAsMaster(myself)",
          "new_text": null,
          "old_line_content": "    clusterSetNodeAsMaster(myself);",
          "new_line_content": "/* This function implements the final part of automatic and manual failovers,",
          "content_same": false
        },
        {
          "line": 2743,
          "old_api": "replicationUnsetMaster",
          "new_api": null,
          "old_text": "replicationUnsetMaster()",
          "new_text": null,
          "old_line_content": "    replicationUnsetMaster();",
          "new_line_content": " * where the slave grabs its master's hash slots, and propagates the new",
          "content_same": false
        },
        {
          "line": 2747,
          "old_api": "clusterNodeGetSlotBit",
          "new_api": null,
          "old_text": "clusterNodeGetSlotBit(oldmaster,j)",
          "new_text": null,
          "old_line_content": "        if (clusterNodeGetSlotBit(oldmaster,j)) {",
          "new_line_content": " * configuration epoch already. */",
          "content_same": false
        },
        {
          "line": 2748,
          "old_api": "clusterDelSlot",
          "new_api": null,
          "old_text": "clusterDelSlot(j)",
          "new_text": null,
          "old_line_content": "            clusterDelSlot(j);",
          "new_line_content": "void clusterFailoverReplaceYourMaster(void) {",
          "content_same": false
        },
        {
          "line": 2749,
          "old_api": "clusterAddSlot",
          "new_api": null,
          "old_text": "clusterAddSlot(myself,j)",
          "new_text": null,
          "old_line_content": "            clusterAddSlot(myself,j);",
          "new_line_content": "    int j;",
          "content_same": false
        },
        {
          "line": 2754,
          "old_api": "clusterUpdateState",
          "new_api": null,
          "old_text": "clusterUpdateState()",
          "new_text": null,
          "old_line_content": "    clusterUpdateState();",
          "new_line_content": "    /* 1) Turn this node into a master. */",
          "content_same": false
        },
        {
          "line": 2759,
          "old_api": "clusterBroadcastPong",
          "new_api": null,
          "old_text": "clusterBroadcastPong(CLUSTER_BROADCAST_ALL)",
          "new_text": null,
          "old_line_content": "    clusterBroadcastPong(CLUSTER_BROADCAST_ALL);",
          "new_line_content": "    for (j = 0; j < CLUSTER_SLOTS; j++) {",
          "content_same": false
        },
        {
          "line": 4820,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[j]->ptr,\"copy\")",
          "new_text": null,
          "old_line_content": "        if (!strcasecmp(c->argv[j]->ptr,\"copy\")) {",
          "new_line_content": "    int write_error = 0;",
          "content_same": false
        },
        {
          "line": 4822,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[j]->ptr,\"replace\")",
          "new_text": null,
          "old_line_content": "        } else if (!strcasecmp(c->argv[j]->ptr,\"replace\")) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4824,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[j]->ptr,\"keys\")",
          "new_text": null,
          "old_line_content": "        } else if (!strcasecmp(c->argv[j]->ptr,\"keys\")) {",
          "new_line_content": "    int first_key = 3; /* Argument index of the first key. */",
          "content_same": false
        },
        {
          "line": 4825,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(c->argv[3]->ptr)",
          "new_text": null,
          "old_line_content": "            if (sdslen(c->argv[3]->ptr) != 0) {",
          "new_line_content": "    int num_keys = 1;  /* By default only migrate the 'key' argument. */",
          "content_same": false
        },
        {
          "line": 4826,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\n                    \"When using MIGRATE KEYS option, the key argument\"\n                    \" must be set to the empty string\")",
          "new_text": null,
          "old_line_content": "                addReplyError(c,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4841,
          "old_api": "getLongFromObjectOrReply",
          "new_api": null,
          "old_text": "getLongFromObjectOrReply(c,c->argv[5],&timeout,NULL)",
          "new_text": null,
          "old_line_content": "    if (getLongFromObjectOrReply(c,c->argv[5],&timeout,NULL) != C_OK ||",
          "new_line_content": "                    \" must be set to the empty string\");",
          "content_same": false
        },
        {
          "line": 4842,
          "old_api": "getLongFromObjectOrReply",
          "new_api": null,
          "old_text": "getLongFromObjectOrReply(c,c->argv[4],&dbid,NULL)",
          "new_text": null,
          "old_line_content": "        getLongFromObjectOrReply(c,c->argv[4],&dbid,NULL) != C_OK)",
          "new_line_content": "                return;",
          "content_same": false
        },
        {
          "line": 2799,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(myself)",
          "new_text": null,
          "old_line_content": "    if (nodeIsMaster(myself) ||",
          "new_line_content": "     *",
          "content_same": false
        },
        {
          "line": 2801,
          "old_api": "nodeFailed",
          "new_api": null,
          "old_text": "nodeFailed(myself->slaveof)",
          "new_text": null,
          "old_line_content": "        (!nodeFailed(myself->slaveof) && !manual_failover) ||",
          "new_line_content": "     * Retry is two times the Timeout.",
          "content_same": false
        },
        {
          "line": 4853,
          "old_api": "zrealloc",
          "new_api": null,
          "old_text": "zrealloc(ov,sizeof(robj*)*num_keys)",
          "new_text": null,
          "old_line_content": "    ov = zrealloc(ov,sizeof(robj*)*num_keys);",
          "new_line_content": "    /* Sanity check */",
          "content_same": false
        },
        {
          "line": 4858,
          "old_api": "lookupKeyRead",
          "new_api": null,
          "old_text": "lookupKeyRead(c->db,c->argv[first_key+j])",
          "new_text": null,
          "old_line_content": "        if ((ov[oi] = lookupKeyRead(c->db,c->argv[first_key+j])) != NULL) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2813,
          "old_api": "mstime_t)(server.unixtime - server.master->lastinteraction)",
          "new_api": null,
          "old_text": "mstime_t)(server.unixtime - server.master->lastinteraction)",
          "new_text": null,
          "old_line_content": "        data_age = (mstime_t)(server.unixtime - server.master->lastinteraction)",
          "new_line_content": "        myself->slaveof == NULL ||",
          "content_same": false
        },
        {
          "line": 2816,
          "old_api": "mstime_t)(server.unixtime - server.repl_down_since)",
          "new_api": null,
          "old_text": "mstime_t)(server.unixtime - server.repl_down_since)",
          "new_text": null,
          "old_line_content": "        data_age = (mstime_t)(server.unixtime - server.repl_down_since) * 1000;",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 4865,
          "old_api": "zfree",
          "new_api": null,
          "old_text": "zfree(kv)",
          "new_text": null,
          "old_line_content": "        zfree(ov); zfree(kv);",
          "new_line_content": "     * expiring in the meantime. */",
          "content_same": false
        },
        {
          "line": 4874,
          "old_api": "migrateGetSocket",
          "new_api": null,
          "old_text": "migrateGetSocket(c,c->argv[1],c->argv[2],timeout)",
          "new_text": null,
          "old_line_content": "    cs = migrateGetSocket(c,c->argv[1],c->argv[2],timeout);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 4876,
          "old_api": "zfree",
          "new_api": null,
          "old_text": "zfree(kv)",
          "new_text": null,
          "old_line_content": "        zfree(ov); zfree(kv);",
          "new_line_content": "    num_keys = oi;",
          "content_same": false
        },
        {
          "line": 4880,
          "old_api": "sdsempty",
          "new_api": null,
          "old_text": "sdsempty()",
          "new_text": null,
          "old_line_content": "    rioInitWithBuffer(&cmd,sdsempty());",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 2835,
          "old_api": "clusterLogCantFailover",
          "new_api": null,
          "old_text": "clusterLogCantFailover(CLUSTER_CANT_FAILOVER_DATA_AGE)",
          "new_text": null,
          "old_line_content": "            clusterLogCantFailover(CLUSTER_CANT_FAILOVER_DATA_AGE);",
          "new_line_content": "    if (data_age > server.cluster_node_timeout)",
          "content_same": false
        },
        {
          "line": 4885,
          "old_api": "rioWriteBulkCount",
          "new_api": null,
          "old_text": "rioWriteBulkCount(&cmd,'*',2)",
          "new_text": null,
          "old_line_content": "        serverAssertWithInfo(c,NULL,rioWriteBulkCount(&cmd,'*',2));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4886,
          "old_api": "rioWriteBulkString",
          "new_api": null,
          "old_text": "rioWriteBulkString(&cmd,\"SELECT\",6)",
          "new_text": null,
          "old_line_content": "        serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,\"SELECT\",6));",
          "new_line_content": "    /* Connect */",
          "content_same": false
        },
        {
          "line": 2843,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "        server.cluster->failover_auth_time = mstime() +",
          "new_line_content": "        data_age >",
          "content_same": false
        },
        {
          "line": 2845,
          "old_api": "random",
          "new_api": null,
          "old_text": "random()",
          "new_text": null,
          "old_line_content": "            random() % 500; /* Random delay between 0 and 500 milliseconds. */",
          "new_line_content": "         (server.cluster_node_timeout * server.cluster_slave_validity_factor)))",
          "content_same": false
        },
        {
          "line": 4896,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "            ttl = expireat-mstime();",
          "new_line_content": "    int select = cs->last_dbid != dbid; /* Should we emit SELECT? */",
          "content_same": false
        },
        {
          "line": 4901,
          "old_api": "serverAssertWithInfo",
          "new_api": null,
          "old_text": "serverAssertWithInfo(c,NULL,\n                rioWriteBulkString(&cmd,\"RESTORE-ASKING\",14))",
          "new_text": null,
          "old_line_content": "            serverAssertWithInfo(c,NULL,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4902,
          "old_api": "rioWriteBulkString",
          "new_api": null,
          "old_text": "rioWriteBulkString(&cmd,\"RESTORE-ASKING\",14)",
          "new_text": null,
          "old_line_content": "                rioWriteBulkString(&cmd,\"RESTORE-ASKING\",14));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4904,
          "old_api": "rioWriteBulkString",
          "new_api": null,
          "old_text": "rioWriteBulkString(&cmd,\"RESTORE\",7)",
          "new_text": null,
          "old_line_content": "            serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,\"RESTORE\",7));",
          "new_line_content": "    for (j = 0; j < num_keys; j++) {",
          "content_same": false
        },
        {
          "line": 4905,
          "old_api": "sdsEncodedObject",
          "new_api": null,
          "old_text": "sdsEncodedObject(kv[j])",
          "new_text": null,
          "old_line_content": "        serverAssertWithInfo(c,NULL,sdsEncodedObject(kv[j]));",
          "new_line_content": "        long long ttl = 0;",
          "content_same": false
        },
        {
          "line": 2859,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n            \"Start of election delayed for %lld milliseconds \"\n            \"(rank #%d, offset %lld).\",\n            server.cluster->failover_auth_time - mstime(),\n            server.cluster->failover_auth_rank,\n            replicationGetSlaveOffset())",
          "new_text": null,
          "old_line_content": "        serverLog(LL_WARNING,",
          "new_line_content": "        server.cluster->failover_auth_count = 0;",
          "content_same": false
        },
        {
          "line": 4908,
          "old_api": "rioWriteBulkLongLong",
          "new_api": null,
          "old_text": "rioWriteBulkLongLong(&cmd,ttl)",
          "new_text": null,
          "old_line_content": "        serverAssertWithInfo(c,NULL,rioWriteBulkLongLong(&cmd,ttl));",
          "new_line_content": "        if (expireat != -1) {",
          "content_same": false
        },
        {
          "line": 4907,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(kv[j]->ptr)",
          "new_text": null,
          "old_line_content": "                sdslen(kv[j]->ptr)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2862,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "            server.cluster->failover_auth_time - mstime(),",
          "new_line_content": "        /* We add another delay that is proportional to the slave rank.",
          "content_same": false
        },
        {
          "line": 2864,
          "old_api": "replicationGetSlaveOffset",
          "new_api": null,
          "old_text": "replicationGetSlaveOffset()",
          "new_text": null,
          "old_line_content": "            replicationGetSlaveOffset());",
          "new_line_content": "         * less updated replication offset, are penalized. */",
          "content_same": false
        },
        {
          "line": 4913,
          "old_api": "serverAssertWithInfo",
          "new_api": null,
          "old_text": "serverAssertWithInfo(c,NULL,\n            rioWriteBulkString(&cmd,payload.io.buffer.ptr,\n                               sdslen(payload.io.buffer.ptr)))",
          "new_text": null,
          "old_line_content": "        serverAssertWithInfo(c,NULL,",
          "new_line_content": "        if (server.cluster_enabled)",
          "content_same": false
        },
        {
          "line": 2868,
          "old_api": "clusterBroadcastPong",
          "new_api": null,
          "old_text": "clusterBroadcastPong(CLUSTER_BROADCAST_LOCAL_SLAVES)",
          "new_text": null,
          "old_line_content": "        clusterBroadcastPong(CLUSTER_BROADCAST_LOCAL_SLAVES);",
          "new_line_content": "        if (server.cluster->mf_end) {",
          "content_same": false
        },
        {
          "line": 4916,
          "old_api": "sdsfree",
          "new_api": null,
          "old_text": "sdsfree(payload.io.buffer.ptr)",
          "new_text": null,
          "old_line_content": "        sdsfree(payload.io.buffer.ptr);",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 2880,
          "old_api": "clusterGetSlaveRank",
          "new_api": null,
          "old_text": "clusterGetSlaveRank()",
          "new_text": null,
          "old_line_content": "        int newrank = clusterGetSlaveRank();",
          "new_line_content": "         * if our offset is better. */",
          "content_same": false
        },
        {
          "line": 4931,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(buf)",
          "new_text": null,
          "old_line_content": "        while ((towrite = sdslen(buf)-pos) > 0) {",
          "new_line_content": "        /* Add the REPLACE option to the RESTORE command if it was specified",
          "content_same": false
        },
        {
          "line": 4933,
          "old_api": "syncWrite",
          "new_api": null,
          "old_text": "syncWrite(cs->fd,buf+pos,towrite,timeout)",
          "new_text": null,
          "old_line_content": "            nwritten = syncWrite(cs->fd,buf+pos,towrite,timeout);",
          "new_line_content": "        if (replace)",
          "content_same": false
        },
        {
          "line": 2886,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n                \"Slave rank updated to #%d, added %lld milliseconds of delay.\",\n                newrank, added_delay)",
          "new_text": null,
          "old_line_content": "            serverLog(LL_WARNING,",
          "new_line_content": "     * slaves for the same master since we computed our election delay.",
          "content_same": false
        },
        {
          "line": 2894,
          "old_api": "clusterLogCantFailover",
          "new_api": null,
          "old_text": "clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_DELAY)",
          "new_text": null,
          "old_line_content": "        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_DELAY);",
          "new_line_content": "        if (newrank > server.cluster->failover_auth_rank) {",
          "content_same": false
        },
        {
          "line": 2900,
          "old_api": "clusterLogCantFailover",
          "new_api": null,
          "old_text": "clusterLogCantFailover(CLUSTER_CANT_FAILOVER_EXPIRED)",
          "new_text": null,
          "old_line_content": "        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_EXPIRED);",
          "new_line_content": "                \"Slave rank updated to #%d, added %lld milliseconds of delay.\",",
          "content_same": false
        },
        {
          "line": 4954,
          "old_api": "zmalloc",
          "new_api": null,
          "old_text": "zmalloc(sizeof(robj*)*(num_keys+1))",
          "new_text": null,
          "old_line_content": "    if (!copy) newargv = zmalloc(sizeof(robj*)*(num_keys+1));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2908,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\"Starting a failover election for epoch %llu.\",\n            (unsigned long long) server.cluster->currentEpoch)",
          "new_text": null,
          "old_line_content": "        serverLog(LL_WARNING,\"Starting a failover election for epoch %llu.\",",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 4957,
          "old_api": "syncReadLine",
          "new_api": null,
          "old_text": "syncReadLine(cs->fd, buf2, sizeof(buf2), timeout)",
          "new_text": null,
          "old_line_content": "        if (syncReadLine(cs->fd, buf2, sizeof(buf2), timeout) <= 0) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2910,
          "old_api": "clusterRequestFailoverAuth",
          "new_api": null,
          "old_text": "clusterRequestFailoverAuth()",
          "new_text": null,
          "old_line_content": "        clusterRequestFailoverAuth();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2912,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                             CLUSTER_TODO_UPDATE_STATE|\n                             CLUSTER_TODO_FSYNC_CONFIG)",
          "new_text": null,
          "old_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "new_line_content": "    if (auth_age > auth_timeout) {",
          "content_same": false
        },
        {
          "line": 4965,
          "old_api": "addReplyErrorFormat",
          "new_api": null,
          "old_text": "addReplyErrorFormat(c,\"Target instance replied with error: %s\",\n                    (select && buf1[0] == '-') ? buf1+1 : buf2+1)",
          "new_text": null,
          "old_line_content": "                addReplyErrorFormat(c,\"Target instance replied with error: %s\",",
          "new_line_content": "    int del_idx = 1; /* Index of the key argument for the replicated DEL op. */",
          "content_same": false
        },
        {
          "line": 2922,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n            \"Failover election won: I'm the new master.\")",
          "new_text": null,
          "old_line_content": "        serverLog(LL_WARNING,",
          "new_line_content": "            (unsigned long long) server.cluster->currentEpoch);",
          "content_same": false
        },
        {
          "line": 4972,
          "old_api": "dbDelete",
          "new_api": null,
          "old_text": "dbDelete(c->db,kv[j])",
          "new_text": null,
          "old_line_content": "                dbDelete(c->db,kv[j]);",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 4973,
          "old_api": "signalModifiedKey",
          "new_api": null,
          "old_text": "signalModifiedKey(c->db,kv[j])",
          "new_text": null,
          "old_line_content": "                signalModifiedKey(c->db,kv[j]);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2928,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n                \"configEpoch set to %llu after successful failover\",\n                (unsigned long long) myself->configEpoch)",
          "new_text": null,
          "old_line_content": "            serverLog(LL_WARNING,",
          "new_line_content": "        return; /* Wait for replies. */",
          "content_same": false
        },
        {
          "line": 2934,
          "old_api": "clusterFailoverReplaceYourMaster",
          "new_api": null,
          "old_text": "clusterFailoverReplaceYourMaster()",
          "new_text": null,
          "old_line_content": "        clusterFailoverReplaceYourMaster();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2936,
          "old_api": "clusterLogCantFailover",
          "new_api": null,
          "old_text": "clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES)",
          "new_text": null,
          "old_line_content": "        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES);",
          "new_line_content": "            \"Failover election won: I'm the new master.\");",
          "content_same": false
        },
        {
          "line": 4995,
          "old_api": "migrateCloseSocket",
          "new_api": null,
          "old_text": "migrateCloseSocket(c->argv[1],c->argv[2])",
          "new_text": null,
          "old_line_content": "    if (socket_error) migrateCloseSocket(c->argv[1],c->argv[2]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5002,
          "old_api": "createStringObject",
          "new_api": null,
          "old_text": "createStringObject(\"DEL\",3)",
          "new_text": null,
          "old_line_content": "            newargv[0] = createStringObject(\"DEL\",3);",
          "new_line_content": "        goto socket_err; /* A retry is guaranteed because of tested conditions.*/",
          "content_same": false
        },
        {
          "line": 5004,
          "old_api": "replaceClientCommandVector",
          "new_api": null,
          "old_text": "replaceClientCommandVector(c,del_idx,newargv)",
          "new_text": null,
          "old_line_content": "            replaceClientCommandVector(c,del_idx,newargv);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2980,
          "old_api": "nodeFailed",
          "new_api": null,
          "old_text": "nodeFailed(mymaster->slaves[j])",
          "new_text": null,
          "old_line_content": "        if (!nodeFailed(mymaster->slaves[j]) &&",
          "new_line_content": "void clusterHandleSlaveMigration(int max_slaves) {",
          "content_same": false
        },
        {
          "line": 2981,
          "old_api": "nodeTimedOut",
          "new_api": null,
          "old_text": "nodeTimedOut(mymaster->slaves[j])",
          "new_text": null,
          "old_line_content": "            !nodeTimedOut(mymaster->slaves[j])) okslaves++;",
          "new_line_content": "    int j, okslaves = 0;",
          "content_same": false
        },
        {
          "line": 5029,
          "old_api": "addReply",
          "new_api": null,
          "old_text": "addReply(c,shared.ok)",
          "new_text": null,
          "old_line_content": "        addReply(c,shared.ok);",
          "new_line_content": "    if (!error_from_target && socket_error) {",
          "content_same": false
        },
        {
          "line": 5035,
          "old_api": "sdsfree",
          "new_api": null,
          "old_text": "sdsfree(cmd.io.buffer.ptr)",
          "new_text": null,
          "old_line_content": "    sdsfree(cmd.io.buffer.ptr);",
          "new_line_content": "        /* Success! Update the last_dbid in migrateCachedSocket, so that we can",
          "content_same": false
        },
        {
          "line": 5036,
          "old_api": "zfree",
          "new_api": null,
          "old_text": "zfree(newargv)",
          "new_text": null,
          "old_line_content": "    zfree(ov); zfree(kv); zfree(newargv);",
          "new_line_content": "         * avoid SELECT the next time if the target DB is the same. Reply +OK.",
          "content_same": false
        },
        {
          "line": 2995,
          "old_api": "dictGetSafeIterator",
          "new_api": null,
          "old_text": "dictGetSafeIterator(server.cluster->nodes)",
          "new_text": null,
          "old_line_content": "    di = dictGetSafeIterator(server.cluster->nodes);",
          "new_line_content": "    if (okslaves <= server.cluster_migration_barrier) return;",
          "content_same": false
        },
        {
          "line": 2996,
          "old_api": "dictNext",
          "new_api": null,
          "old_text": "dictNext(di)",
          "new_text": null,
          "old_line_content": "    while((de = dictNext(di)) != NULL) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2997,
          "old_api": "dictGetVal",
          "new_api": null,
          "old_text": "dictGetVal(de)",
          "new_text": null,
          "old_line_content": "        clusterNode *node = dictGetVal(de);",
          "new_line_content": "    /* Step 3: Idenitfy a candidate for migration, and check if among the",
          "content_same": false
        },
        {
          "line": 5045,
          "old_api": "sdsfree",
          "new_api": null,
          "old_text": "sdsfree(cmd.io.buffer.ptr)",
          "new_text": null,
          "old_line_content": "    sdsfree(cmd.io.buffer.ptr);",
          "new_line_content": "         * the curretly selected socket to -1 to force SELECT the next time. */",
          "content_same": false
        },
        {
          "line": 5051,
          "old_api": "migrateCloseSocket",
          "new_api": null,
          "old_text": "migrateCloseSocket(c->argv[1],c->argv[2])",
          "new_text": null,
          "old_line_content": "    if (!argv_rewritten) migrateCloseSocket(c->argv[1],c->argv[2]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3004,
          "old_api": "nodeFailed",
          "new_api": null,
          "old_text": "nodeFailed(node)",
          "new_text": null,
          "old_line_content": "        if (nodeIsSlave(node) || nodeFailed(node)) is_orphaned = 0;",
          "new_line_content": "     * this does not mean that there are no race conditions possible (two",
          "content_same": false
        },
        {
          "line": 5052,
          "old_api": "zfree",
          "new_api": null,
          "old_text": "zfree(newargv)",
          "new_text": null,
          "old_line_content": "    zfree(newargv);",
          "new_line_content": "/* On socket errors we try to close the cached socket and try again.",
          "content_same": false
        },
        {
          "line": 5063,
          "old_api": "zfree",
          "new_api": null,
          "old_text": "zfree(kv)",
          "new_text": null,
          "old_line_content": "    zfree(ov); zfree(kv);",
          "new_line_content": "     * again. */",
          "content_same": false
        },
        {
          "line": 3016,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "            if (!node->orphaned_time) node->orphaned_time = mstime();",
          "new_line_content": "         * supposed to have replicas. */",
          "content_same": false
        },
        {
          "line": 3026,
          "old_api": "memcmp",
          "new_api": null,
          "old_text": "memcmp(node->slaves[j]->name,\n                           candidate->name,\n                           CLUSTER_NAMELEN)",
          "new_text": null,
          "old_line_content": "                if (memcmp(node->slaves[j]->name,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5081,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"This instance has cluster support disabled\")",
          "new_text": null,
          "old_line_content": "        addReplyError(c,\"This instance has cluster support disabled\");",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 3035,
          "old_api": "dictReleaseIterator",
          "new_api": null,
          "old_text": "dictReleaseIterator(di)",
          "new_text": null,
          "old_line_content": "    dictReleaseIterator(di);",
          "new_line_content": "         * to a master with the maximum number of slaves and with the smallest",
          "content_same": false
        },
        {
          "line": 5085,
          "old_api": "addReply",
          "new_api": null,
          "old_text": "addReply(c,shared.ok)",
          "new_text": null,
          "old_line_content": "    addReply(c,shared.ok);",
          "new_line_content": " * Cluster functions related to serving / redirecting clients",
          "content_same": false
        },
        {
          "line": 3043,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "        (mstime()-target->orphaned_time) > CLUSTER_SLAVE_MIGRATION_DELAY)",
          "new_line_content": "                    candidate = node->slaves[j];",
          "content_same": false
        },
        {
          "line": 3045,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\"Migrating to orphaned master %.40s\",\n            target->name)",
          "new_text": null,
          "old_line_content": "        serverLog(LL_WARNING,\"Migrating to orphaned master %.40s\",",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 5093,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"This instance has cluster support disabled\")",
          "new_text": null,
          "old_line_content": "        addReplyError(c,\"This instance has cluster support disabled\");",
          "new_line_content": "    if (server.cluster_enabled == 0) {",
          "content_same": false
        },
        {
          "line": 3047,
          "old_api": "clusterSetMaster",
          "new_api": null,
          "old_text": "clusterSetMaster(target)",
          "new_text": null,
          "old_line_content": "        clusterSetMaster(target);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 5097,
          "old_api": "addReply",
          "new_api": null,
          "old_text": "addReply(c,shared.ok)",
          "new_text": null,
          "old_line_content": "    addReply(c,shared.ok);",
          "new_line_content": "    c->flags |= CLIENT_ASKING;",
          "content_same": false
        },
        {
          "line": 5103,
          "old_api": "addReply",
          "new_api": null,
          "old_text": "addReply(c,shared.ok)",
          "new_text": null,
          "old_line_content": "    addReply(c,shared.ok);",
          "new_line_content": " * with read-only commands to keys that are served by the slave's master. */",
          "content_same": false
        },
        {
          "line": 3086,
          "old_api": "clientsArePaused",
          "new_api": null,
          "old_text": "clientsArePaused()",
          "new_text": null,
          "old_line_content": "    if (server.cluster->mf_end && clientsArePaused()) {",
          "new_line_content": " * the PAUSED flag, so that the slave will set mf_master_offset when receiving",
          "content_same": false
        },
        {
          "line": 3088,
          "old_api": "clientsArePaused",
          "new_api": null,
          "old_text": "clientsArePaused()",
          "new_text": null,
          "old_line_content": "        clientsArePaused(); /* Just use the side effect of the function. */",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 3098,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "    if (server.cluster->mf_end && server.cluster->mf_end < mstime()) {",
          "new_line_content": "void resetManualFailover(void) {",
          "content_same": false
        },
        {
          "line": 3100,
          "old_api": "resetManualFailover",
          "new_api": null,
          "old_text": "resetManualFailover()",
          "new_text": null,
          "old_line_content": "        resetManualFailover();",
          "new_line_content": "        server.clients_pause_end_time = 0;",
          "content_same": false
        },
        {
          "line": 3116,
          "old_api": "replicationGetSlaveOffset",
          "new_api": null,
          "old_text": "replicationGetSlaveOffset()",
          "new_text": null,
          "old_line_content": "    if (server.cluster->mf_master_offset == replicationGetSlaveOffset()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3120,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n            \"All master replication stream processed, \"\n            \"manual failover can start.\")",
          "new_text": null,
          "old_line_content": "        serverLog(LL_WARNING,",
          "new_line_content": "    /* Return ASAP if no manual failover is in progress. */",
          "content_same": false
        },
        {
          "line": 5179,
          "old_api": "getKeysFromCommand",
          "new_api": null,
          "old_text": "getKeysFromCommand(mcmd,margv,margc,&numkeys)",
          "new_text": null,
          "old_line_content": "        keyindex = getKeysFromCommand(mcmd,margv,margc,&numkeys);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 5182,
          "old_api": "keyHashSlot",
          "new_api": null,
          "old_text": "keyHashSlot((char*)thiskey->ptr,\n                                       sdslen(thiskey->ptr))",
          "new_text": null,
          "old_line_content": "            int thisslot = keyHashSlot((char*)thiskey->ptr,",
          "new_line_content": "     * slot and the node associated. */",
          "content_same": false
        },
        {
          "line": 5183,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(thiskey->ptr)",
          "new_text": null,
          "old_line_content": "                                       sdslen(thiskey->ptr));",
          "new_line_content": "    for (i = 0; i < ms->count; i++) {",
          "content_same": false
        },
        {
          "line": 3138,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "    mstime_t min_pong = 0, now = mstime();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5197,
          "old_api": "getKeysFreeResult",
          "new_api": null,
          "old_text": "getKeysFreeResult(keyindex)",
          "new_text": null,
          "old_line_content": "                    getKeysFreeResult(keyindex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3155,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(prev_ip,curr_ip)",
          "new_text": null,
          "old_line_content": "        if (prev_ip && curr_ip && strcmp(prev_ip,curr_ip)) changed = 1;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3159,
          "old_api": "zstrdup",
          "new_api": null,
          "old_text": "zstrdup(prev_ip)",
          "new_text": null,
          "old_line_content": "            if (prev_ip) prev_ip = zstrdup(prev_ip);",
          "new_line_content": "     * The option can be set at runtime via CONFIG SET, so we periodically check",
          "content_same": false
        },
        {
          "line": 3162,
          "old_api": "strncpy",
          "new_api": null,
          "old_text": "strncpy(myself->ip,server.cluster_announce_ip,NET_IP_STR_LEN)",
          "new_text": null,
          "old_line_content": "                strncpy(myself->ip,server.cluster_announce_ip,NET_IP_STR_LEN);",
          "new_line_content": "        static char *prev_ip = NULL;",
          "content_same": false
        },
        {
          "line": 5218,
          "old_api": "equalStringObjects",
          "new_api": null,
          "old_text": "equalStringObjects(firstkey,thiskey)",
          "new_text": null,
          "old_line_content": "                if (!equalStringObjects(firstkey,thiskey)) {",
          "new_line_content": "                 * can safely serve the request, otherwise we return a TRYAGAIN",
          "content_same": false
        },
        {
          "line": 5221,
          "old_api": "getKeysFreeResult",
          "new_api": null,
          "old_text": "getKeysFreeResult(keyindex)",
          "new_text": null,
          "old_line_content": "                        getKeysFreeResult(keyindex);",
          "new_line_content": "                if (n == myself &&",
          "content_same": false
        },
        {
          "line": 3178,
          "old_api": "dictGetSafeIterator",
          "new_api": null,
          "old_text": "dictGetSafeIterator(server.cluster->nodes)",
          "new_text": null,
          "old_line_content": "    di = dictGetSafeIterator(server.cluster->nodes);",
          "new_line_content": "                myself->ip[0] = '\\0'; /* Force autodetection. */",
          "content_same": false
        },
        {
          "line": 3179,
          "old_api": "dictNext",
          "new_api": null,
          "old_text": "dictNext(di)",
          "new_text": null,
          "old_line_content": "    while((de = dictNext(di)) != NULL) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3180,
          "old_api": "dictGetVal",
          "new_api": null,
          "old_text": "dictGetVal(de)",
          "new_text": null,
          "old_line_content": "        clusterNode *node = dictGetVal(de);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3186,
          "old_api": "nodeInHandshake",
          "new_api": null,
          "old_text": "nodeInHandshake(node)",
          "new_text": null,
          "old_line_content": "        if (nodeInHandshake(node) && now - node->ctime > handshake_timeout) {",
          "new_line_content": "     * the value of 1 second. */",
          "content_same": false
        },
        {
          "line": 3187,
          "old_api": "clusterDelNode",
          "new_api": null,
          "old_text": "clusterDelNode(node)",
          "new_text": null,
          "old_line_content": "            clusterDelNode(node);",
          "new_line_content": "    handshake_timeout = server.cluster_node_timeout;",
          "content_same": false
        },
        {
          "line": 5235,
          "old_api": "lookupKeyRead",
          "new_api": null,
          "old_text": "lookupKeyRead(&server.db[0],thiskey)",
          "new_text": null,
          "old_line_content": "                lookupKeyRead(&server.db[0],thiskey) == NULL)",
          "new_line_content": "                        if (error_code)",
          "content_same": false
        },
        {
          "line": 5240,
          "old_api": "getKeysFreeResult",
          "new_api": null,
          "old_text": "getKeysFreeResult(keyindex)",
          "new_text": null,
          "old_line_content": "        getKeysFreeResult(keyindex);",
          "new_line_content": "                         * keys. */",
          "content_same": false
        },
        {
          "line": 3196,
          "old_api": "anetTcpNonBlockBindConnect",
          "new_api": null,
          "old_text": "anetTcpNonBlockBindConnect(server.neterr, node->ip,\n                node->cport, NET_FIRST_BIND_ADDR)",
          "new_text": null,
          "old_line_content": "            fd = anetTcpNonBlockBindConnect(server.neterr, node->ip,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3204,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "                if (node->ping_sent == 0) node->ping_sent = mstime();",
          "new_line_content": "        if (node->link == NULL) {",
          "content_same": false
        },
        {
          "line": 3205,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_DEBUG, \"Unable to connect to \"\n                    \"Cluster Node [%s]:%d -> %s\", node->ip,\n                    node->cport, server.neterr)",
          "new_text": null,
          "old_line_content": "                serverLog(LL_DEBUG, \"Unable to connect to \"",
          "new_line_content": "            int fd;",
          "content_same": false
        },
        {
          "line": 3210,
          "old_api": "createClusterLink",
          "new_api": null,
          "old_text": "createClusterLink(node)",
          "new_text": null,
          "old_line_content": "            link = createClusterLink(node);",
          "new_line_content": "                node->cport, NET_FIRST_BIND_ADDR);",
          "content_same": false
        },
        {
          "line": 3213,
          "old_api": "aeCreateFileEvent",
          "new_api": null,
          "old_text": "aeCreateFileEvent(server.el,link->fd,AE_READABLE,\n                    clusterReadHandler,link)",
          "new_text": null,
          "old_line_content": "            aeCreateFileEvent(server.el,link->fd,AE_READABLE,",
          "new_line_content": "                 * clusterSendPing() had a chance to be called.",
          "content_same": false
        },
        {
          "line": 3222,
          "old_api": "clusterSendPing",
          "new_api": null,
          "old_text": "clusterSendPing(link, node->flags & CLUSTER_NODE_MEET ?\n                    CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING)",
          "new_text": null,
          "old_line_content": "            clusterSendPing(link, node->flags & CLUSTER_NODE_MEET ?",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3237,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_DEBUG,\"Connecting with Node %.40s at %s:%d\",\n                    node->name, node->ip, node->cport)",
          "new_text": null,
          "old_line_content": "            serverLog(LL_DEBUG,\"Connecting with Node %.40s at %s:%d\",",
          "new_line_content": "            if (old_ping_sent) {",
          "content_same": false
        },
        {
          "line": 3241,
          "old_api": "dictReleaseIterator",
          "new_api": null,
          "old_text": "dictReleaseIterator(di)",
          "new_text": null,
          "old_line_content": "    dictReleaseIterator(di);",
          "new_line_content": "                node->ping_sent = old_ping_sent;",
          "content_same": false
        },
        {
          "line": 5289,
          "old_api": "nodeIsSlave",
          "new_api": null,
          "old_text": "nodeIsSlave(myself)",
          "new_text": null,
          "old_line_content": "        nodeIsSlave(myself) &&",
          "new_line_content": "        if (multiple_keys && missing_keys) {",
          "content_same": false
        },
        {
          "line": 3251,
          "old_api": "dictGetRandomKey",
          "new_api": null,
          "old_text": "dictGetRandomKey(server.cluster->nodes)",
          "new_text": null,
          "old_line_content": "            de = dictGetRandomKey(server.cluster->nodes);",
          "new_line_content": "                    node->name, node->ip, node->cport);",
          "content_same": false
        },
        {
          "line": 3252,
          "old_api": "dictGetVal",
          "new_api": null,
          "old_text": "dictGetVal(de)",
          "new_text": null,
          "old_line_content": "            clusterNode *this = dictGetVal(de);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 5310,
          "old_api": "sdsnew",
          "new_api": null,
          "old_text": "sdsnew(\"-CROSSSLOT Keys in request don't hash to the same slot\\r\\n\")",
          "new_text": null,
          "old_line_content": "        addReplySds(c,sdsnew(\"-CROSSSLOT Keys in request don't hash to the same slot\\r\\n\"));",
          "new_line_content": "    if (n != myself && error_code) *error_code = CLUSTER_REDIR_MOVED;",
          "content_same": false
        },
        {
          "line": 5315,
          "old_api": "sdsnew",
          "new_api": null,
          "old_text": "sdsnew(\"-TRYAGAIN Multiple keys request during rehashing of slot\\r\\n\")",
          "new_text": null,
          "old_line_content": "        addReplySds(c,sdsnew(\"-TRYAGAIN Multiple keys request during rehashing of slot\\r\\n\"));",
          "new_line_content": " * that should be set to one of CLUSTER_REDIR_* macros.",
          "content_same": false
        },
        {
          "line": 5317,
          "old_api": "sdsnew",
          "new_api": null,
          "old_text": "sdsnew(\"-CLUSTERDOWN The cluster is down\\r\\n\")",
          "new_text": null,
          "old_line_content": "        addReplySds(c,sdsnew(\"-CLUSTERDOWN The cluster is down\\r\\n\"));",
          "new_line_content": " * If CLUSTER_REDIR_ASK or CLUSTER_REDIR_MOVED error codes",
          "content_same": false
        },
        {
          "line": 5319,
          "old_api": "sdsnew",
          "new_api": null,
          "old_text": "sdsnew(\"-CLUSTERDOWN Hash slot not served\\r\\n\")",
          "new_text": null,
          "old_line_content": "        addReplySds(c,sdsnew(\"-CLUSTERDOWN Hash slot not served\\r\\n\"));",
          "new_line_content": " * node we want to mention in the redirection. Moreover hashslot should",
          "content_same": false
        },
        {
          "line": 3279,
          "old_api": "dictNext",
          "new_api": null,
          "old_text": "dictNext(di)",
          "new_text": null,
          "old_line_content": "    while((de = dictNext(di)) != NULL) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3280,
          "old_api": "dictGetVal",
          "new_api": null,
          "old_text": "dictGetVal(de)",
          "new_text": null,
          "old_line_content": "        clusterNode *node = dictGetVal(de);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3281,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "        now = mstime(); /* Use an updated time at every iteration. */",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3290,
          "old_api": "nodeFailed",
          "new_api": null,
          "old_text": "nodeFailed(node)",
          "new_text": null,
          "old_line_content": "        if (nodeIsSlave(myself) && nodeIsMaster(node) && !nodeFailed(node)) {",
          "new_line_content": "    this_slaves = 0;",
          "content_same": false
        },
        {
          "line": 3302,
          "old_api": "nodeIsSlave",
          "new_api": null,
          "old_text": "nodeIsSlave(myself)",
          "new_text": null,
          "old_line_content": "            if (nodeIsSlave(myself) && myself->slaveof == node)",
          "new_line_content": "         * is a slave that may migrate to another master. */",
          "content_same": false
        },
        {
          "line": 5350,
          "old_api": "clusterRedirectClient",
          "new_api": null,
          "old_text": "clusterRedirectClient(c,NULL,0,CLUSTER_REDIR_DOWN_STATE)",
          "new_text": null,
          "old_line_content": "            clusterRedirectClient(c,NULL,0,CLUSTER_REDIR_DOWN_STATE);",
          "new_line_content": " * 3) The client may remain blocked forever (or up to the max timeout time)",
          "content_same": false
        },
        {
          "line": 5354,
          "old_api": "dictGetIterator",
          "new_api": null,
          "old_text": "dictGetIterator(c->bpop.keys)",
          "new_text": null,
          "old_line_content": "        di = dictGetIterator(c->bpop.keys);",
          "new_line_content": " * longer handles, the client is sent a redirection error, and the function",
          "content_same": false
        },
        {
          "line": 5355,
          "old_api": "dictNext",
          "new_api": null,
          "old_text": "dictNext(di)",
          "new_text": null,
          "old_line_content": "        while((de = dictNext(di)) != NULL) {",
          "new_line_content": " * returns 1. Otherwise 0 is returned and no operation is performed. */",
          "content_same": false
        },
        {
          "line": 5356,
          "old_api": "dictGetKey",
          "new_api": null,
          "old_text": "dictGetKey(de)",
          "new_text": null,
          "old_line_content": "            robj *key = dictGetKey(de);",
          "new_line_content": "int clusterRedirectBlockedClientIfNeeded(client *c) {",
          "content_same": false
        },
        {
          "line": 5357,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(key->ptr)",
          "new_text": null,
          "old_line_content": "            int slot = keyHashSlot((char*)key->ptr, sdslen(key->ptr));",
          "new_line_content": "    if (c->flags & CLIENT_BLOCKED && c->btype == BLOCKED_LIST) {",
          "content_same": false
        },
        {
          "line": 3318,
          "old_api": "freeClusterLink",
          "new_api": null,
          "old_text": "freeClusterLink(node->link)",
          "new_text": null,
          "old_line_content": "            freeClusterLink(node->link);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5376,
          "old_api": "dictReleaseIterator",
          "new_api": null,
          "old_text": "dictReleaseIterator(di)",
          "new_text": null,
          "old_line_content": "        dictReleaseIterator(di);",
          "new_line_content": "            if (node != myself &&",
          "content_same": false
        },
        {
          "line": 3329,
          "old_api": "clusterSendPing",
          "new_api": null,
          "old_text": "clusterSendPing(node->link, CLUSTERMSG_TYPE_PING)",
          "new_text": null,
          "old_line_content": "            clusterSendPing(node->link, CLUSTERMSG_TYPE_PING);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3336,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(myself)",
          "new_text": null,
          "old_line_content": "            nodeIsMaster(myself) &&",
          "new_line_content": "         * a new ping now, to ensure all the nodes are pinged without",
          "content_same": false
        },
        {
          "line": 3340,
          "old_api": "clusterSendPing",
          "new_api": null,
          "old_text": "clusterSendPing(node->link, CLUSTERMSG_TYPE_PING)",
          "new_text": null,
          "old_line_content": "            clusterSendPing(node->link, CLUSTERMSG_TYPE_PING);",
          "new_line_content": "            (now - node->pong_received) > server.cluster_node_timeout/2)",
          "content_same": false
        },
        {
          "line": 3356,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_DEBUG,\"*** NODE %.40s possibly failing\",\n                    node->name)",
          "new_text": null,
          "old_line_content": "                serverLog(LL_DEBUG,\"*** NODE %.40s possibly failing\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3363,
          "old_api": "dictReleaseIterator",
          "new_api": null,
          "old_text": "dictReleaseIterator(di)",
          "new_text": null,
          "old_line_content": "    dictReleaseIterator(di);",
          "new_line_content": "        delay = now - node->ping_sent;",
          "content_same": false
        },
        {
          "line": 3368,
          "old_api": "nodeIsSlave",
          "new_api": null,
          "old_text": "nodeIsSlave(myself)",
          "new_text": null,
          "old_line_content": "    if (nodeIsSlave(myself) &&",
          "new_line_content": "            if (!(node->flags & (CLUSTER_NODE_PFAIL|CLUSTER_NODE_FAIL))) {",
          "content_same": false
        },
        {
          "line": 3371,
          "old_api": "nodeHasAddr",
          "new_api": null,
          "old_text": "nodeHasAddr(myself->slaveof)",
          "new_text": null,
          "old_line_content": "        nodeHasAddr(myself->slaveof))",
          "new_line_content": "                node->flags |= CLUSTER_NODE_PFAIL;",
          "content_same": false
        },
        {
          "line": 3373,
          "old_api": "replicationSetMaster",
          "new_api": null,
          "old_text": "replicationSetMaster(myself->slaveof->ip, myself->slaveof->port)",
          "new_text": null,
          "old_line_content": "        replicationSetMaster(myself->slaveof->ip, myself->slaveof->port);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3377,
          "old_api": "manualFailoverCheckTimeout",
          "new_api": null,
          "old_text": "manualFailoverCheckTimeout()",
          "new_text": null,
          "old_line_content": "    manualFailoverCheckTimeout();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3379,
          "old_api": "nodeIsSlave",
          "new_api": null,
          "old_text": "nodeIsSlave(myself)",
          "new_text": null,
          "old_line_content": "    if (nodeIsSlave(myself)) {",
          "new_line_content": "     * enable it if we know the address of our master and it appears to",
          "content_same": false
        },
        {
          "line": 3380,
          "old_api": "clusterHandleManualFailover",
          "new_api": null,
          "old_text": "clusterHandleManualFailover()",
          "new_text": null,
          "old_line_content": "        clusterHandleManualFailover();",
          "new_line_content": "     * be up. */",
          "content_same": false
        },
        {
          "line": 3388,
          "old_api": "clusterHandleSlaveMigration",
          "new_api": null,
          "old_text": "clusterHandleSlaveMigration(max_slaves)",
          "new_text": null,
          "old_line_content": "            clusterHandleSlaveMigration(max_slaves);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3404,
          "old_api": "clusterHandleSlaveFailover",
          "new_api": null,
          "old_text": "clusterHandleSlaveFailover()",
          "new_text": null,
          "old_line_content": "        clusterHandleSlaveFailover();",
          "new_line_content": "    if (update_state || server.cluster->state == CLUSTER_FAIL)",
          "content_same": false
        },
        {
          "line": 3408,
          "old_api": "clusterUpdateState",
          "new_api": null,
          "old_text": "clusterUpdateState()",
          "new_text": null,
          "old_line_content": "        clusterUpdateState();",
          "new_line_content": "/* This function is called before the event handler returns to sleep for",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": "ntohs",
          "new_api": null,
          "old_text": "ntohs(g->port)",
          "new_text": null,
          "old_line_content": "                 node->port != ntohs(g->port) ||",
          "new_line_content": "                if (pongtime > node->pong_received)",
          "content_same": false
        },
        {
          "line": 1367,
          "old_api": "ntohs",
          "new_api": null,
          "old_text": "ntohs(g->cport)",
          "new_text": null,
          "old_line_content": "                 node->cport != ntohs(g->cport)))",
          "new_line_content": "                    node->pong_received = pongtime;",
          "content_same": false
        },
        {
          "line": 3414,
          "old_api": "clusterSaveConfigOrDie",
          "new_api": null,
          "old_text": "clusterSaveConfigOrDie(fsync)",
          "new_text": null,
          "old_line_content": "        clusterSaveConfigOrDie(fsync);",
          "new_line_content": "    /* Handle failover, this is needed when it is likely that there is already",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": "freeClusterLink",
          "new_api": null,
          "old_text": "freeClusterLink(node->link)",
          "new_text": null,
          "old_line_content": "                if (node->link) freeClusterLink(node->link);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1370,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(node->ip,g->ip,NET_IP_STR_LEN)",
          "new_text": null,
          "old_line_content": "                memcpy(node->ip,g->ip,NET_IP_STR_LEN);",
          "new_line_content": "            /* If we already know this node, but it is not reachable, and",
          "content_same": false
        },
        {
          "line": 1371,
          "old_api": "ntohs",
          "new_api": null,
          "old_text": "ntohs(g->port)",
          "new_text": null,
          "old_line_content": "                node->port = ntohs(g->port);",
          "new_line_content": "             * we see a different address in the gossip section of a node that",
          "content_same": false
        },
        {
          "line": 1372,
          "old_api": "ntohs",
          "new_api": null,
          "old_text": "ntohs(g->cport)",
          "new_text": null,
          "old_line_content": "                node->cport = ntohs(g->cport);",
          "new_line_content": "             * can talk with this other node, update the address, disconnect",
          "content_same": false
        },
        {
          "line": 1386,
          "old_api": "ntohs",
          "new_api": null,
          "old_text": "ntohs(g->cport)",
          "new_text": null,
          "old_line_content": "                clusterStartHandshake(g->ip,ntohs(g->port),ntohs(g->cport));",
          "new_line_content": "                node->flags &= ~CLUSTER_NODE_NOADDR;",
          "content_same": false
        },
        {
          "line": 1400,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(buf,announced_ip,NET_IP_STR_LEN)",
          "new_text": null,
          "old_line_content": "        memcpy(buf,announced_ip,NET_IP_STR_LEN);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1403,
          "old_api": "anetPeerToString",
          "new_api": null,
          "old_text": "anetPeerToString(link->fd, buf, NET_IP_STR_LEN, NULL)",
          "new_text": null,
          "old_line_content": "        anetPeerToString(link->fd, buf, NET_IP_STR_LEN, NULL);",
          "new_line_content": "        /* Next node */",
          "content_same": false
        },
        {
          "line": 3456,
          "old_api": "dictGetSafeIterator",
          "new_api": null,
          "old_text": "dictGetSafeIterator(server.cluster->nodes)",
          "new_text": null,
          "old_line_content": "    dictIterator *di = dictGetSafeIterator(server.cluster->nodes);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3459,
          "old_api": "dictNext",
          "new_api": null,
          "old_text": "dictNext(di)",
          "new_text": null,
          "old_line_content": "    while((de = dictNext(di)) != NULL) {",
          "new_line_content": "void bitmapClearBit(unsigned char *bitmap, int pos) {",
          "content_same": false
        },
        {
          "line": 3460,
          "old_api": "dictGetVal",
          "new_api": null,
          "old_text": "dictGetVal(de)",
          "new_text": null,
          "old_line_content": "        clusterNode *node = dictGetVal(de);",
          "new_line_content": "    off_t byte = pos/8;",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": "nodeIsSlave",
          "new_api": null,
          "old_text": "nodeIsSlave(node)",
          "new_text": null,
          "old_line_content": "        if (nodeIsSlave(node)) continue;",
          "new_line_content": "    bitmap[byte] &= ~(1<<bit);",
          "content_same": false
        },
        {
          "line": 3465,
          "old_api": "dictReleaseIterator",
          "new_api": null,
          "old_text": "dictReleaseIterator(di)",
          "new_text": null,
          "old_line_content": "    dictReleaseIterator(di);",
          "new_line_content": "/* Return non-zero if there is at least one master with slaves in the cluster.",
          "content_same": false
        },
        {
          "line": 1423,
          "old_api": "ntohs",
          "new_api": null,
          "old_text": "ntohs(hdr->port)",
          "new_text": null,
          "old_line_content": "    int port = ntohs(hdr->port);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 1424,
          "old_api": "ntohs",
          "new_api": null,
          "old_text": "ntohs(hdr->cport)",
          "new_text": null,
          "old_line_content": "    int cport = ntohs(hdr->cport);",
          "new_line_content": " * If the address or port changed, disconnect the node link so that we'll",
          "content_same": false
        },
        {
          "line": 3471,
          "old_api": "bitmapTestBit",
          "new_api": null,
          "old_text": "bitmapTestBit(n->slots,slot)",
          "new_text": null,
          "old_line_content": "    int old = bitmapTestBit(n->slots,slot);",
          "new_line_content": "    int slaves = 0;",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": "nodeIp2String",
          "new_api": null,
          "old_text": "nodeIp2String(ip,link,hdr->myip)",
          "new_text": null,
          "old_line_content": "    nodeIp2String(ip,link,hdr->myip);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1439,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(node->ip,ip,sizeof(ip))",
          "new_text": null,
          "old_line_content": "    memcpy(node->ip,ip,sizeof(ip));",
          "new_line_content": "    /* We don't proceed if the link is the same as the sender link, as this",
          "content_same": false
        },
        {
          "line": 3488,
          "old_api": "clusterMastersHaveSlaves",
          "new_api": null,
          "old_text": "clusterMastersHaveSlaves()",
          "new_text": null,
          "old_line_content": "        if (n->numslots == 1 && clusterMastersHaveSlaves())",
          "new_line_content": "        /* When a master gets its first slot, even if it has no slaves,",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": "freeClusterLink",
          "new_api": null,
          "old_text": "freeClusterLink(node->link)",
          "new_text": null,
          "old_line_content": "    if (node->link) freeClusterLink(node->link);",
          "new_line_content": "     *",
          "content_same": false
        },
        {
          "line": 1444,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\"Address updated for node %.40s, now %s:%d\",\n        node->name, node->ip, node->port)",
          "new_text": null,
          "old_line_content": "    serverLog(LL_WARNING,\"Address updated for node %.40s, now %s:%d\",",
          "new_line_content": "     * it is safe to call during packet processing. */",
          "content_same": false
        },
        {
          "line": 3496,
          "old_api": "bitmapTestBit",
          "new_api": null,
          "old_text": "bitmapTestBit(n->slots,slot)",
          "new_text": null,
          "old_line_content": "    int old = bitmapTestBit(n->slots,slot);",
          "new_line_content": "         *",
          "content_same": false
        },
        {
          "line": 3497,
          "old_api": "bitmapClearBit",
          "new_api": null,
          "old_text": "bitmapClearBit(n->slots,slot)",
          "new_text": null,
          "old_line_content": "    bitmapClearBit(n->slots,slot);",
          "new_line_content": "         * However new masters with slots assigned are considered valid",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": "replicationSetMaster",
          "new_api": null,
          "old_text": "replicationSetMaster(node->ip, node->port)",
          "new_text": null,
          "old_line_content": "        replicationSetMaster(node->ip, node->port);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3504,
          "old_api": "bitmapTestBit",
          "new_api": null,
          "old_text": "bitmapTestBit(n->slots,slot)",
          "new_text": null,
          "old_line_content": "    return bitmapTestBit(n->slots,slot);",
          "new_line_content": "    return old;",
          "content_same": false
        },
        {
          "line": 1458,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(n)",
          "new_text": null,
          "old_line_content": "    if (nodeIsMaster(n)) return;",
          "new_line_content": "        node->name, node->ip, node->port);",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": "clusterNodeRemoveSlave",
          "new_api": null,
          "old_text": "clusterNodeRemoveSlave(n->slaveof,n)",
          "new_text": null,
          "old_line_content": "        clusterNodeRemoveSlave(n->slaveof,n);",
          "new_line_content": "     * replication target as well. */",
          "content_same": false
        },
        {
          "line": 3513,
          "old_api": "clusterNodeSetSlotBit",
          "new_api": null,
          "old_text": "clusterNodeSetSlotBit(n,slot)",
          "new_text": null,
          "old_line_content": "    clusterNodeSetSlotBit(n,slot);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1469,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                         CLUSTER_TODO_UPDATE_STATE)",
          "new_text": null,
          "old_line_content": "    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "new_line_content": " * update the state of the node. */",
          "content_same": false
        },
        {
          "line": 3525,
          "old_api": "clusterNodeClearSlotBit",
          "new_api": null,
          "old_text": "clusterNodeClearSlotBit(n,slot)",
          "new_text": null,
          "old_line_content": "    serverAssert(clusterNodeClearSlotBit(n,slot) == 1);",
          "new_line_content": "    if (server.cluster->slots[slot]) return C_ERR;",
          "content_same": false
        },
        {
          "line": 3536,
          "old_api": "clusterDelSlot",
          "new_api": null,
          "old_text": "clusterDelSlot(j)",
          "new_text": null,
          "old_line_content": "        if (clusterNodeGetSlotBit(node,j)) clusterDelSlot(j);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3545,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(server.cluster->migrating_slots_to,0,\n        sizeof(server.cluster->migrating_slots_to))",
          "new_text": null,
          "old_line_content": "    memset(server.cluster->migrating_slots_to,0,",
          "new_line_content": "int clusterDelNodeSlots(clusterNode *node) {",
          "content_same": false
        },
        {
          "line": 3547,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(server.cluster->importing_slots_from,0,\n        sizeof(server.cluster->importing_slots_from))",
          "new_text": null,
          "old_line_content": "    memset(server.cluster->importing_slots_from,0,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(myself)",
          "new_text": null,
          "old_line_content": "    curmaster = nodeIsMaster(myself) ? myself : myself->slaveof;",
          "new_line_content": "    /* The dirty slots list is a list of slots for which we lose the ownership",
          "content_same": false
        },
        {
          "line": 1503,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\"Discarding UPDATE message about myself.\")",
          "new_text": null,
          "old_line_content": "        serverLog(LL_WARNING,\"Discarding UPDATE message about myself.\");",
          "new_line_content": "     *",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": "bitmapTestBit",
          "new_api": null,
          "old_text": "bitmapTestBit(slots,j)",
          "new_text": null,
          "old_line_content": "        if (bitmapTestBit(slots,j)) {",
          "new_line_content": "    int dirty_slots_count = 0;",
          "content_same": false
        },
        {
          "line": 1528,
          "old_api": "countKeysInSlot",
          "new_api": null,
          "old_text": "countKeysInSlot(j)",
          "new_text": null,
          "old_line_content": "                    countKeysInSlot(j) &&",
          "new_line_content": "             * a new config. We still want the slot to be closed manually). */",
          "content_same": false
        },
        {
          "line": 3577,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "    if (first_call_time == 0) first_call_time = mstime();",
          "new_line_content": "    int j, new_state;",
          "content_same": false
        },
        {
          "line": 3578,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(myself)",
          "new_text": null,
          "old_line_content": "    if (nodeIsMaster(myself) &&",
          "new_line_content": "    int reachable_masters = 0;",
          "content_same": false
        },
        {
          "line": 3580,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "        mstime() - first_call_time < CLUSTER_WRITABLE_DELAY) return;",
          "new_line_content": "    static mstime_t first_call_time = 0;",
          "content_same": false
        },
        {
          "line": 1537,
          "old_api": "clusterDelSlot",
          "new_api": null,
          "old_text": "clusterDelSlot(j)",
          "new_text": null,
          "old_line_content": "                clusterDelSlot(j);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1538,
          "old_api": "clusterAddSlot",
          "new_api": null,
          "old_text": "clusterAddSlot(sender,j)",
          "new_text": null,
          "old_line_content": "                clusterAddSlot(sender,j);",
          "new_line_content": "                /* Was this slot mine, and still contains keys? Mark it as",
          "content_same": false
        },
        {
          "line": 1539,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                                     CLUSTER_TODO_UPDATE_STATE|\n                                     CLUSTER_TODO_FSYNC_CONFIG)",
          "new_text": null,
          "old_line_content": "                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "new_line_content": "                 * a dirty slot. */",
          "content_same": false
        },
        {
          "line": 1554,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n            \"Configuration change detected. Reconfiguring myself \"\n            \"as a replica of %.40s\", sender->name)",
          "new_text": null,
          "old_line_content": "        serverLog(LL_WARNING,",
          "new_line_content": "                                     CLUSTER_TODO_FSYNC_CONFIG);",
          "content_same": false
        },
        {
          "line": 1557,
          "old_api": "clusterSetMaster",
          "new_api": null,
          "old_text": "clusterSetMaster(sender)",
          "new_text": null,
          "old_line_content": "        clusterSetMaster(sender);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1558,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                             CLUSTER_TODO_UPDATE_STATE|\n                             CLUSTER_TODO_FSYNC_CONFIG)",
          "new_text": null,
          "old_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3608,
          "old_api": "dictGetSafeIterator",
          "new_api": null,
          "old_text": "dictGetSafeIterator(server.cluster->nodes)",
          "new_text": null,
          "old_line_content": "        di = dictGetSafeIterator(server.cluster->nodes);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3609,
          "old_api": "dictNext",
          "new_api": null,
          "old_text": "dictNext(di)",
          "new_text": null,
          "old_line_content": "        while((de = dictNext(di)) != NULL) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3610,
          "old_api": "dictGetVal",
          "new_api": null,
          "old_text": "dictGetVal(de)",
          "new_text": null,
          "old_line_content": "            clusterNode *node = dictGetVal(de);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3612,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(node)",
          "new_text": null,
          "old_line_content": "            if (nodeIsMaster(node) && node->numslots) {",
          "new_line_content": "     * serving at least a single slot.",
          "content_same": false
        },
        {
          "line": 3618,
          "old_api": "dictReleaseIterator",
          "new_api": null,
          "old_text": "dictReleaseIterator(di)",
          "new_text": null,
          "old_line_content": "        dictReleaseIterator(di);",
          "new_line_content": "        dictEntry *de;",
          "content_same": false
        },
        {
          "line": 3628,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "            among_minority_time = mstime();",
          "new_line_content": "                    reachable_masters++;",
          "content_same": false
        },
        {
          "line": 1585,
          "old_api": "ntohl",
          "new_api": null,
          "old_text": "ntohl(hdr->totlen)",
          "new_text": null,
          "old_line_content": "    uint32_t totlen = ntohl(hdr->totlen);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1586,
          "old_api": "ntohs",
          "new_api": null,
          "old_text": "ntohs(hdr->type)",
          "new_text": null,
          "old_line_content": "    uint16_t type = ntohs(hdr->type);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1590,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_DEBUG,\"--- Processing packet of type %d, %lu bytes\",\n        type, (unsigned long) totlen)",
          "new_text": null,
          "old_line_content": "    serverLog(LL_DEBUG,\"--- Processing packet of type %d, %lu bytes\",",
          "new_line_content": " * packet, modifying the cluster state if needed.",
          "content_same": false
        },
        {
          "line": 1595,
          "old_api": "sdslen",
          "new_api": null,
          "old_text": "sdslen(link->rcvbuf)",
          "new_text": null,
          "old_line_content": "    if (totlen > sdslen(link->rcvbuf)) return 1;",
          "new_line_content": " * received from the wrong sender ID). */",
          "content_same": false
        },
        {
          "line": 1597,
          "old_api": "ntohs",
          "new_api": null,
          "old_text": "ntohs(hdr->ver)",
          "new_text": null,
          "old_line_content": "    if (ntohs(hdr->ver) != CLUSTER_PROTO_VER) {",
          "new_line_content": "    clusterMsg *hdr = (clusterMsg*) link->rcvbuf;",
          "content_same": false
        },
        {
          "line": 3646,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(myself)",
          "new_text": null,
          "old_line_content": "            nodeIsMaster(myself) &&",
          "new_line_content": "    if (new_state != server.cluster->state) {",
          "content_same": false
        },
        {
          "line": 3647,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "            mstime() - among_minority_time < rejoin_delay)",
          "new_line_content": "        mstime_t rejoin_delay = server.cluster_node_timeout;",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": "ntohs",
          "new_api": null,
          "old_text": "ntohs(hdr->flags)",
          "new_text": null,
          "old_line_content": "    uint16_t flags = ntohs(hdr->flags);",
          "new_line_content": "        server.cluster->stats_bus_messages_received[type]++;",
          "content_same": false
        },
        {
          "line": 3653,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\"Cluster state changed: %s\",\n            new_state == CLUSTER_OK ? \"ok\" : \"fail\")",
          "new_text": null,
          "old_line_content": "        serverLog(LL_WARNING,\"Cluster state changed: %s\",",
          "new_line_content": "        if (rejoin_delay > CLUSTER_MAX_REJOIN_DELAY)",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": "ntohs",
          "new_api": null,
          "old_text": "ntohs(hdr->count)",
          "new_text": null,
          "old_line_content": "        uint16_t count = ntohs(hdr->count);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": "ntohl",
          "new_api": null,
          "old_text": "ntohl(hdr->data.publish.msg.channel_len)",
          "new_text": null,
          "old_line_content": "                ntohl(hdr->data.publish.msg.channel_len) +",
          "new_line_content": "        explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);",
          "content_same": false
        },
        {
          "line": 1626,
          "old_api": "ntohl",
          "new_api": null,
          "old_text": "ntohl(hdr->data.publish.msg.message_len)",
          "new_text": null,
          "old_line_content": "                ntohl(hdr->data.publish.msg.message_len);",
          "new_line_content": "        explen += (sizeof(clusterMsgDataGossip)*count);",
          "content_same": false
        },
        {
          "line": 3687,
          "old_api": "nodeIsSlave",
          "new_api": null,
          "old_text": "nodeIsSlave(myself)",
          "new_text": null,
          "old_line_content": "    if (nodeIsSlave(myself)) return C_OK;",
          "new_line_content": " * The function always returns C_OK even if it will try to correct",
          "content_same": false
        },
        {
          "line": 1643,
          "old_api": "clusterLookupNode",
          "new_api": null,
          "old_text": "clusterLookupNode(hdr->sender)",
          "new_text": null,
          "old_line_content": "    sender = clusterLookupNode(hdr->sender);",
          "new_line_content": "               type == CLUSTERMSG_TYPE_MFSTART)",
          "content_same": false
        },
        {
          "line": 1644,
          "old_api": "nodeInHandshake",
          "new_api": null,
          "old_text": "nodeInHandshake(sender)",
          "new_text": null,
          "old_line_content": "    if (sender && !nodeInHandshake(sender)) {",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3691,
          "old_api": "dictSize",
          "new_api": null,
          "old_text": "dictSize(server.db[j].dict)",
          "new_text": null,
          "old_line_content": "        if (dictSize(server.db[j].dict)) return C_ERR;",
          "new_line_content": " * The function also uses the logging facility in order to warn the user",
          "content_same": false
        },
        {
          "line": 1646,
          "old_api": "ntohu64",
          "new_api": null,
          "old_text": "ntohu64(hdr->currentEpoch)",
          "new_text": null,
          "old_line_content": "        senderCurrentEpoch = ntohu64(hdr->currentEpoch);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1647,
          "old_api": "ntohu64",
          "new_api": null,
          "old_text": "ntohu64(hdr->configEpoch)",
          "new_text": null,
          "old_line_content": "        senderConfigEpoch = ntohu64(hdr->configEpoch);",
          "new_line_content": "        if (totlen != explen) return 1;",
          "content_same": false
        },
        {
          "line": 3697,
          "old_api": "countKeysInSlot",
          "new_api": null,
          "old_text": "countKeysInSlot(j)",
          "new_text": null,
          "old_line_content": "        if (!countKeysInSlot(j)) continue; /* No keys in this slot. */",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                                 CLUSTER_TODO_FSYNC_CONFIG)",
          "new_text": null,
          "old_line_content": "            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "        sender->repl_offset_time = mstime();",
          "new_line_content": "        /* Update our curretEpoch if we see a newer epoch in the cluster. */",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": "nodeIsSlave",
          "new_api": null,
          "old_text": "nodeIsSlave(myself)",
          "new_text": null,
          "old_line_content": "            nodeIsSlave(myself) &&",
          "new_line_content": "            server.cluster->currentEpoch = senderCurrentEpoch;",
          "content_same": false
        },
        {
          "line": 3711,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING, \"I have keys for unassigned slot %d. \"\n                                    \"Taking responsibility for it.\",j)",
          "new_text": null,
          "old_line_content": "            serverLog(LL_WARNING, \"I have keys for unassigned slot %d. \"",
          "new_line_content": "        /* Check if we are assigned to this slot or if we are importing it.",
          "content_same": false
        },
        {
          "line": 3713,
          "old_api": "clusterAddSlot",
          "new_api": null,
          "old_text": "clusterAddSlot(myself,j)",
          "new_text": null,
          "old_line_content": "            clusterAddSlot(myself,j);",
          "new_line_content": "         * sense. */",
          "content_same": false
        },
        {
          "line": 3715,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING, \"I have keys for slot %d, but the slot is \"\n                                    \"assigned to another node. \"\n                                    \"Setting it to importing state.\",j)",
          "new_text": null,
          "old_line_content": "            serverLog(LL_WARNING, \"I have keys for slot %d, but the slot is \"",
          "new_line_content": "            server.cluster->importing_slots_from[j] != NULL) continue;",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\n                \"Received replication offset for paused \"\n                \"master manual failover: %lld\",\n                server.cluster->mf_master_offset)",
          "new_text": null,
          "old_line_content": "            serverLog(LL_WARNING,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3721,
          "old_api": "clusterSaveConfigOrDie",
          "new_api": null,
          "old_text": "clusterSaveConfigOrDie(1)",
          "new_text": null,
          "old_line_content": "    if (update_config) clusterSaveConfigOrDie(1);",
          "new_line_content": "        update_config++;",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_DEBUG,\"Ping packet received: %p\", (void*)link->node)",
          "new_text": null,
          "old_line_content": "        serverLog(LL_DEBUG,\"Ping packet received: %p\", (void*)link->node);",
          "new_line_content": "            hdr->mflags[0] & CLUSTERMSG_FLAG0_PAUSED &&",
          "content_same": false
        },
        {
          "line": 3732,
          "old_api": "serverAssert",
          "new_api": null,
          "old_text": "serverAssert(n != myself)",
          "new_text": null,
          "old_line_content": "    serverAssert(n != myself);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3733,
          "old_api": "serverAssert",
          "new_api": null,
          "old_text": "serverAssert(myself->numslots == 0)",
          "new_text": null,
          "old_line_content": "    serverAssert(myself->numslots == 0);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3735,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(myself)",
          "new_text": null,
          "old_line_content": "    if (nodeIsMaster(myself)) {",
          "new_line_content": "    return C_OK;",
          "content_same": false
        },
        {
          "line": 3738,
          "old_api": "clusterCloseAllSlots",
          "new_api": null,
          "old_text": "clusterCloseAllSlots()",
          "new_text": null,
          "old_line_content": "        clusterCloseAllSlots();",
          "new_line_content": "/* -----------------------------------------------------------------------------",
          "content_same": false
        },
        {
          "line": 3741,
          "old_api": "clusterNodeRemoveSlave",
          "new_api": null,
          "old_text": "clusterNodeRemoveSlave(myself->slaveof,myself)",
          "new_text": null,
          "old_line_content": "            clusterNodeRemoveSlave(myself->slaveof,myself);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1695,
          "old_api": "anetSockName",
          "new_api": null,
          "old_text": "anetSockName(link->fd,ip,sizeof(ip),NULL)",
          "new_text": null,
          "old_line_content": "            if (anetSockName(link->fd,ip,sizeof(ip),NULL) != -1 &&",
          "new_line_content": "         * later if we changed address, and those nodes will use our",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(ip,myself->ip)",
          "new_text": null,
          "old_line_content": "                strcmp(ip,myself->ip))",
          "new_line_content": "         * official address to connect to us. So by obtaining this address",
          "content_same": false
        },
        {
          "line": 3744,
          "old_api": "clusterNodeAddSlave",
          "new_api": null,
          "old_text": "clusterNodeAddSlave(n,myself)",
          "new_text": null,
          "old_line_content": "    clusterNodeAddSlave(n,myself);",
          "new_line_content": "void clusterSetMaster(clusterNode *n) {",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(myself->ip,ip,NET_IP_STR_LEN)",
          "new_text": null,
          "old_line_content": "                memcpy(myself->ip,ip,NET_IP_STR_LEN);",
          "new_line_content": "         * address in the cluster without it being hardcoded in the config.",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\"IP address for this node updated to %s\",\n                    myself->ip)",
          "new_text": null,
          "old_line_content": "                serverLog(LL_WARNING,\"IP address for this node updated to %s\",",
          "new_line_content": "         *",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG)",
          "new_text": null,
          "old_line_content": "                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);",
          "new_line_content": "         * even with a normal PING packet. If it's wrong it will be fixed",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": "nodeIp2String",
          "new_api": null,
          "old_text": "nodeIp2String(node->ip,link,hdr->myip)",
          "new_text": null,
          "old_line_content": "            nodeIp2String(node->ip,link,hdr->myip);",
          "new_line_content": "                    myself->ip);",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": "ntohs",
          "new_api": null,
          "old_text": "ntohs(hdr->cport)",
          "new_text": null,
          "old_line_content": "            node->cport = ntohs(hdr->cport);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": "clusterAddNode",
          "new_api": null,
          "old_text": "clusterAddNode(node)",
          "new_text": null,
          "old_line_content": "            clusterAddNode(node);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1717,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG)",
          "new_text": null,
          "old_line_content": "            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": "clusterProcessGossipSection",
          "new_api": null,
          "old_text": "clusterProcessGossipSection(hdr,link)",
          "new_text": null,
          "old_line_content": "            clusterProcessGossipSection(hdr,link);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3772,
          "old_api": "sdscat",
          "new_api": null,
          "old_text": "sdscat(ci,\"noflags,\")",
          "new_text": null,
          "old_line_content": "        ci = sdscat(ci,\"noflags,\");",
          "new_line_content": "    {CLUSTER_NODE_MYSELF,       \"myself,\"},",
          "content_same": false
        },
        {
          "line": 3777,
          "old_api": "sdscat",
          "new_api": null,
          "old_text": "sdscat(ci, nodeflag->name)",
          "new_text": null,
          "old_line_content": "            if (flags & nodeflag->flag) ci = sdscat(ci, nodeflag->name);",
          "new_line_content": "    {CLUSTER_NODE_HANDSHAKE,    \"handshake,\"},",
          "content_same": false
        },
        {
          "line": 3780,
          "old_api": "sdsIncrLen",
          "new_api": null,
          "old_text": "sdsIncrLen(ci,-1)",
          "new_text": null,
          "old_line_content": "    sdsIncrLen(ci,-1); /* Remove trailing comma. */",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_DEBUG,\"%s packet received: %p\",\n            type == CLUSTERMSG_TYPE_PING ? \"ping\" : \"pong\",\n            (void*)link->node)",
          "new_text": null,
          "old_line_content": "        serverLog(LL_DEBUG,\"%s packet received: %p\",",
          "new_line_content": "         * the gossip section here since we have to trust the sender because",
          "content_same": false
        },
        {
          "line": 1738,
          "old_api": "nodeInHandshake",
          "new_api": null,
          "old_text": "nodeInHandshake(link->node)",
          "new_text": null,
          "old_line_content": "            if (nodeInHandshake(link->node)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1742,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_VERBOSE,\n                        \"Handshake: we already know node %.40s, \"\n                        \"updating the address if needed.\", sender->name)",
          "new_text": null,
          "old_line_content": "                    serverLog(LL_VERBOSE,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1745,
          "old_api": "nodeUpdateAddressIfNeeded",
          "new_api": null,
          "old_text": "nodeUpdateAddressIfNeeded(sender,link,hdr)",
          "new_text": null,
          "old_line_content": "                    if (nodeUpdateAddressIfNeeded(sender,link,hdr))",
          "new_line_content": "        type == CLUSTERMSG_TYPE_MEET)",
          "content_same": false
        },
        {
          "line": 1752,
          "old_api": "clusterDelNode",
          "new_api": null,
          "old_text": "clusterDelNode(link->node)",
          "new_text": null,
          "old_line_content": "                    clusterDelNode(link->node);",
          "new_line_content": "                /* If we already have this node, try to change the",
          "content_same": false
        },
        {
          "line": 3800,
          "old_api": "representClusterNodeFlags",
          "new_api": null,
          "old_text": "representClusterNodeFlags(ci, node->flags)",
          "new_text": null,
          "old_line_content": "    ci = representClusterNodeFlags(ci, node->flags);",
          "new_line_content": " * The function returns the string representation as an SDS string. */",
          "content_same": false
        },
        {
          "line": 3804,
          "old_api": "sdscatprintf",
          "new_api": null,
          "old_text": "sdscatprintf(ci,\" %.40s \",node->slaveof->name)",
          "new_text": null,
          "old_line_content": "        ci = sdscatprintf(ci,\" %.40s \",node->slaveof->name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1759,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_DEBUG,\"Handshake with node %.40s completed.\",\n                    link->node->name)",
          "new_text": null,
          "old_line_content": "                serverLog(LL_DEBUG,\"Handshake with node %.40s completed.\",",
          "new_line_content": "                    {",
          "content_same": false
        },
        {
          "line": 3809,
          "old_api": "sdscatprintf",
          "new_api": null,
          "old_text": "sdscatprintf(ci,\"%lld %lld %llu %s\",\n        (long long) node->ping_sent,\n        (long long) node->pong_received,\n        (unsigned long long) node->configEpoch,\n        (node->link || node->flags & CLUSTER_NODE_MYSELF) ?\n                    \"connected\" : \"disconnected\")",
          "new_text": null,
          "old_line_content": "    ci = sdscatprintf(ci,\"%lld %lld %llu %s\",",
          "new_line_content": "        node->port,",
          "content_same": false
        },
        {
          "line": 1763,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG)",
          "new_text": null,
          "old_line_content": "                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);",
          "new_line_content": "                    /* Free this node as we already have it. This will",
          "content_same": false
        },
        {
          "line": 1764,
          "old_api": "memcmp",
          "new_api": null,
          "old_text": "memcmp(link->node->name,hdr->sender,\n                        CLUSTER_NAMELEN)",
          "new_text": null,
          "old_line_content": "            } else if (memcmp(link->node->name,hdr->sender,",
          "new_line_content": "                     * cause the link to be freed as well. */",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_DEBUG,\"PONG contains mismatching sender ID. About node %.40s added %d ms ago, having flags %d\",\n                    link->node->name,\n                    (int)(mstime()-(link->node->ctime)),\n                    link->node->flags)",
          "new_text": null,
          "old_line_content": "                serverLog(LL_DEBUG,\"PONG contains mismatching sender ID. About node %.40s added %d ms ago, having flags %d\",",
          "new_line_content": "                 * right node name if this was a handshake stage. */",
          "content_same": false
        },
        {
          "line": 3821,
          "old_api": "clusterNodeGetSlotBit",
          "new_api": null,
          "old_text": "clusterNodeGetSlotBit(node,j)",
          "new_text": null,
          "old_line_content": "        if ((bit = clusterNodeGetSlotBit(node,j)) != 0) {",
          "new_line_content": "    /* Latency from the POV of this node, config epoch, link status */",
          "content_same": false
        },
        {
          "line": 1778,
          "old_api": "freeClusterLink",
          "new_api": null,
          "old_text": "freeClusterLink(link)",
          "new_text": null,
          "old_line_content": "                freeClusterLink(link);",
          "new_line_content": "                        CLUSTER_NAMELEN) != 0)",
          "content_same": false
        },
        {
          "line": 1779,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG)",
          "new_text": null,
          "old_line_content": "                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 3828,
          "old_api": "sdscatprintf",
          "new_api": null,
          "old_text": "sdscatprintf(ci,\" %d\",start)",
          "new_text": null,
          "old_line_content": "                ci = sdscatprintf(ci,\" %d\",start);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3830,
          "old_api": "sdscatprintf",
          "new_api": null,
          "old_text": "sdscatprintf(ci,\" %d-%d\",start,j-1)",
          "new_text": null,
          "old_line_content": "                ci = sdscatprintf(ci,\" %d-%d\",start,j-1);",
          "new_line_content": "    start = -1;",
          "content_same": false
        },
        {
          "line": 1786,
          "old_api": "nodeInHandshake",
          "new_api": null,
          "old_text": "nodeInHandshake(sender)",
          "new_text": null,
          "old_line_content": "            !nodeInHandshake(sender) &&",
          "new_line_content": "                    link->node->flags);",
          "content_same": false
        },
        {
          "line": 1787,
          "old_api": "nodeUpdateAddressIfNeeded",
          "new_api": null,
          "old_text": "nodeUpdateAddressIfNeeded(sender,link,hdr)",
          "new_text": null,
          "old_line_content": "            nodeUpdateAddressIfNeeded(sender,link,hdr))",
          "new_line_content": "                link->node->flags |= CLUSTER_NODE_NOADDR;",
          "content_same": false
        },
        {
          "line": 1789,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                                 CLUSTER_TODO_UPDATE_STATE)",
          "new_text": null,
          "old_line_content": "            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "new_line_content": "                link->node->port = 0;",
          "content_same": false
        },
        {
          "line": 3842,
          "old_api": "sdscatprintf",
          "new_api": null,
          "old_text": "sdscatprintf(ci,\" [%d->-%.40s]\",j,\n                    server.cluster->migrating_slots_to[j]->name)",
          "new_text": null,
          "old_line_content": "                ci = sdscatprintf(ci,\" [%d->-%.40s]\",j,",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 1795,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "            link->node->pong_received = mstime();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3845,
          "old_api": "sdscatprintf",
          "new_api": null,
          "old_text": "sdscatprintf(ci,\" [%d-<-%.40s]\",j,\n                    server.cluster->importing_slots_from[j]->name)",
          "new_text": null,
          "old_line_content": "                ci = sdscatprintf(ci,\" [%d-<-%.40s]\",j,",
          "new_line_content": "            start = -1;",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": "nodeTimedOut",
          "new_api": null,
          "old_text": "nodeTimedOut(link->node)",
          "new_text": null,
          "old_line_content": "            if (nodeTimedOut(link->node)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1806,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                                     CLUSTER_TODO_UPDATE_STATE)",
          "new_text": null,
          "old_line_content": "                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "new_line_content": "        /* Update our info about the node */",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": "clearNodeFailureIfNeeded",
          "new_api": null,
          "old_text": "clearNodeFailureIfNeeded(link->node)",
          "new_text": null,
          "old_line_content": "                clearNodeFailureIfNeeded(link->node);",
          "new_line_content": "            link->node->ping_sent = 0;",
          "content_same": false
        },
        {
          "line": 1815,
          "old_api": "memcmp",
          "new_api": null,
          "old_text": "memcmp(hdr->slaveof,CLUSTER_NODE_NULL_NAME,\n                sizeof(hdr->slaveof))",
          "new_text": null,
          "old_line_content": "            if (!memcmp(hdr->slaveof,CLUSTER_NODE_NULL_NAME,",
          "new_line_content": "             * The FAIL condition is also reversible under specific",
          "content_same": false
        },
        {
          "line": 3866,
          "old_api": "sdsempty",
          "new_api": null,
          "old_text": "sdsempty()",
          "new_text": null,
          "old_line_content": "    sds ci = sdsempty(), ni;",
          "new_line_content": "/* Generate a csv-alike representation of the nodes we are aware of,",
          "content_same": false
        },
        {
          "line": 3870,
          "old_api": "dictGetSafeIterator",
          "new_api": null,
          "old_text": "dictGetSafeIterator(server.cluster->nodes)",
          "new_text": null,
          "old_line_content": "    di = dictGetSafeIterator(server.cluster->nodes);",
          "new_line_content": " * All the nodes matching at least one of the node flags specified in",
          "content_same": false
        },
        {
          "line": 3871,
          "old_api": "dictNext",
          "new_api": null,
          "old_text": "dictNext(di)",
          "new_text": null,
          "old_line_content": "    while((de = dictNext(di)) != NULL) {",
          "new_line_content": " * \"filter\" are excluded from the output, so using zero as a filter will",
          "content_same": false
        },
        {
          "line": 1824,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(sender)",
          "new_text": null,
          "old_line_content": "                if (nodeIsMaster(sender)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3872,
          "old_api": "dictGetVal",
          "new_api": null,
          "old_text": "dictGetVal(de)",
          "new_text": null,
          "old_line_content": "        clusterNode *node = dictGetVal(de);",
          "new_line_content": " * include all the known nodes in the representation, including nodes in",
          "content_same": false
        },
        {
          "line": 1826,
          "old_api": "clusterDelNodeSlots",
          "new_api": null,
          "old_text": "clusterDelNodeSlots(sender)",
          "new_text": null,
          "old_line_content": "                    clusterDelNodeSlots(sender);",
          "new_line_content": "        /* Check for role switch: slave -> master or master -> slave. */",
          "content_same": false
        },
        {
          "line": 3875,
          "old_api": "clusterGenNodeDescription",
          "new_api": null,
          "old_text": "clusterGenNodeDescription(node)",
          "new_text": null,
          "old_line_content": "        ni = clusterGenNodeDescription(node);",
          "new_line_content": " * The representation obtained using this function is used for the output",
          "content_same": false
        },
        {
          "line": 3876,
          "old_api": "sdscatsds",
          "new_api": null,
          "old_text": "sdscatsds(ci,ni)",
          "new_text": null,
          "old_line_content": "        ci = sdscatsds(ci,ni);",
          "new_line_content": " * of the CLUSTER NODES function, and as format for the cluster",
          "content_same": false
        },
        {
          "line": 3877,
          "old_api": "sdsfree",
          "new_api": null,
          "old_text": "sdsfree(ni)",
          "new_text": null,
          "old_line_content": "        sdsfree(ni);",
          "new_line_content": " * configuration file (nodes.conf) for a given node. */",
          "content_same": false
        },
        {
          "line": 3878,
          "old_api": "sdscatlen",
          "new_api": null,
          "old_text": "sdscatlen(ci,\"\\n\",1)",
          "new_text": null,
          "old_line_content": "        ci = sdscatlen(ci,\"\\n\",1);",
          "new_line_content": "sds clusterGenNodesDescription(int filter) {",
          "content_same": false
        },
        {
          "line": 3880,
          "old_api": "dictReleaseIterator",
          "new_api": null,
          "old_text": "dictReleaseIterator(di)",
          "new_text": null,
          "old_line_content": "    dictReleaseIterator(di);",
          "new_line_content": "    dictIterator *di;",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": "clusterNodeAddSlave",
          "new_api": null,
          "old_text": "clusterNodeAddSlave(master,sender)",
          "new_text": null,
          "old_line_content": "                    clusterNodeAddSlave(master,sender);",
          "new_line_content": "                    sender->flags &= ~(CLUSTER_NODE_MASTER|",
          "content_same": false
        },
        {
          "line": 1844,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG)",
          "new_text": null,
          "old_line_content": "                    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);",
          "new_line_content": "                    /* Update config and state. */",
          "content_same": false
        },
        {
          "line": 3906,
          "old_api": "getLongLongFromObject",
          "new_api": null,
          "old_text": "getLongLongFromObject(o,&slot)",
          "new_text": null,
          "old_line_content": "    if (getLongLongFromObject(o,&slot) != C_OK ||",
          "new_line_content": "    case CLUSTERMSG_TYPE_FAIL: return \"fail\";",
          "content_same": false
        },
        {
          "line": 3909,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"Invalid or out of range slot\")",
          "new_text": null,
          "old_line_content": "        addReplyError(c,\"Invalid or out of range slot\");",
          "new_line_content": "    case CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK: return \"auth-ack\";",
          "content_same": false
        },
        {
          "line": 1862,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(sender)",
          "new_text": null,
          "old_line_content": "            sender_master = nodeIsMaster(sender) ? sender : sender->slaveof;",
          "new_line_content": "        /* Update our info about served slots.",
          "content_same": false
        },
        {
          "line": 1864,
          "old_api": "memcmp",
          "new_api": null,
          "old_text": "memcmp(sender_master->slots,\n                        hdr->myslots,sizeof(hdr->myslots))",
          "new_text": null,
          "old_line_content": "                dirty_slots = memcmp(sender_master->slots,",
          "new_line_content": "         * Note: this MUST happen after we update the master/slave state",
          "content_same": false
        },
        {
          "line": 1872,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(sender)",
          "new_text": null,
          "old_line_content": "        if (sender && nodeIsMaster(sender) && dirty_slots)",
          "new_line_content": "        int dirty_slots = 0; /* Sender claimed slots don't match my view? */",
          "content_same": false
        },
        {
          "line": 1873,
          "old_api": "clusterUpdateSlotsConfigWith",
          "new_api": null,
          "old_text": "clusterUpdateSlotsConfigWith(sender,senderConfigEpoch,hdr->myslots)",
          "new_text": null,
          "old_line_content": "            clusterUpdateSlotsConfigWith(sender,senderConfigEpoch,hdr->myslots);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3928,
          "old_api": "addDeferredMultiBulkLength",
          "new_api": null,
          "old_text": "addDeferredMultiBulkLength(c)",
          "new_text": null,
          "old_line_content": "    void *slot_replylen = addDeferredMultiBulkLength(c);",
          "new_line_content": "void clusterReplyMultiBulkSlots(client *c) {",
          "content_same": false
        },
        {
          "line": 3931,
          "old_api": "dictGetSafeIterator",
          "new_api": null,
          "old_text": "dictGetSafeIterator(server.cluster->nodes)",
          "new_text": null,
          "old_line_content": "    dictIterator *di = dictGetSafeIterator(server.cluster->nodes);",
          "new_line_content": "     *            3) 1) master IP",
          "content_same": false
        },
        {
          "line": 3932,
          "old_api": "dictNext",
          "new_api": null,
          "old_text": "dictNext(di)",
          "new_text": null,
          "old_line_content": "    while((de = dictNext(di)) != NULL) {",
          "new_line_content": "     *               2) master port",
          "content_same": false
        },
        {
          "line": 3933,
          "old_api": "dictGetVal",
          "new_api": null,
          "old_text": "dictGetVal(de)",
          "new_text": null,
          "old_line_content": "        clusterNode *node = dictGetVal(de);",
          "new_line_content": "     *               3) node ID",
          "content_same": false
        },
        {
          "line": 3938,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(node)",
          "new_text": null,
          "old_line_content": "        if (!nodeIsMaster(node) || node->numslots == 0) continue;",
          "new_line_content": "     */",
          "content_same": false
        },
        {
          "line": 3943,
          "old_api": "clusterNodeGetSlotBit",
          "new_api": null,
          "old_text": "clusterNodeGetSlotBit(node,j)",
          "new_text": null,
          "old_line_content": "            if ((bit = clusterNodeGetSlotBit(node,j)) != 0) {",
          "new_line_content": "    dictEntry *de;",
          "content_same": false
        },
        {
          "line": 1897,
          "old_api": "bitmapTestBit",
          "new_api": null,
          "old_text": "bitmapTestBit(hdr->myslots,j)",
          "new_text": null,
          "old_line_content": "                if (bitmapTestBit(hdr->myslots,j)) {",
          "new_line_content": "         * A and B are master and slave for slots 1,2,3.",
          "content_same": false
        },
        {
          "line": 3948,
          "old_api": "addDeferredMultiBulkLength",
          "new_api": null,
          "old_text": "addDeferredMultiBulkLength(c)",
          "new_text": null,
          "old_line_content": "                void *nested_replylen = addDeferredMultiBulkLength(c);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1903,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_VERBOSE,\n                            \"Node %.40s has old slots configuration, sending \"\n                            \"an UPDATE message about %.40s\",\n                                sender->name, server.cluster->slots[j]->name)",
          "new_text": null,
          "old_line_content": "                        serverLog(LL_VERBOSE,",
          "new_line_content": "         * new configuration, so other nodes that have an updated table must",
          "content_same": false
        },
        {
          "line": 1907,
          "old_api": "clusterSendUpdate",
          "new_api": null,
          "old_text": "clusterSendUpdate(sender->link,\n                            server.cluster->slots[j])",
          "new_text": null,
          "old_line_content": "                        clusterSendUpdate(sender->link,",
          "new_line_content": "            int j;",
          "content_same": false
        },
        {
          "line": 3955,
          "old_api": "addReplyLongLong",
          "new_api": null,
          "old_text": "addReplyLongLong(c, start)",
          "new_text": null,
          "old_line_content": "                    addReplyLongLong(c, start); /* only one slot; low==high */",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3958,
          "old_api": "addReplyLongLong",
          "new_api": null,
          "old_text": "addReplyLongLong(c, start)",
          "new_text": null,
          "old_line_content": "                    addReplyLongLong(c, start); /* low */",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3959,
          "old_api": "addReplyLongLong",
          "new_api": null,
          "old_text": "addReplyLongLong(c, j-1)",
          "new_text": null,
          "old_line_content": "                    addReplyLongLong(c, j-1);   /* high */",
          "new_line_content": "            if (start != -1 && (!bit || j == CLUSTER_SLOTS-1)) {",
          "content_same": false
        },
        {
          "line": 3964,
          "old_api": "addReplyMultiBulkLen",
          "new_api": null,
          "old_text": "addReplyMultiBulkLen(c, 3)",
          "new_text": null,
          "old_line_content": "                addReplyMultiBulkLen(c, 3);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3965,
          "old_api": "addReplyBulkCString",
          "new_api": null,
          "old_text": "addReplyBulkCString(c, node->ip)",
          "new_text": null,
          "old_line_content": "                addReplyBulkCString(c, node->ip);",
          "new_line_content": "                /* If slot exists in output map, add to it's list.",
          "content_same": false
        },
        {
          "line": 3966,
          "old_api": "addReplyLongLong",
          "new_api": null,
          "old_text": "addReplyLongLong(c, node->port)",
          "new_text": null,
          "old_line_content": "                addReplyLongLong(c, node->port);",
          "new_line_content": "                 * else, create a new output map for this slot */",
          "content_same": false
        },
        {
          "line": 3967,
          "old_api": "addReplyBulkCBuffer",
          "new_api": null,
          "old_text": "addReplyBulkCBuffer(c, node->name, CLUSTER_NAMELEN)",
          "new_text": null,
          "old_line_content": "                addReplyBulkCBuffer(c, node->name, CLUSTER_NAMELEN);",
          "new_line_content": "                if (start == j-1) {",
          "content_same": false
        },
        {
          "line": 1922,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(sender)",
          "new_text": null,
          "old_line_content": "            nodeIsMaster(myself) && nodeIsMaster(sender) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1925,
          "old_api": "clusterHandleConfigEpochCollision",
          "new_api": null,
          "old_text": "clusterHandleConfigEpochCollision(sender)",
          "new_text": null,
          "old_line_content": "            clusterHandleConfigEpochCollision(sender);",
          "new_line_content": "                         * of sender's slots. */",
          "content_same": false
        },
        {
          "line": 3973,
          "old_api": "nodeFailed",
          "new_api": null,
          "old_text": "nodeFailed(node->slaves[i])",
          "new_text": null,
          "old_line_content": "                    if (nodeFailed(node->slaves[i])) continue;",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 3974,
          "old_api": "addReplyMultiBulkLen",
          "new_api": null,
          "old_text": "addReplyMultiBulkLen(c, 3)",
          "new_text": null,
          "old_line_content": "                    addReplyMultiBulkLen(c, 3);",
          "new_line_content": "                start = -1;",
          "content_same": false
        },
        {
          "line": 3975,
          "old_api": "addReplyBulkCString",
          "new_api": null,
          "old_text": "addReplyBulkCString(c, node->slaves[i]->ip)",
          "new_text": null,
          "old_line_content": "                    addReplyBulkCString(c, node->slaves[i]->ip);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1929,
          "old_api": "clusterProcessGossipSection",
          "new_api": null,
          "old_text": "clusterProcessGossipSection(hdr,link)",
          "new_text": null,
          "old_line_content": "        if (sender) clusterProcessGossipSection(hdr,link);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3976,
          "old_api": "addReplyLongLong",
          "new_api": null,
          "old_text": "addReplyLongLong(c, node->slaves[i]->port)",
          "new_text": null,
          "old_line_content": "                    addReplyLongLong(c, node->slaves[i]->port);",
          "new_line_content": "                /* First node reply position is always the master */",
          "content_same": false
        },
        {
          "line": 1934,
          "old_api": "clusterLookupNode",
          "new_api": null,
          "old_text": "clusterLookupNode(hdr->data.fail.about.nodename)",
          "new_text": null,
          "old_line_content": "            failing = clusterLookupNode(hdr->data.fail.about.nodename);",
          "new_line_content": "        if (sender &&",
          "content_same": false
        },
        {
          "line": 3985,
          "old_api": "dictReleaseIterator",
          "new_api": null,
          "old_text": "dictReleaseIterator(di)",
          "new_text": null,
          "old_line_content": "    dictReleaseIterator(di);",
          "new_line_content": "                     * with modifications for per-slot node aggregation */",
          "content_same": false
        },
        {
          "line": 3991,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"This instance has cluster support disabled\")",
          "new_text": null,
          "old_line_content": "        addReplyError(c,\"This instance has cluster support disabled\");",
          "new_line_content": "                    nested_elements++;",
          "content_same": false
        },
        {
          "line": 1944,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                                     CLUSTER_TODO_UPDATE_STATE)",
          "new_text": null,
          "old_line_content": "                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "new_line_content": "        clusterNode *failing;",
          "content_same": false
        },
        {
          "line": 3995,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[1]->ptr,\"meet\")",
          "new_text": null,
          "old_line_content": "    if (!strcasecmp(c->argv[1]->ptr,\"meet\") && (c->argc == 4 || c->argc == 5)) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1948,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_NOTICE,\n                \"Ignoring FAIL message from unknown node %.40s about %.40s\",\n                hdr->sender, hdr->data.fail.about.nodename)",
          "new_text": null,
          "old_line_content": "            serverLog(LL_NOTICE,",
          "new_line_content": "            if (failing &&",
          "content_same": false
        },
        {
          "line": 4000,
          "old_api": "addReplyErrorFormat",
          "new_api": null,
          "old_text": "addReplyErrorFormat(c,\"Invalid TCP base port specified: %s\",\n                                (char*)c->argv[3]->ptr)",
          "new_text": null,
          "old_line_content": "            addReplyErrorFormat(c,\"Invalid TCP base port specified: %s\",",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1958,
          "old_api": "dictSize",
          "new_api": null,
          "old_text": "dictSize(server.pubsub_channels)",
          "new_text": null,
          "old_line_content": "        if (dictSize(server.pubsub_channels) ||",
          "new_line_content": "                                     CLUSTER_TODO_UPDATE_STATE);",
          "content_same": false
        },
        {
          "line": 1959,
          "old_api": "listLength",
          "new_api": null,
          "old_text": "listLength(server.pubsub_patterns)",
          "new_text": null,
          "old_line_content": "           listLength(server.pubsub_patterns))",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 4006,
          "old_api": "getLongLongFromObject",
          "new_api": null,
          "old_text": "getLongLongFromObject(c->argv[4], &cport)",
          "new_text": null,
          "old_line_content": "            if (getLongLongFromObject(c->argv[4], &cport) != C_OK) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4007,
          "old_api": "addReplyErrorFormat",
          "new_api": null,
          "old_text": "addReplyErrorFormat(c,\"Invalid TCP bus port specified: %s\",\n                                    (char*)c->argv[4]->ptr)",
          "new_text": null,
          "old_line_content": "                addReplyErrorFormat(c,\"Invalid TCP bus port specified: %s\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1962,
          "old_api": "ntohl",
          "new_api": null,
          "old_text": "ntohl(hdr->data.publish.msg.message_len)",
          "new_text": null,
          "old_line_content": "            message_len = ntohl(hdr->data.publish.msg.message_len);",
          "new_line_content": "                \"Ignoring FAIL message from unknown node %.40s about %.40s\",",
          "content_same": false
        },
        {
          "line": 1963,
          "old_api": "createStringObject",
          "new_api": null,
          "old_text": "createStringObject(\n                        (char*)hdr->data.publish.msg.bulk_data,channel_len)",
          "new_text": null,
          "old_line_content": "            channel = createStringObject(",
          "new_line_content": "                hdr->sender, hdr->data.fail.about.nodename);",
          "content_same": false
        },
        {
          "line": 1965,
          "old_api": "createStringObject",
          "new_api": null,
          "old_text": "createStringObject(\n                        (char*)hdr->data.publish.msg.bulk_data+channel_len,\n                        message_len)",
          "new_text": null,
          "old_line_content": "            message = createStringObject(",
          "new_line_content": "    } else if (type == CLUSTERMSG_TYPE_PUBLISH) {",
          "content_same": false
        },
        {
          "line": 4015,
          "old_api": "clusterStartHandshake",
          "new_api": null,
          "old_text": "clusterStartHandshake(c->argv[2]->ptr,port,cport)",
          "new_text": null,
          "old_line_content": "        if (clusterStartHandshake(c->argv[2]->ptr,port,cport) == 0 &&",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 1968,
          "old_api": "pubsubPublishMessage",
          "new_api": null,
          "old_text": "pubsubPublishMessage(channel,message)",
          "new_text": null,
          "old_line_content": "            pubsubPublishMessage(channel,message);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1969,
          "old_api": "decrRefCount",
          "new_api": null,
          "old_text": "decrRefCount(channel)",
          "new_text": null,
          "old_line_content": "            decrRefCount(channel);",
          "new_line_content": "        /* Don't bother creating useless objects if there are no",
          "content_same": false
        },
        {
          "line": 1970,
          "old_api": "decrRefCount",
          "new_api": null,
          "old_text": "decrRefCount(message)",
          "new_text": null,
          "old_line_content": "            decrRefCount(message);",
          "new_line_content": "         * Pub/Sub subscribers. */",
          "content_same": false
        },
        {
          "line": 4018,
          "old_api": "addReplyErrorFormat",
          "new_api": null,
          "old_text": "addReplyErrorFormat(c,\"Invalid node address specified: %s:%s\",\n                            (char*)c->argv[2]->ptr, (char*)c->argv[3]->ptr)",
          "new_text": null,
          "old_line_content": "            addReplyErrorFormat(c,\"Invalid node address specified: %s:%s\",",
          "new_line_content": "        if (c->argc == 5) {",
          "content_same": false
        },
        {
          "line": 4021,
          "old_api": "addReply",
          "new_api": null,
          "old_text": "addReply(c,shared.ok)",
          "new_text": null,
          "old_line_content": "            addReply(c,shared.ok);",
          "new_line_content": "                                    (char*)c->argv[4]->ptr);",
          "content_same": false
        },
        {
          "line": 4023,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[1]->ptr,\"nodes\")",
          "new_text": null,
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"nodes\") && c->argc == 2) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 4026,
          "old_api": "clusterGenNodesDescription",
          "new_api": null,
          "old_text": "clusterGenNodesDescription(0)",
          "new_text": null,
          "old_line_content": "        sds ci = clusterGenNodesDescription(0);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1980,
          "old_api": "nodeIsMaster",
          "new_api": null,
          "old_text": "nodeIsMaster(sender)",
          "new_text": null,
          "old_line_content": "        if (nodeIsMaster(sender) && sender->numslots > 0 &&",
          "new_line_content": "                        message_len);",
          "content_same": false
        },
        {
          "line": 4029,
          "old_api": "addReplyBulk",
          "new_api": null,
          "old_text": "addReplyBulk(c,o)",
          "new_text": null,
          "old_line_content": "        addReplyBulk(c,o);",
          "new_line_content": "            errno == EINVAL)",
          "content_same": false
        },
        {
          "line": 4030,
          "old_api": "decrRefCount",
          "new_api": null,
          "old_text": "decrRefCount(o)",
          "new_text": null,
          "old_line_content": "        decrRefCount(o);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 4033,
          "old_api": "addReplyBulkCBuffer",
          "new_api": null,
          "old_text": "addReplyBulkCBuffer(c,myself->name, CLUSTER_NAMELEN)",
          "new_text": null,
          "old_line_content": "        addReplyBulkCBuffer(c,myself->name, CLUSTER_NAMELEN);",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 1986,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER)",
          "new_text": null,
          "old_line_content": "            clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);",
          "new_line_content": "        if (!sender) return 1;  /* We don't know that node. */",
          "content_same": false
        },
        {
          "line": 4037,
          "old_api": "strcasecmp",
          "new_api": null,
          "old_text": "strcasecmp(c->argv[1]->ptr,\"flushslots\")",
          "new_text": null,
          "old_line_content": "    } else if (!strcasecmp(c->argv[1]->ptr,\"flushslots\") && c->argc == 2) {",
          "new_line_content": "        /* CLUSTER NODES */",
          "content_same": false
        },
        {
          "line": 4040,
          "old_api": "addReplyError",
          "new_api": null,
          "old_text": "addReplyError(c,\"DB must be empty to perform CLUSTER FLUSHSLOTS.\")",
          "new_text": null,
          "old_line_content": "            addReplyError(c,\"DB must be empty to perform CLUSTER FLUSHSLOTS.\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": "resetManualFailover",
          "new_api": null,
          "old_text": "resetManualFailover()",
          "new_text": null,
          "old_line_content": "        resetManualFailover();",
          "new_line_content": "            senderCurrentEpoch >= server.cluster->failover_auth_epoch)",
          "content_same": false
        },
        {
          "line": 1995,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "        server.cluster->mf_end = mstime() + CLUSTER_MF_TIMEOUT;",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1997,
          "old_api": "mstime",
          "new_api": null,
          "old_text": "mstime()",
          "new_text": null,
          "old_line_content": "        pauseClients(mstime()+(CLUSTER_MF_TIMEOUT*2));",
          "new_line_content": "            /* Maybe we reached a quorum here, set a flag to make sure",
          "content_same": false
        },
        {
          "line": 1998,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\"Manual failover requested by slave %.40s.\",\n            sender->name)",
          "new_text": null,
          "old_line_content": "        serverLog(LL_WARNING,\"Manual failover requested by slave %.40s.\",",
          "new_line_content": "             * we check ASAP. */",
          "content_same": false
        },
        {
          "line": 4045,
          "old_api": "addReply",
          "new_api": null,
          "old_text": "addReply(c,shared.ok)",
          "new_text": null,
          "old_line_content": "        addReply(c,shared.ok);",
          "new_line_content": "        /* CLUSTER MYID */",
          "content_same": false
        },
        {
          "line": 2003,
          "old_api": "ntohu64",
          "new_api": null,
          "old_text": "ntohu64(hdr->data.update.nodecfg.configEpoch)",
          "new_text": null,
          "old_line_content": "                    ntohu64(hdr->data.update.nodecfg.configEpoch);",
          "new_line_content": "         * is one of my slaves. */",
          "content_same": false
        },
        {
          "line": 2006,
          "old_api": "clusterLookupNode",
          "new_api": null,
          "old_text": "clusterLookupNode(hdr->data.update.nodecfg.nodename)",
          "new_text": null,
          "old_line_content": "        n = clusterLookupNode(hdr->data.update.nodecfg.nodename);",
          "new_line_content": "         * accordingly. */",
          "content_same": false
        },
        {
          "line": 4055,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(slots,0,CLUSTER_SLOTS)",
          "new_text": null,
          "old_line_content": "        memset(slots,0,CLUSTER_SLOTS);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2015,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|\n                             CLUSTER_TODO_FSYNC_CONFIG)",
          "new_text": null,
          "old_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|",
          "new_line_content": "        uint64_t reportedConfigEpoch =",
          "content_same": false
        },
        {
          "line": 4064,
          "old_api": "addReplyErrorFormat",
          "new_api": null,
          "old_text": "addReplyErrorFormat(c,\"Slot %d is already unassigned\", slot)",
          "new_text": null,
          "old_line_content": "                addReplyErrorFormat(c,\"Slot %d is already unassigned\", slot);",
          "new_line_content": "        int j, slot;",
          "content_same": false
        },
        {
          "line": 2020,
          "old_api": "clusterUpdateSlotsConfigWith",
          "new_api": null,
          "old_text": "clusterUpdateSlotsConfigWith(n,reportedConfigEpoch,\n            hdr->data.update.nodecfg.slots)",
          "new_text": null,
          "old_line_content": "        clusterUpdateSlotsConfigWith(n,reportedConfigEpoch,",
          "new_line_content": "        if (!n) return 1;   /* We don't know the reported node. */",
          "content_same": false
        },
        {
          "line": 4069,
          "old_api": "zfree",
          "new_api": null,
          "old_text": "zfree(slots)",
          "new_text": null,
          "old_line_content": "                zfree(slots);",
          "new_line_content": "        /* Check that all the arguments are parseable and that all the",
          "content_same": false
        },
        {
          "line": 2023,
          "old_api": "serverLog",
          "new_api": null,
          "old_text": "serverLog(LL_WARNING,\"Received unknown packet type: %d\", type)",
          "new_text": null,
          "old_line_content": "        serverLog(LL_WARNING,\"Received unknown packet type: %d\", type);",
          "new_line_content": "        /* If in our current config the node is a slave, set it as a master. */",
          "content_same": false
        },
        {
          "line": 4075,
          "old_api": "zfree",
          "new_api": null,
          "old_text": "zfree(slots)",
          "new_text": null,
          "old_line_content": "                zfree(slots);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2035,
          "old_api": "freeClusterLink",
          "new_api": null,
          "old_text": "freeClusterLink(link)",
          "new_text": null,
          "old_line_content": "    freeClusterLink(link);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 4089,
          "old_api": "clusterAddSlot",
          "new_api": null,
          "old_text": "clusterAddSlot(myself,j)",
          "new_text": null,
          "old_line_content": "                               clusterAddSlot(myself,j);",
          "new_line_content": "                return;",
          "content_same": false
        },
        {
          "line": 4090,
          "old_api": "serverAssertWithInfo",
          "new_api": null,
          "old_text": "serverAssertWithInfo(c,NULL,retval == C_OK)",
          "new_text": null,
          "old_line_content": "                serverAssertWithInfo(c,NULL,retval == C_OK);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2044,
          "old_api": "UNUSED",
          "new_api": null,
          "old_text": "UNUSED(el)",
          "new_text": null,
          "old_line_content": "    UNUSED(el);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4093,
          "old_api": "zfree",
          "new_api": null,
          "old_text": "zfree(slots)",
          "new_text": null,
          "old_line_content": "        zfree(slots);",
          "new_line_content": "            if (slots[j]) {",
          "content_same": false
        },
        {
          "line": 4094,
          "old_api": "clusterDoBeforeSleep",
          "new_api": null,
          "old_text": "clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG)",
          "new_text": null,
          "old_line_content": "        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);",
          "new_line_content": "                int retval;",
          "content_same": false
        },
        {
          "line": 4095,
          "old_api": "addReply",
          "new_api": null,
          "old_text": "addReply(c,shared.ok)",
          "new_text": null,
          "old_line_content": "        addReply(c,shared.ok);",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 179,
      "total_additions": 623,
      "total_deletions": 621,
      "total_api_changes": 1423
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 13,
        "api_related_lines": 1423,
        "non_api_lines": 8,
        "non_api_line_numbers": [
          1357,
          1358,
          1359,
          1360,
          1361,
          1362,
          1364,
          1368
        ]
      }
    },
    "api_calls_before": 1172,
    "api_calls_after": 1174,
    "diff_info": {
      "added_lines": 13,
      "removed_lines": 0,
      "total_diff_lines": 25
    }
  }
}