{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/54f0c40459e9dc8af77ef1bb156dc05ec504dc2f",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/54f0c40459e9dc8af77ef1bb156dc05ec504dc2f/before.h",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/54f0c40459e9dc8af77ef1bb156dc05ec504dc2f/after.h",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/54f0c40459e9dc8af77ef1bb156dc05ec504dc2f/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": true,
    "api_changes": {
      "replacements": [
        {
          "line": 85,
          "old_api": "std::isfinite(x)",
          "new_api": "std::isnan(x)",
          "old_text": "std::isfinite(x)",
          "new_text": "std::isnan(x)",
          "old_line_content": "  if (!std::isfinite(x)) return x;",
          "new_line_content": "  if (std::isnan(x) || x == 0.0) return 0;",
          "content_same": false
        },
        {
          "line": 129,
          "old_api": "static_cast<int64_t>(bits)",
          "new_api": "Significand",
          "old_text": "static_cast<int64_t>(bits)",
          "new_text": "d.Significand()",
          "old_line_content": "    int64_t bits_int64 = static_cast<int64_t>(bits);",
          "new_line_content": "    bits = (d.Significand() << exponent);",
          "content_same": false
        },
        {
          "line": 130,
          "old_api": "std::numeric_limits<int64_t>::min()",
          "new_api": "static_cast<int64_t>(bits)",
          "old_text": "std::numeric_limits<int64_t>::min()",
          "new_text": "static_cast<int64_t>(bits)",
          "old_line_content": "    if (bits_int64 == std::numeric_limits<int64_t>::min()) {",
          "new_line_content": "    int64_t bits_int64 = static_cast<int64_t>(bits);",
          "content_same": false
        },
        {
          "line": 143,
          "old_api": "FastD2I",
          "new_api": "IsSmiDouble",
          "old_text": "FastD2I(value)",
          "new_text": "IsSmiDouble(value)",
          "old_line_content": "  *smi_int_value = FastD2I(value);",
          "new_line_content": "  if (!IsSmiDouble(value)) return false;",
          "content_same": false
        },
        {
          "line": 144,
          "old_api": "Smi::IsValid(*smi_int_value)",
          "new_api": "FastD2I",
          "old_text": "Smi::IsValid(*smi_int_value)",
          "new_text": "FastD2I(value)",
          "old_line_content": "  DCHECK(Smi::IsValid(*smi_int_value));",
          "new_line_content": "  *smi_int_value = FastD2I(value);",
          "content_same": false
        },
        {
          "line": 155,
          "old_api": "FastD2I",
          "new_api": "IsMinusZero",
          "old_text": "FastD2I(value)",
          "new_text": "IsMinusZero(value)",
          "old_line_content": "         value == FastI2D(FastD2I(value));",
          "new_line_content": "  return value >= kMinInt && value <= kMaxInt && !IsMinusZero(value) &&",
          "content_same": false
        },
        {
          "line": 160,
          "old_api": "FastD2UI",
          "new_api": "IsMinusZero",
          "old_text": "FastD2UI(value)",
          "new_text": "IsMinusZero(value)",
          "old_line_content": "         value == FastUI2D(FastD2UI(value));",
          "new_line_content": "  return !IsMinusZero(value) && value >= 0 && value <= kMaxUInt32 &&",
          "content_same": false
        },
        {
          "line": 195,
          "old_api": "value",
          "new_api": "Smi::ToInt(number)",
          "old_text": "HeapNumber::cast(number).value()",
          "new_text": "Smi::ToInt(number)",
          "old_line_content": "  return DoubleToInt32(HeapNumber::cast(number).value());",
          "new_line_content": "  if (number.IsSmi()) return Smi::ToInt(number);",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": "value",
          "new_api": "Smi::ToInt(number)",
          "old_text": "HeapNumber::cast(number).value()",
          "new_text": "Smi::ToInt(number)",
          "old_line_content": "  return DoubleToUint32(HeapNumber::cast(number).value());",
          "new_line_content": "  if (number.IsSmi()) return Smi::ToInt(number);",
          "content_same": false
        },
        {
          "line": 205,
          "old_api": "Smi::ToInt(number)",
          "new_api": "IsSmi",
          "old_text": "Smi::ToInt(number)",
          "new_text": "number.IsSmi()",
          "old_line_content": "    int value = Smi::ToInt(number);",
          "new_line_content": "  if (number.IsSmi()) {",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": "static_cast<uint32_t>(value)",
          "new_api": "std::numeric_limits<uint32_t>::max()",
          "old_text": "static_cast<uint32_t>(value)",
          "new_text": "std::numeric_limits<uint32_t>::max()",
          "old_line_content": "  if (value < max) return static_cast<uint32_t>(value);",
          "new_line_content": "  uint32_t max = std::numeric_limits<uint32_t>::max();",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": "value",
          "new_api": "Smi::ToInt(number)",
          "old_text": "HeapNumber::cast(number).value()",
          "new_text": "Smi::ToInt(number)",
          "old_line_content": "  double d = HeapNumber::cast(number).value();",
          "new_line_content": "  if (number.IsSmi()) return Smi::ToInt(number);",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": "std::isnan(d)",
          "new_api": "value",
          "old_text": "std::isnan(d)",
          "new_text": "HeapNumber::cast(number).value()",
          "old_line_content": "  if (std::isnan(d)) return 0;",
          "new_line_content": "  double d = HeapNumber::cast(number).value();",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": "std::numeric_limits<int64_t>::max()",
          "new_api": "std::isnan(d)",
          "old_text": "std::numeric_limits<int64_t>::max()",
          "new_text": "std::isnan(d)",
          "old_line_content": "  if (d >= static_cast<double>(std::numeric_limits<int64_t>::max())) {",
          "new_line_content": "  if (std::isnan(d)) return 0;",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": "Smi::ToInt(number)",
          "new_api": "IsSmi",
          "old_text": "Smi::ToInt(number)",
          "new_text": "number.IsSmi()",
          "old_line_content": "    int value = Smi::ToInt(number);",
          "new_line_content": "  if (number.IsSmi()) {",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": "static_cast<uint64_t>(value)",
          "new_api": "std::numeric_limits<uint64_t>::max()",
          "old_text": "static_cast<uint64_t>(value)",
          "new_text": "std::numeric_limits<uint64_t>::max()",
          "old_line_content": "  if (value < max) return static_cast<uint64_t>(value);",
          "new_line_content": "  uint64_t max = std::numeric_limits<uint64_t>::max();",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": "Smi::ToInt(number)",
          "new_api": "IsSmi",
          "old_text": "Smi::ToInt(number)",
          "new_text": "number.IsSmi()",
          "old_line_content": "    int value = Smi::ToInt(number);",
          "new_line_content": "  if (number.IsSmi()) {",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": "static_cast<unsigned>(Smi::kMaxValue)",
          "new_api": "Smi::ToInt(number)",
          "old_text": "static_cast<unsigned>(Smi::kMaxValue)",
          "new_text": "Smi::ToInt(number)",
          "old_line_content": "    DCHECK(static_cast<unsigned>(Smi::kMaxValue) <=",
          "new_line_content": "    int value = Smi::ToInt(number);",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": "std::numeric_limits<size_t>::max()",
          "new_api": "static_cast<unsigned>(Smi::kMaxValue)",
          "old_text": "std::numeric_limits<size_t>::max()",
          "new_text": "static_cast<unsigned>(Smi::kMaxValue)",
          "old_line_content": "           std::numeric_limits<size_t>::max());",
          "new_line_content": "    DCHECK(static_cast<unsigned>(Smi::kMaxValue) <=",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": "CHECK",
          "new_api": "TryNumberToSize",
          "old_text": "CHECK(is_valid)",
          "new_text": "TryNumberToSize(number, &result)",
          "old_line_content": "  CHECK(is_valid);",
          "new_line_content": "  bool is_valid = TryNumberToSize(number, &result);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 258,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "HeapNumber::cast(number).value()",
          "old_line_content": "    // If value is compared directly to the limit, the limit will be",
          "new_line_content": "    double value = HeapNumber::cast(number).value();",
          "content_same": false
        },
        {
          "line": 131,
          "old_api": null,
          "new_api": "std::numeric_limits<int64_t>::min()",
          "old_text": null,
          "new_text": "std::numeric_limits<int64_t>::min()",
          "old_line_content": "      return bits_int64;",
          "new_line_content": "    if (bits_int64 == std::numeric_limits<int64_t>::min()) {",
          "content_same": false
        },
        {
          "line": 263,
          "old_api": null,
          "new_api": "std::numeric_limits<size_t>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<size_t>::max()",
          "old_line_content": "    if (value >= 0 && value < maxSize) {",
          "new_line_content": "    double maxSize = static_cast<double>(std::numeric_limits<size_t>::max());",
          "content_same": false
        },
        {
          "line": 135,
          "old_api": null,
          "new_api": "static_cast<int64_t>(bits)",
          "old_text": null,
          "new_text": "static_cast<int64_t>(bits)",
          "old_line_content": "}",
          "new_line_content": "  return static_cast<int64_t>(d.Sign() * static_cast<int64_t>(bits));",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": null,
          "new_api": "static_cast<size_t>(value)",
          "old_text": null,
          "new_text": "static_cast<size_t>(value)",
          "old_line_content": "      return true;",
          "new_line_content": "      *result = static_cast<size_t>(value);",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": null,
          "new_api": "DoubleToWebIDLInt64",
          "old_text": null,
          "new_text": "DoubleToWebIDLInt64(x)",
          "old_line_content": "}",
          "new_line_content": "  return static_cast<uint64_t>(DoubleToWebIDLInt64(x));",
          "content_same": false
        },
        {
          "line": 145,
          "old_api": null,
          "new_api": "Smi::IsValid(*smi_int_value)",
          "old_text": null,
          "new_text": "Smi::IsValid(*smi_int_value)",
          "old_line_content": "  return true;",
          "new_line_content": "  DCHECK(Smi::IsValid(*smi_int_value));",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(is_valid)",
          "old_line_content": "  return result;",
          "new_line_content": "  CHECK(is_valid);",
          "content_same": false
        },
        {
          "line": 151,
          "old_api": null,
          "new_api": "FastD2I",
          "old_text": null,
          "new_text": "FastD2I(value)",
          "old_line_content": "}",
          "new_line_content": "         !IsMinusZero(value) && value == FastI2D(FastD2I(value));",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": null,
          "new_api": "DoubleToInt32",
          "old_text": null,
          "new_text": "DoubleToInt32(x)",
          "old_line_content": "}",
          "new_line_content": "  return static_cast<uint32_t>(DoubleToInt32(x));",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": null,
          "new_api": "FastD2I",
          "old_text": null,
          "new_text": "FastD2I(value)",
          "old_line_content": "}",
          "new_line_content": "         value == FastI2D(FastD2I(value));",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": null,
          "new_api": "FastD2UI",
          "old_text": null,
          "new_text": "FastD2UI(value)",
          "old_line_content": "}",
          "new_line_content": "         value == FastUI2D(FastD2UI(value));",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": null,
          "new_api": "base::bit_cast<uint64_t>(shifted_value)",
          "old_text": null,
          "new_text": "base::bit_cast<uint64_t>(shifted_value)",
          "old_line_content": "  if ((result >> 32) == kValidTopBits) {",
          "new_line_content": "  uint64_t result = base::bit_cast<uint64_t>(shifted_value);",
          "content_same": false
        },
        {
          "line": 189,
          "old_api": null,
          "new_api": "FastUI2D",
          "old_text": null,
          "new_text": "FastUI2D(result & kBottomBitMask)",
          "old_line_content": "  }",
          "new_line_content": "    return FastUI2D(result & kBottomBitMask) == value;",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "HeapNumber::cast(number).value()",
          "old_line_content": "}",
          "new_line_content": "  return DoubleToInt32(HeapNumber::cast(number).value());",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "HeapNumber::cast(number).value()",
          "old_line_content": "}",
          "new_line_content": "  return DoubleToUint32(HeapNumber::cast(number).value());",
          "content_same": false
        },
        {
          "line": 206,
          "old_api": null,
          "new_api": "Smi::ToInt(number)",
          "old_text": null,
          "new_text": "Smi::ToInt(number)",
          "old_line_content": "    if (value <= 0) return 0;",
          "new_line_content": "    int value = Smi::ToInt(number);",
          "content_same": false
        },
        {
          "line": 210,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "HeapNumber::cast(number).value()",
          "old_line_content": "  // Catch all values smaller than 1 and use the double-negation trick for NANs.",
          "new_line_content": "  double value = HeapNumber::cast(number).value();",
          "content_same": false
        },
        {
          "line": 86,
          "old_api": null,
          "new_api": "std::isfinite(x)",
          "old_text": null,
          "new_text": "std::isfinite(x)",
          "old_line_content": "  // ToIntegerOrInfinity normalizes -0 to +0, so add 0.0.",
          "new_line_content": "  if (!std::isfinite(x)) return x;",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": null,
          "new_api": "static_cast<uint32_t>(value)",
          "old_text": null,
          "new_text": "static_cast<uint32_t>(value)",
          "old_line_content": "  return max;",
          "new_line_content": "  if (value < max) return static_cast<uint32_t>(value);",
          "content_same": false
        },
        {
          "line": 88,
          "old_api": null,
          "new_api": "std::ceil(x)",
          "old_text": null,
          "new_text": "std::ceil(x)",
          "old_line_content": "}",
          "new_line_content": "  return ((x > 0) ? std::floor(x) : std::ceil(x)) + 0.0;",
          "content_same": false
        },
        {
          "line": 93,
          "old_api": null,
          "new_api": "std::isfinite(x)",
          "old_text": null,
          "new_text": "std::isfinite(x)",
          "old_line_content": "    // All doubles within these limits are trivially convertable to an int.",
          "new_line_content": "  if ((std::isfinite(x)) && (x <= INT_MAX) && (x >= INT_MIN)) {",
          "content_same": false
        },
        {
          "line": 95,
          "old_api": null,
          "new_api": "static_cast<int32_t>(x)",
          "old_text": null,
          "new_text": "static_cast<int32_t>(x)",
          "old_line_content": "  }",
          "new_line_content": "    return static_cast<int32_t>(x);",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": null,
          "new_api": "std::numeric_limits<int64_t>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<int64_t>::max()",
          "old_line_content": "  }",
          "new_line_content": "    return std::numeric_limits<int64_t>::max();",
          "content_same": false
        },
        {
          "line": 98,
          "old_api": null,
          "new_api": "Exponent",
          "old_text": null,
          "new_text": "d.Exponent()",
          "old_line_content": "  uint64_t bits;",
          "new_line_content": "  int exponent = d.Exponent();",
          "content_same": false
        },
        {
          "line": 226,
          "old_api": null,
          "new_api": "std::numeric_limits<int64_t>::min()",
          "old_text": null,
          "new_text": "std::numeric_limits<int64_t>::min()",
          "old_line_content": "  }",
          "new_line_content": "    return std::numeric_limits<int64_t>::min();",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": null,
          "new_api": "static_cast<int64_t>(d)",
          "old_text": null,
          "new_text": "static_cast<int64_t>(d)",
          "old_line_content": "}",
          "new_line_content": "  return static_cast<int64_t>(d);",
          "content_same": false
        },
        {
          "line": 102,
          "old_api": null,
          "new_api": "Significand",
          "old_text": null,
          "new_text": "d.Significand()",
          "old_line_content": "  } else {",
          "new_line_content": "    bits = d.Significand() >> -exponent;",
          "content_same": false
        },
        {
          "line": 233,
          "old_api": null,
          "new_api": "Smi::ToInt(number)",
          "old_text": null,
          "new_text": "Smi::ToInt(number)",
          "old_line_content": "    if (value <= 0) return 0;",
          "new_line_content": "    int value = Smi::ToInt(number);",
          "content_same": false
        },
        {
          "line": 108,
          "old_api": null,
          "new_api": "Significand",
          "old_text": null,
          "new_text": "d.Significand()",
          "old_line_content": "  }",
          "new_line_content": "    bits = (d.Significand() << exponent) & 0xFFFFFFFFul;",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "HeapNumber::cast(number).value()",
          "old_line_content": "  // Catch all values smaller than 1 and use the double-negation trick for NANs.",
          "new_line_content": "  double value = HeapNumber::cast(number).value();",
          "content_same": false
        },
        {
          "line": 110,
          "old_api": null,
          "new_api": "static_cast<int64_t>(bits)",
          "old_text": null,
          "new_text": "static_cast<int64_t>(bits)",
          "old_line_content": "}",
          "new_line_content": "  return static_cast<int32_t>(d.Sign() * static_cast<int64_t>(bits));",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": null,
          "new_api": "static_cast<uint64_t>(value)",
          "old_text": null,
          "new_text": "static_cast<uint64_t>(value)",
          "old_line_content": "  return max;",
          "new_line_content": "  if (value < max) return static_cast<uint64_t>(value);",
          "content_same": false
        },
        {
          "line": 117,
          "old_api": null,
          "new_api": "std::isfinite(x)",
          "old_text": null,
          "new_text": "std::isfinite(x)",
          "old_line_content": "    // All doubles within these limits are trivially convertable to an int.",
          "new_line_content": "  if ((std::isfinite(x)) && (x <= kMaxSafeInteger) && (x >= kMinSafeInteger)) {",
          "content_same": false
        },
        {
          "line": 119,
          "old_api": null,
          "new_api": "static_cast<int64_t>(x)",
          "old_text": null,
          "new_text": "static_cast<int64_t>(x)",
          "old_line_content": "  }",
          "new_line_content": "    return static_cast<int64_t>(x);",
          "content_same": false
        },
        {
          "line": 122,
          "old_api": null,
          "new_api": "Exponent",
          "old_text": null,
          "new_text": "d.Exponent()",
          "old_line_content": "  uint64_t bits;",
          "new_line_content": "  int exponent = d.Exponent();",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": null,
          "new_api": "std::numeric_limits<size_t>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<size_t>::max()",
          "old_line_content": "    if (value >= 0) {",
          "new_line_content": "           std::numeric_limits<size_t>::max());",
          "content_same": false
        },
        {
          "line": 253,
          "old_api": null,
          "new_api": "static_cast<size_t>(value)",
          "old_text": null,
          "new_text": "static_cast<size_t>(value)",
          "old_line_content": "      return true;",
          "new_line_content": "      *result = static_cast<size_t>(value);",
          "content_same": false
        },
        {
          "line": 126,
          "old_api": null,
          "new_api": "Significand",
          "old_text": null,
          "new_text": "d.Significand()",
          "old_line_content": "  } else {",
          "new_line_content": "    bits = d.Significand() >> -exponent;",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 128,
          "old_api": "Significand",
          "new_api": null,
          "old_text": "d.Significand()",
          "new_text": null,
          "old_line_content": "    bits = (d.Significand() << exponent);",
          "new_line_content": "    if (exponent > 63) return 0;",
          "content_same": false
        },
        {
          "line": 257,
          "old_api": "value",
          "new_api": null,
          "old_text": "HeapNumber::cast(number).value()",
          "new_text": null,
          "old_line_content": "    double value = HeapNumber::cast(number).value();",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 134,
          "old_api": "static_cast<int64_t>(bits)",
          "new_api": null,
          "old_text": "static_cast<int64_t>(bits)",
          "new_text": null,
          "old_line_content": "  return static_cast<int64_t>(d.Sign() * static_cast<int64_t>(bits));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": "std::numeric_limits<size_t>::max()",
          "new_api": null,
          "old_text": "std::numeric_limits<size_t>::max()",
          "new_text": null,
          "old_line_content": "    double maxSize = static_cast<double>(std::numeric_limits<size_t>::max());",
          "new_line_content": "    // So we might as well cast the limit first, and use < instead of <=.",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": "static_cast<size_t>(value)",
          "new_api": null,
          "old_text": "static_cast<size_t>(value)",
          "new_text": null,
          "old_line_content": "      *result = static_cast<size_t>(value);",
          "new_line_content": "    if (value >= 0 && value < maxSize) {",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": "DoubleToWebIDLInt64",
          "new_api": null,
          "old_text": "DoubleToWebIDLInt64(x)",
          "new_text": null,
          "old_line_content": "  return static_cast<uint64_t>(DoubleToWebIDLInt64(x));",
          "new_line_content": "inline uint64_t DoubleToWebIDLUint64(double x) {",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": "IsSmiDouble",
          "new_api": null,
          "old_text": "IsSmiDouble(value)",
          "new_text": null,
          "old_line_content": "  if (!IsSmiDouble(value)) return false;",
          "new_line_content": "bool DoubleToSmiInteger(double value, int* smi_int_value) {",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": "TryNumberToSize",
          "new_api": null,
          "old_text": "TryNumberToSize(number, &result)",
          "new_text": null,
          "old_line_content": "  bool is_valid = TryNumberToSize(number, &result);",
          "new_line_content": "  size_t result = 0;",
          "content_same": false
        },
        {
          "line": 150,
          "old_api": "FastD2I",
          "new_api": null,
          "old_text": "FastD2I(value)",
          "new_text": null,
          "old_line_content": "         !IsMinusZero(value) && value == FastI2D(FastD2I(value));",
          "new_line_content": "  return value >= Smi::kMinValue && value <= Smi::kMaxValue &&",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": "DoubleToInt32",
          "new_api": null,
          "old_text": "DoubleToInt32(x)",
          "new_text": null,
          "old_line_content": "  return static_cast<uint32_t>(DoubleToInt32(x));",
          "new_line_content": "uint32_t DoubleToUint32(double x) {",
          "content_same": false
        },
        {
          "line": 154,
          "old_api": "IsMinusZero",
          "new_api": null,
          "old_text": "IsMinusZero(value)",
          "new_text": null,
          "old_line_content": "  return value >= kMinInt && value <= kMaxInt && !IsMinusZero(value) &&",
          "new_line_content": "bool IsInt32Double(double value) {",
          "content_same": false
        },
        {
          "line": 159,
          "old_api": "IsMinusZero",
          "new_api": null,
          "old_text": "IsMinusZero(value)",
          "new_text": null,
          "old_line_content": "  return !IsMinusZero(value) && value >= 0 && value <= kMaxUInt32 &&",
          "new_line_content": "bool IsUint32Double(double value) {",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": "base::bit_cast<uint64_t>(shifted_value)",
          "new_api": null,
          "old_text": "base::bit_cast<uint64_t>(shifted_value)",
          "new_text": null,
          "old_line_content": "  uint64_t result = base::bit_cast<uint64_t>(shifted_value);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": "FastUI2D",
          "new_api": null,
          "old_text": "FastUI2D(result & kBottomBitMask)",
          "new_text": null,
          "old_line_content": "    return FastUI2D(result & kBottomBitMask) == value;",
          "new_line_content": "    *uint32_value = result & kBottomBitMask;",
          "content_same": false
        },
        {
          "line": 194,
          "old_api": "Smi::ToInt(number)",
          "new_api": null,
          "old_text": "Smi::ToInt(number)",
          "new_text": null,
          "old_line_content": "  if (number.IsSmi()) return Smi::ToInt(number);",
          "new_line_content": "int32_t NumberToInt32(Object number) {",
          "content_same": false
        },
        {
          "line": 199,
          "old_api": "Smi::ToInt(number)",
          "new_api": null,
          "old_text": "Smi::ToInt(number)",
          "new_text": null,
          "old_line_content": "  if (number.IsSmi()) return Smi::ToInt(number);",
          "new_line_content": "uint32_t NumberToUint32(Object number) {",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": "IsSmi",
          "new_api": null,
          "old_text": "number.IsSmi()",
          "new_text": null,
          "old_line_content": "  if (number.IsSmi()) {",
          "new_line_content": "uint32_t PositiveNumberToUint32(Object number) {",
          "content_same": false
        },
        {
          "line": 209,
          "old_api": "value",
          "new_api": null,
          "old_text": "HeapNumber::cast(number).value()",
          "new_text": null,
          "old_line_content": "  double value = HeapNumber::cast(number).value();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 84,
          "old_api": "std::isnan(x)",
          "new_api": null,
          "old_text": "std::isnan(x)",
          "new_text": null,
          "old_line_content": "  if (std::isnan(x)) return 0;",
          "new_line_content": "  // ToIntegerOrInfinity normalizes -0 to +0. Special case 0 for performance.",
          "content_same": false
        },
        {
          "line": 212,
          "old_api": "std::numeric_limits<uint32_t>::max()",
          "new_api": null,
          "old_text": "std::numeric_limits<uint32_t>::max()",
          "new_text": null,
          "old_line_content": "  uint32_t max = std::numeric_limits<uint32_t>::max();",
          "new_line_content": "  if (!(value >= 1)) return 0;",
          "content_same": false
        },
        {
          "line": 87,
          "old_api": "std::ceil(x)",
          "new_api": null,
          "old_text": "std::ceil(x)",
          "new_text": null,
          "old_line_content": "  return ((x >= 0) ? std::floor(x) : std::ceil(x)) + 0.0;",
          "new_line_content": "  // Add 0.0 in the truncation case to ensure this doesn't return -0.",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": "Smi::ToInt(number)",
          "new_api": null,
          "old_text": "Smi::ToInt(number)",
          "new_text": null,
          "old_line_content": "  if (number.IsSmi()) return Smi::ToInt(number);",
          "new_line_content": "int64_t NumberToInt64(Object number) {",
          "content_same": false
        },
        {
          "line": 92,
          "old_api": "std::isfinite(x)",
          "new_api": null,
          "old_text": "std::isfinite(x)",
          "new_text": null,
          "old_line_content": "  if ((std::isfinite(x)) && (x <= INT_MAX) && (x >= INT_MIN)) {",
          "new_line_content": "int32_t DoubleToInt32(double x) {",
          "content_same": false
        },
        {
          "line": 94,
          "old_api": "static_cast<int32_t>(x)",
          "new_api": null,
          "old_text": "static_cast<int32_t>(x)",
          "new_text": null,
          "old_line_content": "    return static_cast<int32_t>(x);",
          "new_line_content": "    // All doubles within these limits are trivially convertable to an int.",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": "std::numeric_limits<int64_t>::min()",
          "new_api": null,
          "old_text": "std::numeric_limits<int64_t>::min()",
          "new_text": null,
          "old_line_content": "  if (d <= static_cast<double>(std::numeric_limits<int64_t>::min())) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 97,
          "old_api": "Exponent",
          "new_api": null,
          "old_text": "d.Exponent()",
          "new_text": null,
          "old_line_content": "  int exponent = d.Exponent();",
          "new_line_content": "  base::Double d(x);",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": "static_cast<int64_t>(d)",
          "new_api": null,
          "old_text": "static_cast<int64_t>(d)",
          "new_text": null,
          "old_line_content": "  return static_cast<int64_t>(d);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 101,
          "old_api": "Significand",
          "new_api": null,
          "old_text": "d.Significand()",
          "new_text": null,
          "old_line_content": "    bits = d.Significand() >> -exponent;",
          "new_line_content": "    if (exponent <= -base::Double::kSignificandSize) return 0;",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": "IsSmi",
          "new_api": null,
          "old_text": "number.IsSmi()",
          "new_text": null,
          "old_line_content": "  if (number.IsSmi()) {",
          "new_line_content": "uint64_t PositiveNumberToUint64(Object number) {",
          "content_same": false
        },
        {
          "line": 107,
          "old_api": "Significand",
          "new_api": null,
          "old_text": "d.Significand()",
          "new_text": null,
          "old_line_content": "    bits = (d.Significand() << exponent) & 0xFFFFFFFFul;",
          "new_line_content": "    // which would overflow on multiplication with d.Sign().",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": "value",
          "new_api": null,
          "old_text": "HeapNumber::cast(number).value()",
          "new_text": null,
          "old_line_content": "  double value = HeapNumber::cast(number).value();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 109,
          "old_api": "static_cast<int64_t>(bits)",
          "new_api": null,
          "old_text": "static_cast<int64_t>(bits)",
          "new_text": null,
          "old_line_content": "  return static_cast<int32_t>(d.Sign() * static_cast<int64_t>(bits));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": "std::numeric_limits<uint64_t>::max()",
          "new_api": null,
          "old_text": "std::numeric_limits<uint64_t>::max()",
          "new_text": null,
          "old_line_content": "  uint64_t max = std::numeric_limits<uint64_t>::max();",
          "new_line_content": "  if (!(value >= 1)) return 0;",
          "content_same": false
        },
        {
          "line": 116,
          "old_api": "std::isfinite(x)",
          "new_api": null,
          "old_text": "std::isfinite(x)",
          "new_text": null,
          "old_line_content": "  if ((std::isfinite(x)) && (x <= kMaxSafeInteger) && (x >= kMinSafeInteger)) {",
          "new_line_content": "inline int64_t DoubleToWebIDLInt64(double x) {",
          "content_same": false
        },
        {
          "line": 118,
          "old_api": "static_cast<int64_t>(x)",
          "new_api": null,
          "old_text": "static_cast<int64_t>(x)",
          "new_text": null,
          "old_line_content": "    return static_cast<int64_t>(x);",
          "new_line_content": "    // All doubles within these limits are trivially convertable to an int.",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": "IsSmi",
          "new_api": null,
          "old_text": "number.IsSmi()",
          "new_text": null,
          "old_line_content": "  if (number.IsSmi()) {",
          "new_line_content": "  // the function can be used concurrently.",
          "content_same": false
        },
        {
          "line": 121,
          "old_api": "Exponent",
          "new_api": null,
          "old_text": "d.Exponent()",
          "new_text": null,
          "old_line_content": "  int exponent = d.Exponent();",
          "new_line_content": "  base::Double d(x);",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": "static_cast<size_t>(value)",
          "new_api": null,
          "old_text": "static_cast<size_t>(value)",
          "new_text": null,
          "old_line_content": "      *result = static_cast<size_t>(value);",
          "new_line_content": "    if (value >= 0) {",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": "Significand",
          "new_api": null,
          "old_text": "d.Significand()",
          "new_text": null,
          "old_line_content": "    bits = d.Significand() >> -exponent;",
          "new_line_content": "    if (exponent <= -base::Double::kSignificandSize) return 0;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 20,
      "total_additions": 39,
      "total_deletions": 39,
      "total_api_changes": 98
    },
    "non_api_changes": {
      "has_non_api_changes": false,
      "evidence": {
        "total_diff_lines": 5,
        "api_related_lines": 98,
        "non_api_lines": 0,
        "non_api_line_numbers": []
      }
    },
    "api_calls_before": 99,
    "api_calls_after": 99,
    "diff_info": {
      "added_lines": 4,
      "removed_lines": 3,
      "total_diff_lines": 20
    }
  }
}