diff --git a/src/compiler/backend/register-allocator.cc b/src/compiler/backend/register-allocator.cc
index 738c1d92e49..e6a16a8e743 100644
--- a/src/compiler/backend/register-allocator.cc
+++ b/src/compiler/backend/register-allocator.cc
@@ -4644,6 +4644,14 @@ void OperandAssigner::AssignSpillSlots() {
   }
 
   // Now merge *all* disjoint, non-empty `SpillRange`s.
+  // Formerly, this merging was O(n^2) in the number of `SpillRange`s, which
+  // then dominated compile time (>40%) for some pathological cases,
+  // e.g., https://crbug.com/v8/14133.
+  // Now, we allow only `kMaxRetries` unsuccessful merges with directly
+  // following `SpillRange`s. After each `kMaxRetries`, we exponentially
+  // increase the stride, which limits the inner loop to O(log n) and thus
+  // the overall merging to O(n * log n).
+
   // The merging above may have left some `SpillRange`s empty, remove them.
   SpillRange** end_nonempty =
       std::remove_if(spill_ranges.begin(), spill_ranges.end(),
@@ -4653,13 +4661,19 @@ void OperandAssigner::AssignSpillSlots() {
     data()->tick_counter()->TickAndMaybeEnterSafepoint();
     SpillRange* range = *range_it;
     DCHECK(!range->IsEmpty());
+    constexpr size_t kMaxRetries = 1000;
+    size_t retries = kMaxRetries;
+    size_t stride = 1;
     for (SpillRange** other_it = range_it + 1; other_it < end_nonempty;
-         ++other_it) {
+         other_it += stride) {
       SpillRange* other = *other_it;
       DCHECK(!other->IsEmpty());
       if (range->TryMerge(other)) {
         DCHECK(other->IsEmpty());
         std::iter_swap(other_it, --end_nonempty);
+      } else if (--retries == 0) {
+        retries = kMaxRetries;
+        stride *= 2;
       }
     }
   }
