{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/ac9f18274676baab2dc90c6f9431738c6e9c17d5",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/ac9f18274676baab2dc90c6f9431738c6e9c17d5/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/ac9f18274676baab2dc90c6f9431738c6e9c17d5/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/ac9f18274676baab2dc90c6f9431738c6e9c17d5/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": true,
    "api_changes": {
      "replacements": [
        {
          "line": 2200,
          "old_api": "InstructionBlockAt",
          "new_api": "predecessors",
          "old_text": "GetLastInstruction(\n        code(), code()->InstructionBlockAt(block->predecessors()[0]))",
          "new_text": "block->predecessors()",
          "old_line_content": "    Instruction* instr = GetLastInstruction(",
          "new_line_content": "    const InstructionBlock::Predecessors& predecessors = block->predecessors();",
          "content_same": false
        },
        {
          "line": 2202,
          "old_api": "GetParallelMove",
          "new_api": "InstructionBlockAt",
          "old_text": "instr->GetParallelMove(Instruction::END)",
          "new_text": "code()->InstructionBlockAt(predecessors[0])",
          "old_line_content": "    for (MoveOperands* move : *instr->GetParallelMove(Instruction::END)) {",
          "new_line_content": "        code()->InstructionBlockAt(predecessors[0]);",
          "content_same": false
        },
        {
          "line": 2203,
          "old_api": "destination",
          "new_api": "code",
          "old_text": "move->destination()",
          "new_text": "code()",
          "old_line_content": "      InstructionOperand& to = move->destination();",
          "new_line_content": "    const Instruction* instr = GetLastInstruction(code(), predecessor_block);",
          "content_same": false
        },
        {
          "line": 2204,
          "old_api": "IsUnallocated",
          "new_api": "IsDeferred",
          "old_text": "to.IsUnallocated()",
          "new_text": "predecessor_block->IsDeferred()",
          "old_line_content": "      if (to.IsUnallocated() &&",
          "new_line_content": "    if (predecessor_block->IsDeferred()) {",
          "content_same": false
        },
        {
          "line": 2206,
          "old_api": "source",
          "new_api": "size",
          "old_text": "move->source()",
          "new_text": "predecessors.size()",
          "old_line_content": "        hint = &move->source();",
          "new_line_content": "      for (size_t i = 1; i < predecessors.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2214,
          "old_api": "UsePosition::HintTypeForOperand(*hint)",
          "new_api": "DCHECK_NOT_NULL",
          "old_text": "UsePosition::HintTypeForOperand(*hint)",
          "new_text": "DCHECK_NOT_NULL(instr)",
          "old_line_content": "                                  UsePosition::HintTypeForOperand(*hint));",
          "new_line_content": "    DCHECK_NOT_NULL(instr);",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": "first_instruction_index",
          "new_api": "output",
          "old_text": "block->first_instruction_index()",
          "new_text": "phi->output()",
          "old_line_content": "      block->first_instruction_index());",
          "new_line_content": "    UsePosition* use_pos = Define(block_start, &phi->output(), hint,",
          "content_same": false
        },
        {
          "line": 2228,
          "old_api": "NextFullStart",
          "new_api": "UsePosition::HintTypeForOperand(*hint)",
          "old_text": "LifetimePosition::GapFromInstructionIndex(\n                             code()->LastLoopInstructionIndex(block))\n                             .NextFullStart()",
          "new_text": "UsePosition::HintTypeForOperand(*hint)",
          "old_line_content": "  LifetimePosition end = LifetimePosition::GapFromInstructionIndex(",
          "new_line_content": "                                  UsePosition::HintTypeForOperand(*hint));",
          "content_same": false
        },
        {
          "line": 2229,
          "old_api": "LastLoopInstructionIndex",
          "new_api": "MapPhiHint",
          "old_text": "code()->LastLoopInstructionIndex(block)",
          "new_text": "MapPhiHint(hint, use_pos)",
          "old_line_content": "                             code()->LastLoopInstructionIndex(block))",
          "new_line_content": "    MapPhiHint(hint, use_pos);",
          "content_same": false
        },
        {
          "line": 2240,
          "old_api": "Union",
          "new_api": "first_instruction_index",
          "old_text": "live_in_sets()[i]->Union(*live)",
          "new_text": "LifetimePosition::GapFromInstructionIndex(\n      block->first_instruction_index())",
          "old_line_content": "    live_in_sets()[i]->Union(*live);",
          "new_line_content": "  LifetimePosition start = LifetimePosition::GapFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 2247,
          "old_api": "InstructionBlockCount",
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": "code()->InstructionBlockCount()",
          "new_text": "data()->GetOrCreateLiveRangeFor(operand_index)",
          "old_line_content": "  for (int block_id = code()->InstructionBlockCount() - 1; block_id >= 0;",
          "new_line_content": "    TopLevelLiveRange* range = data()->GetOrCreateLiveRangeFor(operand_index);",
          "content_same": false
        },
        {
          "line": 2254,
          "old_api": "AddInitialIntervals",
          "new_api": "Union",
          "old_text": "AddInitialIntervals(block, live)",
          "new_text": "live_in_sets()[i]->Union(*live)",
          "old_line_content": "    AddInitialIntervals(block, live);",
          "new_line_content": "    live_in_sets()[i]->Union(*live);",
          "content_same": false
        },
        {
          "line": 2276,
          "old_api": "GetSpillOperand",
          "new_api": "ProcessLoopHeader",
          "old_text": "range->GetSpillOperand()->IsConstant()",
          "new_text": "ProcessLoopHeader(block, live)",
          "old_line_content": "    if (range->HasSpillOperand() && range->GetSpillOperand()->IsConstant()) {",
          "new_line_content": "    if (block->IsLoopHeader()) ProcessLoopHeader(block, live);",
          "content_same": false
        },
        {
          "line": 2277,
          "old_api": "first_pos",
          "new_api": "live_in_sets",
          "old_text": "range->first_pos()",
          "new_text": "live_in_sets()",
          "old_line_content": "      for (UsePosition* pos = range->first_pos(); pos != nullptr;",
          "new_line_content": "    live_in_sets()[block_id] = live;",
          "content_same": false
        },
        {
          "line": 2292,
          "old_api": "HasSpillRange",
          "new_api": "next",
          "old_text": "range->HasSpillRange()",
          "new_text": "pos->next()",
          "old_line_content": "    SpillRange* spill = range->HasSpillRange()",
          "new_line_content": "           pos = pos->next()) {",
          "content_same": false
        },
        {
          "line": 2293,
          "old_api": "GetSpillRange",
          "new_api": "type",
          "old_text": "range->GetSpillRange()",
          "new_text": "pos->type()",
          "old_line_content": "                            ? range->GetSpillRange()",
          "new_line_content": "        if (pos->type() == UsePositionType::kRequiresSlot) continue;",
          "content_same": false
        },
        {
          "line": 2306,
          "old_api": "std::make_pair(operand, use_pos)",
          "new_api": "HasSpillRange",
          "old_text": "std::make_pair(operand, use_pos)",
          "new_text": "range->HasSpillRange()",
          "old_line_content": "  auto res = phi_hints_.insert(std::make_pair(operand, use_pos));",
          "new_line_content": "    SpillRange* spill = range->HasSpillRange()",
          "content_same": false
        },
        {
          "line": 2307,
          "old_api": "DCHECK",
          "new_api": "GetSpillRange",
          "old_text": "DCHECK(res.second)",
          "new_text": "range->GetSpillRange()",
          "old_line_content": "  DCHECK(res.second);",
          "new_line_content": "                            ? range->GetSpillRange()",
          "content_same": false
        },
        {
          "line": 2308,
          "old_api": "USE",
          "new_api": "AssignSpillRangeToLiveRange",
          "old_text": "USE(res)",
          "new_text": "data()->AssignSpillRangeToLiveRange(range)",
          "old_line_content": "  USE(res);",
          "new_line_content": "                            : data()->AssignSpillRangeToLiveRange(range);",
          "content_same": false
        },
        {
          "line": 2337,
          "old_api": "config",
          "new_api": "IsResolved",
          "old_text": "data->config()",
          "new_text": "hint.second->IsResolved()",
          "old_line_content": "          GetAllocatableRegisterCount(data->config(), kind)),",
          "new_line_content": "    CHECK(hint.second->IsResolved());",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": "config",
          "new_api": "live_ranges",
          "old_text": "data->config()",
          "new_text": "data()->live_ranges()",
          "old_line_content": "          GetAllocatableRegisterCodes(data->config(), kind)) {}",
          "new_line_content": "  for (TopLevelLiveRange* current : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2358,
          "old_api": "live_ranges",
          "new_api": "LifetimePosition::Invalid()",
          "old_text": "data()->live_ranges()",
          "new_text": "LifetimePosition::Invalid()",
          "old_line_content": "    TopLevelLiveRange* range = data()->live_ranges()[i];",
          "new_line_content": "  LifetimePosition ret = LifetimePosition::Invalid();",
          "content_same": false
        },
        {
          "line": 2360,
          "old_api": "HasSpillRange",
          "new_api": "LifetimePosition::GapFromInstructionIndex(instruction_index)",
          "old_text": "range->HasSpillRange()",
          "new_text": "LifetimePosition::GapFromInstructionIndex(instruction_index)",
          "old_line_content": "    if (range->HasNoSpillType() || (operands_only && range->HasSpillRange())) {",
          "new_line_content": "  ret = LifetimePosition::GapFromInstructionIndex(instruction_index);",
          "content_same": false
        },
        {
          "line": 2379,
          "old_api": "ToInstructionIndex",
          "new_api": "TopLevel",
          "old_text": "GetSplitPositionForInstruction(\n          range, pos->pos().ToInstructionIndex())",
          "new_text": "TRACE(\"Live range %d:%d is defined by a spill operand.\\n\",\n          range->TopLevel()->vreg(), range->relative_id())",
          "old_line_content": "      LifetimePosition split_pos = GetSplitPositionForInstruction(",
          "new_line_content": "    TRACE(\"Live range %d:%d is defined by a spill operand.\\n\",",
          "content_same": false
        },
        {
          "line": 2380,
          "old_api": "ToInstructionIndex",
          "new_api": "relative_id",
          "old_text": "pos->pos().ToInstructionIndex()",
          "new_text": "range->relative_id()",
          "old_line_content": "          range, pos->pos().ToInstructionIndex());",
          "new_line_content": "          range->TopLevel()->vreg(), range->relative_id());",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": "IsValid",
          "new_api": "IsGapPosition",
          "old_text": "split_pos.IsValid()",
          "new_text": "next_pos.IsGapPosition()",
          "old_line_content": "      if (!split_pos.IsValid()) continue;",
          "new_line_content": "    if (next_pos.IsGapPosition()) {",
          "content_same": false
        },
        {
          "line": 2385,
          "old_api": "NextFullStart",
          "new_api": "NextUsePositionRegisterIsBeneficial",
          "old_text": "range->Start().NextFullStart()",
          "new_text": "range->NextUsePositionRegisterIsBeneficial(next_pos)",
          "old_line_content": "          FindOptimalSplitPos(range->Start().NextFullStart(), split_pos);",
          "new_line_content": "    UsePosition* pos = range->NextUsePositionRegisterIsBeneficial(next_pos);",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": "TopLevel",
          "new_api": "IsValid",
          "old_text": "range->TopLevel()->IsFixed()",
          "new_text": "split_pos.IsValid()",
          "old_line_content": "  DCHECK(!range->TopLevel()->IsFixed());",
          "new_line_content": "      if (!split_pos.IsValid()) continue;",
          "content_same": false
        },
        {
          "line": 2418,
          "old_api": "value",
          "new_api": "IsGapPosition",
          "old_text": "start.value()",
          "new_text": "pos.IsGapPosition()",
          "old_line_content": "        range->TopLevel()->vreg(), range->relative_id(), start.value(),",
          "new_line_content": "  DCHECK(pos.IsStart() || pos.IsGapPosition() ||",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": "value",
          "new_api": "code",
          "old_text": "end.value()",
          "new_text": "code()",
          "old_line_content": "        end.value());",
          "new_line_content": "         (GetInstructionBlock(code(), pos)->last_instruction_index() !=",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": "DCHECK",
          "new_api": "allocation_zone",
          "old_text": "DCHECK(split_pos >= start)",
          "new_text": "allocation_zone()",
          "old_line_content": "  DCHECK(split_pos >= start);",
          "new_line_content": "  LiveRange* result = range->SplitAt(pos, allocation_zone());",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": "ToInstructionIndex",
          "new_api": "TopLevel",
          "old_text": "end.ToInstructionIndex()",
          "new_text": "range->TopLevel()->IsFixed()",
          "old_line_content": "  int end_instr = end.ToInstructionIndex();",
          "new_line_content": "  DCHECK(!range->TopLevel()->IsFixed());",
          "content_same": false
        },
        {
          "line": 2431,
          "old_api": "DCHECK",
          "new_api": "value",
          "old_text": "DCHECK(start_instr <= end_instr)",
          "new_text": "TRACE(\"Splitting live range %d:%d in position between [%d, %d]\\n\",\n        range->TopLevel()->vreg(), range->relative_id(), start.value(),\n        end.value())",
          "old_line_content": "  DCHECK(start_instr <= end_instr);",
          "new_line_content": "  TRACE(\"Splitting live range %d:%d in position between [%d, %d]\\n\",",
          "content_same": false
        },
        {
          "line": 2436,
          "old_api": "code",
          "new_api": "DCHECK",
          "old_text": "code()",
          "new_text": "DCHECK(split_pos >= start)",
          "old_line_content": "  const InstructionBlock* start_block = GetInstructionBlock(code(), start);",
          "new_line_content": "  DCHECK(split_pos >= start);",
          "content_same": false
        },
        {
          "line": 2437,
          "old_api": "code",
          "new_api": "SplitRangeAt",
          "old_text": "code()",
          "new_text": "SplitRangeAt(range, split_pos)",
          "old_line_content": "  const InstructionBlock* end_block = GetInstructionBlock(code(), end);",
          "new_line_content": "  return SplitRangeAt(range, split_pos);",
          "content_same": false
        },
        {
          "line": 2450,
          "old_api": "ToInt",
          "new_api": "code",
          "old_text": "start_block->rpo_number().ToInt()",
          "new_text": "code()",
          "old_line_content": "        loop->rpo_number().ToInt() <= start_block->rpo_number().ToInt()) {",
          "new_line_content": "  const InstructionBlock* start_block = GetInstructionBlock(code(), start);",
          "content_same": false
        },
        {
          "line": 2462,
          "old_api": "first_instruction_index",
          "new_api": "code",
          "old_text": "block->first_instruction_index()",
          "new_text": "code()",
          "old_line_content": "      block->first_instruction_index());",
          "new_line_content": "    const InstructionBlock* loop = GetContainingLoop(code(), block);",
          "content_same": false
        },
        {
          "line": 2475,
          "old_api": "PreviousUsePositionRegisterIsBeneficial",
          "new_api": "first_instruction_index",
          "old_text": "range->PreviousUsePositionRegisterIsBeneficial(pos)",
          "new_text": "LifetimePosition::GapFromInstructionIndex(\n      block->first_instruction_index())",
          "old_line_content": "      range->PreviousUsePositionRegisterIsBeneficial(pos);",
          "new_line_content": "  return LifetimePosition::GapFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 2482,
          "old_api": "first_instruction_index",
          "new_api": "Start",
          "old_text": "loop_header->first_instruction_index()",
          "new_text": "pos.Start()",
          "old_line_content": "        loop_header->first_instruction_index());",
          "new_line_content": "  const InstructionBlock* block = GetInstructionBlock(code(), pos.Start());",
          "content_same": false
        },
        {
          "line": 2484,
          "old_api": "Covers",
          "new_api": "code",
          "old_text": "range->Covers(loop_start)",
          "new_text": "code()",
          "old_line_content": "    if (range->Covers(loop_start)) {",
          "new_line_content": "      block->IsLoopHeader() ? block : GetContainingLoop(code(), block);",
          "content_same": false
        },
        {
          "line": 2514,
          "old_api": "fixed_live_ranges",
          "new_api": "spilled",
          "old_text": "data()->fixed_live_ranges()",
          "new_text": "range->spilled()",
          "old_line_content": "                                    : data()->fixed_live_ranges();",
          "new_line_content": "  DCHECK(!range->spilled());",
          "content_same": false
        },
        {
          "line": 2519,
          "old_api": "mode",
          "new_api": "AssignSpillRangeToLiveRange",
          "old_text": "mode()",
          "new_text": "data()->AssignSpillRangeToLiveRange(first)",
          "old_line_content": "  if (mode() == GENERAL_REGISTERS) {",
          "new_line_content": "    data()->AssignSpillRangeToLiveRange(first);",
          "content_same": false
        },
        {
          "line": 2533,
          "old_api": "reserve",
          "new_api": "mode",
          "old_text": "unhandled_live_ranges().reserve(\n      static_cast<size_t>(code()->VirtualRegisterCount() * 2))",
          "new_text": "mode()",
          "old_line_content": "  unhandled_live_ranges().reserve(",
          "new_line_content": "  if (mode() == GENERAL_REGISTERS) {",
          "content_same": false
        },
        {
          "line": 2534,
          "old_api": "VirtualRegisterCount",
          "new_api": "config",
          "old_text": "code()->VirtualRegisterCount()",
          "new_text": "data()->config()->GetGeneralRegisterName(register_code)",
          "old_line_content": "      static_cast<size_t>(code()->VirtualRegisterCount() * 2));",
          "new_line_content": "    return data()->config()->GetGeneralRegisterName(register_code);",
          "content_same": false
        },
        {
          "line": 2536,
          "old_api": "reserve",
          "new_api": "config",
          "old_text": "inactive_live_ranges().reserve(8)",
          "new_text": "data()->config()->GetDoubleRegisterName(register_code)",
          "old_line_content": "  inactive_live_ranges().reserve(8);",
          "new_line_content": "    return data()->config()->GetDoubleRegisterName(register_code);",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": "empty",
          "new_api": "reserve",
          "old_text": "inactive_live_ranges().empty()",
          "new_text": "unhandled_live_ranges().reserve(\n      static_cast<size_t>(code()->VirtualRegisterCount() * 2))",
          "old_line_content": "  DCHECK(inactive_live_ranges().empty());",
          "new_line_content": "  unhandled_live_ranges().reserve(",
          "content_same": false
        },
        {
          "line": 2549,
          "old_api": "VirtualRegisterCount",
          "new_api": "reserve",
          "old_text": "code()->VirtualRegisterCount()",
          "new_text": "active_live_ranges().reserve(8)",
          "old_line_content": "  SplitAndSpillRangesDefinedByMemoryOperand(code()->VirtualRegisterCount() <=",
          "new_line_content": "  active_live_ranges().reserve(8);",
          "content_same": false
        },
        {
          "line": 2550,
          "old_api": "num_allocatable_registers",
          "new_api": "reserve",
          "old_text": "num_allocatable_registers()",
          "new_text": "inactive_live_ranges().reserve(8)",
          "old_line_content": "                                            num_allocatable_registers());",
          "new_line_content": "  inactive_live_ranges().reserve(8);",
          "content_same": false
        },
        {
          "line": 2553,
          "old_api": "CanProcessRange",
          "new_api": "data",
          "old_text": "CanProcessRange(range)",
          "new_text": "DCHECK(RegisterConfiguration::kMaxDoubleRegisters >=\n         this->data()->config()->num_general_registers())",
          "old_line_content": "    if (!CanProcessRange(range)) continue;",
          "new_line_content": "  DCHECK(RegisterConfiguration::kMaxDoubleRegisters >=",
          "content_same": false
        },
        {
          "line": 2561,
          "old_api": "SortUnhandled",
          "new_api": "empty",
          "old_text": "SortUnhandled()",
          "new_text": "inactive_live_ranges().empty()",
          "old_line_content": "  SortUnhandled();",
          "new_line_content": "  DCHECK(inactive_live_ranges().empty());",
          "content_same": false
        },
        {
          "line": 2564,
          "old_api": "GetFixedRegisters",
          "new_api": "num_allocatable_registers",
          "old_text": "GetFixedRegisters()",
          "new_text": "num_allocatable_registers()",
          "old_line_content": "  auto& fixed_ranges = GetFixedRegisters();",
          "new_line_content": "                                            num_allocatable_registers());",
          "content_same": false
        },
        {
          "line": 2567,
          "old_api": "kind",
          "new_api": "CanProcessRange",
          "old_text": "current->kind()",
          "new_text": "CanProcessRange(range)",
          "old_line_content": "      DCHECK_EQ(mode(), current->kind());",
          "new_line_content": "    if (!CanProcessRange(range)) continue;",
          "content_same": false
        },
        {
          "line": 2575,
          "old_api": "pop_back",
          "new_api": "SortUnhandled",
          "old_text": "unhandled_live_ranges().pop_back()",
          "new_text": "SortUnhandled()",
          "old_line_content": "    unhandled_live_ranges().pop_back();",
          "new_line_content": "  SortUnhandled();",
          "content_same": false
        },
        {
          "line": 2581,
          "old_api": "TopLevel",
          "new_api": "kind",
          "old_text": "current->TopLevel()->vreg()",
          "new_text": "current->kind()",
          "old_line_content": "    TRACE(\"Processing interval %d:%d start=%d\\n\", current->TopLevel()->vreg(),",
          "new_line_content": "      DCHECK_EQ(mode(), current->kind());",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": "value",
          "new_api": "AddToInactive",
          "old_text": "position.value()",
          "new_text": "AddToInactive(current)",
          "old_line_content": "          current->relative_id(), position.value());",
          "new_line_content": "      AddToInactive(current);",
          "content_same": false
        },
        {
          "line": 2587,
          "old_api": "size",
          "new_api": "UnhandledIsSorted",
          "old_text": "active_live_ranges().size()",
          "new_text": "UnhandledIsSorted()",
          "old_line_content": "    for (size_t i = 0; i < active_live_ranges().size(); ++i) {",
          "new_line_content": "    DCHECK(UnhandledIsSorted());",
          "content_same": false
        },
        {
          "line": 2588,
          "old_api": "active_live_ranges",
          "new_api": "back",
          "old_text": "active_live_ranges()",
          "new_text": "unhandled_live_ranges().back()",
          "old_line_content": "      LiveRange* cur_active = active_live_ranges()[i];",
          "new_line_content": "    LiveRange* current = unhandled_live_ranges().back();",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": "End",
          "new_api": "pop_back",
          "old_text": "cur_active->End()",
          "new_text": "unhandled_live_ranges().pop_back()",
          "old_line_content": "      if (cur_active->End() <= position) {",
          "new_line_content": "    unhandled_live_ranges().pop_back();",
          "content_same": false
        },
        {
          "line": 2590,
          "old_api": "ActiveToHandled",
          "new_api": "UnhandledIsSorted",
          "old_text": "ActiveToHandled(cur_active)",
          "new_text": "UnhandledIsSorted()",
          "old_line_content": "        ActiveToHandled(cur_active);",
          "new_line_content": "    DCHECK(UnhandledIsSorted());",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": "size",
          "new_api": "TopLevel",
          "old_text": "inactive_live_ranges().size()",
          "new_text": "current->TopLevel()",
          "old_line_content": "    for (size_t i = 0; i < inactive_live_ranges().size(); ++i) {",
          "new_line_content": "    if (current->IsTopLevel() && TryReuseSpillForPhi(current->TopLevel()))",
          "content_same": false
        },
        {
          "line": 2601,
          "old_api": "InactiveToHandled",
          "new_api": "size",
          "old_text": "InactiveToHandled(cur_inactive)",
          "new_text": "active_live_ranges().size()",
          "old_line_content": "        InactiveToHandled(cur_inactive);",
          "new_line_content": "    for (size_t i = 0; i < active_live_ranges().size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": "Covers",
          "new_api": "End",
          "old_text": "cur_inactive->Covers(position)",
          "new_text": "cur_active->End()",
          "old_line_content": "      } else if (cur_inactive->Covers(position)) {",
          "new_line_content": "      if (cur_active->End() <= position) {",
          "content_same": false
        },
        {
          "line": 2604,
          "old_api": "InactiveToActive",
          "new_api": "ActiveToHandled",
          "old_text": "InactiveToActive(cur_inactive)",
          "new_text": "ActiveToHandled(cur_active)",
          "old_line_content": "        InactiveToActive(cur_inactive);",
          "new_line_content": "        ActiveToHandled(cur_active);",
          "content_same": false
        },
        {
          "line": 2612,
          "old_api": "AllocateBlockedReg",
          "new_api": "size",
          "old_text": "AllocateBlockedReg(current)",
          "new_text": "inactive_live_ranges().size()",
          "old_line_content": "    if (!result) AllocateBlockedReg(current);",
          "new_line_content": "    for (size_t i = 0; i < inactive_live_ranges().size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2613,
          "old_api": "HasRegisterAssigned",
          "new_api": "inactive_live_ranges",
          "old_text": "current->HasRegisterAssigned()",
          "new_text": "inactive_live_ranges()",
          "old_line_content": "    if (current->HasRegisterAssigned()) {",
          "new_line_content": "      LiveRange* cur_inactive = inactive_live_ranges()[i];",
          "content_same": false
        },
        {
          "line": 2614,
          "old_api": "AddToActive",
          "new_api": "End",
          "old_text": "AddToActive(current)",
          "new_text": "cur_inactive->End()",
          "old_line_content": "      AddToActive(current);",
          "new_line_content": "      if (cur_inactive->End() <= position) {",
          "content_same": false
        },
        {
          "line": 2623,
          "old_api": "set_assigned_register",
          "new_api": "spilled",
          "old_text": "range->set_assigned_register(reg)",
          "new_text": "current->spilled()",
          "old_line_content": "  range->set_assigned_register(reg);",
          "new_line_content": "    DCHECK(!current->HasRegisterAssigned() && !current->spilled());",
          "content_same": false
        },
        {
          "line": 2625,
          "old_api": "TopLevel",
          "new_api": "TryAllocateFreeReg",
          "old_text": "range->TopLevel()->is_phi()",
          "new_text": "TryAllocateFreeReg(current)",
          "old_line_content": "  if (range->IsTopLevel() && range->TopLevel()->is_phi()) {",
          "new_line_content": "    bool result = TryAllocateFreeReg(current);",
          "content_same": false
        },
        {
          "line": 2626,
          "old_api": "TopLevel",
          "new_api": "AllocateBlockedReg",
          "old_text": "range->TopLevel()",
          "new_text": "AllocateBlockedReg(current)",
          "old_line_content": "    data()->GetPhiMapValueFor(range->TopLevel())->set_assigned_register(reg);",
          "new_line_content": "    if (!result) AllocateBlockedReg(current);",
          "content_same": false
        },
        {
          "line": 2640,
          "old_api": "relative_id",
          "new_api": "TopLevel",
          "old_text": "range->relative_id()",
          "new_text": "range->TopLevel()",
          "old_line_content": "        range->relative_id());",
          "new_line_content": "    data()->GetPhiMapValueFor(range->TopLevel())->set_assigned_register(reg);",
          "content_same": false
        },
        {
          "line": 2646,
          "old_api": "IsEmpty",
          "new_api": "TopLevel",
          "old_text": "range->IsEmpty()",
          "new_text": "range->TopLevel()->vreg()",
          "old_line_content": "  if (range == nullptr || range->IsEmpty()) return;",
          "new_line_content": "  TRACE(\"Add live range %d:%d to active\\n\", range->TopLevel()->vreg(),",
          "content_same": false
        },
        {
          "line": 2647,
          "old_api": "spilled",
          "new_api": "relative_id",
          "old_text": "range->spilled()",
          "new_text": "range->relative_id()",
          "old_line_content": "  DCHECK(!range->HasRegisterAssigned() && !range->spilled());",
          "new_line_content": "        range->relative_id());",
          "content_same": false
        },
        {
          "line": 2648,
          "old_api": "Start",
          "new_api": "push_back",
          "old_text": "range->Start()",
          "new_text": "active_live_ranges().push_back(range)",
          "old_line_content": "  DCHECK(allocation_finger_ <= range->Start());",
          "new_line_content": "  active_live_ranges().push_back(range);",
          "content_same": false
        },
        {
          "line": 2655,
          "old_api": "begin",
          "new_api": "push_back",
          "old_text": "unhandled_live_ranges().begin()",
          "new_text": "inactive_live_ranges().push_back(range)",
          "old_line_content": "    auto it = unhandled_live_ranges().begin() + (i + 1);",
          "new_line_content": "  inactive_live_ranges().push_back(range);",
          "content_same": false
        },
        {
          "line": 2660,
          "old_api": "TopLevel",
          "new_api": "IsEmpty",
          "old_text": "TRACE(\"Add live range %d:%d to unhandled at start\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "new_text": "range->IsEmpty()",
          "old_line_content": "  TRACE(\"Add live range %d:%d to unhandled at start\\n\",",
          "new_line_content": "  if (range == nullptr || range->IsEmpty()) return;",
          "content_same": false
        },
        {
          "line": 2661,
          "old_api": "relative_id",
          "new_api": "spilled",
          "old_text": "range->relative_id()",
          "new_text": "range->spilled()",
          "old_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "new_line_content": "  DCHECK(!range->HasRegisterAssigned() && !range->spilled());",
          "content_same": false
        },
        {
          "line": 2662,
          "old_api": "begin",
          "new_api": "Start",
          "old_text": "unhandled_live_ranges().begin()",
          "new_text": "range->Start()",
          "old_line_content": "  unhandled_live_ranges().insert(unhandled_live_ranges().begin(), range);",
          "new_line_content": "  DCHECK(allocation_finger_ <= range->Start());",
          "content_same": false
        },
        {
          "line": 2663,
          "old_api": "UnhandledIsSorted",
          "new_api": "size",
          "old_text": "UnhandledIsSorted()",
          "new_text": "unhandled_live_ranges().size()",
          "old_line_content": "  DCHECK(UnhandledIsSorted());",
          "new_line_content": "  for (int i = static_cast<int>(unhandled_live_ranges().size() - 1); i >= 0;",
          "content_same": false
        },
        {
          "line": 2668,
          "old_api": "IsEmpty",
          "new_api": "relative_id",
          "old_text": "range->IsEmpty()",
          "new_text": "range->relative_id()",
          "old_line_content": "  if (range == nullptr || range->IsEmpty()) return;",
          "new_line_content": "          range->TopLevel()->vreg(), range->relative_id(), i + 1);",
          "content_same": false
        },
        {
          "line": 2669,
          "old_api": "spilled",
          "new_api": "begin",
          "old_text": "range->spilled()",
          "new_text": "unhandled_live_ranges().begin()",
          "old_line_content": "  DCHECK(!range->HasRegisterAssigned() && !range->spilled());",
          "new_line_content": "    auto it = unhandled_live_ranges().begin() + (i + 1);",
          "content_same": false
        },
        {
          "line": 2670,
          "old_api": "TopLevel",
          "new_api": "insert",
          "old_text": "TRACE(\"Add live range %d:%d to unhandled unsorted at end\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "new_text": "unhandled_live_ranges().insert(it, range)",
          "old_line_content": "  TRACE(\"Add live range %d:%d to unhandled unsorted at end\\n\",",
          "new_line_content": "    unhandled_live_ranges().insert(it, range);",
          "content_same": false
        },
        {
          "line": 2671,
          "old_api": "relative_id",
          "new_api": "UnhandledIsSorted",
          "old_text": "range->relative_id()",
          "new_text": "UnhandledIsSorted()",
          "old_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "new_line_content": "    DCHECK(UnhandledIsSorted());",
          "content_same": false
        },
        {
          "line": 2677,
          "old_api": "ShouldBeAllocatedBefore",
          "new_api": "UnhandledIsSorted",
          "old_text": "b->ShouldBeAllocatedBefore(a)",
          "new_text": "UnhandledIsSorted()",
          "old_line_content": "  DCHECK(!a->ShouldBeAllocatedBefore(b) || !b->ShouldBeAllocatedBefore(a));",
          "new_line_content": "  DCHECK(UnhandledIsSorted());",
          "content_same": false
        },
        {
          "line": 2713,
          "old_api": "active_live_ranges",
          "new_api": "Start",
          "old_text": "active_live_ranges()",
          "new_text": "b->Start()",
          "old_line_content": "  RemoveElement(&active_live_ranges(), range);",
          "new_line_content": "    if (a->Start() < b->Start()) return false;",
          "content_same": false
        },
        {
          "line": 2721,
          "old_api": "inactive_live_ranges",
          "new_api": "TopLevel",
          "old_text": "inactive_live_ranges()",
          "new_text": "TRACE(\"Moving live range %d:%d from active to handled\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "old_line_content": "  RemoveElement(&inactive_live_ranges(), range);",
          "new_line_content": "  TRACE(\"Moving live range %d:%d from active to handled\\n\",",
          "content_same": false
        },
        {
          "line": 2722,
          "old_api": "TopLevel",
          "new_api": "relative_id",
          "old_text": "TRACE(\"Moving live range %d:%d from inactive to handled\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "new_text": "range->relative_id()",
          "old_line_content": "  TRACE(\"Moving live range %d:%d from inactive to handled\\n\",",
          "new_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "content_same": false
        },
        {
          "line": 2728,
          "old_api": "inactive_live_ranges",
          "new_api": "push_back",
          "old_text": "inactive_live_ranges()",
          "new_text": "inactive_live_ranges().push_back(range)",
          "old_line_content": "  RemoveElement(&inactive_live_ranges(), range);",
          "new_line_content": "  inactive_live_ranges().push_back(range);",
          "content_same": false
        },
        {
          "line": 2729,
          "old_api": "push_back",
          "new_api": "TopLevel",
          "old_text": "active_live_ranges().push_back(range)",
          "new_text": "TRACE(\"Moving live range %d:%d from active to inactive\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "old_line_content": "  active_live_ranges().push_back(range);",
          "new_line_content": "  TRACE(\"Moving live range %d:%d from active to inactive\\n\",",
          "content_same": false
        },
        {
          "line": 2730,
          "old_api": "TopLevel",
          "new_api": "relative_id",
          "old_text": "TRACE(\"Moving live range %d:%d from inactive to active\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "new_text": "range->relative_id()",
          "old_line_content": "  TRACE(\"Moving live range %d:%d from inactive to active\\n\",",
          "new_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "content_same": false
        },
        {
          "line": 2742,
          "old_api": "active_live_ranges",
          "new_api": "inactive_live_ranges",
          "old_text": "active_live_ranges()",
          "new_text": "inactive_live_ranges()",
          "old_line_content": "  for (LiveRange* cur_active : active_live_ranges()) {",
          "new_line_content": "  RemoveElement(&inactive_live_ranges(), range);",
          "content_same": false
        },
        {
          "line": 2743,
          "old_api": "assigned_register",
          "new_api": "push_back",
          "old_text": "cur_active->assigned_register()",
          "new_text": "active_live_ranges().push_back(range)",
          "old_line_content": "    free_until_pos[cur_active->assigned_register()] =",
          "new_line_content": "  active_live_ranges().push_back(range);",
          "content_same": false
        },
        {
          "line": 2744,
          "old_api": "LifetimePosition::GapFromInstructionIndex(0)",
          "new_api": "TopLevel",
          "old_text": "LifetimePosition::GapFromInstructionIndex(0)",
          "new_text": "TRACE(\"Moving live range %d:%d from inactive to active\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "old_line_content": "        LifetimePosition::GapFromInstructionIndex(0);",
          "new_line_content": "  TRACE(\"Moving live range %d:%d from inactive to active\\n\",",
          "content_same": false
        },
        {
          "line": 2745,
          "old_api": "value",
          "new_api": "relative_id",
          "old_text": "TRACE(\"Register %s is free until pos %d (1)\\n\",\n          RegisterName(cur_active->assigned_register()),\n          LifetimePosition::GapFromInstructionIndex(0).value())",
          "new_text": "range->relative_id()",
          "old_line_content": "    TRACE(\"Register %s is free until pos %d (1)\\n\",",
          "new_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "content_same": false
        },
        {
          "line": 2753,
          "old_api": "FirstIntersection",
          "new_api": "LifetimePosition::MaxPosition()",
          "old_text": "cur_inactive->FirstIntersection(current)",
          "new_text": "LifetimePosition::MaxPosition()",
          "old_line_content": "        cur_inactive->FirstIntersection(current);",
          "new_line_content": "    free_until_pos[i] = LifetimePosition::MaxPosition();",
          "content_same": false
        },
        {
          "line": 2756,
          "old_api": "Min",
          "new_api": "active_live_ranges",
          "old_text": "Min(free_until_pos[cur_reg], next_intersection)",
          "new_text": "active_live_ranges()",
          "old_line_content": "    free_until_pos[cur_reg] = Min(free_until_pos[cur_reg], next_intersection);",
          "new_line_content": "  for (LiveRange* cur_active : active_live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2757,
          "old_api": "RegisterName",
          "new_api": "assigned_register",
          "old_text": "RegisterName(cur_reg)",
          "new_text": "cur_active->assigned_register()",
          "old_line_content": "    TRACE(\"Register %s is free until pos %d (2)\\n\", RegisterName(cur_reg),",
          "new_line_content": "    free_until_pos[cur_active->assigned_register()] =",
          "content_same": false
        },
        {
          "line": 2758,
          "old_api": "value",
          "new_api": "LifetimePosition::GapFromInstructionIndex(0)",
          "old_text": "Min(free_until_pos[cur_reg], next_intersection).value()",
          "new_text": "LifetimePosition::GapFromInstructionIndex(0)",
          "old_line_content": "          Min(free_until_pos[cur_reg], next_intersection).value());",
          "new_line_content": "        LifetimePosition::GapFromInstructionIndex(0);",
          "content_same": false
        },
        {
          "line": 2765,
          "old_api": "value",
          "new_api": "Start",
          "old_text": "free_until_pos[hint_register].value()",
          "new_text": "current->Start()",
          "old_line_content": "        RegisterName(hint_register), free_until_pos[hint_register].value(),",
          "new_line_content": "    DCHECK(cur_inactive->End() > current->Start());",
          "content_same": false
        },
        {
          "line": 2767,
          "old_api": "value",
          "new_api": "FirstIntersection",
          "old_text": "current->End().value()",
          "new_text": "cur_inactive->FirstIntersection(current)",
          "old_line_content": "        current->End().value());",
          "new_line_content": "        cur_inactive->FirstIntersection(current);",
          "content_same": false
        },
        {
          "line": 2770,
          "old_api": "End",
          "new_api": "Min",
          "old_text": "current->End()",
          "new_text": "Min(free_until_pos[cur_reg], next_intersection)",
          "old_line_content": "    if (free_until_pos[hint_register] >= current->End()) {",
          "new_line_content": "    free_until_pos[cur_reg] = Min(free_until_pos[cur_reg], next_intersection);",
          "content_same": false
        },
        {
          "line": 2771,
          "old_api": "TopLevel",
          "new_api": "RegisterName",
          "old_text": "TRACE(\"Assigning preferred reg %s to live range %d:%d\\n\",\n            RegisterName(hint_register), current->TopLevel()->vreg(),\n            current->relative_id())",
          "new_text": "RegisterName(cur_reg)",
          "old_line_content": "      TRACE(\"Assigning preferred reg %s to live range %d:%d\\n\",",
          "new_line_content": "    TRACE(\"Register %s is free until pos %d (2)\\n\", RegisterName(cur_reg),",
          "content_same": false
        },
        {
          "line": 2772,
          "old_api": "TopLevel",
          "new_api": "value",
          "old_text": "current->TopLevel()->vreg()",
          "new_text": "Min(free_until_pos[cur_reg], next_intersection).value()",
          "old_line_content": "            RegisterName(hint_register), current->TopLevel()->vreg(),",
          "new_line_content": "          Min(free_until_pos[cur_reg], next_intersection).value());",
          "content_same": false
        },
        {
          "line": 2780,
          "old_api": "allocatable_register_code",
          "new_api": "relative_id",
          "old_text": "allocatable_register_code(0)",
          "new_text": "current->relative_id()",
          "old_line_content": "  int reg = allocatable_register_code(0);",
          "new_line_content": "        current->TopLevel()->vreg(), current->relative_id(),",
          "content_same": false
        },
        {
          "line": 2781,
          "old_api": "num_allocatable_registers",
          "new_api": "value",
          "old_text": "num_allocatable_registers()",
          "new_text": "current->End().value()",
          "old_line_content": "  for (int i = 1; i < num_allocatable_registers(); ++i) {",
          "new_line_content": "        current->End().value());",
          "content_same": false
        },
        {
          "line": 2795,
          "old_api": "End",
          "new_api": "num_allocatable_registers",
          "old_text": "current->End()",
          "new_text": "num_allocatable_registers()",
          "old_line_content": "  if (pos < current->End()) {",
          "new_line_content": "  for (int i = 1; i < num_allocatable_registers(); ++i) {",
          "content_same": false
        },
        {
          "line": 2804,
          "old_api": "End",
          "new_api": "Start",
          "old_text": "current->End()",
          "new_text": "current->Start()",
          "old_line_content": "  DCHECK(pos >= current->End());",
          "new_line_content": "  if (pos <= current->Start()) {",
          "content_same": false
        },
        {
          "line": 2818,
          "old_api": "Spill",
          "new_api": "End",
          "old_text": "Spill(current)",
          "new_text": "current->End()",
          "old_line_content": "    Spill(current);",
          "new_line_content": "  DCHECK(pos >= current->End());",
          "content_same": false
        },
        {
          "line": 2832,
          "old_api": "Start",
          "new_api": "Spill",
          "old_text": "current->Start()",
          "new_text": "Spill(current)",
          "old_line_content": "        !range->CanBeSpilled(current->Start())) {",
          "new_line_content": "    Spill(current);",
          "content_same": false
        },
        {
          "line": 2839,
          "old_api": "End",
          "new_api": "num_registers",
          "old_text": "range->End()",
          "new_text": "num_registers()",
          "old_line_content": "        use_pos[cur_reg] = range->End();",
          "new_line_content": "  for (int i = 0; i < num_registers(); i++) {",
          "content_same": false
        },
        {
          "line": 2846,
          "old_api": "inactive_live_ranges",
          "new_api": "Start",
          "old_text": "inactive_live_ranges()",
          "new_text": "current->Start()",
          "old_line_content": "  for (LiveRange* range : inactive_live_ranges()) {",
          "new_line_content": "        !range->CanBeSpilled(current->Start())) {",
          "content_same": false
        },
        {
          "line": 2848,
          "old_api": "FirstIntersection",
          "new_api": "LifetimePosition::GapFromInstructionIndex(0)",
          "old_text": "range->FirstIntersection(current)",
          "new_text": "LifetimePosition::GapFromInstructionIndex(0)",
          "old_line_content": "    LifetimePosition next_intersection = range->FirstIntersection(current);",
          "new_line_content": "          LifetimePosition::GapFromInstructionIndex(0);",
          "content_same": false
        },
        {
          "line": 2851,
          "old_api": "TopLevel",
          "new_api": "Start",
          "old_text": "range->TopLevel()->IsFixed()",
          "new_text": "current->Start()",
          "old_line_content": "    if (range->TopLevel()->IsFixed()) {",
          "new_line_content": "          range->NextUsePositionRegisterIsBeneficial(current->Start());",
          "content_same": false
        },
        {
          "line": 2853,
          "old_api": "Min",
          "new_api": "End",
          "old_text": "Min(block_pos[cur_reg], use_pos[cur_reg])",
          "new_text": "range->End()",
          "old_line_content": "      use_pos[cur_reg] = Min(block_pos[cur_reg], use_pos[cur_reg]);",
          "new_line_content": "        use_pos[cur_reg] = range->End();",
          "content_same": false
        },
        {
          "line": 2855,
          "old_api": "Min",
          "new_api": "pos",
          "old_text": "Min(use_pos[cur_reg], next_intersection)",
          "new_text": "next_use->pos()",
          "old_line_content": "      use_pos[cur_reg] = Min(use_pos[cur_reg], next_intersection);",
          "new_line_content": "        use_pos[cur_reg] = next_use->pos();",
          "content_same": false
        },
        {
          "line": 2860,
          "old_api": "num_allocatable_registers",
          "new_api": "inactive_live_ranges",
          "old_text": "num_allocatable_registers()",
          "new_text": "inactive_live_ranges()",
          "old_line_content": "  for (int i = 1; i < num_allocatable_registers(); ++i) {",
          "new_line_content": "  for (LiveRange* range : inactive_live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2861,
          "old_api": "allocatable_register_code",
          "new_api": "Start",
          "old_text": "allocatable_register_code(i)",
          "new_text": "current->Start()",
          "old_line_content": "    int code = allocatable_register_code(i);",
          "new_line_content": "    DCHECK(range->End() > current->Start());",
          "content_same": false
        },
        {
          "line": 2869,
          "old_api": "pos",
          "new_api": "Min",
          "old_text": "register_use->pos()",
          "new_text": "Min(use_pos[cur_reg], next_intersection)",
          "old_line_content": "  if (pos < register_use->pos()) {",
          "new_line_content": "      use_pos[cur_reg] = Min(use_pos[cur_reg], next_intersection);",
          "content_same": false
        },
        {
          "line": 2886,
          "old_api": "RegisterName",
          "new_api": "pos",
          "old_text": "RegisterName(reg)",
          "new_text": "register_use->pos()",
          "old_line_content": "  TRACE(\"Assigning blocked reg %s to live range %d:%d\\n\", RegisterName(reg),",
          "new_line_content": "    SpillBetween(current, current->Start(), register_use->pos());",
          "content_same": false
        },
        {
          "line": 2899,
          "old_api": "assigned_register",
          "new_api": "End",
          "old_text": "current->assigned_register()",
          "new_text": "current->End()",
          "old_line_content": "  int reg = current->assigned_register();",
          "new_line_content": "  DCHECK(block_pos[reg] >= current->End());",
          "content_same": false
        },
        {
          "line": 2900,
          "old_api": "Start",
          "new_api": "RegisterName",
          "old_text": "current->Start()",
          "new_text": "RegisterName(reg)",
          "old_line_content": "  LifetimePosition split_pos = current->Start();",
          "new_line_content": "  TRACE(\"Assigning blocked reg %s to live range %d:%d\\n\", RegisterName(reg),",
          "content_same": false
        },
        {
          "line": 2901,
          "old_api": "size",
          "new_api": "relative_id",
          "old_text": "active_live_ranges().size()",
          "new_text": "current->relative_id()",
          "old_line_content": "  for (size_t i = 0; i < active_live_ranges().size(); ++i) {",
          "new_line_content": "        current->TopLevel()->vreg(), current->relative_id());",
          "content_same": false
        },
        {
          "line": 2902,
          "old_api": "active_live_ranges",
          "new_api": "SetLiveRangeAssignedRegister",
          "old_text": "active_live_ranges()",
          "new_text": "SetLiveRangeAssignedRegister(current, reg)",
          "old_line_content": "    LiveRange* range = active_live_ranges()[i];",
          "new_line_content": "  SetLiveRangeAssignedRegister(current, reg);",
          "content_same": false
        },
        {
          "line": 2907,
          "old_api": "SpillAfter",
          "new_api": "SplitAndSpillIntersecting",
          "old_text": "SpillAfter(range, spill_pos)",
          "new_text": "SplitAndSpillIntersecting(current)",
          "old_line_content": "        SpillAfter(range, spill_pos);",
          "new_line_content": "  SplitAndSpillIntersecting(current);",
          "content_same": false
        },
        {
          "line": 2917,
          "old_api": "pos",
          "new_api": "assigned_register",
          "old_text": "next_pos->pos()",
          "new_text": "range->assigned_register()",
          "old_line_content": "        SpillBetweenUntil(range, spill_pos, current->Start(), next_pos->pos());",
          "new_line_content": "    if (range->assigned_register() == reg) {",
          "content_same": false
        },
        {
          "line": 2919,
          "old_api": "ActiveToHandled",
          "new_api": "FindOptimalSpillingPos",
          "old_text": "ActiveToHandled(range)",
          "new_text": "FindOptimalSpillingPos(range, split_pos)",
          "old_line_content": "      ActiveToHandled(range);",
          "new_line_content": "      LifetimePosition spill_pos = FindOptimalSpillingPos(range, split_pos);",
          "content_same": false
        },
        {
          "line": 2946,
          "old_api": "is_phi",
          "new_api": "SpillAfter",
          "old_text": "range->is_phi()",
          "new_text": "SpillAfter(range, split_pos)",
          "old_line_content": "  if (!range->is_phi()) return false;",
          "new_line_content": "          SpillAfter(range, split_pos);",
          "content_same": false
        },
        {
          "line": 2948,
          "old_api": "HasSpillOperand",
          "new_api": "pos",
          "old_text": "range->HasSpillOperand()",
          "new_text": "next_pos->pos()",
          "old_line_content": "  DCHECK(!range->HasSpillOperand());",
          "new_line_content": "          next_intersection = Min(next_intersection, next_pos->pos());",
          "content_same": false
        },
        {
          "line": 2951,
          "old_api": "phi",
          "new_api": "InactiveToHandled",
          "old_text": "phi_map_value->phi()",
          "new_text": "InactiveToHandled(range)",
          "old_line_content": "  const PhiInstruction* phi = phi_map_value->phi();",
          "new_line_content": "        InactiveToHandled(range);",
          "content_same": false
        },
        {
          "line": 2964,
          "old_api": "last_instruction_index",
          "new_api": "GetPhiMapValueFor",
          "old_text": "pred->last_instruction_index()",
          "new_text": "data()->GetPhiMapValueFor(range)",
          "old_line_content": "            pred->last_instruction_index());",
          "new_line_content": "      data()->GetPhiMapValueFor(range);",
          "content_same": false
        },
        {
          "line": 2965,
          "old_api": "CanCover",
          "new_api": "phi",
          "old_text": "op_range->CanCover(pred_end)",
          "new_text": "phi_map_value->phi()",
          "old_line_content": "    while (op_range != nullptr && !op_range->CanCover(pred_end)) {",
          "new_line_content": "  const PhiInstruction* phi = phi_map_value->phi();",
          "content_same": false
        },
        {
          "line": 2966,
          "old_api": "next",
          "new_api": "block",
          "old_text": "op_range->next()",
          "new_text": "phi_map_value->block()",
          "old_line_content": "      op_range = op_range->next();",
          "new_line_content": "  const InstructionBlock* block = phi_map_value->block();",
          "content_same": false
        },
        {
          "line": 2971,
          "old_api": "TopLevel",
          "new_api": "operands",
          "old_text": "op_range->TopLevel()",
          "new_text": "phi->operands()",
          "old_line_content": "        first_op = op_range->TopLevel();",
          "new_line_content": "    int op = phi->operands()[i];",
          "content_same": false
        },
        {
          "line": 2977,
          "old_api": "size",
          "new_api": "last_instruction_index",
          "old_text": "phi->operands().size()",
          "new_text": "LifetimePosition::InstructionFromInstructionIndex(\n            pred->last_instruction_index())",
          "old_line_content": "  if (spilled_count * 2 <= phi->operands().size()) {",
          "new_line_content": "        LifetimePosition::InstructionFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 2991,
          "old_api": "TryMerge",
          "new_api": "size",
          "old_text": "first_op_spill->TryMerge(op_spill)",
          "new_text": "phi->operands().size()",
          "old_line_content": "    if (op_spill == first_op_spill || first_op_spill->TryMerge(op_spill)) {",
          "new_line_content": "  if (spilled_count * 2 <= phi->operands().size()) {",
          "content_same": false
        },
        {
          "line": 2998,
          "old_api": "size",
          "new_api": "TopLevel",
          "old_text": "phi->operands().size()",
          "new_text": "first_op->TopLevel()->GetSpillRange()",
          "old_line_content": "  if (num_merged * 2 <= phi->operands().size() ||",
          "new_line_content": "  SpillRange* first_op_spill = first_op->TopLevel()->GetSpillRange();",
          "content_same": false
        },
        {
          "line": 3000,
          "old_api": "first_interval",
          "new_api": "size",
          "old_text": "range->first_interval()",
          "new_text": "phi->operands().size()",
          "old_line_content": "                                  range->first_interval())) {",
          "new_line_content": "  for (size_t i = 1; i < phi->operands().size(); i++) {",
          "content_same": false
        },
        {
          "line": 3012,
          "old_api": "TopLevel",
          "new_api": "size",
          "old_text": "range->TopLevel()->GetSpillRange()",
          "new_text": "phi->operands().size()",
          "old_line_content": "            ? range->TopLevel()->GetSpillRange()",
          "new_line_content": "  if (num_merged * 2 <= phi->operands().size() ||",
          "content_same": false
        },
        {
          "line": 3013,
          "old_api": "TopLevel",
          "new_api": "interval",
          "old_text": "range->TopLevel()",
          "new_text": "first_op_spill->interval()",
          "old_line_content": "            : data()->AssignSpillRangeToLiveRange(range->TopLevel());",
          "new_line_content": "      AreUseIntervalsIntersecting(first_op_spill->interval(),",
          "content_same": false
        },
        {
          "line": 3014,
          "old_api": "TryMerge",
          "new_api": "first_interval",
          "old_text": "first_op_spill->TryMerge(spill_range)",
          "new_text": "range->first_interval()",
          "old_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "new_line_content": "                                  range->first_interval())) {",
          "content_same": false
        },
        {
          "line": 3020,
          "old_api": "TopLevel",
          "new_api": "Start",
          "old_text": "range->TopLevel()->HasSpillRange()",
          "new_text": "range->Start()",
          "old_line_content": "        range->TopLevel()->HasSpillRange()",
          "new_line_content": "  LifetimePosition next_pos = range->Start();",
          "content_same": false
        },
        {
          "line": 3021,
          "old_api": "TopLevel",
          "new_api": "NextStart",
          "old_text": "range->TopLevel()->GetSpillRange()",
          "new_text": "next_pos.NextStart()",
          "old_line_content": "            ? range->TopLevel()->GetSpillRange()",
          "new_line_content": "  if (next_pos.IsGapPosition()) next_pos = next_pos.NextStart();",
          "content_same": false
        },
        {
          "line": 3022,
          "old_api": "TopLevel",
          "new_api": "NextUsePositionRegisterIsBeneficial",
          "old_text": "range->TopLevel()",
          "new_text": "range->NextUsePositionRegisterIsBeneficial(next_pos)",
          "old_line_content": "            : data()->AssignSpillRangeToLiveRange(range->TopLevel());",
          "new_line_content": "  UsePosition* pos = range->NextUsePositionRegisterIsBeneficial(next_pos);",
          "content_same": false
        },
        {
          "line": 3025,
          "old_api": "pos",
          "new_api": "TopLevel",
          "old_text": "pos->pos()",
          "new_text": "range->TopLevel()->HasSpillRange()",
          "old_line_content": "    SpillBetween(range, range->Start(), pos->pos());",
          "new_line_content": "        range->TopLevel()->HasSpillRange()",
          "content_same": false
        },
        {
          "line": 3026,
          "old_api": "UnhandledIsSorted",
          "new_api": "TopLevel",
          "old_text": "UnhandledIsSorted()",
          "new_text": "range->TopLevel()->GetSpillRange()",
          "old_line_content": "    DCHECK(UnhandledIsSorted());",
          "new_line_content": "            ? range->TopLevel()->GetSpillRange()",
          "content_same": false
        },
        {
          "line": 3034,
          "old_api": "SplitRangeAt",
          "new_api": "TopLevel",
          "old_text": "SplitRangeAt(range, pos)",
          "new_text": "range->TopLevel()->HasSpillRange()",
          "old_line_content": "  LiveRange* second_part = SplitRangeAt(range, pos);",
          "new_line_content": "        range->TopLevel()->HasSpillRange()",
          "content_same": false
        },
        {
          "line": 3035,
          "old_api": "Spill",
          "new_api": "TopLevel",
          "old_text": "Spill(second_part)",
          "new_text": "range->TopLevel()->GetSpillRange()",
          "old_line_content": "  Spill(second_part);",
          "new_line_content": "            ? range->TopLevel()->GetSpillRange()",
          "content_same": false
        },
        {
          "line": 3049,
          "old_api": "CHECK",
          "new_api": "Spill",
          "old_text": "CHECK(start < end)",
          "new_text": "Spill(second_part)",
          "old_line_content": "  CHECK(start < end);",
          "new_line_content": "  Spill(second_part);",
          "content_same": false
        },
        {
          "line": 3063,
          "old_api": "DCHECK",
          "new_api": "CHECK",
          "old_text": "DCHECK(third_part != second_part)",
          "new_text": "CHECK(start < end)",
          "old_line_content": "    DCHECK(third_part != second_part);",
          "new_line_content": "  CHECK(start < end);",
          "content_same": false
        },
        {
          "line": 3066,
          "old_api": "AddToUnhandledSorted",
          "new_api": "Start",
          "old_text": "AddToUnhandledSorted(third_part)",
          "new_text": "second_part->Start()",
          "old_line_content": "    AddToUnhandledSorted(third_part);",
          "new_line_content": "  if (second_part->Start() < end) {",
          "content_same": false
        },
        {
          "line": 3070,
          "old_api": "AddToUnhandledSorted",
          "new_api": "PrevStart",
          "old_text": "AddToUnhandledSorted(second_part)",
          "new_text": "end.PrevStart().End()",
          "old_line_content": "    AddToUnhandledSorted(second_part);",
          "new_line_content": "    LifetimePosition third_part_end = end.PrevStart().End();",
          "content_same": false
        },
        {
          "line": 3080,
          "old_api": "code",
          "new_api": "AddToUnhandledSorted",
          "old_text": "data()->code()",
          "new_text": "AddToUnhandledSorted(third_part)",
          "old_line_content": "  const InstructionSequence* code = data()->code();",
          "new_line_content": "    AddToUnhandledSorted(third_part);",
          "content_same": false
        },
        {
          "line": 3084,
          "old_api": "HasSpillRange",
          "new_api": "AddToUnhandledSorted",
          "old_text": "range->HasSpillRange()",
          "new_text": "AddToUnhandledSorted(second_part)",
          "old_line_content": "    if (!range->HasSpillRange()) continue;",
          "new_line_content": "    AddToUnhandledSorted(second_part);",
          "content_same": false
        },
        {
          "line": 3094,
          "old_api": "GetSpillMoveInsertionLocations",
          "new_api": "code",
          "old_text": "range->GetSpillMoveInsertionLocations()",
          "new_text": "data()->code()",
          "old_line_content": "          range->GetSpillMoveInsertionLocations();",
          "new_line_content": "  const InstructionSequence* code = data()->code();",
          "content_same": false
        },
        {
          "line": 3095,
          "old_api": "DCHECK_NOT_NULL",
          "new_api": "live_ranges",
          "old_text": "DCHECK_NOT_NULL(spills)",
          "new_text": "data()->live_ranges()",
          "old_line_content": "      DCHECK_NOT_NULL(spills);",
          "new_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3108,
          "old_api": "spill_ranges",
          "new_api": "GetSpillMoveInsertionLocations",
          "old_text": "data()->spill_ranges()",
          "new_text": "range->GetSpillMoveInsertionLocations()",
          "old_line_content": "  ZoneVector<SpillRange*>& spill_ranges = data()->spill_ranges();",
          "new_line_content": "          range->GetSpillMoveInsertionLocations();",
          "content_same": false
        },
        {
          "line": 3127,
          "old_api": "frame",
          "new_api": "IsEmpty",
          "old_text": "data()->frame()->AllocateSpillSlot(byte_width)",
          "new_text": "range->IsEmpty()",
          "old_line_content": "      int index = data()->frame()->AllocateSpillSlot(byte_width);",
          "new_line_content": "    if (range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 3128,
          "old_api": "set_assigned_slot",
          "new_api": "size",
          "old_text": "range->set_assigned_slot(index)",
          "new_text": "spill_ranges.size()",
          "old_line_content": "      range->set_assigned_slot(index);",
          "new_line_content": "    for (size_t j = i + 1; j < spill_ranges.size(); ++j) {",
          "content_same": false
        },
        {
          "line": 3139,
          "old_api": "TopLevel",
          "new_api": "HasSlot",
          "old_text": "top_range->TopLevel()->GetSpillOperand()",
          "new_text": "range->HasSlot()",
          "old_line_content": "      spill_operand = *top_range->TopLevel()->GetSpillOperand();",
          "new_line_content": "    if (!range->HasSlot()) {",
          "content_same": false
        },
        {
          "line": 3140,
          "old_api": "TopLevel",
          "new_api": "ByteWidth",
          "old_text": "top_range->TopLevel()->HasSpillRange()",
          "new_text": "range->ByteWidth()",
          "old_line_content": "    } else if (top_range->TopLevel()->HasSpillRange()) {",
          "new_line_content": "      int byte_width = range->ByteWidth();",
          "content_same": false
        },
        {
          "line": 3141,
          "old_api": "TopLevel",
          "new_api": "frame",
          "old_text": "top_range->TopLevel()->GetSpillRangeOperand()",
          "new_text": "data()->frame()->AllocateSpillSlot(byte_width)",
          "old_line_content": "      spill_operand = top_range->TopLevel()->GetSpillRangeOperand();",
          "new_line_content": "      int index = data()->frame()->AllocateSpillSlot(byte_width);",
          "content_same": false
        },
        {
          "line": 3149,
          "old_api": "GetAssignedOperand",
          "new_api": "live_ranges",
          "old_text": "range->GetAssignedOperand()",
          "new_text": "data()->live_ranges()",
          "old_line_content": "      InstructionOperand assigned = range->GetAssignedOperand();",
          "new_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3150,
          "old_api": "ConvertUsesToOperand",
          "new_api": "IsEmpty",
          "old_text": "range->ConvertUsesToOperand(assigned, spill_operand)",
          "new_text": "top_range->IsEmpty()",
          "old_line_content": "      range->ConvertUsesToOperand(assigned, spill_operand);",
          "new_line_content": "    if (top_range == nullptr || top_range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 3153,
          "old_api": "IsInvalid",
          "new_api": "TopLevel",
          "old_text": "spill_operand.IsInvalid()",
          "new_text": "top_range->TopLevel()->GetSpillOperand()",
          "old_line_content": "    if (!spill_operand.IsInvalid()) {",
          "new_line_content": "      spill_operand = *top_range->TopLevel()->GetSpillOperand();",
          "content_same": false
        },
        {
          "line": 3164,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": "ConvertUsesToOperand",
          "old_text": "top_range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": "range->ConvertUsesToOperand(assigned, spill_operand)",
          "old_line_content": "      if (!top_range->IsSpilledOnlyInDeferredBlocks()) {",
          "new_line_content": "      range->ConvertUsesToOperand(assigned, spill_operand);",
          "content_same": false
        },
        {
          "line": 3167,
          "old_api": "CommitSpillMoves",
          "new_api": "IsInvalid",
          "old_text": "top_range->CommitSpillMoves(\n            data()->code(), spill_operand,\n            top_range->has_slot_use() || top_range->spilled())",
          "new_text": "spill_operand.IsInvalid()",
          "old_line_content": "        top_range->CommitSpillMoves(",
          "new_line_content": "    if (!spill_operand.IsInvalid()) {",
          "content_same": false
        },
        {
          "line": 3183,
          "old_api": "instruction_position",
          "new_api": "spilled",
          "old_text": "map->instruction_position()",
          "new_text": "top_range->spilled()",
          "old_line_content": "    if (safe_point > map->instruction_position()) return false;",
          "new_line_content": "            top_range->has_slot_use() || top_range->spilled());",
          "content_same": false
        },
        {
          "line": 3196,
          "old_api": "AllocatedOperand::cast(*delayed_reference.operand)",
          "new_api": "code",
          "old_text": "AllocatedOperand::cast(*delayed_reference.operand)",
          "new_text": "data()->code()->reference_maps()",
          "old_line_content": "        AllocatedOperand::cast(*delayed_reference.operand));",
          "new_line_content": "  for (ReferenceMap* map : *data()->code()->reference_maps()) {",
          "content_same": false
        },
        {
          "line": 3208,
          "old_api": "IsEmpty",
          "new_api": "delayed_references",
          "old_text": "range->IsEmpty()",
          "new_text": "data()->delayed_references()",
          "old_line_content": "    if (range->IsEmpty()) continue;",
          "new_line_content": "       data()->delayed_references()) {",
          "content_same": false
        },
        {
          "line": 3209,
          "old_api": "has_preassigned_slot",
          "new_api": "RecordReference",
          "old_text": "range->has_preassigned_slot()",
          "new_text": "delayed_reference.map->RecordReference(\n        AllocatedOperand::cast(*delayed_reference.operand))",
          "old_line_content": "    if (range->has_preassigned_slot()) continue;",
          "new_line_content": "    delayed_reference.map->RecordReference(",
          "content_same": false
        },
        {
          "line": 3215,
          "old_api": "End",
          "new_api": "code",
          "old_text": "cur->End()",
          "new_text": "data()->code()->reference_maps()",
          "old_line_content": "      LifetimePosition this_end = cur->End();",
          "new_line_content": "  const ReferenceMapDeque* reference_maps = data()->code()->reference_maps();",
          "content_same": false
        },
        {
          "line": 3216,
          "old_api": "ToInstructionIndex",
          "new_api": "begin",
          "old_text": "this_end.ToInstructionIndex()",
          "new_text": "reference_maps->begin()",
          "old_line_content": "      if (this_end.ToInstructionIndex() > end)",
          "new_line_content": "  ReferenceMapDeque::const_iterator first_it = reference_maps->begin();",
          "content_same": false
        },
        {
          "line": 3217,
          "old_api": "ToInstructionIndex",
          "new_api": "live_ranges",
          "old_text": "this_end.ToInstructionIndex()",
          "new_text": "data()->live_ranges()",
          "old_line_content": "        end = this_end.ToInstructionIndex();",
          "new_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3223,
          "old_api": "begin",
          "new_api": "has_preassigned_slot",
          "old_text": "reference_maps->begin()",
          "new_text": "range->has_preassigned_slot()",
          "old_line_content": "    if (start < last_range_start) first_it = reference_maps->begin();",
          "new_line_content": "    if (range->has_preassigned_slot()) continue;",
          "content_same": false
        },
        {
          "line": 3228,
          "old_api": "end",
          "new_api": "next",
          "old_text": "reference_maps->end()",
          "new_text": "cur->next()",
          "old_line_content": "    for (; first_it != reference_maps->end(); ++first_it) {",
          "new_line_content": "    for (LiveRange* cur = range; cur != nullptr; cur = cur->next()) {",
          "content_same": false
        },
        {
          "line": 3230,
          "old_api": "instruction_position",
          "new_api": "ToInstructionIndex",
          "old_text": "map->instruction_position()",
          "new_text": "this_end.ToInstructionIndex()",
          "old_line_content": "      if (map->instruction_position() >= start) break;",
          "new_line_content": "      if (this_end.ToInstructionIndex() > end)",
          "content_same": false
        },
        {
          "line": 3237,
          "old_api": "HasSpillOperand",
          "new_api": "begin",
          "old_text": "range->HasSpillOperand()",
          "new_text": "reference_maps->begin()",
          "old_line_content": "      if (range->HasSpillOperand()) {",
          "new_line_content": "    if (start < last_range_start) first_it = reference_maps->begin();",
          "content_same": false
        },
        {
          "line": 3242,
          "old_api": "IsStackSlot",
          "new_api": "end",
          "old_text": "spill_operand.IsStackSlot()",
          "new_text": "reference_maps->end()",
          "old_line_content": "      DCHECK(spill_operand.IsStackSlot());",
          "new_line_content": "    for (; first_it != reference_maps->end(); ++first_it) {",
          "content_same": false
        },
        {
          "line": 3244,
          "old_api": "representation",
          "new_api": "instruction_position",
          "old_text": "AllocatedOperand::cast(spill_operand).representation()",
          "new_text": "map->instruction_position()",
          "old_line_content": "                AllocatedOperand::cast(spill_operand).representation());",
          "new_line_content": "      if (map->instruction_position() >= start) break;",
          "content_same": false
        },
        {
          "line": 3249,
          "old_api": "end",
          "new_api": "GetSpillOperand",
          "old_text": "reference_maps->end()",
          "new_text": "range->GetSpillOperand()->IsConstant()",
          "old_line_content": "    for (auto it = first_it; it != reference_maps->end(); ++it) {",
          "new_line_content": "          !range->GetSpillOperand()->IsConstant()) ||",
          "content_same": false
        },
        {
          "line": 3251,
          "old_api": "instruction_position",
          "new_api": "HasSpillOperand",
          "old_text": "map->instruction_position()",
          "new_text": "range->HasSpillOperand()",
          "old_line_content": "      int safe_point = map->instruction_position();",
          "new_line_content": "      if (range->HasSpillOperand()) {",
          "content_same": false
        },
        {
          "line": 3288,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": "next",
          "old_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": "cur->next()",
          "old_line_content": "      int spill_index = range->IsSpilledOnlyInDeferredBlocks()",
          "new_line_content": "          LiveRange* next = cur->next();",
          "content_same": false
        },
        {
          "line": 3289,
          "old_api": "ToInstructionIndex",
          "new_api": "Start",
          "old_text": "cur->Start().ToInstructionIndex()",
          "new_text": "next->Start()",
          "old_line_content": "                            ? cur->Start().ToInstructionIndex()",
          "new_line_content": "          if (next == nullptr || next->Start() > safe_point_pos) {",
          "content_same": false
        },
        {
          "line": 3302,
          "old_api": "value",
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": "cur->Start().value()",
          "new_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "            range->vreg(), cur->relative_id(), cur->Start().value(),",
          "new_line_content": "      int spill_index = range->IsSpilledOnlyInDeferredBlocks()",
          "content_same": false
        },
        {
          "line": 3304,
          "old_api": "GetAssignedOperand",
          "new_api": "spill_start_index",
          "old_text": "cur->GetAssignedOperand()",
          "new_text": "range->spill_start_index()",
          "old_line_content": "        InstructionOperand operand = cur->GetAssignedOperand();",
          "new_line_content": "                            : range->spill_start_index();",
          "content_same": false
        },
        {
          "line": 3306,
          "old_api": "representation",
          "new_api": "IsInvalid",
          "old_text": "DCHECK_EQ(MachineRepresentation::kTagged,\n                  AllocatedOperand::cast(operand).representation())",
          "new_text": "spill_operand.IsInvalid()",
          "old_line_content": "        DCHECK_EQ(MachineRepresentation::kTagged,",
          "new_line_content": "      if (!spill_operand.IsInvalid() && safe_point >= spill_index) {",
          "content_same": false
        },
        {
          "line": 3307,
          "old_api": "representation",
          "new_api": "vreg",
          "old_text": "AllocatedOperand::cast(operand).representation()",
          "new_text": "TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",\n              range->vreg(), spill_index, safe_point)",
          "old_line_content": "                  AllocatedOperand::cast(operand).representation());",
          "new_line_content": "        TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",",
          "content_same": false
        },
        {
          "line": 3308,
          "old_api": "AllocatedOperand::cast(operand)",
          "new_api": "vreg",
          "old_text": "AllocatedOperand::cast(operand)",
          "new_text": "range->vreg()",
          "old_line_content": "        map->RecordReference(AllocatedOperand::cast(operand));",
          "new_line_content": "              range->vreg(), spill_index, safe_point);",
          "content_same": false
        },
        {
          "line": 3321,
          "old_api": "PredecessorCount",
          "new_api": "representation",
          "old_text": "block->PredecessorCount()",
          "new_text": "AllocatedOperand::cast(operand).representation()",
          "old_line_content": "  if (block->PredecessorCount() != 1) return false;",
          "new_line_content": "                  AllocatedOperand::cast(operand).representation());",
          "content_same": false
        },
        {
          "line": 3322,
          "old_api": "rpo_number",
          "new_api": "AllocatedOperand::cast(operand)",
          "old_text": "block->rpo_number()",
          "new_text": "AllocatedOperand::cast(operand)",
          "old_line_content": "  return block->predecessors()[0].IsNext(block->rpo_number());",
          "new_line_content": "        map->RecordReference(AllocatedOperand::cast(operand));",
          "content_same": false
        },
        {
          "line": 3335,
          "old_api": "Current",
          "new_api": "PredecessorCount",
          "old_text": "iterator.Current()",
          "new_text": "block->PredecessorCount()",
          "old_line_content": "      LiveRangeBoundArray* array = finder.ArrayFor(iterator.Current());",
          "new_line_content": "  if (block->PredecessorCount() != 1) return false;",
          "content_same": false
        },
        {
          "line": 3336,
          "old_api": "predecessors",
          "new_api": "rpo_number",
          "old_text": "block->predecessors()",
          "new_text": "block->rpo_number()",
          "old_line_content": "      for (const RpoNumber& pred : block->predecessors()) {",
          "new_line_content": "  return block->predecessors()[0].IsNext(block->rpo_number());",
          "content_same": false
        },
        {
          "line": 3343,
          "old_api": "GetAssignedOperand",
          "new_api": "live_in_sets",
          "old_text": "result.cur_cover_->GetAssignedOperand()",
          "new_text": "data()->live_in_sets()",
          "old_line_content": "        InstructionOperand cur_op = result.cur_cover_->GetAssignedOperand();",
          "new_line_content": "  ZoneVector<BitVector*>& live_in_sets = data()->live_in_sets();",
          "content_same": false
        },
        {
          "line": 3344,
          "old_api": "Equals",
          "new_api": "instruction_blocks",
          "old_text": "pred_op.Equals(cur_op)",
          "new_text": "code()->instruction_blocks()",
          "old_line_content": "        if (pred_op.Equals(cur_op)) continue;",
          "new_line_content": "  for (const InstructionBlock* block : code()->instruction_blocks()) {",
          "content_same": false
        },
        {
          "line": 3345,
          "old_api": "IsAnyRegister",
          "new_api": "CanEagerlyResolveControlFlow",
          "old_text": "cur_op.IsAnyRegister()",
          "new_text": "CanEagerlyResolveControlFlow(block)",
          "old_line_content": "        if (!pred_op.IsAnyRegister() && cur_op.IsAnyRegister()) {",
          "new_line_content": "    if (CanEagerlyResolveControlFlow(block)) continue;",
          "content_same": false
        },
        {
          "line": 3352,
          "old_api": "code_start",
          "new_api": "InstructionBlockAt",
          "old_text": "block->code_start()",
          "new_text": "code()->InstructionBlockAt(pred)",
          "old_line_content": "              LifetimePosition::GapFromInstructionIndex(block->code_start());",
          "new_line_content": "        const InstructionBlock* pred_block = code()->InstructionBlockAt(pred);",
          "content_same": false
        },
        {
          "line": 3356,
          "old_api": "next",
          "new_api": "GetAssignedOperand",
          "old_text": "current->next()",
          "new_text": "result.pred_cover_->GetAssignedOperand()",
          "old_line_content": "          const LiveRange* successor = current->next();",
          "new_line_content": "        InstructionOperand pred_op = result.pred_cover_->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3357,
          "old_api": "End",
          "new_api": "GetAssignedOperand",
          "old_text": "current->End()",
          "new_text": "result.cur_cover_->GetAssignedOperand()",
          "old_line_content": "          if (current->End() < block_end &&",
          "new_line_content": "        InstructionOperand cur_op = result.cur_cover_->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3358,
          "old_api": "spilled",
          "new_api": "Equals",
          "old_text": "successor->spilled()",
          "new_text": "pred_op.Equals(cur_op)",
          "old_line_content": "              (successor == nullptr || successor->spilled())) {",
          "new_line_content": "        if (pred_op.Equals(cur_op)) continue;",
          "content_same": false
        },
        {
          "line": 3372,
          "old_api": "TopLevel",
          "new_api": "spilled",
          "old_text": "current->TopLevel()->IsSpilledOnlyInDeferredBlocks()",
          "new_text": "successor->spilled()",
          "old_line_content": "          if (current->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&",
          "new_line_content": "              (successor == nullptr || successor->spilled())) {",
          "content_same": false
        },
        {
          "line": 3377,
          "old_api": "ToInt",
          "new_api": "NextUsePosition",
          "old_text": "pred_block->rpo_number().ToInt()",
          "new_text": "current->NextUsePosition(block_start)",
          "old_line_content": "                pred_block->rpo_number().ToInt());",
          "new_line_content": "            for (const UsePosition* use = current->NextUsePosition(block_start);",
          "content_same": false
        },
        {
          "line": 3387,
          "old_api": "Advance",
          "new_api": "IsDeferred",
          "old_text": "iterator.Advance()",
          "new_text": "pred_block->IsDeferred()",
          "old_line_content": "      iterator.Advance();",
          "new_line_content": "              pred_block->IsDeferred()) {",
          "content_same": false
        },
        {
          "line": 3394,
          "old_api": "live_ranges",
          "new_api": "ResolveControlFlow",
          "old_text": "data()->live_ranges()",
          "new_text": "ResolveControlFlow(block, cur_op, pred_block, pred_op)",
          "old_line_content": "  for (TopLevelLiveRange* top : data()->live_ranges()) {",
          "new_line_content": "        int move_loc = ResolveControlFlow(block, cur_op, pred_block, pred_op);",
          "content_same": false
        },
        {
          "line": 3395,
          "old_api": "IsEmpty",
          "new_api": "USE",
          "old_text": "top->IsEmpty()",
          "new_text": "USE(move_loc)",
          "old_line_content": "    if (top == nullptr || top->IsEmpty() ||",
          "new_line_content": "        USE(move_loc);",
          "content_same": false
        },
        {
          "line": 3396,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": "IsAnyRegister",
          "old_text": "top->IsSpilledOnlyInDeferredBlocks()",
          "new_text": "DCHECK_IMPLIES(\n            result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&\n                !(pred_op.IsAnyRegister() && cur_op.IsAnyRegister()),\n            code()->GetInstructionBlock(move_loc)->IsDeferred())",
          "old_line_content": "        !top->IsSpilledOnlyInDeferredBlocks())",
          "new_line_content": "        DCHECK_IMPLIES(",
          "content_same": false
        },
        {
          "line": 3398,
          "old_api": "vreg",
          "new_api": "IsAnyRegister",
          "old_text": "top->vreg()",
          "new_text": "cur_op.IsAnyRegister()",
          "old_line_content": "    CommitSpillsInDeferredBlocks(top, finder.ArrayFor(top->vreg()), local_zone);",
          "new_line_content": "                !(pred_op.IsAnyRegister() && cur_op.IsAnyRegister()),",
          "content_same": false
        },
        {
          "line": 3410,
          "old_api": "PredecessorCount",
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": "block->PredecessorCount()",
          "new_text": "top->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "  if (block->PredecessorCount() == 1) {",
          "new_line_content": "        !top->IsSpilledOnlyInDeferredBlocks())",
          "content_same": false
        },
        {
          "line": 3421,
          "old_api": "AddGapMove",
          "new_api": "Equals",
          "old_text": "data()->AddGapMove(gap_index, position, pred_op, cur_op)",
          "new_text": "pred_op.Equals(cur_op)",
          "old_line_content": "  data()->AddGapMove(gap_index, position, pred_op, cur_op);",
          "new_line_content": "  DCHECK(!pred_op.Equals(cur_op));",
          "content_same": false
        },
        {
          "line": 3428,
          "old_api": "live_ranges",
          "new_api": "SuccessorCount",
          "old_text": "data()->live_ranges()",
          "new_text": "pred->SuccessorCount()",
          "old_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "new_line_content": "    DCHECK(pred->SuccessorCount() == 1);",
          "content_same": false
        },
        {
          "line": 3430,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": "last_instruction_index",
          "old_text": "top_range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": "pred->last_instruction_index()",
          "old_line_content": "    bool connect_spilled = top_range->IsSpilledOnlyInDeferredBlocks();",
          "new_line_content": "                ->InstructionAt(pred->last_instruction_index())",
          "content_same": false
        },
        {
          "line": 3432,
          "old_api": "next",
          "new_api": "last_instruction_index",
          "old_text": "first_range->next()",
          "new_text": "pred->last_instruction_index()",
          "old_line_content": "    for (LiveRange *second_range = first_range->next(); second_range != nullptr;",
          "new_line_content": "    gap_index = pred->last_instruction_index();",
          "content_same": false
        },
        {
          "line": 3444,
          "old_api": "GetAssignedOperand",
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": "second_range->GetAssignedOperand()",
          "new_text": "top_range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "      InstructionOperand cur_operand = second_range->GetAssignedOperand();",
          "new_line_content": "    bool connect_spilled = top_range->IsSpilledOnlyInDeferredBlocks();",
          "content_same": false
        },
        {
          "line": 3448,
          "old_api": "ToInstructionIndex",
          "new_api": "Start",
          "old_text": "pos.ToInstructionIndex()",
          "new_text": "second_range->Start()",
          "old_line_content": "      int gap_index = pos.ToInstructionIndex();",
          "new_line_content": "      LifetimePosition pos = second_range->Start();",
          "content_same": false
        },
        {
          "line": 3451,
          "old_api": "GetInstructionBlock",
          "new_api": "spilled",
          "old_text": "code()->GetInstructionBlock(gap_index)",
          "new_text": "second_range->spilled()",
          "old_line_content": "        const InstructionBlock* block = code()->GetInstructionBlock(gap_index);",
          "new_line_content": "      if (second_range->spilled()) continue;",
          "content_same": false
        },
        {
          "line": 3452,
          "old_api": "IsDeferred",
          "new_api": "End",
          "old_text": "block->IsDeferred()",
          "new_text": "first_range->End()",
          "old_line_content": "        DCHECK(block->IsDeferred());",
          "new_line_content": "      if (first_range->End() != pos) continue;",
          "content_same": false
        },
        {
          "line": 3459,
          "old_api": "IsGapPosition",
          "new_api": "Equals",
          "old_text": "pos.IsGapPosition()",
          "new_text": "prev_operand.Equals(cur_operand)",
          "old_line_content": "      if (pos.IsGapPosition()) {",
          "new_line_content": "      if (prev_operand.Equals(cur_operand)) continue;",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": "IsStart",
          "new_api": "ToInstructionIndex",
          "old_text": "pos.IsStart()",
          "new_text": "pos.ToInstructionIndex()",
          "old_line_content": "        if (pos.IsStart()) {",
          "new_line_content": "      int gap_index = pos.ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 3473,
          "old_api": "IsAnyRegister",
          "new_api": "IsGapPosition",
          "old_text": "cur_operand.IsAnyRegister()",
          "new_text": "pos.IsGapPosition()",
          "old_line_content": "              !(prev_operand.IsAnyRegister() && cur_operand.IsAnyRegister()),",
          "new_line_content": "      if (pos.IsGapPosition()) {",
          "content_same": false
        },
        {
          "line": 3474,
          "old_api": "GetInstructionBlock",
          "new_api": "IsStart",
          "old_text": "code()->GetInstructionBlock(gap_index)->IsDeferred()",
          "new_text": "pos.IsStart()",
          "old_line_content": "          code()->GetInstructionBlock(gap_index)->IsDeferred());",
          "new_line_content": "        gap_pos = pos.IsStart() ? Instruction::START : Instruction::END;",
          "content_same": false
        },
        {
          "line": 3487,
          "old_api": "empty",
          "new_api": "IsAnyRegister",
          "old_text": "delayed_insertion_map.empty()",
          "new_text": "cur_operand.IsAnyRegister()",
          "old_line_content": "  if (delayed_insertion_map.empty()) return;",
          "new_line_content": "              !(prev_operand.IsAnyRegister() && cur_operand.IsAnyRegister()),",
          "content_same": false
        },
        {
          "line": 3491,
          "old_api": "reserve",
          "new_api": "InstructionAt",
          "old_text": "to_insert.reserve(4)",
          "new_text": "code()->InstructionAt(gap_index)->GetOrCreateParallelMove(\n              gap_pos, code_zone())",
          "old_line_content": "  to_insert.reserve(4);",
          "new_line_content": "          code()->InstructionAt(gap_index)->GetOrCreateParallelMove(",
          "content_same": false
        },
        {
          "line": 3492,
          "old_api": "reserve",
          "new_api": "code_zone",
          "old_text": "to_eliminate.reserve(4)",
          "new_text": "code_zone()",
          "old_line_content": "  to_eliminate.reserve(4);",
          "new_line_content": "              gap_pos, code_zone());",
          "content_same": false
        },
        {
          "line": 3494,
          "old_api": "begin",
          "new_api": "AddMove",
          "old_text": "delayed_insertion_map.begin()",
          "new_text": "move->AddMove(prev_operand, cur_operand)",
          "old_line_content": "  for (auto it = delayed_insertion_map.begin();; ++it) {",
          "new_line_content": "        move->AddMove(prev_operand, cur_operand);",
          "content_same": false
        },
        {
          "line": 3506,
          "old_api": "clear",
          "new_api": "reserve",
          "old_text": "to_eliminate.clear()",
          "new_text": "to_eliminate.reserve(4)",
          "old_line_content": "      to_eliminate.clear();",
          "new_line_content": "  to_eliminate.reserve(4);",
          "content_same": false
        },
        {
          "line": 3507,
          "old_api": "clear",
          "new_api": "begin",
          "old_text": "to_insert.clear()",
          "new_text": "delayed_insertion_map.begin()",
          "old_line_content": "      to_insert.clear();",
          "new_line_content": "  ParallelMove* moves = delayed_insertion_map.begin()->first.first;",
          "content_same": false
        },
        {
          "line": 3513,
          "old_api": "PrepareInsertAfter",
          "new_api": "Eliminate",
          "old_text": "moves->PrepareInsertAfter(move)",
          "new_text": "move->Eliminate()",
          "old_line_content": "    MoveOperands* eliminate = moves->PrepareInsertAfter(move);",
          "new_line_content": "        move->Eliminate();",
          "content_same": false
        },
        {
          "line": 3526,
          "old_api": "GetSpillRangeOperand",
          "new_api": "code_zone",
          "old_text": "range->GetSpillRangeOperand()",
          "new_text": "code_zone()",
          "old_line_content": "  InstructionOperand spill_operand = range->GetSpillRangeOperand();",
          "new_line_content": "        new (code_zone()) MoveOperands(it->first.second, it->second);",
          "content_same": false
        },
        {
          "line": 3528,
          "old_api": "vreg",
          "new_api": "push_back",
          "old_text": "TRACE(\"Live Range %d will be spilled only in deferred blocks.\\n\",\n        range->vreg())",
          "new_text": "to_insert.push_back(move)",
          "old_line_content": "  TRACE(\"Live Range %d will be spilled only in deferred blocks.\\n\",",
          "new_line_content": "    to_insert.push_back(move);",
          "content_same": false
        },
        {
          "line": 3529,
          "old_api": "vreg",
          "new_api": "push_back",
          "old_text": "range->vreg()",
          "new_text": "to_eliminate.push_back(eliminate)",
          "old_line_content": "        range->vreg());",
          "new_line_content": "    if (eliminate != nullptr) to_eliminate.push_back(eliminate);",
          "content_same": false
        },
        {
          "line": 3536,
          "old_api": "spilled",
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": "child->spilled()",
          "new_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "      if (pos->type() != UsePositionType::kRequiresSlot && !child->spilled())",
          "new_line_content": "  DCHECK(range->IsSpilledOnlyInDeferredBlocks());",
          "content_same": false
        },
        {
          "line": 3539,
          "old_api": "ToInstructionIndex",
          "new_api": "code",
          "old_text": "pos->pos().ToInstructionIndex()",
          "new_text": "data()->code()",
          "old_line_content": "          code->GetInstructionBlock(pos->pos().ToInstructionIndex())",
          "new_line_content": "  InstructionSequence* code = data()->code();",
          "content_same": false
        },
        {
          "line": 3547,
          "old_api": "GetListOfBlocksRequiringSpillOperands",
          "new_api": "next",
          "old_text": "range->GetListOfBlocksRequiringSpillOperands()",
          "new_text": "child->next()",
          "old_line_content": "           range->GetListOfBlocksRequiringSpillOperands());",
          "new_line_content": "       child = child->next()) {",
          "content_same": false
        },
        {
          "line": 3548,
          "old_api": "Advance",
          "new_api": "first_pos",
          "old_text": "iterator.Advance()",
          "new_text": "child->first_pos()",
          "old_line_content": "       !iterator.Done(); iterator.Advance()) {",
          "new_line_content": "    for (const UsePosition* pos = child->first_pos(); pos != nullptr;",
          "content_same": false
        },
        {
          "line": 3549,
          "old_api": "Current",
          "new_api": "next",
          "old_text": "iterator.Current()",
          "new_text": "pos->next()",
          "old_line_content": "    worklist.push(iterator.Current());",
          "new_line_content": "         pos = pos->next()) {",
          "content_same": false
        },
        {
          "line": 3562,
          "old_api": "RpoNumber::FromInt(block_id)",
          "new_api": "Advance",
          "old_text": "RpoNumber::FromInt(block_id)",
          "new_text": "iterator.Advance()",
          "old_line_content": "        code->InstructionBlockAt(RpoNumber::FromInt(block_id));",
          "new_line_content": "       !iterator.Done(); iterator.Advance()) {",
          "content_same": false
        },
        {
          "line": 3571,
          "old_api": "last_instruction_index",
          "new_api": "front",
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(\n                pred_block->last_instruction_index())",
          "new_text": "worklist.front()",
          "old_line_content": "            LifetimePosition::InstructionFromInstructionIndex(",
          "new_line_content": "    int block_id = worklist.front();",
          "content_same": false
        },
        {
          "line": 3572,
          "old_api": "last_instruction_index",
          "new_api": "pop",
          "old_text": "pred_block->last_instruction_index()",
          "new_text": "worklist.pop()",
          "old_line_content": "                pred_block->last_instruction_index());",
          "new_line_content": "    worklist.pop();",
          "content_same": false
        },
        {
          "line": 3574,
          "old_api": "Find",
          "new_api": "Add",
          "old_text": "array->Find(pred_end)",
          "new_text": "done_blocks.Add(block_id)",
          "old_line_content": "        LiveRangeBound* bound = array->Find(pred_end);",
          "new_line_content": "    done_blocks.Add(block_id);",
          "content_same": false
        },
        {
          "line": 3576,
          "old_api": "GetAssignedOperand",
          "new_api": "RpoNumber::FromInt(block_id)",
          "old_text": "bound->range_->GetAssignedOperand()",
          "new_text": "RpoNumber::FromInt(block_id)",
          "old_line_content": "        InstructionOperand pred_op = bound->range_->GetAssignedOperand();",
          "new_line_content": "        code->InstructionBlockAt(RpoNumber::FromInt(block_id));",
          "content_same": false
        },
        {
          "line": 3578,
          "old_api": "first_instruction_index",
          "new_api": "predecessors",
          "old_text": "spill_block->first_instruction_index()",
          "new_text": "spill_block->predecessors()",
          "old_line_content": "        data()->AddGapMove(spill_block->first_instruction_index(),",
          "new_line_content": "    for (const RpoNumber& pred : spill_block->predecessors()) {",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2207,
          "old_api": null,
          "new_api": "InstructionBlockAt",
          "old_text": null,
          "new_text": "code()->InstructionBlockAt(predecessors[i])",
          "old_line_content": "        break;",
          "new_line_content": "        predecessor_block = code()->InstructionBlockAt(predecessors[i]);",
          "content_same": false
        },
        {
          "line": 2208,
          "old_api": null,
          "new_api": "IsDeferred",
          "old_text": null,
          "new_text": "predecessor_block->IsDeferred()",
          "old_line_content": "      }",
          "new_line_content": "        if (!predecessor_block->IsDeferred()) {",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "code()",
          "old_line_content": "    }",
          "new_line_content": "          instr = GetLastInstruction(code(), predecessor_block);",
          "content_same": false
        },
        {
          "line": 2216,
          "old_api": null,
          "new_api": "GetParallelMove",
          "old_text": null,
          "new_text": "instr->GetParallelMove(Instruction::END)",
          "old_line_content": "  }",
          "new_line_content": "    for (MoveOperands* move : *instr->GetParallelMove(Instruction::END)) {",
          "content_same": false
        },
        {
          "line": 2217,
          "old_api": null,
          "new_api": "destination",
          "old_text": null,
          "new_text": "move->destination()",
          "old_line_content": "}",
          "new_line_content": "      InstructionOperand& to = move->destination();",
          "content_same": false
        },
        {
          "line": 2218,
          "old_api": null,
          "new_api": "IsUnallocated",
          "old_text": null,
          "new_text": "to.IsUnallocated()",
          "old_line_content": "",
          "new_line_content": "      if (to.IsUnallocated() &&",
          "content_same": false
        },
        {
          "line": 2219,
          "old_api": null,
          "new_api": "virtual_register",
          "old_text": null,
          "new_text": "UnallocatedOperand::cast(to).virtual_register()",
          "old_line_content": "",
          "new_line_content": "          UnallocatedOperand::cast(to).virtual_register() == phi_vreg) {",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": null,
          "new_api": "source",
          "old_text": null,
          "new_text": "move->source()",
          "old_line_content": "void LiveRangeBuilder::ProcessLoopHeader(const InstructionBlock* block,",
          "new_line_content": "        hint = &move->source();",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(hint != nullptr)",
          "old_line_content": "  // for each value live on entry to the header.",
          "new_line_content": "    DCHECK(hint != nullptr);",
          "content_same": false
        },
        {
          "line": 2225,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(\n        block->first_instruction_index())",
          "old_line_content": "  BitVector::Iterator iterator(live);",
          "new_line_content": "    LifetimePosition block_start = LifetimePosition::GapFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 2236,
          "old_api": null,
          "new_api": "IsLoopHeader",
          "old_text": null,
          "new_text": "block->IsLoopHeader()",
          "old_line_content": "  }",
          "new_line_content": "  DCHECK(block->IsLoopHeader());",
          "content_same": false
        },
        {
          "line": 2241,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "block->first_instruction_index()",
          "old_line_content": "  }",
          "new_line_content": "      block->first_instruction_index());",
          "content_same": false
        },
        {
          "line": 2242,
          "old_api": null,
          "new_api": "NextFullStart",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(\n                             code()->LastLoopInstructionIndex(block))\n                             .NextFullStart()",
          "old_line_content": "}",
          "new_line_content": "  LifetimePosition end = LifetimePosition::GapFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 2243,
          "old_api": null,
          "new_api": "LastLoopInstructionIndex",
          "old_text": null,
          "new_text": "code()->LastLoopInstructionIndex(block)",
          "old_line_content": "",
          "new_line_content": "                             code()->LastLoopInstructionIndex(block))",
          "content_same": false
        },
        {
          "line": 2245,
          "old_api": null,
          "new_api": "Done",
          "old_text": null,
          "new_text": "iterator.Done()",
          "old_line_content": "void LiveRangeBuilder::BuildLiveRanges() {",
          "new_line_content": "  while (!iterator.Done()) {",
          "content_same": false
        },
        {
          "line": 2246,
          "old_api": null,
          "new_api": "Current",
          "old_text": null,
          "new_text": "iterator.Current()",
          "old_line_content": "  // Process the blocks in reverse order.",
          "new_line_content": "    int operand_index = iterator.Current();",
          "content_same": false
        },
        {
          "line": 2248,
          "old_api": null,
          "new_api": "allocation_zone",
          "old_text": null,
          "new_text": "allocation_zone()",
          "old_line_content": "       --block_id) {",
          "new_line_content": "    range->EnsureInterval(start, end, allocation_zone());",
          "content_same": false
        },
        {
          "line": 2249,
          "old_api": null,
          "new_api": "Advance",
          "old_text": null,
          "new_text": "iterator.Advance()",
          "old_line_content": "    InstructionBlock* block =",
          "new_line_content": "    iterator.Advance();",
          "content_same": false
        },
        {
          "line": 2252,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "block->loop_end().ToInt()",
          "old_line_content": "    // Initially consider all live_out values live for the entire block. We",
          "new_line_content": "  for (int i = block->rpo_number().ToInt() + 1; i < block->loop_end().ToInt();",
          "content_same": false
        },
        {
          "line": 2261,
          "old_api": null,
          "new_api": "InstructionBlockCount",
          "old_text": null,
          "new_text": "code()->InstructionBlockCount()",
          "old_line_content": "    // out on backward successor edges.",
          "new_line_content": "  for (int block_id = code()->InstructionBlockCount() - 1; block_id >= 0;",
          "content_same": false
        },
        {
          "line": 2264,
          "old_api": null,
          "new_api": "RpoNumber::FromInt(block_id)",
          "old_text": null,
          "new_text": "RpoNumber::FromInt(block_id)",
          "old_line_content": "  }",
          "new_line_content": "        code()->InstructionBlockAt(RpoNumber::FromInt(block_id));",
          "content_same": false
        },
        {
          "line": 2265,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "data()",
          "old_line_content": "  // Postprocess the ranges.",
          "new_line_content": "    BitVector* live = ComputeLiveOut(block, data());",
          "content_same": false
        },
        {
          "line": 2268,
          "old_api": null,
          "new_api": "AddInitialIntervals",
          "old_text": null,
          "new_text": "AddInitialIntervals(block, live)",
          "old_line_content": "    // Give slots to all ranges with a non fixed slot use.",
          "new_line_content": "    AddInitialIntervals(block, live);",
          "content_same": false
        },
        {
          "line": 2271,
          "old_api": null,
          "new_api": "ProcessInstructions",
          "old_text": null,
          "new_text": "ProcessInstructions(block, live)",
          "old_line_content": "    }",
          "new_line_content": "    ProcessInstructions(block, live);",
          "content_same": false
        },
        {
          "line": 2273,
          "old_api": null,
          "new_api": "ProcessPhis",
          "old_text": null,
          "new_text": "ProcessPhis(block, live)",
          "old_line_content": "    // live ranges, every use requires the constant to be in a register.",
          "new_line_content": "    ProcessPhis(block, live);",
          "content_same": false
        },
        {
          "line": 2280,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "        UsePositionType new_type = UsePositionType::kAny;",
          "new_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2283,
          "old_api": null,
          "new_api": "HasNoSpillType",
          "old_text": null,
          "new_text": "range->HasNoSpillType()",
          "old_line_content": "          new_type = UsePositionType::kRequiresRegister;",
          "new_line_content": "    if (range->has_slot_use() && range->HasNoSpillType()) {",
          "content_same": false
        },
        {
          "line": 2284,
          "old_api": null,
          "new_api": "AssignSpillRangeToLiveRange",
          "old_text": null,
          "new_text": "data()->AssignSpillRangeToLiveRange(range)",
          "old_line_content": "        }",
          "new_line_content": "      data()->AssignSpillRangeToLiveRange(range);",
          "content_same": false
        },
        {
          "line": 2290,
          "old_api": null,
          "new_api": "GetSpillOperand",
          "old_text": null,
          "new_text": "range->GetSpillOperand()->IsConstant()",
          "old_line_content": "    TopLevelLiveRange* range = preassigned.first;",
          "new_line_content": "    if (range->HasSpillOperand() && range->GetSpillOperand()->IsConstant()) {",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": null,
          "new_api": "first_pos",
          "old_text": null,
          "new_text": "range->first_pos()",
          "old_line_content": "    int slot_id = preassigned.second;",
          "new_line_content": "      for (UsePosition* pos = range->first_pos(); pos != nullptr;",
          "content_same": false
        },
        {
          "line": 2296,
          "old_api": null,
          "new_api": "IsGapPosition",
          "old_text": null,
          "new_text": "pos->pos().IsGapPosition()",
          "old_line_content": "  }",
          "new_line_content": "        if (!pos->pos().IsGapPosition()) {",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": null,
          "new_api": "set_type",
          "old_text": null,
          "new_text": "pos->set_type(new_type, true)",
          "old_line_content": "#endif",
          "new_line_content": "        pos->set_type(new_type, true);",
          "content_same": false
        },
        {
          "line": 2303,
          "old_api": null,
          "new_api": "preassigned_slot_ranges",
          "old_text": null,
          "new_text": "data()->preassigned_slot_ranges()",
          "old_line_content": "void LiveRangeBuilder::MapPhiHint(InstructionOperand* operand,",
          "new_line_content": "  for (auto preassigned : data()->preassigned_slot_ranges()) {",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": null,
          "new_api": "set_assigned_slot",
          "old_text": null,
          "new_text": "spill->set_assigned_slot(slot_id)",
          "old_line_content": "}",
          "new_line_content": "    spill->set_assigned_slot(slot_id);",
          "content_same": false
        },
        {
          "line": 2312,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "Verify()",
          "old_line_content": "void LiveRangeBuilder::ResolvePhiHint(InstructionOperand* operand,",
          "new_line_content": "  Verify();",
          "content_same": false
        },
        {
          "line": 2319,
          "old_api": null,
          "new_api": "IsResolved",
          "old_text": null,
          "new_text": "use_pos->IsResolved()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(!use_pos->IsResolved());",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": null,
          "new_api": "std::make_pair(operand, use_pos)",
          "old_text": null,
          "new_text": "std::make_pair(operand, use_pos)",
          "old_line_content": "",
          "new_line_content": "  auto res = phi_hints_.insert(std::make_pair(operand, use_pos));",
          "content_same": false
        },
        {
          "line": 2321,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(res.second)",
          "old_line_content": "void LiveRangeBuilder::Verify() const {",
          "new_line_content": "  DCHECK(res.second);",
          "content_same": false
        },
        {
          "line": 2322,
          "old_api": null,
          "new_api": "USE",
          "old_text": null,
          "new_text": "USE(res)",
          "old_line_content": "  for (auto& hint : phi_hints_) {",
          "new_line_content": "  USE(res);",
          "content_same": false
        },
        {
          "line": 2328,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "phi_hints_.find(operand)",
          "old_line_content": "}",
          "new_line_content": "  auto it = phi_hints_.find(operand);",
          "content_same": false
        },
        {
          "line": 2329,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "phi_hints_.end()",
          "old_line_content": "",
          "new_line_content": "  if (it == phi_hints_.end()) return;",
          "content_same": false
        },
        {
          "line": 2330,
          "old_api": null,
          "new_api": "IsResolved",
          "old_text": null,
          "new_text": "it->second->IsResolved()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(!it->second->IsResolved());",
          "content_same": false
        },
        {
          "line": 2331,
          "old_api": null,
          "new_api": "ResolveHint",
          "old_text": null,
          "new_text": "it->second->ResolveHint(use_pos)",
          "old_line_content": "RegisterAllocator::RegisterAllocator(RegisterAllocationData* data,",
          "new_line_content": "  it->second->ResolveHint(use_pos);",
          "content_same": false
        },
        {
          "line": 2340,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "current->Verify()",
          "old_line_content": "",
          "new_line_content": "    if (current != nullptr && !current->IsEmpty()) current->Verify();",
          "content_same": false
        },
        {
          "line": 2349,
          "old_api": null,
          "new_api": "config",
          "old_text": null,
          "new_text": "data->config()",
          "old_line_content": "  }",
          "new_line_content": "      num_registers_(GetRegisterCount(data->config(), kind)),",
          "content_same": false
        },
        {
          "line": 2351,
          "old_api": null,
          "new_api": "config",
          "old_text": null,
          "new_text": "data->config()",
          "old_line_content": "}",
          "new_line_content": "          GetAllocatableRegisterCount(data->config(), kind)),",
          "content_same": false
        },
        {
          "line": 2353,
          "old_api": null,
          "new_api": "config",
          "old_text": null,
          "new_text": "data->config()",
          "old_line_content": "",
          "new_line_content": "          GetAllocatableRegisterCodes(data->config(), kind)) {}",
          "content_same": false
        },
        {
          "line": 2361,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "range->End()",
          "old_line_content": "      continue;",
          "new_line_content": "  if (range->Start() >= ret || ret >= range->End()) {",
          "content_same": false
        },
        {
          "line": 2362,
          "old_api": null,
          "new_api": "LifetimePosition::Invalid()",
          "old_text": null,
          "new_text": "LifetimePosition::Invalid()",
          "old_line_content": "    }",
          "new_line_content": "    return LifetimePosition::Invalid();",
          "content_same": false
        },
        {
          "line": 2370,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "    }",
          "new_line_content": "  size_t initial_range_count = data()->live_ranges().size();",
          "content_same": false
        },
        {
          "line": 2372,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "    // If the range already has a spill operand and it doesn't need a",
          "new_line_content": "    TopLevelLiveRange* range = data()->live_ranges()[i];",
          "content_same": false
        },
        {
          "line": 2373,
          "old_api": null,
          "new_api": "CanProcessRange",
          "old_text": null,
          "new_text": "CanProcessRange(range)",
          "old_line_content": "    // register immediately, split it and spill the first part of the range.",
          "new_line_content": "    if (!CanProcessRange(range)) continue;",
          "content_same": false
        },
        {
          "line": 2374,
          "old_api": null,
          "new_api": "HasSpillRange",
          "old_text": null,
          "new_text": "range->HasSpillRange()",
          "old_line_content": "    if (pos == nullptr) {",
          "new_line_content": "    if (range->HasNoSpillType() || (operands_only && range->HasSpillRange())) {",
          "content_same": false
        },
        {
          "line": 2378,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "range->Start()",
          "old_line_content": "      // the register is too close to the start of live range.",
          "new_line_content": "    LifetimePosition start = range->Start();",
          "content_same": false
        },
        {
          "line": 2383,
          "old_api": null,
          "new_api": "NextStart",
          "old_text": null,
          "new_text": "next_pos.NextStart()",
          "old_line_content": "",
          "new_line_content": "      next_pos = next_pos.NextStart();",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "Spill(range)",
          "old_line_content": "    }",
          "new_line_content": "      Spill(range);",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": null,
          "new_api": "NextStart",
          "old_text": null,
          "new_text": "range->Start().NextStart()",
          "old_line_content": "  }",
          "new_line_content": "    } else if (pos->pos() > range->Start().NextStart()) {",
          "content_same": false
        },
        {
          "line": 2393,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "GetSplitPositionForInstruction(\n          range, pos->pos().ToInstructionIndex())",
          "old_line_content": "",
          "new_line_content": "      LifetimePosition split_pos = GetSplitPositionForInstruction(",
          "content_same": false
        },
        {
          "line": 2394,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "pos->pos().ToInstructionIndex()",
          "old_line_content": "LiveRange* RegisterAllocator::SplitRangeAt(LiveRange* range,",
          "new_line_content": "          range, pos->pos().ToInstructionIndex());",
          "content_same": false
        },
        {
          "line": 2399,
          "old_api": null,
          "new_api": "NextFullStart",
          "old_text": null,
          "new_text": "range->Start().NextFullStart()",
          "old_line_content": "",
          "new_line_content": "          FindOptimalSplitPos(range->Start().NextFullStart(), split_pos);",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": null,
          "new_api": "SplitRangeAt",
          "old_text": null,
          "new_text": "SplitRangeAt(range, split_pos)",
          "old_line_content": "",
          "new_line_content": "      SplitRangeAt(range, split_pos);",
          "content_same": false
        },
        {
          "line": 2402,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "Spill(range)",
          "old_line_content": "  // We can't properly connect liveranges if splitting occurred at the end",
          "new_line_content": "      Spill(range);",
          "content_same": false
        },
        {
          "line": 2410,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->IsFixed()",
          "old_line_content": "}",
          "new_line_content": "  DCHECK(!range->TopLevel()->IsFixed());",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->vreg()",
          "old_line_content": "",
          "new_line_content": "  TRACE(\"Splitting live range %d:%d at %d\\n\", range->TopLevel()->vreg(),",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "pos.value()",
          "old_line_content": "",
          "new_line_content": "        range->relative_id(), pos.value());",
          "content_same": false
        },
        {
          "line": 2414,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "range->Start()",
          "old_line_content": "                                           LifetimePosition start,",
          "new_line_content": "  if (pos <= range->Start()) return range;",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "pos.ToInstructionIndex()",
          "old_line_content": "",
          "new_line_content": "          pos.ToInstructionIndex()));",
          "content_same": false
        },
        {
          "line": 2432,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "start.value()",
          "old_line_content": "",
          "new_line_content": "        range->TopLevel()->vreg(), range->relative_id(), start.value(),",
          "content_same": false
        },
        {
          "line": 2433,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "end.value()",
          "old_line_content": "  // We have no choice",
          "new_line_content": "        end.value());",
          "content_same": false
        },
        {
          "line": 2435,
          "old_api": null,
          "new_api": "FindOptimalSplitPos",
          "old_text": null,
          "new_text": "FindOptimalSplitPos(start, end)",
          "old_line_content": "",
          "new_line_content": "  LifetimePosition split_pos = FindOptimalSplitPos(start, end);",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "start.ToInstructionIndex()",
          "old_line_content": "  }",
          "new_line_content": "  int start_instr = start.ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 2444,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "end.ToInstructionIndex()",
          "old_line_content": "",
          "new_line_content": "  int end_instr = end.ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(start_instr <= end_instr)",
          "old_line_content": "  const InstructionBlock* block = end_block;",
          "new_line_content": "  DCHECK(start_instr <= end_instr);",
          "content_same": false
        },
        {
          "line": 2451,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "code()",
          "old_line_content": "      // No more loops or loop starts before the lifetime start.",
          "new_line_content": "  const InstructionBlock* end_block = GetInstructionBlock(code(), end);",
          "content_same": false
        },
        {
          "line": 2464,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "start_block->rpo_number().ToInt()",
          "old_line_content": "",
          "new_line_content": "        loop->rpo_number().ToInt() <= start_block->rpo_number().ToInt()) {",
          "content_same": false
        },
        {
          "line": 2473,
          "old_api": null,
          "new_api": "IsLoopHeader",
          "old_text": null,
          "new_text": "end_block->IsLoopHeader()",
          "old_line_content": "",
          "new_line_content": "  if (block == end_block && !end_block->IsLoopHeader()) return end;",
          "content_same": false
        },
        {
          "line": 2476,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "block->first_instruction_index()",
          "old_line_content": "",
          "new_line_content": "      block->first_instruction_index());",
          "content_same": false
        },
        {
          "line": 2489,
          "old_api": null,
          "new_api": "PreviousUsePositionRegisterIsBeneficial",
          "old_text": null,
          "new_text": "range->PreviousUsePositionRegisterIsBeneficial(pos)",
          "old_line_content": "    }",
          "new_line_content": "      range->PreviousUsePositionRegisterIsBeneficial(pos);",
          "content_same": false
        },
        {
          "line": 2495,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(\n        loop_header->first_instruction_index())",
          "old_line_content": "  return pos;",
          "new_line_content": "    LifetimePosition loop_start = LifetimePosition::GapFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "loop_header->first_instruction_index()",
          "old_line_content": "}",
          "new_line_content": "        loop_header->first_instruction_index());",
          "content_same": false
        },
        {
          "line": 2498,
          "old_api": null,
          "new_api": "Covers",
          "old_text": null,
          "new_text": "range->Covers(loop_start)",
          "old_line_content": "",
          "new_line_content": "    if (range->Covers(loop_start)) {",
          "content_same": false
        },
        {
          "line": 2499,
          "old_api": null,
          "new_api": "pos",
          "old_text": null,
          "new_text": "prev_use->pos()",
          "old_line_content": "void RegisterAllocator::Spill(LiveRange* range) {",
          "new_line_content": "      if (prev_use == nullptr || prev_use->pos() < loop_start) {",
          "content_same": false
        },
        {
          "line": 2506,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "code()",
          "old_line_content": "  }",
          "new_line_content": "    loop_header = GetContainingLoop(code(), loop_header);",
          "content_same": false
        },
        {
          "line": 2515,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()",
          "old_line_content": "}",
          "new_line_content": "  TopLevelLiveRange* first = range->TopLevel();",
          "content_same": false
        },
        {
          "line": 2516,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "range->relative_id()",
          "old_line_content": "",
          "new_line_content": "  TRACE(\"Spilling live range %d:%d\\n\", first->vreg(), range->relative_id());",
          "content_same": false
        },
        {
          "line": 2518,
          "old_api": null,
          "new_api": "HasNoSpillType",
          "old_text": null,
          "new_text": "first->HasNoSpillType()",
          "old_line_content": "const char* RegisterAllocator::RegisterName(int register_code) const {",
          "new_line_content": "  if (first->HasNoSpillType()) {",
          "content_same": false
        },
        {
          "line": 2521,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "range->Spill()",
          "old_line_content": "  } else {",
          "new_line_content": "  range->Spill();",
          "content_same": false
        },
        {
          "line": 2527,
          "old_api": null,
          "new_api": "fixed_double_live_ranges",
          "old_text": null,
          "new_text": "data()->fixed_double_live_ranges()",
          "old_line_content": "LinearScanAllocator::LinearScanAllocator(RegisterAllocationData* data,",
          "new_line_content": "  return mode() == DOUBLE_REGISTERS ? data()->fixed_double_live_ranges()",
          "content_same": false
        },
        {
          "line": 2528,
          "old_api": null,
          "new_api": "fixed_live_ranges",
          "old_text": null,
          "new_text": "data()->fixed_live_ranges()",
          "old_line_content": "                                         RegisterKind kind, Zone* local_zone)",
          "new_line_content": "                                    : data()->fixed_live_ranges();",
          "content_same": false
        },
        {
          "line": 2548,
          "old_api": null,
          "new_api": "VirtualRegisterCount",
          "old_text": null,
          "new_text": "code()->VirtualRegisterCount()",
          "old_line_content": "",
          "new_line_content": "      static_cast<size_t>(code()->VirtualRegisterCount() * 2));",
          "content_same": false
        },
        {
          "line": 2554,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "this->data()->config()->num_general_registers()",
          "old_line_content": "    for (LiveRange* to_add = range; to_add != nullptr;",
          "new_line_content": "         this->data()->config()->num_general_registers());",
          "content_same": false
        },
        {
          "line": 2559,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "unhandled_live_ranges().empty()",
          "old_line_content": "    }",
          "new_line_content": "  DCHECK(unhandled_live_ranges().empty());",
          "content_same": false
        },
        {
          "line": 2560,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "active_live_ranges().empty()",
          "old_line_content": "  }",
          "new_line_content": "  DCHECK(active_live_ranges().empty());",
          "content_same": false
        },
        {
          "line": 2563,
          "old_api": null,
          "new_api": "VirtualRegisterCount",
          "old_text": null,
          "new_text": "code()->VirtualRegisterCount()",
          "old_line_content": "",
          "new_line_content": "  SplitAndSpillRangesDefinedByMemoryOperand(code()->VirtualRegisterCount() <=",
          "content_same": false
        },
        {
          "line": 2566,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "    if (current != nullptr) {",
          "new_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2569,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "to_add->next()",
          "old_line_content": "    }",
          "new_line_content": "         to_add = to_add->next()) {",
          "content_same": false
        },
        {
          "line": 2570,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "to_add->spilled()",
          "old_line_content": "  }",
          "new_line_content": "      if (!to_add->spilled()) {",
          "content_same": false
        },
        {
          "line": 2571,
          "old_api": null,
          "new_api": "AddToUnhandledUnsorted",
          "old_text": null,
          "new_text": "AddToUnhandledUnsorted(to_add)",
          "old_line_content": "",
          "new_line_content": "        AddToUnhandledUnsorted(to_add);",
          "content_same": false
        },
        {
          "line": 2578,
          "old_api": null,
          "new_api": "GetFixedRegisters",
          "old_text": null,
          "new_text": "GetFixedRegisters()",
          "old_line_content": "#ifdef DEBUG",
          "new_line_content": "  auto& fixed_ranges = GetFixedRegisters();",
          "content_same": false
        },
        {
          "line": 2586,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "unhandled_live_ranges().empty()",
          "old_line_content": "",
          "new_line_content": "  while (!unhandled_live_ranges().empty()) {",
          "content_same": false
        },
        {
          "line": 2591,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "        --i;  // The live range was removed from the list of active live ranges.",
          "new_line_content": "    LifetimePosition position = current->Start();",
          "content_same": false
        },
        {
          "line": 2595,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "current->TopLevel()->vreg()",
          "old_line_content": "      }",
          "new_line_content": "    TRACE(\"Processing interval %d:%d start=%d\\n\", current->TopLevel()->vreg(),",
          "content_same": false
        },
        {
          "line": 2596,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "position.value()",
          "old_line_content": "    }",
          "new_line_content": "          current->relative_id(), position.value());",
          "content_same": false
        },
        {
          "line": 2602,
          "old_api": null,
          "new_api": "active_live_ranges",
          "old_text": null,
          "new_text": "active_live_ranges()",
          "old_line_content": "        --i;  // Live range was removed from the list of inactive live ranges.",
          "new_line_content": "      LiveRange* cur_active = active_live_ranges()[i];",
          "content_same": false
        },
        {
          "line": 2606,
          "old_api": null,
          "new_api": "Covers",
          "old_text": null,
          "new_text": "cur_active->Covers(position)",
          "old_line_content": "      }",
          "new_line_content": "      } else if (!cur_active->Covers(position)) {",
          "content_same": false
        },
        {
          "line": 2607,
          "old_api": null,
          "new_api": "ActiveToInactive",
          "old_text": null,
          "new_text": "ActiveToInactive(cur_active)",
          "old_line_content": "    }",
          "new_line_content": "        ActiveToInactive(cur_active);",
          "content_same": false
        },
        {
          "line": 2615,
          "old_api": null,
          "new_api": "InactiveToHandled",
          "old_text": null,
          "new_text": "InactiveToHandled(cur_inactive)",
          "old_line_content": "    }",
          "new_line_content": "        InactiveToHandled(cur_inactive);",
          "content_same": false
        },
        {
          "line": 2617,
          "old_api": null,
          "new_api": "Covers",
          "old_text": null,
          "new_text": "cur_inactive->Covers(position)",
          "old_line_content": "}",
          "new_line_content": "      } else if (cur_inactive->Covers(position)) {",
          "content_same": false
        },
        {
          "line": 2618,
          "old_api": null,
          "new_api": "InactiveToActive",
          "old_text": null,
          "new_text": "InactiveToActive(cur_inactive)",
          "old_line_content": "",
          "new_line_content": "        InactiveToActive(cur_inactive);",
          "content_same": false
        },
        {
          "line": 2627,
          "old_api": null,
          "new_api": "HasRegisterAssigned",
          "old_text": null,
          "new_text": "current->HasRegisterAssigned()",
          "old_line_content": "  }",
          "new_line_content": "    if (current->HasRegisterAssigned()) {",
          "content_same": false
        },
        {
          "line": 2628,
          "old_api": null,
          "new_api": "AddToActive",
          "old_text": null,
          "new_text": "AddToActive(current)",
          "old_line_content": "}",
          "new_line_content": "      AddToActive(current);",
          "content_same": false
        },
        {
          "line": 2636,
          "old_api": null,
          "new_api": "kind",
          "old_text": null,
          "new_text": "range->kind()",
          "old_line_content": "",
          "new_line_content": "  data()->MarkAllocated(range->kind(), reg);",
          "content_same": false
        },
        {
          "line": 2637,
          "old_api": null,
          "new_api": "set_assigned_register",
          "old_text": null,
          "new_text": "range->set_assigned_register(reg)",
          "old_line_content": "",
          "new_line_content": "  range->set_assigned_register(reg);",
          "content_same": false
        },
        {
          "line": 2638,
          "old_api": null,
          "new_api": "SetUseHints",
          "old_text": null,
          "new_text": "range->SetUseHints(reg)",
          "old_line_content": "void LinearScanAllocator::AddToInactive(LiveRange* range) {",
          "new_line_content": "  range->SetUseHints(reg);",
          "content_same": false
        },
        {
          "line": 2665,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "unhandled_live_ranges().at(i)",
          "old_line_content": "",
          "new_line_content": "    LiveRange* cur_range = unhandled_live_ranges().at(i);",
          "content_same": false
        },
        {
          "line": 2666,
          "old_api": null,
          "new_api": "ShouldBeAllocatedBefore",
          "old_text": null,
          "new_text": "range->ShouldBeAllocatedBefore(cur_range)",
          "old_line_content": "",
          "new_line_content": "    if (!range->ShouldBeAllocatedBefore(cur_range)) continue;",
          "content_same": false
        },
        {
          "line": 2667,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "TRACE(\"Add live range %d:%d to unhandled at %d\\n\",\n          range->TopLevel()->vreg(), range->relative_id(), i + 1)",
          "old_line_content": "void LinearScanAllocator::AddToUnhandledUnsorted(LiveRange* range) {",
          "new_line_content": "    TRACE(\"Add live range %d:%d to unhandled at %d\\n\",",
          "content_same": false
        },
        {
          "line": 2674,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "TRACE(\"Add live range %d:%d to unhandled at start\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "old_line_content": "",
          "new_line_content": "  TRACE(\"Add live range %d:%d to unhandled at start\\n\",",
          "content_same": false
        },
        {
          "line": 2675,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "range->relative_id()",
          "old_line_content": "",
          "new_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "content_same": false
        },
        {
          "line": 2676,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "unhandled_live_ranges().begin()",
          "old_line_content": "static bool UnhandledSortHelper(LiveRange* a, LiveRange* b) {",
          "new_line_content": "  unhandled_live_ranges().insert(unhandled_live_ranges().begin(), range);",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "range->IsEmpty()",
          "old_line_content": "",
          "new_line_content": "  if (range == nullptr || range->IsEmpty()) return;",
          "content_same": false
        },
        {
          "line": 2683,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "range->spilled()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(!range->HasRegisterAssigned() && !range->spilled());",
          "content_same": false
        },
        {
          "line": 2684,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "TRACE(\"Add live range %d:%d to unhandled unsorted at end\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "old_line_content": "// Sort the unhandled live ranges so that the ranges to be processed first are",
          "new_line_content": "  TRACE(\"Add live range %d:%d to unhandled unsorted at end\\n\",",
          "content_same": false
        },
        {
          "line": 2685,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "range->relative_id()",
          "old_line_content": "// at the end of the array list.  This is convenient for the register allocation",
          "new_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "content_same": false
        },
        {
          "line": 2686,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "unhandled_live_ranges().push_back(range)",
          "old_line_content": "// algorithm because it is efficient to remove elements from the end.",
          "new_line_content": "  unhandled_live_ranges().push_back(range);",
          "content_same": false
        },
        {
          "line": 2691,
          "old_api": null,
          "new_api": "ShouldBeAllocatedBefore",
          "old_text": null,
          "new_text": "b->ShouldBeAllocatedBefore(a)",
          "old_line_content": "}",
          "new_line_content": "  DCHECK(!a->ShouldBeAllocatedBefore(b) || !b->ShouldBeAllocatedBefore(a));",
          "content_same": false
        },
        {
          "line": 2692,
          "old_api": null,
          "new_api": "ShouldBeAllocatedBefore",
          "old_text": null,
          "new_text": "a->ShouldBeAllocatedBefore(b)",
          "old_line_content": "",
          "new_line_content": "  if (a->ShouldBeAllocatedBefore(b)) return false;",
          "content_same": false
        },
        {
          "line": 2693,
          "old_api": null,
          "new_api": "ShouldBeAllocatedBefore",
          "old_text": null,
          "new_text": "b->ShouldBeAllocatedBefore(a)",
          "old_line_content": "",
          "new_line_content": "  if (b->ShouldBeAllocatedBefore(a)) return true;",
          "content_same": false
        },
        {
          "line": 2694,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "b->TopLevel()->vreg()",
          "old_line_content": "bool LinearScanAllocator::UnhandledIsSorted() {",
          "new_line_content": "  return a->TopLevel()->vreg() < b->TopLevel()->vreg();",
          "content_same": false
        },
        {
          "line": 2702,
          "old_api": null,
          "new_api": "TRACE",
          "old_text": null,
          "new_text": "TRACE(\"Sort unhandled\\n\")",
          "old_line_content": "}",
          "new_line_content": "  TRACE(\"Sort unhandled\\n\");",
          "content_same": false
        },
        {
          "line": 2703,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "unhandled_live_ranges().end()",
          "old_line_content": "",
          "new_line_content": "  std::sort(unhandled_live_ranges().begin(), unhandled_live_ranges().end(),",
          "content_same": false
        },
        {
          "line": 2709,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "unhandled_live_ranges().size()",
          "old_line_content": "}",
          "new_line_content": "  size_t len = unhandled_live_ranges().size();",
          "content_same": false
        },
        {
          "line": 2711,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "unhandled_live_ranges().at(i - 1)",
          "old_line_content": "",
          "new_line_content": "    LiveRange* a = unhandled_live_ranges().at(i - 1);",
          "content_same": false
        },
        {
          "line": 2712,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "unhandled_live_ranges().at(i)",
          "old_line_content": "void LinearScanAllocator::ActiveToInactive(LiveRange* range) {",
          "new_line_content": "    LiveRange* b = unhandled_live_ranges().at(i);",
          "content_same": false
        },
        {
          "line": 2720,
          "old_api": null,
          "new_api": "active_live_ranges",
          "old_text": null,
          "new_text": "active_live_ranges()",
          "old_line_content": "void LinearScanAllocator::InactiveToHandled(LiveRange* range) {",
          "new_line_content": "  RemoveElement(&active_live_ranges(), range);",
          "content_same": false
        },
        {
          "line": 2727,
          "old_api": null,
          "new_api": "active_live_ranges",
          "old_text": null,
          "new_text": "active_live_ranges()",
          "old_line_content": "void LinearScanAllocator::InactiveToActive(LiveRange* range) {",
          "new_line_content": "  RemoveElement(&active_live_ranges(), range);",
          "content_same": false
        },
        {
          "line": 2735,
          "old_api": null,
          "new_api": "inactive_live_ranges",
          "old_text": null,
          "new_text": "inactive_live_ranges()",
          "old_line_content": "bool LinearScanAllocator::TryAllocateFreeReg(LiveRange* current) {",
          "new_line_content": "  RemoveElement(&inactive_live_ranges(), range);",
          "content_same": false
        },
        {
          "line": 2736,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "TRACE(\"Moving live range %d:%d from inactive to handled\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "old_line_content": "  LifetimePosition free_until_pos[RegisterConfiguration::kMaxDoubleRegisters];",
          "new_line_content": "  TRACE(\"Moving live range %d:%d from inactive to handled\\n\",",
          "content_same": false
        },
        {
          "line": 2737,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "range->relative_id()",
          "old_line_content": "",
          "new_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "content_same": false
        },
        {
          "line": 2752,
          "old_api": null,
          "new_api": "num_registers",
          "old_text": null,
          "new_text": "num_registers()",
          "old_line_content": "    LifetimePosition next_intersection =",
          "new_line_content": "  for (int i = 0; i < num_registers(); i++) {",
          "content_same": false
        },
        {
          "line": 2759,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "TRACE(\"Register %s is free until pos %d (1)\\n\",\n          RegisterName(cur_active->assigned_register()),\n          LifetimePosition::GapFromInstructionIndex(0).value())",
          "old_line_content": "  }",
          "new_line_content": "    TRACE(\"Register %s is free until pos %d (1)\\n\",",
          "content_same": false
        },
        {
          "line": 2760,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "cur_active->assigned_register()",
          "old_line_content": "",
          "new_line_content": "          RegisterName(cur_active->assigned_register()),",
          "content_same": false
        },
        {
          "line": 2761,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(0).value()",
          "old_line_content": "  int hint_register;",
          "new_line_content": "          LifetimePosition::GapFromInstructionIndex(0).value());",
          "content_same": false
        },
        {
          "line": 2764,
          "old_api": null,
          "new_api": "inactive_live_ranges",
          "old_text": null,
          "new_text": "inactive_live_ranges()",
          "old_line_content": "        \"Found reg hint %s (free until [%d) for live range %d:%d (end %d[).\\n\",",
          "new_line_content": "  for (LiveRange* cur_inactive : inactive_live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2768,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "next_intersection.IsValid()",
          "old_line_content": "",
          "new_line_content": "    if (!next_intersection.IsValid()) continue;",
          "content_same": false
        },
        {
          "line": 2769,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "cur_inactive->assigned_register()",
          "old_line_content": "    // The desired register is free until the end of the current live range.",
          "new_line_content": "    int cur_reg = cur_inactive->assigned_register();",
          "content_same": false
        },
        {
          "line": 2776,
          "old_api": null,
          "new_api": "FirstHintPosition",
          "old_text": null,
          "new_text": "current->FirstHintPosition(&hint_register)",
          "old_line_content": "    }",
          "new_line_content": "  if (current->FirstHintPosition(&hint_register) != nullptr) {",
          "content_same": false
        },
        {
          "line": 2777,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "TRACE(\n        \"Found reg hint %s (free until [%d) for live range %d:%d (end %d[).\\n\",\n        RegisterName(hint_register), free_until_pos[hint_register].value(),\n        current->TopLevel()->vreg(), current->relative_id(),\n        current->End().value())",
          "old_line_content": "  }",
          "new_line_content": "    TRACE(",
          "content_same": false
        },
        {
          "line": 2779,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "free_until_pos[hint_register].value()",
          "old_line_content": "  // Find the register which stays free for the longest time.",
          "new_line_content": "        RegisterName(hint_register), free_until_pos[hint_register].value(),",
          "content_same": false
        },
        {
          "line": 2784,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "current->End()",
          "old_line_content": "      reg = code;",
          "new_line_content": "    if (free_until_pos[hint_register] >= current->End()) {",
          "content_same": false
        },
        {
          "line": 2785,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "TRACE(\"Assigning preferred reg %s to live range %d:%d\\n\",\n            RegisterName(hint_register), current->TopLevel()->vreg(),\n            current->relative_id())",
          "old_line_content": "    }",
          "new_line_content": "      TRACE(\"Assigning preferred reg %s to live range %d:%d\\n\",",
          "content_same": false
        },
        {
          "line": 2786,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "current->TopLevel()->vreg()",
          "old_line_content": "  }",
          "new_line_content": "            RegisterName(hint_register), current->TopLevel()->vreg(),",
          "content_same": false
        },
        {
          "line": 2787,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "current->relative_id()",
          "old_line_content": "",
          "new_line_content": "            current->relative_id());",
          "content_same": false
        },
        {
          "line": 2788,
          "old_api": null,
          "new_api": "SetLiveRangeAssignedRegister",
          "old_text": null,
          "new_text": "SetLiveRangeAssignedRegister(current, hint_register)",
          "old_line_content": "  LifetimePosition pos = free_until_pos[reg];",
          "new_line_content": "      SetLiveRangeAssignedRegister(current, hint_register);",
          "content_same": false
        },
        {
          "line": 2794,
          "old_api": null,
          "new_api": "allocatable_register_code",
          "old_text": null,
          "new_text": "allocatable_register_code(0)",
          "old_line_content": "",
          "new_line_content": "  int reg = allocatable_register_code(0);",
          "content_same": false
        },
        {
          "line": 2796,
          "old_api": null,
          "new_api": "allocatable_register_code",
          "old_text": null,
          "new_text": "allocatable_register_code(i)",
          "old_line_content": "    // Register reg is available at the range start but becomes blocked before",
          "new_line_content": "    int code = allocatable_register_code(i);",
          "content_same": false
        },
        {
          "line": 2809,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "current->End()",
          "old_line_content": "  return true;",
          "new_line_content": "  if (pos < current->End()) {",
          "content_same": false
        },
        {
          "line": 2812,
          "old_api": null,
          "new_api": "SplitRangeAt",
          "old_text": null,
          "new_text": "SplitRangeAt(current, pos)",
          "old_line_content": "",
          "new_line_content": "    LiveRange* tail = SplitRangeAt(current, pos);",
          "content_same": false
        },
        {
          "line": 2813,
          "old_api": null,
          "new_api": "AddToUnhandledSorted",
          "old_text": null,
          "new_text": "AddToUnhandledSorted(tail)",
          "old_line_content": "void LinearScanAllocator::AllocateBlockedReg(LiveRange* current) {",
          "new_line_content": "    AddToUnhandledSorted(tail);",
          "content_same": false
        },
        {
          "line": 2819,
          "old_api": null,
          "new_api": "RegisterName",
          "old_text": null,
          "new_text": "RegisterName(reg)",
          "old_line_content": "    return;",
          "new_line_content": "  TRACE(\"Assigning free reg %s to live range %d:%d\\n\", RegisterName(reg),",
          "content_same": false
        },
        {
          "line": 2820,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "current->relative_id()",
          "old_line_content": "  }",
          "new_line_content": "        current->TopLevel()->vreg(), current->relative_id());",
          "content_same": false
        },
        {
          "line": 2821,
          "old_api": null,
          "new_api": "SetLiveRangeAssignedRegister",
          "old_text": null,
          "new_text": "SetLiveRangeAssignedRegister(current, reg)",
          "old_line_content": "",
          "new_line_content": "  SetLiveRangeAssignedRegister(current, reg);",
          "content_same": false
        },
        {
          "line": 2828,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "",
          "new_line_content": "  UsePosition* register_use = current->NextRegisterPosition(current->Start());",
          "content_same": false
        },
        {
          "line": 2840,
          "old_api": null,
          "new_api": "LifetimePosition::MaxPosition()",
          "old_text": null,
          "new_text": "LifetimePosition::MaxPosition()",
          "old_line_content": "      } else {",
          "new_line_content": "    use_pos[i] = block_pos[i] = LifetimePosition::MaxPosition();",
          "content_same": false
        },
        {
          "line": 2843,
          "old_api": null,
          "new_api": "active_live_ranges",
          "old_text": null,
          "new_text": "active_live_ranges()",
          "old_line_content": "    }",
          "new_line_content": "  for (LiveRange* range : active_live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2844,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "range->assigned_register()",
          "old_line_content": "  }",
          "new_line_content": "    int cur_reg = range->assigned_register();",
          "content_same": false
        },
        {
          "line": 2845,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->IsFixed()",
          "old_line_content": "",
          "new_line_content": "    if (range->TopLevel()->IsFixed() ||",
          "content_same": false
        },
        {
          "line": 2862,
          "old_api": null,
          "new_api": "FirstIntersection",
          "old_text": null,
          "new_text": "range->FirstIntersection(current)",
          "old_line_content": "    if (use_pos[code] > use_pos[reg]) {",
          "new_line_content": "    LifetimePosition next_intersection = range->FirstIntersection(current);",
          "content_same": false
        },
        {
          "line": 2863,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "next_intersection.IsValid()",
          "old_line_content": "      reg = code;",
          "new_line_content": "    if (!next_intersection.IsValid()) continue;",
          "content_same": false
        },
        {
          "line": 2864,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "range->assigned_register()",
          "old_line_content": "    }",
          "new_line_content": "    int cur_reg = range->assigned_register();",
          "content_same": false
        },
        {
          "line": 2865,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->IsFixed()",
          "old_line_content": "  }",
          "new_line_content": "    if (range->TopLevel()->IsFixed()) {",
          "content_same": false
        },
        {
          "line": 2866,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(block_pos[cur_reg], next_intersection)",
          "old_line_content": "",
          "new_line_content": "      block_pos[cur_reg] = Min(block_pos[cur_reg], next_intersection);",
          "content_same": false
        },
        {
          "line": 2867,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(block_pos[cur_reg], use_pos[cur_reg])",
          "old_line_content": "  LifetimePosition pos = use_pos[reg];",
          "new_line_content": "      use_pos[cur_reg] = Min(block_pos[cur_reg], use_pos[cur_reg]);",
          "content_same": false
        },
        {
          "line": 2873,
          "old_api": null,
          "new_api": "allocatable_register_code",
          "old_text": null,
          "new_text": "allocatable_register_code(0)",
          "old_line_content": "    return;",
          "new_line_content": "  int reg = allocatable_register_code(0);",
          "content_same": false
        },
        {
          "line": 2874,
          "old_api": null,
          "new_api": "num_allocatable_registers",
          "old_text": null,
          "new_text": "num_allocatable_registers()",
          "old_line_content": "  }",
          "new_line_content": "  for (int i = 1; i < num_allocatable_registers(); ++i) {",
          "content_same": false
        },
        {
          "line": 2875,
          "old_api": null,
          "new_api": "allocatable_register_code",
          "old_text": null,
          "new_text": "allocatable_register_code(i)",
          "old_line_content": "",
          "new_line_content": "    int code = allocatable_register_code(i);",
          "content_same": false
        },
        {
          "line": 2883,
          "old_api": null,
          "new_api": "pos",
          "old_text": null,
          "new_text": "register_use->pos()",
          "old_line_content": "",
          "new_line_content": "  if (pos < register_use->pos()) {",
          "content_same": false
        },
        {
          "line": 2890,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "current->End()",
          "old_line_content": "  // This register was not free. Thus we need to find and spill",
          "new_line_content": "  if (block_pos[reg] < current->End()) {",
          "content_same": false
        },
        {
          "line": 2894,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "block_pos[reg].Start()",
          "old_line_content": "}",
          "new_line_content": "        SplitBetween(current, current->Start(), block_pos[reg].Start());",
          "content_same": false
        },
        {
          "line": 2895,
          "old_api": null,
          "new_api": "AddToUnhandledSorted",
          "old_text": null,
          "new_text": "AddToUnhandledSorted(tail)",
          "old_line_content": "",
          "new_line_content": "    AddToUnhandledSorted(tail);",
          "content_same": false
        },
        {
          "line": 2912,
          "old_api": null,
          "new_api": "HasRegisterAssigned",
          "old_text": null,
          "new_text": "current->HasRegisterAssigned()",
          "old_line_content": "        // start before the current range as this violates allocation invariant",
          "new_line_content": "  DCHECK(current->HasRegisterAssigned());",
          "content_same": false
        },
        {
          "line": 2913,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "current->assigned_register()",
          "old_line_content": "        // and will lead to an inconsistent state of active and inactive",
          "new_line_content": "  int reg = current->assigned_register();",
          "content_same": false
        },
        {
          "line": 2914,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "        // live-ranges: ranges are allocated in order of their start positions,",
          "new_line_content": "  LifetimePosition split_pos = current->Start();",
          "content_same": false
        },
        {
          "line": 2915,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "active_live_ranges().size()",
          "old_line_content": "        // ranges are retired from active/inactive when the start of the",
          "new_line_content": "  for (size_t i = 0; i < active_live_ranges().size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2916,
          "old_api": null,
          "new_api": "active_live_ranges",
          "old_text": null,
          "new_text": "active_live_ranges()",
          "old_line_content": "        // current live-range is larger than their end.",
          "new_line_content": "    LiveRange* range = active_live_ranges()[i];",
          "content_same": false
        },
        {
          "line": 2918,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "      }",
          "new_line_content": "      UsePosition* next_pos = range->NextRegisterPosition(current->Start());",
          "content_same": false
        },
        {
          "line": 2921,
          "old_api": null,
          "new_api": "SpillAfter",
          "old_text": null,
          "new_text": "SpillAfter(range, spill_pos)",
          "old_line_content": "    }",
          "new_line_content": "        SpillAfter(range, spill_pos);",
          "content_same": false
        },
        {
          "line": 2931,
          "old_api": null,
          "new_api": "pos",
          "old_text": null,
          "new_text": "next_pos->pos()",
          "old_line_content": "        if (next_pos == nullptr) {",
          "new_line_content": "        SpillBetweenUntil(range, spill_pos, current->Start(), next_pos->pos());",
          "content_same": false
        },
        {
          "line": 2933,
          "old_api": null,
          "new_api": "ActiveToHandled",
          "old_text": null,
          "new_text": "ActiveToHandled(range)",
          "old_line_content": "        } else {",
          "new_line_content": "      ActiveToHandled(range);",
          "content_same": false
        },
        {
          "line": 2938,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inactive_live_ranges().size()",
          "old_line_content": "        --i;",
          "new_line_content": "  for (size_t i = 0; i < inactive_live_ranges().size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2939,
          "old_api": null,
          "new_api": "inactive_live_ranges",
          "old_text": null,
          "new_text": "inactive_live_ranges()",
          "old_line_content": "      }",
          "new_line_content": "    LiveRange* range = inactive_live_ranges()[i];",
          "content_same": false
        },
        {
          "line": 2940,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "    }",
          "new_line_content": "    DCHECK(range->End() > current->Start());",
          "content_same": false
        },
        {
          "line": 2941,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->IsFixed()",
          "old_line_content": "  }",
          "new_line_content": "    if (range->assigned_register() == reg && !range->TopLevel()->IsFixed()) {",
          "content_same": false
        },
        {
          "line": 2942,
          "old_api": null,
          "new_api": "FirstIntersection",
          "old_text": null,
          "new_text": "range->FirstIntersection(current)",
          "old_line_content": "}",
          "new_line_content": "      LifetimePosition next_intersection = range->FirstIntersection(current);",
          "content_same": false
        },
        {
          "line": 2943,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "next_intersection.IsValid()",
          "old_line_content": "",
          "new_line_content": "      if (next_intersection.IsValid()) {",
          "content_same": false
        },
        {
          "line": 2944,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "",
          "new_line_content": "        UsePosition* next_pos = range->NextRegisterPosition(current->Start());",
          "content_same": false
        },
        {
          "line": 2949,
          "old_api": null,
          "new_api": "SpillBetween",
          "old_text": null,
          "new_text": "SpillBetween(range, split_pos, next_intersection)",
          "old_line_content": "  RegisterAllocationData::PhiMapValue* phi_map_value =",
          "new_line_content": "          SpillBetween(range, split_pos, next_intersection);",
          "content_same": false
        },
        {
          "line": 2960,
          "old_api": null,
          "new_api": "is_phi",
          "old_text": null,
          "new_text": "range->is_phi()",
          "old_line_content": "    const InstructionBlock* pred =",
          "new_line_content": "  if (!range->is_phi()) return false;",
          "content_same": false
        },
        {
          "line": 2962,
          "old_api": null,
          "new_api": "HasSpillOperand",
          "old_text": null,
          "new_text": "range->HasSpillOperand()",
          "old_line_content": "    LifetimePosition pred_end =",
          "new_line_content": "  DCHECK(!range->HasSpillOperand());",
          "content_same": false
        },
        {
          "line": 2970,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "phi->operands().size()",
          "old_line_content": "      if (first_op == nullptr) {",
          "new_line_content": "  for (size_t i = 0; i < phi->operands().size(); i++) {",
          "content_same": false
        },
        {
          "line": 2972,
          "old_api": null,
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": null,
          "new_text": "data()->GetOrCreateLiveRangeFor(op)",
          "old_line_content": "      }",
          "new_line_content": "    LiveRange* op_range = data()->GetOrCreateLiveRangeFor(op);",
          "content_same": false
        },
        {
          "line": 2973,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "op_range->TopLevel()->HasSpillRange()",
          "old_line_content": "    }",
          "new_line_content": "    if (!op_range->TopLevel()->HasSpillRange()) continue;",
          "content_same": false
        },
        {
          "line": 2975,
          "old_api": null,
          "new_api": "predecessors",
          "old_text": null,
          "new_text": "block->predecessors()",
          "old_line_content": "",
          "new_line_content": "        code()->InstructionBlockAt(block->predecessors()[i]);",
          "content_same": false
        },
        {
          "line": 2978,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "pred->last_instruction_index()",
          "old_line_content": "    return false;",
          "new_line_content": "            pred->last_instruction_index());",
          "content_same": false
        },
        {
          "line": 2979,
          "old_api": null,
          "new_api": "CanCover",
          "old_text": null,
          "new_text": "op_range->CanCover(pred_end)",
          "old_line_content": "  }",
          "new_line_content": "    while (op_range != nullptr && !op_range->CanCover(pred_end)) {",
          "content_same": false
        },
        {
          "line": 2980,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "op_range->next()",
          "old_line_content": "",
          "new_line_content": "      op_range = op_range->next();",
          "content_same": false
        },
        {
          "line": 2982,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "op_range->spilled()",
          "old_line_content": "  // operands.",
          "new_line_content": "    if (op_range != nullptr && op_range->spilled()) {",
          "content_same": false
        },
        {
          "line": 2985,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "op_range->TopLevel()",
          "old_line_content": "  size_t num_merged = 1;",
          "new_line_content": "        first_op = op_range->TopLevel();",
          "content_same": false
        },
        {
          "line": 2997,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(first_op != nullptr)",
          "old_line_content": "  // same spill slot.",
          "new_line_content": "  DCHECK(first_op != nullptr);",
          "content_same": false
        },
        {
          "line": 3001,
          "old_api": null,
          "new_api": "operands",
          "old_text": null,
          "new_text": "phi->operands()",
          "old_line_content": "    return false;",
          "new_line_content": "    int op = phi->operands()[i];",
          "content_same": false
        },
        {
          "line": 3002,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "  }",
          "new_line_content": "    TopLevelLiveRange* op_range = data()->live_ranges()[op];",
          "content_same": false
        },
        {
          "line": 3003,
          "old_api": null,
          "new_api": "HasSpillRange",
          "old_text": null,
          "new_text": "op_range->HasSpillRange()",
          "old_line_content": "",
          "new_line_content": "    if (!op_range->HasSpillRange()) continue;",
          "content_same": false
        },
        {
          "line": 3004,
          "old_api": null,
          "new_api": "GetSpillRange",
          "old_text": null,
          "new_text": "op_range->GetSpillRange()",
          "old_line_content": "  // If the range does not need register soon, spill it to the merged",
          "new_line_content": "    SpillRange* op_spill = op_range->GetSpillRange();",
          "content_same": false
        },
        {
          "line": 3005,
          "old_api": null,
          "new_api": "TryMerge",
          "old_text": null,
          "new_text": "first_op_spill->TryMerge(op_spill)",
          "old_line_content": "  // spill range.",
          "new_line_content": "    if (op_spill == first_op_spill || first_op_spill->TryMerge(op_spill)) {",
          "content_same": false
        },
        {
          "line": 3027,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()",
          "old_line_content": "    return true;",
          "new_line_content": "            : data()->AssignSpillRangeToLiveRange(range->TopLevel());",
          "content_same": false
        },
        {
          "line": 3028,
          "old_api": null,
          "new_api": "TryMerge",
          "old_text": null,
          "new_text": "first_op_spill->TryMerge(spill_range)",
          "old_line_content": "  }",
          "new_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "content_same": false
        },
        {
          "line": 3029,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(merged)",
          "old_line_content": "  return false;",
          "new_line_content": "    CHECK(merged);",
          "content_same": false
        },
        {
          "line": 3030,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "Spill(range)",
          "old_line_content": "}",
          "new_line_content": "    Spill(range);",
          "content_same": false
        },
        {
          "line": 3032,
          "old_api": null,
          "new_api": "NextStart",
          "old_text": null,
          "new_text": "range->Start().NextStart()",
          "old_line_content": "",
          "new_line_content": "  } else if (pos->pos() > range->Start().NextStart()) {",
          "content_same": false
        },
        {
          "line": 3036,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()",
          "old_line_content": "}",
          "new_line_content": "            : data()->AssignSpillRangeToLiveRange(range->TopLevel());",
          "content_same": false
        },
        {
          "line": 3037,
          "old_api": null,
          "new_api": "TryMerge",
          "old_text": null,
          "new_text": "first_op_spill->TryMerge(spill_range)",
          "old_line_content": "",
          "new_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "content_same": false
        },
        {
          "line": 3038,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(merged)",
          "old_line_content": "",
          "new_line_content": "    CHECK(merged);",
          "content_same": false
        },
        {
          "line": 3039,
          "old_api": null,
          "new_api": "pos",
          "old_text": null,
          "new_text": "pos->pos()",
          "old_line_content": "void LinearScanAllocator::SpillBetween(LiveRange* range, LifetimePosition start,",
          "new_line_content": "    SpillBetween(range, range->Start(), pos->pos());",
          "content_same": false
        },
        {
          "line": 3040,
          "old_api": null,
          "new_api": "UnhandledIsSorted",
          "old_text": null,
          "new_text": "UnhandledIsSorted()",
          "old_line_content": "                                       LifetimePosition end) {",
          "new_line_content": "    DCHECK(UnhandledIsSorted());",
          "content_same": false
        },
        {
          "line": 3048,
          "old_api": null,
          "new_api": "SplitRangeAt",
          "old_text": null,
          "new_text": "SplitRangeAt(range, pos)",
          "old_line_content": "                                            LifetimePosition end) {",
          "new_line_content": "  LiveRange* second_part = SplitRangeAt(range, pos);",
          "content_same": false
        },
        {
          "line": 3055,
          "old_api": null,
          "new_api": "SpillBetweenUntil",
          "old_text": null,
          "new_text": "SpillBetweenUntil(range, start, start, end)",
          "old_line_content": "    // and put the rest to unhandled.",
          "new_line_content": "  SpillBetweenUntil(range, start, start, end);",
          "content_same": false
        },
        {
          "line": 3064,
          "old_api": null,
          "new_api": "SplitRangeAt",
          "old_text": null,
          "new_text": "SplitRangeAt(range, start)",
          "old_line_content": "",
          "new_line_content": "  LiveRange* second_part = SplitRangeAt(range, start);",
          "content_same": false
        },
        {
          "line": 3071,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "end.Start()",
          "old_line_content": "  }",
          "new_line_content": "    if (data()->IsBlockBoundary(end.Start())) {",
          "content_same": false
        },
        {
          "line": 3072,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "end.Start()",
          "old_line_content": "}",
          "new_line_content": "      third_part_end = end.Start();",
          "content_same": false
        },
        {
          "line": 3074,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "SplitBetween(\n        second_part, Max(second_part->Start().End(), until), third_part_end)",
          "old_line_content": "",
          "new_line_content": "    LiveRange* third_part = SplitBetween(",
          "content_same": false
        },
        {
          "line": 3075,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "second_part->Start().End()",
          "old_line_content": "SpillSlotLocator::SpillSlotLocator(RegisterAllocationData* data)",
          "new_line_content": "        second_part, Max(second_part->Start().End(), until), third_part_end);",
          "content_same": false
        },
        {
          "line": 3077,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(third_part != second_part)",
          "old_line_content": "",
          "new_line_content": "    DCHECK(third_part != second_part);",
          "content_same": false
        },
        {
          "line": 3079,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "Spill(second_part)",
          "old_line_content": "void SpillSlotLocator::LocateSpillSlots() {",
          "new_line_content": "    Spill(second_part);",
          "content_same": false
        },
        {
          "line": 3096,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "range->IsEmpty()",
          "old_line_content": "      for (; spills != nullptr; spills = spills->next) {",
          "new_line_content": "    if (range == nullptr || range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 3098,
          "old_api": null,
          "new_api": "HasSpillRange",
          "old_text": null,
          "new_text": "range->HasSpillRange()",
          "old_line_content": "      }",
          "new_line_content": "    if (!range->HasSpillRange()) continue;",
          "content_same": false
        },
        {
          "line": 3099,
          "old_api": null,
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": null,
          "new_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "    }",
          "new_line_content": "    if (range->IsSpilledOnlyInDeferredBlocks()) {",
          "content_same": false
        },
        {
          "line": 3100,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "child->next()",
          "old_line_content": "  }",
          "new_line_content": "      for (LiveRange* child = range; child != nullptr; child = child->next()) {",
          "content_same": false
        },
        {
          "line": 3101,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "child->spilled()",
          "old_line_content": "}",
          "new_line_content": "        if (child->spilled()) {",
          "content_same": false
        },
        {
          "line": 3102,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "child->Start().ToInstructionIndex()",
          "old_line_content": "",
          "new_line_content": "          code->GetInstructionBlock(child->Start().ToInstructionIndex())",
          "content_same": false
        },
        {
          "line": 3109,
          "old_api": null,
          "new_api": "DCHECK_NOT_NULL",
          "old_text": null,
          "new_text": "DCHECK_NOT_NULL(spills)",
          "old_line_content": "  // Merge disjoint spill ranges",
          "new_line_content": "      DCHECK_NOT_NULL(spills);",
          "content_same": false
        },
        {
          "line": 3111,
          "old_api": null,
          "new_api": "GetInstructionBlock",
          "old_text": null,
          "new_text": "code->GetInstructionBlock(spills->gap_index)->mark_needs_frame()",
          "old_line_content": "    SpillRange* range = spill_ranges[i];",
          "new_line_content": "        code->GetInstructionBlock(spills->gap_index)->mark_needs_frame();",
          "content_same": false
        },
        {
          "line": 3122,
          "old_api": null,
          "new_api": "spill_ranges",
          "old_text": null,
          "new_text": "data()->spill_ranges()",
          "old_line_content": "  for (SpillRange* range : spill_ranges) {",
          "new_line_content": "  ZoneVector<SpillRange*>& spill_ranges = data()->spill_ranges();",
          "content_same": false
        },
        {
          "line": 3124,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "spill_ranges.size()",
          "old_line_content": "    // Allocate a new operand referring to the spill slot.",
          "new_line_content": "  for (size_t i = 0; i < spill_ranges.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 3130,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "other->IsEmpty()",
          "old_line_content": "  }",
          "new_line_content": "      if (other != nullptr && !other->IsEmpty()) {",
          "content_same": false
        },
        {
          "line": 3131,
          "old_api": null,
          "new_api": "TryMerge",
          "old_text": null,
          "new_text": "range->TryMerge(other)",
          "old_line_content": "}",
          "new_line_content": "        range->TryMerge(other);",
          "content_same": false
        },
        {
          "line": 3137,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "range->IsEmpty()",
          "old_line_content": "    InstructionOperand spill_operand;",
          "new_line_content": "    if (range == nullptr || range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 3142,
          "old_api": null,
          "new_api": "set_assigned_slot",
          "old_text": null,
          "new_text": "range->set_assigned_slot(index)",
          "old_line_content": "    }",
          "new_line_content": "      range->set_assigned_slot(index);",
          "content_same": false
        },
        {
          "line": 3152,
          "old_api": null,
          "new_api": "HasSpillOperand",
          "old_text": null,
          "new_text": "top_range->HasSpillOperand()",
          "old_line_content": "",
          "new_line_content": "    if (top_range->HasSpillOperand()) {",
          "content_same": false
        },
        {
          "line": 3154,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "top_range->TopLevel()->HasSpillRange()",
          "old_line_content": "      // If this top level range has a child spilled in a deferred block, we use",
          "new_line_content": "    } else if (top_range->TopLevel()->HasSpillRange()) {",
          "content_same": false
        },
        {
          "line": 3155,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "top_range->TopLevel()->GetSpillRangeOperand()",
          "old_line_content": "      // the range and control flow connection mechanism instead of spilling at",
          "new_line_content": "      spill_operand = top_range->TopLevel()->GetSpillRangeOperand();",
          "content_same": false
        },
        {
          "line": 3157,
          "old_api": null,
          "new_api": "is_phi",
          "old_text": null,
          "new_text": "top_range->is_phi()",
          "old_line_content": "      // phases. Normally, when we spill at definition, we do not insert a",
          "new_line_content": "    if (top_range->is_phi()) {",
          "content_same": false
        },
        {
          "line": 3158,
          "old_api": null,
          "new_api": "GetPhiMapValueFor",
          "old_text": null,
          "new_text": "data()->GetPhiMapValueFor(top_range)->CommitAssignment(\n          top_range->GetAssignedOperand())",
          "old_line_content": "      // connecting move when a successor child range is spilled - because the",
          "new_line_content": "      data()->GetPhiMapValueFor(top_range)->CommitAssignment(",
          "content_same": false
        },
        {
          "line": 3159,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "top_range->GetAssignedOperand()",
          "old_line_content": "      // spilled range picks up its value from the slot which was assigned at",
          "new_line_content": "          top_range->GetAssignedOperand());",
          "content_same": false
        },
        {
          "line": 3162,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "range->next()",
          "old_line_content": "      // where a spill operand is expected, and then finalize by inserting the",
          "new_line_content": "         range = range->next()) {",
          "content_same": false
        },
        {
          "line": 3163,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "range->GetAssignedOperand()",
          "old_line_content": "      // spills in the deferred blocks dominators.",
          "new_line_content": "      InstructionOperand assigned = range->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3178,
          "old_api": null,
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": null,
          "new_text": "top_range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "",
          "new_line_content": "      if (!top_range->IsSpilledOnlyInDeferredBlocks()) {",
          "content_same": false
        },
        {
          "line": 3181,
          "old_api": null,
          "new_api": "CommitSpillMoves",
          "old_text": null,
          "new_text": "top_range->CommitSpillMoves(\n            data()->code(), spill_operand,\n            top_range->has_slot_use() || top_range->spilled())",
          "old_line_content": "  int safe_point = 0;",
          "new_line_content": "        top_range->CommitSpillMoves(",
          "content_same": false
        },
        {
          "line": 3197,
          "old_api": null,
          "new_api": "instruction_position",
          "old_text": null,
          "new_text": "map->instruction_position()",
          "old_line_content": "  }",
          "new_line_content": "    if (safe_point > map->instruction_position()) return false;",
          "content_same": false
        },
        {
          "line": 3198,
          "old_api": null,
          "new_api": "instruction_position",
          "old_text": null,
          "new_text": "map->instruction_position()",
          "old_line_content": "  // Iterate over all safe point positions and record a pointer",
          "new_line_content": "    safe_point = map->instruction_position();",
          "content_same": false
        },
        {
          "line": 3205,
          "old_api": null,
          "new_api": "SafePointsAreInOrder",
          "old_text": null,
          "new_text": "SafePointsAreInOrder()",
          "old_line_content": "    // Skip non-reference values.",
          "new_line_content": "  DCHECK(SafePointsAreInOrder());",
          "content_same": false
        },
        {
          "line": 3210,
          "old_api": null,
          "new_api": "AllocatedOperand::cast(*delayed_reference.operand)",
          "old_text": null,
          "new_text": "AllocatedOperand::cast(*delayed_reference.operand)",
          "old_line_content": "",
          "new_line_content": "        AllocatedOperand::cast(*delayed_reference.operand));",
          "content_same": false
        },
        {
          "line": 3220,
          "old_api": null,
          "new_api": "IsReference",
          "old_text": null,
          "new_text": "data()->IsReference(range)",
          "old_line_content": "",
          "new_line_content": "    if (!data()->IsReference(range)) continue;",
          "content_same": false
        },
        {
          "line": 3222,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "range->IsEmpty()",
          "old_line_content": "    // step backwards and reset the first_it so we don't miss any safe points.",
          "new_line_content": "    if (range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 3226,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "range->Start().ToInstructionIndex()",
          "old_line_content": "    // Step across all the safe points that are before the start of this range,",
          "new_line_content": "    int start = range->Start().ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 3229,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "cur->End()",
          "old_line_content": "      ReferenceMap* map = *first_it;",
          "new_line_content": "      LifetimePosition this_end = cur->End();",
          "content_same": false
        },
        {
          "line": 3231,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "this_end.ToInstructionIndex()",
          "old_line_content": "    }",
          "new_line_content": "        end = this_end.ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 3232,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "cur->Start().ToInstructionIndex()",
          "old_line_content": "",
          "new_line_content": "      DCHECK(cur->Start().ToInstructionIndex() >= start);",
          "content_same": false
        },
        {
          "line": 3248,
          "old_api": null,
          "new_api": "HasSpillOperand",
          "old_text": null,
          "new_text": "range->HasSpillOperand()",
          "old_line_content": "    // Step through the safe points to see whether they are in the range.",
          "new_line_content": "    if (((range->HasSpillOperand() &&",
          "content_same": false
        },
        {
          "line": 3250,
          "old_api": null,
          "new_api": "HasSpillRange",
          "old_text": null,
          "new_text": "range->HasSpillRange()",
          "old_line_content": "      ReferenceMap* map = *it;",
          "new_line_content": "         range->HasSpillRange())) {",
          "content_same": false
        },
        {
          "line": 3252,
          "old_api": null,
          "new_api": "GetSpillOperand",
          "old_text": null,
          "new_text": "range->GetSpillOperand()",
          "old_line_content": "",
          "new_line_content": "        spill_operand = *range->GetSpillOperand();",
          "content_same": false
        },
        {
          "line": 3254,
          "old_api": null,
          "new_api": "GetSpillRangeOperand",
          "old_text": null,
          "new_text": "range->GetSpillRangeOperand()",
          "old_line_content": "      if (safe_point - 1 > end) break;",
          "new_line_content": "        spill_operand = range->GetSpillRangeOperand();",
          "content_same": false
        },
        {
          "line": 3256,
          "old_api": null,
          "new_api": "IsStackSlot",
          "old_text": null,
          "new_text": "spill_operand.IsStackSlot()",
          "old_line_content": "      // Advance to the next active range that covers the current",
          "new_line_content": "      DCHECK(spill_operand.IsStackSlot());",
          "content_same": false
        },
        {
          "line": 3257,
          "old_api": null,
          "new_api": "representation",
          "old_text": null,
          "new_text": "DCHECK_EQ(MachineRepresentation::kTagged,\n                AllocatedOperand::cast(spill_operand).representation())",
          "old_line_content": "      // safe point position.",
          "new_line_content": "      DCHECK_EQ(MachineRepresentation::kTagged,",
          "content_same": false
        },
        {
          "line": 3258,
          "old_api": null,
          "new_api": "representation",
          "old_text": null,
          "new_text": "AllocatedOperand::cast(spill_operand).representation()",
          "old_line_content": "      LifetimePosition safe_point_pos =",
          "new_line_content": "                AllocatedOperand::cast(spill_operand).representation());",
          "content_same": false
        },
        {
          "line": 3263,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "reference_maps->end()",
          "old_line_content": "      // the last child, because the next safe_point_pos may be covered by cur.",
          "new_line_content": "    for (auto it = first_it; it != reference_maps->end(); ++it) {",
          "content_same": false
        },
        {
          "line": 3265,
          "old_api": null,
          "new_api": "instruction_position",
          "old_text": null,
          "new_text": "map->instruction_position()",
          "old_line_content": "      // safe_point_pos is in between intervals.",
          "new_line_content": "      int safe_point = map->instruction_position();",
          "content_same": false
        },
        {
          "line": 3273,
          "old_api": null,
          "new_api": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "old_text": null,
          "new_text": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "old_line_content": "        } else {",
          "new_line_content": "          LifetimePosition::InstructionFromInstructionIndex(safe_point);",
          "content_same": false
        },
        {
          "line": 3281,
          "old_api": null,
          "new_api": "DCHECK_NOT_NULL",
          "old_text": null,
          "new_text": "DCHECK_NOT_NULL(cur)",
          "old_line_content": "",
          "new_line_content": "      DCHECK_NOT_NULL(cur);",
          "content_same": false
        },
        {
          "line": 3282,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "cur->Start()",
          "old_line_content": "      if (!found) {",
          "new_line_content": "      DCHECK(safe_point_pos >= cur->Start() || range == cur);",
          "content_same": false
        },
        {
          "line": 3285,
          "old_api": null,
          "new_api": "Covers",
          "old_text": null,
          "new_text": "cur->Covers(safe_point_pos)",
          "old_line_content": "",
          "new_line_content": "        if (cur->Covers(safe_point_pos)) {",
          "content_same": false
        },
        {
          "line": 3303,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "cur->Start().ToInstructionIndex()",
          "old_line_content": "            safe_point);",
          "new_line_content": "                            ? cur->Start().ToInstructionIndex()",
          "content_same": false
        },
        {
          "line": 3309,
          "old_api": null,
          "new_api": "AllocatedOperand::cast(spill_operand)",
          "old_text": null,
          "new_text": "AllocatedOperand::cast(spill_operand)",
          "old_line_content": "      }",
          "new_line_content": "        map->RecordReference(AllocatedOperand::cast(spill_operand));",
          "content_same": false
        },
        {
          "line": 3312,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "cur->spilled()",
          "old_line_content": "}",
          "new_line_content": "      if (!cur->spilled()) {",
          "content_same": false
        },
        {
          "line": 3313,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "TRACE(\n            \"Pointer in register for range %d:%d (start at %d) \"\n            \"at safe point %d\\n\",\n            range->vreg(), cur->relative_id(), cur->Start().value(),\n            safe_point)",
          "old_line_content": "",
          "new_line_content": "        TRACE(",
          "content_same": false
        },
        {
          "line": 3316,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "cur->Start().value()",
          "old_line_content": "    : data_(data) {}",
          "new_line_content": "            range->vreg(), cur->relative_id(), cur->Start().value(),",
          "content_same": false
        },
        {
          "line": 3318,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "cur->GetAssignedOperand()",
          "old_line_content": "",
          "new_line_content": "        InstructionOperand operand = cur->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3319,
          "old_api": null,
          "new_api": "IsStackSlot",
          "old_text": null,
          "new_text": "operand.IsStackSlot()",
          "old_line_content": "bool LiveRangeConnector::CanEagerlyResolveControlFlow(",
          "new_line_content": "        DCHECK(!operand.IsStackSlot());",
          "content_same": false
        },
        {
          "line": 3320,
          "old_api": null,
          "new_api": "representation",
          "old_text": null,
          "new_text": "DCHECK_EQ(MachineRepresentation::kTagged,\n                  AllocatedOperand::cast(operand).representation())",
          "old_line_content": "    const InstructionBlock* block) const {",
          "new_line_content": "        DCHECK_EQ(MachineRepresentation::kTagged,",
          "content_same": false
        },
        {
          "line": 3346,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "block->rpo_number().ToInt()",
          "old_line_content": "          // We're doing a reload.",
          "new_line_content": "    BitVector* live = live_in_sets[block->rpo_number().ToInt()];",
          "content_same": false
        },
        {
          "line": 3348,
          "old_api": null,
          "new_api": "Done",
          "old_text": null,
          "new_text": "iterator.Done()",
          "old_line_content": "          // 1) there's no register use in this block, and",
          "new_line_content": "    while (!iterator.Done()) {",
          "content_same": false
        },
        {
          "line": 3349,
          "old_api": null,
          "new_api": "Current",
          "old_text": null,
          "new_text": "iterator.Current()",
          "old_line_content": "          // 2) the range ends before the block does, and",
          "new_line_content": "      LiveRangeBoundArray* array = finder.ArrayFor(iterator.Current());",
          "content_same": false
        },
        {
          "line": 3350,
          "old_api": null,
          "new_api": "predecessors",
          "old_text": null,
          "new_text": "block->predecessors()",
          "old_line_content": "          // 3) we don't have a successor, or the successor is spilled.",
          "new_line_content": "      for (const RpoNumber& pred : block->predecessors()) {",
          "content_same": false
        },
        {
          "line": 3353,
          "old_api": null,
          "new_api": "FindConnectableSubranges",
          "old_text": null,
          "new_text": "array->FindConnectableSubranges(block, pred_block, &result)",
          "old_line_content": "          LifetimePosition block_end =",
          "new_line_content": "        if (!array->FindConnectableSubranges(block, pred_block, &result)) {",
          "content_same": false
        },
        {
          "line": 3359,
          "old_api": null,
          "new_api": "IsAnyRegister",
          "old_text": null,
          "new_text": "cur_op.IsAnyRegister()",
          "old_line_content": "            // verify point 1: no register use. We can go to the end of the",
          "new_line_content": "        if (!pred_op.IsAnyRegister() && cur_op.IsAnyRegister()) {",
          "content_same": false
        },
        {
          "line": 3366,
          "old_api": null,
          "new_api": "code_start",
          "old_text": null,
          "new_text": "block->code_start()",
          "old_line_content": "                uses_reg = true;",
          "new_line_content": "              LifetimePosition::GapFromInstructionIndex(block->code_start());",
          "content_same": false
        },
        {
          "line": 3368,
          "old_api": null,
          "new_api": "code_end",
          "old_text": null,
          "new_text": "block->code_end()",
          "old_line_content": "              }",
          "new_line_content": "              LifetimePosition::GapFromInstructionIndex(block->code_end());",
          "content_same": false
        },
        {
          "line": 3370,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "current->next()",
          "old_line_content": "            if (!uses_reg) continue;",
          "new_line_content": "          const LiveRange* successor = current->next();",
          "content_same": false
        },
        {
          "line": 3371,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "current->End()",
          "old_line_content": "          }",
          "new_line_content": "          if (current->End() < block_end &&",
          "content_same": false
        },
        {
          "line": 3378,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "use->next()",
          "old_line_content": "          }",
          "new_line_content": "                 use != nullptr; use = use->next()) {",
          "content_same": false
        },
        {
          "line": 3379,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "use->operand()->IsAnyRegister()",
          "old_line_content": "        }",
          "new_line_content": "              if (use->operand()->IsAnyRegister()) {",
          "content_same": false
        },
        {
          "line": 3386,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "current->TopLevel()->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "      }",
          "new_line_content": "          if (current->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&",
          "content_same": false
        },
        {
          "line": 3390,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "current->TopLevel()->GetListOfBlocksRequiringSpillOperands()->Add(\n                pred_block->rpo_number().ToInt())",
          "old_line_content": "",
          "new_line_content": "            current->TopLevel()->GetListOfBlocksRequiringSpillOperands()->Add(",
          "content_same": false
        },
        {
          "line": 3391,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "pred_block->rpo_number().ToInt()",
          "old_line_content": "  // At this stage, we collected blocks needing a spill operand from",
          "new_line_content": "                pred_block->rpo_number().ToInt());",
          "content_same": false
        },
        {
          "line": 3397,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "      continue;",
          "new_line_content": "            result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&",
          "content_same": false
        },
        {
          "line": 3399,
          "old_api": null,
          "new_api": "GetInstructionBlock",
          "old_text": null,
          "new_text": "code()->GetInstructionBlock(move_loc)->IsDeferred()",
          "old_line_content": "  }",
          "new_line_content": "            code()->GetInstructionBlock(move_loc)->IsDeferred());",
          "content_same": false
        },
        {
          "line": 3401,
          "old_api": null,
          "new_api": "Advance",
          "old_text": null,
          "new_text": "iterator.Advance()",
          "old_line_content": "",
          "new_line_content": "      iterator.Advance();",
          "content_same": false
        },
        {
          "line": 3408,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "  int gap_index;",
          "new_line_content": "  for (TopLevelLiveRange* top : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3409,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "top->IsEmpty()",
          "old_line_content": "  Instruction::GapPosition position;",
          "new_line_content": "    if (top == nullptr || top->IsEmpty() ||",
          "content_same": false
        },
        {
          "line": 3412,
          "old_api": null,
          "new_api": "vreg",
          "old_text": null,
          "new_text": "top->vreg()",
          "old_line_content": "    position = Instruction::START;",
          "new_line_content": "    CommitSpillsInDeferredBlocks(top, finder.ArrayFor(top->vreg()), local_zone);",
          "content_same": false
        },
        {
          "line": 3424,
          "old_api": null,
          "new_api": "PredecessorCount",
          "old_text": null,
          "new_text": "block->PredecessorCount()",
          "old_line_content": "",
          "new_line_content": "  if (block->PredecessorCount() == 1) {",
          "content_same": false
        },
        {
          "line": 3425,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "block->first_instruction_index()",
          "old_line_content": "",
          "new_line_content": "    gap_index = block->first_instruction_index();",
          "content_same": false
        },
        {
          "line": 3429,
          "old_api": null,
          "new_api": "InstructionAt",
          "old_text": null,
          "new_text": "code()\n                ->InstructionAt(pred->last_instruction_index())\n                ->HasReferenceMap()",
          "old_line_content": "    if (top_range == nullptr) continue;",
          "new_line_content": "    DCHECK(!code()",
          "content_same": false
        },
        {
          "line": 3435,
          "old_api": null,
          "new_api": "AddGapMove",
          "old_text": null,
          "new_text": "data()->AddGapMove(gap_index, position, pred_op, cur_op)",
          "old_line_content": "      // Add gap move if the two live ranges touch and there is no block",
          "new_line_content": "  data()->AddGapMove(gap_index, position, pred_op, cur_op);",
          "content_same": false
        },
        {
          "line": 3442,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "      }",
          "new_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3446,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "first_range->next()",
          "old_line_content": "      bool delay_insertion = false;",
          "new_line_content": "    for (LiveRange *second_range = first_range->next(); second_range != nullptr;",
          "content_same": false
        },
        {
          "line": 3447,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "second_range->next()",
          "old_line_content": "      Instruction::GapPosition gap_pos;",
          "new_line_content": "         first_range = second_range, second_range = second_range->next()) {",
          "content_same": false
        },
        {
          "line": 3453,
          "old_api": null,
          "new_api": "IsBlockBoundary",
          "old_text": null,
          "new_text": "data()->IsBlockBoundary(pos)",
          "old_line_content": "        // Performing a reload in this block, meaning the spill operand must",
          "new_line_content": "      if (data()->IsBlockBoundary(pos) &&",
          "content_same": false
        },
        {
          "line": 3454,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "code()",
          "old_line_content": "        // be defined here.",
          "new_line_content": "          !CanEagerlyResolveControlFlow(GetInstructionBlock(code(), pos))) {",
          "content_same": false
        },
        {
          "line": 3457,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "first_range->GetAssignedOperand()",
          "old_line_content": "      }",
          "new_line_content": "      InstructionOperand prev_operand = first_range->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3458,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "second_range->GetAssignedOperand()",
          "old_line_content": "",
          "new_line_content": "      InstructionOperand cur_operand = second_range->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3463,
          "old_api": null,
          "new_api": "IsAnyRegister",
          "old_text": null,
          "new_text": "prev_operand.IsAnyRegister()",
          "old_line_content": "          delay_insertion = true;",
          "new_line_content": "      if (connect_spilled && !prev_operand.IsAnyRegister() &&",
          "content_same": false
        },
        {
          "line": 3464,
          "old_api": null,
          "new_api": "IsAnyRegister",
          "old_text": null,
          "new_text": "cur_operand.IsAnyRegister()",
          "old_line_content": "        } else {",
          "new_line_content": "          cur_operand.IsAnyRegister()) {",
          "content_same": false
        },
        {
          "line": 3465,
          "old_api": null,
          "new_api": "GetInstructionBlock",
          "old_text": null,
          "new_text": "code()->GetInstructionBlock(gap_index)",
          "old_line_content": "          gap_index++;",
          "new_line_content": "        const InstructionBlock* block = code()->GetInstructionBlock(gap_index);",
          "content_same": false
        },
        {
          "line": 3466,
          "old_api": null,
          "new_api": "IsDeferred",
          "old_text": null,
          "new_text": "block->IsDeferred()",
          "old_line_content": "        }",
          "new_line_content": "        DCHECK(block->IsDeferred());",
          "content_same": false
        },
        {
          "line": 3469,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "top_range->GetListOfBlocksRequiringSpillOperands()->Add(\n            block->rpo_number().ToInt())",
          "old_line_content": "      // Reloads or spills for spilled in deferred blocks ranges must happen",
          "new_line_content": "        top_range->GetListOfBlocksRequiringSpillOperands()->Add(",
          "content_same": false
        },
        {
          "line": 3470,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "block->rpo_number().ToInt()",
          "old_line_content": "      // only in deferred blocks.",
          "new_line_content": "            block->rpo_number().ToInt());",
          "content_same": false
        },
        {
          "line": 3476,
          "old_api": null,
          "new_api": "IsStart",
          "old_text": null,
          "new_text": "pos.IsStart()",
          "old_line_content": "      ParallelMove* move =",
          "new_line_content": "        if (pos.IsStart()) {",
          "content_same": false
        },
        {
          "line": 3485,
          "old_api": null,
          "new_api": "IsAnyRegister",
          "old_text": null,
          "new_text": "DCHECK_IMPLIES(\n          connect_spilled &&\n              !(prev_operand.IsAnyRegister() && cur_operand.IsAnyRegister()),\n          code()->GetInstructionBlock(gap_index)->IsDeferred())",
          "old_line_content": "    }",
          "new_line_content": "      DCHECK_IMPLIES(",
          "content_same": false
        },
        {
          "line": 3488,
          "old_api": null,
          "new_api": "GetInstructionBlock",
          "old_text": null,
          "new_text": "code()->GetInstructionBlock(gap_index)->IsDeferred()",
          "old_line_content": "  // Insert all the moves which should occur after the stored move.",
          "new_line_content": "          code()->GetInstructionBlock(gap_index)->IsDeferred());",
          "content_same": false
        },
        {
          "line": 3496,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "delayed_insertion_map.insert(\n            std::make_pair(std::make_pair(move, prev_operand), cur_operand))",
          "old_line_content": "    if (done || it->first.first != moves) {",
          "new_line_content": "        delayed_insertion_map.insert(",
          "content_same": false
        },
        {
          "line": 3497,
          "old_api": null,
          "new_api": "std::make_pair(move, prev_operand)",
          "old_text": null,
          "new_text": "std::make_pair(move, prev_operand)",
          "old_line_content": "      // Commit the MoveOperands for current ParallelMove.",
          "new_line_content": "            std::make_pair(std::make_pair(move, prev_operand), cur_operand));",
          "content_same": false
        },
        {
          "line": 3501,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "delayed_insertion_map.empty()",
          "old_line_content": "      for (MoveOperands* move : to_insert) {",
          "new_line_content": "  if (delayed_insertion_map.empty()) return;",
          "content_same": false
        },
        {
          "line": 3505,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "to_insert.reserve(4)",
          "old_line_content": "      // Reset state.",
          "new_line_content": "  to_insert.reserve(4);",
          "content_same": false
        },
        {
          "line": 3508,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "delayed_insertion_map.begin()",
          "old_line_content": "      moves = it->first.first;",
          "new_line_content": "  for (auto it = delayed_insertion_map.begin();; ++it) {",
          "content_same": false
        },
        {
          "line": 3509,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "delayed_insertion_map.end()",
          "old_line_content": "    }",
          "new_line_content": "    bool done = it == delayed_insertion_map.end();",
          "content_same": false
        },
        {
          "line": 3516,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "moves->push_back(move)",
          "old_line_content": "  }",
          "new_line_content": "        moves->push_back(move);",
          "content_same": false
        },
        {
          "line": 3520,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "to_eliminate.clear()",
          "old_line_content": "void LiveRangeConnector::CommitSpillsInDeferredBlocks(",
          "new_line_content": "      to_eliminate.clear();",
          "content_same": false
        },
        {
          "line": 3521,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "to_insert.clear()",
          "old_line_content": "    TopLevelLiveRange* range, LiveRangeBoundArray* array, Zone* temp_zone) {",
          "new_line_content": "      to_insert.clear();",
          "content_same": false
        },
        {
          "line": 3527,
          "old_api": null,
          "new_api": "PrepareInsertAfter",
          "old_text": null,
          "new_text": "moves->PrepareInsertAfter(move)",
          "old_line_content": "",
          "new_line_content": "    MoveOperands* eliminate = moves->PrepareInsertAfter(move);",
          "content_same": false
        },
        {
          "line": 3537,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "range->spilled()",
          "old_line_content": "        continue;",
          "new_line_content": "  DCHECK(!range->spilled());",
          "content_same": false
        },
        {
          "line": 3540,
          "old_api": null,
          "new_api": "GetSpillRangeOperand",
          "old_text": null,
          "new_text": "range->GetSpillRangeOperand()",
          "old_line_content": "              ->rpo_number());",
          "new_line_content": "  InstructionOperand spill_operand = range->GetSpillRangeOperand();",
          "content_same": false
        },
        {
          "line": 3542,
          "old_api": null,
          "new_api": "vreg",
          "old_text": null,
          "new_text": "TRACE(\"Live Range %d will be spilled only in deferred blocks.\\n\",\n        range->vreg())",
          "old_line_content": "  }",
          "new_line_content": "  TRACE(\"Live Range %d will be spilled only in deferred blocks.\\n\",",
          "content_same": false
        },
        {
          "line": 3543,
          "old_api": null,
          "new_api": "vreg",
          "old_text": null,
          "new_text": "range->vreg()",
          "old_line_content": "",
          "new_line_content": "        range->vreg());",
          "content_same": false
        },
        {
          "line": 3550,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "child->spilled()",
          "old_line_content": "  }",
          "new_line_content": "      if (pos->type() != UsePositionType::kRequiresSlot && !child->spilled())",
          "content_same": false
        },
        {
          "line": 3552,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "range->AddBlockRequiringSpillOperand(\n          code->GetInstructionBlock(pos->pos().ToInstructionIndex())\n              ->rpo_number())",
          "old_line_content": "  // Seek the deferred blocks that dominate locations requiring spill operands,",
          "new_line_content": "      range->AddBlockRequiringSpillOperand(",
          "content_same": false
        },
        {
          "line": 3553,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "pos->pos().ToInstructionIndex()",
          "old_line_content": "  // and spill there. We only need to spill at the start of such blocks.",
          "new_line_content": "          code->GetInstructionBlock(pos->pos().ToInstructionIndex())",
          "content_same": false
        },
        {
          "line": 3561,
          "old_api": null,
          "new_api": "GetListOfBlocksRequiringSpillOperands",
          "old_text": null,
          "new_text": "range->GetListOfBlocksRequiringSpillOperands()",
          "old_line_content": "    const InstructionBlock* spill_block =",
          "new_line_content": "           range->GetListOfBlocksRequiringSpillOperands());",
          "content_same": false
        },
        {
          "line": 3563,
          "old_api": null,
          "new_api": "Current",
          "old_text": null,
          "new_text": "iterator.Current()",
          "old_line_content": "",
          "new_line_content": "    worklist.push(iterator.Current());",
          "content_same": false
        },
        {
          "line": 3569,
          "old_api": null,
          "new_api": "GetListOfBlocksRequiringSpillOperands",
          "old_text": null,
          "new_text": "range->GetListOfBlocksRequiringSpillOperands()->length()",
          "old_line_content": "      } else {",
          "new_line_content": "      range->GetListOfBlocksRequiringSpillOperands()->length(), temp_zone);",
          "content_same": false
        },
        {
          "line": 3570,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "worklist.empty()",
          "old_line_content": "        LifetimePosition pred_end =",
          "new_line_content": "  while (!worklist.empty()) {",
          "content_same": false
        },
        {
          "line": 3573,
          "old_api": null,
          "new_api": "Contains",
          "old_text": null,
          "new_text": "done_blocks.Contains(block_id)",
          "old_line_content": "",
          "new_line_content": "    if (done_blocks.Contains(block_id)) continue;",
          "content_same": false
        },
        {
          "line": 3579,
          "old_api": null,
          "new_api": "InstructionBlockAt",
          "old_text": null,
          "new_text": "code->InstructionBlockAt(pred)",
          "old_line_content": "                           Instruction::GapPosition::START, pred_op,",
          "new_line_content": "      const InstructionBlock* pred_block = code->InstructionBlockAt(pred);",
          "content_same": false
        },
        {
          "line": 3581,
          "old_api": null,
          "new_api": "IsDeferred",
          "old_text": null,
          "new_text": "pred_block->IsDeferred()",
          "old_line_content": "      }",
          "new_line_content": "      if (pred_block->IsDeferred()) {",
          "content_same": false
        },
        {
          "line": 3582,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "pred_block->rpo_number().ToInt()",
          "old_line_content": "    }",
          "new_line_content": "        worklist.push(pred_block->rpo_number().ToInt());",
          "content_same": false
        },
        {
          "line": 3585,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::InstructionFromInstructionIndex(\n                pred_block->last_instruction_index())",
          "old_line_content": "",
          "new_line_content": "            LifetimePosition::InstructionFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 3586,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "pred_block->last_instruction_index()",
          "old_line_content": "",
          "new_line_content": "                pred_block->last_instruction_index());",
          "content_same": false
        },
        {
          "line": 3588,
          "old_api": null,
          "new_api": "Find",
          "old_text": null,
          "new_text": "array->Find(pred_end)",
          "old_line_content": "}  // namespace internal",
          "new_line_content": "        LiveRangeBound* bound = array->Find(pred_end);",
          "content_same": false
        },
        {
          "line": 3590,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "bound->range_->GetAssignedOperand()",
          "old_line_content": "",
          "new_line_content": "        InstructionOperand pred_op = bound->range_->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3592,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "spill_block->first_instruction_index()",
          "old_line_content": "",
          "new_line_content": "        data()->AddGapMove(spill_block->first_instruction_index(),",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2201,
          "old_api": "predecessors",
          "new_api": null,
          "old_text": "block->predecessors()",
          "new_text": null,
          "old_line_content": "        code(), code()->InstructionBlockAt(block->predecessors()[0]));",
          "new_line_content": "    const InstructionBlock* predecessor_block =",
          "content_same": false
        },
        {
          "line": 2205,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "UnallocatedOperand::cast(to).virtual_register()",
          "new_text": null,
          "old_line_content": "          UnallocatedOperand::cast(to).virtual_register() == phi_vreg) {",
          "new_line_content": "      // \"Prefer the hint from the first non-deferred predecessor, if any.",
          "content_same": false
        },
        {
          "line": 2210,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(hint != nullptr)",
          "new_text": null,
          "old_line_content": "    DCHECK(hint != nullptr);",
          "new_line_content": "          break;",
          "content_same": false
        },
        {
          "line": 2211,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "LifetimePosition::GapFromInstructionIndex(\n        block->first_instruction_index())",
          "new_text": null,
          "old_line_content": "    LifetimePosition block_start = LifetimePosition::GapFromInstructionIndex(",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2212,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "block->first_instruction_index()",
          "new_text": null,
          "old_line_content": "        block->first_instruction_index());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2213,
          "old_api": "output",
          "new_api": null,
          "old_text": "phi->output()",
          "new_text": null,
          "old_line_content": "    UsePosition* use_pos = Define(block_start, &phi->output(), hint,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2215,
          "old_api": "MapPhiHint",
          "new_api": null,
          "old_text": "MapPhiHint(hint, use_pos)",
          "new_text": null,
          "old_line_content": "    MapPhiHint(hint, use_pos);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2222,
          "old_api": "IsLoopHeader",
          "new_api": null,
          "old_text": "block->IsLoopHeader()",
          "new_text": null,
          "old_line_content": "  DCHECK(block->IsLoopHeader());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2231,
          "old_api": "Done",
          "new_api": null,
          "old_text": "iterator.Done()",
          "new_text": null,
          "old_line_content": "  while (!iterator.Done()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2232,
          "old_api": "Current",
          "new_api": null,
          "old_text": "iterator.Current()",
          "new_text": null,
          "old_line_content": "    int operand_index = iterator.Current();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2233,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": null,
          "old_text": "data()->GetOrCreateLiveRangeFor(operand_index)",
          "new_text": null,
          "old_line_content": "    TopLevelLiveRange* range = data()->GetOrCreateLiveRangeFor(operand_index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2234,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "    range->EnsureInterval(start, end, allocation_zone());",
          "new_line_content": "void LiveRangeBuilder::ProcessLoopHeader(const InstructionBlock* block,",
          "content_same": false
        },
        {
          "line": 2235,
          "old_api": "Advance",
          "new_api": null,
          "old_text": "iterator.Advance()",
          "new_text": null,
          "old_line_content": "    iterator.Advance();",
          "new_line_content": "                                         BitVector* live) {",
          "content_same": false
        },
        {
          "line": 2238,
          "old_api": "ToInt",
          "new_api": null,
          "old_text": "block->loop_end().ToInt()",
          "new_text": null,
          "old_line_content": "  for (int i = block->rpo_number().ToInt() + 1; i < block->loop_end().ToInt();",
          "new_line_content": "  // for each value live on entry to the header.",
          "content_same": false
        },
        {
          "line": 2250,
          "old_api": "RpoNumber::FromInt(block_id)",
          "new_api": null,
          "old_text": "RpoNumber::FromInt(block_id)",
          "new_text": null,
          "old_line_content": "        code()->InstructionBlockAt(RpoNumber::FromInt(block_id));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": "data",
          "new_api": null,
          "old_text": "data()",
          "new_text": null,
          "old_line_content": "    BitVector* live = ComputeLiveOut(block, data());",
          "new_line_content": "  // Insert all values into the live in sets of all blocks in the loop.",
          "content_same": false
        },
        {
          "line": 2257,
          "old_api": "ProcessInstructions",
          "new_api": null,
          "old_text": "ProcessInstructions(block, live)",
          "new_text": null,
          "old_line_content": "    ProcessInstructions(block, live);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": "ProcessPhis",
          "new_api": null,
          "old_text": "ProcessPhis(block, live)",
          "new_text": null,
          "old_line_content": "    ProcessPhis(block, live);",
          "new_line_content": "void LiveRangeBuilder::BuildLiveRanges() {",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": "ProcessLoopHeader",
          "new_api": null,
          "old_text": "ProcessLoopHeader(block, live)",
          "new_text": null,
          "old_line_content": "    if (block->IsLoopHeader()) ProcessLoopHeader(block, live);",
          "new_line_content": "       --block_id) {",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": "live_in_sets",
          "new_api": null,
          "old_text": "live_in_sets()",
          "new_text": null,
          "old_line_content": "    live_in_sets()[block_id] = live;",
          "new_line_content": "    InstructionBlock* block =",
          "content_same": false
        },
        {
          "line": 2266,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "new_line_content": "    // Initially consider all live_out values live for the entire block. We",
          "content_same": false
        },
        {
          "line": 2269,
          "old_api": "HasNoSpillType",
          "new_api": null,
          "old_text": "range->HasNoSpillType()",
          "new_text": null,
          "old_line_content": "    if (range->has_slot_use() && range->HasNoSpillType()) {",
          "new_line_content": "    // Process the instructions in reverse order, generating and killing",
          "content_same": false
        },
        {
          "line": 2270,
          "old_api": "AssignSpillRangeToLiveRange",
          "new_api": null,
          "old_text": "data()->AssignSpillRangeToLiveRange(range)",
          "new_text": null,
          "old_line_content": "      data()->AssignSpillRangeToLiveRange(range);",
          "new_line_content": "    // live values.",
          "content_same": false
        },
        {
          "line": 2278,
          "old_api": "next",
          "new_api": null,
          "old_text": "pos->next()",
          "new_text": null,
          "old_line_content": "           pos = pos->next()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": "type",
          "new_api": null,
          "old_text": "pos->type()",
          "new_text": null,
          "old_line_content": "        if (pos->type() == UsePositionType::kRequiresSlot) continue;",
          "new_line_content": "  // Postprocess the ranges.",
          "content_same": false
        },
        {
          "line": 2282,
          "old_api": "IsGapPosition",
          "new_api": null,
          "old_text": "pos->pos().IsGapPosition()",
          "new_text": null,
          "old_line_content": "        if (!pos->pos().IsGapPosition()) {",
          "new_line_content": "    // Give slots to all ranges with a non fixed slot use.",
          "content_same": false
        },
        {
          "line": 2285,
          "old_api": "set_type",
          "new_api": null,
          "old_text": "pos->set_type(new_type, true)",
          "new_text": null,
          "old_line_content": "        pos->set_type(new_type, true);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2289,
          "old_api": "preassigned_slot_ranges",
          "new_api": null,
          "old_text": "data()->preassigned_slot_ranges()",
          "new_text": null,
          "old_line_content": "  for (auto preassigned : data()->preassigned_slot_ranges()) {",
          "new_line_content": "    // operand assigned.",
          "content_same": false
        },
        {
          "line": 2294,
          "old_api": "AssignSpillRangeToLiveRange",
          "new_api": null,
          "old_text": "data()->AssignSpillRangeToLiveRange(range)",
          "new_text": null,
          "old_line_content": "                            : data()->AssignSpillRangeToLiveRange(range);",
          "new_line_content": "        UsePositionType new_type = UsePositionType::kAny;",
          "content_same": false
        },
        {
          "line": 2295,
          "old_api": "set_assigned_slot",
          "new_api": null,
          "old_text": "spill->set_assigned_slot(slot_id)",
          "new_text": null,
          "old_line_content": "    spill->set_assigned_slot(slot_id);",
          "new_line_content": "        // Can't mark phis as needing a register.",
          "content_same": false
        },
        {
          "line": 2298,
          "old_api": "Verify",
          "new_api": null,
          "old_text": "Verify()",
          "new_text": null,
          "old_line_content": "  Verify();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2305,
          "old_api": "IsResolved",
          "new_api": null,
          "old_text": "use_pos->IsResolved()",
          "new_text": null,
          "old_line_content": "  DCHECK(!use_pos->IsResolved());",
          "new_line_content": "    int slot_id = preassigned.second;",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": "find",
          "new_api": null,
          "old_text": "phi_hints_.find(operand)",
          "new_text": null,
          "old_line_content": "  auto it = phi_hints_.find(operand);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2315,
          "old_api": "end",
          "new_api": null,
          "old_text": "phi_hints_.end()",
          "new_text": null,
          "old_line_content": "  if (it == phi_hints_.end()) return;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": "IsResolved",
          "new_api": null,
          "old_text": "it->second->IsResolved()",
          "new_text": null,
          "old_line_content": "  DCHECK(!it->second->IsResolved());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2317,
          "old_api": "ResolveHint",
          "new_api": null,
          "old_text": "it->second->ResolveHint(use_pos)",
          "new_text": null,
          "old_line_content": "  it->second->ResolveHint(use_pos);",
          "new_line_content": "void LiveRangeBuilder::MapPhiHint(InstructionOperand* operand,",
          "content_same": false
        },
        {
          "line": 2323,
          "old_api": "IsResolved",
          "new_api": null,
          "old_text": "hint.second->IsResolved()",
          "new_text": null,
          "old_line_content": "    CHECK(hint.second->IsResolved());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2325,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* current : data()->live_ranges()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2326,
          "old_api": "Verify",
          "new_api": null,
          "old_text": "current->Verify()",
          "new_text": null,
          "old_line_content": "    if (current != nullptr && !current->IsEmpty()) current->Verify();",
          "new_line_content": "void LiveRangeBuilder::ResolvePhiHint(InstructionOperand* operand,",
          "content_same": false
        },
        {
          "line": 2335,
          "old_api": "config",
          "new_api": null,
          "old_text": "data->config()",
          "new_text": null,
          "old_line_content": "      num_registers_(GetRegisterCount(data->config(), kind)),",
          "new_line_content": "void LiveRangeBuilder::Verify() const {",
          "content_same": false
        },
        {
          "line": 2344,
          "old_api": "LifetimePosition::Invalid()",
          "new_api": null,
          "old_text": "LifetimePosition::Invalid()",
          "new_text": null,
          "old_line_content": "  LifetimePosition ret = LifetimePosition::Invalid();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2346,
          "old_api": "LifetimePosition::GapFromInstructionIndex(instruction_index)",
          "new_api": null,
          "old_text": "LifetimePosition::GapFromInstructionIndex(instruction_index)",
          "new_text": null,
          "old_line_content": "  ret = LifetimePosition::GapFromInstructionIndex(instruction_index);",
          "new_line_content": "                                     RegisterKind kind)",
          "content_same": false
        },
        {
          "line": 2347,
          "old_api": "End",
          "new_api": null,
          "old_text": "range->End()",
          "new_text": null,
          "old_line_content": "  if (range->Start() >= ret || ret >= range->End()) {",
          "new_line_content": "    : data_(data),",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": "LifetimePosition::Invalid()",
          "new_api": null,
          "old_text": "LifetimePosition::Invalid()",
          "new_text": null,
          "old_line_content": "    return LifetimePosition::Invalid();",
          "new_line_content": "      mode_(kind),",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": "size",
          "new_api": null,
          "old_text": "data()->live_ranges().size()",
          "new_text": null,
          "old_line_content": "  size_t initial_range_count = data()->live_ranges().size();",
          "new_line_content": "LifetimePosition RegisterAllocator::GetSplitPositionForInstruction(",
          "content_same": false
        },
        {
          "line": 2359,
          "old_api": "CanProcessRange",
          "new_api": null,
          "old_text": "CanProcessRange(range)",
          "new_text": null,
          "old_line_content": "    if (!CanProcessRange(range)) continue;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": "Start",
          "new_api": null,
          "old_text": "range->Start()",
          "new_text": null,
          "old_line_content": "    LifetimePosition start = range->Start();",
          "new_line_content": "  return ret;",
          "content_same": false
        },
        {
          "line": 2365,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "TRACE(\"Live range %d:%d is defined by a spill operand.\\n\",\n          range->TopLevel()->vreg(), range->relative_id())",
          "new_text": null,
          "old_line_content": "    TRACE(\"Live range %d:%d is defined by a spill operand.\\n\",",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2366,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "range->relative_id()",
          "new_text": null,
          "old_line_content": "          range->TopLevel()->vreg(), range->relative_id());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2368,
          "old_api": "IsGapPosition",
          "new_api": null,
          "old_text": "next_pos.IsGapPosition()",
          "new_text": null,
          "old_line_content": "    if (next_pos.IsGapPosition()) {",
          "new_line_content": "void RegisterAllocator::SplitAndSpillRangesDefinedByMemoryOperand(",
          "content_same": false
        },
        {
          "line": 2369,
          "old_api": "NextStart",
          "new_api": null,
          "old_text": "next_pos.NextStart()",
          "new_text": null,
          "old_line_content": "      next_pos = next_pos.NextStart();",
          "new_line_content": "    bool operands_only) {",
          "content_same": false
        },
        {
          "line": 2371,
          "old_api": "NextUsePositionRegisterIsBeneficial",
          "new_api": null,
          "old_text": "range->NextUsePositionRegisterIsBeneficial(next_pos)",
          "new_text": null,
          "old_line_content": "    UsePosition* pos = range->NextUsePositionRegisterIsBeneficial(next_pos);",
          "new_line_content": "  for (size_t i = 0; i < initial_range_count; ++i) {",
          "content_same": false
        },
        {
          "line": 2375,
          "old_api": "Spill",
          "new_api": null,
          "old_text": "Spill(range)",
          "new_text": null,
          "old_line_content": "      Spill(range);",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 2376,
          "old_api": "NextStart",
          "new_api": null,
          "old_text": "range->Start().NextStart()",
          "new_text": null,
          "old_line_content": "    } else if (pos->pos() > range->Start().NextStart()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2387,
          "old_api": "SplitRangeAt",
          "new_api": null,
          "old_text": "SplitRangeAt(range, split_pos)",
          "new_text": null,
          "old_line_content": "      SplitRangeAt(range, split_pos);",
          "new_line_content": "    // register immediately, split it and spill the first part of the range.",
          "content_same": false
        },
        {
          "line": 2388,
          "old_api": "Spill",
          "new_api": null,
          "old_text": "Spill(range)",
          "new_text": null,
          "old_line_content": "      Spill(range);",
          "new_line_content": "    if (pos == nullptr) {",
          "content_same": false
        },
        {
          "line": 2397,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->vreg()",
          "new_text": null,
          "old_line_content": "  TRACE(\"Splitting live range %d:%d at %d\\n\", range->TopLevel()->vreg(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": "value",
          "new_api": null,
          "old_text": "pos.value()",
          "new_text": null,
          "old_line_content": "        range->relative_id(), pos.value());",
          "new_line_content": "      split_pos =",
          "content_same": false
        },
        {
          "line": 2400,
          "old_api": "Start",
          "new_api": null,
          "old_text": "range->Start()",
          "new_text": null,
          "old_line_content": "  if (pos <= range->Start()) return range;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2404,
          "old_api": "IsGapPosition",
          "new_api": null,
          "old_text": "pos.IsGapPosition()",
          "new_text": null,
          "old_line_content": "  DCHECK(pos.IsStart() || pos.IsGapPosition() ||",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2405,
          "old_api": "code",
          "new_api": null,
          "old_text": "code()",
          "new_text": null,
          "old_line_content": "         (GetInstructionBlock(code(), pos)->last_instruction_index() !=",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2406,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "pos.ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "          pos.ToInstructionIndex()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2408,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "  LiveRange* result = range->SplitAt(pos, allocation_zone());",
          "new_line_content": "LiveRange* RegisterAllocator::SplitRangeAt(LiveRange* range,",
          "content_same": false
        },
        {
          "line": 2416,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->IsFixed()",
          "new_text": null,
          "old_line_content": "  DCHECK(!range->TopLevel()->IsFixed());",
          "new_line_content": "  // We can't properly connect liveranges if splitting occurred at the end",
          "content_same": false
        },
        {
          "line": 2417,
          "old_api": "value",
          "new_api": null,
          "old_text": "TRACE(\"Splitting live range %d:%d in position between [%d, %d]\\n\",\n        range->TopLevel()->vreg(), range->relative_id(), start.value(),\n        end.value())",
          "new_text": null,
          "old_line_content": "  TRACE(\"Splitting live range %d:%d in position between [%d, %d]\\n\",",
          "new_line_content": "  // a block.",
          "content_same": false
        },
        {
          "line": 2421,
          "old_api": "FindOptimalSplitPos",
          "new_api": null,
          "old_text": "FindOptimalSplitPos(start, end)",
          "new_text": null,
          "old_line_content": "  LifetimePosition split_pos = FindOptimalSplitPos(start, end);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": "SplitRangeAt",
          "new_api": null,
          "old_text": "SplitRangeAt(range, split_pos)",
          "new_text": null,
          "old_line_content": "  return SplitRangeAt(range, split_pos);",
          "new_line_content": "  return result;",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "start.ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "  int start_instr = start.ToInstructionIndex();",
          "new_line_content": "                                           LifetimePosition end) {",
          "content_same": false
        },
        {
          "line": 2448,
          "old_api": "code",
          "new_api": null,
          "old_text": "code()",
          "new_text": null,
          "old_line_content": "    const InstructionBlock* loop = GetContainingLoop(code(), block);",
          "new_line_content": "  if (start_instr == end_instr) return end;",
          "content_same": false
        },
        {
          "line": 2459,
          "old_api": "IsLoopHeader",
          "new_api": null,
          "old_text": "end_block->IsLoopHeader()",
          "new_text": null,
          "old_line_content": "  if (block == end_block && !end_block->IsLoopHeader()) return end;",
          "new_line_content": "  const InstructionBlock* block = end_block;",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "LifetimePosition::GapFromInstructionIndex(\n      block->first_instruction_index())",
          "new_text": null,
          "old_line_content": "  return LifetimePosition::GapFromInstructionIndex(",
          "new_line_content": "  do {",
          "content_same": false
        },
        {
          "line": 2468,
          "old_api": "Start",
          "new_api": null,
          "old_text": "pos.Start()",
          "new_text": null,
          "old_line_content": "  const InstructionBlock* block = GetInstructionBlock(code(), pos.Start());",
          "new_line_content": "    block = loop;",
          "content_same": false
        },
        {
          "line": 2470,
          "old_api": "code",
          "new_api": null,
          "old_text": "code()",
          "new_text": null,
          "old_line_content": "      block->IsLoopHeader() ? block : GetContainingLoop(code(), block);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "LifetimePosition::GapFromInstructionIndex(\n        loop_header->first_instruction_index())",
          "new_text": null,
          "old_line_content": "    LifetimePosition loop_start = LifetimePosition::GapFromInstructionIndex(",
          "new_line_content": "    LiveRange* range, LifetimePosition pos) {",
          "content_same": false
        },
        {
          "line": 2485,
          "old_api": "pos",
          "new_api": null,
          "old_text": "prev_use->pos()",
          "new_text": null,
          "old_line_content": "      if (prev_use == nullptr || prev_use->pos() < loop_start) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2492,
          "old_api": "code",
          "new_api": null,
          "old_text": "code()",
          "new_text": null,
          "old_line_content": "    loop_header = GetContainingLoop(code(), loop_header);",
          "new_line_content": "    // We are going to spill live range inside the loop.",
          "content_same": false
        },
        {
          "line": 2500,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "range->spilled()",
          "new_text": null,
          "old_line_content": "  DCHECK(!range->spilled());",
          "new_line_content": "        // No register beneficial use inside the loop before the pos.",
          "content_same": false
        },
        {
          "line": 2501,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()",
          "new_text": null,
          "old_line_content": "  TopLevelLiveRange* first = range->TopLevel();",
          "new_line_content": "        pos = loop_start;",
          "content_same": false
        },
        {
          "line": 2502,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "range->relative_id()",
          "new_text": null,
          "old_line_content": "  TRACE(\"Spilling live range %d:%d\\n\", first->vreg(), range->relative_id());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": "HasNoSpillType",
          "new_api": null,
          "old_text": "first->HasNoSpillType()",
          "new_text": null,
          "old_line_content": "  if (first->HasNoSpillType()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2505,
          "old_api": "AssignSpillRangeToLiveRange",
          "new_api": null,
          "old_text": "data()->AssignSpillRangeToLiveRange(first)",
          "new_text": null,
          "old_line_content": "    data()->AssignSpillRangeToLiveRange(first);",
          "new_line_content": "    // Try hoisting out to an outer loop.",
          "content_same": false
        },
        {
          "line": 2507,
          "old_api": "Spill",
          "new_api": null,
          "old_text": "range->Spill()",
          "new_text": null,
          "old_line_content": "  range->Spill();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2513,
          "old_api": "fixed_double_live_ranges",
          "new_api": null,
          "old_text": "data()->fixed_double_live_ranges()",
          "new_text": null,
          "old_line_content": "  return mode() == DOUBLE_REGISTERS ? data()->fixed_double_live_ranges()",
          "new_line_content": "void RegisterAllocator::Spill(LiveRange* range) {",
          "content_same": false
        },
        {
          "line": 2520,
          "old_api": "config",
          "new_api": null,
          "old_text": "data()->config()->GetGeneralRegisterName(register_code)",
          "new_text": null,
          "old_line_content": "    return data()->config()->GetGeneralRegisterName(register_code);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2522,
          "old_api": "config",
          "new_api": null,
          "old_text": "data()->config()->GetDoubleRegisterName(register_code)",
          "new_text": null,
          "old_line_content": "    return data()->config()->GetDoubleRegisterName(register_code);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2535,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "active_live_ranges().reserve(8)",
          "new_text": null,
          "old_line_content": "  active_live_ranges().reserve(8);",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 2539,
          "old_api": "data",
          "new_api": null,
          "old_text": "DCHECK(RegisterConfiguration::kMaxDoubleRegisters >=\n         this->data()->config()->num_general_registers())",
          "new_text": null,
          "old_line_content": "  DCHECK(RegisterConfiguration::kMaxDoubleRegisters >=",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2540,
          "old_api": "data",
          "new_api": null,
          "old_text": "this->data()->config()->num_general_registers()",
          "new_text": null,
          "old_line_content": "         this->data()->config()->num_general_registers());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2545,
          "old_api": "empty",
          "new_api": null,
          "old_text": "unhandled_live_ranges().empty()",
          "new_text": null,
          "old_line_content": "  DCHECK(unhandled_live_ranges().empty());",
          "new_line_content": "      active_live_ranges_(local_zone),",
          "content_same": false
        },
        {
          "line": 2546,
          "old_api": "empty",
          "new_api": null,
          "old_text": "active_live_ranges().empty()",
          "new_text": null,
          "old_line_content": "  DCHECK(active_live_ranges().empty());",
          "new_line_content": "      inactive_live_ranges_(local_zone) {",
          "content_same": false
        },
        {
          "line": 2552,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "new_line_content": "  // when allocating local arrays.",
          "content_same": false
        },
        {
          "line": 2555,
          "old_api": "next",
          "new_api": null,
          "old_text": "to_add->next()",
          "new_text": null,
          "old_line_content": "         to_add = to_add->next()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2556,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "to_add->spilled()",
          "new_text": null,
          "old_line_content": "      if (!to_add->spilled()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2557,
          "old_api": "AddToUnhandledUnsorted",
          "new_api": null,
          "old_text": "AddToUnhandledUnsorted(to_add)",
          "new_text": null,
          "old_line_content": "        AddToUnhandledUnsorted(to_add);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2562,
          "old_api": "UnhandledIsSorted",
          "new_api": null,
          "old_text": "UnhandledIsSorted()",
          "new_text": null,
          "old_line_content": "  DCHECK(UnhandledIsSorted());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2568,
          "old_api": "AddToInactive",
          "new_api": null,
          "old_text": "AddToInactive(current)",
          "new_text": null,
          "old_line_content": "      AddToInactive(current);",
          "new_line_content": "    for (LiveRange* to_add = range; to_add != nullptr;",
          "content_same": false
        },
        {
          "line": 2572,
          "old_api": "empty",
          "new_api": null,
          "old_text": "unhandled_live_ranges().empty()",
          "new_text": null,
          "old_line_content": "  while (!unhandled_live_ranges().empty()) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2573,
          "old_api": "UnhandledIsSorted",
          "new_api": null,
          "old_text": "UnhandledIsSorted()",
          "new_text": null,
          "old_line_content": "    DCHECK(UnhandledIsSorted());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2574,
          "old_api": "back",
          "new_api": null,
          "old_text": "unhandled_live_ranges().back()",
          "new_text": null,
          "old_line_content": "    LiveRange* current = unhandled_live_ranges().back();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2577,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "    LifetimePosition position = current->Start();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2584,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "current->TopLevel()",
          "new_text": null,
          "old_line_content": "    if (current->IsTopLevel() && TryReuseSpillForPhi(current->TopLevel()))",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2592,
          "old_api": "Covers",
          "new_api": null,
          "old_text": "cur_active->Covers(position)",
          "new_text": null,
          "old_line_content": "      } else if (!cur_active->Covers(position)) {",
          "new_line_content": "#ifdef DEBUG",
          "content_same": false
        },
        {
          "line": 2593,
          "old_api": "ActiveToInactive",
          "new_api": null,
          "old_text": "ActiveToInactive(cur_active)",
          "new_text": null,
          "old_line_content": "        ActiveToInactive(cur_active);",
          "new_line_content": "    allocation_finger_ = position;",
          "content_same": false
        },
        {
          "line": 2599,
          "old_api": "inactive_live_ranges",
          "new_api": null,
          "old_text": "inactive_live_ranges()",
          "new_text": null,
          "old_line_content": "      LiveRange* cur_inactive = inactive_live_ranges()[i];",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 2600,
          "old_api": "End",
          "new_api": null,
          "old_text": "cur_inactive->End()",
          "new_text": null,
          "old_line_content": "      if (cur_inactive->End() <= position) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2609,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "current->spilled()",
          "new_text": null,
          "old_line_content": "    DCHECK(!current->HasRegisterAssigned() && !current->spilled());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2611,
          "old_api": "TryAllocateFreeReg",
          "new_api": null,
          "old_text": "TryAllocateFreeReg(current)",
          "new_text": null,
          "old_line_content": "    bool result = TryAllocateFreeReg(current);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2622,
          "old_api": "kind",
          "new_api": null,
          "old_text": "range->kind()",
          "new_text": null,
          "old_line_content": "  data()->MarkAllocated(range->kind(), reg);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2624,
          "old_api": "SetUseHints",
          "new_api": null,
          "old_text": "range->SetUseHints(reg)",
          "new_text": null,
          "old_line_content": "  range->SetUseHints(reg);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2632,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->vreg()",
          "new_text": null,
          "old_line_content": "  TRACE(\"Add live range %d:%d to active\\n\", range->TopLevel()->vreg(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2633,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "range->relative_id()",
          "new_text": null,
          "old_line_content": "        range->relative_id());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2634,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "active_live_ranges().push_back(range)",
          "new_text": null,
          "old_line_content": "  active_live_ranges().push_back(range);",
          "new_line_content": "void LinearScanAllocator::SetLiveRangeAssignedRegister(LiveRange* range,",
          "content_same": false
        },
        {
          "line": 2641,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "inactive_live_ranges().push_back(range)",
          "new_text": null,
          "old_line_content": "  inactive_live_ranges().push_back(range);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2649,
          "old_api": "size",
          "new_api": null,
          "old_text": "unhandled_live_ranges().size()",
          "new_text": null,
          "old_line_content": "  for (int i = static_cast<int>(unhandled_live_ranges().size() - 1); i >= 0;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2651,
          "old_api": "at",
          "new_api": null,
          "old_text": "unhandled_live_ranges().at(i)",
          "new_text": null,
          "old_line_content": "    LiveRange* cur_range = unhandled_live_ranges().at(i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2652,
          "old_api": "ShouldBeAllocatedBefore",
          "new_api": null,
          "old_text": "range->ShouldBeAllocatedBefore(cur_range)",
          "new_text": null,
          "old_line_content": "    if (!range->ShouldBeAllocatedBefore(cur_range)) continue;",
          "new_line_content": "void LinearScanAllocator::AddToInactive(LiveRange* range) {",
          "content_same": false
        },
        {
          "line": 2656,
          "old_api": "insert",
          "new_api": null,
          "old_text": "unhandled_live_ranges().insert(it, range)",
          "new_text": null,
          "old_line_content": "    unhandled_live_ranges().insert(it, range);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2657,
          "old_api": "UnhandledIsSorted",
          "new_api": null,
          "old_text": "UnhandledIsSorted()",
          "new_text": null,
          "old_line_content": "    DCHECK(UnhandledIsSorted());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2672,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "unhandled_live_ranges().push_back(range)",
          "new_text": null,
          "old_line_content": "  unhandled_live_ranges().push_back(range);",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 2678,
          "old_api": "ShouldBeAllocatedBefore",
          "new_api": null,
          "old_text": "a->ShouldBeAllocatedBefore(b)",
          "new_text": null,
          "old_line_content": "  if (a->ShouldBeAllocatedBefore(b)) return false;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2679,
          "old_api": "ShouldBeAllocatedBefore",
          "new_api": null,
          "old_text": "b->ShouldBeAllocatedBefore(a)",
          "new_text": null,
          "old_line_content": "  if (b->ShouldBeAllocatedBefore(a)) return true;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2680,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "b->TopLevel()->vreg()",
          "new_text": null,
          "old_line_content": "  return a->TopLevel()->vreg() < b->TopLevel()->vreg();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2688,
          "old_api": "TRACE",
          "new_api": null,
          "old_text": "TRACE(\"Sort unhandled\\n\")",
          "new_text": null,
          "old_line_content": "  TRACE(\"Sort unhandled\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2689,
          "old_api": "end",
          "new_api": null,
          "old_text": "unhandled_live_ranges().end()",
          "new_text": null,
          "old_line_content": "  std::sort(unhandled_live_ranges().begin(), unhandled_live_ranges().end(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2695,
          "old_api": "size",
          "new_api": null,
          "old_text": "unhandled_live_ranges().size()",
          "new_text": null,
          "old_line_content": "  size_t len = unhandled_live_ranges().size();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": "at",
          "new_api": null,
          "old_text": "unhandled_live_ranges().at(i - 1)",
          "new_text": null,
          "old_line_content": "    LiveRange* a = unhandled_live_ranges().at(i - 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2698,
          "old_api": "at",
          "new_api": null,
          "old_text": "unhandled_live_ranges().at(i)",
          "new_text": null,
          "old_line_content": "    LiveRange* b = unhandled_live_ranges().at(i);",
          "new_line_content": "// Sort the unhandled live ranges so that the ranges to be processed first are",
          "content_same": false
        },
        {
          "line": 2699,
          "old_api": "Start",
          "new_api": null,
          "old_text": "b->Start()",
          "new_text": null,
          "old_line_content": "    if (a->Start() < b->Start()) return false;",
          "new_line_content": "// at the end of the array list.  This is convenient for the register allocation",
          "content_same": false
        },
        {
          "line": 2706,
          "old_api": "active_live_ranges",
          "new_api": null,
          "old_text": "active_live_ranges()",
          "new_text": null,
          "old_line_content": "  RemoveElement(&active_live_ranges(), range);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2707,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "TRACE(\"Moving live range %d:%d from active to handled\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "new_text": null,
          "old_line_content": "  TRACE(\"Moving live range %d:%d from active to handled\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2708,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "range->relative_id()",
          "new_text": null,
          "old_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "new_line_content": "bool LinearScanAllocator::UnhandledIsSorted() {",
          "content_same": false
        },
        {
          "line": 2714,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "inactive_live_ranges().push_back(range)",
          "new_text": null,
          "old_line_content": "  inactive_live_ranges().push_back(range);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2715,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "TRACE(\"Moving live range %d:%d from active to inactive\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "new_text": null,
          "old_line_content": "  TRACE(\"Moving live range %d:%d from active to inactive\\n\",",
          "new_line_content": "  return true;",
          "content_same": false
        },
        {
          "line": 2716,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "range->relative_id()",
          "new_text": null,
          "old_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2723,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "range->relative_id()",
          "new_text": null,
          "old_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2731,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "range->relative_id()",
          "new_text": null,
          "old_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2738,
          "old_api": "num_registers",
          "new_api": null,
          "old_text": "num_registers()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i < num_registers(); i++) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2739,
          "old_api": "LifetimePosition::MaxPosition()",
          "new_api": null,
          "old_text": "LifetimePosition::MaxPosition()",
          "new_text": null,
          "old_line_content": "    free_until_pos[i] = LifetimePosition::MaxPosition();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2746,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "cur_active->assigned_register()",
          "new_text": null,
          "old_line_content": "          RegisterName(cur_active->assigned_register()),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2747,
          "old_api": "value",
          "new_api": null,
          "old_text": "LifetimePosition::GapFromInstructionIndex(0).value()",
          "new_text": null,
          "old_line_content": "          LifetimePosition::GapFromInstructionIndex(0).value());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2750,
          "old_api": "inactive_live_ranges",
          "new_api": null,
          "old_text": "inactive_live_ranges()",
          "new_text": null,
          "old_line_content": "  for (LiveRange* cur_inactive : inactive_live_ranges()) {",
          "new_line_content": "  LifetimePosition free_until_pos[RegisterConfiguration::kMaxDoubleRegisters];",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "    DCHECK(cur_inactive->End() > current->Start());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2754,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "next_intersection.IsValid()",
          "new_text": null,
          "old_line_content": "    if (!next_intersection.IsValid()) continue;",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2755,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "cur_inactive->assigned_register()",
          "new_text": null,
          "old_line_content": "    int cur_reg = cur_inactive->assigned_register();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2762,
          "old_api": "FirstHintPosition",
          "new_api": null,
          "old_text": "current->FirstHintPosition(&hint_register)",
          "new_text": null,
          "old_line_content": "  if (current->FirstHintPosition(&hint_register) != nullptr) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2763,
          "old_api": "value",
          "new_api": null,
          "old_text": "TRACE(\n        \"Found reg hint %s (free until [%d) for live range %d:%d (end %d[).\\n\",\n        RegisterName(hint_register), free_until_pos[hint_register].value(),\n        current->TopLevel()->vreg(), current->relative_id(),\n        current->End().value())",
          "new_text": null,
          "old_line_content": "    TRACE(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2766,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "current->relative_id()",
          "new_text": null,
          "old_line_content": "        current->TopLevel()->vreg(), current->relative_id(),",
          "new_line_content": "    LifetimePosition next_intersection =",
          "content_same": false
        },
        {
          "line": 2773,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "current->relative_id()",
          "new_text": null,
          "old_line_content": "            current->relative_id());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2774,
          "old_api": "SetLiveRangeAssignedRegister",
          "new_api": null,
          "old_text": "SetLiveRangeAssignedRegister(current, hint_register)",
          "new_text": null,
          "old_line_content": "      SetLiveRangeAssignedRegister(current, hint_register);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2782,
          "old_api": "allocatable_register_code",
          "new_api": null,
          "old_text": "allocatable_register_code(i)",
          "new_text": null,
          "old_line_content": "    int code = allocatable_register_code(i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2790,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "  if (pos <= current->Start()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2798,
          "old_api": "SplitRangeAt",
          "new_api": null,
          "old_text": "SplitRangeAt(current, pos)",
          "new_text": null,
          "old_line_content": "    LiveRange* tail = SplitRangeAt(current, pos);",
          "new_line_content": "      reg = code;",
          "content_same": false
        },
        {
          "line": 2799,
          "old_api": "AddToUnhandledSorted",
          "new_api": null,
          "old_text": "AddToUnhandledSorted(tail)",
          "new_text": null,
          "old_line_content": "    AddToUnhandledSorted(tail);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2805,
          "old_api": "RegisterName",
          "new_api": null,
          "old_text": "RegisterName(reg)",
          "new_text": null,
          "old_line_content": "  TRACE(\"Assigning free reg %s to live range %d:%d\\n\", RegisterName(reg),",
          "new_line_content": "    // All registers are blocked.",
          "content_same": false
        },
        {
          "line": 2806,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "current->relative_id()",
          "new_text": null,
          "old_line_content": "        current->TopLevel()->vreg(), current->relative_id());",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 2807,
          "old_api": "SetLiveRangeAssignedRegister",
          "new_api": null,
          "old_text": "SetLiveRangeAssignedRegister(current, reg)",
          "new_text": null,
          "old_line_content": "  SetLiveRangeAssignedRegister(current, reg);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2814,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "  UsePosition* register_use = current->NextRegisterPosition(current->Start());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2825,
          "old_api": "num_registers",
          "new_api": null,
          "old_text": "num_registers()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i < num_registers(); i++) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2826,
          "old_api": "LifetimePosition::MaxPosition()",
          "new_api": null,
          "old_text": "LifetimePosition::MaxPosition()",
          "new_text": null,
          "old_line_content": "    use_pos[i] = block_pos[i] = LifetimePosition::MaxPosition();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2829,
          "old_api": "active_live_ranges",
          "new_api": null,
          "old_text": "active_live_ranges()",
          "new_text": null,
          "old_line_content": "  for (LiveRange* range : active_live_ranges()) {",
          "new_line_content": "  if (register_use == nullptr) {",
          "content_same": false
        },
        {
          "line": 2830,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "range->assigned_register()",
          "new_text": null,
          "old_line_content": "    int cur_reg = range->assigned_register();",
          "new_line_content": "    // There is no use in the current live range that requires a register.",
          "content_same": false
        },
        {
          "line": 2831,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->IsFixed()",
          "new_text": null,
          "old_line_content": "    if (range->TopLevel()->IsFixed() ||",
          "new_line_content": "    // We can just spill it.",
          "content_same": false
        },
        {
          "line": 2834,
          "old_api": "LifetimePosition::GapFromInstructionIndex(0)",
          "new_api": null,
          "old_text": "LifetimePosition::GapFromInstructionIndex(0)",
          "new_text": null,
          "old_line_content": "          LifetimePosition::GapFromInstructionIndex(0);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2837,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "          range->NextUsePositionRegisterIsBeneficial(current->Start());",
          "new_line_content": "  LifetimePosition block_pos[RegisterConfiguration::kMaxDoubleRegisters];",
          "content_same": false
        },
        {
          "line": 2841,
          "old_api": "pos",
          "new_api": null,
          "old_text": "next_use->pos()",
          "new_text": null,
          "old_line_content": "        use_pos[cur_reg] = next_use->pos();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2847,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "    DCHECK(range->End() > current->Start());",
          "new_line_content": "      block_pos[cur_reg] = use_pos[cur_reg] =",
          "content_same": false
        },
        {
          "line": 2849,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "next_intersection.IsValid()",
          "new_text": null,
          "old_line_content": "    if (!next_intersection.IsValid()) continue;",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 2850,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "range->assigned_register()",
          "new_text": null,
          "old_line_content": "    int cur_reg = range->assigned_register();",
          "new_line_content": "      UsePosition* next_use =",
          "content_same": false
        },
        {
          "line": 2852,
          "old_api": "Min",
          "new_api": null,
          "old_text": "Min(block_pos[cur_reg], next_intersection)",
          "new_text": null,
          "old_line_content": "      block_pos[cur_reg] = Min(block_pos[cur_reg], next_intersection);",
          "new_line_content": "      if (next_use == nullptr) {",
          "content_same": false
        },
        {
          "line": 2859,
          "old_api": "allocatable_register_code",
          "new_api": null,
          "old_text": "allocatable_register_code(0)",
          "new_text": null,
          "old_line_content": "  int reg = allocatable_register_code(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2872,
          "old_api": "pos",
          "new_api": null,
          "old_text": "register_use->pos()",
          "new_text": null,
          "old_line_content": "    SpillBetween(current, current->Start(), register_use->pos());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2876,
          "old_api": "End",
          "new_api": null,
          "old_text": "current->End()",
          "new_text": null,
          "old_line_content": "  if (block_pos[reg] < current->End()) {",
          "new_line_content": "    if (use_pos[code] > use_pos[reg]) {",
          "content_same": false
        },
        {
          "line": 2880,
          "old_api": "Start",
          "new_api": null,
          "old_text": "block_pos[reg].Start()",
          "new_text": null,
          "old_line_content": "        SplitBetween(current, current->Start(), block_pos[reg].Start());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2881,
          "old_api": "AddToUnhandledSorted",
          "new_api": null,
          "old_text": "AddToUnhandledSorted(tail)",
          "new_text": null,
          "old_line_content": "    AddToUnhandledSorted(tail);",
          "new_line_content": "  LifetimePosition pos = use_pos[reg];",
          "content_same": false
        },
        {
          "line": 2885,
          "old_api": "End",
          "new_api": null,
          "old_text": "current->End()",
          "new_text": null,
          "old_line_content": "  DCHECK(block_pos[reg] >= current->End());",
          "new_line_content": "    // Spill starting part of live range up to that use.",
          "content_same": false
        },
        {
          "line": 2887,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "current->relative_id()",
          "new_text": null,
          "old_line_content": "        current->TopLevel()->vreg(), current->relative_id());",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 2888,
          "old_api": "SetLiveRangeAssignedRegister",
          "new_api": null,
          "old_text": "SetLiveRangeAssignedRegister(current, reg)",
          "new_text": null,
          "old_line_content": "  SetLiveRangeAssignedRegister(current, reg);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2893,
          "old_api": "SplitAndSpillIntersecting",
          "new_api": null,
          "old_text": "SplitAndSpillIntersecting(current)",
          "new_text": null,
          "old_line_content": "  SplitAndSpillIntersecting(current);",
          "new_line_content": "    LiveRange* tail =",
          "content_same": false
        },
        {
          "line": 2898,
          "old_api": "HasRegisterAssigned",
          "new_api": null,
          "old_text": "current->HasRegisterAssigned()",
          "new_text": null,
          "old_line_content": "  DCHECK(current->HasRegisterAssigned());",
          "new_line_content": "  // Register reg is not blocked for the whole range.",
          "content_same": false
        },
        {
          "line": 2903,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "range->assigned_register()",
          "new_text": null,
          "old_line_content": "    if (range->assigned_register() == reg) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2904,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "      UsePosition* next_pos = range->NextRegisterPosition(current->Start());",
          "new_line_content": "  // This register was not free. Thus we need to find and spill",
          "content_same": false
        },
        {
          "line": 2905,
          "old_api": "FindOptimalSpillingPos",
          "new_api": null,
          "old_text": "FindOptimalSpillingPos(range, split_pos)",
          "new_text": null,
          "old_line_content": "      LifetimePosition spill_pos = FindOptimalSpillingPos(range, split_pos);",
          "new_line_content": "  // parts of active and inactive live regions that use the same register",
          "content_same": false
        },
        {
          "line": 2924,
          "old_api": "size",
          "new_api": null,
          "old_text": "inactive_live_ranges().size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < inactive_live_ranges().size(); ++i) {",
          "new_line_content": "        // remains spilled at least until the start of the current live range.",
          "content_same": false
        },
        {
          "line": 2925,
          "old_api": "inactive_live_ranges",
          "new_api": null,
          "old_text": "inactive_live_ranges()",
          "new_text": null,
          "old_line_content": "    LiveRange* range = inactive_live_ranges()[i];",
          "new_line_content": "        // This guarantees that we will not introduce new unhandled ranges that",
          "content_same": false
        },
        {
          "line": 2926,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "    DCHECK(range->End() > current->Start());",
          "new_line_content": "        // start before the current range as this violates allocation invariant",
          "content_same": false
        },
        {
          "line": 2927,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->IsFixed()",
          "new_text": null,
          "old_line_content": "    if (range->assigned_register() == reg && !range->TopLevel()->IsFixed()) {",
          "new_line_content": "        // and will lead to an inconsistent state of active and inactive",
          "content_same": false
        },
        {
          "line": 2928,
          "old_api": "FirstIntersection",
          "new_api": null,
          "old_text": "range->FirstIntersection(current)",
          "new_text": null,
          "old_line_content": "      LifetimePosition next_intersection = range->FirstIntersection(current);",
          "new_line_content": "        // live-ranges: ranges are allocated in order of their start positions,",
          "content_same": false
        },
        {
          "line": 2929,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "next_intersection.IsValid()",
          "new_text": null,
          "old_line_content": "      if (next_intersection.IsValid()) {",
          "new_line_content": "        // ranges are retired from active/inactive when the start of the",
          "content_same": false
        },
        {
          "line": 2930,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "        UsePosition* next_pos = range->NextRegisterPosition(current->Start());",
          "new_line_content": "        // current live-range is larger than their end.",
          "content_same": false
        },
        {
          "line": 2932,
          "old_api": "SpillAfter",
          "new_api": null,
          "old_text": "SpillAfter(range, split_pos)",
          "new_text": null,
          "old_line_content": "          SpillAfter(range, split_pos);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2934,
          "old_api": "pos",
          "new_api": null,
          "old_text": "next_pos->pos()",
          "new_text": null,
          "old_line_content": "          next_intersection = Min(next_intersection, next_pos->pos());",
          "new_line_content": "      --i;",
          "content_same": false
        },
        {
          "line": 2935,
          "old_api": "SpillBetween",
          "new_api": null,
          "old_text": "SpillBetween(range, split_pos, next_intersection)",
          "new_text": null,
          "old_line_content": "          SpillBetween(range, split_pos, next_intersection);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2937,
          "old_api": "InactiveToHandled",
          "new_api": null,
          "old_text": "InactiveToHandled(range)",
          "new_text": null,
          "old_line_content": "        InactiveToHandled(range);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2950,
          "old_api": "GetPhiMapValueFor",
          "new_api": null,
          "old_text": "data()->GetPhiMapValueFor(range)",
          "new_text": null,
          "old_line_content": "      data()->GetPhiMapValueFor(range);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2952,
          "old_api": "block",
          "new_api": null,
          "old_text": "phi_map_value->block()",
          "new_text": null,
          "old_line_content": "  const InstructionBlock* block = phi_map_value->block();",
          "new_line_content": "        --i;",
          "content_same": false
        },
        {
          "line": 2956,
          "old_api": "size",
          "new_api": null,
          "old_text": "phi->operands().size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < phi->operands().size(); i++) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2957,
          "old_api": "operands",
          "new_api": null,
          "old_text": "phi->operands()",
          "new_text": null,
          "old_line_content": "    int op = phi->operands()[i];",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2958,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": null,
          "old_text": "data()->GetOrCreateLiveRangeFor(op)",
          "new_text": null,
          "old_line_content": "    LiveRange* op_range = data()->GetOrCreateLiveRangeFor(op);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2959,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "op_range->TopLevel()->HasSpillRange()",
          "new_text": null,
          "old_line_content": "    if (!op_range->TopLevel()->HasSpillRange()) continue;",
          "new_line_content": "bool LinearScanAllocator::TryReuseSpillForPhi(TopLevelLiveRange* range) {",
          "content_same": false
        },
        {
          "line": 2961,
          "old_api": "predecessors",
          "new_api": null,
          "old_text": "block->predecessors()",
          "new_text": null,
          "old_line_content": "        code()->InstructionBlockAt(block->predecessors()[i]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2963,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(\n            pred->last_instruction_index())",
          "new_text": null,
          "old_line_content": "        LifetimePosition::InstructionFromInstructionIndex(",
          "new_line_content": "  RegisterAllocationData::PhiMapValue* phi_map_value =",
          "content_same": false
        },
        {
          "line": 2968,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "op_range->spilled()",
          "new_text": null,
          "old_line_content": "    if (op_range != nullptr && op_range->spilled()) {",
          "new_line_content": "  size_t spilled_count = 0;",
          "content_same": false
        },
        {
          "line": 2983,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(first_op != nullptr)",
          "new_text": null,
          "old_line_content": "  DCHECK(first_op != nullptr);",
          "new_line_content": "      spilled_count++;",
          "content_same": false
        },
        {
          "line": 2984,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "first_op->TopLevel()->GetSpillRange()",
          "new_text": null,
          "old_line_content": "  SpillRange* first_op_spill = first_op->TopLevel()->GetSpillRange();",
          "new_line_content": "      if (first_op == nullptr) {",
          "content_same": false
        },
        {
          "line": 2986,
          "old_api": "size",
          "new_api": null,
          "old_text": "phi->operands().size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 1; i < phi->operands().size(); i++) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2987,
          "old_api": "operands",
          "new_api": null,
          "old_text": "phi->operands()",
          "new_text": null,
          "old_line_content": "    int op = phi->operands()[i];",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2988,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "    TopLevelLiveRange* op_range = data()->live_ranges()[op];",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2989,
          "old_api": "HasSpillRange",
          "new_api": null,
          "old_text": "op_range->HasSpillRange()",
          "new_text": null,
          "old_line_content": "    if (!op_range->HasSpillRange()) continue;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2990,
          "old_api": "GetSpillRange",
          "new_api": null,
          "old_text": "op_range->GetSpillRange()",
          "new_text": null,
          "old_line_content": "    SpillRange* op_spill = op_range->GetSpillRange();",
          "new_line_content": "  // Only continue if more than half of the operands are spilled.",
          "content_same": false
        },
        {
          "line": 2999,
          "old_api": "interval",
          "new_api": null,
          "old_text": "first_op_spill->interval()",
          "new_text": null,
          "old_line_content": "      AreUseIntervalsIntersecting(first_op_spill->interval(),",
          "new_line_content": "  size_t num_merged = 1;",
          "content_same": false
        },
        {
          "line": 3006,
          "old_api": "Start",
          "new_api": null,
          "old_text": "range->Start()",
          "new_text": null,
          "old_line_content": "  LifetimePosition next_pos = range->Start();",
          "new_line_content": "      num_merged++;",
          "content_same": false
        },
        {
          "line": 3007,
          "old_api": "NextStart",
          "new_api": null,
          "old_text": "next_pos.NextStart()",
          "new_text": null,
          "old_line_content": "  if (next_pos.IsGapPosition()) next_pos = next_pos.NextStart();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3008,
          "old_api": "NextUsePositionRegisterIsBeneficial",
          "new_api": null,
          "old_text": "range->NextUsePositionRegisterIsBeneficial(next_pos)",
          "new_text": null,
          "old_line_content": "  UsePosition* pos = range->NextUsePositionRegisterIsBeneficial(next_pos);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3011,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->HasSpillRange()",
          "new_text": null,
          "old_line_content": "        range->TopLevel()->HasSpillRange()",
          "new_line_content": "  // same spill slot.",
          "content_same": false
        },
        {
          "line": 3015,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(merged)",
          "new_text": null,
          "old_line_content": "    CHECK(merged);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 3016,
          "old_api": "Spill",
          "new_api": null,
          "old_text": "Spill(range)",
          "new_text": null,
          "old_line_content": "    Spill(range);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3018,
          "old_api": "NextStart",
          "new_api": null,
          "old_text": "range->Start().NextStart()",
          "new_text": null,
          "old_line_content": "  } else if (pos->pos() > range->Start().NextStart()) {",
          "new_line_content": "  // If the range does not need register soon, spill it to the merged",
          "content_same": false
        },
        {
          "line": 3023,
          "old_api": "TryMerge",
          "new_api": null,
          "old_text": "first_op_spill->TryMerge(spill_range)",
          "new_text": null,
          "old_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "new_line_content": "  if (pos == nullptr) {",
          "content_same": false
        },
        {
          "line": 3024,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(merged)",
          "new_text": null,
          "old_line_content": "    CHECK(merged);",
          "new_line_content": "    SpillRange* spill_range =",
          "content_same": false
        },
        {
          "line": 3041,
          "old_api": "SpillBetweenUntil",
          "new_api": null,
          "old_text": "SpillBetweenUntil(range, start, start, end)",
          "new_text": null,
          "old_line_content": "  SpillBetweenUntil(range, start, start, end);",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 3050,
          "old_api": "SplitRangeAt",
          "new_api": null,
          "old_text": "SplitRangeAt(range, start)",
          "new_text": null,
          "old_line_content": "  LiveRange* second_part = SplitRangeAt(range, start);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3052,
          "old_api": "Start",
          "new_api": null,
          "old_text": "second_part->Start()",
          "new_text": null,
          "old_line_content": "  if (second_part->Start() < end) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3056,
          "old_api": "PrevStart",
          "new_api": null,
          "old_text": "end.PrevStart().End()",
          "new_text": null,
          "old_line_content": "    LifetimePosition third_part_end = end.PrevStart().End();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3057,
          "old_api": "Start",
          "new_api": null,
          "old_text": "end.Start()",
          "new_text": null,
          "old_line_content": "    if (data()->IsBlockBoundary(end.Start())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3058,
          "old_api": "Start",
          "new_api": null,
          "old_text": "end.Start()",
          "new_text": null,
          "old_line_content": "      third_part_end = end.Start();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3060,
          "old_api": "End",
          "new_api": null,
          "old_text": "SplitBetween(\n        second_part, Max(second_part->Start().End(), until), third_part_end)",
          "new_text": null,
          "old_line_content": "    LiveRange* third_part = SplitBetween(",
          "new_line_content": "                                            LifetimePosition start,",
          "content_same": false
        },
        {
          "line": 3061,
          "old_api": "End",
          "new_api": null,
          "old_text": "second_part->Start().End()",
          "new_text": null,
          "old_line_content": "        second_part, Max(second_part->Start().End(), until), third_part_end);",
          "new_line_content": "                                            LifetimePosition until,",
          "content_same": false
        },
        {
          "line": 3065,
          "old_api": "Spill",
          "new_api": null,
          "old_text": "Spill(second_part)",
          "new_text": null,
          "old_line_content": "    Spill(second_part);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3081,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 3082,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (range == nullptr || range->IsEmpty()) continue;",
          "new_line_content": "    // The split result does not intersect with [start, end[.",
          "content_same": false
        },
        {
          "line": 3085,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": null,
          "old_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": null,
          "old_line_content": "    if (range->IsSpilledOnlyInDeferredBlocks()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3086,
          "old_api": "next",
          "new_api": null,
          "old_text": "child->next()",
          "new_text": null,
          "old_line_content": "      for (LiveRange* child = range; child != nullptr; child = child->next()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3087,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "child->spilled()",
          "new_text": null,
          "old_line_content": "        if (child->spilled()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3088,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "child->Start().ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "          code->GetInstructionBlock(child->Start().ToInstructionIndex())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3097,
          "old_api": "GetInstructionBlock",
          "new_api": null,
          "old_text": "code->GetInstructionBlock(spills->gap_index)->mark_needs_frame()",
          "new_text": null,
          "old_line_content": "        code->GetInstructionBlock(spills->gap_index)->mark_needs_frame();",
          "new_line_content": "    // We care only about ranges which spill in the frame.",
          "content_same": false
        },
        {
          "line": 3110,
          "old_api": "size",
          "new_api": null,
          "old_text": "spill_ranges.size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < spill_ranges.size(); ++i) {",
          "new_line_content": "      for (; spills != nullptr; spills = spills->next) {",
          "content_same": false
        },
        {
          "line": 3113,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (range->IsEmpty()) continue;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3114,
          "old_api": "size",
          "new_api": null,
          "old_text": "spill_ranges.size()",
          "new_text": null,
          "old_line_content": "    for (size_t j = i + 1; j < spill_ranges.size(); ++j) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3116,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "other->IsEmpty()",
          "new_text": null,
          "old_line_content": "      if (other != nullptr && !other->IsEmpty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3117,
          "old_api": "TryMerge",
          "new_api": null,
          "old_text": "range->TryMerge(other)",
          "new_text": null,
          "old_line_content": "        range->TryMerge(other);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3123,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (range == nullptr || range->IsEmpty()) continue;",
          "new_line_content": "  // Merge disjoint spill ranges",
          "content_same": false
        },
        {
          "line": 3125,
          "old_api": "HasSlot",
          "new_api": null,
          "old_text": "range->HasSlot()",
          "new_text": null,
          "old_line_content": "    if (!range->HasSlot()) {",
          "new_line_content": "    SpillRange* range = spill_ranges[i];",
          "content_same": false
        },
        {
          "line": 3126,
          "old_api": "ByteWidth",
          "new_api": null,
          "old_text": "range->ByteWidth()",
          "new_text": null,
          "old_line_content": "      int byte_width = range->ByteWidth();",
          "new_line_content": "    if (range == nullptr) continue;",
          "content_same": false
        },
        {
          "line": 3135,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "new_line_content": "  // Allocate slots for the merged spill ranges.",
          "content_same": false
        },
        {
          "line": 3136,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "top_range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (top_range == nullptr || top_range->IsEmpty()) continue;",
          "new_line_content": "  for (SpillRange* range : spill_ranges) {",
          "content_same": false
        },
        {
          "line": 3138,
          "old_api": "HasSpillOperand",
          "new_api": null,
          "old_text": "top_range->HasSpillOperand()",
          "new_text": null,
          "old_line_content": "    if (top_range->HasSpillOperand()) {",
          "new_line_content": "    // Allocate a new operand referring to the spill slot.",
          "content_same": false
        },
        {
          "line": 3143,
          "old_api": "is_phi",
          "new_api": null,
          "old_text": "top_range->is_phi()",
          "new_text": null,
          "old_line_content": "    if (top_range->is_phi()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3144,
          "old_api": "GetPhiMapValueFor",
          "new_api": null,
          "old_text": "data()->GetPhiMapValueFor(top_range)->CommitAssignment(\n          top_range->GetAssignedOperand())",
          "new_text": null,
          "old_line_content": "      data()->GetPhiMapValueFor(top_range)->CommitAssignment(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3145,
          "old_api": "GetAssignedOperand",
          "new_api": null,
          "old_text": "top_range->GetAssignedOperand()",
          "new_text": null,
          "old_line_content": "          top_range->GetAssignedOperand());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3148,
          "old_api": "next",
          "new_api": null,
          "old_text": "range->next()",
          "new_text": null,
          "old_line_content": "         range = range->next()) {",
          "new_line_content": "void OperandAssigner::CommitAssignment() {",
          "content_same": false
        },
        {
          "line": 3168,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()",
          "new_text": null,
          "old_line_content": "            data()->code(), spill_operand,",
          "new_line_content": "      // If this top level range has a child spilled in a deferred block, we use",
          "content_same": false
        },
        {
          "line": 3169,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "top_range->spilled()",
          "new_text": null,
          "old_line_content": "            top_range->has_slot_use() || top_range->spilled());",
          "new_line_content": "      // the range and control flow connection mechanism instead of spilling at",
          "content_same": false
        },
        {
          "line": 3184,
          "old_api": "instruction_position",
          "new_api": null,
          "old_text": "map->instruction_position()",
          "new_text": null,
          "old_line_content": "    safe_point = map->instruction_position();",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3191,
          "old_api": "SafePointsAreInOrder",
          "new_api": null,
          "old_text": "SafePointsAreInOrder()",
          "new_text": null,
          "old_line_content": "  DCHECK(SafePointsAreInOrder());",
          "new_line_content": "    : data_(data) {}",
          "content_same": false
        },
        {
          "line": 3194,
          "old_api": "delayed_references",
          "new_api": null,
          "old_text": "data()->delayed_references()",
          "new_text": null,
          "old_line_content": "       data()->delayed_references()) {",
          "new_line_content": "bool ReferenceMapPopulator::SafePointsAreInOrder() const {",
          "content_same": false
        },
        {
          "line": 3195,
          "old_api": "RecordReference",
          "new_api": null,
          "old_text": "delayed_reference.map->RecordReference(\n        AllocatedOperand::cast(*delayed_reference.operand))",
          "new_text": null,
          "old_line_content": "    delayed_reference.map->RecordReference(",
          "new_line_content": "  int safe_point = 0;",
          "content_same": false
        },
        {
          "line": 3201,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()->reference_maps()",
          "new_text": null,
          "old_line_content": "  const ReferenceMapDeque* reference_maps = data()->code()->reference_maps();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3202,
          "old_api": "begin",
          "new_api": null,
          "old_text": "reference_maps->begin()",
          "new_text": null,
          "old_line_content": "  ReferenceMapDeque::const_iterator first_it = reference_maps->begin();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3203,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3206,
          "old_api": "IsReference",
          "new_api": null,
          "old_text": "data()->IsReference(range)",
          "new_text": null,
          "old_line_content": "    if (!data()->IsReference(range)) continue;",
          "new_line_content": "  // Map all delayed references.",
          "content_same": false
        },
        {
          "line": 3212,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "range->Start().ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "    int start = range->Start().ToInstructionIndex();",
          "new_line_content": "  // Iterate over all safe point positions and record a pointer",
          "content_same": false
        },
        {
          "line": 3214,
          "old_api": "next",
          "new_api": null,
          "old_text": "cur->next()",
          "new_text": null,
          "old_line_content": "    for (LiveRange* cur = range; cur != nullptr; cur = cur->next()) {",
          "new_line_content": "  int last_range_start = 0;",
          "content_same": false
        },
        {
          "line": 3218,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "cur->Start().ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "      DCHECK(cur->Start().ToInstructionIndex() >= start);",
          "new_line_content": "    if (range == nullptr) continue;",
          "content_same": false
        },
        {
          "line": 3234,
          "old_api": "HasSpillOperand",
          "new_api": null,
          "old_text": "range->HasSpillOperand()",
          "new_text": null,
          "old_line_content": "    if (((range->HasSpillOperand() &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3235,
          "old_api": "GetSpillOperand",
          "new_api": null,
          "old_text": "range->GetSpillOperand()->IsConstant()",
          "new_text": null,
          "old_line_content": "          !range->GetSpillOperand()->IsConstant()) ||",
          "new_line_content": "    // Most of the ranges are in order, but not all.  Keep an eye on when they",
          "content_same": false
        },
        {
          "line": 3236,
          "old_api": "HasSpillRange",
          "new_api": null,
          "old_text": "range->HasSpillRange()",
          "new_text": null,
          "old_line_content": "         range->HasSpillRange())) {",
          "new_line_content": "    // step backwards and reset the first_it so we don't miss any safe points.",
          "content_same": false
        },
        {
          "line": 3238,
          "old_api": "GetSpillOperand",
          "new_api": null,
          "old_text": "range->GetSpillOperand()",
          "new_text": null,
          "old_line_content": "        spill_operand = *range->GetSpillOperand();",
          "new_line_content": "    last_range_start = start;",
          "content_same": false
        },
        {
          "line": 3240,
          "old_api": "GetSpillRangeOperand",
          "new_api": null,
          "old_text": "range->GetSpillRangeOperand()",
          "new_text": null,
          "old_line_content": "        spill_operand = range->GetSpillRangeOperand();",
          "new_line_content": "    // Step across all the safe points that are before the start of this range,",
          "content_same": false
        },
        {
          "line": 3243,
          "old_api": "representation",
          "new_api": null,
          "old_text": "DCHECK_EQ(MachineRepresentation::kTagged,\n                AllocatedOperand::cast(spill_operand).representation())",
          "new_text": null,
          "old_line_content": "      DCHECK_EQ(MachineRepresentation::kTagged,",
          "new_line_content": "      ReferenceMap* map = *first_it;",
          "content_same": false
        },
        {
          "line": 3259,
          "old_api": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "new_api": null,
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "new_text": null,
          "old_line_content": "          LifetimePosition::InstructionFromInstructionIndex(safe_point);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3267,
          "old_api": "DCHECK_NOT_NULL",
          "new_api": null,
          "old_text": "DCHECK_NOT_NULL(cur)",
          "new_text": null,
          "old_line_content": "      DCHECK_NOT_NULL(cur);",
          "new_line_content": "      // The safe points are sorted so we can stop searching here.",
          "content_same": false
        },
        {
          "line": 3268,
          "old_api": "Start",
          "new_api": null,
          "old_text": "cur->Start()",
          "new_text": null,
          "old_line_content": "      DCHECK(safe_point_pos >= cur->Start() || range == cur);",
          "new_line_content": "      if (safe_point - 1 > end) break;",
          "content_same": false
        },
        {
          "line": 3271,
          "old_api": "Covers",
          "new_api": null,
          "old_text": "cur->Covers(safe_point_pos)",
          "new_text": null,
          "old_line_content": "        if (cur->Covers(safe_point_pos)) {",
          "new_line_content": "      // safe point position.",
          "content_same": false
        },
        {
          "line": 3274,
          "old_api": "next",
          "new_api": null,
          "old_text": "cur->next()",
          "new_text": null,
          "old_line_content": "          LiveRange* next = cur->next();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3275,
          "old_api": "Start",
          "new_api": null,
          "old_text": "next->Start()",
          "new_text": null,
          "old_line_content": "          if (next == nullptr || next->Start() > safe_point_pos) {",
          "new_line_content": "      // Search for the child range (cur) that covers safe_point_pos. If we",
          "content_same": false
        },
        {
          "line": 3290,
          "old_api": "spill_start_index",
          "new_api": null,
          "old_text": "range->spill_start_index()",
          "new_text": null,
          "old_line_content": "                            : range->spill_start_index();",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 3292,
          "old_api": "IsInvalid",
          "new_api": null,
          "old_text": "spill_operand.IsInvalid()",
          "new_text": null,
          "old_line_content": "      if (!spill_operand.IsInvalid() && safe_point >= spill_index) {",
          "new_line_content": "          cur = next;",
          "content_same": false
        },
        {
          "line": 3293,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",\n              range->vreg(), spill_index, safe_point)",
          "new_text": null,
          "old_line_content": "        TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3294,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "range->vreg()",
          "new_text": null,
          "old_line_content": "              range->vreg(), spill_index, safe_point);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3295,
          "old_api": "AllocatedOperand::cast(spill_operand)",
          "new_api": null,
          "old_text": "AllocatedOperand::cast(spill_operand)",
          "new_text": null,
          "old_line_content": "        map->RecordReference(AllocatedOperand::cast(spill_operand));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3298,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "cur->spilled()",
          "new_text": null,
          "old_line_content": "      if (!cur->spilled()) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3299,
          "old_api": "value",
          "new_api": null,
          "old_text": "TRACE(\n            \"Pointer in register for range %d:%d (start at %d) \"\n            \"at safe point %d\\n\",\n            range->vreg(), cur->relative_id(), cur->Start().value(),\n            safe_point)",
          "new_text": null,
          "old_line_content": "        TRACE(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3305,
          "old_api": "IsStackSlot",
          "new_api": null,
          "old_text": "operand.IsStackSlot()",
          "new_text": null,
          "old_line_content": "        DCHECK(!operand.IsStackSlot());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3329,
          "old_api": "live_in_sets",
          "new_api": null,
          "old_text": "data()->live_in_sets()",
          "new_text": null,
          "old_line_content": "  ZoneVector<BitVector*>& live_in_sets = data()->live_in_sets();",
          "new_line_content": "LiveRangeConnector::LiveRangeConnector(RegisterAllocationData* data)",
          "content_same": false
        },
        {
          "line": 3330,
          "old_api": "instruction_blocks",
          "new_api": null,
          "old_text": "code()->instruction_blocks()",
          "new_text": null,
          "old_line_content": "  for (const InstructionBlock* block : code()->instruction_blocks()) {",
          "new_line_content": "    : data_(data) {}",
          "content_same": false
        },
        {
          "line": 3331,
          "old_api": "CanEagerlyResolveControlFlow",
          "new_api": null,
          "old_text": "CanEagerlyResolveControlFlow(block)",
          "new_text": null,
          "old_line_content": "    if (CanEagerlyResolveControlFlow(block)) continue;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3332,
          "old_api": "ToInt",
          "new_api": null,
          "old_text": "block->rpo_number().ToInt()",
          "new_text": null,
          "old_line_content": "    BitVector* live = live_in_sets[block->rpo_number().ToInt()];",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3334,
          "old_api": "Done",
          "new_api": null,
          "old_text": "iterator.Done()",
          "new_text": null,
          "old_line_content": "    while (!iterator.Done()) {",
          "new_line_content": "    const InstructionBlock* block) const {",
          "content_same": false
        },
        {
          "line": 3338,
          "old_api": "InstructionBlockAt",
          "new_api": null,
          "old_text": "code()->InstructionBlockAt(pred)",
          "new_text": null,
          "old_line_content": "        const InstructionBlock* pred_block = code()->InstructionBlockAt(pred);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3339,
          "old_api": "FindConnectableSubranges",
          "new_api": null,
          "old_text": "array->FindConnectableSubranges(block, pred_block, &result)",
          "new_text": null,
          "old_line_content": "        if (!array->FindConnectableSubranges(block, pred_block, &result)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3342,
          "old_api": "GetAssignedOperand",
          "new_api": null,
          "old_text": "result.pred_cover_->GetAssignedOperand()",
          "new_text": null,
          "old_line_content": "        InstructionOperand pred_op = result.pred_cover_->GetAssignedOperand();",
          "new_line_content": "  LiveRangeFinder finder(data(), local_zone);",
          "content_same": false
        },
        {
          "line": 3354,
          "old_api": "code_end",
          "new_api": null,
          "old_text": "block->code_end()",
          "new_text": null,
          "old_line_content": "              LifetimePosition::GapFromInstructionIndex(block->code_end());",
          "new_line_content": "          continue;",
          "content_same": false
        },
        {
          "line": 3363,
          "old_api": "NextUsePosition",
          "new_api": null,
          "old_text": "current->NextUsePosition(block_start)",
          "new_text": null,
          "old_line_content": "            for (const UsePosition* use = current->NextUsePosition(block_start);",
          "new_line_content": "          // 2) the range ends before the block does, and",
          "content_same": false
        },
        {
          "line": 3364,
          "old_api": "next",
          "new_api": null,
          "old_text": "use->next()",
          "new_text": null,
          "old_line_content": "                 use != nullptr; use = use->next()) {",
          "new_line_content": "          // 3) we don't have a successor, or the successor is spilled.",
          "content_same": false
        },
        {
          "line": 3365,
          "old_api": "operand",
          "new_api": null,
          "old_text": "use->operand()->IsAnyRegister()",
          "new_text": null,
          "old_line_content": "              if (use->operand()->IsAnyRegister()) {",
          "new_line_content": "          LifetimePosition block_start =",
          "content_same": false
        },
        {
          "line": 3373,
          "old_api": "IsDeferred",
          "new_api": null,
          "old_text": "pred_block->IsDeferred()",
          "new_text": null,
          "old_line_content": "              pred_block->IsDeferred()) {",
          "new_line_content": "            // verify point 1: no register use. We can go to the end of the",
          "content_same": false
        },
        {
          "line": 3376,
          "old_api": "ToInt",
          "new_api": null,
          "old_text": "current->TopLevel()->GetListOfBlocksRequiringSpillOperands()->Add(\n                pred_block->rpo_number().ToInt())",
          "new_text": null,
          "old_line_content": "            current->TopLevel()->GetListOfBlocksRequiringSpillOperands()->Add(",
          "new_line_content": "            bool uses_reg = false;",
          "content_same": false
        },
        {
          "line": 3380,
          "old_api": "ResolveControlFlow",
          "new_api": null,
          "old_text": "ResolveControlFlow(block, cur_op, pred_block, pred_op)",
          "new_text": null,
          "old_line_content": "        int move_loc = ResolveControlFlow(block, cur_op, pred_block, pred_op);",
          "new_line_content": "                uses_reg = true;",
          "content_same": false
        },
        {
          "line": 3381,
          "old_api": "USE",
          "new_api": null,
          "old_text": "USE(move_loc)",
          "new_text": null,
          "old_line_content": "        USE(move_loc);",
          "new_line_content": "                break;",
          "content_same": false
        },
        {
          "line": 3382,
          "old_api": "IsAnyRegister",
          "new_api": null,
          "old_text": "DCHECK_IMPLIES(\n            result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&\n                !(pred_op.IsAnyRegister() && cur_op.IsAnyRegister()),\n            code()->GetInstructionBlock(move_loc)->IsDeferred())",
          "new_text": null,
          "old_line_content": "        DCHECK_IMPLIES(",
          "new_line_content": "              }",
          "content_same": false
        },
        {
          "line": 3383,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks()",
          "new_text": null,
          "old_line_content": "            result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3384,
          "old_api": "IsAnyRegister",
          "new_api": null,
          "old_text": "cur_op.IsAnyRegister()",
          "new_text": null,
          "old_line_content": "                !(pred_op.IsAnyRegister() && cur_op.IsAnyRegister()),",
          "new_line_content": "            if (!uses_reg) continue;",
          "content_same": false
        },
        {
          "line": 3385,
          "old_api": "GetInstructionBlock",
          "new_api": null,
          "old_text": "code()->GetInstructionBlock(move_loc)->IsDeferred()",
          "new_text": null,
          "old_line_content": "            code()->GetInstructionBlock(move_loc)->IsDeferred());",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 3407,
          "old_api": "Equals",
          "new_api": null,
          "old_text": "pred_op.Equals(cur_op)",
          "new_text": null,
          "old_line_content": "  DCHECK(!pred_op.Equals(cur_op));",
          "new_line_content": "  // deferred blocks.",
          "content_same": false
        },
        {
          "line": 3411,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "block->first_instruction_index()",
          "new_text": null,
          "old_line_content": "    gap_index = block->first_instruction_index();",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 3414,
          "old_api": "SuccessorCount",
          "new_api": null,
          "old_text": "pred->SuccessorCount()",
          "new_text": null,
          "old_line_content": "    DCHECK(pred->SuccessorCount() == 1);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3415,
          "old_api": "InstructionAt",
          "new_api": null,
          "old_text": "code()\n                ->InstructionAt(pred->last_instruction_index())\n                ->HasReferenceMap()",
          "new_text": null,
          "old_line_content": "    DCHECK(!code()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3416,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "pred->last_instruction_index()",
          "new_text": null,
          "old_line_content": "                ->InstructionAt(pred->last_instruction_index())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3418,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "pred->last_instruction_index()",
          "new_text": null,
          "old_line_content": "    gap_index = pred->last_instruction_index();",
          "new_line_content": "                                           const InstructionOperand& cur_op,",
          "content_same": false
        },
        {
          "line": 3433,
          "old_api": "next",
          "new_api": null,
          "old_text": "second_range->next()",
          "new_text": null,
          "old_line_content": "         first_range = second_range, second_range = second_range->next()) {",
          "new_line_content": "    position = Instruction::END;",
          "content_same": false
        },
        {
          "line": 3434,
          "old_api": "Start",
          "new_api": null,
          "old_text": "second_range->Start()",
          "new_text": null,
          "old_line_content": "      LifetimePosition pos = second_range->Start();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3437,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "second_range->spilled()",
          "new_text": null,
          "old_line_content": "      if (second_range->spilled()) continue;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3438,
          "old_api": "End",
          "new_api": null,
          "old_text": "first_range->End()",
          "new_text": null,
          "old_line_content": "      if (first_range->End() != pos) continue;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3439,
          "old_api": "IsBlockBoundary",
          "new_api": null,
          "old_text": "data()->IsBlockBoundary(pos)",
          "new_text": null,
          "old_line_content": "      if (data()->IsBlockBoundary(pos) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3440,
          "old_api": "code",
          "new_api": null,
          "old_text": "code()",
          "new_text": null,
          "old_line_content": "          !CanEagerlyResolveControlFlow(GetInstructionBlock(code(), pos))) {",
          "new_line_content": "void LiveRangeConnector::ConnectRanges(Zone* local_zone) {",
          "content_same": false
        },
        {
          "line": 3443,
          "old_api": "GetAssignedOperand",
          "new_api": null,
          "old_text": "first_range->GetAssignedOperand()",
          "new_text": null,
          "old_line_content": "      InstructionOperand prev_operand = first_range->GetAssignedOperand();",
          "new_line_content": "    if (top_range == nullptr) continue;",
          "content_same": false
        },
        {
          "line": 3445,
          "old_api": "Equals",
          "new_api": null,
          "old_text": "prev_operand.Equals(cur_operand)",
          "new_text": null,
          "old_line_content": "      if (prev_operand.Equals(cur_operand)) continue;",
          "new_line_content": "    LiveRange* first_range = top_range;",
          "content_same": false
        },
        {
          "line": 3449,
          "old_api": "IsAnyRegister",
          "new_api": null,
          "old_text": "prev_operand.IsAnyRegister()",
          "new_text": null,
          "old_line_content": "      if (connect_spilled && !prev_operand.IsAnyRegister() &&",
          "new_line_content": "      // Add gap move if the two live ranges touch and there is no block",
          "content_same": false
        },
        {
          "line": 3450,
          "old_api": "IsAnyRegister",
          "new_api": null,
          "old_text": "cur_operand.IsAnyRegister()",
          "new_text": null,
          "old_line_content": "          cur_operand.IsAnyRegister()) {",
          "new_line_content": "      // boundary.",
          "content_same": false
        },
        {
          "line": 3455,
          "old_api": "ToInt",
          "new_api": null,
          "old_text": "top_range->GetListOfBlocksRequiringSpillOperands()->Add(\n            block->rpo_number().ToInt())",
          "new_text": null,
          "old_line_content": "        top_range->GetListOfBlocksRequiringSpillOperands()->Add(",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 3456,
          "old_api": "ToInt",
          "new_api": null,
          "old_text": "block->rpo_number().ToInt()",
          "new_text": null,
          "old_line_content": "            block->rpo_number().ToInt());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3460,
          "old_api": "IsStart",
          "new_api": null,
          "old_text": "pos.IsStart()",
          "new_text": null,
          "old_line_content": "        gap_pos = pos.IsStart() ? Instruction::START : Instruction::END;",
          "new_line_content": "      bool delay_insertion = false;",
          "content_same": false
        },
        {
          "line": 3471,
          "old_api": "IsAnyRegister",
          "new_api": null,
          "old_text": "DCHECK_IMPLIES(\n          connect_spilled &&\n              !(prev_operand.IsAnyRegister() && cur_operand.IsAnyRegister()),\n          code()->GetInstructionBlock(gap_index)->IsDeferred())",
          "new_text": null,
          "old_line_content": "      DCHECK_IMPLIES(",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3477,
          "old_api": "InstructionAt",
          "new_api": null,
          "old_text": "code()->InstructionAt(gap_index)->GetOrCreateParallelMove(\n              gap_pos, code_zone())",
          "new_text": null,
          "old_line_content": "          code()->InstructionAt(gap_index)->GetOrCreateParallelMove(",
          "new_line_content": "          delay_insertion = true;",
          "content_same": false
        },
        {
          "line": 3478,
          "old_api": "code_zone",
          "new_api": null,
          "old_text": "code_zone()",
          "new_text": null,
          "old_line_content": "              gap_pos, code_zone());",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 3480,
          "old_api": "AddMove",
          "new_api": null,
          "old_text": "move->AddMove(prev_operand, cur_operand)",
          "new_text": null,
          "old_line_content": "        move->AddMove(prev_operand, cur_operand);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3482,
          "old_api": "insert",
          "new_api": null,
          "old_text": "delayed_insertion_map.insert(\n            std::make_pair(std::make_pair(move, prev_operand), cur_operand))",
          "new_text": null,
          "old_line_content": "        delayed_insertion_map.insert(",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3483,
          "old_api": "std::make_pair(move, prev_operand)",
          "new_api": null,
          "old_text": "std::make_pair(move, prev_operand)",
          "new_text": null,
          "old_line_content": "            std::make_pair(std::make_pair(move, prev_operand), cur_operand));",
          "new_line_content": "      // Reloads or spills for spilled in deferred blocks ranges must happen",
          "content_same": false
        },
        {
          "line": 3493,
          "old_api": "begin",
          "new_api": null,
          "old_text": "delayed_insertion_map.begin()",
          "new_text": null,
          "old_line_content": "  ParallelMove* moves = delayed_insertion_map.begin()->first.first;",
          "new_line_content": "      if (!delay_insertion) {",
          "content_same": false
        },
        {
          "line": 3495,
          "old_api": "end",
          "new_api": null,
          "old_text": "delayed_insertion_map.end()",
          "new_text": null,
          "old_line_content": "    bool done = it == delayed_insertion_map.end();",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 3499,
          "old_api": "Eliminate",
          "new_api": null,
          "old_text": "move->Eliminate()",
          "new_text": null,
          "old_line_content": "        move->Eliminate();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3502,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "moves->push_back(move)",
          "new_text": null,
          "old_line_content": "        moves->push_back(move);",
          "new_line_content": "  // Insert all the moves which should occur after the stored move.",
          "content_same": false
        },
        {
          "line": 3512,
          "old_api": "code_zone",
          "new_api": null,
          "old_text": "code_zone()",
          "new_text": null,
          "old_line_content": "        new (code_zone()) MoveOperands(it->first.second, it->second);",
          "new_line_content": "      for (MoveOperands* move : to_eliminate) {",
          "content_same": false
        },
        {
          "line": 3514,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "to_insert.push_back(move)",
          "new_text": null,
          "old_line_content": "    to_insert.push_back(move);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3515,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "to_eliminate.push_back(eliminate)",
          "new_text": null,
          "old_line_content": "    if (eliminate != nullptr) to_eliminate.push_back(eliminate);",
          "new_line_content": "      for (MoveOperands* move : to_insert) {",
          "content_same": false
        },
        {
          "line": 3522,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": null,
          "old_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": null,
          "old_line_content": "  DCHECK(range->IsSpilledOnlyInDeferredBlocks());",
          "new_line_content": "      moves = it->first.first;",
          "content_same": false
        },
        {
          "line": 3523,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "range->spilled()",
          "new_text": null,
          "old_line_content": "  DCHECK(!range->spilled());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3525,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()",
          "new_text": null,
          "old_line_content": "  InstructionSequence* code = data()->code();",
          "new_line_content": "    MoveOperands* move =",
          "content_same": false
        },
        {
          "line": 3533,
          "old_api": "next",
          "new_api": null,
          "old_text": "child->next()",
          "new_text": null,
          "old_line_content": "       child = child->next()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3534,
          "old_api": "first_pos",
          "new_api": null,
          "old_text": "child->first_pos()",
          "new_text": null,
          "old_line_content": "    for (const UsePosition* pos = child->first_pos(); pos != nullptr;",
          "new_line_content": "void LiveRangeConnector::CommitSpillsInDeferredBlocks(",
          "content_same": false
        },
        {
          "line": 3535,
          "old_api": "next",
          "new_api": null,
          "old_text": "pos->next()",
          "new_text": null,
          "old_line_content": "         pos = pos->next()) {",
          "new_line_content": "    TopLevelLiveRange* range, LiveRangeBoundArray* array, Zone* temp_zone) {",
          "content_same": false
        },
        {
          "line": 3538,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "range->AddBlockRequiringSpillOperand(\n          code->GetInstructionBlock(pos->pos().ToInstructionIndex())\n              ->rpo_number())",
          "new_text": null,
          "old_line_content": "      range->AddBlockRequiringSpillOperand(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3555,
          "old_api": "GetListOfBlocksRequiringSpillOperands",
          "new_api": null,
          "old_text": "range->GetListOfBlocksRequiringSpillOperands()->length()",
          "new_text": null,
          "old_line_content": "      range->GetListOfBlocksRequiringSpillOperands()->length(), temp_zone);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3556,
          "old_api": "empty",
          "new_api": null,
          "old_text": "worklist.empty()",
          "new_text": null,
          "old_line_content": "  while (!worklist.empty()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3557,
          "old_api": "front",
          "new_api": null,
          "old_text": "worklist.front()",
          "new_text": null,
          "old_line_content": "    int block_id = worklist.front();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3558,
          "old_api": "pop",
          "new_api": null,
          "old_text": "worklist.pop()",
          "new_text": null,
          "old_line_content": "    worklist.pop();",
          "new_line_content": "  ZoneQueue<int> worklist(temp_zone);",
          "content_same": false
        },
        {
          "line": 3559,
          "old_api": "Contains",
          "new_api": null,
          "old_text": "done_blocks.Contains(block_id)",
          "new_text": null,
          "old_line_content": "    if (done_blocks.Contains(block_id)) continue;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3560,
          "old_api": "Add",
          "new_api": null,
          "old_text": "done_blocks.Add(block_id)",
          "new_text": null,
          "old_line_content": "    done_blocks.Add(block_id);",
          "new_line_content": "  for (BitVector::Iterator iterator(",
          "content_same": false
        },
        {
          "line": 3564,
          "old_api": "predecessors",
          "new_api": null,
          "old_text": "spill_block->predecessors()",
          "new_text": null,
          "old_line_content": "    for (const RpoNumber& pred : spill_block->predecessors()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3565,
          "old_api": "InstructionBlockAt",
          "new_api": null,
          "old_text": "code->InstructionBlockAt(pred)",
          "new_text": null,
          "old_line_content": "      const InstructionBlock* pred_block = code->InstructionBlockAt(pred);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3567,
          "old_api": "IsDeferred",
          "new_api": null,
          "old_text": "pred_block->IsDeferred()",
          "new_text": null,
          "old_line_content": "      if (pred_block->IsDeferred()) {",
          "new_line_content": "  // and spill there. We only need to spill at the start of such blocks.",
          "content_same": false
        },
        {
          "line": 3568,
          "old_api": "ToInt",
          "new_api": null,
          "old_text": "pred_block->rpo_number().ToInt()",
          "new_text": null,
          "old_line_content": "        worklist.push(pred_block->rpo_number().ToInt());",
          "new_line_content": "  BitVector done_blocks(",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 239,
      "total_additions": 359,
      "total_deletions": 352,
      "total_api_changes": 950
    },
    "non_api_changes": {
      "has_non_api_changes": false,
      "evidence": {
        "total_diff_lines": 16,
        "api_related_lines": 950,
        "non_api_lines": 0,
        "non_api_line_numbers": []
      }
    },
    "api_calls_before": 2124,
    "api_calls_after": 2132,
    "diff_info": {
      "added_lines": 16,
      "removed_lines": 2,
      "total_diff_lines": 30
    }
  }
}