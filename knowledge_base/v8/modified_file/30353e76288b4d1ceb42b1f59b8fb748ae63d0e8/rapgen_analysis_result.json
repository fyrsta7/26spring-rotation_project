{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/30353e76288b4d1ceb42b1f59b8fb748ae63d0e8",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/30353e76288b4d1ceb42b1f59b8fb748ae63d0e8/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/30353e76288b4d1ceb42b1f59b8fb748ae63d0e8/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/30353e76288b4d1ceb42b1f59b8fb748ae63d0e8/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": true,
    "api_changes": {
      "replacements": [
        {
          "line": 600,
          "old_api": "identity",
          "new_api": "in_gc",
          "old_text": "allocator_->identity()",
          "new_text": "allocator_->in_gc()",
          "old_line_content": "  if (!allocator_->in_gc() && !(allocator_->identity() == NEW_SPACE &&",
          "new_line_content": "  if (!allocator_->in_gc()) {",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": "StartIncrementalMarkingIfAllocationLimitIsReached",
          "new_api": "GCFlagsForIncrementalMarking",
          "old_text": "space_heap()->StartIncrementalMarkingIfAllocationLimitIsReached(\n        allocator_->local_heap(), space_heap()->GCFlagsForIncrementalMarking(),\n        kGCCallbackScheduleIdleGarbageCollection)",
          "new_text": "space_heap()->GCFlagsForIncrementalMarking()",
          "old_line_content": "    space_heap()->StartIncrementalMarkingIfAllocationLimitIsReached(",
          "new_line_content": "        allocator_->local_heap(), space_heap()->GCFlagsForIncrementalMarking(),",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": "identity",
          "new_api": "incremental_marking",
          "old_text": "allocator_->identity()",
          "new_text": "space_heap()->incremental_marking()->IsStopped()",
          "old_line_content": "  if (allocator_->identity() == NEW_SPACE &&",
          "new_line_content": "      space_heap()->incremental_marking()->IsStopped()) {",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": "incremental_marking",
          "new_api": "is_main_thread",
          "old_text": "space_heap()->incremental_marking()->IsStopped()",
          "new_text": "allocator_->is_main_thread()",
          "old_line_content": "      space_heap()->incremental_marking()->IsStopped()) {",
          "new_line_content": "    DCHECK(allocator_->is_main_thread());",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "is_main_thread",
          "new_api": "StartMinorMSIncrementalMarkingIfNeeded",
          "old_text": "allocator_->is_main_thread()",
          "new_text": "space_heap()->StartMinorMSIncrementalMarkingIfNeeded()",
          "old_line_content": "    DCHECK(allocator_->is_main_thread());",
          "new_line_content": "    space_heap()->StartMinorMSIncrementalMarkingIfNeeded();",
          "content_same": false
        },
        {
          "line": 617,
          "old_api": "Heap::GetMaximumFillToAlign(alignment)",
          "new_api": "top",
          "old_text": "Heap::GetMaximumFillToAlign(alignment)",
          "new_text": "allocator_->allocation_info().top()",
          "old_line_content": "  size_in_bytes += Heap::GetMaximumFillToAlign(alignment);",
          "new_line_content": "  if (allocator_->allocation_info().top() + size_in_bytes <=",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": "top",
          "new_api": "limit",
          "old_text": "allocator_->allocation_info().top()",
          "new_text": "allocator_->allocation_info().limit()",
          "old_line_content": "  if (allocator_->allocation_info().top() + size_in_bytes <=",
          "new_line_content": "      allocator_->allocation_info().limit()) {",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": "is_main_thread",
          "new_api": "IsMainThread",
          "old_text": "allocator_->is_main_thread()",
          "new_text": "isolate_heap()->IsMainThread()",
          "old_line_content": "      allocator_->is_main_thread() ||",
          "new_line_content": "      (allocator_->in_gc() && isolate_heap()->IsMainThread());",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": "sweeper",
          "new_api": "identity",
          "old_text": "space_heap()->sweeper()->GetTracingScope(\n      allocator_->identity(), is_main_thread)",
          "new_text": "allocator_->identity()",
          "old_line_content": "  const auto sweeping_scope_id = space_heap()->sweeper()->GetTracingScope(",
          "new_line_content": "      allocator_->identity(), is_main_thread);",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "sweeper",
          "new_api": "identity",
          "old_text": "space_heap()->sweeper()->ShouldRefillFreelistForSpace(\n            allocator_->identity())",
          "new_text": "allocator_->identity()",
          "old_line_content": "    if (space_heap()->sweeper()->ShouldRefillFreelistForSpace(",
          "new_line_content": "            allocator_->identity())) {",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": "tracer",
          "new_api": "sweeper",
          "old_text": "isolate_heap()->tracer()",
          "new_text": "isolate_heap()->sweeper()->GetTraceIdForFlowEvent(\n                sweeping_scope_id)",
          "old_line_content": "            isolate_heap()->tracer(), sweeping_scope_id, sweeping_scope_kind,",
          "new_line_content": "            isolate_heap()->sweeper()->GetTraceIdForFlowEvent(",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "is_compaction_space",
          "new_api": "identity",
          "old_text": "space_->is_compaction_space()",
          "new_text": "allocator_->identity()",
          "old_line_content": "  if (space_->is_compaction_space()) {",
          "new_line_content": "    DCHECK_NE(NEW_SPACE, allocator_->identity());",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": "identity",
          "new_api": "RemovePageSafe",
          "old_text": "allocator_->identity()",
          "new_text": "main_space->RemovePageSafe(size_in_bytes)",
          "old_line_content": "        space_heap()->paged_space(allocator_->identity());",
          "new_line_content": "    Page* page = main_space->RemovePageSafe(size_in_bytes);",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": "AddPage",
          "new_api": "static_cast<size_t>(size_in_bytes)",
          "old_text": "space_->AddPage(page)",
          "new_text": "static_cast<size_t>(size_in_bytes)",
          "old_line_content": "      space_->AddPage(page);",
          "new_line_content": "      if (TryAllocationFromFreeListMain(static_cast<size_t>(size_in_bytes),",
          "content_same": false
        },
        {
          "line": 685,
          "old_api": "identity",
          "new_api": "ShouldExpandOldGenerationOnSlowAllocation",
          "old_text": "allocator_->identity()",
          "new_text": "space_heap()->ShouldExpandOldGenerationOnSlowAllocation(\n          allocator_->local_heap(), origin)",
          "old_line_content": "  if (allocator_->identity() != NEW_SPACE &&",
          "new_line_content": "      space_heap()->ShouldExpandOldGenerationOnSlowAllocation(",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": "ShouldExpandOldGenerationOnSlowAllocation",
          "new_api": "local_heap",
          "old_text": "space_heap()->ShouldExpandOldGenerationOnSlowAllocation(\n          allocator_->local_heap(), origin)",
          "new_text": "allocator_->local_heap()",
          "old_line_content": "      space_heap()->ShouldExpandOldGenerationOnSlowAllocation(",
          "new_line_content": "          allocator_->local_heap(), origin) &&",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "local_heap",
          "new_api": "AreaSize",
          "old_text": "allocator_->local_heap()",
          "new_text": "space_->AreaSize()",
          "old_line_content": "          allocator_->local_heap(), origin) &&",
          "new_line_content": "      space_heap()->CanExpandOldGeneration(space_->AreaSize())) {",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": "AreaSize",
          "new_api": "static_cast<size_t>(size_in_bytes)",
          "old_text": "space_->AreaSize()",
          "new_text": "static_cast<size_t>(size_in_bytes)",
          "old_line_content": "      space_heap()->CanExpandOldGeneration(space_->AreaSize())) {",
          "new_line_content": "    if (TryExpandAndAllocate(static_cast<size_t>(size_in_bytes), origin)) {",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": "in_gc",
          "new_api": "force_oom",
          "old_text": "allocator_->in_gc()",
          "new_text": "space_heap()->force_oom()",
          "old_line_content": "  if (allocator_->identity() != NEW_SPACE && allocator_->in_gc() &&",
          "new_line_content": "      !space_heap()->force_oom()) {",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": "local_heap",
          "new_api": "static_cast<size_t>(size_in_bytes)",
          "old_text": "allocator_->local_heap()",
          "new_text": "static_cast<size_t>(size_in_bytes)",
          "old_line_content": "  while (space_->TryExpand(allocator_->local_heap(), origin)) {",
          "new_line_content": "    if (TryAllocationFromFreeListMain(static_cast<size_t>(size_in_bytes),",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "tracer",
          "new_api": "sweeper",
          "old_text": "isolate_heap()->tracer()",
          "new_text": "isolate_heap()->sweeper()->GetTraceIdForFlowEvent(sweeping_scope_id)",
          "old_line_content": "      isolate_heap()->tracer(), sweeping_scope_id, sweeping_scope_kind,",
          "new_line_content": "      isolate_heap()->sweeper()->GetTraceIdForFlowEvent(sweeping_scope_id),",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "sweeper",
          "new_api": "identity",
          "old_text": "space_heap()->sweeper()->ParallelSweepSpace(\n      allocator_->identity(), sweeping_mode, required_freed_bytes, max_pages)",
          "new_text": "allocator_->identity()",
          "old_line_content": "  space_heap()->sweeper()->ParallelSweepSpace(",
          "new_line_content": "      allocator_->identity(), sweeping_mode, required_freed_bytes, max_pages);",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "identity",
          "new_api": "RefillFreeList",
          "old_text": "allocator_->identity()",
          "new_text": "space_->RefillFreeList()",
          "old_line_content": "      allocator_->identity(), sweeping_mode, required_freed_bytes, max_pages);",
          "new_line_content": "  space_->RefillFreeList();",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": "RefillFreeList",
          "new_api": "TryAllocationFromFreeListMain",
          "old_text": "space_->RefillFreeList()",
          "new_text": "TryAllocationFromFreeListMain(size_in_bytes, origin)",
          "old_line_content": "  space_->RefillFreeList();",
          "new_line_content": "  return TryAllocationFromFreeListMain(size_in_bytes, origin);",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "Page::FromAllocationAreaAddress(top)",
          "new_api": "IsBlackAllocationEnabled",
          "old_text": "Page::FromAllocationAreaAddress(top)",
          "new_text": "allocator_->IsBlackAllocationEnabled()",
          "old_line_content": "    Page* page = Page::FromAllocationAreaAddress(top);",
          "new_line_content": "    if (allocator_->IsBlackAllocationEnabled()) {",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": "IsBlackAllocationEnabled",
          "new_api": "CreateBlackArea",
          "old_text": "allocator_->IsBlackAllocationEnabled()",
          "new_text": "page->CreateBlackArea(top, limit)",
          "old_line_content": "    if (allocator_->IsBlackAllocationEnabled()) {",
          "new_line_content": "      page->CreateBlackArea(top, limit);",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "limit",
          "new_api": "top",
          "old_text": "allocator_->limit()",
          "new_text": "allocator_->top()",
          "old_line_content": "  Address old_limit = allocator_->limit();",
          "new_line_content": "  DCHECK_LE(allocator_->top(), new_limit);",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "top",
          "new_api": "DCHECK_GE",
          "old_text": "allocator_->top()",
          "new_text": "DCHECK_GE(old_limit, new_limit)",
          "old_line_content": "  DCHECK_LE(allocator_->top(), new_limit);",
          "new_line_content": "  DCHECK_GE(old_limit, new_limit);",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": "identity",
          "new_api": "emplace",
          "old_text": "allocator_->identity()",
          "new_text": "optional_scope.emplace(\"DecreaseLimit writes to the page header.\")",
          "old_line_content": "    if (allocator_->identity() == CODE_SPACE) {",
          "new_line_content": "      optional_scope.emplace(\"DecreaseLimit writes to the page header.\");",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": "original_limit_relaxed",
          "new_api": "supports_extending_lab",
          "old_text": "allocator_->original_limit_relaxed()",
          "new_text": "allocator_->supports_extending_lab()",
          "old_line_content": "    Address old_max_limit = allocator_->original_limit_relaxed();",
          "new_line_content": "    if (!allocator_->supports_extending_lab()) {",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": "supports_extending_lab",
          "new_api": "DCHECK_EQ",
          "old_text": "allocator_->supports_extending_lab()",
          "new_text": "DCHECK_EQ(old_max_limit, old_limit)",
          "old_line_content": "    if (!allocator_->supports_extending_lab()) {",
          "new_line_content": "      DCHECK_EQ(old_max_limit, old_limit);",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "DCHECK_EQ",
          "new_api": "top",
          "old_text": "DCHECK_EQ(old_max_limit, old_limit)",
          "new_text": "allocator_->top()",
          "old_line_content": "      DCHECK_EQ(old_max_limit, old_limit);",
          "new_line_content": "      allocator_->ResetLab(allocator_->top(), new_limit, new_limit);",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": "top",
          "new_api": "Free",
          "old_text": "allocator_->top()",
          "new_text": "space_->Free(new_limit, old_max_limit - new_limit,\n                   SpaceAccountingMode::kSpaceAccounted)",
          "old_line_content": "      allocator_->ResetLab(allocator_->top(), new_limit, new_limit);",
          "new_line_content": "      space_->Free(new_limit, old_max_limit - new_limit,",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": "ExtendLAB",
          "new_api": "CreateFillerObjectAt",
          "old_text": "allocator_->ExtendLAB(new_limit)",
          "new_text": "space_heap()->CreateFillerObjectAt(\n          new_limit, static_cast<int>(old_max_limit - new_limit))",
          "old_line_content": "      allocator_->ExtendLAB(new_limit);",
          "new_line_content": "      space_heap()->CreateFillerObjectAt(",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": "CreateFillerObjectAt",
          "new_api": "static_cast<int>(old_max_limit - new_limit)",
          "old_text": "space_heap()->CreateFillerObjectAt(\n          new_limit, static_cast<int>(old_max_limit - new_limit))",
          "new_text": "static_cast<int>(old_max_limit - new_limit)",
          "old_line_content": "      space_heap()->CreateFillerObjectAt(",
          "new_line_content": "          new_limit, static_cast<int>(old_max_limit - new_limit));",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": "IsBlackAllocationEnabled",
          "new_api": "DestroyBlackArea",
          "old_text": "allocator_->IsBlackAllocationEnabled()",
          "new_text": "Page::FromAllocationAreaAddress(new_limit)->DestroyBlackArea(new_limit,\n                                                                   old_limit)",
          "old_line_content": "    if (allocator_->IsBlackAllocationEnabled()) {",
          "new_line_content": "      Page::FromAllocationAreaAddress(new_limit)->DestroyBlackArea(new_limit,",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": "IsAligned",
          "new_api": "limit",
          "old_text": "IsAligned(size_in_bytes, kTaggedSize)",
          "new_text": "allocator_->limit()",
          "old_line_content": "  DCHECK(IsAligned(size_in_bytes, kTaggedSize));",
          "new_line_content": "  DCHECK_LE(allocator_->top(), allocator_->limit());",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": "limit",
          "new_api": "top",
          "old_text": "allocator_->limit()",
          "new_text": "allocator_->top()",
          "old_line_content": "  if (allocator_->top() != allocator_->limit()) {",
          "new_line_content": "    DCHECK_EQ(Page::FromAddress(allocator_->top()),",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "top",
          "new_api": "limit",
          "old_text": "allocator_->top()",
          "new_text": "allocator_->limit()",
          "old_line_content": "    DCHECK_EQ(Page::FromAddress(allocator_->top()),",
          "new_line_content": "              Page::FromAddress(allocator_->limit() - 1));",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "Allocate",
          "new_api": "is_null",
          "old_text": "space_->free_list_->Allocate(size_in_bytes, &new_node_size, origin)",
          "new_text": "new_node.is_null()",
          "old_line_content": "      space_->free_list_->Allocate(size_in_bytes, &new_node_size, origin);",
          "new_line_content": "  if (new_node.is_null()) return false;",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": "is_null",
          "new_api": "DCHECK_GE",
          "old_text": "new_node.is_null()",
          "new_text": "DCHECK_GE(new_node_size, size_in_bytes)",
          "old_line_content": "  if (new_node.is_null()) return false;",
          "new_line_content": "  DCHECK_GE(new_node_size, size_in_bytes);",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": "Page::FromHeapObject(new_node)",
          "new_api": "IncreaseAllocatedBytes",
          "old_text": "Page::FromHeapObject(new_node)",
          "new_text": "space_->IncreaseAllocatedBytes(new_node_size, page)",
          "old_line_content": "  Page* page = Page::FromHeapObject(new_node);",
          "new_line_content": "  space_->IncreaseAllocatedBytes(new_node_size, page);",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": "start",
          "new_api": "top",
          "old_text": "allocator_->allocation_info().start()",
          "new_text": "allocator_->allocation_info().top()",
          "old_line_content": "  DCHECK_EQ(allocator_->allocation_info().start(),",
          "new_line_content": "            allocator_->allocation_info().top());",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "top",
          "new_api": "address",
          "old_text": "allocator_->allocation_info().top()",
          "new_text": "new_node.address()",
          "old_line_content": "            allocator_->allocation_info().top());",
          "new_line_content": "  Address start = new_node.address();",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": "address",
          "new_api": "ComputeLimit",
          "old_text": "new_node.address()",
          "new_text": "allocator_->ComputeLimit(start, end, size_in_bytes)",
          "old_line_content": "  Address end = new_node.address() + new_node_size;",
          "new_line_content": "  Address limit = allocator_->ComputeLimit(start, end, size_in_bytes);",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "ComputeLimit",
          "new_api": "DCHECK_LE",
          "old_text": "allocator_->ComputeLimit(start, end, size_in_bytes)",
          "new_text": "DCHECK_LE(limit, end)",
          "old_line_content": "  Address limit = allocator_->ComputeLimit(start, end, size_in_bytes);",
          "new_line_content": "  DCHECK_LE(limit, end);",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": "supports_extending_lab",
          "new_api": "Free",
          "old_text": "allocator_->supports_extending_lab()",
          "new_text": "space_->Free(limit, end - limit, SpaceAccountingMode::kSpaceAccounted)",
          "old_line_content": "    if (!allocator_->supports_extending_lab()) {",
          "new_line_content": "      space_->Free(limit, end - limit, SpaceAccountingMode::kSpaceAccounted);",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": "is_main_thread",
          "new_api": "static_cast<int>(end - limit)",
          "old_text": "allocator_->is_main_thread()",
          "new_text": "static_cast<int>(end - limit)",
          "old_line_content": "      DCHECK(allocator_->is_main_thread());",
          "new_line_content": "      space_heap()->CreateFillerObjectAt(limit, static_cast<int>(end - limit));",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": "SetLinearAllocationArea",
          "new_api": "AddRangeToActiveSystemPages",
          "old_text": "SetLinearAllocationArea(start, limit, end)",
          "new_text": "space_->AddRangeToActiveSystemPages(page, start, limit)",
          "old_line_content": "  SetLinearAllocationArea(start, limit, end);",
          "new_line_content": "  space_->AddRangeToActiveSystemPages(page, start, limit);",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": "supports_extending_lab",
          "new_api": "top",
          "old_text": "allocator_->supports_extending_lab()",
          "new_text": "allocator_->top()",
          "old_line_content": "  if (!allocator_->supports_extending_lab()) return false;",
          "new_line_content": "  Address current_top = allocator_->top();",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": "limit",
          "new_api": "original_limit_relaxed",
          "old_text": "allocator_->limit()",
          "new_text": "allocator_->original_limit_relaxed()",
          "old_line_content": "  Address current_limit = allocator_->limit();",
          "new_line_content": "  Address max_limit = allocator_->original_limit_relaxed();",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "ComputeLimit",
          "new_api": "ExtendLAB",
          "old_text": "allocator_->ComputeLimit(current_top, max_limit, size_in_bytes)",
          "new_text": "allocator_->ExtendLAB(new_limit)",
          "old_line_content": "      allocator_->ComputeLimit(current_top, max_limit, size_in_bytes);",
          "new_line_content": "  allocator_->ExtendLAB(new_limit);",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": "ExtendLAB",
          "new_api": "is_main_thread",
          "old_text": "allocator_->ExtendLAB(new_limit)",
          "new_text": "allocator_->is_main_thread()",
          "old_line_content": "  allocator_->ExtendLAB(new_limit);",
          "new_line_content": "  DCHECK(allocator_->is_main_thread());",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": "is_main_thread",
          "new_api": "CreateFillerObjectAt",
          "old_text": "allocator_->is_main_thread()",
          "new_text": "space_heap()->CreateFillerObjectAt(new_limit,\n                                     static_cast<int>(max_limit - new_limit))",
          "old_line_content": "  DCHECK(allocator_->is_main_thread());",
          "new_line_content": "  space_heap()->CreateFillerObjectAt(new_limit,",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": "CreateFillerObjectAt",
          "new_api": "static_cast<int>(max_limit - new_limit)",
          "old_text": "space_heap()->CreateFillerObjectAt(new_limit,\n                                     static_cast<int>(max_limit - new_limit))",
          "new_text": "static_cast<int>(max_limit - new_limit)",
          "old_line_content": "  space_heap()->CreateFillerObjectAt(new_limit,",
          "new_line_content": "                                     static_cast<int>(max_limit - new_limit));",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": "static_cast<int>(max_limit - new_limit)",
          "new_api": "Page::FromAddress(current_top)",
          "old_text": "static_cast<int>(max_limit - new_limit)",
          "new_text": "Page::FromAddress(current_top)",
          "old_line_content": "                                     static_cast<int>(max_limit - new_limit));",
          "new_line_content": "  Page* page = Page::FromAddress(current_top);",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": "identity",
          "new_api": "AddRangeToActiveSystemPages",
          "old_text": "allocator_->identity()",
          "new_text": "space_->AddRangeToActiveSystemPages(page, current_limit, new_limit)",
          "old_line_content": "  DCHECK_EQ(NEW_SPACE, allocator_->identity());",
          "new_line_content": "  space_->AddRangeToActiveSystemPages(page, current_limit, new_limit);",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "mutex",
          "new_api": "FreeLinearAllocationAreaUnsynchronized",
          "old_text": "space_->mutex()",
          "new_text": "FreeLinearAllocationAreaUnsynchronized()",
          "old_line_content": "  base::MutexGuard guard(space_->mutex());",
          "new_line_content": "  FreeLinearAllocationAreaUnsynchronized();",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": "top",
          "new_api": "limit",
          "old_text": "allocator_->top()",
          "new_text": "allocator_->limit()",
          "old_line_content": "  Address current_top = allocator_->top();",
          "new_line_content": "  Address current_limit = allocator_->limit();",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": "supports_extending_lab",
          "new_api": "original_limit_relaxed",
          "old_text": "allocator_->supports_extending_lab()",
          "new_text": "allocator_->original_limit_relaxed()",
          "old_line_content": "  Address current_max_limit = allocator_->supports_extending_lab()",
          "new_line_content": "                                  ? allocator_->original_limit_relaxed()",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": "IsBlackAllocationEnabled",
          "new_api": "DestroyBlackArea",
          "old_text": "allocator_->IsBlackAllocationEnabled()",
          "new_text": "Page::FromAddress(current_top)\n        ->DestroyBlackArea(current_top, current_limit)",
          "old_line_content": "  if (current_top != current_limit && allocator_->IsBlackAllocationEnabled()) {",
          "new_line_content": "    Page::FromAddress(current_top)",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": "ResetLab",
          "new_api": "DCHECK_GE",
          "old_text": "allocator_->ResetLab(kNullAddress, kNullAddress, kNullAddress)",
          "new_text": "DCHECK_GE(current_limit, current_top)",
          "old_line_content": "  allocator_->ResetLab(kNullAddress, kNullAddress, kNullAddress);",
          "new_line_content": "  DCHECK_GE(current_limit, current_top);",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "marking_state",
          "new_api": "HeapObject::FromAddress(current_top)",
          "old_text": "space_heap()->marking_state()->IsUnmarked(\n                     HeapObject::FromAddress(current_top))",
          "new_text": "HeapObject::FromAddress(current_top)",
          "old_line_content": "                 space_heap()->marking_state()->IsUnmarked(",
          "new_line_content": "                     HeapObject::FromAddress(current_top)));",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": "HeapObject::FromAddress(current_top)",
          "new_api": "Free",
          "old_text": "HeapObject::FromAddress(current_top)",
          "new_text": "space_->Free(current_top, current_max_limit - current_top,\n               SpaceAccountingMode::kSpaceAccounted)",
          "old_line_content": "                     HeapObject::FromAddress(current_top)));",
          "new_line_content": "  space_->Free(current_top, current_max_limit - current_top,",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 640,
          "old_api": null,
          "new_api": "sweeper",
          "old_text": null,
          "new_text": "space_heap()->sweeper()->GetTracingScope(\n      allocator_->identity(), is_main_thread)",
          "old_line_content": "      is_main_thread ? ThreadKind::kMain : ThreadKind::kBackground;",
          "new_line_content": "  const auto sweeping_scope_id = space_heap()->sweeper()->GetTracingScope(",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": null,
          "new_api": "original_limit_relaxed",
          "old_text": null,
          "new_text": "allocator_->original_limit_relaxed()",
          "old_line_content": "    PagedSpace::ConcurrentAllocationMutex guard(space_);",
          "new_line_content": "    Address old_max_limit = allocator_->original_limit_relaxed();",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": null,
          "new_api": "sweeping_in_progress",
          "old_text": null,
          "new_text": "space_heap()->sweeping_in_progress()",
          "old_line_content": "  // Sweeping is still in progress.",
          "new_line_content": "  if (space_heap()->sweeping_in_progress()) {",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": null,
          "new_api": "ResetLab",
          "old_text": null,
          "new_text": "allocator_->ResetLab(kNullAddress, kNullAddress, kNullAddress)",
          "old_line_content": "",
          "new_line_content": "  allocator_->ResetLab(kNullAddress, kNullAddress, kNullAddress);",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": null,
          "new_api": "sweeper",
          "old_text": null,
          "new_text": "space_heap()->sweeper()->ShouldRefillFreelistForSpace(\n            allocator_->identity())",
          "old_line_content": "    // may have freed some objects in the meantime.",
          "new_line_content": "    if (space_heap()->sweeper()->ShouldRefillFreelistForSpace(",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": null,
          "new_api": "marking_state",
          "old_text": null,
          "new_text": "DCHECK_IMPLIES(current_limit - current_top >= 2 * kTaggedSize,\n                 space_heap()->marking_state()->IsUnmarked(\n                     HeapObject::FromAddress(current_top)))",
          "old_line_content": "",
          "new_line_content": "  DCHECK_IMPLIES(current_limit - current_top >= 2 * kTaggedSize,",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "TRACE_GC_EPOCH_WITH_FLOW(\n            isolate_heap()->tracer(), sweeping_scope_id, sweeping_scope_kind,\n            isolate_heap()->sweeper()->GetTraceIdForFlowEvent(\n                sweeping_scope_id),\n            TRACE_EVENT_FLAG_FLOW_IN | TRACE_EVENT_FLAG_FLOW_OUT)",
          "old_line_content": "      {",
          "new_line_content": "        TRACE_GC_EPOCH_WITH_FLOW(",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": null,
          "new_api": "ExtendLAB",
          "old_text": null,
          "new_text": "allocator_->ExtendLAB(new_limit)",
          "old_line_content": "    } else {",
          "new_line_content": "      allocator_->ExtendLAB(new_limit);",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": null,
          "new_api": "IsBlackAllocationEnabled",
          "old_text": null,
          "new_text": "allocator_->IsBlackAllocationEnabled()",
          "old_line_content": "    }",
          "new_line_content": "    if (allocator_->IsBlackAllocationEnabled()) {",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": null,
          "new_api": "RefillFreeList",
          "old_text": null,
          "new_text": "space_->RefillFreeList()",
          "old_line_content": "            TRACE_EVENT_FLAG_FLOW_IN | TRACE_EVENT_FLAG_FLOW_OUT);",
          "new_line_content": "        space_->RefillFreeList();",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": null,
          "new_api": "AdvanceAllocationObservers",
          "old_text": null,
          "new_text": "allocator_->AdvanceAllocationObservers()",
          "old_line_content": "",
          "new_line_content": "  allocator_->AdvanceAllocationObservers();",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": null,
          "new_api": "static_cast<size_t>(size_in_bytes)",
          "old_text": null,
          "new_text": "static_cast<size_t>(size_in_bytes)",
          "old_line_content": "      // Retry the free list allocation.",
          "new_line_content": "      if (TryAllocationFromFreeListMain(static_cast<size_t>(size_in_bytes),",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": null,
          "new_api": "ContributeToSweepingMain",
          "old_text": null,
          "new_text": "ContributeToSweepingMain(size_in_bytes, kMaxPagesToSweep, size_in_bytes,\n                                 origin, sweeping_scope_id,\n                                 sweeping_scope_kind)",
          "old_line_content": "",
          "new_line_content": "    if (ContributeToSweepingMain(size_in_bytes, kMaxPagesToSweep, size_in_bytes,",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": null,
          "new_api": "IsAligned",
          "old_text": null,
          "new_text": "IsAligned(size_in_bytes, kTaggedSize)",
          "old_line_content": "  PagedSpace::ConcurrentAllocationMutex guard(space_);",
          "new_line_content": "  DCHECK(IsAligned(size_in_bytes, kTaggedSize));",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": null,
          "new_api": "limit",
          "old_text": null,
          "new_text": "allocator_->limit()",
          "old_line_content": "#ifdef DEBUG",
          "new_line_content": "  if (allocator_->top() != allocator_->limit()) {",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": null,
          "new_api": "is_compaction_space",
          "old_text": null,
          "new_text": "space_->is_compaction_space()",
          "old_line_content": "",
          "new_line_content": "  if (space_->is_compaction_space()) {",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "allocator_->top()",
          "old_line_content": "  // Don't free list allocate if there is linear space available.",
          "new_line_content": "  DCHECK_LT(static_cast<size_t>(allocator_->limit() - allocator_->top()),",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "allocator_->identity()",
          "old_line_content": "    PagedSpaceBase* main_space =",
          "new_line_content": "        space_heap()->paged_space(allocator_->identity());",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": null,
          "new_api": "AddPage",
          "old_text": null,
          "new_text": "space_->AddPage(page)",
          "old_line_content": "    if (page != nullptr) {",
          "new_line_content": "      space_->AddPage(page);",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": null,
          "new_api": "FreeLinearAllocationAreaUnsynchronized",
          "old_text": null,
          "new_text": "FreeLinearAllocationAreaUnsynchronized()",
          "old_line_content": "  // if it is big enough.",
          "new_line_content": "  FreeLinearAllocationAreaUnsynchronized();",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": null,
          "new_api": "Allocate",
          "old_text": null,
          "new_text": "space_->free_list_->Allocate(size_in_bytes, &new_node_size, origin)",
          "old_line_content": "  Tagged<FreeSpace> new_node =",
          "new_line_content": "      space_->free_list_->Allocate(size_in_bytes, &new_node_size, origin);",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "allocator_->identity()",
          "old_line_content": "",
          "new_line_content": "  if (allocator_->identity() != NEW_SPACE &&",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": null,
          "new_api": "MarkCompactCollector::IsOnEvacuationCandidate(new_node)",
          "old_text": null,
          "new_text": "MarkCompactCollector::IsOnEvacuationCandidate(new_node)",
          "old_line_content": "  // candidate.",
          "new_line_content": "  DCHECK(!MarkCompactCollector::IsOnEvacuationCandidate(new_node));",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": null,
          "new_api": "Page::FromHeapObject(new_node)",
          "old_text": null,
          "new_text": "Page::FromHeapObject(new_node)",
          "old_line_content": "  // a little of this again immediately - see below.",
          "new_line_content": "  Page* page = Page::FromHeapObject(new_node);",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": null,
          "new_api": "ContributeToSweepingMain",
          "old_text": null,
          "new_text": "ContributeToSweepingMain(0, 0, size_in_bytes, origin, sweeping_scope_id,\n                               sweeping_scope_kind)",
          "old_line_content": "  // Try sweeping all pages.",
          "new_line_content": "  if (ContributeToSweepingMain(0, 0, size_in_bytes, origin, sweeping_scope_id,",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": null,
          "new_api": "start",
          "old_text": null,
          "new_text": "allocator_->allocation_info().start()",
          "old_line_content": "",
          "new_line_content": "  DCHECK_EQ(allocator_->allocation_info().start(),",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": null,
          "new_api": "in_gc",
          "old_text": null,
          "new_text": "allocator_->in_gc()",
          "old_line_content": "",
          "new_line_content": "  if (allocator_->identity() != NEW_SPACE && allocator_->in_gc() &&",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": null,
          "new_api": "TryExpandAndAllocate",
          "old_text": null,
          "new_text": "TryExpandAndAllocate(size_in_bytes, origin)",
          "old_line_content": "    // GC and give it a chance to increase the heap limit.",
          "new_line_content": "    if (TryExpandAndAllocate(size_in_bytes, origin)) {",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": null,
          "new_api": "supports_extending_lab",
          "old_text": null,
          "new_text": "allocator_->supports_extending_lab()",
          "old_line_content": "  if (limit != end) {",
          "new_line_content": "    if (!allocator_->supports_extending_lab()) {",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": null,
          "new_api": "is_main_thread",
          "old_text": null,
          "new_text": "allocator_->is_main_thread()",
          "old_line_content": "    } else {",
          "new_line_content": "      DCHECK(allocator_->is_main_thread());",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": null,
          "new_api": "SetLinearAllocationArea",
          "old_text": null,
          "new_text": "SetLinearAllocationArea(start, limit, end)",
          "old_line_content": "  }",
          "new_line_content": "  SetLinearAllocationArea(start, limit, end);",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": null,
          "new_api": "local_heap",
          "old_text": null,
          "new_text": "allocator_->local_heap()",
          "old_line_content": "  // list entries before this thread gets a chance.",
          "new_line_content": "  while (space_->TryExpand(allocator_->local_heap(), origin)) {",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": null,
          "new_api": "supports_extending_lab",
          "old_text": null,
          "new_text": "allocator_->supports_extending_lab()",
          "old_line_content": "bool PagedSpaceAllocatorPolicy::TryExtendLAB(int size_in_bytes) {",
          "new_line_content": "  if (!allocator_->supports_extending_lab()) return false;",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": null,
          "new_api": "limit",
          "old_text": null,
          "new_text": "allocator_->limit()",
          "old_line_content": "  if (current_top == kNullAddress) return false;",
          "new_line_content": "  Address current_limit = allocator_->limit();",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "allocator_->identity()",
          "old_line_content": "    ThreadKind sweeping_scope_kind) {",
          "new_line_content": "  if (!space_heap()->sweeping_in_progress_for_space(allocator_->identity()))",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": null,
          "new_api": "AdvanceAllocationObservers",
          "old_text": null,
          "new_text": "allocator_->AdvanceAllocationObservers()",
          "old_line_content": "  }",
          "new_line_content": "  allocator_->AdvanceAllocationObservers();",
          "content_same": false
        },
        {
          "line": 728,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "allocator_->identity()",
          "old_line_content": "    return false;",
          "new_line_content": "  if (space_heap()->sweeper()->IsSweepingDoneForSpace(allocator_->identity()))",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": null,
          "new_api": "ComputeLimit",
          "old_text": null,
          "new_text": "allocator_->ComputeLimit(current_top, max_limit, size_in_bytes)",
          "old_line_content": "  Address new_limit =",
          "new_line_content": "      allocator_->ComputeLimit(current_top, max_limit, size_in_bytes);",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "TRACE_GC_EPOCH_WITH_FLOW(\n      isolate_heap()->tracer(), sweeping_scope_id, sweeping_scope_kind,\n      isolate_heap()->sweeper()->GetTraceIdForFlowEvent(sweeping_scope_id),\n      TRACE_EVENT_FLAG_FLOW_IN | TRACE_EVENT_FLAG_FLOW_OUT)",
          "old_line_content": "",
          "new_line_content": "  TRACE_GC_EPOCH_WITH_FLOW(",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": null,
          "new_api": "StartIncrementalMarkingIfAllocationLimitIsReached",
          "old_text": null,
          "new_text": "space_heap()->StartIncrementalMarkingIfAllocationLimitIsReached(\n        allocator_->local_heap(), space_heap()->GCFlagsForIncrementalMarking(),\n        kGCCallbackScheduleIdleGarbageCollection)",
          "old_line_content": "    // running.",
          "new_line_content": "    space_heap()->StartIncrementalMarkingIfAllocationLimitIsReached(",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "allocator_->identity()",
          "old_line_content": "  }",
          "new_line_content": "  if (allocator_->identity() == NEW_SPACE &&",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "allocator_->identity()",
          "old_line_content": "  // black allocation.",
          "new_line_content": "  DCHECK_EQ(NEW_SPACE, allocator_->identity());",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": null,
          "new_api": "in_gc_for_space",
          "old_text": null,
          "new_text": "allocator_->in_gc_for_space()",
          "old_line_content": "  Sweeper::SweepingMode sweeping_mode =",
          "new_line_content": "      allocator_->in_gc_for_space() ? Sweeper::SweepingMode::kEagerDuringGC",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": null,
          "new_api": "sweeper",
          "old_text": null,
          "new_text": "space_heap()->sweeper()->ParallelSweepSpace(\n      allocator_->identity(), sweeping_mode, required_freed_bytes, max_pages)",
          "old_line_content": "",
          "new_line_content": "  space_heap()->sweeper()->ParallelSweepSpace(",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": null,
          "new_api": "IsLabValid",
          "old_text": null,
          "new_text": "allocator_->IsLabValid()",
          "old_line_content": "void PagedSpaceAllocatorPolicy::FreeLinearAllocationArea() {",
          "new_line_content": "  if (!allocator_->IsLabValid()) return;",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": null,
          "new_api": "Heap::GetMaximumFillToAlign(alignment)",
          "old_text": null,
          "new_text": "Heap::GetMaximumFillToAlign(alignment)",
          "old_line_content": "  // allocated, so assume the worst case.",
          "new_line_content": "  size_in_bytes += Heap::GetMaximumFillToAlign(alignment);",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": null,
          "new_api": "mutex",
          "old_text": null,
          "new_text": "space_->mutex()",
          "old_line_content": "",
          "new_line_content": "  base::MutexGuard guard(space_->mutex());",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": null,
          "new_api": "RefillLabMain",
          "old_text": null,
          "new_text": "RefillLabMain(size_in_bytes, origin)",
          "old_line_content": "  }",
          "new_line_content": "  return RefillLabMain(size_in_bytes, origin);",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": null,
          "new_api": "ResetLab",
          "old_text": null,
          "new_text": "allocator_->ResetLab(top, limit, end)",
          "old_line_content": "                                                        Address end) {",
          "new_line_content": "  allocator_->ResetLab(top, limit, end);",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": null,
          "new_api": "IsLabValid",
          "old_text": null,
          "new_text": "allocator_->IsLabValid()",
          "old_line_content": "void PagedSpaceAllocatorPolicy::FreeLinearAllocationAreaUnsynchronized() {",
          "new_line_content": "  if (!allocator_->IsLabValid()) return;",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": null,
          "new_api": "Page::FromAllocationAreaAddress(top)",
          "old_text": null,
          "new_text": "Page::FromAllocationAreaAddress(top)",
          "old_line_content": "  if (top != kNullAddress && top != limit) {",
          "new_line_content": "    Page* page = Page::FromAllocationAreaAddress(top);",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "allocator_->Verify()",
          "old_line_content": "#if DEBUG",
          "new_line_content": "  allocator_->Verify();",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": null,
          "new_api": "supports_extending_lab",
          "old_text": null,
          "new_text": "allocator_->supports_extending_lab()",
          "old_line_content": "",
          "new_line_content": "  Address current_max_limit = allocator_->supports_extending_lab()",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": null,
          "new_api": "DCHECK_GE",
          "old_text": null,
          "new_text": "DCHECK_GE(size_in_bytes, 0)",
          "old_line_content": "  // Allocation in this space has failed.",
          "new_line_content": "  DCHECK_GE(size_in_bytes, 0);",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "allocator_->top()",
          "old_line_content": "",
          "new_line_content": "  Address current_top = allocator_->top();",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": null,
          "new_api": "TryExtendLAB",
          "old_text": null,
          "new_text": "TryExtendLAB(size_in_bytes)",
          "old_line_content": "",
          "new_line_content": "  if (TryExtendLAB(size_in_bytes)) return true;",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "",
          "new_line_content": "  static constexpr int kMaxPagesToSweep = 1;",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "limit",
          "old_text": null,
          "new_text": "allocator_->limit()",
          "old_line_content": "void PagedSpaceAllocatorPolicy::DecreaseLimit(Address new_limit) {",
          "new_line_content": "  Address old_limit = allocator_->limit();",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": null,
          "new_api": "TryAllocationFromFreeListMain",
          "old_text": null,
          "new_text": "TryAllocationFromFreeListMain(size_in_bytes, origin)",
          "old_line_content": "",
          "new_line_content": "  if (TryAllocationFromFreeListMain(size_in_bytes, origin)) return true;",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": null,
          "new_api": "supports_extending_lab",
          "old_text": null,
          "new_text": "allocator_->supports_extending_lab()",
          "old_line_content": "                                  : current_limit;",
          "new_line_content": "  DCHECK_IMPLIES(!allocator_->supports_extending_lab(),",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": null,
          "new_api": "is_main_thread",
          "old_text": null,
          "new_text": "allocator_->is_main_thread()",
          "old_line_content": "  const bool is_main_thread =",
          "new_line_content": "      allocator_->is_main_thread() ||",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "allocator_->identity()",
          "old_line_content": "    base::Optional<CodePageHeaderModificationScope> optional_scope;",
          "new_line_content": "    if (allocator_->identity() == CODE_SPACE) {",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": null,
          "new_api": "IsBlackAllocationEnabled",
          "old_text": null,
          "new_text": "allocator_->IsBlackAllocationEnabled()",
          "old_line_content": "",
          "new_line_content": "  if (current_top != current_limit && allocator_->IsBlackAllocationEnabled()) {",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 897,
          "old_api": "DestroyBlackArea",
          "new_api": null,
          "old_text": "Page::FromAddress(current_top)\n        ->DestroyBlackArea(current_top, current_limit)",
          "new_text": null,
          "old_line_content": "    Page::FromAddress(current_top)",
          "new_line_content": "        ->DestroyBlackArea(current_top, current_limit);",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "identity",
          "new_api": null,
          "old_text": "allocator_->identity()",
          "new_text": null,
          "old_line_content": "      allocator_->identity(), is_main_thread);",
          "new_line_content": "  // Sweeping is still in progress.",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "supports_extending_lab",
          "new_api": null,
          "old_text": "allocator_->supports_extending_lab()",
          "new_text": null,
          "old_line_content": "  DCHECK_IMPLIES(!allocator_->supports_extending_lab(),",
          "new_line_content": "                 current_max_limit == current_limit);",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": "sweeping_in_progress",
          "new_api": null,
          "old_text": "space_heap()->sweeping_in_progress()",
          "new_text": null,
          "old_line_content": "  if (space_heap()->sweeping_in_progress()) {",
          "new_line_content": "    // First try to refill the free-list, concurrent sweeper threads",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": "DCHECK_GE",
          "new_api": null,
          "old_text": "DCHECK_GE(current_limit, current_top)",
          "new_text": null,
          "old_line_content": "  DCHECK_GE(current_limit, current_top);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "Free",
          "new_api": null,
          "old_text": "space_->Free(new_limit, old_max_limit - new_limit,\n                   SpaceAccountingMode::kSpaceAccounted)",
          "new_text": null,
          "old_line_content": "      space_->Free(new_limit, old_max_limit - new_limit,",
          "new_line_content": "                   SpaceAccountingMode::kSpaceAccounted);",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "identity",
          "new_api": null,
          "old_text": "allocator_->identity()",
          "new_text": null,
          "old_line_content": "            allocator_->identity())) {",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "Free",
          "new_api": null,
          "old_text": "space_->Free(current_top, current_max_limit - current_top,\n               SpaceAccountingMode::kSpaceAccounted)",
          "new_text": null,
          "old_line_content": "  space_->Free(current_top, current_max_limit - current_top,",
          "new_line_content": "               SpaceAccountingMode::kSpaceAccounted);",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": "sweeper",
          "new_api": null,
          "old_text": "isolate_heap()->sweeper()->GetTraceIdForFlowEvent(\n                sweeping_scope_id)",
          "new_text": null,
          "old_line_content": "            isolate_heap()->sweeper()->GetTraceIdForFlowEvent(",
          "new_line_content": "                sweeping_scope_id),",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": "static_cast<int>(old_max_limit - new_limit)",
          "new_api": null,
          "old_text": "static_cast<int>(old_max_limit - new_limit)",
          "new_text": null,
          "old_line_content": "          new_limit, static_cast<int>(old_max_limit - new_limit));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": "RefillFreeList",
          "new_api": null,
          "old_text": "space_->RefillFreeList()",
          "new_text": null,
          "old_line_content": "        space_->RefillFreeList();",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": "DestroyBlackArea",
          "new_api": null,
          "old_text": "Page::FromAllocationAreaAddress(new_limit)->DestroyBlackArea(new_limit,\n                                                                   old_limit)",
          "new_text": null,
          "old_line_content": "      Page::FromAllocationAreaAddress(new_limit)->DestroyBlackArea(new_limit,",
          "new_line_content": "                                                                   old_limit);",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": "AdvanceAllocationObservers",
          "new_api": null,
          "old_text": "allocator_->AdvanceAllocationObservers()",
          "new_text": null,
          "old_line_content": "  allocator_->AdvanceAllocationObservers();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": "static_cast<size_t>(size_in_bytes)",
          "new_api": null,
          "old_text": "static_cast<size_t>(size_in_bytes)",
          "new_text": null,
          "old_line_content": "      if (TryAllocationFromFreeListMain(static_cast<size_t>(size_in_bytes),",
          "new_line_content": "                                        origin))",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": "ContributeToSweepingMain",
          "new_api": null,
          "old_text": "ContributeToSweepingMain(size_in_bytes, kMaxPagesToSweep, size_in_bytes,\n                                 origin, sweeping_scope_id,\n                                 sweeping_scope_kind)",
          "new_text": null,
          "old_line_content": "    if (ContributeToSweepingMain(size_in_bytes, kMaxPagesToSweep, size_in_bytes,",
          "new_line_content": "                                 origin, sweeping_scope_id,",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": "limit",
          "new_api": null,
          "old_text": "allocator_->limit()",
          "new_text": null,
          "old_line_content": "  DCHECK_LE(allocator_->top(), allocator_->limit());",
          "new_line_content": "#ifdef DEBUG",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "limit",
          "new_api": null,
          "old_text": "allocator_->limit()",
          "new_text": null,
          "old_line_content": "              Page::FromAddress(allocator_->limit() - 1));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": "identity",
          "new_api": null,
          "old_text": "allocator_->identity()",
          "new_text": null,
          "old_line_content": "    DCHECK_NE(NEW_SPACE, allocator_->identity());",
          "new_line_content": "    // If there is not enough memory in the compaction space left, try to steal",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "top",
          "new_api": null,
          "old_text": "allocator_->top()",
          "new_text": null,
          "old_line_content": "  DCHECK_LT(static_cast<size_t>(allocator_->limit() - allocator_->top()),",
          "new_line_content": "            size_in_bytes);",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": "RemovePageSafe",
          "new_api": null,
          "old_text": "main_space->RemovePageSafe(size_in_bytes)",
          "new_text": null,
          "old_line_content": "    Page* page = main_space->RemovePageSafe(size_in_bytes);",
          "new_line_content": "    if (page != nullptr) {",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "static_cast<size_t>(size_in_bytes)",
          "new_api": null,
          "old_text": "static_cast<size_t>(size_in_bytes)",
          "new_text": null,
          "old_line_content": "      if (TryAllocationFromFreeListMain(static_cast<size_t>(size_in_bytes),",
          "new_line_content": "                                        origin))",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "FreeLinearAllocationAreaUnsynchronized",
          "new_api": null,
          "old_text": "FreeLinearAllocationAreaUnsynchronized()",
          "new_text": null,
          "old_line_content": "  FreeLinearAllocationAreaUnsynchronized();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "DCHECK_GE",
          "new_api": null,
          "old_text": "DCHECK_GE(new_node_size, size_in_bytes)",
          "new_text": null,
          "old_line_content": "  DCHECK_GE(new_node_size, size_in_bytes);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": "static_cast<size_t>(size_in_bytes)",
          "new_api": null,
          "old_text": "static_cast<size_t>(size_in_bytes)",
          "new_text": null,
          "old_line_content": "    if (TryExpandAndAllocate(static_cast<size_t>(size_in_bytes), origin)) {",
          "new_line_content": "      return true;",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": "MarkCompactCollector::IsOnEvacuationCandidate(new_node)",
          "new_api": null,
          "old_text": "MarkCompactCollector::IsOnEvacuationCandidate(new_node)",
          "new_text": null,
          "old_line_content": "  DCHECK(!MarkCompactCollector::IsOnEvacuationCandidate(new_node));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": "ContributeToSweepingMain",
          "new_api": null,
          "old_text": "ContributeToSweepingMain(0, 0, size_in_bytes, origin, sweeping_scope_id,\n                               sweeping_scope_kind)",
          "new_text": null,
          "old_line_content": "  if (ContributeToSweepingMain(0, 0, size_in_bytes, origin, sweeping_scope_id,",
          "new_line_content": "                               sweeping_scope_kind))",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": "IncreaseAllocatedBytes",
          "new_api": null,
          "old_text": "space_->IncreaseAllocatedBytes(new_node_size, page)",
          "new_text": null,
          "old_line_content": "  space_->IncreaseAllocatedBytes(new_node_size, page);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": "force_oom",
          "new_api": null,
          "old_text": "space_heap()->force_oom()",
          "new_text": null,
          "old_line_content": "      !space_heap()->force_oom()) {",
          "new_line_content": "    // Avoid OOM crash in the GC in order to invoke NearHeapLimitCallback after",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": "TryExpandAndAllocate",
          "new_api": null,
          "old_text": "TryExpandAndAllocate(size_in_bytes, origin)",
          "new_text": null,
          "old_line_content": "    if (TryExpandAndAllocate(size_in_bytes, origin)) {",
          "new_line_content": "      return true;",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": "DCHECK_LE",
          "new_api": null,
          "old_text": "DCHECK_LE(size_in_bytes, limit - start)",
          "new_text": null,
          "old_line_content": "  DCHECK_LE(size_in_bytes, limit - start);",
          "new_line_content": "  if (limit != end) {",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": "Free",
          "new_api": null,
          "old_text": "space_->Free(limit, end - limit, SpaceAccountingMode::kSpaceAccounted)",
          "new_text": null,
          "old_line_content": "      space_->Free(limit, end - limit, SpaceAccountingMode::kSpaceAccounted);",
          "new_line_content": "      end = limit;",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": "static_cast<int>(end - limit)",
          "new_api": null,
          "old_text": "static_cast<int>(end - limit)",
          "new_text": null,
          "old_line_content": "      space_heap()->CreateFillerObjectAt(limit, static_cast<int>(end - limit));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "AddRangeToActiveSystemPages",
          "new_api": null,
          "old_text": "space_->AddRangeToActiveSystemPages(page, start, limit)",
          "new_text": null,
          "old_line_content": "  space_->AddRangeToActiveSystemPages(page, start, limit);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": "static_cast<size_t>(size_in_bytes)",
          "new_api": null,
          "old_text": "static_cast<size_t>(size_in_bytes)",
          "new_text": null,
          "old_line_content": "    if (TryAllocationFromFreeListMain(static_cast<size_t>(size_in_bytes),",
          "new_line_content": "                                      origin)) {",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": "top",
          "new_api": null,
          "old_text": "allocator_->top()",
          "new_text": null,
          "old_line_content": "  Address current_top = allocator_->top();",
          "new_line_content": "  if (current_top == kNullAddress) return false;",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": "original_limit_relaxed",
          "new_api": null,
          "old_text": "allocator_->original_limit_relaxed()",
          "new_text": null,
          "old_line_content": "  Address max_limit = allocator_->original_limit_relaxed();",
          "new_line_content": "  if (current_top + size_in_bytes > max_limit) {",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": "identity",
          "new_api": null,
          "old_text": "allocator_->identity()",
          "new_text": null,
          "old_line_content": "  if (!space_heap()->sweeping_in_progress_for_space(allocator_->identity()))",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": "AdvanceAllocationObservers",
          "new_api": null,
          "old_text": "allocator_->AdvanceAllocationObservers()",
          "new_text": null,
          "old_line_content": "  allocator_->AdvanceAllocationObservers();",
          "new_line_content": "  Address new_limit =",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": "ShouldOptimizeForLoadTime",
          "new_api": null,
          "old_text": "space_heap()->ShouldOptimizeForLoadTime()",
          "new_text": null,
          "old_line_content": "                                space_heap()->ShouldOptimizeForLoadTime())) {",
          "new_line_content": "    // Start incremental marking before the actual allocation, this allows the",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "identity",
          "new_api": null,
          "old_text": "allocator_->identity()",
          "new_text": null,
          "old_line_content": "  if (space_heap()->sweeper()->IsSweepingDoneForSpace(allocator_->identity()))",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": "GCFlagsForIncrementalMarking",
          "new_api": null,
          "old_text": "space_heap()->GCFlagsForIncrementalMarking()",
          "new_text": null,
          "old_line_content": "        allocator_->local_heap(), space_heap()->GCFlagsForIncrementalMarking(),",
          "new_line_content": "        kGCCallbackScheduleIdleGarbageCollection);",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": "sweeper",
          "new_api": null,
          "old_text": "isolate_heap()->sweeper()->GetTraceIdForFlowEvent(sweeping_scope_id)",
          "new_text": null,
          "old_line_content": "      isolate_heap()->sweeper()->GetTraceIdForFlowEvent(sweeping_scope_id),",
          "new_line_content": "      TRACE_EVENT_FLAG_FLOW_IN | TRACE_EVENT_FLAG_FLOW_OUT);",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": "Page::FromAddress(current_top)",
          "new_api": null,
          "old_text": "Page::FromAddress(current_top)",
          "new_text": null,
          "old_line_content": "  Page* page = Page::FromAddress(current_top);",
          "new_line_content": "  // No need to create a black allocation area since new space doesn't use",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "in_gc_for_space",
          "new_api": null,
          "old_text": "allocator_->in_gc_for_space()",
          "new_text": null,
          "old_line_content": "      allocator_->in_gc_for_space() ? Sweeper::SweepingMode::kEagerDuringGC",
          "new_line_content": "                                    : Sweeper::SweepingMode::kLazyOrConcurrent;",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": "StartMinorMSIncrementalMarkingIfNeeded",
          "new_api": null,
          "old_text": "space_heap()->StartMinorMSIncrementalMarkingIfNeeded()",
          "new_text": null,
          "old_line_content": "    space_heap()->StartMinorMSIncrementalMarkingIfNeeded();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "AddRangeToActiveSystemPages",
          "new_api": null,
          "old_text": "space_->AddRangeToActiveSystemPages(page, current_limit, new_limit)",
          "new_text": null,
          "old_line_content": "  space_->AddRangeToActiveSystemPages(page, current_limit, new_limit);",
          "new_line_content": "  return true;",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "IsLabValid",
          "new_api": null,
          "old_text": "allocator_->IsLabValid()",
          "new_text": null,
          "old_line_content": "  if (!allocator_->IsLabValid()) return;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": "TryAllocationFromFreeListMain",
          "new_api": null,
          "old_text": "TryAllocationFromFreeListMain(size_in_bytes, origin)",
          "new_text": null,
          "old_line_content": "  return TryAllocationFromFreeListMain(size_in_bytes, origin);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": "limit",
          "new_api": null,
          "old_text": "allocator_->allocation_info().limit()",
          "new_text": null,
          "old_line_content": "      allocator_->allocation_info().limit()) {",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": "FreeLinearAllocationAreaUnsynchronized",
          "new_api": null,
          "old_text": "FreeLinearAllocationAreaUnsynchronized()",
          "new_text": null,
          "old_line_content": "  FreeLinearAllocationAreaUnsynchronized();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "RefillLabMain",
          "new_api": null,
          "old_text": "RefillLabMain(size_in_bytes, origin)",
          "new_text": null,
          "old_line_content": "  return RefillLabMain(size_in_bytes, origin);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": "ResetLab",
          "new_api": null,
          "old_text": "allocator_->ResetLab(top, limit, end)",
          "new_text": null,
          "old_line_content": "  allocator_->ResetLab(top, limit, end);",
          "new_line_content": "  if (top != kNullAddress && top != limit) {",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": "IsLabValid",
          "new_api": null,
          "old_text": "allocator_->IsLabValid()",
          "new_text": null,
          "old_line_content": "  if (!allocator_->IsLabValid()) return;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "Verify",
          "new_api": null,
          "old_text": "allocator_->Verify()",
          "new_text": null,
          "old_line_content": "  allocator_->Verify();",
          "new_line_content": "#endif  // DEBUG",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": "CreateBlackArea",
          "new_api": null,
          "old_text": "page->CreateBlackArea(top, limit)",
          "new_text": null,
          "old_line_content": "      page->CreateBlackArea(top, limit);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "DCHECK_GE",
          "new_api": null,
          "old_text": "DCHECK_GE(size_in_bytes, 0)",
          "new_text": null,
          "old_line_content": "  DCHECK_GE(size_in_bytes, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": "TryExtendLAB",
          "new_api": null,
          "old_text": "TryExtendLAB(size_in_bytes)",
          "new_text": null,
          "old_line_content": "  if (TryExtendLAB(size_in_bytes)) return true;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "limit",
          "new_api": null,
          "old_text": "allocator_->limit()",
          "new_text": null,
          "old_line_content": "  Address current_limit = allocator_->limit();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "  static constexpr int kMaxPagesToSweep = 1;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": "original_limit_relaxed",
          "new_api": null,
          "old_text": "allocator_->original_limit_relaxed()",
          "new_text": null,
          "old_line_content": "                                  ? allocator_->original_limit_relaxed()",
          "new_line_content": "                                  : current_limit;",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": "TryAllocationFromFreeListMain",
          "new_api": null,
          "old_text": "TryAllocationFromFreeListMain(size_in_bytes, origin)",
          "new_text": null,
          "old_line_content": "  if (TryAllocationFromFreeListMain(size_in_bytes, origin)) return true;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": "DCHECK_GE",
          "new_api": null,
          "old_text": "DCHECK_GE(old_limit, new_limit)",
          "new_text": null,
          "old_line_content": "  DCHECK_GE(old_limit, new_limit);",
          "new_line_content": "  if (new_limit != old_limit) {",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": "IsMainThread",
          "new_api": null,
          "old_text": "isolate_heap()->IsMainThread()",
          "new_text": null,
          "old_line_content": "      (allocator_->in_gc() && isolate_heap()->IsMainThread());",
          "new_line_content": "  const auto sweeping_scope_kind =",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": "emplace",
          "new_api": null,
          "old_text": "optional_scope.emplace(\"DecreaseLimit writes to the page header.\")",
          "new_text": null,
          "old_line_content": "      optional_scope.emplace(\"DecreaseLimit writes to the page header.\");",
          "new_line_content": "    }",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 64,
      "total_additions": 63,
      "total_deletions": 64,
      "total_api_changes": 191
    },
    "non_api_changes": {
      "has_non_api_changes": false,
      "evidence": {
        "total_diff_lines": 2,
        "api_related_lines": 191,
        "non_api_lines": 0,
        "non_api_line_numbers": []
      }
    },
    "api_calls_before": 564,
    "api_calls_after": 561,
    "diff_info": {
      "added_lines": 1,
      "removed_lines": 2,
      "total_diff_lines": 15
    }
  }
}