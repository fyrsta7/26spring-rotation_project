{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/bc00836ef07af9c61d85a80d4b566c967ad57a44",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/bc00836ef07af9c61d85a80d4b566c967ad57a44/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/bc00836ef07af9c61d85a80d4b566c967ad57a44/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/bc00836ef07af9c61d85a80d4b566c967ad57a44/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 53,
          "old_api": "ReduceEffectPhi",
          "new_api": "ReduceSpeculativeNumberComparison",
          "old_text": "ReduceEffectPhi(node)",
          "new_text": "ReduceSpeculativeNumberComparison(node)",
          "old_line_content": "      return ReduceEffectPhi(node);",
          "new_line_content": "      return ReduceSpeculativeNumberComparison(node);",
          "content_same": false
        },
        {
          "line": 59,
          "old_api": "ReduceOtherNode",
          "new_api": "ReduceSpeculativeNumberOperation",
          "old_text": "ReduceOtherNode(node)",
          "new_text": "ReduceSpeculativeNumberOperation(node)",
          "old_line_content": "      return ReduceOtherNode(node);",
          "new_line_content": "      return ReduceSpeculativeNumberOperation(node);",
          "content_same": false
        },
        {
          "line": 61,
          "old_api": "NoChange",
          "new_api": "ReduceEffectPhi",
          "old_text": "NoChange()",
          "new_text": "ReduceEffectPhi(node)",
          "old_line_content": "  return NoChange();",
          "new_line_content": "      return ReduceEffectPhi(node);",
          "content_same": false
        },
        {
          "line": 130,
          "old_api": "op",
          "new_api": "zone->New<Check>(node, head_)",
          "old_text": "b->op()",
          "new_text": "zone->New<Check>(node, head_)",
          "old_line_content": "  if (a->op() != b->op()) {",
          "new_line_content": "  Check* head = zone->New<Check>(node, head_);",
          "content_same": false
        },
        {
          "line": 131,
          "old_api": "opcode",
          "new_api": "zone->New<EffectPathChecks>(head, size_ + 1)",
          "old_text": "a->opcode()",
          "new_text": "zone->New<EffectPathChecks>(head, size_ + 1)",
          "old_line_content": "    if (a->opcode() == IrOpcode::kCheckInternalizedString &&",
          "new_line_content": "  return zone->New<EffectPathChecks>(head, size_ + 1);",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": "opcode",
          "new_api": "op",
          "old_text": "b->opcode()",
          "new_text": "b->op()",
          "old_line_content": "               b->opcode() == IrOpcode::kCheckedTaggedToInt32) {",
          "new_line_content": "  if (a->op() != b->op()) {",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": "op",
          "new_api": "mode",
          "old_text": "a->op()",
          "new_text": "bp.mode()",
          "old_line_content": "              CheckTaggedInputParametersOf(a->op());",
          "new_line_content": "          if (ap.mode() != bp.mode()) {",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": "TypeSubsumes",
          "new_api": "NodeProperties::GetType(replacement)",
          "old_text": "TypeSubsumes(node, check->node)",
          "new_text": "NodeProperties::GetType(replacement)",
          "old_line_content": "    if (CheckSubsumes(check->node, node) && TypeSubsumes(node, check->node)) {",
          "new_line_content": "  Type replacement_type = NodeProperties::GetType(replacement);",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": "IsDead",
          "new_api": "Is",
          "old_text": "check->node->IsDead()",
          "new_text": "replacement_type.Is(node_type)",
          "old_line_content": "      DCHECK(!check->node->IsDead());",
          "new_line_content": "  return replacement_type.Is(node_type);",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": "resize",
          "new_api": "id",
          "old_text": "info_for_node_.resize(id + 1, nullptr)",
          "new_text": "node->id()",
          "old_line_content": "  if (id >= info_for_node_.size()) info_for_node_.resize(id + 1, nullptr);",
          "new_line_content": "  size_t const id = node->id();",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "Replace",
          "new_api": "NodeProperties::GetEffectInput(node)",
          "old_text": "Replace(check)",
          "new_text": "NodeProperties::GetEffectInput(node)",
          "old_line_content": "    return Replace(check);",
          "new_line_content": "  Node* const effect = NodeProperties::GetEffectInput(node);",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": "zone",
          "new_api": "NoChange",
          "old_text": "zone()",
          "new_text": "NoChange()",
          "old_line_content": "  return UpdateChecks(node, checks->AddCheck(zone(), node));",
          "new_line_content": "  if (checks == nullptr) return NoChange();",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": "NodeProperties::GetControlInput(node)",
          "new_api": "Replace",
          "old_text": "NodeProperties::GetControlInput(node)",
          "new_text": "Replace(check)",
          "old_line_content": "  Node* const control = NodeProperties::GetControlInput(node);",
          "new_line_content": "    return Replace(check);",
          "content_same": false
        },
        {
          "line": 293,
          "old_api": "NoChange",
          "new_api": "TakeChecksFromFirstEffect",
          "old_text": "NoChange()",
          "new_text": "TakeChecksFromFirstEffect(node)",
          "old_line_content": "    if (node_checks_.Get(effect) == nullptr) return NoChange();",
          "new_line_content": "    return TakeChecksFromFirstEffect(node);",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": "Get",
          "new_api": "op",
          "old_text": "EffectPathChecks::Copy(\n      zone(), node_checks_.Get(NodeProperties::GetEffectInput(node, 0)))",
          "new_text": "node->op()->EffectInputCount()",
          "old_line_content": "  EffectPathChecks* checks = EffectPathChecks::Copy(",
          "new_line_content": "  int const input_count = node->op()->EffectInputCount();",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": "NodeProperties::GetEffectInput(node, i)",
          "new_api": "NoChange",
          "old_text": "NodeProperties::GetEffectInput(node, i)",
          "new_text": "NoChange()",
          "old_line_content": "    Node* const input = NodeProperties::GetEffectInput(node, i);",
          "new_line_content": "    if (node_checks_.Get(effect) == nullptr) return NoChange();",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": "NodeProperties::GetValueInput(node, 0)",
          "new_api": "NodeProperties::GetEffectInput(node, i)",
          "old_text": "NodeProperties::GetValueInput(node, 0)",
          "new_text": "NodeProperties::GetEffectInput(node, i)",
          "old_line_content": "  Node* const first = NodeProperties::GetValueInput(node, 0);",
          "new_line_content": "    Node* const input = NodeProperties::GetEffectInput(node, i);",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "NodeProperties::GetType(first)",
          "new_api": "Get",
          "old_text": "NodeProperties::GetType(first)",
          "new_text": "node_checks_.Get(input)",
          "old_line_content": "  Type const first_type = NodeProperties::GetType(first);",
          "new_line_content": "    checks->Merge(node_checks_.Get(input));",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "NodeProperties::GetType(second)",
          "new_api": "UpdateChecks",
          "old_text": "NodeProperties::GetType(second)",
          "new_text": "UpdateChecks(node, checks)",
          "old_line_content": "  Type const second_type = NodeProperties::GetType(second);",
          "new_line_content": "  return UpdateChecks(node, checks);",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": "NoChange",
          "new_api": "NodeProperties::GetType(first)",
          "old_text": "NoChange()",
          "new_text": "NodeProperties::GetType(first)",
          "old_line_content": "  if (checks == nullptr) return NoChange();",
          "new_line_content": "  Type const first_type = NodeProperties::GetType(first);",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": "FollowedBy",
          "new_api": "Type::UnsignedSmall()",
          "old_text": "Changed(node).FollowedBy(\n              ReduceSpeculativeNumberComparison(node))",
          "new_text": "Type::UnsignedSmall()",
          "old_line_content": "          return Changed(node).FollowedBy(",
          "new_line_content": "    if (!first_type.Is(Type::UnsignedSmall())) {",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": "ReduceSpeculativeNumberComparison",
          "new_api": "LookupBoundsCheckFor",
          "old_text": "ReduceSpeculativeNumberComparison(node)",
          "new_text": "checks->LookupBoundsCheckFor(first)",
          "old_line_content": "              ReduceSpeculativeNumberComparison(node));",
          "new_line_content": "      if (Node* check = checks->LookupBoundsCheckFor(first)) {",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": "FollowedBy",
          "new_api": "Type::UnsignedSmall()",
          "old_text": "Changed(node).FollowedBy(\n              ReduceSpeculativeNumberComparison(node))",
          "new_text": "Type::UnsignedSmall()",
          "old_line_content": "          return Changed(node).FollowedBy(",
          "new_line_content": "    if (!second_type.Is(Type::UnsignedSmall())) {",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": "ReduceSpeculativeNumberComparison",
          "new_api": "LookupBoundsCheckFor",
          "old_text": "ReduceSpeculativeNumberComparison(node)",
          "new_text": "checks->LookupBoundsCheckFor(second)",
          "old_line_content": "              ReduceSpeculativeNumberComparison(node));",
          "new_line_content": "      if (Node* check = checks->LookupBoundsCheckFor(second)) {",
          "content_same": false
        },
        {
          "line": 362,
          "old_api": "UpdateChecks",
          "new_api": "NodeProperties::ReplaceValueInput(node, check, 1)",
          "old_text": "UpdateChecks(node, checks)",
          "new_text": "NodeProperties::ReplaceValueInput(node, check, 1)",
          "old_line_content": "  return UpdateChecks(node, checks);",
          "new_line_content": "          NodeProperties::ReplaceValueInput(node, check, 1);",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": "opcode",
          "new_api": "UpdateChecks",
          "old_text": "node->opcode()",
          "new_text": "UpdateChecks(node, checks)",
          "old_line_content": "         node->opcode() == IrOpcode::kSpeculativeToNumber);",
          "new_line_content": "  return UpdateChecks(node, checks);",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": "NodeProperties::GetValueInput(node, 0)",
          "new_api": "opcode",
          "old_text": "NodeProperties::GetValueInput(node, 0)",
          "new_text": "node->opcode()",
          "old_line_content": "  Node* const first = NodeProperties::GetValueInput(node, 0);",
          "new_line_content": "  DCHECK(node->opcode() == IrOpcode::kSpeculativeNumberAdd ||",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": "NodeProperties::GetEffectInput(node)",
          "new_api": "opcode",
          "old_text": "NodeProperties::GetEffectInput(node)",
          "new_text": "node->opcode()",
          "old_line_content": "  Node* const effect = NodeProperties::GetEffectInput(node);",
          "new_line_content": "         node->opcode() == IrOpcode::kSpeculativeNumberSubtract ||",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": "Get",
          "new_api": "opcode",
          "old_text": "node_checks_.Get(effect)",
          "new_text": "node->opcode()",
          "old_line_content": "  EffectPathChecks const* checks = node_checks_.Get(effect);",
          "new_line_content": "         node->opcode() == IrOpcode::kSpeculativeSafeIntegerAdd ||",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": "NoChange",
          "new_api": "op",
          "old_text": "NoChange()",
          "new_text": "node->op()->EffectInputCount()",
          "old_line_content": "  if (checks == nullptr) return NoChange();",
          "new_line_content": "  DCHECK_EQ(1, node->op()->EffectInputCount());",
          "content_same": false
        },
        {
          "line": 399,
          "old_api": "zone",
          "new_api": "NodeProperties::ReplaceValueInput(node, check, 0)",
          "old_text": "zone()",
          "new_text": "NodeProperties::ReplaceValueInput(node, check, 0)",
          "old_line_content": "  return UpdateChecks(node, EffectPathChecks::Empty(zone()));",
          "new_line_content": "      NodeProperties::ReplaceValueInput(node, check, 0);",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": "op",
          "new_api": "UpdateChecks",
          "old_text": "node->op()->EffectInputCount()",
          "new_text": "UpdateChecks(node, checks)",
          "old_line_content": "  if (node->op()->EffectInputCount() == 1) {",
          "new_line_content": "  return UpdateChecks(node, checks);",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "NoChange",
          "new_api": "TakeChecksFromFirstEffect",
          "old_text": "NoChange()",
          "new_text": "TakeChecksFromFirstEffect(node)",
          "old_line_content": "  return NoChange();",
          "new_line_content": "      return TakeChecksFromFirstEffect(node);",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": "Get",
          "new_api": "op",
          "old_text": "node_checks_.Get(effect)",
          "new_text": "node->op()->EffectInputCount()",
          "old_line_content": "  EffectPathChecks const* checks = node_checks_.Get(effect);",
          "new_line_content": "  DCHECK_EQ(0, node->op()->EffectInputCount());",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": "UpdateChecks",
          "new_api": "op",
          "old_text": "UpdateChecks(node, checks)",
          "new_text": "node->op()->EffectOutputCount()",
          "old_line_content": "  return UpdateChecks(node, checks);",
          "new_line_content": "  DCHECK_EQ(1, node->op()->EffectOutputCount());",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": "Get",
          "new_api": "NoChange",
          "old_text": "node_checks_.Get(node)",
          "new_text": "NoChange()",
          "old_line_content": "  EffectPathChecks const* original = node_checks_.Get(node);",
          "new_line_content": "  if (checks == nullptr) return NoChange();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 47,
          "old_api": null,
          "new_api": "SIMPLIFIED_CHECKED_OP_LIST",
          "old_text": null,
          "new_text": "SIMPLIFIED_CHECKED_OP_LIST(SIMPLIFIED_CHECKED_OP)",
          "old_line_content": "    case IrOpcode::kSpeculativeNumberSubtract:",
          "new_line_content": "      SIMPLIFIED_CHECKED_OP_LIST(SIMPLIFIED_CHECKED_OP)",
          "content_same": false
        },
        {
          "line": 49,
          "old_api": null,
          "new_api": "ReduceCheckNode",
          "old_text": null,
          "new_text": "ReduceCheckNode(node)",
          "old_line_content": "    case IrOpcode::kSpeculativeSafeIntegerSubtract:",
          "new_line_content": "      return ReduceCheckNode(node);",
          "content_same": false
        },
        {
          "line": 65,
          "old_api": null,
          "new_api": "ReduceStart",
          "old_text": null,
          "new_text": "ReduceStart(node)",
          "old_line_content": "RedundancyElimination::EffectPathChecks*",
          "new_line_content": "      return ReduceStart(node);",
          "content_same": false
        },
        {
          "line": 67,
          "old_api": null,
          "new_api": "ReduceOtherNode",
          "old_text": null,
          "new_text": "ReduceOtherNode(node)",
          "old_line_content": "                                              EffectPathChecks const* checks) {",
          "new_line_content": "      return ReduceOtherNode(node);",
          "content_same": false
        },
        {
          "line": 69,
          "old_api": null,
          "new_api": "NoChange",
          "old_text": null,
          "new_text": "NoChange()",
          "old_line_content": "}",
          "new_line_content": "  return NoChange();",
          "content_same": false
        },
        {
          "line": 76,
          "old_api": null,
          "new_api": "zone->New<EffectPathChecks>(*checks)",
          "old_text": null,
          "new_text": "zone->New<EffectPathChecks>(*checks)",
          "old_line_content": "",
          "new_line_content": "  return zone->New<EffectPathChecks>(*checks);",
          "content_same": false
        },
        {
          "line": 82,
          "old_api": null,
          "new_api": "zone->New<EffectPathChecks>(nullptr, 0)",
          "old_text": null,
          "new_text": "zone->New<EffectPathChecks>(nullptr, 0)",
          "old_line_content": "  while (this_head != that_head) {",
          "new_line_content": "  return zone->New<EffectPathChecks>(nullptr, 0);",
          "content_same": false
        },
        {
          "line": 119,
          "old_api": null,
          "new_api": "DCHECK_LT",
          "old_text": null,
          "new_text": "DCHECK_LT(0u, size_)",
          "old_line_content": "RedundancyElimination::EffectPathChecks const*",
          "new_line_content": "    DCHECK_LT(0u, size_);",
          "content_same": false
        },
        {
          "line": 120,
          "old_api": null,
          "new_api": "DCHECK_NOT_NULL",
          "old_text": null,
          "new_text": "DCHECK_NOT_NULL(head_)",
          "old_line_content": "RedundancyElimination::EffectPathChecks::AddCheck(Zone* zone,",
          "new_line_content": "    DCHECK_NOT_NULL(head_);",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "a->opcode()",
          "old_line_content": "      // CheckedTaggedSignedToInt32(node) implies CheckedTaggedToInt32(node)",
          "new_line_content": "    if (a->opcode() == IrOpcode::kCheckInternalizedString &&",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "a->opcode()",
          "old_line_content": "      // CheckedTaggedSignedToInt32(node) implies",
          "new_line_content": "    } else if (a->opcode() == IrOpcode::kCheckSmi &&",
          "content_same": false
        },
        {
          "line": 143,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "b->opcode()",
          "old_line_content": "      // CheckedTaggedToArrayIndex(node)",
          "new_line_content": "               b->opcode() == IrOpcode::kCheckNumber) {",
          "content_same": false
        },
        {
          "line": 146,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "b->opcode()",
          "old_line_content": "      // CheckedTaggedToInt32(node) implies CheckedTaggedToArrayIndex(node)",
          "new_line_content": "               b->opcode() == IrOpcode::kCheckedTaggedToInt32) {",
          "content_same": false
        },
        {
          "line": 149,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "b->opcode()",
          "old_line_content": "      // CheckReceiver(node) implies CheckReceiverOrNullOrUndefined(node)",
          "new_line_content": "               b->opcode() == IrOpcode::kCheckedTaggedToArrayIndex) {",
          "content_same": false
        },
        {
          "line": 152,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "a->opcode()",
          "old_line_content": "    } else {",
          "new_line_content": "    } else if (a->opcode() == IrOpcode::kCheckedTaggedToInt32 &&",
          "content_same": false
        },
        {
          "line": 155,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "a->opcode()",
          "old_line_content": "        case IrOpcode::kCheckSmi:",
          "new_line_content": "    } else if (a->opcode() == IrOpcode::kCheckReceiver &&",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "b->opcode()",
          "old_line_content": "        case IrOpcode::kCheckString:",
          "new_line_content": "               b->opcode() == IrOpcode::kCheckReceiverOrNullOrUndefined) {",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "b->opcode()",
          "old_line_content": "        case IrOpcode::kCheckBigInt:",
          "new_line_content": "    } else if (a->opcode() != b->opcode()) {",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "a->opcode()",
          "old_line_content": "        case IrOpcode::kCheckedInt64ToInt32:",
          "new_line_content": "      switch (a->opcode()) {",
          "content_same": false
        },
        {
          "line": 187,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "a->op()",
          "old_line_content": "        case IrOpcode::kCheckedTaggedToFloat64:",
          "new_line_content": "              CheckMinusZeroParametersOf(a->op());",
          "content_same": false
        },
        {
          "line": 189,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "b->op()",
          "old_line_content": "          CheckTaggedInputParameters const& ap =",
          "new_line_content": "              CheckMinusZeroParametersOf(b->op());",
          "content_same": false
        },
        {
          "line": 198,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "a->op()",
          "old_line_content": "          }",
          "new_line_content": "              CheckTaggedInputParametersOf(a->op());",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "b->op()",
          "old_line_content": "        }",
          "new_line_content": "              CheckTaggedInputParametersOf(b->op());",
          "content_same": false
        },
        {
          "line": 203,
          "old_api": null,
          "new_api": "mode",
          "old_text": null,
          "new_text": "bp.mode()",
          "old_line_content": "          return false;",
          "new_line_content": "          if (ap.mode() != bp.mode() &&",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": null,
          "new_api": "mode",
          "old_text": null,
          "new_text": "ap.mode()",
          "old_line_content": "      }",
          "new_line_content": "              ap.mode() != CheckTaggedInputMode::kNumber) {",
          "content_same": false
        },
        {
          "line": 210,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "a->op()",
          "old_line_content": "  return true;",
          "new_line_content": "          DCHECK(!IsCheckedWithFeedback(a->op()));",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "a->op()->ValueInputCount()",
          "old_line_content": "    // If either node is untyped, we are running during an untyped optimization",
          "new_line_content": "  for (int i = a->op()->ValueInputCount(); --i >= 0;) {",
          "content_same": false
        },
        {
          "line": 216,
          "old_api": null,
          "new_api": "InputAt",
          "old_text": null,
          "new_text": "b->InputAt(i)",
          "old_line_content": "    // phase, and replacement is OK.",
          "new_line_content": "    if (a->InputAt(i) != b->InputAt(i)) return false;",
          "content_same": false
        },
        {
          "line": 222,
          "old_api": null,
          "new_api": "NodeProperties::IsTyped(replacement)",
          "old_text": null,
          "new_text": "NodeProperties::IsTyped(replacement)",
          "old_line_content": "}",
          "new_line_content": "  if (!NodeProperties::IsTyped(node) || !NodeProperties::IsTyped(replacement)) {",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": null,
          "new_api": "NodeProperties::GetType(node)",
          "old_text": null,
          "new_text": "NodeProperties::GetType(node)",
          "old_line_content": "  for (Check const* check = head_; check != nullptr; check = check->next) {",
          "new_line_content": "  Type node_type = NodeProperties::GetType(node);",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": null,
          "new_api": "TypeSubsumes",
          "old_text": null,
          "new_text": "TypeSubsumes(node, check->node)",
          "old_line_content": "Node* RedundancyElimination::EffectPathChecks::LookupBoundsCheckFor(",
          "new_line_content": "    if (CheckSubsumes(check->node, node) && TypeSubsumes(node, check->node)) {",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": null,
          "new_api": "IsDead",
          "old_text": null,
          "new_text": "check->node->IsDead()",
          "old_line_content": "    Node* node) const {",
          "new_line_content": "      DCHECK(!check->node->IsDead());",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "check->node->opcode()",
          "old_line_content": "}",
          "new_line_content": "    if (check->node->opcode() == IrOpcode::kCheckBounds &&",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": null,
          "new_api": "TypeSubsumes",
          "old_text": null,
          "new_text": "TypeSubsumes(node, check->node)",
          "old_line_content": "",
          "new_line_content": "        check->node->InputAt(0) == node && TypeSubsumes(node, check->node) &&",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "check->node->op()",
          "old_line_content": "RedundancyElimination::EffectPathChecks const*",
          "new_line_content": "        !(CheckBoundsParametersOf(check->node->op()).flags() &",
          "content_same": false
        },
        {
          "line": 260,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "info_for_node_.size()",
          "old_line_content": "  info_for_node_[id] = checks;",
          "new_line_content": "  if (id < info_for_node_.size()) return info_for_node_[id];",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "node->id()",
          "old_line_content": "  // If we do not know anything about the predecessor, do not propagate just yet",
          "new_line_content": "  size_t const id = node->id();",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "info_for_node_.resize(id + 1, nullptr)",
          "old_line_content": "  // because we will have to recompute anyway once we compute the predecessor.",
          "new_line_content": "  if (id >= info_for_node_.size()) info_for_node_.resize(id + 1, nullptr);",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "node_checks_.Get(effect)",
          "old_line_content": "  }",
          "new_line_content": "  EffectPathChecks const* checks = node_checks_.Get(effect);",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": null,
          "new_api": "LookupCheck",
          "old_text": null,
          "new_text": "checks->LookupCheck(node)",
          "old_line_content": "",
          "new_line_content": "  if (Node* check = checks->LookupCheck(node)) {",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "ReplaceWithValue",
          "old_text": null,
          "new_text": "ReplaceWithValue(node, check)",
          "old_line_content": "Reduction RedundancyElimination::ReduceEffectPhi(Node* node) {",
          "new_line_content": "    ReplaceWithValue(node, check);",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": null,
          "new_api": "zone",
          "old_text": null,
          "new_text": "zone()",
          "old_line_content": "    // the information from the loop entry edge.",
          "new_line_content": "  return UpdateChecks(node, checks->AddCheck(zone(), node));",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": null,
          "new_api": "NodeProperties::GetControlInput(node)",
          "old_text": null,
          "new_text": "NodeProperties::GetControlInput(node)",
          "old_line_content": "",
          "new_line_content": "  Node* const control = NodeProperties::GetControlInput(node);",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "control->opcode()",
          "old_line_content": "  // Shortcut for the case when we do not know anything about some input.",
          "new_line_content": "  if (control->opcode() == IrOpcode::kLoop) {",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "control->opcode()",
          "old_line_content": "",
          "new_line_content": "  DCHECK_EQ(IrOpcode::kMerge, control->opcode());",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": null,
          "new_api": "NodeProperties::GetEffectInput(node, i)",
          "old_text": null,
          "new_text": "NodeProperties::GetEffectInput(node, i)",
          "old_line_content": "  for (int i = 1; i < input_count; ++i) {",
          "new_line_content": "    Node* const effect = NodeProperties::GetEffectInput(node, i);",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "EffectPathChecks::Copy(\n      zone(), node_checks_.Get(NodeProperties::GetEffectInput(node, 0)))",
          "old_line_content": "",
          "new_line_content": "  EffectPathChecks* checks = EffectPathChecks::Copy(",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": null,
          "new_api": "NodeProperties::GetEffectInput(node, 0)",
          "old_text": null,
          "new_text": "NodeProperties::GetEffectInput(node, 0)",
          "old_line_content": "Reduction RedundancyElimination::ReduceSpeculativeNumberComparison(Node* node) {",
          "new_line_content": "      zone(), node_checks_.Get(NodeProperties::GetEffectInput(node, 0)));",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "node->op()",
          "old_line_content": "  // If we do not know anything about the predecessor, do not propagate just yet",
          "new_line_content": "  NumberOperationHint const hint = NumberOperationHintOf(node->op());",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": null,
          "new_api": "NodeProperties::GetValueInput(node, 0)",
          "old_text": null,
          "new_text": "NodeProperties::GetValueInput(node, 0)",
          "old_line_content": "  // because we will have to recompute anyway once we compute the predecessor.",
          "new_line_content": "  Node* const first = NodeProperties::GetValueInput(node, 0);",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": null,
          "new_api": "NodeProperties::GetValueInput(node, 1)",
          "old_text": null,
          "new_text": "NodeProperties::GetValueInput(node, 1)",
          "old_line_content": "",
          "new_line_content": "  Node* const second = NodeProperties::GetValueInput(node, 1);",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": null,
          "new_api": "NodeProperties::GetType(second)",
          "old_text": null,
          "new_text": "NodeProperties::GetType(second)",
          "old_line_content": "  // Avoid the potentially expensive lookups below if the {node}",
          "new_line_content": "  Type const second_type = NodeProperties::GetType(second);",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": null,
          "new_api": "NodeProperties::GetEffectInput(node)",
          "old_text": null,
          "new_text": "NodeProperties::GetEffectInput(node)",
          "old_line_content": "  // has seen non-Smi inputs in the past, which is a clear signal",
          "new_line_content": "  Node* const effect = NodeProperties::GetEffectInput(node);",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "node_checks_.Get(effect)",
          "old_line_content": "  // that the comparison is probably not performed on a value that",
          "new_line_content": "  EffectPathChecks const* checks = node_checks_.Get(effect);",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": null,
          "new_api": "NoChange",
          "old_text": null,
          "new_text": "NoChange()",
          "old_line_content": "    // if it's type is already in UnsignedSmall range, since the bounds",
          "new_line_content": "  if (checks == nullptr) return NoChange();",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": null,
          "new_api": "NodeProperties::GetType(check)",
          "old_text": null,
          "new_text": "NodeProperties::GetType(check)",
          "old_line_content": "        }",
          "new_line_content": "        if (!first_type.Is(NodeProperties::GetType(check))) {",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": null,
          "new_api": "NodeProperties::ReplaceValueInput(node, check, 0)",
          "old_text": null,
          "new_text": "NodeProperties::ReplaceValueInput(node, check, 0)",
          "old_line_content": "    // if it's type is already in UnsignedSmall range, since the bounds",
          "new_line_content": "          NodeProperties::ReplaceValueInput(node, check, 0);",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": null,
          "new_api": "FollowedBy",
          "old_text": null,
          "new_text": "Changed(node).FollowedBy(\n              ReduceSpeculativeNumberComparison(node))",
          "old_line_content": "    // check is only going to narrow that range further, but the result",
          "new_line_content": "          return Changed(node).FollowedBy(",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": null,
          "new_api": "ReduceSpeculativeNumberComparison",
          "old_text": null,
          "new_text": "ReduceSpeculativeNumberComparison(node)",
          "old_line_content": "    // is not going to make the representation selection any better.",
          "new_line_content": "              ReduceSpeculativeNumberComparison(node));",
          "content_same": false
        },
        {
          "line": 357,
          "old_api": null,
          "new_api": "NodeProperties::GetType(check)",
          "old_text": null,
          "new_text": "NodeProperties::GetType(check)",
          "old_line_content": "        }",
          "new_line_content": "        if (!second_type.Is(NodeProperties::GetType(check))) {",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": null,
          "new_api": "FollowedBy",
          "old_text": null,
          "new_text": "Changed(node).FollowedBy(\n              ReduceSpeculativeNumberComparison(node))",
          "old_line_content": "}",
          "new_line_content": "          return Changed(node).FollowedBy(",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": null,
          "new_api": "ReduceSpeculativeNumberComparison",
          "old_text": null,
          "new_text": "ReduceSpeculativeNumberComparison(node)",
          "old_line_content": "",
          "new_line_content": "              ReduceSpeculativeNumberComparison(node));",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "node->opcode()",
          "old_line_content": "  // If we do not know anything about the predecessor, do not propagate just yet",
          "new_line_content": "         node->opcode() == IrOpcode::kSpeculativeSafeIntegerSubtract ||",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "node->opcode()",
          "old_line_content": "  // because we will have to recompute anyway once we compute the predecessor.",
          "new_line_content": "         node->opcode() == IrOpcode::kSpeculativeToNumber);",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "node->op()->EffectOutputCount()",
          "old_line_content": "",
          "new_line_content": "  DCHECK_EQ(1, node->op()->EffectOutputCount());",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": null,
          "new_api": "NodeProperties::GetValueInput(node, 0)",
          "old_text": null,
          "new_text": "NodeProperties::GetValueInput(node, 0)",
          "old_line_content": "  // in the graph already, which we might be able to",
          "new_line_content": "  Node* const first = NodeProperties::GetValueInput(node, 0);",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": null,
          "new_api": "NodeProperties::GetEffectInput(node)",
          "old_text": null,
          "new_text": "NodeProperties::GetEffectInput(node)",
          "old_line_content": "  // reuse here to improve the representation selection",
          "new_line_content": "  Node* const effect = NodeProperties::GetEffectInput(node);",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "node_checks_.Get(effect)",
          "old_line_content": "  // for the {node} later on.",
          "new_line_content": "  EffectPathChecks const* checks = node_checks_.Get(effect);",
          "content_same": false
        },
        {
          "line": 387,
          "old_api": null,
          "new_api": "NoChange",
          "old_text": null,
          "new_text": "NoChange()",
          "old_line_content": "    // than the type of the {first} node, otherwise we",
          "new_line_content": "  if (checks == nullptr) return NoChange();",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": null,
          "new_api": "LookupBoundsCheckFor",
          "old_text": null,
          "new_text": "checks->LookupBoundsCheckFor(first)",
          "old_line_content": "  }",
          "new_line_content": "  if (Node* check = checks->LookupBoundsCheckFor(first)) {",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": null,
          "new_api": "NodeProperties::GetType(check)",
          "old_text": null,
          "new_text": "NodeProperties::GetType(check)",
          "old_line_content": "Reduction RedundancyElimination::ReduceStart(Node* node) {",
          "new_line_content": "    if (!NodeProperties::GetType(first).Is(NodeProperties::GetType(check))) {",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": null,
          "new_api": "zone",
          "old_text": null,
          "new_text": "zone()",
          "old_line_content": "      // Effect terminators should be handled specially.",
          "new_line_content": "  return UpdateChecks(node, EffectPathChecks::Empty(zone()));",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": null,
          "new_api": "NoChange",
          "old_text": null,
          "new_text": "NoChange()",
          "old_line_content": "Reduction RedundancyElimination::TakeChecksFromFirstEffect(Node* node) {",
          "new_line_content": "      return NoChange();",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "node->op()->EffectOutputCount()",
          "old_line_content": "  // If we do not know anything about the predecessor, do not propagate just yet",
          "new_line_content": "  DCHECK_EQ(0, node->op()->EffectOutputCount());",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": null,
          "new_api": "NoChange",
          "old_text": null,
          "new_text": "NoChange()",
          "old_line_content": "  // because we will have to recompute anyway once we compute the predecessor.",
          "new_line_content": "  return NoChange();",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": null,
          "new_api": "NodeProperties::GetEffectInput(node)",
          "old_text": null,
          "new_text": "NodeProperties::GetEffectInput(node)",
          "old_line_content": "}",
          "new_line_content": "  Node* const effect = NodeProperties::GetEffectInput(node);",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "node_checks_.Get(effect)",
          "old_line_content": "",
          "new_line_content": "  EffectPathChecks const* checks = node_checks_.Get(effect);",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": null,
          "new_api": "UpdateChecks",
          "old_text": null,
          "new_text": "UpdateChecks(node, checks)",
          "old_line_content": "  if (checks != original) {",
          "new_line_content": "  return UpdateChecks(node, checks);",
          "content_same": false
        },
        {
          "line": 438,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "node_checks_.Get(node)",
          "old_line_content": "  }",
          "new_line_content": "  EffectPathChecks const* original = node_checks_.Get(node);",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": null,
          "new_api": "Equals",
          "old_text": null,
          "new_text": "checks->Equals(original)",
          "old_line_content": "}  // namespace compiler",
          "new_line_content": "    if (original == nullptr || !checks->Equals(original)) {",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": null,
          "new_api": "Set",
          "old_text": null,
          "new_text": "node_checks_.Set(node, checks)",
          "old_line_content": "}  // namespace internal",
          "new_line_content": "      node_checks_.Set(node, checks);",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": null,
          "new_api": "Changed",
          "old_text": null,
          "new_text": "Changed(node)",
          "old_line_content": "}  // namespace v8",
          "new_line_content": "      return Changed(node);",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": null,
          "new_api": "NoChange",
          "old_text": null,
          "new_text": "NoChange()",
          "old_line_content": "",
          "new_line_content": "  return NoChange();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 39,
          "old_api": "SIMPLIFIED_CHECKED_OP_LIST",
          "new_api": null,
          "old_text": "SIMPLIFIED_CHECKED_OP_LIST(SIMPLIFIED_CHECKED_OP)",
          "new_text": null,
          "old_line_content": "      SIMPLIFIED_CHECKED_OP_LIST(SIMPLIFIED_CHECKED_OP)",
          "new_line_content": "    // folded together if repeated with identical inputs.",
          "content_same": false
        },
        {
          "line": 41,
          "old_api": "ReduceCheckNode",
          "new_api": null,
          "old_text": "ReduceCheckNode(node)",
          "new_text": null,
          "old_line_content": "      return ReduceCheckNode(node);",
          "new_line_content": "    case IrOpcode::kBigIntSubtract:",
          "content_same": false
        },
        {
          "line": 45,
          "old_api": "ReduceSpeculativeNumberComparison",
          "new_api": null,
          "old_text": "ReduceSpeculativeNumberComparison(node)",
          "new_text": null,
          "old_line_content": "      return ReduceSpeculativeNumberComparison(node);",
          "new_line_content": "    case IrOpcode::kStringSubstring:",
          "content_same": false
        },
        {
          "line": 51,
          "old_api": "ReduceSpeculativeNumberOperation",
          "new_api": null,
          "old_text": "ReduceSpeculativeNumberOperation(node)",
          "new_text": null,
          "old_line_content": "      return ReduceSpeculativeNumberOperation(node);",
          "new_line_content": "    case IrOpcode::kSpeculativeNumberLessThan:",
          "content_same": false
        },
        {
          "line": 57,
          "old_api": "ReduceStart",
          "new_api": null,
          "old_text": "ReduceStart(node)",
          "new_text": null,
          "old_line_content": "      return ReduceStart(node);",
          "new_line_content": "    case IrOpcode::kSpeculativeSafeIntegerSubtract:",
          "content_same": false
        },
        {
          "line": 68,
          "old_api": "zone->New<EffectPathChecks>(*checks)",
          "new_api": null,
          "old_text": "zone->New<EffectPathChecks>(*checks)",
          "new_text": null,
          "old_line_content": "  return zone->New<EffectPathChecks>(*checks);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 74,
          "old_api": "zone->New<EffectPathChecks>(nullptr, 0)",
          "new_api": null,
          "old_text": "zone->New<EffectPathChecks>(nullptr, 0)",
          "new_text": null,
          "old_line_content": "  return zone->New<EffectPathChecks>(nullptr, 0);",
          "new_line_content": "RedundancyElimination::EffectPathChecks::Copy(Zone* zone,",
          "content_same": false
        },
        {
          "line": 111,
          "old_api": "DCHECK_LT",
          "new_api": null,
          "old_text": "DCHECK_LT(0u, size_)",
          "new_text": null,
          "old_line_content": "    DCHECK_LT(0u, size_);",
          "new_line_content": "  while (size_ > that_size) {",
          "content_same": false
        },
        {
          "line": 112,
          "old_api": "DCHECK_NOT_NULL",
          "new_api": null,
          "old_text": "DCHECK_NOT_NULL(head_)",
          "new_text": null,
          "old_line_content": "    DCHECK_NOT_NULL(head_);",
          "new_line_content": "    head_ = head_->next;",
          "content_same": false
        },
        {
          "line": 122,
          "old_api": "zone->New<Check>(node, head_)",
          "new_api": null,
          "old_text": "zone->New<Check>(node, head_)",
          "new_text": null,
          "old_line_content": "  Check* head = zone->New<Check>(node, head_);",
          "new_line_content": "    head_ = head_->next;",
          "content_same": false
        },
        {
          "line": 123,
          "old_api": "zone->New<EffectPathChecks>(head, size_ + 1)",
          "new_api": null,
          "old_text": "zone->New<EffectPathChecks>(head, size_ + 1)",
          "new_text": null,
          "old_line_content": "  return zone->New<EffectPathChecks>(head, size_ + 1);",
          "new_line_content": "    that_head = that_head->next;",
          "content_same": false
        },
        {
          "line": 132,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "b->opcode()",
          "new_text": null,
          "old_line_content": "        b->opcode() == IrOpcode::kCheckString) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 134,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "a->opcode()",
          "new_text": null,
          "old_line_content": "    } else if (a->opcode() == IrOpcode::kCheckSmi &&",
          "new_line_content": "namespace {",
          "content_same": false
        },
        {
          "line": 135,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "b->opcode()",
          "new_text": null,
          "old_line_content": "               b->opcode() == IrOpcode::kCheckNumber) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 137,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "a->opcode()",
          "new_text": null,
          "old_line_content": "    } else if (a->opcode() == IrOpcode::kCheckedTaggedSignedToInt32 &&",
          "new_line_content": "bool CheckSubsumes(Node const* a, Node const* b) {",
          "content_same": false
        },
        {
          "line": 141,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "b->opcode()",
          "new_text": null,
          "old_line_content": "               b->opcode() == IrOpcode::kCheckedTaggedToArrayIndex) {",
          "new_line_content": "      // CheckInternalizedString(node) implies CheckString(node)",
          "content_same": false
        },
        {
          "line": 144,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "a->opcode()",
          "new_text": null,
          "old_line_content": "    } else if (a->opcode() == IrOpcode::kCheckedTaggedToInt32 &&",
          "new_line_content": "      // CheckSmi(node) implies CheckNumber(node)",
          "content_same": false
        },
        {
          "line": 147,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "a->opcode()",
          "new_text": null,
          "old_line_content": "    } else if (a->opcode() == IrOpcode::kCheckReceiver &&",
          "new_line_content": "      // CheckedTaggedSignedToInt32(node) implies CheckedTaggedToInt32(node)",
          "content_same": false
        },
        {
          "line": 150,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "b->opcode()",
          "new_text": null,
          "old_line_content": "    } else if (a->opcode() != b->opcode()) {",
          "new_line_content": "      // CheckedTaggedSignedToInt32(node) implies",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": "op",
          "new_api": null,
          "old_text": "a->op()",
          "new_text": null,
          "old_line_content": "              CheckMinusZeroParametersOf(a->op());",
          "new_line_content": "        case IrOpcode::kCheckedUint64ToInt32:",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": "op",
          "new_api": null,
          "old_text": "b->op()",
          "new_text": null,
          "old_line_content": "              CheckMinusZeroParametersOf(b->op());",
          "new_line_content": "          break;",
          "content_same": false
        },
        {
          "line": 182,
          "old_api": "mode",
          "new_api": null,
          "old_text": "bp.mode()",
          "new_text": null,
          "old_line_content": "          if (ap.mode() != bp.mode()) {",
          "new_line_content": "        case IrOpcode::kCheckedFloat64ToInt32:",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": "op",
          "new_api": null,
          "old_text": "b->op()",
          "new_text": null,
          "old_line_content": "              CheckTaggedInputParametersOf(b->op());",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 195,
          "old_api": "mode",
          "new_api": null,
          "old_text": "bp.mode()",
          "new_text": null,
          "old_line_content": "          if (ap.mode() != bp.mode() &&",
          "new_line_content": "        case IrOpcode::kCheckedTaggedToFloat64:",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": "mode",
          "new_api": null,
          "old_text": "ap.mode()",
          "new_text": null,
          "old_line_content": "              ap.mode() != CheckTaggedInputMode::kNumber) {",
          "new_line_content": "        case IrOpcode::kCheckedTruncateTaggedToWord32: {",
          "content_same": false
        },
        {
          "line": 202,
          "old_api": "op",
          "new_api": null,
          "old_text": "a->op()",
          "new_text": null,
          "old_line_content": "          DCHECK(!IsCheckedWithFeedback(a->op()));",
          "new_line_content": "          // for Number, in which case {b} will be subsumed no matter what.",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": "op",
          "new_api": null,
          "old_text": "a->op()->ValueInputCount()",
          "new_text": null,
          "old_line_content": "  for (int i = a->op()->ValueInputCount(); --i >= 0;) {",
          "new_line_content": "          break;",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": "InputAt",
          "new_api": null,
          "old_text": "b->InputAt(i)",
          "new_text": null,
          "old_line_content": "    if (a->InputAt(i) != b->InputAt(i)) return false;",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": "NodeProperties::IsTyped(replacement)",
          "new_api": null,
          "old_text": "NodeProperties::IsTyped(replacement)",
          "new_text": null,
          "old_line_content": "  if (!NodeProperties::IsTyped(node) || !NodeProperties::IsTyped(replacement)) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": "NodeProperties::GetType(node)",
          "new_api": null,
          "old_text": "NodeProperties::GetType(node)",
          "new_text": null,
          "old_line_content": "  Type node_type = NodeProperties::GetType(node);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": "NodeProperties::GetType(replacement)",
          "new_api": null,
          "old_text": "NodeProperties::GetType(replacement)",
          "new_text": null,
          "old_line_content": "  Type replacement_type = NodeProperties::GetType(replacement);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": "Is",
          "new_api": null,
          "old_text": "replacement_type.Is(node_type)",
          "new_text": null,
          "old_line_content": "  return replacement_type.Is(node_type);",
          "new_line_content": "bool TypeSubsumes(Node* node, Node* replacement) {",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "check->node->opcode()",
          "new_text": null,
          "old_line_content": "    if (check->node->opcode() == IrOpcode::kCheckBounds &&",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": "TypeSubsumes",
          "new_api": null,
          "old_text": "TypeSubsumes(node, check->node)",
          "new_text": null,
          "old_line_content": "        check->node->InputAt(0) == node && TypeSubsumes(node, check->node) &&",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": "op",
          "new_api": null,
          "old_text": "check->node->op()",
          "new_text": null,
          "old_line_content": "        !(CheckBoundsParametersOf(check->node->op()).flags() &",
          "new_line_content": "  return nullptr;",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": "id",
          "new_api": null,
          "old_text": "node->id()",
          "new_text": null,
          "old_line_content": "  size_t const id = node->id();",
          "new_line_content": "      return check->node;",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": "size",
          "new_api": null,
          "old_text": "info_for_node_.size()",
          "new_text": null,
          "old_line_content": "  if (id < info_for_node_.size()) return info_for_node_[id];",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": "id",
          "new_api": null,
          "old_text": "node->id()",
          "new_text": null,
          "old_line_content": "  size_t const id = node->id();",
          "new_line_content": "RedundancyElimination::PathChecksForEffectNodes::Get(Node* node) const {",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": "NodeProperties::GetEffectInput(node)",
          "new_api": null,
          "old_text": "NodeProperties::GetEffectInput(node)",
          "new_text": null,
          "old_line_content": "  Node* const effect = NodeProperties::GetEffectInput(node);",
          "new_line_content": "void RedundancyElimination::PathChecksForEffectNodes::Set(",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": "Get",
          "new_api": null,
          "old_text": "node_checks_.Get(effect)",
          "new_text": null,
          "old_line_content": "  EffectPathChecks const* checks = node_checks_.Get(effect);",
          "new_line_content": "    Node* node, EffectPathChecks const* checks) {",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": "NoChange",
          "new_api": null,
          "old_text": "NoChange()",
          "new_text": null,
          "old_line_content": "  if (checks == nullptr) return NoChange();",
          "new_line_content": "  info_for_node_[id] = checks;",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": "LookupCheck",
          "new_api": null,
          "old_text": "checks->LookupCheck(node)",
          "new_text": null,
          "old_line_content": "  if (Node* check = checks->LookupCheck(node)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "ReplaceWithValue",
          "new_api": null,
          "old_text": "ReplaceWithValue(node, check)",
          "new_text": null,
          "old_line_content": "    ReplaceWithValue(node, check);",
          "new_line_content": "Reduction RedundancyElimination::ReduceCheckNode(Node* node) {",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "control->opcode()",
          "new_text": null,
          "old_line_content": "  if (control->opcode() == IrOpcode::kLoop) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": "TakeChecksFromFirstEffect",
          "new_api": null,
          "old_text": "TakeChecksFromFirstEffect(node)",
          "new_text": null,
          "old_line_content": "    return TakeChecksFromFirstEffect(node);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "control->opcode()",
          "new_text": null,
          "old_line_content": "  DCHECK_EQ(IrOpcode::kMerge, control->opcode());",
          "new_line_content": "Reduction RedundancyElimination::ReduceEffectPhi(Node* node) {",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": "op",
          "new_api": null,
          "old_text": "node->op()->EffectInputCount()",
          "new_text": null,
          "old_line_content": "  int const input_count = node->op()->EffectInputCount();",
          "new_line_content": "    // Here we rely on having only reducible loops:",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": "NodeProperties::GetEffectInput(node, i)",
          "new_api": null,
          "old_text": "NodeProperties::GetEffectInput(node, i)",
          "new_text": null,
          "old_line_content": "    Node* const effect = NodeProperties::GetEffectInput(node, i);",
          "new_line_content": "    // the information from the loop entry edge.",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": "NodeProperties::GetEffectInput(node, 0)",
          "new_api": null,
          "old_text": "NodeProperties::GetEffectInput(node, 0)",
          "new_text": null,
          "old_line_content": "      zone(), node_checks_.Get(NodeProperties::GetEffectInput(node, 0)));",
          "new_line_content": "  for (int i = 0; i < input_count; ++i) {",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": "Get",
          "new_api": null,
          "old_text": "node_checks_.Get(input)",
          "new_text": null,
          "old_line_content": "    checks->Merge(node_checks_.Get(input));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "UpdateChecks",
          "new_api": null,
          "old_text": "UpdateChecks(node, checks)",
          "new_text": null,
          "old_line_content": "  return UpdateChecks(node, checks);",
          "new_line_content": "  // Make a copy of the first input's checks and merge with the checks",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": "op",
          "new_api": null,
          "old_text": "node->op()",
          "new_text": null,
          "old_line_content": "  NumberOperationHint const hint = NumberOperationHintOf(node->op());",
          "new_line_content": "  for (int i = 1; i < input_count; ++i) {",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": "NodeProperties::GetValueInput(node, 1)",
          "new_api": null,
          "old_text": "NodeProperties::GetValueInput(node, 1)",
          "new_text": null,
          "old_line_content": "  Node* const second = NodeProperties::GetValueInput(node, 1);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": "NodeProperties::GetEffectInput(node)",
          "new_api": null,
          "old_text": "NodeProperties::GetEffectInput(node)",
          "new_text": null,
          "old_line_content": "  Node* const effect = NodeProperties::GetEffectInput(node);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": "Get",
          "new_api": null,
          "old_text": "node_checks_.Get(effect)",
          "new_text": null,
          "old_line_content": "  EffectPathChecks const* checks = node_checks_.Get(effect);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": "Type::UnsignedSmall()",
          "new_api": null,
          "old_text": "Type::UnsignedSmall()",
          "new_text": null,
          "old_line_content": "    if (!first_type.Is(Type::UnsignedSmall())) {",
          "new_line_content": "  // has seen non-Smi inputs in the past, which is a clear signal",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": "LookupBoundsCheckFor",
          "new_api": null,
          "old_text": "checks->LookupBoundsCheckFor(first)",
          "new_text": null,
          "old_line_content": "      if (Node* check = checks->LookupBoundsCheckFor(first)) {",
          "new_line_content": "  // that the comparison is probably not performed on a value that",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": "NodeProperties::GetType(check)",
          "new_api": null,
          "old_text": "NodeProperties::GetType(check)",
          "new_text": null,
          "old_line_content": "        if (!first_type.Is(NodeProperties::GetType(check))) {",
          "new_line_content": "  // already passed an array bounds check.",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": "NodeProperties::ReplaceValueInput(node, check, 0)",
          "new_api": null,
          "old_text": "NodeProperties::ReplaceValueInput(node, check, 0)",
          "new_text": null,
          "old_line_content": "          NodeProperties::ReplaceValueInput(node, check, 0);",
          "new_line_content": "    // is not going to make the representation selection any better.",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": "Type::UnsignedSmall()",
          "new_api": null,
          "old_text": "Type::UnsignedSmall()",
          "new_text": null,
          "old_line_content": "    if (!second_type.Is(Type::UnsignedSmall())) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": "LookupBoundsCheckFor",
          "new_api": null,
          "old_text": "checks->LookupBoundsCheckFor(second)",
          "new_text": null,
          "old_line_content": "      if (Node* check = checks->LookupBoundsCheckFor(second)) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": "NodeProperties::GetType(check)",
          "new_api": null,
          "old_text": "NodeProperties::GetType(check)",
          "new_text": null,
          "old_line_content": "        if (!second_type.Is(NodeProperties::GetType(check))) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 354,
          "old_api": "NodeProperties::ReplaceValueInput(node, check, 1)",
          "new_api": null,
          "old_text": "NodeProperties::ReplaceValueInput(node, check, 1)",
          "new_text": null,
          "old_line_content": "          NodeProperties::ReplaceValueInput(node, check, 1);",
          "new_line_content": "    // is not going to make the representation selection any better.",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "node->opcode()",
          "new_text": null,
          "old_line_content": "  DCHECK(node->opcode() == IrOpcode::kSpeculativeNumberAdd ||",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 367,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "node->opcode()",
          "new_text": null,
          "old_line_content": "         node->opcode() == IrOpcode::kSpeculativeNumberSubtract ||",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 368,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "node->opcode()",
          "new_text": null,
          "old_line_content": "         node->opcode() == IrOpcode::kSpeculativeSafeIntegerAdd ||",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 369,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "node->opcode()",
          "new_text": null,
          "old_line_content": "         node->opcode() == IrOpcode::kSpeculativeSafeIntegerSubtract ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": "op",
          "new_api": null,
          "old_text": "node->op()->EffectInputCount()",
          "new_text": null,
          "old_line_content": "  DCHECK_EQ(1, node->op()->EffectInputCount());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "op",
          "new_api": null,
          "old_text": "node->op()->EffectOutputCount()",
          "new_text": null,
          "old_line_content": "  DCHECK_EQ(1, node->op()->EffectOutputCount());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 385,
          "old_api": "LookupBoundsCheckFor",
          "new_api": null,
          "old_text": "checks->LookupBoundsCheckFor(first)",
          "new_text": null,
          "old_line_content": "  if (Node* check = checks->LookupBoundsCheckFor(first)) {",
          "new_line_content": "  // If we do not know anything about the predecessor, do not propagate just yet",
          "content_same": false
        },
        {
          "line": 390,
          "old_api": "NodeProperties::GetType(check)",
          "new_api": null,
          "old_text": "NodeProperties::GetType(check)",
          "new_text": null,
          "old_line_content": "    if (!NodeProperties::GetType(first).Is(NodeProperties::GetType(check))) {",
          "new_line_content": "  // in the graph already, which we might be able to",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": "NodeProperties::ReplaceValueInput(node, check, 0)",
          "new_api": null,
          "old_text": "NodeProperties::ReplaceValueInput(node, check, 0)",
          "new_text": null,
          "old_line_content": "      NodeProperties::ReplaceValueInput(node, check, 0);",
          "new_line_content": "  // reuse here to improve the representation selection",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": "UpdateChecks",
          "new_api": null,
          "old_text": "UpdateChecks(node, checks)",
          "new_text": null,
          "old_line_content": "  return UpdateChecks(node, checks);",
          "new_line_content": "    // than the type of the {first} node, otherwise we",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": "op",
          "new_api": null,
          "old_text": "node->op()->EffectOutputCount()",
          "new_text": null,
          "old_line_content": "    if (node->op()->EffectOutputCount() == 1) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": "TakeChecksFromFirstEffect",
          "new_api": null,
          "old_text": "TakeChecksFromFirstEffect(node)",
          "new_text": null,
          "old_line_content": "      return TakeChecksFromFirstEffect(node);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": "NoChange",
          "new_api": null,
          "old_text": "NoChange()",
          "new_text": null,
          "old_line_content": "      return NoChange();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": "op",
          "new_api": null,
          "old_text": "node->op()->EffectOutputCount()",
          "new_text": null,
          "old_line_content": "  DCHECK_EQ(1, node->op()->EffectOutputCount());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": "NodeProperties::GetEffectInput(node)",
          "new_api": null,
          "old_text": "NodeProperties::GetEffectInput(node)",
          "new_text": null,
          "old_line_content": "  Node* const effect = NodeProperties::GetEffectInput(node);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "NoChange",
          "new_api": null,
          "old_text": "NoChange()",
          "new_text": null,
          "old_line_content": "  if (checks == nullptr) return NoChange();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": "Equals",
          "new_api": null,
          "old_text": "checks->Equals(original)",
          "new_text": null,
          "old_line_content": "    if (original == nullptr || !checks->Equals(original)) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": "Set",
          "new_api": null,
          "old_text": "node_checks_.Set(node, checks)",
          "new_text": null,
          "old_line_content": "      node_checks_.Set(node, checks);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": "Changed",
          "new_api": null,
          "old_text": "Changed(node)",
          "new_text": null,
          "old_line_content": "      return Changed(node);",
          "new_line_content": "Reduction RedundancyElimination::UpdateChecks(Node* node,",
          "content_same": false
        },
        {
          "line": 439,
          "old_api": "NoChange",
          "new_api": null,
          "old_text": "NoChange()",
          "new_text": null,
          "old_line_content": "  return NoChange();",
          "new_line_content": "  // Only signal that the {node} has Changed, if the information about {checks}",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 36,
      "total_additions": 83,
      "total_deletions": 83,
      "total_api_changes": 202
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 202,
        "non_api_lines": 5,
        "non_api_line_numbers": [
          38,
          40,
          42,
          43,
          44
        ]
      }
    },
    "api_calls_before": 179,
    "api_calls_after": 179,
    "diff_info": {
      "added_lines": 8,
      "removed_lines": 0,
      "total_diff_lines": 20
    }
  }
}