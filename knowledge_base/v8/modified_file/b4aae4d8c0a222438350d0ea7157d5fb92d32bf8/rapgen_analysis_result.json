{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/b4aae4d8c0a222438350d0ea7157d5fb92d32bf8",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/b4aae4d8c0a222438350d0ea7157d5fb92d32bf8/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/b4aae4d8c0a222438350d0ea7157d5fb92d32bf8/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/b4aae4d8c0a222438350d0ea7157d5fb92d32bf8/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 655,
          "old_api": "InputAt",
          "new_api": "end",
          "old_text": "node->InputAt(0)",
          "new_text": "visited->end()",
          "old_line_content": "        Node* object = node->InputAt(0);",
          "new_line_content": "            visited->find(object) != visited->end()) {",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": "count",
          "new_api": "IsLive",
          "old_text": "visited->count(input)",
          "new_text": "all_nodes.IsLive(node)",
          "old_line_content": "      if (NodeProperties::IsControlEdge(edge) && visited->count(input) == 0 &&",
          "new_line_content": "    if (!all_nodes.IsLive(node)) continue;",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": "id",
          "new_api": "input_edges",
          "old_text": "FATAL(\n            \"Floating control detected in wasm turbofan graph: Node #%d:%s is \"\n            \"inside loop headed by #%d, but its control dependency #%d:%s is \"\n            \"outside\",\n            node->id(), node->op()->mnemonic(), loop_header->id(), input->id(),\n            input->op()->mnemonic())",
          "new_text": "node->input_edges()",
          "old_line_content": "        FATAL(",
          "new_line_content": "    for (Edge edge : node->input_edges()) {",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "opcode",
          "new_api": "LoopNodes",
          "old_text": "node->opcode()",
          "new_text": "loop_tree->LoopNodes(loop)",
          "old_line_content": "        switch (node->opcode()) {",
          "new_line_content": "  for (Node* node : loop_tree->LoopNodes(loop)) {",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": "InputAt",
          "new_api": "Contains",
          "old_text": "node->InputAt(1)",
          "new_text": "loop_tree->Contains(loop, use)",
          "old_line_content": "            unmarked_exit = (node->InputAt(1) != loop_node);",
          "new_line_content": "      if (!loop_tree->Contains(loop, use)) {",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": "id",
          "new_api": "opcode",
          "old_text": "PrintF(\n                \"Cannot peel loop %i. Loop exit without explicit mark: Node %i \"\n                \"(%s) is inside loop, but its use %i (%s) is outside.\\n\",\n                loop_node->id(), node->id(), node->op()->mnemonic(), use->id(),\n                use->op()->mnemonic())",
          "new_text": "use->opcode()",
          "old_line_content": "            PrintF(",
          "new_line_content": "            unmarked_exit = (use->opcode() != IrOpcode::kTerminate);",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": "op",
          "new_api": "id",
          "old_text": "use->op()->mnemonic()",
          "new_text": "PrintF(\n                \"Cannot peel loop %i. Loop exit without explicit mark: Node %i \"\n                \"(%s) is inside loop, but its use %i (%s) is outside.\\n\",\n                loop_node->id(), node->id(), node->op()->mnemonic(), use->id(),\n                use->op()->mnemonic())",
          "old_line_content": "                use->op()->mnemonic());",
          "new_line_content": "            PrintF(",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": "opcode",
          "new_api": "begin",
          "old_text": "header->opcode()",
          "new_text": "HeaderNodes(loop).begin()",
          "old_line_content": "  DCHECK_EQ(IrOpcode::kLoop, header->opcode());",
          "new_line_content": "  Node* first = *HeaderNodes(loop).begin();",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": "size",
          "new_api": "Get",
          "old_text": "new_copies.size()",
          "new_text": "node_map_.Get(node)",
          "old_line_content": "  DCHECK_EQ(new_copies.size(), copy_count_);",
          "new_line_content": "  return copies_->at(node_map_.Get(node) + copy_index);",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": "DCHECK_EQ",
          "new_api": "end",
          "old_text": "DCHECK_EQ(copy_count_, 1)",
          "new_text": "new_copies.end()",
          "old_line_content": "  DCHECK_EQ(copy_count_, 1);",
          "new_line_content": "  copies_->insert(copies_->end(), new_copies.begin(), new_copies.end());",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 771,
          "old_api": null,
          "new_api": "DCHECK_EQ",
          "old_text": null,
          "new_text": "DCHECK_EQ(copy_count_, 1)",
          "old_line_content": "}",
          "new_line_content": "  DCHECK_EQ(copy_count_, 1);",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "copies_->size()",
          "old_line_content": "",
          "new_line_content": "  node_map_.Set(original, copies_->size() + 1);",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "copies_->push_back(original)",
          "old_line_content": "}  // namespace compiler",
          "new_line_content": "  copies_->push_back(original);",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "copies_->push_back(copy)",
          "old_line_content": "}  // namespace internal",
          "new_line_content": "  copies_->push_back(copy);",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": null,
          "new_api": "InputAt",
          "old_text": null,
          "new_text": "node->InputAt(0)",
          "old_line_content": "        // Extending this idea to array.get/array.len has been found to hurt",
          "new_line_content": "        Node* object = node->InputAt(0);",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "object->opcode()",
          "old_line_content": "        // more than it helps (tested on Sheets, Feb 2023).",
          "new_line_content": "        if (object->opcode() == IrOpcode::kWasmStructGet &&",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": null,
          "new_api": "ENQUEUE_USES",
          "old_text": null,
          "new_text": "ENQUEUE_USES(use, true)",
          "old_line_content": "          has_instruction_worth_peeling = true;",
          "new_line_content": "        ENQUEUE_USES(use, true);",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": null,
          "new_api": "ENQUEUE_USES",
          "old_text": null,
          "new_text": "ENQUEUE_USES(use, true)",
          "old_line_content": "",
          "new_line_content": "        ENQUEUE_USES(use, true)",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": null,
          "new_api": "to",
          "old_text": null,
          "new_text": "edge.to()",
          "old_line_content": "            \"Floating control detected in wasm turbofan graph: Node #%d:%s is \"",
          "new_line_content": "      Node* input = edge.to();",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "visited->count(input)",
          "old_line_content": "            \"inside loop headed by #%d, but its control dependency #%d:%s is \"",
          "new_line_content": "      if (NodeProperties::IsControlEdge(edge) && visited->count(input) == 0 &&",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "input->opcode()",
          "old_line_content": "            \"outside\",",
          "new_line_content": "          input->opcode() != IrOpcode::kStart) {",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "input->id()",
          "old_line_content": "  }",
          "new_line_content": "            node->id(), node->op()->mnemonic(), loop_header->id(), input->id(),",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "input->op()->mnemonic()",
          "old_line_content": "",
          "new_line_content": "            input->op()->mnemonic());",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": null,
          "new_api": "GetLoopControl",
          "old_text": null,
          "new_text": "loop_tree->GetLoopControl(loop)",
          "old_line_content": "        bool unmarked_exit;",
          "new_line_content": "  Node* loop_node = loop_tree->GetLoopControl(loop);",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "node->uses()",
          "old_line_content": "          case IrOpcode::kLoopExit:",
          "new_line_content": "    for (Node* use : node->uses()) {",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "node->opcode()",
          "old_line_content": "          case IrOpcode::kLoopExitValue:",
          "new_line_content": "        switch (node->opcode()) {",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": null,
          "new_api": "InputAt",
          "old_text": null,
          "new_text": "node->InputAt(1)->InputAt(1)",
          "old_line_content": "        }",
          "new_line_content": "            unmarked_exit = (node->InputAt(1)->InputAt(1) != loop_node);",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "use->id()",
          "old_line_content": "        }",
          "new_line_content": "                loop_node->id(), node->id(), node->op()->mnemonic(), use->id(),",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "use->op()->mnemonic()",
          "old_line_content": "      }",
          "new_line_content": "                use->op()->mnemonic());",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "first->opcode()",
          "old_line_content": "  return header;",
          "new_line_content": "  if (first->opcode() == IrOpcode::kLoop) return first;",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "first->opcode()",
          "old_line_content": "}",
          "new_line_content": "  DCHECK(IrOpcode::IsPhiOpcode(first->opcode()));",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": null,
          "new_api": "NodeProperties::GetControlInput(first)",
          "old_text": null,
          "new_text": "NodeProperties::GetControlInput(first)",
          "old_line_content": "",
          "new_line_content": "  Node* header = NodeProperties::GetControlInput(first);",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "header->opcode()",
          "old_line_content": "Node* NodeCopier::map(Node* node, uint32_t copy_index) {",
          "new_line_content": "  DCHECK_EQ(IrOpcode::kLoop, header->opcode());",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": null,
          "new_api": "DCHECK_LT",
          "old_text": null,
          "new_text": "DCHECK_LT(copy_index, copy_count_)",
          "old_line_content": "",
          "new_line_content": "  DCHECK_LT(copy_index, copy_count_);",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "node_map_.Get(node)",
          "old_line_content": "void NodeCopier::Insert(Node* original, const NodeVector& new_copies) {",
          "new_line_content": "  if (node_map_.Get(node) == 0) return node;",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "new_copies.size()",
          "old_line_content": "}",
          "new_line_content": "  DCHECK_EQ(new_copies.size(), copy_count_);",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "copies_->size()",
          "old_line_content": "",
          "new_line_content": "  node_map_.Set(original, copies_->size() + 1);",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "copies_->push_back(original)",
          "old_line_content": "void NodeCopier::Insert(Node* original, Node* copy) {",
          "new_line_content": "  copies_->push_back(original);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 768,
          "old_api": "size",
          "new_api": null,
          "old_text": "copies_->size()",
          "new_text": null,
          "old_line_content": "  node_map_.Set(original, copies_->size() + 1);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "copies_->push_back(original)",
          "new_text": null,
          "old_line_content": "  copies_->push_back(original);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "copies_->push_back(copy)",
          "new_text": null,
          "old_line_content": "  copies_->push_back(copy);",
          "new_line_content": "void NodeCopier::Insert(Node* original, Node* copy) {",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "object->opcode()",
          "new_text": null,
          "old_line_content": "        if (object->opcode() == IrOpcode::kWasmStructGet &&",
          "new_line_content": "          has_instruction_worth_peeling = true;",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": "end",
          "new_api": null,
          "old_text": "visited->end()",
          "new_text": null,
          "old_line_content": "            visited->find(object) != visited->end()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": "ENQUEUE_USES",
          "new_api": null,
          "old_text": "ENQUEUE_USES(use, true)",
          "new_text": null,
          "old_line_content": "        ENQUEUE_USES(use, true);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "ENQUEUE_USES",
          "new_api": null,
          "old_text": "ENQUEUE_USES(use, true)",
          "new_text": null,
          "old_line_content": "        ENQUEUE_USES(use, true)",
          "new_line_content": "        // specifically designed for being hoisted out of loops.",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": "IsLive",
          "new_api": null,
          "old_text": "all_nodes.IsLive(node)",
          "new_text": null,
          "old_line_content": "    if (!all_nodes.IsLive(node)) continue;",
          "new_line_content": "  for (Node* node : *visited) {",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": "input_edges",
          "new_api": null,
          "old_text": "node->input_edges()",
          "new_text": null,
          "old_line_content": "    for (Edge edge : node->input_edges()) {",
          "new_line_content": "    if (node == loop_header) continue;",
          "content_same": false
        },
        {
          "line": 685,
          "old_api": "to",
          "new_api": null,
          "old_text": "edge.to()",
          "new_text": null,
          "old_line_content": "      Node* input = edge.to();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "input->opcode()",
          "new_text": null,
          "old_line_content": "          input->opcode() != IrOpcode::kStart) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": "op",
          "new_api": null,
          "old_text": "input->op()->mnemonic()",
          "new_text": null,
          "old_line_content": "            input->op()->mnemonic());",
          "new_line_content": "            \"Floating control detected in wasm turbofan graph: Node #%d:%s is \"",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": "GetLoopControl",
          "new_api": null,
          "old_text": "loop_tree->GetLoopControl(loop)",
          "new_text": null,
          "old_line_content": "  Node* loop_node = loop_tree->GetLoopControl(loop);",
          "new_line_content": "bool LoopFinder::HasMarkedExits(LoopTree* loop_tree,",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": "LoopNodes",
          "new_api": null,
          "old_text": "loop_tree->LoopNodes(loop)",
          "new_text": null,
          "old_line_content": "  for (Node* node : loop_tree->LoopNodes(loop)) {",
          "new_line_content": "                                const LoopTree::Loop* loop) {",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": "uses",
          "new_api": null,
          "old_text": "node->uses()",
          "new_text": null,
          "old_line_content": "    for (Node* use : node->uses()) {",
          "new_line_content": "  // Look for returns and if projections that are outside the loop but whose",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": "Contains",
          "new_api": null,
          "old_text": "loop_tree->Contains(loop, use)",
          "new_text": null,
          "old_line_content": "      if (!loop_tree->Contains(loop, use)) {",
          "new_line_content": "  // control input is inside the loop.",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "use->opcode()",
          "new_text": null,
          "old_line_content": "            unmarked_exit = (use->opcode() != IrOpcode::kTerminate);",
          "new_line_content": "          case IrOpcode::kLoopExitEffect:",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "id",
          "new_api": null,
          "old_text": "use->id()",
          "new_text": null,
          "old_line_content": "                loop_node->id(), node->id(), node->op()->mnemonic(), use->id(),",
          "new_line_content": "          if (v8_flags.trace_turbo_loop) {",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": "begin",
          "new_api": null,
          "old_text": "HeaderNodes(loop).begin()",
          "new_text": null,
          "old_line_content": "  Node* first = *HeaderNodes(loop).begin();",
          "new_line_content": "  return true;",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "first->opcode()",
          "new_text": null,
          "old_line_content": "  if (first->opcode() == IrOpcode::kLoop) return first;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "first->opcode()",
          "new_text": null,
          "old_line_content": "  DCHECK(IrOpcode::IsPhiOpcode(first->opcode()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": "NodeProperties::GetControlInput(first)",
          "new_api": null,
          "old_text": "NodeProperties::GetControlInput(first)",
          "new_text": null,
          "old_line_content": "  Node* header = NodeProperties::GetControlInput(first);",
          "new_line_content": "Node* LoopTree::HeaderNode(const Loop* loop) {",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": "DCHECK_LT",
          "new_api": null,
          "old_text": "DCHECK_LT(copy_index, copy_count_)",
          "new_text": null,
          "old_line_content": "  DCHECK_LT(copy_index, copy_count_);",
          "new_line_content": "  return header;",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": "Get",
          "new_api": null,
          "old_text": "node_map_.Get(node)",
          "new_text": null,
          "old_line_content": "  if (node_map_.Get(node) == 0) return node;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": "Get",
          "new_api": null,
          "old_text": "node_map_.Get(node)",
          "new_text": null,
          "old_line_content": "  return copies_->at(node_map_.Get(node) + copy_index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "size",
          "new_api": null,
          "old_text": "copies_->size()",
          "new_text": null,
          "old_line_content": "  node_map_.Set(original, copies_->size() + 1);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "copies_->push_back(original)",
          "new_text": null,
          "old_line_content": "  copies_->push_back(original);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": "end",
          "new_api": null,
          "old_text": "new_copies.end()",
          "new_text": null,
          "old_line_content": "  copies_->insert(copies_->end(), new_copies.begin(), new_copies.end());",
          "new_line_content": "void NodeCopier::Insert(Node* original, const NodeVector& new_copies) {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 10,
      "total_additions": 28,
      "total_deletions": 28,
      "total_api_changes": 66
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 66,
        "non_api_lines": 5,
        "non_api_line_numbers": [
          661,
          662,
          663,
          664,
          666
        ]
      }
    },
    "api_calls_before": 289,
    "api_calls_after": 289,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 2,
      "total_diff_lines": 28
    }
  }
}