diff --git a/src/compiler/loop-analysis.cc b/src/compiler/loop-analysis.cc
index 0c4ed5a8c34..bf995b938a6 100644
--- a/src/compiler/loop-analysis.cc
+++ b/src/compiler/loop-analysis.cc
@@ -650,8 +650,6 @@ ZoneUnorderedSet<Node*>* LoopFinder::FindSmallInnermostLoopFromHeader(
       case IrOpcode::kWasmStructGet: {
         // When a chained load occurs in the loop, assume that peeling might
         // help.
-        // Extending this idea to array.get/array.len has been found to hurt
-        // more than it helps (tested on Sheets, Feb 2023).
         Node* object = node->InputAt(0);
         if (object->opcode() == IrOpcode::kWasmStructGet &&
             visited->find(object) != visited->end()) {
@@ -660,7 +658,13 @@ ZoneUnorderedSet<Node*>* LoopFinder::FindSmallInnermostLoopFromHeader(
         ENQUEUE_USES(use, true);
         break;
       }
+      case IrOpcode::kWasmArrayGet:
+        // Rationale for array.get: loops that contain an array.get also
+        // contain a bounds check, which needs to load the array's length,
+        // which benefits from load elimination after peeling.
       case IrOpcode::kStringPrepareForGetCodeunit:
+        // Rationale for PrepareForGetCodeunit: this internal operation is
+        // specifically designed for being hoisted out of loops.
         has_instruction_worth_peeling = true;
         V8_FALLTHROUGH;
       default:
