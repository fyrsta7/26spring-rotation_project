{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/f298b11b5e28980cbfba3cf9cde59c27b892e486",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/f298b11b5e28980cbfba3cf9cde59c27b892e486/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/f298b11b5e28980cbfba3cf9cde59c27b892e486/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/f298b11b5e28980cbfba3cf9cde59c27b892e486/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 223,
          "old_api": "end",
          "new_api": "find",
          "old_text": "ripts.end()) ",
          "new_text": "ripts.find(node->script_id_);\n",
          "old_line_content": "      scripts.find(node->script_id_) != scripts.end()) {",
          "new_line_content": "    auto script_iterator = scripts.find(node->script_id_);",
          "content_same": false
        },
        {
          "line": 226,
          "old_api": "nst_cast<std::map<int, Handle<Script>>&>(scripts);",
          "new_api": "IsName",
          "old_text": "nst_cast<std::map<int, Handle<Script>>&>(scripts);\n",
          "new_text": "ript->name().IsName()) ",
          "old_line_content": "        const_cast<std::map<int, Handle<Script>>&>(scripts);",
          "new_line_content": "      if (script->name().IsName()) {",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": "is_null",
          "new_api": "factory",
          "old_text": "ript.is_null()) ",
          "new_text": "ApiHandle<v8::String>(\n            isolate_->factory()->InternalizeUtf8String(names_->GetName(name)));\n",
          "old_line_content": "    if (!script.is_null()) {",
          "new_line_content": "        script_name = ToApiHandle<v8::String>(",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": "IsName",
          "new_api": "GetName",
          "old_text": "ript->name().IsName()) ",
          "new_text": "mes_->GetName(name)))",
          "old_line_content": "      if (script->name().IsName()) {",
          "new_line_content": "            isolate_->factory()->InternalizeUtf8String(names_->GetName(name)));",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": "factory",
          "new_api": "ript::GetLineNumber(script, node->script_position_);",
          "old_text": "ApiHandle<v8::String>(\n            isolate_->factory()->InternalizeUtf8String(names_->GetName(name)));\n",
          "new_text": "ript::GetLineNumber(script, node->script_position_);\n",
          "old_line_content": "        script_name = ToApiHandle<v8::String>(",
          "new_line_content": "      line = 1 + Script::GetLineNumber(script, node->script_position_);",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": "GetName",
          "new_api": "ript::GetColumnNumber(script, node->script_position_);",
          "old_text": "mes_->GetName(name)))",
          "new_text": "ript::GetColumnNumber(script, node->script_position_);\n",
          "old_line_content": "            isolate_->factory()->InternalizeUtf8String(names_->GetName(name)));",
          "new_line_content": "      column = 1 + Script::GetColumnNumber(script, node->script_position_);",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": "aleSample",
          "new_api": "push_back",
          "old_text": "aleSample(alloc.first, alloc.second));",
          "new_text": "ofile->nodes_.push_back(v8::AllocationProfile::Node{\n      ToApiHandle<v8::String>(\n          isolate_->factory()->InternalizeUtf8String(node->name_)),\n      script_name, node->script_id_, node->script_position_, line, column,\n      node->id_, std::vector<v8::AllocationProfile::Node*>(), allocations});\n",
          "old_line_content": "    allocations.push_back(ScaleSample(alloc.first, alloc.second));",
          "new_line_content": "  profile->nodes_.push_back(v8::AllocationProfile::Node{",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": "factory",
          "new_api": "d::vector<v8::AllocationProfile::Node*>(),",
          "old_text": "ApiHandle<v8::String>(\n          isolate_->factory()->InternalizeUtf8String(node->name_)),\n",
          "new_text": "d::vector<v8::AllocationProfile::Node*>(), ",
          "old_line_content": "      ToApiHandle<v8::String>(",
          "new_line_content": "      node->id_, std::vector<v8::AllocationProfile::Node*>(), allocations});",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": "factory",
          "new_api": "back",
          "old_text": "olate_->factory()->InternalizeUtf8String(node->name_)),",
          "new_text": "ofile->nodes_.back();\n",
          "old_line_content": "          isolate_->factory()->InternalizeUtf8String(node->name_)),",
          "new_line_content": "  v8::AllocationProfile::Node* current = &profile->nodes_.back();",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": "size",
          "new_api": "emplace_back",
          "old_text": "mples_.size());",
          "new_text": "mples.emplace_back(v8::AllocationProfile::Sample{\n        sample->owner->id_, sample->size, ScaleSample(sample->size, 1).count,\n        sample->sample_id});\n",
          "old_line_content": "  samples.reserve(samples_.size());",
          "new_line_content": "    samples.emplace_back(v8::AllocationProfile::Sample{",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 224,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "ripts.end()) ",
          "old_line_content": "    // Cannot use std::map<T>::at because it is not available on android.",
          "new_line_content": "    if (script_iterator != scripts.end()) {",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "olate_->heap()->CollectAllGarbage(\n        Heap::kNoGCFlags, GarbageCollectionReason::kSamplingProfiler);\n",
          "old_line_content": "",
          "new_line_content": "    isolate_->heap()->CollectAllGarbage(",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "ript->name());",
          "old_line_content": "    Handle<Script> script = non_const_scripts[node->script_id_];",
          "new_line_content": "        Name name = Name::cast(script->name());",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rrent->children.push_back(\n        TranslateAllocationNode(profile, it.second.get(), scripts));\n",
          "old_line_content": "  // the potential to be sampled. That's ok since map iterators are not",
          "new_line_content": "    current->children.push_back(",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": null,
          "new_api": "is_null",
          "old_text": null,
          "new_text": "ript.is_null();\n",
          "old_line_content": "  std::map<int, Handle<Script>> scripts;",
          "new_line_content": "    for (Script script = iterator.Next(); !script.is_null();",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "erator.Next()) ",
          "old_line_content": "  {",
          "new_line_content": "         script = iterator.Next()) {",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": null,
          "new_api": "ndle",
          "old_text": null,
          "new_text": "ndle(script, isolate_);\n",
          "old_line_content": "    Script::Iterator iterator(isolate_);",
          "new_line_content": "      scripts[script.id()] = handle(script, isolate_);",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": null,
          "new_api": "aleSample",
          "old_text": null,
          "new_text": "aleSample(alloc.first, alloc.second));",
          "old_line_content": "    }",
          "new_line_content": "    allocations.push_back(ScaleSample(alloc.first, alloc.second));",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": null,
          "new_api": "factory",
          "old_text": null,
          "new_text": "ApiHandle<v8::String>(\n          isolate_->factory()->InternalizeUtf8String(node->name_)),\n",
          "old_line_content": "  }",
          "new_line_content": "      ToApiHandle<v8::String>(",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": null,
          "new_api": "anslateAllocationNode",
          "old_text": null,
          "new_text": "anslateAllocationNode(profile, &profile_root_, scripts);\n",
          "old_line_content": "    }",
          "new_line_content": "  TranslateAllocationNode(profile, &profile_root_, scripts);",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": null,
          "new_api": "ildSamples",
          "old_text": null,
          "new_text": "ildSamples();\n",
          "old_line_content": "  }",
          "new_line_content": "  profile->samples_ = BuildSamples();",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": null,
          "new_api": "factory",
          "old_text": null,
          "new_text": "olate_->factory()->InternalizeUtf8String(node->name_)),",
          "old_line_content": "",
          "new_line_content": "          isolate_->factory()->InternalizeUtf8String(node->name_)),",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "mples_.size());",
          "old_line_content": "const std::vector<v8::AllocationProfile::Sample>",
          "new_line_content": "  samples.reserve(samples_.size());",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": ".second.get(), ",
          "old_line_content": "  // invalidated upon std::map insertion.",
          "new_line_content": "        TranslateAllocationNode(profile, it.second.get(), scripts));",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": ".second.get();\n",
          "old_line_content": "  std::vector<v8::AllocationProfile::Sample> samples;",
          "new_line_content": "    const Sample* sample = it.second.get();",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": null,
          "new_api": "aleSample",
          "old_text": null,
          "new_text": "aleSample(sample->size, 1).c",
          "old_line_content": "  for (const auto& it : samples_) {",
          "new_line_content": "        sample->owner->id_, sample->size, ScaleSample(sample->size, 1).count,",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 288,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "mples.emplace_back(v8::AllocationProfile::Sample{\n        sample->owner->id_, sample->size, ScaleSample(sample->size, 1).count,\n        sample->sample_id});\n",
          "new_text": null,
          "old_line_content": "    samples.emplace_back(v8::AllocationProfile::Sample{",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "aleSample",
          "new_api": null,
          "old_text": "aleSample(sample->size, 1).c",
          "new_text": null,
          "old_line_content": "        sample->owner->id_, sample->size, ScaleSample(sample->size, 1).count,",
          "new_line_content": "  return samples;",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": "name",
          "new_api": null,
          "old_text": "ript->name());",
          "new_text": null,
          "old_line_content": "        Name name = Name::cast(script->name());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": "heap",
          "new_api": null,
          "old_text": "olate_->heap()->CollectAllGarbage(\n        Heap::kNoGCFlags, GarbageCollectionReason::kSamplingProfiler);\n",
          "new_text": null,
          "old_line_content": "    isolate_->heap()->CollectAllGarbage(",
          "new_line_content": "  // To resolve positions to line/column numbers, we will need to look up",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": "ript::GetLineNumber(script, node->script_position_);",
          "new_api": null,
          "old_text": "ript::GetLineNumber(script, node->script_position_);\n",
          "new_text": null,
          "old_line_content": "      line = 1 + Script::GetLineNumber(script, node->script_position_);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": "ript::GetColumnNumber(script, node->script_position_);",
          "new_api": null,
          "old_text": "ript::GetColumnNumber(script, node->script_position_);\n",
          "new_text": null,
          "old_line_content": "      column = 1 + Script::GetColumnNumber(script, node->script_position_);",
          "new_line_content": "  for (auto alloc : node->allocations_) {",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": "is_null",
          "new_api": null,
          "old_text": "ript.is_null();\n",
          "new_text": null,
          "old_line_content": "    for (Script script = iterator.Next(); !script.is_null();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "Next",
          "new_api": null,
          "old_text": "erator.Next()) ",
          "new_text": null,
          "old_line_content": "         script = iterator.Next()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "ndle",
          "new_api": null,
          "old_text": "ndle(script, isolate_);\n",
          "new_text": null,
          "old_line_content": "      scripts[script.id()] = handle(script, isolate_);",
          "new_line_content": "  auto profile = new v8::internal::AllocationProfile();",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "ofile->nodes_.push_back(v8::AllocationProfile::Node{\n      ToApiHandle<v8::String>(\n          isolate_->factory()->InternalizeUtf8String(node->name_)),\n      script_name, node->script_id_, node->script_position_, line, column,\n      node->id_, std::vector<v8::AllocationProfile::Node*>(), allocations});\n",
          "new_text": null,
          "old_line_content": "  profile->nodes_.push_back(v8::AllocationProfile::Node{",
          "new_line_content": "      script_name, node->script_id_, node->script_position_, line, column,",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": "anslateAllocationNode",
          "new_api": null,
          "old_text": "anslateAllocationNode(profile, &profile_root_, scripts);\n",
          "new_text": null,
          "old_line_content": "  TranslateAllocationNode(profile, &profile_root_, scripts);",
          "new_line_content": "  return profile;",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": "ildSamples",
          "new_api": null,
          "old_text": "ildSamples();\n",
          "new_text": null,
          "old_line_content": "  profile->samples_ = BuildSamples();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": "d::vector<v8::AllocationProfile::Node*>(),",
          "new_api": null,
          "old_text": "d::vector<v8::AllocationProfile::Node*>(), ",
          "new_text": null,
          "old_line_content": "      node->id_, std::vector<v8::AllocationProfile::Node*>(), allocations});",
          "new_line_content": "  // because the translation may allocate strings on the JS heap that have",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": "back",
          "new_api": null,
          "old_text": "ofile->nodes_.back();\n",
          "new_text": null,
          "old_line_content": "  v8::AllocationProfile::Node* current = &profile->nodes_.back();",
          "new_line_content": "  // the potential to be sampled. That's ok since map iterators are not",
          "content_same": false
        },
        {
          "line": 253,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rrent->children.push_back(\n        TranslateAllocationNode(profile, it.second.get(), scripts));\n",
          "new_text": null,
          "old_line_content": "    current->children.push_back(",
          "new_line_content": "  node->pinned_ = false;",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": "get",
          "new_api": null,
          "old_text": ".second.get(), ",
          "new_text": null,
          "old_line_content": "        TranslateAllocationNode(profile, it.second.get(), scripts));",
          "new_line_content": "  return current;",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": "get",
          "new_api": null,
          "old_text": ".second.get();\n",
          "new_text": null,
          "old_line_content": "    const Sample* sample = it.second.get();",
          "new_line_content": "        sample->sample_id});",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 10,
      "total_additions": 16,
      "total_deletions": 17,
      "total_api_changes": 43
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 7,
        "api_related_lines": 43,
        "non_api_lines": 2,
        "non_api_line_numbers": [
          225,
          222
        ]
      }
    },
    "api_calls_before": 112,
    "api_calls_after": 110,
    "diff_info": {
      "added_lines": 4,
      "removed_lines": 7,
      "total_diff_lines": 23
    }
  }
}