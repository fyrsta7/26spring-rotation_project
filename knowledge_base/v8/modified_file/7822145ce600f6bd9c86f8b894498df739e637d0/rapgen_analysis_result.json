{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/7822145ce600f6bd9c86f8b894498df739e637d0",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/7822145ce600f6bd9c86f8b894498df739e637d0/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/7822145ce600f6bd9c86f8b894498df739e637d0/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/7822145ce600f6bd9c86f8b894498df739e637d0/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 3122,
          "old_api": "relative_id",
          "new_api": "SplitRangeAt",
          "old_text": "current->relative_id()",
          "new_text": "SplitRangeAt(current, pos)",
          "old_line_content": "        current->TopLevel()->vreg(), current->relative_id());",
          "new_line_content": "    LiveRange* tail = SplitRangeAt(current, pos);",
          "content_same": false
        },
        {
          "line": 3123,
          "old_api": "SetLiveRangeAssignedRegister",
          "new_api": "AddToUnhandled",
          "old_text": "SetLiveRangeAssignedRegister(current, reg)",
          "new_text": "AddToUnhandled(tail)",
          "old_line_content": "  SetLiveRangeAssignedRegister(current, reg);",
          "new_line_content": "    AddToUnhandled(tail);",
          "content_same": false
        },
        {
          "line": 3133,
          "old_api": "Spill",
          "new_api": "relative_id",
          "old_text": "Spill(current)",
          "new_text": "current->relative_id()",
          "old_line_content": "    Spill(current);",
          "new_line_content": "        current->TopLevel()->vreg(), current->relative_id());",
          "content_same": false
        },
        {
          "line": 3140,
          "old_api": "representation",
          "new_api": "Start",
          "old_text": "current->representation()",
          "new_text": "current->Start()",
          "old_line_content": "  MachineRepresentation rep = current->representation();",
          "new_line_content": "  UsePosition* register_use = current->NextRegisterPosition(current->Start());",
          "content_same": false
        },
        {
          "line": 3151,
          "old_api": "LifetimePosition::MaxPosition()",
          "new_api": "representation",
          "old_text": "LifetimePosition::MaxPosition()",
          "new_text": "current->representation()",
          "old_line_content": "    use_pos[i] = block_pos[i] = LifetimePosition::MaxPosition();",
          "new_line_content": "  MachineRepresentation rep = current->representation();",
          "content_same": false
        },
        {
          "line": 3154,
          "old_api": "active_live_ranges",
          "new_api": "GetFPRegisterSet",
          "old_text": "active_live_ranges()",
          "new_text": "GetFPRegisterSet(rep, &num_regs, &num_codes, &codes)",
          "old_line_content": "  for (LiveRange* range : active_live_ranges()) {",
          "new_line_content": "    GetFPRegisterSet(rep, &num_regs, &num_codes, &codes);",
          "content_same": false
        },
        {
          "line": 3166,
          "old_api": "Start",
          "new_api": "assigned_register",
          "old_text": "current->Start()",
          "new_text": "range->assigned_register()",
          "old_line_content": "            range->NextLifetimePositionRegisterIsBeneficial(current->Start());",
          "new_line_content": "    int cur_reg = range->assigned_register();",
          "content_same": false
        },
        {
          "line": 3172,
          "old_api": "DCHECK",
          "new_api": "LifetimePosition::GapFromInstructionIndex(0)",
          "old_text": "DCHECK(aliases > 0 || (aliases == 0 && alias_base_index == -1))",
          "new_text": "LifetimePosition::GapFromInstructionIndex(0)",
          "old_line_content": "      DCHECK(aliases > 0 || (aliases == 0 && alias_base_index == -1));",
          "new_line_content": "            LifetimePosition::GapFromInstructionIndex(0);",
          "content_same": false
        },
        {
          "line": 3177,
          "old_api": "LifetimePosition::GapFromInstructionIndex(0)",
          "new_api": "Start",
          "old_text": "LifetimePosition::GapFromInstructionIndex(0)",
          "new_text": "current->Start()",
          "old_line_content": "              LifetimePosition::GapFromInstructionIndex(0);",
          "new_line_content": "            range->NextLifetimePositionRegisterIsBeneficial(current->Start());",
          "content_same": false
        },
        {
          "line": 3181,
          "old_api": "NextLifetimePositionRegisterIsBeneficial",
          "new_api": "config",
          "old_text": "range->NextLifetimePositionRegisterIsBeneficial(\n                      current->Start())",
          "new_text": "data()->config()->GetAliases(\n          range->representation(), cur_reg, rep, &alias_base_index)",
          "old_line_content": "                  range->NextLifetimePositionRegisterIsBeneficial(",
          "new_line_content": "      int aliases = data()->config()->GetAliases(",
          "content_same": false
        },
        {
          "line": 3182,
          "old_api": "Start",
          "new_api": "representation",
          "old_text": "current->Start()",
          "new_text": "range->representation()",
          "old_line_content": "                      current->Start()));",
          "new_line_content": "          range->representation(), cur_reg, rep, &alias_base_index);",
          "content_same": false
        },
        {
          "line": 3188,
          "old_api": "inactive_live_ranges",
          "new_api": "LifetimePosition::GapFromInstructionIndex(0)",
          "old_text": "inactive_live_ranges()",
          "new_text": "LifetimePosition::GapFromInstructionIndex(0)",
          "old_line_content": "  for (LiveRange* range : inactive_live_ranges()) {",
          "new_line_content": "              LifetimePosition::GapFromInstructionIndex(0);",
          "content_same": false
        },
        {
          "line": 3191,
          "old_api": "TopLevel",
          "new_api": "NextLifetimePositionRegisterIsBeneficial",
          "old_text": "range->TopLevel()->IsFixed()",
          "new_text": "Min(block_pos[aliased_reg],\n                  range->NextLifetimePositionRegisterIsBeneficial(\n                      current->Start()))",
          "old_line_content": "    bool is_fixed = range->TopLevel()->IsFixed();",
          "new_line_content": "              Min(block_pos[aliased_reg],",
          "content_same": false
        },
        {
          "line": 3209,
          "old_api": "Min",
          "new_api": "Start",
          "old_text": "Min(block_pos[cur_reg], next_intersection)",
          "new_text": "range->Start()",
          "old_line_content": "        block_pos[cur_reg] = Min(block_pos[cur_reg], next_intersection);",
          "new_line_content": "        if (block_pos[cur_reg] < range->Start()) continue;",
          "content_same": false
        },
        {
          "line": 3216,
          "old_api": "config",
          "new_api": "IsValid",
          "old_text": "data()->config()->GetAliases(\n          range->representation(), cur_reg, rep, &alias_base_index)",
          "new_text": "next_intersection.IsValid()",
          "old_line_content": "      int aliases = data()->config()->GetAliases(",
          "new_line_content": "    if (!next_intersection.IsValid()) continue;",
          "content_same": false
        },
        {
          "line": 3218,
          "old_api": "DCHECK",
          "new_api": "check_fp_aliasing",
          "old_text": "DCHECK(aliases > 0 || (aliases == 0 && alias_base_index == -1))",
          "new_text": "check_fp_aliasing()",
          "old_line_content": "      DCHECK(aliases > 0 || (aliases == 0 && alias_base_index == -1));",
          "new_line_content": "    if (kSimpleFPAliasing || !check_fp_aliasing()) {",
          "content_same": false
        },
        {
          "line": 3227,
          "old_api": "Min",
          "new_api": "config",
          "old_text": "Min(use_pos[aliased_reg], next_intersection)",
          "new_text": "data()->config()->GetAliases(\n          range->representation(), cur_reg, rep, &alias_base_index)",
          "old_line_content": "          use_pos[aliased_reg] = Min(use_pos[aliased_reg], next_intersection);",
          "new_line_content": "      int aliases = data()->config()->GetAliases(",
          "content_same": false
        },
        {
          "line": 3257,
          "old_api": "Start",
          "new_api": "pos",
          "old_text": "block_pos[reg].Start()",
          "new_text": "register_use->pos()",
          "old_line_content": "        SplitBetween(current, current->Start(), block_pos[reg].Start());",
          "new_line_content": "      SpillBetween(current, current->Start(), register_use->pos());",
          "content_same": false
        },
        {
          "line": 3264,
          "old_api": "relative_id",
          "new_api": "End",
          "old_text": "current->relative_id()",
          "new_text": "current->End()",
          "old_line_content": "        current->TopLevel()->vreg(), current->relative_id());",
          "new_line_content": "  if (block_pos[reg] < current->End()) {",
          "content_same": false
        },
        {
          "line": 3275,
          "old_api": "HasRegisterAssigned",
          "new_api": "relative_id",
          "old_text": "current->HasRegisterAssigned()",
          "new_text": "current->relative_id()",
          "old_line_content": "  DCHECK(current->HasRegisterAssigned());",
          "new_line_content": "        current->TopLevel()->vreg(), current->relative_id());",
          "content_same": false
        },
        {
          "line": 3276,
          "old_api": "assigned_register",
          "new_api": "SetLiveRangeAssignedRegister",
          "old_text": "current->assigned_register()",
          "new_text": "SetLiveRangeAssignedRegister(current, reg)",
          "old_line_content": "  int reg = current->assigned_register();",
          "new_line_content": "  SetLiveRangeAssignedRegister(current, reg);",
          "content_same": false
        },
        {
          "line": 3281,
          "old_api": "assigned_register",
          "new_api": "SplitAndSpillIntersecting",
          "old_text": "range->assigned_register()",
          "new_text": "SplitAndSpillIntersecting(current)",
          "old_line_content": "      if (range->assigned_register() != reg) continue;",
          "new_line_content": "  SplitAndSpillIntersecting(current);",
          "content_same": false
        },
        {
          "line": 3290,
          "old_api": "Start",
          "new_api": "active_live_ranges",
          "old_text": "current->Start()",
          "new_text": "active_live_ranges()",
          "old_line_content": "    UsePosition* next_pos = range->NextRegisterPosition(current->Start());",
          "new_line_content": "    LiveRange* range = active_live_ranges()[i];",
          "content_same": false
        },
        {
          "line": 3291,
          "old_api": "FindOptimalSpillingPos",
          "new_api": "check_fp_aliasing",
          "old_text": "FindOptimalSpillingPos(range, split_pos)",
          "new_text": "check_fp_aliasing()",
          "old_line_content": "    LifetimePosition spill_pos = FindOptimalSpillingPos(range, split_pos);",
          "new_line_content": "    if (kSimpleFPAliasing || !check_fp_aliasing()) {",
          "content_same": false
        },
        {
          "line": 3304,
          "old_api": "pos",
          "new_api": "SpillAfter",
          "old_text": "next_pos->pos()",
          "new_text": "SpillAfter(range, spill_pos)",
          "old_line_content": "                                                        next_pos->pos()));",
          "new_line_content": "      SpillAfter(range, spill_pos);",
          "content_same": false
        },
        {
          "line": 3314,
          "old_api": "TopLevel",
          "new_api": "Start",
          "old_text": "range->TopLevel()->IsFixed()",
          "new_text": "current->Start()",
          "old_line_content": "    if (range->TopLevel()->IsFixed()) continue;",
          "new_line_content": "      DCHECK(LifetimePosition::ExistsGapPositionBetween(current->Start(),",
          "content_same": false
        },
        {
          "line": 3315,
          "old_api": "check_fp_aliasing",
          "new_api": "pos",
          "old_text": "check_fp_aliasing()",
          "new_text": "next_pos->pos()",
          "old_line_content": "    if (kSimpleFPAliasing || !check_fp_aliasing()) {",
          "new_line_content": "                                                        next_pos->pos()));",
          "content_same": false
        },
        {
          "line": 3316,
          "old_api": "assigned_register",
          "new_api": "pos",
          "old_text": "range->assigned_register()",
          "new_text": "next_pos->pos()",
          "old_line_content": "      if (range->assigned_register() != reg) continue;",
          "new_line_content": "      SpillBetweenUntil(range, spill_pos, current->Start(), next_pos->pos());",
          "content_same": false
        },
        {
          "line": 3318,
          "old_api": "representation",
          "new_api": "ActiveToHandled",
          "old_text": "current->representation()",
          "new_text": "ActiveToHandled(range)",
          "old_line_content": "      if (!data()->config()->AreAliases(current->representation(), reg,",
          "new_line_content": "    ActiveToHandled(range);",
          "content_same": false
        },
        {
          "line": 3324,
          "old_api": "FirstIntersection",
          "new_api": "Start",
          "old_text": "range->FirstIntersection(current)",
          "new_text": "current->Start()",
          "old_line_content": "    LifetimePosition next_intersection = range->FirstIntersection(current);",
          "new_line_content": "    DCHECK(range->End() > current->Start());",
          "content_same": false
        },
        {
          "line": 3325,
          "old_api": "IsValid",
          "new_api": "TopLevel",
          "old_text": "next_intersection.IsValid()",
          "new_text": "range->TopLevel()->IsFixed()",
          "old_line_content": "    if (next_intersection.IsValid()) {",
          "new_line_content": "    if (range->TopLevel()->IsFixed()) continue;",
          "content_same": false
        },
        {
          "line": 3326,
          "old_api": "Start",
          "new_api": "check_fp_aliasing",
          "old_text": "current->Start()",
          "new_text": "check_fp_aliasing()",
          "old_line_content": "      UsePosition* next_pos = range->NextRegisterPosition(current->Start());",
          "new_line_content": "    if (kSimpleFPAliasing || !check_fp_aliasing()) {",
          "content_same": false
        },
        {
          "line": 3330,
          "old_api": "pos",
          "new_api": "representation",
          "old_text": "next_pos->pos()",
          "new_text": "range->representation()",
          "old_line_content": "        next_intersection = Min(next_intersection, next_pos->pos());",
          "new_line_content": "                                        range->representation(),",
          "content_same": false
        },
        {
          "line": 3331,
          "old_api": "SpillBetween",
          "new_api": "assigned_register",
          "old_text": "SpillBetween(range, split_pos, next_intersection)",
          "new_text": "range->assigned_register()",
          "old_line_content": "        SpillBetween(range, split_pos, next_intersection);",
          "new_line_content": "                                        range->assigned_register()))",
          "content_same": false
        },
        {
          "line": 3341,
          "old_api": "is_phi",
          "new_api": "pos",
          "old_text": "range->is_phi()",
          "new_text": "next_pos->pos()",
          "old_line_content": "  if (!range->is_phi()) return false;",
          "new_line_content": "        next_intersection = Min(next_intersection, next_pos->pos());",
          "content_same": false
        },
        {
          "line": 3352,
          "old_api": "operands",
          "new_api": "is_phi",
          "old_text": "phi->operands()",
          "new_text": "range->is_phi()",
          "old_line_content": "    int op = phi->operands()[i];",
          "new_line_content": "  if (!range->is_phi()) return false;",
          "content_same": false
        },
        {
          "line": 3354,
          "old_api": "TopLevel",
          "new_api": "HasSpillOperand",
          "old_text": "op_range->TopLevel()->HasSpillRange()",
          "new_text": "range->HasSpillOperand()",
          "old_line_content": "    if (!op_range->TopLevel()->HasSpillRange()) continue;",
          "new_line_content": "  DCHECK(!range->HasSpillOperand());",
          "content_same": false
        },
        {
          "line": 3356,
          "old_api": "predecessors",
          "new_api": "GetPhiMapValueFor",
          "old_text": "block->predecessors()",
          "new_text": "data()->GetPhiMapValueFor(range)",
          "old_line_content": "        code()->InstructionBlockAt(block->predecessors()[i]);",
          "new_line_content": "      data()->GetPhiMapValueFor(range);",
          "content_same": false
        },
        {
          "line": 3358,
          "old_api": "last_instruction_index",
          "new_api": "block",
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(\n            pred->last_instruction_index())",
          "new_text": "phi_map_value->block()",
          "old_line_content": "        LifetimePosition::InstructionFromInstructionIndex(",
          "new_line_content": "  const InstructionBlock* block = phi_map_value->block();",
          "content_same": false
        },
        {
          "line": 3363,
          "old_api": "spilled",
          "new_api": "operands",
          "old_text": "op_range->spilled()",
          "new_text": "phi->operands()",
          "old_line_content": "    if (op_range != nullptr && op_range->spilled()) {",
          "new_line_content": "    int op = phi->operands()[i];",
          "content_same": false
        },
        {
          "line": 3372,
          "old_api": "size",
          "new_api": "next",
          "old_text": "phi->operands().size()",
          "new_text": "op_range->next()",
          "old_line_content": "  if (spilled_count * 2 <= phi->operands().size()) {",
          "new_line_content": "      op_range = op_range->next();",
          "content_same": false
        },
        {
          "line": 3383,
          "old_api": "live_ranges",
          "new_api": "size",
          "old_text": "data()->live_ranges()",
          "new_text": "phi->operands().size()",
          "old_line_content": "    TopLevelLiveRange* op_range = data()->live_ranges()[op];",
          "new_line_content": "  if (spilled_count * 2 <= phi->operands().size()) {",
          "content_same": false
        },
        {
          "line": 3393,
          "old_api": "size",
          "new_api": "operands",
          "old_text": "phi->operands().size()",
          "new_text": "phi->operands()",
          "old_line_content": "  if (num_merged * 2 <= phi->operands().size() ||",
          "new_line_content": "    int op = phi->operands()[i];",
          "content_same": false
        },
        {
          "line": 3394,
          "old_api": "interval",
          "new_api": "live_ranges",
          "old_text": "first_op_spill->interval()",
          "new_text": "data()->live_ranges()",
          "old_line_content": "      AreUseIntervalsIntersecting(first_op_spill->interval(),",
          "new_line_content": "    TopLevelLiveRange* op_range = data()->live_ranges()[op];",
          "content_same": false
        },
        {
          "line": 3395,
          "old_api": "first_interval",
          "new_api": "HasSpillRange",
          "old_text": "range->first_interval()",
          "new_text": "op_range->HasSpillRange()",
          "old_line_content": "                                  range->first_interval())) {",
          "new_line_content": "    if (!op_range->HasSpillRange()) continue;",
          "content_same": false
        },
        {
          "line": 3406,
          "old_api": "TopLevel",
          "new_api": "first_interval",
          "old_text": "range->TopLevel()->HasSpillRange()",
          "new_text": "range->first_interval()",
          "old_line_content": "        range->TopLevel()->HasSpillRange()",
          "new_line_content": "                                  range->first_interval())) {",
          "content_same": false
        },
        {
          "line": 3418,
          "old_api": "TryMerge",
          "new_api": "TopLevel",
          "old_text": "first_op_spill->TryMerge(spill_range)",
          "new_text": "range->TopLevel()->GetSpillRange()",
          "old_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "new_line_content": "            ? range->TopLevel()->GetSpillRange()",
          "content_same": false
        },
        {
          "line": 3420,
          "old_api": "pos",
          "new_api": "TryMerge",
          "old_text": "pos->pos()",
          "new_text": "first_op_spill->TryMerge(spill_range)",
          "old_line_content": "    SpillBetween(range, range->Start(), pos->pos());",
          "new_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "content_same": false
        },
        {
          "line": 3428,
          "old_api": "SplitRangeAt",
          "new_api": "TopLevel",
          "old_text": "SplitRangeAt(range, pos)",
          "new_text": "range->TopLevel()",
          "old_line_content": "  LiveRange* second_part = SplitRangeAt(range, pos);",
          "new_line_content": "            : data()->AssignSpillRangeToLiveRange(range->TopLevel());",
          "content_same": false
        },
        {
          "line": 3429,
          "old_api": "Spill",
          "new_api": "TryMerge",
          "old_text": "Spill(second_part)",
          "new_text": "first_op_spill->TryMerge(spill_range)",
          "old_line_content": "  Spill(second_part);",
          "new_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "content_same": false
        },
        {
          "line": 3446,
          "old_api": "Start",
          "new_api": "SpillBetweenUntil",
          "old_text": "second_part->Start()",
          "new_text": "SpillBetweenUntil(range, start, start, end)",
          "old_line_content": "  if (second_part->Start() < end) {",
          "new_line_content": "  SpillBetweenUntil(range, start, start, end);",
          "content_same": false
        },
        {
          "line": 3454,
          "old_api": "End",
          "new_api": "CHECK",
          "old_text": "SplitBetween(\n        second_part, Max(second_part->Start().End(), until), third_part_end)",
          "new_text": "CHECK(start < end)",
          "old_line_content": "    LiveRange* third_part = SplitBetween(",
          "new_line_content": "  CHECK(start < end);",
          "content_same": false
        },
        {
          "line": 3455,
          "old_api": "End",
          "new_api": "SplitRangeAt",
          "old_text": "second_part->Start().End()",
          "new_text": "SplitRangeAt(range, start)",
          "old_line_content": "        second_part, Max(second_part->Start().End(), until), third_part_end);",
          "new_line_content": "  LiveRange* second_part = SplitRangeAt(range, start);",
          "content_same": false
        },
        {
          "line": 3457,
          "old_api": "DCHECK",
          "new_api": "Start",
          "old_text": "DCHECK(third_part != second_part)",
          "new_text": "second_part->Start()",
          "old_line_content": "    DCHECK(third_part != second_part);",
          "new_line_content": "  if (second_part->Start() < end) {",
          "content_same": false
        },
        {
          "line": 3475,
          "old_api": "size",
          "new_api": "AddToUnhandled",
          "old_text": "data()->live_ranges().size()",
          "new_text": "AddToUnhandled(second_part)",
          "old_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "new_line_content": "    AddToUnhandled(second_part);",
          "content_same": false
        },
        {
          "line": 3485,
          "old_api": "GetSpillMoveInsertionLocations",
          "new_api": "code",
          "old_text": "range->GetSpillMoveInsertionLocations()",
          "new_text": "data()->code()",
          "old_line_content": "        range->GetSpillMoveInsertionLocations();",
          "new_line_content": "  const InstructionSequence* code = data()->code();",
          "content_same": false
        },
        {
          "line": 3486,
          "old_api": "DCHECK_NOT_NULL",
          "new_api": "size",
          "old_text": "DCHECK_NOT_NULL(spills)",
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "    DCHECK_NOT_NULL(spills);",
          "new_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "content_same": false
        },
        {
          "line": 3488,
          "old_api": "GetInstructionBlock",
          "new_api": "size",
          "old_text": "code->GetInstructionBlock(spills->gap_index)->mark_needs_frame()",
          "new_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "old_line_content": "      code->GetInstructionBlock(spills->gap_index)->mark_needs_frame();",
          "new_line_content": "    CHECK_EQ(live_ranges_size,",
          "content_same": false
        },
        {
          "line": 3515,
          "old_api": "HasSlot",
          "new_api": "size",
          "old_text": "range->HasSlot()",
          "new_text": "spill_ranges.size()",
          "old_line_content": "    if (!range->HasSlot()) {",
          "new_line_content": "    for (size_t j = i + 1; j < spill_ranges.size(); ++j) {",
          "content_same": false
        },
        {
          "line": 3517,
          "old_api": "set_assigned_slot",
          "new_api": "IsEmpty",
          "old_text": "range->set_assigned_slot(index)",
          "new_text": "other->IsEmpty()",
          "old_line_content": "      range->set_assigned_slot(index);",
          "new_line_content": "      if (other != nullptr && !other->IsEmpty()) {",
          "content_same": false
        },
        {
          "line": 3524,
          "old_api": "size",
          "new_api": "IsEmpty",
          "old_text": "data()->live_ranges().size()",
          "new_text": "range->IsEmpty()",
          "old_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "new_line_content": "    if (range == nullptr || range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 3526,
          "old_api": "size",
          "new_api": "HasSlot",
          "old_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "new_text": "range->HasSlot()",
          "old_line_content": "    CHECK_EQ(live_ranges_size,",
          "new_line_content": "    if (!range->HasSlot()) {",
          "content_same": false
        },
        {
          "line": 3527,
          "old_api": "size",
          "new_api": "byte_width",
          "old_text": "data()->live_ranges().size()",
          "new_text": "range->byte_width()",
          "old_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "new_line_content": "      int index = data()->frame()->AllocateSpillSlot(range->byte_width());",
          "content_same": false
        },
        {
          "line": 3528,
          "old_api": "IsEmpty",
          "new_api": "set_assigned_slot",
          "old_text": "top_range->IsEmpty()",
          "new_text": "range->set_assigned_slot(index)",
          "old_line_content": "    if (top_range == nullptr || top_range->IsEmpty()) continue;",
          "new_line_content": "      range->set_assigned_slot(index);",
          "content_same": false
        },
        {
          "line": 3535,
          "old_api": "is_phi",
          "new_api": "size",
          "old_text": "top_range->is_phi()",
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "    if (top_range->is_phi()) {",
          "new_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "content_same": false
        },
        {
          "line": 3536,
          "old_api": "GetPhiMapValueFor",
          "new_api": "live_ranges",
          "old_text": "data()->GetPhiMapValueFor(top_range)->CommitAssignment(\n          top_range->GetAssignedOperand())",
          "new_text": "data()->live_ranges()",
          "old_line_content": "      data()->GetPhiMapValueFor(top_range)->CommitAssignment(",
          "new_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3537,
          "old_api": "GetAssignedOperand",
          "new_api": "size",
          "old_text": "top_range->GetAssignedOperand()",
          "new_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "old_line_content": "          top_range->GetAssignedOperand());",
          "new_line_content": "    CHECK_EQ(live_ranges_size,",
          "content_same": false
        },
        {
          "line": 3541,
          "old_api": "GetAssignedOperand",
          "new_api": "HasSpillOperand",
          "old_text": "range->GetAssignedOperand()",
          "new_text": "top_range->HasSpillOperand()",
          "old_line_content": "      InstructionOperand assigned = range->GetAssignedOperand();",
          "new_line_content": "    if (top_range->HasSpillOperand()) {",
          "content_same": false
        },
        {
          "line": 3542,
          "old_api": "IsUnallocated",
          "new_api": "TopLevel",
          "old_text": "assigned.IsUnallocated()",
          "new_text": "top_range->TopLevel()->GetSpillOperand()",
          "old_line_content": "      DCHECK(!assigned.IsUnallocated());",
          "new_line_content": "      spill_operand = *top_range->TopLevel()->GetSpillOperand();",
          "content_same": false
        },
        {
          "line": 3543,
          "old_api": "ConvertUsesToOperand",
          "new_api": "TopLevel",
          "old_text": "range->ConvertUsesToOperand(assigned, spill_operand)",
          "new_text": "top_range->TopLevel()->HasSpillRange()",
          "old_line_content": "      range->ConvertUsesToOperand(assigned, spill_operand);",
          "new_line_content": "    } else if (top_range->TopLevel()->HasSpillRange()) {",
          "content_same": false
        },
        {
          "line": 3546,
          "old_api": "IsInvalid",
          "new_api": "is_phi",
          "old_text": "spill_operand.IsInvalid()",
          "new_text": "top_range->is_phi()",
          "old_line_content": "    if (!spill_operand.IsInvalid()) {",
          "new_line_content": "    if (top_range->is_phi()) {",
          "content_same": false
        },
        {
          "line": 3557,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": "IsInvalid",
          "old_text": "top_range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": "spill_operand.IsInvalid()",
          "old_line_content": "      if (!top_range->IsSpilledOnlyInDeferredBlocks()) {",
          "new_line_content": "    if (!spill_operand.IsInvalid()) {",
          "content_same": false
        },
        {
          "line": 3587,
          "old_api": "delayed_references",
          "new_api": "instruction_position",
          "old_text": "data()->delayed_references()",
          "new_text": "map->instruction_position()",
          "old_line_content": "       data()->delayed_references()) {",
          "new_line_content": "    if (safe_point > map->instruction_position()) return false;",
          "content_same": false
        },
        {
          "line": 3588,
          "old_api": "RecordReference",
          "new_api": "instruction_position",
          "old_text": "delayed_reference.map->RecordReference(\n        AllocatedOperand::cast(*delayed_reference.operand))",
          "new_text": "map->instruction_position()",
          "old_line_content": "    delayed_reference.map->RecordReference(",
          "new_line_content": "    safe_point = map->instruction_position();",
          "content_same": false
        },
        {
          "line": 3595,
          "old_api": "begin",
          "new_api": "SafePointsAreInOrder",
          "old_text": "reference_maps->begin()",
          "new_text": "SafePointsAreInOrder()",
          "old_line_content": "  ReferenceMapDeque::const_iterator first_it = reference_maps->begin();",
          "new_line_content": "  DCHECK(SafePointsAreInOrder());",
          "content_same": false
        },
        {
          "line": 3598,
          "old_api": "size",
          "new_api": "delayed_references",
          "old_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "new_text": "data()->delayed_references()",
          "old_line_content": "    CHECK_EQ(live_ranges_size,",
          "new_line_content": "       data()->delayed_references()) {",
          "content_same": false
        },
        {
          "line": 3599,
          "old_api": "size",
          "new_api": "RecordReference",
          "old_text": "data()->live_ranges().size()",
          "new_text": "delayed_reference.map->RecordReference(\n        AllocatedOperand::cast(*delayed_reference.operand))",
          "old_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "new_line_content": "    delayed_reference.map->RecordReference(",
          "content_same": false
        },
        {
          "line": 3605,
          "old_api": "has_preassigned_slot",
          "new_api": "code",
          "old_text": "range->has_preassigned_slot()",
          "new_text": "data()->code()->reference_maps()",
          "old_line_content": "    if (range->has_preassigned_slot()) continue;",
          "new_line_content": "  const ReferenceMapDeque* reference_maps = data()->code()->reference_maps();",
          "content_same": false
        },
        {
          "line": 3608,
          "old_api": "ToInstructionIndex",
          "new_api": "live_ranges",
          "old_text": "range->Start().ToInstructionIndex()",
          "new_text": "data()->live_ranges()",
          "old_line_content": "    int start = range->Start().ToInstructionIndex();",
          "new_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3610,
          "old_api": "next",
          "new_api": "size",
          "old_text": "cur->next()",
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "    for (LiveRange* cur = range; cur != nullptr; cur = cur->next()) {",
          "new_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "content_same": false
        },
        {
          "line": 3613,
          "old_api": "ToInstructionIndex",
          "new_api": "IsReference",
          "old_text": "this_end.ToInstructionIndex()",
          "new_text": "data()->IsReference(range)",
          "old_line_content": "        end = this_end.ToInstructionIndex();",
          "new_line_content": "    if (!data()->IsReference(range)) continue;",
          "content_same": false
        },
        {
          "line": 3619,
          "old_api": "begin",
          "new_api": "ToInstructionIndex",
          "old_text": "reference_maps->begin()",
          "new_text": "range->Start().ToInstructionIndex()",
          "old_line_content": "    if (start < last_range_start) first_it = reference_maps->begin();",
          "new_line_content": "    int start = range->Start().ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 3624,
          "old_api": "end",
          "new_api": "ToInstructionIndex",
          "old_text": "reference_maps->end()",
          "new_text": "this_end.ToInstructionIndex()",
          "old_line_content": "    for (; first_it != reference_maps->end(); ++first_it) {",
          "new_line_content": "        end = this_end.ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 3630,
          "old_api": "HasSpillOperand",
          "new_api": "begin",
          "old_text": "range->HasSpillOperand()",
          "new_text": "reference_maps->begin()",
          "old_line_content": "    if (((range->HasSpillOperand() &&",
          "new_line_content": "    if (start < last_range_start) first_it = reference_maps->begin();",
          "content_same": false
        },
        {
          "line": 3645,
          "old_api": "end",
          "new_api": "GetSpillOperand",
          "old_text": "reference_maps->end()",
          "new_text": "range->GetSpillOperand()",
          "old_line_content": "    for (auto it = first_it; it != reference_maps->end(); ++it) {",
          "new_line_content": "        spill_operand = *range->GetSpillOperand();",
          "content_same": false
        },
        {
          "line": 3647,
          "old_api": "instruction_position",
          "new_api": "GetSpillRangeOperand",
          "old_text": "map->instruction_position()",
          "new_text": "range->GetSpillRangeOperand()",
          "old_line_content": "      int safe_point = map->instruction_position();",
          "new_line_content": "        spill_operand = range->GetSpillRangeOperand();",
          "content_same": false
        },
        {
          "line": 3695,
          "old_api": "value",
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": "TRACE(\n            \"Pointer in register for range %d:%d (start at %d) \"\n            \"at safe point %d\\n\",\n            range->vreg(), cur->relative_id(), cur->Start().value(),\n            safe_point)",
          "new_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "        TRACE(",
          "new_line_content": "      int spill_index = range->IsSpilledOnlyInDeferredBlocks()",
          "content_same": false
        },
        {
          "line": 3700,
          "old_api": "GetAssignedOperand",
          "new_api": "vreg",
          "old_text": "cur->GetAssignedOperand()",
          "new_text": "TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",\n              range->vreg(), spill_index, safe_point)",
          "old_line_content": "        InstructionOperand operand = cur->GetAssignedOperand();",
          "new_line_content": "        TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",",
          "content_same": false
        },
        {
          "line": 3701,
          "old_api": "IsStackSlot",
          "new_api": "vreg",
          "old_text": "operand.IsStackSlot()",
          "new_text": "range->vreg()",
          "old_line_content": "        DCHECK(!operand.IsStackSlot());",
          "new_line_content": "              range->vreg(), spill_index, safe_point);",
          "content_same": false
        },
        {
          "line": 3702,
          "old_api": "representation",
          "new_api": "AllocatedOperand::cast(spill_operand)",
          "old_text": "CanBeTaggedPointer(\n            AllocatedOperand::cast(operand).representation())",
          "new_text": "AllocatedOperand::cast(spill_operand)",
          "old_line_content": "        DCHECK(CanBeTaggedPointer(",
          "new_line_content": "        map->RecordReference(AllocatedOperand::cast(spill_operand));",
          "content_same": false
        },
        {
          "line": 3728,
          "old_api": "ToInt",
          "new_api": "PredecessorCount",
          "old_text": "block->rpo_number().ToInt()",
          "new_text": "block->PredecessorCount()",
          "old_line_content": "    BitVector* live = live_in_sets[block->rpo_number().ToInt()];",
          "new_line_content": "  if (block->PredecessorCount() != 1) return false;",
          "content_same": false
        },
        {
          "line": 3736,
          "old_api": "FindConnectableSubranges",
          "new_api": "live_in_sets",
          "old_text": "array->FindConnectableSubranges(block, pred_block, &result)",
          "new_text": "data()->live_in_sets()",
          "old_line_content": "        if (!array->FindConnectableSubranges(block, pred_block, &result)) {",
          "new_line_content": "  ZoneVector<BitVector*>& live_in_sets = data()->live_in_sets();",
          "content_same": false
        },
        {
          "line": 3739,
          "old_api": "GetAssignedOperand",
          "new_api": "ToInt",
          "old_text": "result.pred_cover_->GetAssignedOperand()",
          "new_text": "block->rpo_number().ToInt()",
          "old_line_content": "        InstructionOperand pred_op = result.pred_cover_->GetAssignedOperand();",
          "new_line_content": "    BitVector* live = live_in_sets[block->rpo_number().ToInt()];",
          "content_same": false
        },
        {
          "line": 3741,
          "old_api": "Equals",
          "new_api": "Done",
          "old_text": "pred_op.Equals(cur_op)",
          "new_text": "iterator.Done()",
          "old_line_content": "        if (pred_op.Equals(cur_op)) continue;",
          "new_line_content": "    while (!iterator.Done()) {",
          "content_same": false
        },
        {
          "line": 3742,
          "old_api": "IsAnyRegister",
          "new_api": "Current",
          "old_text": "cur_op.IsAnyRegister()",
          "new_text": "iterator.Current()",
          "old_line_content": "        if (!pred_op.IsAnyRegister() && cur_op.IsAnyRegister()) {",
          "new_line_content": "      int vreg = iterator.Current();",
          "content_same": false
        },
        {
          "line": 3751,
          "old_api": "code_end",
          "new_api": "GetAssignedOperand",
          "old_text": "block->code_end()",
          "new_text": "result.cur_cover_->GetAssignedOperand()",
          "old_line_content": "              LifetimePosition::GapFromInstructionIndex(block->code_end());",
          "new_line_content": "        InstructionOperand cur_op = result.cur_cover_->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3753,
          "old_api": "next",
          "new_api": "IsAnyRegister",
          "old_text": "current->next()",
          "new_text": "cur_op.IsAnyRegister()",
          "old_line_content": "          const LiveRange* successor = current->next();",
          "new_line_content": "        if (!pred_op.IsAnyRegister() && cur_op.IsAnyRegister()) {",
          "content_same": false
        },
        {
          "line": 3760,
          "old_api": "NextUsePosition",
          "new_api": "code_start",
          "old_text": "current->NextUsePosition(block_start)",
          "new_text": "block->code_start()",
          "old_line_content": "            for (const UsePosition* use = current->NextUsePosition(block_start);",
          "new_line_content": "              LifetimePosition::GapFromInstructionIndex(block->code_start());",
          "content_same": false
        },
        {
          "line": 3762,
          "old_api": "operand",
          "new_api": "code_end",
          "old_text": "use->operand()->IsAnyRegister()",
          "new_text": "block->code_end()",
          "old_line_content": "              if (use->operand()->IsAnyRegister()) {",
          "new_line_content": "              LifetimePosition::GapFromInstructionIndex(block->code_end());",
          "content_same": false
        },
        {
          "line": 3773,
          "old_api": "ToInt",
          "new_api": "operand",
          "old_text": "current->TopLevel()->GetListOfBlocksRequiringSpillOperands()->Add(\n                pred_block->rpo_number().ToInt())",
          "new_text": "use->operand()->IsAnyRegister()",
          "old_line_content": "            current->TopLevel()->GetListOfBlocksRequiringSpillOperands()->Add(",
          "new_line_content": "              if (use->operand()->IsAnyRegister()) {",
          "content_same": false
        },
        {
          "line": 3781,
          "old_api": "IsAnyRegister",
          "new_api": "IsDeferred",
          "old_text": "cur_op.IsAnyRegister()",
          "new_text": "pred_block->IsDeferred()",
          "old_line_content": "                !(pred_op.IsAnyRegister() && cur_op.IsAnyRegister()),",
          "new_line_content": "              pred_block->IsDeferred()) {",
          "content_same": false
        },
        {
          "line": 3784,
          "old_api": "Advance",
          "new_api": "ToInt",
          "old_text": "iterator.Advance()",
          "new_text": "current->TopLevel()->GetListOfBlocksRequiringSpillOperands()->Add(\n                pred_block->rpo_number().ToInt())",
          "old_line_content": "      iterator.Advance();",
          "new_line_content": "            current->TopLevel()->GetListOfBlocksRequiringSpillOperands()->Add(",
          "content_same": false
        },
        {
          "line": 3791,
          "old_api": "size",
          "new_api": "TopLevel",
          "old_text": "data()->live_ranges().size()",
          "new_text": "result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "new_line_content": "            result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&",
          "content_same": false
        },
        {
          "line": 3792,
          "old_api": "live_ranges",
          "new_api": "IsAnyRegister",
          "old_text": "data()->live_ranges()",
          "new_text": "cur_op.IsAnyRegister()",
          "old_line_content": "  for (TopLevelLiveRange* top : data()->live_ranges()) {",
          "new_line_content": "                !(pred_op.IsAnyRegister() && cur_op.IsAnyRegister()),",
          "content_same": false
        },
        {
          "line": 3793,
          "old_api": "size",
          "new_api": "GetInstructionBlock",
          "old_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "new_text": "code()->GetInstructionBlock(move_loc)->IsDeferred()",
          "old_line_content": "    CHECK_EQ(live_ranges_size,",
          "new_line_content": "            code()->GetInstructionBlock(move_loc)->IsDeferred());",
          "content_same": false
        },
        {
          "line": 3795,
          "old_api": "IsEmpty",
          "new_api": "Advance",
          "old_text": "top->IsEmpty()",
          "new_text": "iterator.Advance()",
          "old_line_content": "    if (top == nullptr || top->IsEmpty() ||",
          "new_line_content": "      iterator.Advance();",
          "content_same": false
        },
        {
          "line": 3807,
          "old_api": "Equals",
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": "pred_op.Equals(cur_op)",
          "new_text": "top->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "  DCHECK(!pred_op.Equals(cur_op));",
          "new_line_content": "        !top->IsSpilledOnlyInDeferredBlocks())",
          "content_same": false
        },
        {
          "line": 3818,
          "old_api": "last_instruction_index",
          "new_api": "Equals",
          "old_text": "pred->last_instruction_index()",
          "new_text": "pred_op.Equals(cur_op)",
          "old_line_content": "    gap_index = pred->last_instruction_index();",
          "new_line_content": "  DCHECK(!pred_op.Equals(cur_op));",
          "content_same": false
        },
        {
          "line": 3821,
          "old_api": "AddGapMove",
          "new_api": "PredecessorCount",
          "old_text": "data()->AddGapMove(gap_index, position, pred_op, cur_op)",
          "new_text": "block->PredecessorCount()",
          "old_line_content": "  data()->AddGapMove(gap_index, position, pred_op, cur_op);",
          "new_line_content": "  if (block->PredecessorCount() == 1) {",
          "content_same": false
        },
        {
          "line": 3827,
          "old_api": "size",
          "new_api": "last_instruction_index",
          "old_text": "data()->live_ranges().size()",
          "new_text": "pred->last_instruction_index()",
          "old_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "new_line_content": "                ->InstructionAt(pred->last_instruction_index())",
          "content_same": false
        },
        {
          "line": 3829,
          "old_api": "size",
          "new_api": "last_instruction_index",
          "old_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "new_text": "pred->last_instruction_index()",
          "old_line_content": "    CHECK_EQ(live_ranges_size,",
          "new_line_content": "    gap_index = pred->last_instruction_index();",
          "content_same": false
        },
        {
          "line": 3832,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": "AddGapMove",
          "old_text": "top_range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": "data()->AddGapMove(gap_index, position, pred_op, cur_op)",
          "old_line_content": "    bool connect_spilled = top_range->IsSpilledOnlyInDeferredBlocks();",
          "new_line_content": "  data()->AddGapMove(gap_index, position, pred_op, cur_op);",
          "content_same": false
        },
        {
          "line": 3839,
          "old_api": "spilled",
          "new_api": "live_ranges",
          "old_text": "second_range->spilled()",
          "new_text": "data()->live_ranges()",
          "old_line_content": "      if (second_range->spilled()) continue;",
          "new_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3840,
          "old_api": "End",
          "new_api": "size",
          "old_text": "first_range->End()",
          "new_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "old_line_content": "      if (first_range->End() != pos) continue;",
          "new_line_content": "    CHECK_EQ(live_ranges_size,",
          "content_same": false
        },
        {
          "line": 3841,
          "old_api": "IsBlockBoundary",
          "new_api": "size",
          "old_text": "data()->IsBlockBoundary(pos)",
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "      if (data()->IsBlockBoundary(pos) &&",
          "new_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "content_same": false
        },
        {
          "line": 3845,
          "old_api": "GetAssignedOperand",
          "new_api": "next",
          "old_text": "first_range->GetAssignedOperand()",
          "new_text": "first_range->next()",
          "old_line_content": "      InstructionOperand prev_operand = first_range->GetAssignedOperand();",
          "new_line_content": "    for (LiveRange *second_range = first_range->next(); second_range != nullptr;",
          "content_same": false
        },
        {
          "line": 3846,
          "old_api": "GetAssignedOperand",
          "new_api": "next",
          "old_text": "second_range->GetAssignedOperand()",
          "new_text": "second_range->next()",
          "old_line_content": "      InstructionOperand cur_operand = second_range->GetAssignedOperand();",
          "new_line_content": "         first_range = second_range, second_range = second_range->next()) {",
          "content_same": false
        },
        {
          "line": 3847,
          "old_api": "Equals",
          "new_api": "Start",
          "old_text": "prev_operand.Equals(cur_operand)",
          "new_text": "second_range->Start()",
          "old_line_content": "      if (prev_operand.Equals(cur_operand)) continue;",
          "new_line_content": "      LifetimePosition pos = second_range->Start();",
          "content_same": false
        },
        {
          "line": 3850,
          "old_api": "ToInstructionIndex",
          "new_api": "spilled",
          "old_text": "pos.ToInstructionIndex()",
          "new_text": "second_range->spilled()",
          "old_line_content": "      int gap_index = pos.ToInstructionIndex();",
          "new_line_content": "      if (second_range->spilled()) continue;",
          "content_same": false
        },
        {
          "line": 3851,
          "old_api": "IsAnyRegister",
          "new_api": "End",
          "old_text": "prev_operand.IsAnyRegister()",
          "new_text": "first_range->End()",
          "old_line_content": "      if (connect_spilled && !prev_operand.IsAnyRegister() &&",
          "new_line_content": "      if (first_range->End() != pos) continue;",
          "content_same": false
        },
        {
          "line": 3852,
          "old_api": "IsAnyRegister",
          "new_api": "IsBlockBoundary",
          "old_text": "cur_operand.IsAnyRegister()",
          "new_text": "data()->IsBlockBoundary(pos)",
          "old_line_content": "          cur_operand.IsAnyRegister()) {",
          "new_line_content": "      if (data()->IsBlockBoundary(pos) &&",
          "content_same": false
        },
        {
          "line": 3853,
          "old_api": "GetInstructionBlock",
          "new_api": "code",
          "old_text": "code()->GetInstructionBlock(gap_index)",
          "new_text": "code()",
          "old_line_content": "        const InstructionBlock* block = code()->GetInstructionBlock(gap_index);",
          "new_line_content": "          !CanEagerlyResolveControlFlow(GetInstructionBlock(code(), pos))) {",
          "content_same": false
        },
        {
          "line": 3857,
          "old_api": "ToInt",
          "new_api": "GetAssignedOperand",
          "old_text": "top_range->GetListOfBlocksRequiringSpillOperands()->Add(\n            block->rpo_number().ToInt())",
          "new_text": "second_range->GetAssignedOperand()",
          "old_line_content": "        top_range->GetListOfBlocksRequiringSpillOperands()->Add(",
          "new_line_content": "      InstructionOperand cur_operand = second_range->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3858,
          "old_api": "ToInt",
          "new_api": "Equals",
          "old_text": "block->rpo_number().ToInt()",
          "new_text": "prev_operand.Equals(cur_operand)",
          "old_line_content": "            block->rpo_number().ToInt());",
          "new_line_content": "      if (prev_operand.Equals(cur_operand)) continue;",
          "content_same": false
        },
        {
          "line": 3861,
          "old_api": "IsGapPosition",
          "new_api": "ToInstructionIndex",
          "old_text": "pos.IsGapPosition()",
          "new_text": "pos.ToInstructionIndex()",
          "old_line_content": "      if (pos.IsGapPosition()) {",
          "new_line_content": "      int gap_index = pos.ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 3862,
          "old_api": "IsStart",
          "new_api": "IsAnyRegister",
          "old_text": "pos.IsStart()",
          "new_text": "prev_operand.IsAnyRegister()",
          "old_line_content": "        gap_pos = pos.IsStart() ? Instruction::START : Instruction::END;",
          "new_line_content": "      if (connect_spilled && !prev_operand.IsAnyRegister() &&",
          "content_same": false
        },
        {
          "line": 3864,
          "old_api": "IsStart",
          "new_api": "GetInstructionBlock",
          "old_text": "pos.IsStart()",
          "new_text": "code()->GetInstructionBlock(gap_index)",
          "old_line_content": "        if (pos.IsStart()) {",
          "new_line_content": "        const InstructionBlock* block = code()->GetInstructionBlock(gap_index);",
          "content_same": false
        },
        {
          "line": 3873,
          "old_api": "IsAnyRegister",
          "new_api": "IsStart",
          "old_text": "DCHECK_IMPLIES(\n          connect_spilled &&\n              !(prev_operand.IsAnyRegister() && cur_operand.IsAnyRegister()),\n          code()->GetInstructionBlock(gap_index)->IsDeferred())",
          "new_text": "pos.IsStart()",
          "old_line_content": "      DCHECK_IMPLIES(",
          "new_line_content": "        gap_pos = pos.IsStart() ? Instruction::START : Instruction::END;",
          "content_same": false
        },
        {
          "line": 3875,
          "old_api": "IsAnyRegister",
          "new_api": "IsStart",
          "old_text": "cur_operand.IsAnyRegister()",
          "new_text": "pos.IsStart()",
          "old_line_content": "              !(prev_operand.IsAnyRegister() && cur_operand.IsAnyRegister()),",
          "new_line_content": "        if (pos.IsStart()) {",
          "content_same": false
        },
        {
          "line": 3884,
          "old_api": "insert",
          "new_api": "IsAnyRegister",
          "old_text": "delayed_insertion_map.insert(\n            std::make_pair(std::make_pair(move, prev_operand), cur_operand))",
          "new_text": "DCHECK_IMPLIES(\n          connect_spilled &&\n              !(prev_operand.IsAnyRegister() && cur_operand.IsAnyRegister()),\n          code()->GetInstructionBlock(gap_index)->IsDeferred())",
          "old_line_content": "        delayed_insertion_map.insert(",
          "new_line_content": "      DCHECK_IMPLIES(",
          "content_same": false
        },
        {
          "line": 3893,
          "old_api": "reserve",
          "new_api": "AddMove",
          "old_text": "to_insert.reserve(4)",
          "new_text": "move->AddMove(prev_operand, cur_operand)",
          "old_line_content": "  to_insert.reserve(4);",
          "new_line_content": "        move->AddMove(prev_operand, cur_operand);",
          "content_same": false
        },
        {
          "line": 3895,
          "old_api": "begin",
          "new_api": "insert",
          "old_text": "delayed_insertion_map.begin()",
          "new_text": "delayed_insertion_map.insert(\n            std::make_pair(std::make_pair(move, prev_operand), cur_operand))",
          "old_line_content": "  ParallelMove* moves = delayed_insertion_map.begin()->first.first;",
          "new_line_content": "        delayed_insertion_map.insert(",
          "content_same": false
        },
        {
          "line": 3896,
          "old_api": "begin",
          "new_api": "std::make_pair(move, prev_operand)",
          "old_text": "delayed_insertion_map.begin()",
          "new_text": "std::make_pair(move, prev_operand)",
          "old_line_content": "  for (auto it = delayed_insertion_map.begin();; ++it) {",
          "new_line_content": "            std::make_pair(std::make_pair(move, prev_operand), cur_operand));",
          "content_same": false
        },
        {
          "line": 3904,
          "old_api": "push_back",
          "new_api": "reserve",
          "old_text": "moves->push_back(move)",
          "new_text": "to_insert.reserve(4)",
          "old_line_content": "        moves->push_back(move);",
          "new_line_content": "  to_insert.reserve(4);",
          "content_same": false
        },
        {
          "line": 3908,
          "old_api": "clear",
          "new_api": "end",
          "old_text": "to_eliminate.clear()",
          "new_text": "delayed_insertion_map.end()",
          "old_line_content": "      to_eliminate.clear();",
          "new_line_content": "    bool done = it == delayed_insertion_map.end();",
          "content_same": false
        },
        {
          "line": 3915,
          "old_api": "PrepareInsertAfter",
          "new_api": "push_back",
          "old_text": "moves->PrepareInsertAfter(move, &to_eliminate)",
          "new_text": "moves->push_back(move)",
          "old_line_content": "    moves->PrepareInsertAfter(move, &to_eliminate);",
          "new_line_content": "        moves->push_back(move);",
          "content_same": false
        },
        {
          "line": 3926,
          "old_api": "code",
          "new_api": "PrepareInsertAfter",
          "old_text": "data()->code()",
          "new_text": "moves->PrepareInsertAfter(move, &to_eliminate)",
          "old_line_content": "  InstructionSequence* code = data()->code();",
          "new_line_content": "    moves->PrepareInsertAfter(move, &to_eliminate);",
          "content_same": false
        },
        {
          "line": 3927,
          "old_api": "GetSpillRangeOperand",
          "new_api": "push_back",
          "old_text": "range->GetSpillRangeOperand()",
          "new_text": "to_insert.push_back(move)",
          "old_line_content": "  InstructionOperand spill_operand = range->GetSpillRangeOperand();",
          "new_line_content": "    to_insert.push_back(move);",
          "content_same": false
        },
        {
          "line": 3934,
          "old_api": "next",
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": "child->next()",
          "new_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "       child = child->next()) {",
          "new_line_content": "  DCHECK(range->IsSpilledOnlyInDeferredBlocks());",
          "content_same": false
        },
        {
          "line": 3935,
          "old_api": "first_pos",
          "new_api": "spilled",
          "old_text": "child->first_pos()",
          "new_text": "range->spilled()",
          "old_line_content": "    for (const UsePosition* pos = child->first_pos(); pos != nullptr;",
          "new_line_content": "  DCHECK(!range->spilled());",
          "content_same": false
        },
        {
          "line": 3937,
          "old_api": "spilled",
          "new_api": "code",
          "old_text": "child->spilled()",
          "new_text": "data()->code()",
          "old_line_content": "      if (pos->type() != UsePositionType::kRequiresSlot && !child->spilled())",
          "new_line_content": "  InstructionSequence* code = data()->code();",
          "content_same": false
        },
        {
          "line": 3940,
          "old_api": "ToInstructionIndex",
          "new_api": "vreg",
          "old_text": "pos->pos().ToInstructionIndex()",
          "new_text": "TRACE(\"Live Range %d will be spilled only in deferred blocks.\\n\",\n        range->vreg())",
          "old_line_content": "          code->GetInstructionBlock(pos->pos().ToInstructionIndex())",
          "new_line_content": "  TRACE(\"Live Range %d will be spilled only in deferred blocks.\\n\",",
          "content_same": false
        },
        {
          "line": 3948,
          "old_api": "GetListOfBlocksRequiringSpillOperands",
          "new_api": "spilled",
          "old_text": "range->GetListOfBlocksRequiringSpillOperands()",
          "new_text": "child->spilled()",
          "old_line_content": "           range->GetListOfBlocksRequiringSpillOperands());",
          "new_line_content": "      if (pos->type() != UsePositionType::kRequiresSlot && !child->spilled())",
          "content_same": false
        },
        {
          "line": 3950,
          "old_api": "Current",
          "new_api": "ToInstructionIndex",
          "old_text": "iterator.Current()",
          "new_text": "range->AddBlockRequiringSpillOperand(\n          code->GetInstructionBlock(pos->pos().ToInstructionIndex())\n              ->rpo_number())",
          "old_line_content": "    worklist.push(iterator.Current());",
          "new_line_content": "      range->AddBlockRequiringSpillOperand(",
          "content_same": false
        },
        {
          "line": 3959,
          "old_api": "front",
          "new_api": "GetListOfBlocksRequiringSpillOperands",
          "old_text": "worklist.front()",
          "new_text": "range->GetListOfBlocksRequiringSpillOperands()",
          "old_line_content": "    int block_id = worklist.front();",
          "new_line_content": "           range->GetListOfBlocksRequiringSpillOperands());",
          "content_same": false
        },
        {
          "line": 3960,
          "old_api": "pop",
          "new_api": "Advance",
          "old_text": "worklist.pop()",
          "new_text": "iterator.Advance()",
          "old_line_content": "    worklist.pop();",
          "new_line_content": "       !iterator.Done(); iterator.Advance()) {",
          "content_same": false
        },
        {
          "line": 3961,
          "old_api": "Contains",
          "new_api": "Current",
          "old_text": "done_blocks.Contains(block_id)",
          "new_text": "iterator.Current()",
          "old_line_content": "    if (done_blocks.Contains(block_id)) continue;",
          "new_line_content": "    worklist.push(iterator.Current());",
          "content_same": false
        },
        {
          "line": 3969,
          "old_api": "IsDeferred",
          "new_api": "empty",
          "old_text": "pred_block->IsDeferred()",
          "new_text": "worklist.empty()",
          "old_line_content": "      if (pred_block->IsDeferred()) {",
          "new_line_content": "  while (!worklist.empty()) {",
          "content_same": false
        },
        {
          "line": 3970,
          "old_api": "ToInt",
          "new_api": "front",
          "old_text": "pred_block->rpo_number().ToInt()",
          "new_text": "worklist.front()",
          "old_line_content": "        worklist.push(pred_block->rpo_number().ToInt());",
          "new_line_content": "    int block_id = worklist.front();",
          "content_same": false
        },
        {
          "line": 3973,
          "old_api": "last_instruction_index",
          "new_api": "Add",
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(\n                pred_block->last_instruction_index())",
          "new_text": "done_blocks.Add(block_id)",
          "old_line_content": "            LifetimePosition::InstructionFromInstructionIndex(",
          "new_line_content": "    done_blocks.Add(block_id);",
          "content_same": false
        },
        {
          "line": 3978,
          "old_api": "GetAssignedOperand",
          "new_api": "InstructionBlockAt",
          "old_text": "bound->range_->GetAssignedOperand()",
          "new_text": "code->InstructionBlockAt(pred)",
          "old_line_content": "        InstructionOperand pred_op = bound->range_->GetAssignedOperand();",
          "new_line_content": "      const InstructionBlock* pred_block = code->InstructionBlockAt(pred);",
          "content_same": false
        },
        {
          "line": 3980,
          "old_api": "rpo_number",
          "new_api": "IsDeferred",
          "old_text": "spill_block->rpo_number()",
          "new_text": "pred_block->IsDeferred()",
          "old_line_content": "        RpoNumber spill_block_number = spill_block->rpo_number();",
          "new_line_content": "      if (pred_block->IsDeferred()) {",
          "content_same": false
        },
        {
          "line": 3981,
          "old_api": "vreg",
          "new_api": "ToInt",
          "old_text": "std::make_pair(\n                spill_block_number, range->vreg())",
          "new_text": "pred_block->rpo_number().ToInt()",
          "old_line_content": "        if (done_moves.find(std::make_pair(",
          "new_line_content": "        worklist.push(pred_block->rpo_number().ToInt());",
          "content_same": false
        },
        {
          "line": 3987,
          "old_api": "mark_needs_frame",
          "new_api": "Find",
          "old_text": "spill_block->mark_needs_frame()",
          "new_text": "array->Find(pred_end)",
          "old_line_content": "          spill_block->mark_needs_frame();",
          "new_line_content": "        LiveRangeBound* bound = array->Find(pred_end);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 3586,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "data()->code()->reference_maps()",
          "old_line_content": "  for (RegisterAllocationData::DelayedReference& delayed_reference :",
          "new_line_content": "  for (ReferenceMap* map : *data()->code()->reference_maps()) {",
          "content_same": false
        },
        {
          "line": 3600,
          "old_api": null,
          "new_api": "AllocatedOperand::cast(*delayed_reference.operand)",
          "old_text": null,
          "new_text": "AllocatedOperand::cast(*delayed_reference.operand)",
          "old_line_content": "    if (range == nullptr) continue;",
          "new_line_content": "        AllocatedOperand::cast(*delayed_reference.operand));",
          "content_same": false
        },
        {
          "line": 3606,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "reference_maps->begin()",
          "old_line_content": "",
          "new_line_content": "  ReferenceMapDeque::const_iterator first_it = reference_maps->begin();",
          "content_same": false
        },
        {
          "line": 3607,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "    // Find the extent of the range and its children.",
          "new_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "content_same": false
        },
        {
          "line": 3609,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "old_line_content": "    int end = 0;",
          "new_line_content": "    CHECK_EQ(live_ranges_size,",
          "content_same": false
        },
        {
          "line": 3101,
          "old_api": null,
          "new_api": "FirstHintPosition",
          "old_text": null,
          "new_text": "current->FirstHintPosition(&reg)",
          "old_line_content": "  LifetimePosition pos = free_until_pos[reg];",
          "new_line_content": "  if (current->FirstHintPosition(&reg) == nullptr) {",
          "content_same": false
        },
        {
          "line": 3615,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "range->IsEmpty()",
          "old_line_content": "    }",
          "new_line_content": "    if (range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 3616,
          "old_api": null,
          "new_api": "has_preassigned_slot",
          "old_text": null,
          "new_text": "range->has_preassigned_slot()",
          "old_line_content": "",
          "new_line_content": "    if (range->has_preassigned_slot()) continue;",
          "content_same": false
        },
        {
          "line": 3106,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "free_until_pos[code].ToInstructionIndex()",
          "old_line_content": "  }",
          "new_line_content": "    if (free_until_pos[code].ToInstructionIndex() >",
          "content_same": false
        },
        {
          "line": 3107,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "free_until_pos[reg].ToInstructionIndex()",
          "old_line_content": "",
          "new_line_content": "        free_until_pos[reg].ToInstructionIndex()) {",
          "content_same": false
        },
        {
          "line": 3621,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "cur->next()",
          "old_line_content": "",
          "new_line_content": "    for (LiveRange* cur = range; cur != nullptr; cur = cur->next()) {",
          "content_same": false
        },
        {
          "line": 3622,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "cur->End()",
          "old_line_content": "    // Step across all the safe points that are before the start of this range,",
          "new_line_content": "      LifetimePosition this_end = cur->End();",
          "content_same": false
        },
        {
          "line": 3623,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "this_end.ToInstructionIndex()",
          "old_line_content": "    // recording how far we step in order to save doing this for the next range.",
          "new_line_content": "      if (this_end.ToInstructionIndex() > end)",
          "content_same": false
        },
        {
          "line": 3625,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "cur->Start().ToInstructionIndex()",
          "old_line_content": "      ReferenceMap* map = *first_it;",
          "new_line_content": "      DCHECK(cur->Start().ToInstructionIndex() >= start);",
          "content_same": false
        },
        {
          "line": 3114,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "    // Try to allocate preferred register once more.",
          "new_line_content": "  if (pos <= current->Start()) {",
          "content_same": false
        },
        {
          "line": 3119,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "current->End()",
          "old_line_content": "  // end.",
          "new_line_content": "  if (pos < current->End()) {",
          "content_same": false
        },
        {
          "line": 3635,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "reference_maps->end()",
          "old_line_content": "      } else {",
          "new_line_content": "    for (; first_it != reference_maps->end(); ++first_it) {",
          "content_same": false
        },
        {
          "line": 3637,
          "old_api": null,
          "new_api": "instruction_position",
          "old_text": null,
          "new_text": "map->instruction_position()",
          "old_line_content": "      }",
          "new_line_content": "      if (map->instruction_position() >= start) break;",
          "content_same": false
        },
        {
          "line": 3126,
          "old_api": null,
          "new_api": "TryAllocatePreferredReg",
          "old_text": null,
          "new_text": "TryAllocatePreferredReg(current, free_until_pos)",
          "old_line_content": "}",
          "new_line_content": "    if (TryAllocatePreferredReg(current, free_until_pos)) return true;",
          "content_same": false
        },
        {
          "line": 3641,
          "old_api": null,
          "new_api": "HasSpillOperand",
          "old_text": null,
          "new_text": "range->HasSpillOperand()",
          "old_line_content": "    }",
          "new_line_content": "    if (((range->HasSpillOperand() &&",
          "content_same": false
        },
        {
          "line": 3642,
          "old_api": null,
          "new_api": "GetSpillOperand",
          "old_text": null,
          "new_text": "range->GetSpillOperand()->IsConstant()",
          "old_line_content": "",
          "new_line_content": "          !range->GetSpillOperand()->IsConstant()) ||",
          "content_same": false
        },
        {
          "line": 3131,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "current->End()",
          "old_line_content": "    // There is no use in the current live range that requires a register.",
          "new_line_content": "  DCHECK(pos >= current->End());",
          "content_same": false
        },
        {
          "line": 3132,
          "old_api": null,
          "new_api": "RegisterName",
          "old_text": null,
          "new_text": "RegisterName(reg)",
          "old_line_content": "    // We can just spill it.",
          "new_line_content": "  TRACE(\"Assigning free reg %s to live range %d:%d\\n\", RegisterName(reg),",
          "content_same": false
        },
        {
          "line": 3643,
          "old_api": null,
          "new_api": "HasSpillRange",
          "old_text": null,
          "new_text": "range->HasSpillRange()",
          "old_line_content": "    LiveRange* cur = range;",
          "new_line_content": "         range->HasSpillRange())) {",
          "content_same": false
        },
        {
          "line": 3134,
          "old_api": null,
          "new_api": "SetLiveRangeAssignedRegister",
          "old_text": null,
          "new_text": "SetLiveRangeAssignedRegister(current, reg)",
          "old_line_content": "    return;",
          "new_line_content": "  SetLiveRangeAssignedRegister(current, reg);",
          "content_same": false
        },
        {
          "line": 3644,
          "old_api": null,
          "new_api": "HasSpillOperand",
          "old_text": null,
          "new_text": "range->HasSpillOperand()",
          "old_line_content": "    // Step through the safe points to see whether they are in the range.",
          "new_line_content": "      if (range->HasSpillOperand()) {",
          "content_same": false
        },
        {
          "line": 3649,
          "old_api": null,
          "new_api": "IsStackSlot",
          "old_text": null,
          "new_text": "spill_operand.IsStackSlot()",
          "old_line_content": "      // The safe points are sorted so we can stop searching here.",
          "new_line_content": "      DCHECK(spill_operand.IsStackSlot());",
          "content_same": false
        },
        {
          "line": 3650,
          "old_api": null,
          "new_api": "representation",
          "old_text": null,
          "new_text": "CanBeTaggedPointer(\n          AllocatedOperand::cast(spill_operand).representation())",
          "old_line_content": "      if (safe_point - 1 > end) break;",
          "new_line_content": "      DCHECK(CanBeTaggedPointer(",
          "content_same": false
        },
        {
          "line": 3651,
          "old_api": null,
          "new_api": "representation",
          "old_text": null,
          "new_text": "AllocatedOperand::cast(spill_operand).representation()",
          "old_line_content": "",
          "new_line_content": "          AllocatedOperand::cast(spill_operand).representation()));",
          "content_same": false
        },
        {
          "line": 3144,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "Spill(current)",
          "old_line_content": "",
          "new_line_content": "    Spill(current);",
          "content_same": false
        },
        {
          "line": 3656,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "reference_maps->end()",
          "old_line_content": "",
          "new_line_content": "    for (auto it = first_it; it != reference_maps->end(); ++it) {",
          "content_same": false
        },
        {
          "line": 3658,
          "old_api": null,
          "new_api": "instruction_position",
          "old_text": null,
          "new_text": "map->instruction_position()",
          "old_line_content": "      // don't find it before the children pass safe_point_pos, keep cur at",
          "new_line_content": "      int safe_point = map->instruction_position();",
          "content_same": false
        },
        {
          "line": 3148,
          "old_api": null,
          "new_api": "num_registers",
          "old_text": null,
          "new_text": "num_registers()",
          "old_line_content": "  LifetimePosition use_pos[RegisterConfiguration::kMaxFPRegisters];",
          "new_line_content": "  int num_regs = num_registers();",
          "content_same": false
        },
        {
          "line": 3149,
          "old_api": null,
          "new_api": "num_allocatable_registers",
          "old_text": null,
          "new_text": "num_allocatable_registers()",
          "old_line_content": "  LifetimePosition block_pos[RegisterConfiguration::kMaxFPRegisters];",
          "new_line_content": "  int num_codes = num_allocatable_registers();",
          "content_same": false
        },
        {
          "line": 3150,
          "old_api": null,
          "new_api": "allocatable_register_codes",
          "old_text": null,
          "new_text": "allocatable_register_codes()",
          "old_line_content": "  for (int i = 0; i < num_regs; i++) {",
          "new_line_content": "  const int* codes = allocatable_register_codes();",
          "content_same": false
        },
        {
          "line": 3666,
          "old_api": null,
          "new_api": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "old_text": null,
          "new_text": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "old_line_content": "      while (!found) {",
          "new_line_content": "          LifetimePosition::InstructionFromInstructionIndex(safe_point);",
          "content_same": false
        },
        {
          "line": 3162,
          "old_api": null,
          "new_api": "LifetimePosition::MaxPosition()",
          "old_text": null,
          "new_text": "LifetimePosition::MaxPosition()",
          "old_line_content": "      } else {",
          "new_line_content": "    use_pos[i] = block_pos[i] = LifetimePosition::MaxPosition();",
          "content_same": false
        },
        {
          "line": 3674,
          "old_api": null,
          "new_api": "DCHECK_NOT_NULL",
          "old_text": null,
          "new_text": "DCHECK_NOT_NULL(cur)",
          "old_line_content": "          cur = next;",
          "new_line_content": "      DCHECK_NOT_NULL(cur);",
          "content_same": false
        },
        {
          "line": 3675,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "cur->Start()",
          "old_line_content": "        }",
          "new_line_content": "      DCHECK(safe_point_pos >= cur->Start() || range == cur);",
          "content_same": false
        },
        {
          "line": 3165,
          "old_api": null,
          "new_api": "active_live_ranges",
          "old_text": null,
          "new_text": "active_live_ranges()",
          "old_line_content": "        use_pos[cur_reg] =",
          "new_line_content": "  for (LiveRange* range : active_live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3678,
          "old_api": null,
          "new_api": "Covers",
          "old_text": null,
          "new_text": "cur->Covers(safe_point_pos)",
          "old_line_content": "      if (!found) {",
          "new_line_content": "        if (cur->Covers(safe_point_pos)) {",
          "content_same": false
        },
        {
          "line": 3168,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "    } else {",
          "new_line_content": "        range->TopLevel()->IsFixed() || !range->CanBeSpilled(current->Start());",
          "content_same": false
        },
        {
          "line": 3169,
          "old_api": null,
          "new_api": "check_fp_aliasing",
          "old_text": null,
          "new_text": "check_fp_aliasing()",
          "old_line_content": "      int alias_base_index = -1;",
          "new_line_content": "    if (kSimpleFPAliasing || !check_fp_aliasing()) {",
          "content_same": false
        },
        {
          "line": 3681,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "cur->next()",
          "old_line_content": "",
          "new_line_content": "          LiveRange* next = cur->next();",
          "content_same": false
        },
        {
          "line": 3682,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "next->Start()",
          "old_line_content": "      // Check if the live range is spilled and the safe point is after",
          "new_line_content": "          if (next == nullptr || next->Start() > safe_point_pos) {",
          "content_same": false
        },
        {
          "line": 3174,
          "old_api": null,
          "new_api": "LifetimePosition::GapFromInstructionIndex(0)",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(0)",
          "old_line_content": "        int aliased_reg = alias_base_index + aliases;",
          "new_line_content": "        DCHECK_NE(LifetimePosition::GapFromInstructionIndex(0),",
          "content_same": false
        },
        {
          "line": 3183,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(aliases > 0 || (aliases == 0 && alias_base_index == -1))",
          "old_line_content": "        }",
          "new_line_content": "      DCHECK(aliases > 0 || (aliases == 0 && alias_base_index == -1));",
          "content_same": false
        },
        {
          "line": 3696,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "cur->Start().ToInstructionIndex()",
          "old_line_content": "            \"Pointer in register for range %d:%d (start at %d) \"",
          "new_line_content": "                            ? cur->Start().ToInstructionIndex()",
          "content_same": false
        },
        {
          "line": 3697,
          "old_api": null,
          "new_api": "spill_start_index",
          "old_text": null,
          "new_text": "range->spill_start_index()",
          "old_line_content": "            \"at safe point %d\\n\",",
          "new_line_content": "                            : range->spill_start_index();",
          "content_same": false
        },
        {
          "line": 3699,
          "old_api": null,
          "new_api": "IsInvalid",
          "old_text": null,
          "new_text": "spill_operand.IsInvalid()",
          "old_line_content": "            safe_point);",
          "new_line_content": "      if (!spill_operand.IsInvalid() && safe_point >= spill_index) {",
          "content_same": false
        },
        {
          "line": 3192,
          "old_api": null,
          "new_api": "NextLifetimePositionRegisterIsBeneficial",
          "old_text": null,
          "new_text": "range->NextLifetimePositionRegisterIsBeneficial(\n                      current->Start())",
          "old_line_content": "",
          "new_line_content": "                  range->NextLifetimePositionRegisterIsBeneficial(",
          "content_same": false
        },
        {
          "line": 3193,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "    // Don't perform costly intersections if they are guaranteed to not update",
          "new_line_content": "                      current->Start()));",
          "content_same": false
        },
        {
          "line": 3705,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "cur->spilled()",
          "old_line_content": "      }",
          "new_line_content": "      if (!cur->spilled()) {",
          "content_same": false
        },
        {
          "line": 3706,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "TRACE(\n            \"Pointer in register for range %d:%d (start at %d) \"\n            \"at safe point %d\\n\",\n            range->vreg(), cur->relative_id(), cur->Start().value(),\n            safe_point)",
          "old_line_content": "    }",
          "new_line_content": "        TRACE(",
          "content_same": false
        },
        {
          "line": 3709,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "cur->Start().value()",
          "old_line_content": "",
          "new_line_content": "            range->vreg(), cur->relative_id(), cur->Start().value(),",
          "content_same": false
        },
        {
          "line": 3199,
          "old_api": null,
          "new_api": "inactive_live_ranges",
          "old_text": null,
          "new_text": "inactive_live_ranges()",
          "old_line_content": "      } else {",
          "new_line_content": "  for (LiveRange* range : inactive_live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3711,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "cur->GetAssignedOperand()",
          "old_line_content": "LiveRangeConnector::LiveRangeConnector(RegisterAllocationData* data)",
          "new_line_content": "        InstructionOperand operand = cur->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3201,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "range->assigned_register()",
          "old_line_content": "      }",
          "new_line_content": "    int cur_reg = range->assigned_register();",
          "content_same": false
        },
        {
          "line": 3202,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->IsFixed()",
          "old_line_content": "    }",
          "new_line_content": "    bool is_fixed = range->TopLevel()->IsFixed();",
          "content_same": false
        },
        {
          "line": 3712,
          "old_api": null,
          "new_api": "IsStackSlot",
          "old_text": null,
          "new_text": "operand.IsStackSlot()",
          "old_line_content": "    : data_(data) {}",
          "new_line_content": "        DCHECK(!operand.IsStackSlot());",
          "content_same": false
        },
        {
          "line": 3713,
          "old_api": null,
          "new_api": "representation",
          "old_text": null,
          "new_text": "CanBeTaggedPointer(\n            AllocatedOperand::cast(operand).representation())",
          "old_line_content": "",
          "new_line_content": "        DCHECK(CanBeTaggedPointer(",
          "content_same": false
        },
        {
          "line": 3714,
          "old_api": null,
          "new_api": "representation",
          "old_text": null,
          "new_text": "AllocatedOperand::cast(operand).representation()",
          "old_line_content": "",
          "new_line_content": "            AllocatedOperand::cast(operand).representation()));",
          "content_same": false
        },
        {
          "line": 3715,
          "old_api": null,
          "new_api": "AllocatedOperand::cast(operand)",
          "old_text": null,
          "new_text": "AllocatedOperand::cast(operand)",
          "old_line_content": "bool LiveRangeConnector::CanEagerlyResolveControlFlow(",
          "new_line_content": "        map->RecordReference(AllocatedOperand::cast(operand));",
          "content_same": false
        },
        {
          "line": 3211,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "range->Start()",
          "old_line_content": "      } else {",
          "new_line_content": "        if (use_pos[cur_reg] < range->Start()) continue;",
          "content_same": false
        },
        {
          "line": 3215,
          "old_api": null,
          "new_api": "FirstIntersection",
          "old_text": null,
          "new_text": "range->FirstIntersection(current)",
          "old_line_content": "      int alias_base_index = -1;",
          "new_line_content": "    LifetimePosition next_intersection = range->FirstIntersection(current);",
          "content_same": false
        },
        {
          "line": 3729,
          "old_api": null,
          "new_api": "rpo_number",
          "old_text": null,
          "new_text": "block->rpo_number()",
          "old_line_content": "    BitVector::Iterator iterator(live);",
          "new_line_content": "  return block->predecessors()[0].IsNext(block->rpo_number());",
          "content_same": false
        },
        {
          "line": 3220,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(block_pos[cur_reg], next_intersection)",
          "old_line_content": "        int aliased_reg = alias_base_index + aliases;",
          "new_line_content": "        block_pos[cur_reg] = Min(block_pos[cur_reg], next_intersection);",
          "content_same": false
        },
        {
          "line": 3221,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(block_pos[cur_reg], use_pos[cur_reg])",
          "old_line_content": "        if (is_fixed) {",
          "new_line_content": "        use_pos[cur_reg] = Min(block_pos[cur_reg], use_pos[cur_reg]);",
          "content_same": false
        },
        {
          "line": 3737,
          "old_api": null,
          "new_api": "instruction_blocks",
          "old_text": null,
          "new_text": "code()->instruction_blocks()",
          "old_line_content": "          continue;",
          "new_line_content": "  for (const InstructionBlock* block : code()->instruction_blocks()) {",
          "content_same": false
        },
        {
          "line": 3738,
          "old_api": null,
          "new_api": "CanEagerlyResolveControlFlow",
          "old_text": null,
          "new_text": "CanEagerlyResolveControlFlow(block)",
          "old_line_content": "        }",
          "new_line_content": "    if (CanEagerlyResolveControlFlow(block)) continue;",
          "content_same": false
        },
        {
          "line": 3228,
          "old_api": null,
          "new_api": "representation",
          "old_text": null,
          "new_text": "range->representation()",
          "old_line_content": "        }",
          "new_line_content": "          range->representation(), cur_reg, rep, &alias_base_index);",
          "content_same": false
        },
        {
          "line": 3229,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(aliases > 0 || (aliases == 0 && alias_base_index == -1))",
          "old_line_content": "      }",
          "new_line_content": "      DCHECK(aliases > 0 || (aliases == 0 && alias_base_index == -1));",
          "content_same": false
        },
        {
          "line": 3743,
          "old_api": null,
          "new_api": "ArrayFor",
          "old_text": null,
          "new_text": "finder.ArrayFor(vreg)",
          "old_line_content": "          // We're doing a reload.",
          "new_line_content": "      LiveRangeBoundArray* array = finder.ArrayFor(vreg);",
          "content_same": false
        },
        {
          "line": 3744,
          "old_api": null,
          "new_api": "predecessors",
          "old_text": null,
          "new_text": "block->predecessors()",
          "old_line_content": "          // We don't need to, if:",
          "new_line_content": "      for (const RpoNumber& pred : block->predecessors()) {",
          "content_same": false
        },
        {
          "line": 3234,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(block_pos[aliased_reg], next_intersection)",
          "old_line_content": "  for (int i = 1; i < num_codes; ++i) {",
          "new_line_content": "              Min(block_pos[aliased_reg], next_intersection);",
          "content_same": false
        },
        {
          "line": 3746,
          "old_api": null,
          "new_api": "InstructionBlockAt",
          "old_text": null,
          "new_text": "code()->InstructionBlockAt(pred)",
          "old_line_content": "          // 2) the range ends before the block does, and",
          "new_line_content": "        const InstructionBlock* pred_block = code()->InstructionBlockAt(pred);",
          "content_same": false
        },
        {
          "line": 3236,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(block_pos[aliased_reg], use_pos[aliased_reg])",
          "old_line_content": "    if (use_pos[code] > use_pos[reg]) {",
          "new_line_content": "              Min(block_pos[aliased_reg], use_pos[aliased_reg]);",
          "content_same": false
        },
        {
          "line": 3747,
          "old_api": null,
          "new_api": "FindConnectableSubranges",
          "old_text": null,
          "new_text": "array->FindConnectableSubranges(block, pred_block, &result)",
          "old_line_content": "          // 3) we don't have a successor, or the successor is spilled.",
          "new_line_content": "        if (!array->FindConnectableSubranges(block, pred_block, &result)) {",
          "content_same": false
        },
        {
          "line": 3238,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(use_pos[aliased_reg], next_intersection)",
          "old_line_content": "    }",
          "new_line_content": "          use_pos[aliased_reg] = Min(use_pos[aliased_reg], next_intersection);",
          "content_same": false
        },
        {
          "line": 3750,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "result.pred_cover_->GetAssignedOperand()",
          "old_line_content": "          LifetimePosition block_end =",
          "new_line_content": "        InstructionOperand pred_op = result.pred_cover_->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3752,
          "old_api": null,
          "new_api": "Equals",
          "old_text": null,
          "new_text": "pred_op.Equals(cur_op)",
          "old_line_content": "          const LiveRange* current = result.cur_cover_;",
          "new_line_content": "        if (pred_op.Equals(cur_op)) continue;",
          "content_same": false
        },
        {
          "line": 3252,
          "old_api": null,
          "new_api": "pos",
          "old_text": null,
          "new_text": "register_use->pos()",
          "old_line_content": "  // is blocked, if applicable.",
          "new_line_content": "  if (use_pos[reg] < register_use->pos()) {",
          "content_same": false
        },
        {
          "line": 3764,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "current->next()",
          "old_line_content": "                break;",
          "new_line_content": "          const LiveRange* successor = current->next();",
          "content_same": false
        },
        {
          "line": 3765,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "current->End()",
          "old_line_content": "              }",
          "new_line_content": "          if (current->End() < block_end &&",
          "content_same": false
        },
        {
          "line": 3255,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "    // position.",
          "new_line_content": "    if (LifetimePosition::ExistsGapPositionBetween(current->Start(),",
          "content_same": false
        },
        {
          "line": 3256,
          "old_api": null,
          "new_api": "pos",
          "old_text": null,
          "new_text": "register_use->pos()",
          "old_line_content": "    LiveRange* tail =",
          "new_line_content": "                                                   register_use->pos())) {",
          "content_same": false
        },
        {
          "line": 3766,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "successor->spilled()",
          "old_line_content": "            }",
          "new_line_content": "              (successor == nullptr || successor->spilled())) {",
          "content_same": false
        },
        {
          "line": 3771,
          "old_api": null,
          "new_api": "NextUsePosition",
          "old_text": null,
          "new_text": "current->NextUsePosition(block_start)",
          "old_line_content": "            // The spill location should be defined in pred_block, so add",
          "new_line_content": "            for (const UsePosition* use = current->NextUsePosition(block_start);",
          "content_same": false
        },
        {
          "line": 3772,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "use->next()",
          "old_line_content": "            // pred_block to the list of blocks requiring a spill operand.",
          "new_line_content": "                 use != nullptr; use = use->next()) {",
          "content_same": false
        },
        {
          "line": 3268,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "block_pos[reg].Start()",
          "old_line_content": "  // parts of active and inactive live regions that use the same register",
          "new_line_content": "        SplitBetween(current, current->Start(), block_pos[reg].Start());",
          "content_same": false
        },
        {
          "line": 3269,
          "old_api": null,
          "new_api": "AddToUnhandled",
          "old_text": null,
          "new_text": "AddToUnhandled(tail)",
          "old_line_content": "  // at the same lifetime positions as current.",
          "new_line_content": "    AddToUnhandled(tail);",
          "content_same": false
        },
        {
          "line": 3273,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "current->End()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(block_pos[reg] >= current->End());",
          "content_same": false
        },
        {
          "line": 3274,
          "old_api": null,
          "new_api": "RegisterName",
          "old_text": null,
          "new_text": "RegisterName(reg)",
          "old_line_content": "void LinearScanAllocator::SplitAndSpillIntersecting(LiveRange* current) {",
          "new_line_content": "  TRACE(\"Assigning blocked reg %s to live range %d:%d\\n\", RegisterName(reg),",
          "content_same": false
        },
        {
          "line": 3785,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "pred_block->rpo_number().ToInt()",
          "old_line_content": "    }",
          "new_line_content": "                pred_block->rpo_number().ToInt());",
          "content_same": false
        },
        {
          "line": 3788,
          "old_api": null,
          "new_api": "ResolveControlFlow",
          "old_text": null,
          "new_text": "ResolveControlFlow(block, cur_op, pred_block, pred_op)",
          "old_line_content": "  // At this stage, we collected blocks needing a spill operand from",
          "new_line_content": "        int move_loc = ResolveControlFlow(block, cur_op, pred_block, pred_op);",
          "content_same": false
        },
        {
          "line": 3789,
          "old_api": null,
          "new_api": "USE",
          "old_text": null,
          "new_text": "USE(move_loc)",
          "old_line_content": "  // ConnectRanges and from ResolveControlFlow. Time to commit the spills for",
          "new_line_content": "        USE(move_loc);",
          "content_same": false
        },
        {
          "line": 3790,
          "old_api": null,
          "new_api": "IsAnyRegister",
          "old_text": null,
          "new_text": "DCHECK_IMPLIES(\n            result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&\n                !(pred_op.IsAnyRegister() && cur_op.IsAnyRegister()),\n            code()->GetInstructionBlock(move_loc)->IsDeferred())",
          "old_line_content": "  // deferred blocks.",
          "new_line_content": "        DCHECK_IMPLIES(",
          "content_same": false
        },
        {
          "line": 3286,
          "old_api": null,
          "new_api": "HasRegisterAssigned",
          "old_text": null,
          "new_text": "current->HasRegisterAssigned()",
          "old_line_content": "        continue;",
          "new_line_content": "  DCHECK(current->HasRegisterAssigned());",
          "content_same": false
        },
        {
          "line": 3287,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "current->assigned_register()",
          "old_line_content": "      }",
          "new_line_content": "  int reg = current->assigned_register();",
          "content_same": false
        },
        {
          "line": 3288,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "    }",
          "new_line_content": "  LifetimePosition split_pos = current->Start();",
          "content_same": false
        },
        {
          "line": 3289,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "active_live_ranges().size()",
          "old_line_content": "",
          "new_line_content": "  for (size_t i = 0; i < active_live_ranges().size(); ++i) {",
          "content_same": false
        },
        {
          "line": 3802,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "",
          "new_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "content_same": false
        },
        {
          "line": 3803,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "int LiveRangeConnector::ResolveControlFlow(const InstructionBlock* block,",
          "new_line_content": "  for (TopLevelLiveRange* top : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3292,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "range->assigned_register()",
          "old_line_content": "    if (next_pos == nullptr) {",
          "new_line_content": "      if (range->assigned_register() != reg) continue;",
          "content_same": false
        },
        {
          "line": 3804,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "old_line_content": "                                           const InstructionOperand& cur_op,",
          "new_line_content": "    CHECK_EQ(live_ranges_size,",
          "content_same": false
        },
        {
          "line": 3294,
          "old_api": null,
          "new_api": "representation",
          "old_text": null,
          "new_text": "current->representation()",
          "old_line_content": "    } else {",
          "new_line_content": "      if (!data()->config()->AreAliases(current->representation(), reg,",
          "content_same": false
        },
        {
          "line": 3295,
          "old_api": null,
          "new_api": "representation",
          "old_text": null,
          "new_text": "range->representation()",
          "old_line_content": "      // When spilling between spill_pos and next_pos ensure that the range",
          "new_line_content": "                                        range->representation(),",
          "content_same": false
        },
        {
          "line": 3296,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "range->assigned_register()",
          "old_line_content": "      // remains spilled at least until the start of the current live range.",
          "new_line_content": "                                        range->assigned_register())) {",
          "content_same": false
        },
        {
          "line": 3805,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "                                           const InstructionBlock* pred,",
          "new_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "content_same": false
        },
        {
          "line": 3806,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "top->IsEmpty()",
          "old_line_content": "                                           const InstructionOperand& pred_op) {",
          "new_line_content": "    if (top == nullptr || top->IsEmpty() ||",
          "content_same": false
        },
        {
          "line": 3809,
          "old_api": null,
          "new_api": "vreg",
          "old_text": null,
          "new_text": "top->vreg()",
          "old_line_content": "  Instruction::GapPosition position;",
          "new_line_content": "    CommitSpillsInDeferredBlocks(top, finder.ArrayFor(top->vreg()), local_zone);",
          "content_same": false
        },
        {
          "line": 3301,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "      // ranges are retired from active/inactive when the start of the",
          "new_line_content": "    UsePosition* next_pos = range->NextRegisterPosition(current->Start());",
          "content_same": false
        },
        {
          "line": 3302,
          "old_api": null,
          "new_api": "FindOptimalSpillingPos",
          "old_text": null,
          "new_text": "FindOptimalSpillingPos(range, split_pos)",
          "old_line_content": "      // current live-range is larger than their end.",
          "new_line_content": "    LifetimePosition spill_pos = FindOptimalSpillingPos(range, split_pos);",
          "content_same": false
        },
        {
          "line": 3822,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "block->first_instruction_index()",
          "old_line_content": "  return gap_index;",
          "new_line_content": "    gap_index = block->first_instruction_index();",
          "content_same": false
        },
        {
          "line": 3825,
          "old_api": null,
          "new_api": "SuccessorCount",
          "old_text": null,
          "new_text": "pred->SuccessorCount()",
          "old_line_content": "void LiveRangeConnector::ConnectRanges(Zone* local_zone) {",
          "new_line_content": "    DCHECK_EQ(1, pred->SuccessorCount());",
          "content_same": false
        },
        {
          "line": 3826,
          "old_api": null,
          "new_api": "InstructionAt",
          "old_text": null,
          "new_text": "code()\n                ->InstructionAt(pred->last_instruction_index())\n                ->HasReferenceMap()",
          "old_line_content": "  DelayedInsertionMap delayed_insertion_map(local_zone);",
          "new_line_content": "    DCHECK(!code()",
          "content_same": false
        },
        {
          "line": 3322,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inactive_live_ranges().size()",
          "old_line_content": "    }",
          "new_line_content": "  for (size_t i = 0; i < inactive_live_ranges().size(); ++i) {",
          "content_same": false
        },
        {
          "line": 3323,
          "old_api": null,
          "new_api": "inactive_live_ranges",
          "old_text": null,
          "new_text": "inactive_live_ranges()",
          "old_line_content": "",
          "new_line_content": "    LiveRange* range = inactive_live_ranges()[i];",
          "content_same": false
        },
        {
          "line": 3838,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "      // boundary.",
          "new_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "content_same": false
        },
        {
          "line": 3327,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "range->assigned_register()",
          "old_line_content": "      if (next_pos == nullptr) {",
          "new_line_content": "      if (range->assigned_register() != reg) continue;",
          "content_same": false
        },
        {
          "line": 3329,
          "old_api": null,
          "new_api": "representation",
          "old_text": null,
          "new_text": "current->representation()",
          "old_line_content": "      } else {",
          "new_line_content": "      if (!data()->config()->AreAliases(current->representation(), reg,",
          "content_same": false
        },
        {
          "line": 3843,
          "old_api": null,
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": null,
          "new_text": "top_range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "        continue;",
          "new_line_content": "    bool connect_spilled = top_range->IsSpilledOnlyInDeferredBlocks();",
          "content_same": false
        },
        {
          "line": 3335,
          "old_api": null,
          "new_api": "FirstIntersection",
          "old_text": null,
          "new_text": "range->FirstIntersection(current)",
          "old_line_content": "    }",
          "new_line_content": "    LifetimePosition next_intersection = range->FirstIntersection(current);",
          "content_same": false
        },
        {
          "line": 3336,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "next_intersection.IsValid()",
          "old_line_content": "  }",
          "new_line_content": "    if (next_intersection.IsValid()) {",
          "content_same": false
        },
        {
          "line": 3337,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "}",
          "new_line_content": "      UsePosition* next_pos = range->NextRegisterPosition(current->Start());",
          "content_same": false
        },
        {
          "line": 3339,
          "old_api": null,
          "new_api": "SpillAfter",
          "old_text": null,
          "new_text": "SpillAfter(range, split_pos)",
          "old_line_content": "",
          "new_line_content": "        SpillAfter(range, split_pos);",
          "content_same": false
        },
        {
          "line": 3342,
          "old_api": null,
          "new_api": "SpillBetween",
          "old_text": null,
          "new_text": "SpillBetween(range, split_pos, next_intersection)",
          "old_line_content": "",
          "new_line_content": "        SpillBetween(range, split_pos, next_intersection);",
          "content_same": false
        },
        {
          "line": 3344,
          "old_api": null,
          "new_api": "InactiveToHandled",
          "old_text": null,
          "new_text": "InactiveToHandled(range)",
          "old_line_content": "  RegisterAllocationData::PhiMapValue* phi_map_value =",
          "new_line_content": "      InactiveToHandled(range);",
          "content_same": false
        },
        {
          "line": 3856,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "first_range->GetAssignedOperand()",
          "old_line_content": "        // be defined here.",
          "new_line_content": "      InstructionOperand prev_operand = first_range->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3863,
          "old_api": null,
          "new_api": "IsAnyRegister",
          "old_text": null,
          "new_text": "cur_operand.IsAnyRegister()",
          "old_line_content": "      } else {",
          "new_line_content": "          cur_operand.IsAnyRegister()) {",
          "content_same": false
        },
        {
          "line": 3865,
          "old_api": null,
          "new_api": "IsDeferred",
          "old_text": null,
          "new_text": "block->IsDeferred()",
          "old_line_content": "          delay_insertion = true;",
          "new_line_content": "        DCHECK(block->IsDeferred());",
          "content_same": false
        },
        {
          "line": 3868,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "top_range->GetListOfBlocksRequiringSpillOperands()->Add(\n            block->rpo_number().ToInt())",
          "old_line_content": "        }",
          "new_line_content": "        top_range->GetListOfBlocksRequiringSpillOperands()->Add(",
          "content_same": false
        },
        {
          "line": 3357,
          "old_api": null,
          "new_api": "phi",
          "old_text": null,
          "new_text": "phi_map_value->phi()",
          "old_line_content": "    LifetimePosition pred_end =",
          "new_line_content": "  const PhiInstruction* phi = phi_map_value->phi();",
          "content_same": false
        },
        {
          "line": 3869,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "block->rpo_number().ToInt()",
          "old_line_content": "        gap_pos = delay_insertion ? Instruction::END : Instruction::START;",
          "new_line_content": "            block->rpo_number().ToInt());",
          "content_same": false
        },
        {
          "line": 3872,
          "old_api": null,
          "new_api": "IsGapPosition",
          "old_text": null,
          "new_text": "pos.IsGapPosition()",
          "old_line_content": "      // only in deferred blocks.",
          "new_line_content": "      if (pos.IsGapPosition()) {",
          "content_same": false
        },
        {
          "line": 3362,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "phi->operands().size()",
          "old_line_content": "    }",
          "new_line_content": "  for (size_t i = 0; i < phi->operands().size(); i++) {",
          "content_same": false
        },
        {
          "line": 3364,
          "old_api": null,
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": null,
          "new_text": "data()->GetOrCreateLiveRangeFor(op)",
          "old_line_content": "      spilled_count++;",
          "new_line_content": "    LiveRange* op_range = data()->GetOrCreateLiveRangeFor(op);",
          "content_same": false
        },
        {
          "line": 3365,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "op_range->TopLevel()->HasSpillRange()",
          "old_line_content": "      if (first_op == nullptr) {",
          "new_line_content": "    if (!op_range->TopLevel()->HasSpillRange()) continue;",
          "content_same": false
        },
        {
          "line": 3367,
          "old_api": null,
          "new_api": "predecessors",
          "old_text": null,
          "new_text": "block->predecessors()",
          "old_line_content": "      }",
          "new_line_content": "        code()->InstructionBlockAt(block->predecessors()[i]);",
          "content_same": false
        },
        {
          "line": 3369,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::InstructionFromInstructionIndex(\n            pred->last_instruction_index())",
          "old_line_content": "  }",
          "new_line_content": "        LifetimePosition::InstructionFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 3370,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "pred->last_instruction_index()",
          "old_line_content": "",
          "new_line_content": "            pred->last_instruction_index());",
          "content_same": false
        },
        {
          "line": 3371,
          "old_api": null,
          "new_api": "CanCover",
          "old_text": null,
          "new_text": "op_range->CanCover(pred_end)",
          "old_line_content": "  // Only continue if more than half of the operands are spilled.",
          "new_line_content": "    while (op_range != nullptr && !op_range->CanCover(pred_end)) {",
          "content_same": false
        },
        {
          "line": 3374,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "op_range->spilled()",
          "old_line_content": "  }",
          "new_line_content": "    if (op_range != nullptr && op_range->spilled()) {",
          "content_same": false
        },
        {
          "line": 3886,
          "old_api": null,
          "new_api": "IsAnyRegister",
          "old_text": null,
          "new_text": "cur_operand.IsAnyRegister()",
          "old_line_content": "      }",
          "new_line_content": "              !(prev_operand.IsAnyRegister() && cur_operand.IsAnyRegister()),",
          "content_same": false
        },
        {
          "line": 3887,
          "old_api": null,
          "new_api": "GetInstructionBlock",
          "old_text": null,
          "new_text": "code()->GetInstructionBlock(gap_index)->IsDeferred()",
          "old_line_content": "    }",
          "new_line_content": "          code()->GetInstructionBlock(gap_index)->IsDeferred());",
          "content_same": false
        },
        {
          "line": 3377,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "op_range->TopLevel()",
          "old_line_content": "  // operands.",
          "new_line_content": "        first_op = op_range->TopLevel();",
          "content_same": false
        },
        {
          "line": 3890,
          "old_api": null,
          "new_api": "InstructionAt",
          "old_text": null,
          "new_text": "code()->InstructionAt(gap_index)->GetOrCreateParallelMove(\n              gap_pos, code_zone())",
          "old_line_content": "  // Insert all the moves which should occur after the stored move.",
          "new_line_content": "          code()->InstructionAt(gap_index)->GetOrCreateParallelMove(",
          "content_same": false
        },
        {
          "line": 3891,
          "old_api": null,
          "new_api": "code_zone",
          "old_text": null,
          "new_text": "code_zone()",
          "old_line_content": "  ZoneVector<MoveOperands*> to_insert(local_zone);",
          "new_line_content": "              gap_pos, code_zone());",
          "content_same": false
        },
        {
          "line": 3900,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "delayed_insertion_map.empty()",
          "old_line_content": "      for (MoveOperands* move : to_eliminate) {",
          "new_line_content": "  if (delayed_insertion_map.empty()) return;",
          "content_same": false
        },
        {
          "line": 3389,
          "old_api": null,
          "new_api": "DCHECK_NOT_NULL",
          "old_text": null,
          "new_text": "DCHECK_NOT_NULL(first_op)",
          "old_line_content": "  }",
          "new_line_content": "  DCHECK_NOT_NULL(first_op);",
          "content_same": false
        },
        {
          "line": 3390,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "first_op->TopLevel()->GetSpillRange()",
          "old_line_content": "",
          "new_line_content": "  SpillRange* first_op_spill = first_op->TopLevel()->GetSpillRange();",
          "content_same": false
        },
        {
          "line": 3392,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "phi->operands().size()",
          "old_line_content": "  // same spill slot.",
          "new_line_content": "  for (size_t i = 1; i < phi->operands().size(); i++) {",
          "content_same": false
        },
        {
          "line": 3905,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "to_eliminate.reserve(4)",
          "old_line_content": "      }",
          "new_line_content": "  to_eliminate.reserve(4);",
          "content_same": false
        },
        {
          "line": 3906,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "delayed_insertion_map.begin()",
          "old_line_content": "      if (done) break;",
          "new_line_content": "  ParallelMove* moves = delayed_insertion_map.begin()->first.first;",
          "content_same": false
        },
        {
          "line": 3907,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "delayed_insertion_map.begin()",
          "old_line_content": "      // Reset state.",
          "new_line_content": "  for (auto it = delayed_insertion_map.begin();; ++it) {",
          "content_same": false
        },
        {
          "line": 3396,
          "old_api": null,
          "new_api": "GetSpillRange",
          "old_text": null,
          "new_text": "op_range->GetSpillRange()",
          "old_line_content": "    return false;",
          "new_line_content": "    SpillRange* op_spill = op_range->GetSpillRange();",
          "content_same": false
        },
        {
          "line": 3397,
          "old_api": null,
          "new_api": "TryMerge",
          "old_text": null,
          "new_text": "first_op_spill->TryMerge(op_spill)",
          "old_line_content": "  }",
          "new_line_content": "    if (op_spill == first_op_spill || first_op_spill->TryMerge(op_spill)) {",
          "content_same": false
        },
        {
          "line": 3912,
          "old_api": null,
          "new_api": "Eliminate",
          "old_text": null,
          "new_text": "move->Eliminate()",
          "old_line_content": "    // Gather all MoveOperands for a single ParallelMove.",
          "new_line_content": "        move->Eliminate();",
          "content_same": false
        },
        {
          "line": 3404,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "phi->operands().size()",
          "old_line_content": "  if (pos == nullptr) {",
          "new_line_content": "  if (num_merged * 2 <= phi->operands().size() ||",
          "content_same": false
        },
        {
          "line": 3405,
          "old_api": null,
          "new_api": "interval",
          "old_text": null,
          "new_text": "first_op_spill->interval()",
          "old_line_content": "    SpillRange* spill_range =",
          "new_line_content": "      AreUseIntervalsIntersecting(first_op_spill->interval(),",
          "content_same": false
        },
        {
          "line": 3919,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "to_eliminate.clear()",
          "old_line_content": "",
          "new_line_content": "      to_eliminate.clear();",
          "content_same": false
        },
        {
          "line": 3920,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "to_insert.clear()",
          "old_line_content": "",
          "new_line_content": "      to_insert.clear();",
          "content_same": false
        },
        {
          "line": 3412,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "range->Start()",
          "old_line_content": "    return true;",
          "new_line_content": "  LifetimePosition next_pos = range->Start();",
          "content_same": false
        },
        {
          "line": 3925,
          "old_api": null,
          "new_api": "code_zone",
          "old_text": null,
          "new_text": "code_zone()",
          "old_line_content": "",
          "new_line_content": "        new (code_zone()) MoveOperands(it->first.second, it->second);",
          "content_same": false
        },
        {
          "line": 3414,
          "old_api": null,
          "new_api": "NextUsePositionRegisterIsBeneficial",
          "old_text": null,
          "new_text": "range->NextUsePositionRegisterIsBeneficial(next_pos)",
          "old_line_content": "    SpillRange* spill_range =",
          "new_line_content": "  UsePosition* pos = range->NextUsePositionRegisterIsBeneficial(next_pos);",
          "content_same": false
        },
        {
          "line": 3419,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()",
          "old_line_content": "    if (!merged) return false;",
          "new_line_content": "            : data()->AssignSpillRangeToLiveRange(range->TopLevel());",
          "content_same": false
        },
        {
          "line": 3422,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "Spill(range)",
          "old_line_content": "  }",
          "new_line_content": "    Spill(range);",
          "content_same": false
        },
        {
          "line": 3424,
          "old_api": null,
          "new_api": "NextStart",
          "old_text": null,
          "new_text": "range->Start().NextStart()",
          "old_line_content": "}",
          "new_line_content": "  } else if (pos->pos() > range->Start().NextStart()) {",
          "content_same": false
        },
        {
          "line": 3426,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->HasSpillRange()",
          "old_line_content": "",
          "new_line_content": "        range->TopLevel()->HasSpillRange()",
          "content_same": false
        },
        {
          "line": 3427,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->GetSpillRange()",
          "old_line_content": "void LinearScanAllocator::SpillAfter(LiveRange* range, LifetimePosition pos) {",
          "new_line_content": "            ? range->TopLevel()->GetSpillRange()",
          "content_same": false
        },
        {
          "line": 3938,
          "old_api": null,
          "new_api": "GetSpillRangeOperand",
          "old_text": null,
          "new_text": "range->GetSpillRangeOperand()",
          "old_line_content": "        continue;",
          "new_line_content": "  InstructionOperand spill_operand = range->GetSpillRangeOperand();",
          "content_same": false
        },
        {
          "line": 3941,
          "old_api": null,
          "new_api": "vreg",
          "old_text": null,
          "new_text": "range->vreg()",
          "old_line_content": "              ->rpo_number());",
          "new_line_content": "        range->vreg());",
          "content_same": false
        },
        {
          "line": 3431,
          "old_api": null,
          "new_api": "pos",
          "old_text": null,
          "new_text": "pos->pos()",
          "old_line_content": "",
          "new_line_content": "    SpillBetween(range, range->Start(), pos->pos());",
          "content_same": false
        },
        {
          "line": 3945,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "child->next()",
          "old_line_content": "  ZoneQueue<int> worklist(temp_zone);",
          "new_line_content": "       child = child->next()) {",
          "content_same": false
        },
        {
          "line": 3946,
          "old_api": null,
          "new_api": "first_pos",
          "old_text": null,
          "new_text": "child->first_pos()",
          "old_line_content": "",
          "new_line_content": "    for (const UsePosition* pos = child->first_pos(); pos != nullptr;",
          "content_same": false
        },
        {
          "line": 3947,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "pos->next()",
          "old_line_content": "  for (BitVector::Iterator iterator(",
          "new_line_content": "         pos = pos->next()) {",
          "content_same": false
        },
        {
          "line": 3439,
          "old_api": null,
          "new_api": "SplitRangeAt",
          "old_text": null,
          "new_text": "SplitRangeAt(range, pos)",
          "old_line_content": "void LinearScanAllocator::SpillBetweenUntil(LiveRange* range,",
          "new_line_content": "  LiveRange* second_part = SplitRangeAt(range, pos);",
          "content_same": false
        },
        {
          "line": 3440,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "Spill(second_part)",
          "old_line_content": "                                            LifetimePosition start,",
          "new_line_content": "  Spill(second_part);",
          "content_same": false
        },
        {
          "line": 3951,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "pos->pos().ToInstructionIndex()",
          "old_line_content": "  }",
          "new_line_content": "          code->GetInstructionBlock(pos->pos().ToInstructionIndex())",
          "content_same": false
        },
        {
          "line": 3968,
          "old_api": null,
          "new_api": "GetListOfBlocksRequiringSpillOperands",
          "old_text": null,
          "new_text": "range->GetListOfBlocksRequiringSpillOperands()->length()",
          "old_line_content": "",
          "new_line_content": "      range->GetListOfBlocksRequiringSpillOperands()->length(), temp_zone);",
          "content_same": false
        },
        {
          "line": 3971,
          "old_api": null,
          "new_api": "pop",
          "old_text": null,
          "new_text": "worklist.pop()",
          "old_line_content": "      } else {",
          "new_line_content": "    worklist.pop();",
          "content_same": false
        },
        {
          "line": 3972,
          "old_api": null,
          "new_api": "Contains",
          "old_text": null,
          "new_text": "done_blocks.Contains(block_id)",
          "old_line_content": "        LifetimePosition pred_end =",
          "new_line_content": "    if (done_blocks.Contains(block_id)) continue;",
          "content_same": false
        },
        {
          "line": 3461,
          "old_api": null,
          "new_api": "PrevStart",
          "old_text": null,
          "new_text": "end.PrevStart().End()",
          "old_line_content": "  } else {",
          "new_line_content": "    LifetimePosition third_part_end = end.PrevStart().End();",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "end.Start()",
          "old_line_content": "    // The split result does not intersect with [start, end[.",
          "new_line_content": "    if (data()->IsBlockBoundary(end.Start())) {",
          "content_same": false
        },
        {
          "line": 3463,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "end.Start()",
          "old_line_content": "    // Nothing to spill. Just put it to unhandled as whole.",
          "new_line_content": "      third_part_end = end.Start();",
          "content_same": false
        },
        {
          "line": 3975,
          "old_api": null,
          "new_api": "RpoNumber::FromInt(block_id)",
          "old_text": null,
          "new_text": "RpoNumber::FromInt(block_id)",
          "old_line_content": "",
          "new_line_content": "        code->InstructionBlockAt(RpoNumber::FromInt(block_id));",
          "content_same": false
        },
        {
          "line": 3465,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "SplitBetween(\n        second_part, Max(second_part->Start().End(), until), third_part_end)",
          "old_line_content": "  }",
          "new_line_content": "    LiveRange* third_part = SplitBetween(",
          "content_same": false
        },
        {
          "line": 3466,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "second_part->Start().End()",
          "old_line_content": "}",
          "new_line_content": "        second_part, Max(second_part->Start().End(), until), third_part_end);",
          "content_same": false
        },
        {
          "line": 3977,
          "old_api": null,
          "new_api": "predecessors",
          "old_text": null,
          "new_text": "spill_block->predecessors()",
          "old_line_content": "",
          "new_line_content": "    for (const RpoNumber& pred : spill_block->predecessors()) {",
          "content_same": false
        },
        {
          "line": 3468,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(third_part != second_part)",
          "old_line_content": "",
          "new_line_content": "    DCHECK(third_part != second_part);",
          "content_same": false
        },
        {
          "line": 3470,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "Spill(second_part)",
          "old_line_content": "    : data_(data) {}",
          "new_line_content": "    Spill(second_part);",
          "content_same": false
        },
        {
          "line": 3471,
          "old_api": null,
          "new_api": "AddToUnhandled",
          "old_text": null,
          "new_text": "AddToUnhandled(third_part)",
          "old_line_content": "",
          "new_line_content": "    AddToUnhandled(third_part);",
          "content_same": false
        },
        {
          "line": 3984,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::InstructionFromInstructionIndex(\n                pred_block->last_instruction_index())",
          "old_line_content": "                             Instruction::GapPosition::START, pred_op,",
          "new_line_content": "            LifetimePosition::InstructionFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 3985,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "pred_block->last_instruction_index()",
          "old_line_content": "                             spill_operand);",
          "new_line_content": "                pred_block->last_instruction_index());",
          "content_same": false
        },
        {
          "line": 3989,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "bound->range_->GetAssignedOperand()",
          "old_line_content": "      }",
          "new_line_content": "        InstructionOperand pred_op = bound->range_->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3991,
          "old_api": null,
          "new_api": "rpo_number",
          "old_text": null,
          "new_text": "spill_block->rpo_number()",
          "old_line_content": "  }",
          "new_line_content": "        RpoNumber spill_block_number = spill_block->rpo_number();",
          "content_same": false
        },
        {
          "line": 3992,
          "old_api": null,
          "new_api": "vreg",
          "old_text": null,
          "new_text": "std::make_pair(\n                spill_block_number, range->vreg())",
          "old_line_content": "}",
          "new_line_content": "        if (done_moves.find(std::make_pair(",
          "content_same": false
        },
        {
          "line": 3993,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "done_moves.end()",
          "old_line_content": "",
          "new_line_content": "                spill_block_number, range->vreg())) == done_moves.end()) {",
          "content_same": false
        },
        {
          "line": 3994,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "spill_block->first_instruction_index()",
          "old_line_content": "#undef TRACE",
          "new_line_content": "          data()->AddGapMove(spill_block->first_instruction_index(),",
          "content_same": false
        },
        {
          "line": 3997,
          "old_api": null,
          "new_api": "vreg",
          "old_text": null,
          "new_text": "range->vreg()",
          "old_line_content": "}  // namespace internal",
          "new_line_content": "          done_moves.insert(std::make_pair(spill_block_number, range->vreg()));",
          "content_same": false
        },
        {
          "line": 3998,
          "old_api": null,
          "new_api": "mark_needs_frame",
          "old_text": null,
          "new_text": "spill_block->mark_needs_frame()",
          "old_line_content": "}  // namespace v8",
          "new_line_content": "          spill_block->mark_needs_frame();",
          "content_same": false
        },
        {
          "line": 3487,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "    for (; spills != nullptr; spills = spills->next) {",
          "new_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3489,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "    }",
          "new_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "content_same": false
        },
        {
          "line": 3490,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "range->IsEmpty()",
          "old_line_content": "  }",
          "new_line_content": "    if (range == nullptr || range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 3492,
          "old_api": null,
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": null,
          "new_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "",
          "new_line_content": "    if (!range->HasSpillRange() || range->IsSpilledOnlyInDeferredBlocks()) {",
          "content_same": false
        },
        {
          "line": 3496,
          "old_api": null,
          "new_api": "GetSpillMoveInsertionLocations",
          "old_text": null,
          "new_text": "range->GetSpillMoveInsertionLocations()",
          "old_line_content": "",
          "new_line_content": "        range->GetSpillMoveInsertionLocations();",
          "content_same": false
        },
        {
          "line": 3497,
          "old_api": null,
          "new_api": "DCHECK_NOT_NULL",
          "old_text": null,
          "new_text": "DCHECK_NOT_NULL(spills)",
          "old_line_content": "void OperandAssigner::AssignSpillSlots() {",
          "new_line_content": "    DCHECK_NOT_NULL(spills);",
          "content_same": false
        },
        {
          "line": 3499,
          "old_api": null,
          "new_api": "GetInstructionBlock",
          "old_text": null,
          "new_text": "code->GetInstructionBlock(spills->gap_index)->mark_needs_frame()",
          "old_line_content": "  // Merge disjoint spill ranges",
          "new_line_content": "      code->GetInstructionBlock(spills->gap_index)->mark_needs_frame();",
          "content_same": false
        },
        {
          "line": 3509,
          "old_api": null,
          "new_api": "spill_ranges",
          "old_text": null,
          "new_text": "data()->spill_ranges()",
          "old_line_content": "    }",
          "new_line_content": "  ZoneVector<SpillRange*>& spill_ranges = data()->spill_ranges();",
          "content_same": false
        },
        {
          "line": 3511,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "spill_ranges.size()",
          "old_line_content": "  // Allocate slots for the merged spill ranges.",
          "new_line_content": "  for (size_t i = 0; i < spill_ranges.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 3514,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "range->IsEmpty()",
          "old_line_content": "    // Allocate a new operand referring to the spill slot.",
          "new_line_content": "    if (range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 3518,
          "old_api": null,
          "new_api": "TryMerge",
          "old_text": null,
          "new_text": "range->TryMerge(other)",
          "old_line_content": "    }",
          "new_line_content": "        range->TryMerge(other);",
          "content_same": false
        },
        {
          "line": 3538,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "    }",
          "new_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "content_same": false
        },
        {
          "line": 3539,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "top_range->IsEmpty()",
          "old_line_content": "    for (LiveRange* range = top_range; range != nullptr;",
          "new_line_content": "    if (top_range == nullptr || top_range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 3544,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "top_range->TopLevel()->GetSpillRangeOperand()",
          "old_line_content": "    }",
          "new_line_content": "      spill_operand = top_range->TopLevel()->GetSpillRangeOperand();",
          "content_same": false
        },
        {
          "line": 3547,
          "old_api": null,
          "new_api": "GetPhiMapValueFor",
          "old_text": null,
          "new_text": "data()->GetPhiMapValueFor(top_range)->CommitAssignment(\n          top_range->GetAssignedOperand())",
          "old_line_content": "      // If this top level range has a child spilled in a deferred block, we use",
          "new_line_content": "      data()->GetPhiMapValueFor(top_range)->CommitAssignment(",
          "content_same": false
        },
        {
          "line": 3548,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "top_range->GetAssignedOperand()",
          "old_line_content": "      // the range and control flow connection mechanism instead of spilling at",
          "new_line_content": "          top_range->GetAssignedOperand());",
          "content_same": false
        },
        {
          "line": 3551,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "range->next()",
          "old_line_content": "      // connecting move when a successor child range is spilled - because the",
          "new_line_content": "         range = range->next()) {",
          "content_same": false
        },
        {
          "line": 3552,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "range->GetAssignedOperand()",
          "old_line_content": "      // spilled range picks up its value from the slot which was assigned at",
          "new_line_content": "      InstructionOperand assigned = range->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3553,
          "old_api": null,
          "new_api": "IsUnallocated",
          "old_text": null,
          "new_text": "assigned.IsUnallocated()",
          "old_line_content": "      // definition. For ranges that are determined to spill only in deferred",
          "new_line_content": "      DCHECK(!assigned.IsUnallocated());",
          "content_same": false
        },
        {
          "line": 3554,
          "old_api": null,
          "new_api": "ConvertUsesToOperand",
          "old_text": null,
          "new_text": "range->ConvertUsesToOperand(assigned, spill_operand)",
          "old_line_content": "      // blocks, we let ConnectLiveRanges and ResolveControlFlow find the blocks",
          "new_line_content": "      range->ConvertUsesToOperand(assigned, spill_operand);",
          "content_same": false
        },
        {
          "line": 3568,
          "old_api": null,
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": null,
          "new_text": "top_range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "",
          "new_line_content": "      if (!top_range->IsSpilledOnlyInDeferredBlocks()) {",
          "content_same": false
        },
        {
          "line": 3571,
          "old_api": null,
          "new_api": "CommitSpillMoves",
          "old_text": null,
          "new_text": "top_range->CommitSpillMoves(\n            data()->code(), spill_operand,\n            top_range->has_slot_use() || top_range->spilled())",
          "old_line_content": "",
          "new_line_content": "        top_range->CommitSpillMoves(",
          "content_same": false
        },
        {
          "line": 3572,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "data()->code()",
          "old_line_content": "",
          "new_line_content": "            data()->code(), spill_operand,",
          "content_same": false
        },
        {
          "line": 3573,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "top_range->spilled()",
          "old_line_content": "bool ReferenceMapPopulator::SafePointsAreInOrder() const {",
          "new_line_content": "            top_range->has_slot_use() || top_range->spilled());",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 3584,
          "old_api": "SafePointsAreInOrder",
          "new_api": null,
          "old_text": "SafePointsAreInOrder()",
          "new_text": null,
          "old_line_content": "  DCHECK(SafePointsAreInOrder());",
          "new_line_content": "bool ReferenceMapPopulator::SafePointsAreInOrder() const {",
          "content_same": false
        },
        {
          "line": 3589,
          "old_api": "AllocatedOperand::cast(*delayed_reference.operand)",
          "new_api": null,
          "old_text": "AllocatedOperand::cast(*delayed_reference.operand)",
          "new_text": null,
          "old_line_content": "        AllocatedOperand::cast(*delayed_reference.operand));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3594,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()->reference_maps()",
          "new_text": null,
          "old_line_content": "  const ReferenceMapDeque* reference_maps = data()->code()->reference_maps();",
          "new_line_content": "void ReferenceMapPopulator::PopulateReferenceMaps() {",
          "content_same": false
        },
        {
          "line": 3596,
          "old_api": "size",
          "new_api": null,
          "old_text": "data()->live_ranges().size()",
          "new_text": null,
          "old_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "new_line_content": "  // Map all delayed references.",
          "content_same": false
        },
        {
          "line": 3597,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "new_line_content": "  for (RegisterAllocationData::DelayedReference& delayed_reference :",
          "content_same": false
        },
        {
          "line": 3602,
          "old_api": "IsReference",
          "new_api": null,
          "old_text": "data()->IsReference(range)",
          "new_text": null,
          "old_line_content": "    if (!data()->IsReference(range)) continue;",
          "new_line_content": "  // Iterate over all safe point positions and record a pointer",
          "content_same": false
        },
        {
          "line": 3604,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (range->IsEmpty()) continue;",
          "new_line_content": "  int last_range_start = 0;",
          "content_same": false
        },
        {
          "line": 3611,
          "old_api": "End",
          "new_api": null,
          "old_text": "cur->End()",
          "new_text": null,
          "old_line_content": "      LifetimePosition this_end = cur->End();",
          "new_line_content": "    if (range == nullptr) continue;",
          "content_same": false
        },
        {
          "line": 3612,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "this_end.ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "      if (this_end.ToInstructionIndex() > end)",
          "new_line_content": "    // Skip non-reference values.",
          "content_same": false
        },
        {
          "line": 3614,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "cur->Start().ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "      DCHECK(cur->Start().ToInstructionIndex() >= start);",
          "new_line_content": "    // Skip empty live ranges.",
          "content_same": false
        },
        {
          "line": 3103,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "  if (pos <= current->Start()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3108,
          "old_api": "End",
          "new_api": null,
          "old_text": "current->End()",
          "new_text": null,
          "old_line_content": "  if (pos < current->End()) {",
          "new_line_content": "      reg = code;",
          "content_same": false
        },
        {
          "line": 3111,
          "old_api": "SplitRangeAt",
          "new_api": null,
          "old_text": "SplitRangeAt(current, pos)",
          "new_text": null,
          "old_line_content": "    LiveRange* tail = SplitRangeAt(current, pos);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3112,
          "old_api": "AddToUnhandled",
          "new_api": null,
          "old_text": "AddToUnhandled(tail)",
          "new_text": null,
          "old_line_content": "    AddToUnhandled(tail);",
          "new_line_content": "  LifetimePosition pos = free_until_pos[reg];",
          "content_same": false
        },
        {
          "line": 3626,
          "old_api": "instruction_position",
          "new_api": null,
          "old_text": "map->instruction_position()",
          "new_text": null,
          "old_line_content": "      if (map->instruction_position() >= start) break;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3115,
          "old_api": "TryAllocatePreferredReg",
          "new_api": null,
          "old_text": "TryAllocatePreferredReg(current, free_until_pos)",
          "new_text": null,
          "old_line_content": "    if (TryAllocatePreferredReg(current, free_until_pos)) return true;",
          "new_line_content": "    // All registers are blocked.",
          "content_same": false
        },
        {
          "line": 3631,
          "old_api": "GetSpillOperand",
          "new_api": null,
          "old_text": "range->GetSpillOperand()->IsConstant()",
          "new_text": null,
          "old_line_content": "          !range->GetSpillOperand()->IsConstant()) ||",
          "new_line_content": "    last_range_start = start;",
          "content_same": false
        },
        {
          "line": 3120,
          "old_api": "End",
          "new_api": null,
          "old_text": "current->End()",
          "new_text": null,
          "old_line_content": "  DCHECK(pos >= current->End());",
          "new_line_content": "    // Register reg is available at the range start but becomes blocked before",
          "content_same": false
        },
        {
          "line": 3121,
          "old_api": "RegisterName",
          "new_api": null,
          "old_text": "RegisterName(reg)",
          "new_text": null,
          "old_line_content": "  TRACE(\"Assigning free reg %s to live range %d:%d\\n\", RegisterName(reg),",
          "new_line_content": "    // the range end. Split current at position where it becomes blocked.",
          "content_same": false
        },
        {
          "line": 3632,
          "old_api": "HasSpillRange",
          "new_api": null,
          "old_text": "range->HasSpillRange()",
          "new_text": null,
          "old_line_content": "         range->HasSpillRange())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3633,
          "old_api": "HasSpillOperand",
          "new_api": null,
          "old_text": "range->HasSpillOperand()",
          "new_text": null,
          "old_line_content": "      if (range->HasSpillOperand()) {",
          "new_line_content": "    // Step across all the safe points that are before the start of this range,",
          "content_same": false
        },
        {
          "line": 3634,
          "old_api": "GetSpillOperand",
          "new_api": null,
          "old_text": "range->GetSpillOperand()",
          "new_text": null,
          "old_line_content": "        spill_operand = *range->GetSpillOperand();",
          "new_line_content": "    // recording how far we step in order to save doing this for the next range.",
          "content_same": false
        },
        {
          "line": 3636,
          "old_api": "GetSpillRangeOperand",
          "new_api": null,
          "old_text": "range->GetSpillRangeOperand()",
          "new_text": null,
          "old_line_content": "        spill_operand = range->GetSpillRangeOperand();",
          "new_line_content": "      ReferenceMap* map = *first_it;",
          "content_same": false
        },
        {
          "line": 3638,
          "old_api": "IsStackSlot",
          "new_api": null,
          "old_text": "spill_operand.IsStackSlot()",
          "new_text": null,
          "old_line_content": "      DCHECK(spill_operand.IsStackSlot());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3639,
          "old_api": "representation",
          "new_api": null,
          "old_text": "CanBeTaggedPointer(\n          AllocatedOperand::cast(spill_operand).representation())",
          "new_text": null,
          "old_line_content": "      DCHECK(CanBeTaggedPointer(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3640,
          "old_api": "representation",
          "new_api": null,
          "old_text": "AllocatedOperand::cast(spill_operand).representation()",
          "new_text": null,
          "old_line_content": "          AllocatedOperand::cast(spill_operand).representation()));",
          "new_line_content": "    InstructionOperand spill_operand;",
          "content_same": false
        },
        {
          "line": 3129,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "  UsePosition* register_use = current->NextRegisterPosition(current->Start());",
          "new_line_content": "  // Register reg is available at the range start and is free until the range",
          "content_same": false
        },
        {
          "line": 3137,
          "old_api": "num_registers",
          "new_api": null,
          "old_text": "num_registers()",
          "new_text": null,
          "old_line_content": "  int num_regs = num_registers();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3138,
          "old_api": "num_allocatable_registers",
          "new_api": null,
          "old_text": "num_allocatable_registers()",
          "new_text": null,
          "old_line_content": "  int num_codes = num_allocatable_registers();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3139,
          "old_api": "allocatable_register_codes",
          "new_api": null,
          "old_text": "allocatable_register_codes()",
          "new_text": null,
          "old_line_content": "  const int* codes = allocatable_register_codes();",
          "new_line_content": "void LinearScanAllocator::AllocateBlockedReg(LiveRange* current) {",
          "content_same": false
        },
        {
          "line": 3143,
          "old_api": "GetFPRegisterSet",
          "new_api": null,
          "old_text": "GetFPRegisterSet(rep, &num_regs, &num_codes, &codes)",
          "new_text": null,
          "old_line_content": "    GetFPRegisterSet(rep, &num_regs, &num_codes, &codes);",
          "new_line_content": "    // We can just spill it.",
          "content_same": false
        },
        {
          "line": 3655,
          "old_api": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "new_api": null,
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "new_text": null,
          "old_line_content": "          LifetimePosition::InstructionFromInstructionIndex(safe_point);",
          "new_line_content": "    // Step through the safe points to see whether they are in the range.",
          "content_same": false
        },
        {
          "line": 3663,
          "old_api": "DCHECK_NOT_NULL",
          "new_api": null,
          "old_text": "DCHECK_NOT_NULL(cur)",
          "new_text": null,
          "old_line_content": "      DCHECK_NOT_NULL(cur);",
          "new_line_content": "      // Advance to the next active range that covers the current",
          "content_same": false
        },
        {
          "line": 3664,
          "old_api": "Start",
          "new_api": null,
          "old_text": "cur->Start()",
          "new_text": null,
          "old_line_content": "      DCHECK(safe_point_pos >= cur->Start() || range == cur);",
          "new_line_content": "      // safe point position.",
          "content_same": false
        },
        {
          "line": 3155,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "range->assigned_register()",
          "new_text": null,
          "old_line_content": "    int cur_reg = range->assigned_register();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3667,
          "old_api": "Covers",
          "new_api": null,
          "old_text": "cur->Covers(safe_point_pos)",
          "new_text": null,
          "old_line_content": "        if (cur->Covers(safe_point_pos)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3157,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "        range->TopLevel()->IsFixed() || !range->CanBeSpilled(current->Start());",
          "new_line_content": "  // block_pos keeps track of positions where a register/alias is blocked",
          "content_same": false
        },
        {
          "line": 3158,
          "old_api": "check_fp_aliasing",
          "new_api": null,
          "old_text": "check_fp_aliasing()",
          "new_text": null,
          "old_line_content": "    if (kSimpleFPAliasing || !check_fp_aliasing()) {",
          "new_line_content": "  // from.",
          "content_same": false
        },
        {
          "line": 3670,
          "old_api": "next",
          "new_api": null,
          "old_text": "cur->next()",
          "new_text": null,
          "old_line_content": "          LiveRange* next = cur->next();",
          "new_line_content": "      // the last child, because the next safe_point_pos may be covered by cur.",
          "content_same": false
        },
        {
          "line": 3671,
          "old_api": "Start",
          "new_api": null,
          "old_text": "next->Start()",
          "new_text": null,
          "old_line_content": "          if (next == nullptr || next->Start() > safe_point_pos) {",
          "new_line_content": "      // This may happen if cur has more than one interval, and the current",
          "content_same": false
        },
        {
          "line": 3161,
          "old_api": "LifetimePosition::GapFromInstructionIndex(0)",
          "new_api": null,
          "old_text": "LifetimePosition::GapFromInstructionIndex(0)",
          "new_text": null,
          "old_line_content": "            LifetimePosition::GapFromInstructionIndex(0);",
          "new_line_content": "  for (int i = 0; i < num_regs; i++) {",
          "content_same": false
        },
        {
          "line": 3163,
          "old_api": "LifetimePosition::GapFromInstructionIndex(0)",
          "new_api": null,
          "old_text": "LifetimePosition::GapFromInstructionIndex(0)",
          "new_text": null,
          "old_line_content": "        DCHECK_NE(LifetimePosition::GapFromInstructionIndex(0),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3170,
          "old_api": "config",
          "new_api": null,
          "old_text": "data()->config()->GetAliases(\n          range->representation(), cur_reg, rep, &alias_base_index)",
          "new_text": null,
          "old_line_content": "      int aliases = data()->config()->GetAliases(",
          "new_line_content": "      if (is_fixed_or_cant_spill) {",
          "content_same": false
        },
        {
          "line": 3171,
          "old_api": "representation",
          "new_api": null,
          "old_text": "range->representation()",
          "new_text": null,
          "old_line_content": "          range->representation(), cur_reg, rep, &alias_base_index);",
          "new_line_content": "        block_pos[cur_reg] = use_pos[cur_reg] =",
          "content_same": false
        },
        {
          "line": 3684,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": null,
          "old_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": null,
          "old_line_content": "      int spill_index = range->IsSpilledOnlyInDeferredBlocks()",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 3685,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "cur->Start().ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "                            ? cur->Start().ToInstructionIndex()",
          "new_line_content": "          cur = next;",
          "content_same": false
        },
        {
          "line": 3686,
          "old_api": "spill_start_index",
          "new_api": null,
          "old_text": "range->spill_start_index()",
          "new_text": null,
          "old_line_content": "                            : range->spill_start_index();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3688,
          "old_api": "IsInvalid",
          "new_api": null,
          "old_text": "spill_operand.IsInvalid()",
          "new_text": null,
          "old_line_content": "      if (!spill_operand.IsInvalid() && safe_point >= spill_index) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3689,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",\n              range->vreg(), spill_index, safe_point)",
          "new_text": null,
          "old_line_content": "        TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",",
          "new_line_content": "      if (!found) {",
          "content_same": false
        },
        {
          "line": 3690,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "range->vreg()",
          "new_text": null,
          "old_line_content": "              range->vreg(), spill_index, safe_point);",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 3691,
          "old_api": "AllocatedOperand::cast(spill_operand)",
          "new_api": null,
          "old_text": "AllocatedOperand::cast(spill_operand)",
          "new_text": null,
          "old_line_content": "        map->RecordReference(AllocatedOperand::cast(spill_operand));",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3180,
          "old_api": "NextLifetimePositionRegisterIsBeneficial",
          "new_api": null,
          "old_text": "Min(block_pos[aliased_reg],\n                  range->NextLifetimePositionRegisterIsBeneficial(\n                      current->Start()))",
          "new_text": null,
          "old_line_content": "              Min(block_pos[aliased_reg],",
          "new_line_content": "      int alias_base_index = -1;",
          "content_same": false
        },
        {
          "line": 3694,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "cur->spilled()",
          "new_text": null,
          "old_line_content": "      if (!cur->spilled()) {",
          "new_line_content": "      // the spill position.",
          "content_same": false
        },
        {
          "line": 3698,
          "old_api": "value",
          "new_api": null,
          "old_text": "cur->Start().value()",
          "new_text": null,
          "old_line_content": "            range->vreg(), cur->relative_id(), cur->Start().value(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3189,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "    DCHECK(range->End() > current->Start());",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 3190,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "range->assigned_register()",
          "new_text": null,
          "old_line_content": "    int cur_reg = range->assigned_register();",
          "new_line_content": "          use_pos[aliased_reg] =",
          "content_same": false
        },
        {
          "line": 3703,
          "old_api": "representation",
          "new_api": null,
          "old_text": "AllocatedOperand::cast(operand).representation()",
          "new_text": null,
          "old_line_content": "            AllocatedOperand::cast(operand).representation()));",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3704,
          "old_api": "AllocatedOperand::cast(operand)",
          "new_api": null,
          "old_text": "AllocatedOperand::cast(operand)",
          "new_text": null,
          "old_line_content": "        map->RecordReference(AllocatedOperand::cast(operand));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3196,
          "old_api": "check_fp_aliasing",
          "new_api": null,
          "old_text": "check_fp_aliasing()",
          "new_text": null,
          "old_line_content": "    if ((kSimpleFPAliasing || !check_fp_aliasing())) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3198,
          "old_api": "Start",
          "new_api": null,
          "old_text": "range->Start()",
          "new_text": null,
          "old_line_content": "        if (block_pos[cur_reg] < range->Start()) continue;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3204,
          "old_api": "FirstIntersection",
          "new_api": null,
          "old_text": "range->FirstIntersection(current)",
          "new_text": null,
          "old_line_content": "    LifetimePosition next_intersection = range->FirstIntersection(current);",
          "new_line_content": "    // Don't perform costly intersections if they are guaranteed to not update",
          "content_same": false
        },
        {
          "line": 3205,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "next_intersection.IsValid()",
          "new_text": null,
          "old_line_content": "    if (!next_intersection.IsValid()) continue;",
          "new_line_content": "    // block_pos or use_pos.",
          "content_same": false
        },
        {
          "line": 3717,
          "old_api": "PredecessorCount",
          "new_api": null,
          "old_text": "block->PredecessorCount()",
          "new_text": null,
          "old_line_content": "  if (block->PredecessorCount() != 1) return false;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3718,
          "old_api": "rpo_number",
          "new_api": null,
          "old_text": "block->rpo_number()",
          "new_text": null,
          "old_line_content": "  return block->predecessors()[0].IsNext(block->rpo_number());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3210,
          "old_api": "Min",
          "new_api": null,
          "old_text": "Min(block_pos[cur_reg], use_pos[cur_reg])",
          "new_text": null,
          "old_line_content": "        use_pos[cur_reg] = Min(block_pos[cur_reg], use_pos[cur_reg]);",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 3212,
          "old_api": "Min",
          "new_api": null,
          "old_text": "Min(use_pos[cur_reg], next_intersection)",
          "new_text": null,
          "old_line_content": "        use_pos[cur_reg] = Min(use_pos[cur_reg], next_intersection);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3725,
          "old_api": "live_in_sets",
          "new_api": null,
          "old_text": "data()->live_in_sets()",
          "new_text": null,
          "old_line_content": "  ZoneVector<BitVector*>& live_in_sets = data()->live_in_sets();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3726,
          "old_api": "instruction_blocks",
          "new_api": null,
          "old_text": "code()->instruction_blocks()",
          "new_text": null,
          "old_line_content": "  for (const InstructionBlock* block : code()->instruction_blocks()) {",
          "new_line_content": "bool LiveRangeConnector::CanEagerlyResolveControlFlow(",
          "content_same": false
        },
        {
          "line": 3727,
          "old_api": "CanEagerlyResolveControlFlow",
          "new_api": null,
          "old_text": "CanEagerlyResolveControlFlow(block)",
          "new_text": null,
          "old_line_content": "    if (CanEagerlyResolveControlFlow(block)) continue;",
          "new_line_content": "    const InstructionBlock* block) const {",
          "content_same": false
        },
        {
          "line": 3217,
          "old_api": "representation",
          "new_api": null,
          "old_text": "range->representation()",
          "new_text": null,
          "old_line_content": "          range->representation(), cur_reg, rep, &alias_base_index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3730,
          "old_api": "Done",
          "new_api": null,
          "old_text": "iterator.Done()",
          "new_text": null,
          "old_line_content": "    while (!iterator.Done()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3731,
          "old_api": "Current",
          "new_api": null,
          "old_text": "iterator.Current()",
          "new_text": null,
          "old_line_content": "      int vreg = iterator.Current();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3732,
          "old_api": "ArrayFor",
          "new_api": null,
          "old_text": "finder.ArrayFor(vreg)",
          "new_text": null,
          "old_line_content": "      LiveRangeBoundArray* array = finder.ArrayFor(vreg);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3733,
          "old_api": "predecessors",
          "new_api": null,
          "old_text": "block->predecessors()",
          "new_text": null,
          "old_line_content": "      for (const RpoNumber& pred : block->predecessors()) {",
          "new_line_content": "void LiveRangeConnector::ResolveControlFlow(Zone* local_zone) {",
          "content_same": false
        },
        {
          "line": 3735,
          "old_api": "InstructionBlockAt",
          "new_api": null,
          "old_text": "code()->InstructionBlockAt(pred)",
          "new_text": null,
          "old_line_content": "        const InstructionBlock* pred_block = code()->InstructionBlockAt(pred);",
          "new_line_content": "  LiveRangeFinder finder(data(), local_zone);",
          "content_same": false
        },
        {
          "line": 3225,
          "old_api": "Min",
          "new_api": null,
          "old_text": "Min(block_pos[aliased_reg], use_pos[aliased_reg])",
          "new_text": null,
          "old_line_content": "              Min(block_pos[aliased_reg], use_pos[aliased_reg]);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 3740,
          "old_api": "GetAssignedOperand",
          "new_api": null,
          "old_text": "result.cur_cover_->GetAssignedOperand()",
          "new_text": null,
          "old_line_content": "        InstructionOperand cur_op = result.cur_cover_->GetAssignedOperand();",
          "new_line_content": "    BitVector::Iterator iterator(live);",
          "content_same": false
        },
        {
          "line": 3749,
          "old_api": "code_start",
          "new_api": null,
          "old_text": "block->code_start()",
          "new_text": null,
          "old_line_content": "              LifetimePosition::GapFromInstructionIndex(block->code_start());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3241,
          "old_api": "pos",
          "new_api": null,
          "old_text": "register_use->pos()",
          "new_text": null,
          "old_line_content": "  if (use_pos[reg] < register_use->pos()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3754,
          "old_api": "End",
          "new_api": null,
          "old_text": "current->End()",
          "new_text": null,
          "old_line_content": "          if (current->End() < block_end &&",
          "new_line_content": "          // We're doing a reload.",
          "content_same": false
        },
        {
          "line": 3755,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "successor->spilled()",
          "new_text": null,
          "old_line_content": "              (successor == nullptr || successor->spilled())) {",
          "new_line_content": "          // We don't need to, if:",
          "content_same": false
        },
        {
          "line": 3244,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "    if (LifetimePosition::ExistsGapPositionBetween(current->Start(),",
          "new_line_content": "  int reg = codes[0];",
          "content_same": false
        },
        {
          "line": 3245,
          "old_api": "pos",
          "new_api": null,
          "old_text": "register_use->pos()",
          "new_text": null,
          "old_line_content": "                                                   register_use->pos())) {",
          "new_line_content": "  for (int i = 1; i < num_codes; ++i) {",
          "content_same": false
        },
        {
          "line": 3246,
          "old_api": "pos",
          "new_api": null,
          "old_text": "register_use->pos()",
          "new_text": null,
          "old_line_content": "      SpillBetween(current, current->Start(), register_use->pos());",
          "new_line_content": "    int code = codes[i];",
          "content_same": false
        },
        {
          "line": 3761,
          "old_api": "next",
          "new_api": null,
          "old_text": "use->next()",
          "new_text": null,
          "old_line_content": "                 use != nullptr; use = use->next()) {",
          "new_line_content": "          LifetimePosition block_end =",
          "content_same": false
        },
        {
          "line": 3253,
          "old_api": "End",
          "new_api": null,
          "old_text": "current->End()",
          "new_text": null,
          "old_line_content": "  if (block_pos[reg] < current->End()) {",
          "new_line_content": "    // If there is a gap position before the next register use, we can",
          "content_same": false
        },
        {
          "line": 3769,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "current->TopLevel()->IsSpilledOnlyInDeferredBlocks()",
          "new_text": null,
          "old_line_content": "          if (current->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3258,
          "old_api": "AddToUnhandled",
          "new_api": null,
          "old_text": "AddToUnhandled(tail)",
          "new_text": null,
          "old_line_content": "    AddToUnhandled(tail);",
          "new_line_content": "      return;",
          "content_same": false
        },
        {
          "line": 3770,
          "old_api": "IsDeferred",
          "new_api": null,
          "old_text": "pred_block->IsDeferred()",
          "new_text": null,
          "old_line_content": "              pred_block->IsDeferred()) {",
          "new_line_content": "            bool uses_reg = false;",
          "content_same": false
        },
        {
          "line": 3262,
          "old_api": "End",
          "new_api": null,
          "old_text": "current->End()",
          "new_text": null,
          "old_line_content": "  DCHECK(block_pos[reg] >= current->End());",
          "new_line_content": "  // We couldn't spill until the next register use. Split before the register",
          "content_same": false
        },
        {
          "line": 3263,
          "old_api": "RegisterName",
          "new_api": null,
          "old_text": "RegisterName(reg)",
          "new_text": null,
          "old_line_content": "  TRACE(\"Assigning blocked reg %s to live range %d:%d\\n\", RegisterName(reg),",
          "new_line_content": "  // is blocked, if applicable.",
          "content_same": false
        },
        {
          "line": 3774,
          "old_api": "ToInt",
          "new_api": null,
          "old_text": "pred_block->rpo_number().ToInt()",
          "new_text": null,
          "old_line_content": "                pred_block->rpo_number().ToInt());",
          "new_line_content": "                uses_reg = true;",
          "content_same": false
        },
        {
          "line": 3265,
          "old_api": "SetLiveRangeAssignedRegister",
          "new_api": null,
          "old_text": "SetLiveRangeAssignedRegister(current, reg)",
          "new_text": null,
          "old_line_content": "  SetLiveRangeAssignedRegister(current, reg);",
          "new_line_content": "    // Register becomes blocked before the current range end. Split before that",
          "content_same": false
        },
        {
          "line": 3777,
          "old_api": "ResolveControlFlow",
          "new_api": null,
          "old_text": "ResolveControlFlow(block, cur_op, pred_block, pred_op)",
          "new_text": null,
          "old_line_content": "        int move_loc = ResolveControlFlow(block, cur_op, pred_block, pred_op);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3778,
          "old_api": "USE",
          "new_api": null,
          "old_text": "USE(move_loc)",
          "new_text": null,
          "old_line_content": "        USE(move_loc);",
          "new_line_content": "            if (!uses_reg) continue;",
          "content_same": false
        },
        {
          "line": 3779,
          "old_api": "IsAnyRegister",
          "new_api": null,
          "old_text": "DCHECK_IMPLIES(\n            result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&\n                !(pred_op.IsAnyRegister() && cur_op.IsAnyRegister()),\n            code()->GetInstructionBlock(move_loc)->IsDeferred())",
          "new_text": null,
          "old_line_content": "        DCHECK_IMPLIES(",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 3270,
          "old_api": "SplitAndSpillIntersecting",
          "new_api": null,
          "old_text": "SplitAndSpillIntersecting(current)",
          "new_text": null,
          "old_line_content": "  SplitAndSpillIntersecting(current);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3782,
          "old_api": "GetInstructionBlock",
          "new_api": null,
          "old_text": "code()->GetInstructionBlock(move_loc)->IsDeferred()",
          "new_text": null,
          "old_line_content": "            code()->GetInstructionBlock(move_loc)->IsDeferred());",
          "new_line_content": "            // The spill location should be defined in pred_block, so add",
          "content_same": false
        },
        {
          "line": 3277,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "  LifetimePosition split_pos = current->Start();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3278,
          "old_api": "size",
          "new_api": null,
          "old_text": "active_live_ranges().size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < active_live_ranges().size(); ++i) {",
          "new_line_content": "  // This register was not free. Thus we need to find and spill",
          "content_same": false
        },
        {
          "line": 3279,
          "old_api": "active_live_ranges",
          "new_api": null,
          "old_text": "active_live_ranges()",
          "new_text": null,
          "old_line_content": "    LiveRange* range = active_live_ranges()[i];",
          "new_line_content": "  // parts of active and inactive live regions that use the same register",
          "content_same": false
        },
        {
          "line": 3280,
          "old_api": "check_fp_aliasing",
          "new_api": null,
          "old_text": "check_fp_aliasing()",
          "new_text": null,
          "old_line_content": "    if (kSimpleFPAliasing || !check_fp_aliasing()) {",
          "new_line_content": "  // at the same lifetime positions as current.",
          "content_same": false
        },
        {
          "line": 3794,
          "old_api": "size",
          "new_api": null,
          "old_text": "data()->live_ranges().size()",
          "new_text": null,
          "old_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3283,
          "old_api": "representation",
          "new_api": null,
          "old_text": "current->representation()",
          "new_text": null,
          "old_line_content": "      if (!data()->config()->AreAliases(current->representation(), reg,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3284,
          "old_api": "representation",
          "new_api": null,
          "old_text": "range->representation()",
          "new_text": null,
          "old_line_content": "                                        range->representation(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3285,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "range->assigned_register()",
          "new_text": null,
          "old_line_content": "                                        range->assigned_register())) {",
          "new_line_content": "void LinearScanAllocator::SplitAndSpillIntersecting(LiveRange* current) {",
          "content_same": false
        },
        {
          "line": 3796,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": null,
          "old_text": "top->IsSpilledOnlyInDeferredBlocks()",
          "new_text": null,
          "old_line_content": "        !top->IsSpilledOnlyInDeferredBlocks())",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3798,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "top->vreg()",
          "new_text": null,
          "old_line_content": "    CommitSpillsInDeferredBlocks(top, finder.ArrayFor(top->vreg()), local_zone);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3293,
          "old_api": "SpillAfter",
          "new_api": null,
          "old_text": "SpillAfter(range, spill_pos)",
          "new_text": null,
          "old_line_content": "      SpillAfter(range, spill_pos);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 3810,
          "old_api": "PredecessorCount",
          "new_api": null,
          "old_text": "block->PredecessorCount()",
          "new_text": null,
          "old_line_content": "  if (block->PredecessorCount() == 1) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3811,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "block->first_instruction_index()",
          "new_text": null,
          "old_line_content": "    gap_index = block->first_instruction_index();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3814,
          "old_api": "SuccessorCount",
          "new_api": null,
          "old_text": "pred->SuccessorCount()",
          "new_text": null,
          "old_line_content": "    DCHECK_EQ(1, pred->SuccessorCount());",
          "new_line_content": "int LiveRangeConnector::ResolveControlFlow(const InstructionBlock* block,",
          "content_same": false
        },
        {
          "line": 3303,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "      DCHECK(LifetimePosition::ExistsGapPositionBetween(current->Start(),",
          "new_line_content": "    if (next_pos == nullptr) {",
          "content_same": false
        },
        {
          "line": 3815,
          "old_api": "InstructionAt",
          "new_api": null,
          "old_text": "code()\n                ->InstructionAt(pred->last_instruction_index())\n                ->HasReferenceMap()",
          "new_text": null,
          "old_line_content": "    DCHECK(!code()",
          "new_line_content": "                                           const InstructionOperand& cur_op,",
          "content_same": false
        },
        {
          "line": 3305,
          "old_api": "pos",
          "new_api": null,
          "old_text": "next_pos->pos()",
          "new_text": null,
          "old_line_content": "      SpillBetweenUntil(range, spill_pos, current->Start(), next_pos->pos());",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 3816,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "pred->last_instruction_index()",
          "new_text": null,
          "old_line_content": "                ->InstructionAt(pred->last_instruction_index())",
          "new_line_content": "                                           const InstructionBlock* pred,",
          "content_same": false
        },
        {
          "line": 3307,
          "old_api": "ActiveToHandled",
          "new_api": null,
          "old_text": "ActiveToHandled(range)",
          "new_text": null,
          "old_line_content": "    ActiveToHandled(range);",
          "new_line_content": "      // remains spilled at least until the start of the current live range.",
          "content_same": false
        },
        {
          "line": 3311,
          "old_api": "size",
          "new_api": null,
          "old_text": "inactive_live_ranges().size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < inactive_live_ranges().size(); ++i) {",
          "new_line_content": "      // live-ranges: ranges are allocated in order of their start positions,",
          "content_same": false
        },
        {
          "line": 3312,
          "old_api": "inactive_live_ranges",
          "new_api": null,
          "old_text": "inactive_live_ranges()",
          "new_text": null,
          "old_line_content": "    LiveRange* range = inactive_live_ranges()[i];",
          "new_line_content": "      // ranges are retired from active/inactive when the start of the",
          "content_same": false
        },
        {
          "line": 3313,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "    DCHECK(range->End() > current->Start());",
          "new_line_content": "      // current live-range is larger than their end.",
          "content_same": false
        },
        {
          "line": 3828,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "new_line_content": "                ->HasReferenceMap());",
          "content_same": false
        },
        {
          "line": 3830,
          "old_api": "size",
          "new_api": null,
          "old_text": "data()->live_ranges().size()",
          "new_text": null,
          "old_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "new_line_content": "    position = Instruction::END;",
          "content_same": false
        },
        {
          "line": 3319,
          "old_api": "representation",
          "new_api": null,
          "old_text": "range->representation()",
          "new_text": null,
          "old_line_content": "                                        range->representation(),",
          "new_line_content": "    --i;",
          "content_same": false
        },
        {
          "line": 3320,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "range->assigned_register()",
          "new_text": null,
          "old_line_content": "                                        range->assigned_register()))",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3834,
          "old_api": "next",
          "new_api": null,
          "old_text": "first_range->next()",
          "new_text": null,
          "old_line_content": "    for (LiveRange *second_range = first_range->next(); second_range != nullptr;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3835,
          "old_api": "next",
          "new_api": null,
          "old_text": "second_range->next()",
          "new_text": null,
          "old_line_content": "         first_range = second_range, second_range = second_range->next()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3836,
          "old_api": "Start",
          "new_api": null,
          "old_text": "second_range->Start()",
          "new_text": null,
          "old_line_content": "      LifetimePosition pos = second_range->Start();",
          "new_line_content": "void LiveRangeConnector::ConnectRanges(Zone* local_zone) {",
          "content_same": false
        },
        {
          "line": 3328,
          "old_api": "SpillAfter",
          "new_api": null,
          "old_text": "SpillAfter(range, split_pos)",
          "new_text": null,
          "old_line_content": "        SpillAfter(range, split_pos);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 3842,
          "old_api": "code",
          "new_api": null,
          "old_text": "code()",
          "new_text": null,
          "old_line_content": "          !CanEagerlyResolveControlFlow(GetInstructionBlock(code(), pos))) {",
          "new_line_content": "    if (top_range == nullptr) continue;",
          "content_same": false
        },
        {
          "line": 3333,
          "old_api": "InactiveToHandled",
          "new_api": null,
          "old_text": "InactiveToHandled(range)",
          "new_text": null,
          "old_line_content": "      InactiveToHandled(range);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3854,
          "old_api": "IsDeferred",
          "new_api": null,
          "old_text": "block->IsDeferred()",
          "new_text": null,
          "old_line_content": "        DCHECK(block->IsDeferred());",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 3343,
          "old_api": "HasSpillOperand",
          "new_api": null,
          "old_text": "range->HasSpillOperand()",
          "new_text": null,
          "old_line_content": "  DCHECK(!range->HasSpillOperand());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3345,
          "old_api": "GetPhiMapValueFor",
          "new_api": null,
          "old_text": "data()->GetPhiMapValueFor(range)",
          "new_text": null,
          "old_line_content": "      data()->GetPhiMapValueFor(range);",
          "new_line_content": "      --i;",
          "content_same": false
        },
        {
          "line": 3346,
          "old_api": "phi",
          "new_api": null,
          "old_text": "phi_map_value->phi()",
          "new_text": null,
          "old_line_content": "  const PhiInstruction* phi = phi_map_value->phi();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3347,
          "old_api": "block",
          "new_api": null,
          "old_text": "phi_map_value->block()",
          "new_text": null,
          "old_line_content": "  const InstructionBlock* block = phi_map_value->block();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3351,
          "old_api": "size",
          "new_api": null,
          "old_text": "phi->operands().size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < phi->operands().size(); i++) {",
          "new_line_content": "bool LinearScanAllocator::TryReuseSpillForPhi(TopLevelLiveRange* range) {",
          "content_same": false
        },
        {
          "line": 3353,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": null,
          "old_text": "data()->GetOrCreateLiveRangeFor(op)",
          "new_text": null,
          "old_line_content": "    LiveRange* op_range = data()->GetOrCreateLiveRangeFor(op);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3359,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "pred->last_instruction_index()",
          "new_text": null,
          "old_line_content": "            pred->last_instruction_index());",
          "new_line_content": "  // Count the number of spilled operands.",
          "content_same": false
        },
        {
          "line": 3360,
          "old_api": "CanCover",
          "new_api": null,
          "old_text": "op_range->CanCover(pred_end)",
          "new_text": null,
          "old_line_content": "    while (op_range != nullptr && !op_range->CanCover(pred_end)) {",
          "new_line_content": "  size_t spilled_count = 0;",
          "content_same": false
        },
        {
          "line": 3361,
          "old_api": "next",
          "new_api": null,
          "old_text": "op_range->next()",
          "new_text": null,
          "old_line_content": "      op_range = op_range->next();",
          "new_line_content": "  LiveRange* first_op = nullptr;",
          "content_same": false
        },
        {
          "line": 3876,
          "old_api": "GetInstructionBlock",
          "new_api": null,
          "old_text": "code()->GetInstructionBlock(gap_index)->IsDeferred()",
          "new_text": null,
          "old_line_content": "          code()->GetInstructionBlock(gap_index)->IsDeferred());",
          "new_line_content": "          delay_insertion = true;",
          "content_same": false
        },
        {
          "line": 3366,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "op_range->TopLevel()",
          "new_text": null,
          "old_line_content": "        first_op = op_range->TopLevel();",
          "new_line_content": "    const InstructionBlock* pred =",
          "content_same": false
        },
        {
          "line": 3879,
          "old_api": "InstructionAt",
          "new_api": null,
          "old_text": "code()->InstructionAt(gap_index)->GetOrCreateParallelMove(\n              gap_pos, code_zone())",
          "new_text": null,
          "old_line_content": "          code()->InstructionAt(gap_index)->GetOrCreateParallelMove(",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3880,
          "old_api": "code_zone",
          "new_api": null,
          "old_text": "code_zone()",
          "new_text": null,
          "old_line_content": "              gap_pos, code_zone());",
          "new_line_content": "        gap_pos = delay_insertion ? Instruction::END : Instruction::START;",
          "content_same": false
        },
        {
          "line": 3882,
          "old_api": "AddMove",
          "new_api": null,
          "old_text": "move->AddMove(prev_operand, cur_operand)",
          "new_text": null,
          "old_line_content": "        move->AddMove(prev_operand, cur_operand);",
          "new_line_content": "      // Reloads or spills for spilled in deferred blocks ranges must happen",
          "content_same": false
        },
        {
          "line": 3885,
          "old_api": "std::make_pair(move, prev_operand)",
          "new_api": null,
          "old_text": "std::make_pair(move, prev_operand)",
          "new_text": null,
          "old_line_content": "            std::make_pair(std::make_pair(move, prev_operand), cur_operand));",
          "new_line_content": "          connect_spilled &&",
          "content_same": false
        },
        {
          "line": 3889,
          "old_api": "empty",
          "new_api": null,
          "old_text": "delayed_insertion_map.empty()",
          "new_text": null,
          "old_line_content": "  if (delayed_insertion_map.empty()) return;",
          "new_line_content": "      ParallelMove* move =",
          "content_same": false
        },
        {
          "line": 3378,
          "old_api": "DCHECK_NOT_NULL",
          "new_api": null,
          "old_text": "DCHECK_NOT_NULL(first_op)",
          "new_text": null,
          "old_line_content": "  DCHECK_NOT_NULL(first_op);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3379,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "first_op->TopLevel()->GetSpillRange()",
          "new_text": null,
          "old_line_content": "  SpillRange* first_op_spill = first_op->TopLevel()->GetSpillRange();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3381,
          "old_api": "size",
          "new_api": null,
          "old_text": "phi->operands().size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 1; i < phi->operands().size(); i++) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3382,
          "old_api": "operands",
          "new_api": null,
          "old_text": "phi->operands()",
          "new_text": null,
          "old_line_content": "    int op = phi->operands()[i];",
          "new_line_content": "  // Only continue if more than half of the operands are spilled.",
          "content_same": false
        },
        {
          "line": 3894,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "to_eliminate.reserve(4)",
          "new_text": null,
          "old_line_content": "  to_eliminate.reserve(4);",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 3384,
          "old_api": "HasSpillRange",
          "new_api": null,
          "old_text": "op_range->HasSpillRange()",
          "new_text": null,
          "old_line_content": "    if (!op_range->HasSpillRange()) continue;",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 3385,
          "old_api": "GetSpillRange",
          "new_api": null,
          "old_text": "op_range->GetSpillRange()",
          "new_text": null,
          "old_line_content": "    SpillRange* op_spill = op_range->GetSpillRange();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3386,
          "old_api": "TryMerge",
          "new_api": null,
          "old_text": "first_op_spill->TryMerge(op_spill)",
          "new_text": null,
          "old_line_content": "    if (op_spill == first_op_spill || first_op_spill->TryMerge(op_spill)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3897,
          "old_api": "end",
          "new_api": null,
          "old_text": "delayed_insertion_map.end()",
          "new_text": null,
          "old_line_content": "    bool done = it == delayed_insertion_map.end();",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3901,
          "old_api": "Eliminate",
          "new_api": null,
          "old_text": "move->Eliminate()",
          "new_text": null,
          "old_line_content": "        move->Eliminate();",
          "new_line_content": "  // Insert all the moves which should occur after the stored move.",
          "content_same": false
        },
        {
          "line": 3909,
          "old_api": "clear",
          "new_api": null,
          "old_text": "to_insert.clear()",
          "new_text": null,
          "old_line_content": "      to_insert.clear();",
          "new_line_content": "    if (done || it->first.first != moves) {",
          "content_same": false
        },
        {
          "line": 3401,
          "old_api": "Start",
          "new_api": null,
          "old_text": "range->Start()",
          "new_text": null,
          "old_line_content": "  LifetimePosition next_pos = range->Start();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3402,
          "old_api": "NextStart",
          "new_api": null,
          "old_text": "next_pos.NextStart()",
          "new_text": null,
          "old_line_content": "  if (next_pos.IsGapPosition()) next_pos = next_pos.NextStart();",
          "new_line_content": "  // Only continue if enough operands could be merged to the",
          "content_same": false
        },
        {
          "line": 3403,
          "old_api": "NextUsePositionRegisterIsBeneficial",
          "new_api": null,
          "old_text": "range->NextUsePositionRegisterIsBeneficial(next_pos)",
          "new_text": null,
          "old_line_content": "  UsePosition* pos = range->NextUsePositionRegisterIsBeneficial(next_pos);",
          "new_line_content": "  // same spill slot.",
          "content_same": false
        },
        {
          "line": 3914,
          "old_api": "code_zone",
          "new_api": null,
          "old_text": "code_zone()",
          "new_text": null,
          "old_line_content": "        new (code_zone()) MoveOperands(it->first.second, it->second);",
          "new_line_content": "      for (MoveOperands* move : to_insert) {",
          "content_same": false
        },
        {
          "line": 3916,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "to_insert.push_back(move)",
          "new_text": null,
          "old_line_content": "    to_insert.push_back(move);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3407,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->GetSpillRange()",
          "new_text": null,
          "old_line_content": "            ? range->TopLevel()->GetSpillRange()",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 3408,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()",
          "new_text": null,
          "old_line_content": "            : data()->AssignSpillRangeToLiveRange(range->TopLevel());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3409,
          "old_api": "TryMerge",
          "new_api": null,
          "old_text": "first_op_spill->TryMerge(spill_range)",
          "new_text": null,
          "old_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3411,
          "old_api": "Spill",
          "new_api": null,
          "old_text": "Spill(range)",
          "new_text": null,
          "old_line_content": "    Spill(range);",
          "new_line_content": "  // spill range.",
          "content_same": false
        },
        {
          "line": 3923,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": null,
          "old_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": null,
          "old_line_content": "  DCHECK(range->IsSpilledOnlyInDeferredBlocks());",
          "new_line_content": "    // Gather all MoveOperands for a single ParallelMove.",
          "content_same": false
        },
        {
          "line": 3924,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "range->spilled()",
          "new_text": null,
          "old_line_content": "  DCHECK(!range->spilled());",
          "new_line_content": "    MoveOperands* move =",
          "content_same": false
        },
        {
          "line": 3415,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->HasSpillRange()",
          "new_text": null,
          "old_line_content": "        range->TopLevel()->HasSpillRange()",
          "new_line_content": "  if (pos == nullptr) {",
          "content_same": false
        },
        {
          "line": 3416,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->GetSpillRange()",
          "new_text": null,
          "old_line_content": "            ? range->TopLevel()->GetSpillRange()",
          "new_line_content": "    SpillRange* spill_range =",
          "content_same": false
        },
        {
          "line": 3929,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "TRACE(\"Live Range %d will be spilled only in deferred blocks.\\n\",\n        range->vreg())",
          "new_text": null,
          "old_line_content": "  TRACE(\"Live Range %d will be spilled only in deferred blocks.\\n\",",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3930,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "range->vreg()",
          "new_text": null,
          "old_line_content": "        range->vreg());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3936,
          "old_api": "next",
          "new_api": null,
          "old_text": "pos->next()",
          "new_text": null,
          "old_line_content": "         pos = pos->next()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3939,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "range->AddBlockRequiringSpillOperand(\n          code->GetInstructionBlock(pos->pos().ToInstructionIndex())\n              ->rpo_number())",
          "new_text": null,
          "old_line_content": "      range->AddBlockRequiringSpillOperand(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3435,
          "old_api": "SpillBetweenUntil",
          "new_api": null,
          "old_text": "SpillBetweenUntil(range, start, start, end)",
          "new_text": null,
          "old_line_content": "  SpillBetweenUntil(range, start, start, end);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3949,
          "old_api": "Advance",
          "new_api": null,
          "old_text": "iterator.Advance()",
          "new_text": null,
          "old_line_content": "       !iterator.Done(); iterator.Advance()) {",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 3443,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(start < end)",
          "new_text": null,
          "old_line_content": "  CHECK(start < end);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3444,
          "old_api": "SplitRangeAt",
          "new_api": null,
          "old_text": "SplitRangeAt(range, start)",
          "new_text": null,
          "old_line_content": "  LiveRange* second_part = SplitRangeAt(range, start);",
          "new_line_content": "void LinearScanAllocator::SpillBetween(LiveRange* range, LifetimePosition start,",
          "content_same": false
        },
        {
          "line": 3957,
          "old_api": "GetListOfBlocksRequiringSpillOperands",
          "new_api": null,
          "old_text": "range->GetListOfBlocksRequiringSpillOperands()->length()",
          "new_text": null,
          "old_line_content": "      range->GetListOfBlocksRequiringSpillOperands()->length(), temp_zone);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3958,
          "old_api": "empty",
          "new_api": null,
          "old_text": "worklist.empty()",
          "new_text": null,
          "old_line_content": "  while (!worklist.empty()) {",
          "new_line_content": "  for (BitVector::Iterator iterator(",
          "content_same": false
        },
        {
          "line": 3450,
          "old_api": "PrevStart",
          "new_api": null,
          "old_text": "end.PrevStart().End()",
          "new_text": null,
          "old_line_content": "    LifetimePosition third_part_end = end.PrevStart().End();",
          "new_line_content": "void LinearScanAllocator::SpillBetweenUntil(LiveRange* range,",
          "content_same": false
        },
        {
          "line": 3451,
          "old_api": "Start",
          "new_api": null,
          "old_text": "end.Start()",
          "new_text": null,
          "old_line_content": "    if (data()->IsBlockBoundary(end.Start())) {",
          "new_line_content": "                                            LifetimePosition start,",
          "content_same": false
        },
        {
          "line": 3452,
          "old_api": "Start",
          "new_api": null,
          "old_text": "end.Start()",
          "new_text": null,
          "old_line_content": "      third_part_end = end.Start();",
          "new_line_content": "                                            LifetimePosition until,",
          "content_same": false
        },
        {
          "line": 3962,
          "old_api": "Add",
          "new_api": null,
          "old_text": "done_blocks.Add(block_id)",
          "new_text": null,
          "old_line_content": "    done_blocks.Add(block_id);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3964,
          "old_api": "RpoNumber::FromInt(block_id)",
          "new_api": null,
          "old_text": "RpoNumber::FromInt(block_id)",
          "new_text": null,
          "old_line_content": "        code->InstructionBlockAt(RpoNumber::FromInt(block_id));",
          "new_line_content": "  ZoneSet<std::pair<RpoNumber, int>> done_moves(temp_zone);",
          "content_same": false
        },
        {
          "line": 3966,
          "old_api": "predecessors",
          "new_api": null,
          "old_text": "spill_block->predecessors()",
          "new_text": null,
          "old_line_content": "    for (const RpoNumber& pred : spill_block->predecessors()) {",
          "new_line_content": "  // and spill there. We only need to spill at the start of such blocks.",
          "content_same": false
        },
        {
          "line": 3967,
          "old_api": "InstructionBlockAt",
          "new_api": null,
          "old_text": "code->InstructionBlockAt(pred)",
          "new_text": null,
          "old_line_content": "      const InstructionBlock* pred_block = code->InstructionBlockAt(pred);",
          "new_line_content": "  BitVector done_blocks(",
          "content_same": false
        },
        {
          "line": 3459,
          "old_api": "Spill",
          "new_api": null,
          "old_text": "Spill(second_part)",
          "new_text": null,
          "old_line_content": "    Spill(second_part);",
          "new_line_content": "    // Split it at position between ]start+1, end[, spill the middle part",
          "content_same": false
        },
        {
          "line": 3460,
          "old_api": "AddToUnhandled",
          "new_api": null,
          "old_text": "AddToUnhandled(third_part)",
          "new_text": null,
          "old_line_content": "    AddToUnhandled(third_part);",
          "new_line_content": "    // and put the rest to unhandled.",
          "content_same": false
        },
        {
          "line": 3974,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "pred_block->last_instruction_index()",
          "new_text": null,
          "old_line_content": "                pred_block->last_instruction_index());",
          "new_line_content": "    InstructionBlock* spill_block =",
          "content_same": false
        },
        {
          "line": 3464,
          "old_api": "AddToUnhandled",
          "new_api": null,
          "old_text": "AddToUnhandled(second_part)",
          "new_text": null,
          "old_line_content": "    AddToUnhandled(second_part);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3976,
          "old_api": "Find",
          "new_api": null,
          "old_text": "array->Find(pred_end)",
          "new_text": null,
          "old_line_content": "        LiveRangeBound* bound = array->Find(pred_end);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3982,
          "old_api": "end",
          "new_api": null,
          "old_text": "done_moves.end()",
          "new_text": null,
          "old_line_content": "                spill_block_number, range->vreg())) == done_moves.end()) {",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 3983,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "spill_block->first_instruction_index()",
          "new_text": null,
          "old_line_content": "          data()->AddGapMove(spill_block->first_instruction_index(),",
          "new_line_content": "        LifetimePosition pred_end =",
          "content_same": false
        },
        {
          "line": 3474,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()",
          "new_text": null,
          "old_line_content": "  const InstructionSequence* code = data()->code();",
          "new_line_content": "    // Nothing to spill. Just put it to unhandled as whole.",
          "content_same": false
        },
        {
          "line": 3986,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "range->vreg()",
          "new_text": null,
          "old_line_content": "          done_moves.insert(std::make_pair(spill_block_number, range->vreg()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3476,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3477,
          "old_api": "size",
          "new_api": null,
          "old_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "new_text": null,
          "old_line_content": "    CHECK_EQ(live_ranges_size,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3478,
          "old_api": "size",
          "new_api": null,
          "old_text": "data()->live_ranges().size()",
          "new_text": null,
          "old_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3479,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (range == nullptr || range->IsEmpty()) continue;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3481,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": null,
          "old_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": null,
          "old_line_content": "    if (!range->HasSpillRange() || range->IsSpilledOnlyInDeferredBlocks()) {",
          "new_line_content": "    : data_(data) {}",
          "content_same": false
        },
        {
          "line": 3498,
          "old_api": "spill_ranges",
          "new_api": null,
          "old_text": "data()->spill_ranges()",
          "new_text": null,
          "old_line_content": "  ZoneVector<SpillRange*>& spill_ranges = data()->spill_ranges();",
          "new_line_content": "    for (; spills != nullptr; spills = spills->next) {",
          "content_same": false
        },
        {
          "line": 3500,
          "old_api": "size",
          "new_api": null,
          "old_text": "spill_ranges.size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < spill_ranges.size(); ++i) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3503,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (range->IsEmpty()) continue;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3504,
          "old_api": "size",
          "new_api": null,
          "old_text": "spill_ranges.size()",
          "new_text": null,
          "old_line_content": "    for (size_t j = i + 1; j < spill_ranges.size(); ++j) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3506,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "other->IsEmpty()",
          "new_text": null,
          "old_line_content": "      if (other != nullptr && !other->IsEmpty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3507,
          "old_api": "TryMerge",
          "new_api": null,
          "old_text": "range->TryMerge(other)",
          "new_text": null,
          "old_line_content": "        range->TryMerge(other);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3513,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (range == nullptr || range->IsEmpty()) continue;",
          "new_line_content": "    if (range == nullptr) continue;",
          "content_same": false
        },
        {
          "line": 3516,
          "old_api": "byte_width",
          "new_api": null,
          "old_text": "range->byte_width()",
          "new_text": null,
          "old_line_content": "      int index = data()->frame()->AllocateSpillSlot(range->byte_width());",
          "new_line_content": "      SpillRange* other = spill_ranges[j];",
          "content_same": false
        },
        {
          "line": 3525,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "new_line_content": "    // Allocate a new operand referring to the spill slot.",
          "content_same": false
        },
        {
          "line": 3530,
          "old_api": "HasSpillOperand",
          "new_api": null,
          "old_text": "top_range->HasSpillOperand()",
          "new_text": null,
          "old_line_content": "    if (top_range->HasSpillOperand()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3531,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "top_range->TopLevel()->GetSpillOperand()",
          "new_text": null,
          "old_line_content": "      spill_operand = *top_range->TopLevel()->GetSpillOperand();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3532,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "top_range->TopLevel()->HasSpillRange()",
          "new_text": null,
          "old_line_content": "    } else if (top_range->TopLevel()->HasSpillRange()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3533,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "top_range->TopLevel()->GetSpillRangeOperand()",
          "new_text": null,
          "old_line_content": "      spill_operand = top_range->TopLevel()->GetSpillRangeOperand();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3540,
          "old_api": "next",
          "new_api": null,
          "old_text": "range->next()",
          "new_text": null,
          "old_line_content": "         range = range->next()) {",
          "new_line_content": "    InstructionOperand spill_operand;",
          "content_same": false
        },
        {
          "line": 3560,
          "old_api": "CommitSpillMoves",
          "new_api": null,
          "old_text": "top_range->CommitSpillMoves(\n            data()->code(), spill_operand,\n            top_range->has_slot_use() || top_range->spilled())",
          "new_text": null,
          "old_line_content": "        top_range->CommitSpillMoves(",
          "new_line_content": "      // definition. Refer to the ConnectLiveRanges and ResolveControlFlow",
          "content_same": false
        },
        {
          "line": 3561,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()",
          "new_text": null,
          "old_line_content": "            data()->code(), spill_operand,",
          "new_line_content": "      // phases. Normally, when we spill at definition, we do not insert a",
          "content_same": false
        },
        {
          "line": 3562,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "top_range->spilled()",
          "new_text": null,
          "old_line_content": "            top_range->has_slot_use() || top_range->spilled());",
          "new_line_content": "      // connecting move when a successor child range is spilled - because the",
          "content_same": false
        },
        {
          "line": 3575,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()->reference_maps()",
          "new_text": null,
          "old_line_content": "  for (ReferenceMap* map : *data()->code()->reference_maps()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3576,
          "old_api": "instruction_position",
          "new_api": null,
          "old_text": "map->instruction_position()",
          "new_text": null,
          "old_line_content": "    if (safe_point > map->instruction_position()) return false;",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3577,
          "old_api": "instruction_position",
          "new_api": null,
          "old_text": "map->instruction_position()",
          "new_text": null,
          "old_line_content": "    safe_point = map->instruction_position();",
          "new_line_content": "}",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 154,
      "total_additions": 225,
      "total_deletions": 222,
      "total_api_changes": 601
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 15,
        "api_related_lines": 601,
        "non_api_lines": 11,
        "non_api_line_numbers": [
          3104,
          3092,
          3093,
          3094,
          3095,
          3096,
          3097,
          3098,
          3099,
          3100,
          3102
        ]
      }
    },
    "api_calls_before": 2326,
    "api_calls_after": 2329,
    "diff_info": {
      "added_lines": 15,
      "removed_lines": 4,
      "total_diff_lines": 32
    }
  }
}