{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/a8a7794e49c221f971c3434b9a94a1517ede0e5a",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/a8a7794e49c221f971c3434b9a94a1517ede0e5a/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/a8a7794e49c221f971c3434b9a94a1517ede0e5a/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/a8a7794e49c221f971c3434b9a94a1517ede0e5a/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 658,
          "old_api": "typed_old_to_old_slots",
          "new_api": "NeverEvacuate",
          "old_text": "p->typed_old_to_old_slots()",
          "new_text": "p->NeverEvacuate()",
          "old_line_content": "    CHECK_NULL(p->typed_old_to_old_slots());",
          "new_line_content": "    if (p->NeverEvacuate()) continue;",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "ShouldReduceMemory",
          "new_api": "area_size",
          "old_text": "heap()->ShouldReduceMemory()",
          "new_text": "p->area_size()",
          "old_line_content": "  const bool reduce_memory = heap()->ShouldReduceMemory();",
          "new_line_content": "    DCHECK(p->area_size() == area_size);",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": "ClearFlag",
          "new_api": "ShouldReduceMemory",
          "old_text": "p->ClearFlag(MemoryChunk::FORCE_EVACUATION_CANDIDATE_FOR_TESTING)",
          "new_text": "heap()->ShouldReduceMemory()",
          "old_line_content": "        p->ClearFlag(MemoryChunk::FORCE_EVACUATION_CANDIDATE_FOR_TESTING);",
          "new_line_content": "  const bool reduce_memory = heap()->ShouldReduceMemory();",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": "AddEvacuationCandidate",
          "new_api": "DCHECK_LE",
          "old_text": "AddEvacuationCandidate(pages[i].second)",
          "new_text": "DCHECK_LE(estimated_new_pages, candidate_count)",
          "old_line_content": "      AddEvacuationCandidate(pages[i].second);",
          "new_line_content": "    DCHECK_LE(estimated_new_pages, candidate_count);",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": "length",
          "new_api": "heap",
          "old_text": "evacuation_candidates_.length()",
          "new_text": "heap()",
          "old_line_content": "  DCHECK_EQ(0, evacuation_candidates_.length());",
          "new_line_content": "    RememberedSet<OLD_TO_OLD>::ClearAll(heap());",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "incremental_marking",
          "new_api": "Rewind",
          "old_text": "heap()->incremental_marking()->IsMarking()",
          "new_text": "evacuation_candidates_.Rewind(0)",
          "old_line_content": "  was_marked_incrementally_ = heap()->incremental_marking()->IsMarking();",
          "new_line_content": "    evacuation_candidates_.Rewind(0);",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": "DCHECK",
          "new_api": "incremental_marking",
          "old_text": "DCHECK(!FLAG_never_compact || !FLAG_always_compact)",
          "new_text": "heap()->incremental_marking()->IsMarking()",
          "old_line_content": "  DCHECK(!FLAG_never_compact || !FLAG_always_compact);",
          "new_line_content": "  was_marked_incrementally_ = heap()->incremental_marking()->IsMarking();",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": "memory_allocator",
          "new_api": "sweeping_in_progress",
          "old_text": "heap()->memory_allocator()->unmapper()->WaitUntilCompleted()",
          "new_text": "sweeping_in_progress()",
          "old_line_content": "  heap()->memory_allocator()->unmapper()->WaitUntilCompleted();",
          "new_line_content": "  if (sweeping_in_progress()) {",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": "AbortWeakCells",
          "new_api": "memory_allocator",
          "old_text": "AbortWeakCells()",
          "new_text": "heap()->memory_allocator()->unmapper()->WaitUntilCompleted()",
          "old_line_content": "    AbortWeakCells();",
          "new_line_content": "  heap()->memory_allocator()->unmapper()->WaitUntilCompleted();",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": "UsingEmbedderHeapTracer",
          "new_api": "ShouldAbortIncrementalMarking",
          "old_text": "heap_->UsingEmbedderHeapTracer()",
          "new_text": "heap_->ShouldAbortIncrementalMarking()",
          "old_line_content": "    if (heap_->UsingEmbedderHeapTracer()) {",
          "new_line_content": "  if (was_marked_incrementally_ && heap_->ShouldAbortIncrementalMarking()) {",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": "mark_compact_collector",
          "new_api": "incremental_marking",
          "old_text": "heap_->mark_compact_collector()->embedder_heap_tracer()->AbortTracing()",
          "new_text": "heap()->incremental_marking()->Stop()",
          "old_line_content": "      heap_->mark_compact_collector()->embedder_heap_tracer()->AbortTracing();",
          "new_line_content": "    heap()->incremental_marking()->Stop();",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": "StartCompaction",
          "new_api": "UsingEmbedderHeapTracer",
          "old_text": "StartCompaction(NON_INCREMENTAL_COMPACTION)",
          "new_text": "UsingEmbedderHeapTracer()",
          "old_line_content": "    StartCompaction(NON_INCREMENTAL_COMPACTION);",
          "new_line_content": "  if (UsingEmbedderHeapTracer()) {",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": "VerifyMarkbitsAreClean",
          "new_api": "next",
          "old_text": "VerifyMarkbitsAreClean()",
          "new_text": "spaces.next()",
          "old_line_content": "    VerifyMarkbitsAreClean();",
          "new_line_content": "       space = spaces.next()) {",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "tracer",
          "new_api": "VerifyMarkbitsAreClean",
          "old_text": "heap()->tracer()",
          "new_text": "VerifyMarkbitsAreClean()",
          "old_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_FINISH);",
          "new_line_content": "    VerifyMarkbitsAreClean();",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": "weak_object_to_code_table",
          "new_api": "contains_late_pages",
          "old_text": "heap()->weak_object_to_code_table()->Rehash(\n      heap()->isolate()->factory()->undefined_value())",
          "new_text": "sweeper().contains_late_pages()",
          "old_line_content": "  heap()->weak_object_to_code_table()->Rehash(",
          "new_line_content": "  if (sweeper().contains_late_pages() && FLAG_concurrent_sweeping) {",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": "DCHECK",
          "new_api": "weak_object_to_code_table",
          "old_text": "DCHECK(state_ == SWEEP_SPACES || state_ == RELOCATE_OBJECTS)",
          "new_text": "heap()->weak_object_to_code_table()->Rehash(\n      heap()->isolate()->factory()->undefined_value())",
          "old_line_content": "  DCHECK(state_ == SWEEP_SPACES || state_ == RELOCATE_OBJECTS);",
          "new_line_content": "  heap()->weak_object_to_code_table()->Rehash(",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": "store_stub_cache",
          "new_api": "isolate",
          "old_text": "isolate()->store_stub_cache()->Clear()",
          "new_text": "heap_->isolate()->inner_pointer_to_code_cache()->Flush()",
          "old_line_content": "  isolate()->store_stub_cache()->Clear();",
          "new_line_content": "  heap_->isolate()->inner_pointer_to_code_cache()->Flush();",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": "ClearNextCandidate",
          "new_api": "builtins",
          "old_text": "ClearNextCandidate(candidate, undefined)",
          "new_text": "isolate_->builtins()->builtin(Builtins::kCompileLazy)",
          "old_line_content": "    ClearNextCandidate(candidate, undefined);",
          "new_line_content": "  Code* lazy_compile = isolate_->builtins()->builtin(Builtins::kCompileLazy);",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": "Marking::IsWhite(code_mark)",
          "new_api": "GetNextCandidate",
          "old_text": "Marking::IsWhite(code_mark)",
          "new_text": "GetNextCandidate(candidate)",
          "old_line_content": "    if (Marking::IsWhite(code_mark)) {",
          "new_line_content": "    next_candidate = GetNextCandidate(candidate);",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": "is_compiled",
          "new_api": "ClearNextCandidate",
          "old_text": "shared->is_compiled()",
          "new_text": "ClearNextCandidate(candidate, undefined)",
          "old_line_content": "      if (FLAG_trace_code_flushing && shared->is_compiled()) {",
          "new_line_content": "    ClearNextCandidate(candidate, undefined);",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "ShortPrint",
          "new_api": "shared",
          "old_text": "shared->ShortPrint()",
          "new_text": "candidate->shared()",
          "old_line_content": "        shared->ShortPrint();",
          "new_line_content": "    SharedFunctionInfo* shared = candidate->shared();",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "OptimizedCodeMapIsCleared",
          "new_api": "Marking::IsWhite(code_mark)",
          "old_text": "shared->OptimizedCodeMapIsCleared()",
          "new_text": "Marking::IsWhite(code_mark)",
          "old_line_content": "      if (!shared->OptimizedCodeMapIsCleared()) {",
          "new_line_content": "    if (Marking::IsWhite(code_mark)) {",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": "ClearOptimizedCodeMap",
          "new_api": "is_compiled",
          "old_text": "shared->ClearOptimizedCodeMap()",
          "new_text": "shared->is_compiled()",
          "old_line_content": "        shared->ClearOptimizedCodeMap();",
          "new_line_content": "      if (FLAG_trace_code_flushing && shared->is_compiled()) {",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": "set_code",
          "new_api": "ShortPrint",
          "old_text": "shared->set_code(lazy_compile)",
          "new_text": "shared->ShortPrint()",
          "old_line_content": "      shared->set_code(lazy_compile);",
          "new_line_content": "        shared->ShortPrint();",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": "set_code",
          "new_api": "GetAge",
          "old_text": "candidate->set_code(lazy_compile)",
          "new_text": "code->GetAge()",
          "old_line_content": "      candidate->set_code(lazy_compile);",
          "new_line_content": "        PrintF(\" - age: %d]\\n\", code->GetAge());",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "set_code",
          "new_api": "OptimizedCodeMapIsCleared",
          "old_text": "candidate->set_code(code)",
          "new_text": "shared->OptimizedCodeMapIsCleared()",
          "old_line_content": "      candidate->set_code(code);",
          "new_line_content": "      if (!shared->OptimizedCodeMapIsCleared()) {",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": "Code::GetObjectFromEntryAddress(slot)",
          "new_api": "Marking::IsBlack(code_mark)",
          "old_text": "Code::GetObjectFromEntryAddress(slot)",
          "new_text": "Marking::IsBlack(code_mark)",
          "old_line_content": "    Code* target = Code::cast(Code::GetObjectFromEntryAddress(slot));",
          "new_line_content": "      DCHECK(Marking::IsBlack(code_mark));",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": "heap",
          "new_api": "set_code",
          "old_text": "isolate_->heap()->mark_compact_collector()->RecordCodeEntrySlot(\n        candidate, slot, target)",
          "new_text": "candidate->set_code(code)",
          "old_line_content": "    isolate_->heap()->mark_compact_collector()->RecordCodeEntrySlot(",
          "new_line_content": "      candidate->set_code(code);",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "heap",
          "new_api": "address",
          "old_text": "isolate_->heap()->mark_compact_collector()->RecordSlot(\n        shared, shared_code_slot, *shared_code_slot)",
          "new_text": "candidate->address()",
          "old_line_content": "    isolate_->heap()->mark_compact_collector()->RecordSlot(",
          "new_line_content": "    Address slot = candidate->address() + JSFunction::kCodeEntryOffset;",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": "PrintF",
          "new_api": "GetNextCandidate",
          "old_text": "PrintF(\"[code-flushing clears: \")",
          "new_text": "GetNextCandidate(candidate)",
          "old_line_content": "        PrintF(\"[code-flushing clears: \");",
          "new_line_content": "    next_candidate = GetNextCandidate(candidate);",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": "ShortPrint",
          "new_api": "ClearNextCandidate",
          "old_text": "candidate->ShortPrint()",
          "new_text": "ClearNextCandidate(candidate)",
          "old_line_content": "        candidate->ShortPrint();",
          "new_line_content": "    ClearNextCandidate(candidate);",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": "OptimizedCodeMapIsCleared",
          "new_api": "Marking::IsWhite(code_mark)",
          "old_text": "candidate->OptimizedCodeMapIsCleared()",
          "new_text": "Marking::IsWhite(code_mark)",
          "old_line_content": "      if (!candidate->OptimizedCodeMapIsCleared()) {",
          "new_line_content": "    if (Marking::IsWhite(code_mark)) {",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "ClearOptimizedCodeMap",
          "new_api": "is_compiled",
          "old_text": "candidate->ClearOptimizedCodeMap()",
          "new_text": "candidate->is_compiled()",
          "old_line_content": "        candidate->ClearOptimizedCodeMap();",
          "new_line_content": "      if (FLAG_trace_code_flushing && candidate->is_compiled()) {",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": "set_code",
          "new_api": "ShortPrint",
          "old_text": "candidate->set_code(lazy_compile)",
          "new_text": "candidate->ShortPrint()",
          "old_line_content": "      candidate->set_code(lazy_compile);",
          "new_line_content": "        candidate->ShortPrint();",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": "HeapObject::RawField(candidate, SharedFunctionInfo::kCodeOffset)",
          "new_api": "OptimizedCodeMapIsCleared",
          "old_text": "HeapObject::RawField(candidate, SharedFunctionInfo::kCodeOffset)",
          "new_text": "candidate->OptimizedCodeMapIsCleared()",
          "old_line_content": "        HeapObject::RawField(candidate, SharedFunctionInfo::kCodeOffset);",
          "new_line_content": "      if (!candidate->OptimizedCodeMapIsCleared()) {",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "heap",
          "new_api": "ClearOptimizedCodeMap",
          "old_text": "isolate_->heap()->mark_compact_collector()->RecordSlot(candidate, code_slot,\n                                                           *code_slot)",
          "new_text": "candidate->ClearOptimizedCodeMap()",
          "old_line_content": "    isolate_->heap()->mark_compact_collector()->RecordSlot(candidate, code_slot,",
          "new_line_content": "        candidate->ClearOptimizedCodeMap();",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "GetNextCandidate",
          "new_api": "ShortPrint",
          "old_text": "GetNextCandidate(shared_info)",
          "new_text": "shared_info->ShortPrint()",
          "old_line_content": "    next_candidate = GetNextCandidate(shared_info);",
          "new_line_content": "    shared_info->ShortPrint();",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": "SetNextCandidate",
          "new_api": "ClearNextCandidate",
          "old_text": "SetNextCandidate(candidate, next_candidate)",
          "new_text": "ClearNextCandidate(shared_info)",
          "old_line_content": "        SetNextCandidate(candidate, next_candidate);",
          "new_line_content": "    ClearNextCandidate(shared_info);",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": "PrintF",
          "new_api": "heap",
          "old_text": "PrintF(\"]\\n\")",
          "new_text": "isolate_->heap()->incremental_marking()->IterateBlackObject(function)",
          "old_line_content": "    PrintF(\"]\\n\");",
          "new_line_content": "  isolate_->heap()->incremental_marking()->IterateBlackObject(function);",
          "content_same": false
        },
        {
          "line": 1050,
          "old_api": "GetNextCandidate",
          "new_api": "shared",
          "old_text": "GetNextCandidate(function)",
          "new_text": "function->shared()->ShortPrint()",
          "old_line_content": "    next_candidate = GetNextCandidate(function);",
          "new_line_content": "    function->shared()->ShortPrint();",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": "SetNextCandidate",
          "new_api": "ClearNextCandidate",
          "old_text": "SetNextCandidate(candidate, next_candidate)",
          "new_text": "ClearNextCandidate(function, undefined)",
          "old_line_content": "        SetNextCandidate(candidate, next_candidate);",
          "new_line_content": "    ClearNextCandidate(function, undefined);",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": "mark_compact_collector",
          "new_api": "MarkObjectByPointer",
          "old_text": "heap->mark_compact_collector()->MarkObject(object, mark)",
          "new_text": "MarkObjectByPointer(collector, object, p)",
          "old_line_content": "    heap->mark_compact_collector()->MarkObject(object, mark);",
          "new_line_content": "      MarkObjectByPointer(collector, object, p);",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": "Marking::IsWhite(mark_bit)",
          "new_api": "mark_compact_collector",
          "old_text": "Marking::IsWhite(mark_bit)",
          "new_text": "heap->mark_compact_collector()->MarkObject(object, mark)",
          "old_line_content": "    if (Marking::IsWhite(mark_bit)) {",
          "new_line_content": "    heap->mark_compact_collector()->MarkObject(object, mark);",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": "ObjectMarking::MarkBitFrom(map)",
          "new_api": "heap",
          "old_text": "ObjectMarking::MarkBitFrom(map)",
          "new_text": "collector->heap()->mark_compact_collector()->IsMarked(obj)",
          "old_line_content": "    MarkBit map_mark = ObjectMarking::MarkBitFrom(map);",
          "new_line_content": "    DCHECK(!collector->heap()->mark_compact_collector()->IsMarked(obj));",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": "IterateBody",
          "new_api": "map",
          "old_text": "IterateBody(map, obj)",
          "new_text": "obj->map()",
          "old_line_content": "    IterateBody(map, obj);",
          "new_line_content": "    Map* map = obj->map();",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": "IsHeapObject",
          "new_api": "isolate",
          "old_text": "o->IsHeapObject()",
          "new_text": "heap->isolate()",
          "old_line_content": "      if (!o->IsHeapObject()) continue;",
          "new_line_content": "    StackLimitCheck check(heap->isolate());",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": "RecordSlot",
          "new_api": "HasOverflowed",
          "old_text": "collector->RecordSlot(object, p, o)",
          "new_text": "check.HasOverflowed()",
          "old_line_content": "      collector->RecordSlot(object, p, o);",
          "new_line_content": "    if (check.HasOverflowed()) return false;",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": "ObjectMarking::MarkBitFrom(obj)",
          "new_api": "mark_compact_collector",
          "old_text": "ObjectMarking::MarkBitFrom(obj)",
          "new_text": "heap->mark_compact_collector()",
          "old_line_content": "      MarkBit mark = ObjectMarking::MarkBitFrom(obj);",
          "new_line_content": "    MarkCompactCollector* collector = heap->mark_compact_collector();",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "JSRegExp::code_index(is_one_byte)",
          "new_api": "data",
          "old_text": "JSRegExp::code_index(is_one_byte)",
          "new_text": "re->data()",
          "old_line_content": "    Object* code = re->DataAt(JSRegExp::code_index(is_one_byte));",
          "new_line_content": "    if (HeapObject::cast(re->data())->map()->instance_type() !=",
          "content_same": false
        },
        {
          "line": 1202,
          "old_api": "ObjectMarking::MarkBitFrom(data)",
          "new_api": "JSRegExp::saved_code_index(is_one_byte)",
          "old_text": "ObjectMarking::MarkBitFrom(data)",
          "new_text": "JSRegExp::saved_code_index(is_one_byte)",
          "old_line_content": "      if (Marking::IsBlackOrGrey(ObjectMarking::MarkBitFrom(data))) {",
          "new_line_content": "      re->SetDataAt(JSRegExp::saved_code_index(is_one_byte), code);",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": "JSRegExp::code_index(is_one_byte)",
          "new_api": "ObjectMarking::MarkBitFrom(data)",
          "old_text": "JSRegExp::code_index(is_one_byte)",
          "new_text": "ObjectMarking::MarkBitFrom(data)",
          "old_line_content": "      re->SetDataAt(JSRegExp::code_index(is_one_byte),",
          "new_line_content": "      if (Marking::IsBlackOrGrey(ObjectMarking::MarkBitFrom(data))) {",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": "IsSmi",
          "new_api": "JSRegExp::saved_code_index(is_one_byte)",
          "old_text": "code->IsSmi()",
          "new_text": "JSRegExp::saved_code_index(is_one_byte)",
          "old_line_content": "    } else if (code->IsSmi()) {",
          "new_line_content": "            data->data_start() + JSRegExp::saved_code_index(is_one_byte);",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": "value",
          "new_api": "mark_compact_collector",
          "old_text": "Smi::cast(code)->value()",
          "new_text": "heap->mark_compact_collector()->RecordSlot(data, slot, code)",
          "old_line_content": "      int value = Smi::cast(code)->value();",
          "new_line_content": "        heap->mark_compact_collector()->RecordSlot(data, slot, code);",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": "UpdateRegExpCodeAgeAndFlush",
          "new_api": "mark_compact_collector",
          "old_text": "UpdateRegExpCodeAgeAndFlush(heap, re, true)",
          "new_text": "heap->mark_compact_collector()",
          "old_line_content": "    UpdateRegExpCodeAgeAndFlush(heap, re, true);",
          "new_line_content": "    MarkCompactCollector* collector = heap->mark_compact_collector();",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "UpdateRegExpCodeAgeAndFlush",
          "new_api": "is_code_flushing_enabled",
          "old_text": "UpdateRegExpCodeAgeAndFlush(heap, re, false)",
          "new_text": "collector->is_code_flushing_enabled()",
          "old_line_content": "    UpdateRegExpCodeAgeAndFlush(heap, re, false);",
          "new_line_content": "    if (!collector->is_code_flushing_enabled()) {",
          "content_same": false
        },
        {
          "line": 1286,
          "old_api": "ObjectMarking::MarkBitFrom(shared)",
          "new_api": "VisitPointer",
          "old_text": "ObjectMarking::MarkBitFrom(shared)",
          "new_text": "VisitPointer(p)",
          "old_line_content": "      MarkBit shared_mark = ObjectMarking::MarkBitFrom(shared);",
          "new_line_content": "    for (Object** p = start; p < end; p++) VisitPointer(p);",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": "ObjectMarking::MarkBitFrom(code)",
          "new_api": "Advance",
          "old_text": "ObjectMarking::MarkBitFrom(code)",
          "new_text": "it.Advance()",
          "old_line_content": "    MarkBit code_mark = ObjectMarking::MarkBitFrom(code);",
          "new_line_content": "  for (StackFrameIterator it(isolate, top); !it.done(); it.Advance()) {",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": "MarkObject",
          "new_api": "frame",
          "old_text": "MarkObject(optimized_code, optimized_code_mark)",
          "new_text": "it.frame()",
          "old_line_content": "      MarkObject(optimized_code, optimized_code_mark);",
          "new_line_content": "    StackFrame* frame = it.frame();",
          "content_same": false
        },
        {
          "line": 1330,
          "old_api": "isolate",
          "new_api": "mark_compact_collector",
          "old_text": "heap()->isolate()->thread_manager()->IterateArchivedThreads(\n      &code_marking_visitor)",
          "new_text": "heap()->mark_compact_collector()",
          "old_line_content": "  heap()->isolate()->thread_manager()->IterateArchivedThreads(",
          "new_line_content": "  DCHECK(this == heap()->mark_compact_collector());",
          "content_same": false
        },
        {
          "line": 1337,
          "old_api": "ProcessMarkingDeque",
          "new_api": "isolate",
          "old_text": "ProcessMarkingDeque()",
          "new_text": "heap()->isolate()->thread_manager()->IterateArchivedThreads(\n      &code_marking_visitor)",
          "old_line_content": "  ProcessMarkingDeque();",
          "new_line_content": "  heap()->isolate()->thread_manager()->IterateArchivedThreads(",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": "explicit",
          "new_api": "ProcessMarkingDeque",
          "old_text": "explicit",
          "new_text": "ProcessMarkingDeque()",
          "old_line_content": "  explicit RootMarkingVisitor(Heap* heap)",
          "new_line_content": "  ProcessMarkingDeque();",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": "map",
          "new_api": "IsHeapObject",
          "old_text": "object->map()",
          "new_text": "*p)->IsHeapObject()",
          "old_line_content": "    Map* map = object->map();",
          "new_line_content": "    if (!(*p)->IsHeapObject()) return;",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": "SetMark",
          "new_api": "HeapObject::cast(*p)",
          "old_text": "collector_->SetMark(object, mark_bit)",
          "new_text": "HeapObject::cast(*p)",
          "old_line_content": "    collector_->SetMark(object, mark_bit);",
          "new_line_content": "    HeapObject* object = HeapObject::cast(*p);",
          "content_same": false
        },
        {
          "line": 1371,
          "old_api": "ObjectMarking::MarkBitFrom(map)",
          "new_api": "Marking::IsBlackOrGrey(mark_bit)",
          "old_text": "ObjectMarking::MarkBitFrom(map)",
          "new_text": "Marking::IsBlackOrGrey(mark_bit)",
          "old_line_content": "    MarkBit map_mark = ObjectMarking::MarkBitFrom(map);",
          "new_line_content": "    if (Marking::IsBlackOrGrey(mark_bit)) return;",
          "content_same": false
        },
        {
          "line": 1373,
          "old_api": "MarkCompactMarkingVisitor::IterateBody(map, object)",
          "new_api": "map",
          "old_text": "MarkCompactMarkingVisitor::IterateBody(map, object)",
          "new_text": "object->map()",
          "old_line_content": "    MarkCompactMarkingVisitor::IterateBody(map, object);",
          "new_line_content": "    Map* map = object->map();",
          "content_same": false
        },
        {
          "line": 1402,
          "old_api": "String::cast(*p)",
          "new_api": "mark_compact_collector",
          "old_text": "String::cast(*p)",
          "new_text": "heap_->mark_compact_collector()",
          "old_line_content": "            heap_->FinalizeExternalString(String::cast(*p));",
          "new_line_content": "    MarkCompactCollector* collector = heap_->mark_compact_collector();",
          "content_same": false
        },
        {
          "line": 1418,
          "old_api": "DCHECK",
          "new_api": "RecordSlot",
          "old_text": "DCHECK(!finalize_external_strings)",
          "new_text": "collector->RecordSlot(table_, p, o)",
          "old_line_content": "    DCHECK(!finalize_external_strings);",
          "new_line_content": "          collector->RecordSlot(table_, p, o);",
          "content_same": false
        },
        {
          "line": 1444,
          "old_api": "AllocationSite::cast(object)",
          "new_api": "Marking::IsGrey(mark_bit)",
          "old_text": "AllocationSite::cast(object)",
          "new_text": "Marking::IsGrey(mark_bit)",
          "old_line_content": "      AllocationSite* site = AllocationSite::cast(object);",
          "new_line_content": "    DCHECK(!Marking::IsGrey(mark_bit));",
          "content_same": false
        },
        {
          "line": 1445,
          "old_api": "MarkZombie",
          "new_api": "Marking::IsBlack(mark_bit)",
          "old_text": "site->MarkZombie()",
          "new_text": "Marking::IsBlack(mark_bit)",
          "old_line_content": "      site->MarkZombie();",
          "new_line_content": "    if (Marking::IsBlack(mark_bit)) {",
          "content_same": false
        },
        {
          "line": 1469,
          "old_api": "PushBlack",
          "new_api": "IsFull",
          "old_text": "PushBlack(object)",
          "new_text": "marking_deque()->IsFull()",
          "old_line_content": "      PushBlack(object);",
          "new_line_content": "  DCHECK(!marking_deque()->IsFull());",
          "content_same": false
        },
        {
          "line": 1476,
          "old_api": "IsFull",
          "new_api": "PushBlack",
          "old_text": "marking_deque()->IsFull()",
          "new_text": "PushBlack(object)",
          "old_line_content": "  DCHECK(!marking_deque()->IsFull());",
          "new_line_content": "      PushBlack(object);",
          "content_same": false
        },
        {
          "line": 1483,
          "old_api": "PushBlack",
          "new_api": "IsFull",
          "old_text": "PushBlack(object)",
          "new_text": "marking_deque()->IsFull()",
          "old_line_content": "    PushBlack(object);",
          "new_line_content": "  DCHECK(!marking_deque()->IsFull());",
          "content_same": false
        },
        {
          "line": 1490,
          "old_api": "explicit",
          "new_api": "PushBlack",
          "old_text": "explicit",
          "new_text": "PushBlack(object)",
          "old_line_content": "  explicit RecordMigratedSlotVisitor(MarkCompactCollector* collector)",
          "new_line_content": "    PushBlack(object);",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": "IsEvacuationCandidate",
          "new_api": "reinterpret_cast<Address>(start)",
          "old_text": "Page::FromAddress(code_entry)->IsEvacuationCandidate()",
          "new_text": "reinterpret_cast<Address>(start)",
          "old_line_content": "    if (Page::FromAddress(code_entry)->IsEvacuationCandidate()) {",
          "new_line_content": "      RecordMigratedSlot(*start, reinterpret_cast<Address>(start));",
          "content_same": false
        },
        {
          "line": 1514,
          "old_api": "rmode",
          "new_api": "Page::FromAddress(code_entry_slot)",
          "old_text": "rinfo->rmode()",
          "new_text": "Page::FromAddress(code_entry_slot)",
          "old_line_content": "    DCHECK(RelocInfo::IsCodeTarget(rinfo->rmode()));",
          "new_line_content": "      RememberedSet<OLD_TO_OLD>::InsertTyped(Page::FromAddress(code_entry_slot),",
          "content_same": false
        },
        {
          "line": 1526,
          "old_api": "debug_call_address",
          "new_api": "heap",
          "old_text": "rinfo->debug_call_address()",
          "new_text": "collector_->heap()->InNewSpace(target)",
          "old_line_content": "    Code* target = Code::GetCodeFromTargetAddress(rinfo->debug_call_address());",
          "new_line_content": "    DCHECK(!collector_->heap()->InNewSpace(target));",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": "host",
          "new_api": "RecordRelocSlot",
          "old_text": "rinfo->host()",
          "new_text": "collector_->RecordRelocSlot(host, rinfo, target)",
          "old_line_content": "    Code* host = rinfo->host();",
          "new_line_content": "    collector_->RecordRelocSlot(host, rinfo, target);",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": "RecordRelocSlot",
          "new_api": "rmode",
          "old_text": "collector_->RecordRelocSlot(host, rinfo, target)",
          "new_text": "rinfo->rmode()",
          "old_line_content": "    collector_->RecordRelocSlot(host, rinfo, target);",
          "new_line_content": "    DCHECK(RelocInfo::IsDebugBreakSlot(rinfo->rmode()) &&",
          "content_same": false
        },
        {
          "line": 1537,
          "old_api": "host",
          "new_api": "heap",
          "old_text": "rinfo->host()",
          "new_text": "collector_->heap()->InNewSpace(target)",
          "old_line_content": "    Code* host = rinfo->host();",
          "new_line_content": "    DCHECK(!collector_->heap()->InNewSpace(target));",
          "content_same": false
        },
        {
          "line": 1538,
          "old_api": "heap",
          "new_api": "RecordRelocSlot",
          "old_text": "collector_->heap()->RecordWriteIntoCode(host, rinfo, object)",
          "new_text": "collector_->RecordRelocSlot(host, rinfo, target)",
          "old_line_content": "    collector_->heap()->RecordWriteIntoCode(host, rinfo, object);",
          "new_line_content": "    collector_->RecordRelocSlot(host, rinfo, target);",
          "content_same": false
        },
        {
          "line": 1543,
          "old_api": "rmode",
          "new_api": "target_object",
          "old_text": "rinfo->rmode()",
          "new_text": "rinfo->target_object()",
          "old_line_content": "    DCHECK(rinfo->rmode() == RelocInfo::CELL);",
          "new_line_content": "    HeapObject* object = HeapObject::cast(rinfo->target_object());",
          "content_same": false
        },
        {
          "line": 1544,
          "old_api": "target_cell",
          "new_api": "host",
          "old_text": "rinfo->target_cell()",
          "new_text": "rinfo->host()",
          "old_line_content": "    Cell* cell = rinfo->target_cell();",
          "new_line_content": "    Code* host = rinfo->host();",
          "content_same": false
        },
        {
          "line": 1545,
          "old_api": "host",
          "new_api": "heap",
          "old_text": "rinfo->host()",
          "new_text": "collector_->heap()->RecordWriteIntoCode(host, rinfo, object)",
          "old_line_content": "    Code* host = rinfo->host();",
          "new_line_content": "    collector_->heap()->RecordWriteIntoCode(host, rinfo, object);",
          "content_same": false
        },
        {
          "line": 1555,
          "old_api": "code_age_stub",
          "new_api": "heap",
          "old_text": "rinfo->code_age_stub()",
          "new_text": "collector_->heap()->InNewSpace(cell)",
          "old_line_content": "    Code* stub = rinfo->code_age_stub();",
          "new_line_content": "    DCHECK(!collector_->heap()->InNewSpace(cell));",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": "USE",
          "new_api": "RecordRelocSlot",
          "old_text": "USE(stub)",
          "new_text": "collector_->RecordRelocSlot(host, rinfo, cell)",
          "old_line_content": "    USE(stub);",
          "new_line_content": "    collector_->RecordRelocSlot(host, rinfo, cell);",
          "content_same": false
        },
        {
          "line": 1608,
          "old_api": "AbortCompactionForTesting",
          "new_api": "isolate",
          "old_text": "AbortCompactionForTesting(object)",
          "new_text": "heap->isolate()->is_profiling()",
          "old_line_content": "    if (AbortCompactionForTesting(object)) return false;",
          "new_line_content": "            heap->isolate()->is_profiling() ||",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": "Size",
          "new_api": "isolate",
          "old_text": "object->Size()",
          "new_text": "heap->isolate()->heap_profiler()->is_tracking_object_moves()",
          "old_line_content": "    int size = object->Size();",
          "new_line_content": "            heap->isolate()->heap_profiler()->is_tracking_object_moves()) {}",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": "address",
          "new_api": "MigrateObject<kFast>(dst, src, size, dest)",
          "old_text": "dst->address()",
          "new_text": "MigrateObject<kFast>(dst, src, size, dest)",
          "old_line_content": "    Address dst_addr = dst->address();",
          "new_line_content": "      MigrateObject<kFast>(dst, src, size, dest);",
          "content_same": false
        },
        {
          "line": 1639,
          "old_api": "CopyBlock",
          "new_api": "address",
          "old_text": "heap_->CopyBlock(dst_addr, src_addr, size)",
          "new_text": "dst->address()",
          "old_line_content": "      heap_->CopyBlock(dst_addr, src_addr, size);",
          "new_line_content": "    Address dst_addr = dst->address();",
          "content_same": false
        },
        {
          "line": 1640,
          "old_api": "IsBytecodeArray",
          "new_api": "address",
          "old_text": "dst->IsBytecodeArray()",
          "new_text": "src->address()",
          "old_line_content": "      if ((mode == kProfiled) && FLAG_ignition && dst->IsBytecodeArray()) {",
          "new_line_content": "    Address src_addr = src->address();",
          "content_same": false
        },
        {
          "line": 1641,
          "old_api": "isolate",
          "new_api": "AllowedToBeMigrated",
          "old_text": "heap_->isolate()",
          "new_text": "heap_->AllowedToBeMigrated(src, dest)",
          "old_line_content": "        PROFILE(heap_->isolate(),",
          "new_line_content": "    DCHECK(heap_->AllowedToBeMigrated(src, dest));",
          "content_same": false
        },
        {
          "line": 1642,
          "old_api": "AbstractCode::cast(src)",
          "new_api": "DCHECK",
          "old_text": "AbstractCode::cast(src)",
          "new_text": "DCHECK(dest != LO_SPACE)",
          "old_line_content": "                CodeMoveEvent(AbstractCode::cast(src), dst_addr));",
          "new_line_content": "    DCHECK(dest != LO_SPACE);",
          "content_same": false
        },
        {
          "line": 1644,
          "old_api": "mark_compact_collector",
          "new_api": "DCHECK_OBJECT_SIZE",
          "old_text": "heap_->mark_compact_collector()",
          "new_text": "DCHECK_OBJECT_SIZE(size)",
          "old_line_content": "      RecordMigratedSlotVisitor visitor(heap_->mark_compact_collector());",
          "new_line_content": "      DCHECK_OBJECT_SIZE(size);",
          "content_same": false
        },
        {
          "line": 1645,
          "old_api": "map",
          "new_api": "IsAligned",
          "old_text": "dst->map()->instance_type()",
          "new_text": "IsAligned(size, kPointerSize)",
          "old_line_content": "      dst->IterateBodyFast(dst->map()->instance_type(), size, &visitor);",
          "new_line_content": "      DCHECK(IsAligned(size, kPointerSize));",
          "content_same": false
        },
        {
          "line": 1647,
          "old_api": "code_space",
          "new_api": "IsBytecodeArray",
          "old_text": "heap_->code_space()",
          "new_text": "dst->IsBytecodeArray()",
          "old_line_content": "      DCHECK_CODEOBJECT_SIZE(size, heap_->code_space());",
          "new_line_content": "      if ((mode == kProfiled) && FLAG_ignition && dst->IsBytecodeArray()) {",
          "content_same": false
        },
        {
          "line": 1649,
          "old_api": "isolate",
          "new_api": "AbstractCode::cast(src)",
          "old_text": "heap_->isolate()",
          "new_text": "AbstractCode::cast(src)",
          "old_line_content": "        PROFILE(heap_->isolate(),",
          "new_line_content": "                CodeMoveEvent(AbstractCode::cast(src), dst_addr));",
          "content_same": false
        },
        {
          "line": 1652,
          "old_api": "CopyBlock",
          "new_api": "map",
          "old_text": "heap_->CopyBlock(dst_addr, src_addr, size)",
          "new_text": "dst->map()->instance_type()",
          "old_line_content": "      heap_->CopyBlock(dst_addr, src_addr, size);",
          "new_line_content": "      dst->IterateBodyFast(dst->map()->instance_type(), size, &visitor);",
          "content_same": false
        },
        {
          "line": 1654,
          "old_api": "mark_compact_collector",
          "new_api": "code_space",
          "old_text": "heap_->mark_compact_collector()",
          "new_text": "heap_->code_space()",
          "old_line_content": "      RecordMigratedSlotVisitor visitor(heap_->mark_compact_collector());",
          "new_line_content": "      DCHECK_CODEOBJECT_SIZE(size, heap_->code_space());",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": "DCHECK_OBJECT_SIZE",
          "new_api": "AbstractCode::cast(src)",
          "old_text": "DCHECK_OBJECT_SIZE(size)",
          "new_text": "AbstractCode::cast(src)",
          "old_line_content": "      DCHECK_OBJECT_SIZE(size);",
          "new_line_content": "                CodeMoveEvent(AbstractCode::cast(src), dst_addr));",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": "OnMoveEvent",
          "new_api": "map",
          "old_text": "heap_->OnMoveEvent(dst, src, size)",
          "new_text": "dst->map()->instance_type()",
          "old_line_content": "      heap_->OnMoveEvent(dst, src, size);",
          "new_line_content": "      dst->IterateBodyFast(dst->map()->instance_type(), size, &visitor);",
          "content_same": false
        },
        {
          "line": 1664,
          "old_api": "Memory::Address_at(src_addr)",
          "new_api": "DCHECK_OBJECT_SIZE",
          "old_text": "Memory::Address_at(src_addr)",
          "new_text": "DCHECK_OBJECT_SIZE(size)",
          "old_line_content": "    Memory::Address_at(src_addr) = dst_addr;",
          "new_line_content": "      DCHECK_OBJECT_SIZE(size);",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": "heap_->UpdateAllocationSite<Heap::kCached>(object,\n                                               local_pretenuring_feedback_)",
          "new_api": "LocalAllocationBuffer::InvalidBuffer()",
          "old_text": "heap_->UpdateAllocationSite<Heap::kCached>(object,\n                                               local_pretenuring_feedback_)",
          "new_text": "LocalAllocationBuffer::InvalidBuffer()",
          "old_line_content": "    heap_->UpdateAllocationSite<Heap::kCached>(object,",
          "new_line_content": "        buffer_(LocalAllocationBuffer::InvalidBuffer()),",
          "content_same": false
        },
        {
          "line": 1720,
          "old_api": "AllocateTargetObject",
          "new_api": "address",
          "old_text": "AllocateTargetObject(object, &target)",
          "new_text": "object->address()",
          "old_line_content": "    AllocationSpace space = AllocateTargetObject(object, &target);",
          "new_line_content": "    if (heap_->ShouldBePromoted<DEFAULT_PROMOTION>(object->address(), size) &&",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": "HeapObject::cast(target)",
          "new_api": "Get",
          "old_text": "HeapObject::cast(target)",
          "new_text": "compaction_spaces_->Get(OLD_SPACE)",
          "old_line_content": "    MigrateObject(HeapObject::cast(target), object, size, space);",
          "new_line_content": "        TryEvacuateObject(compaction_spaces_->Get(OLD_SPACE), object,",
          "content_same": false
        },
        {
          "line": 1745,
          "old_api": "AllocateInLab",
          "new_api": "RequiredAlignment",
          "old_text": "AllocateInLab(size, alignment)",
          "new_text": "old_object->RequiredAlignment()",
          "old_line_content": "        allocation = AllocateInLab(size, alignment);",
          "new_line_content": "    AllocationAlignment alignment = old_object->RequiredAlignment();",
          "content_same": false
        },
        {
          "line": 1752,
          "old_api": "DCHECK",
          "new_api": "AllocateInLab",
          "old_text": "DCHECK(ok)",
          "new_text": "AllocateInLab(size, alignment)",
          "old_line_content": "    DCHECK(ok);",
          "new_line_content": "        allocation = AllocateInLab(size, alignment);",
          "content_same": false
        },
        {
          "line": 1759,
          "old_api": "AllocateInNewSpace",
          "new_api": "DCHECK",
          "old_text": "AllocateInNewSpace(kLabSize, kWordAligned, kStickyBailoutOldSpace)",
          "new_text": "DCHECK(ok)",
          "old_line_content": "        AllocateInNewSpace(kLabSize, kWordAligned, kStickyBailoutOldSpace);",
          "new_line_content": "    DCHECK(ok);",
          "content_same": false
        },
        {
          "line": 1780,
          "old_api": "IsRetry",
          "new_api": "new_space",
          "old_text": "allocation.IsRetry()",
          "new_text": "heap_->new_space()->AllocateRawSynchronized(size_in_bytes, alignment)",
          "old_line_content": "        if (allocation.IsRetry()) {",
          "new_line_content": "        heap_->new_space()->AllocateRawSynchronized(size_in_bytes, alignment);",
          "content_same": false
        },
        {
          "line": 1810,
          "old_api": "IsRetry",
          "new_api": "IsValid",
          "old_text": "allocation.IsRetry()",
          "new_text": "buffer_.IsValid()",
          "old_line_content": "    if (allocation.IsRetry()) {",
          "new_line_content": "    if (!buffer_.IsValid()) {",
          "content_same": false
        },
        {
          "line": 1816,
          "old_api": "IsRetry",
          "new_api": "AllocateRawAligned",
          "old_text": "allocation.IsRetry()",
          "new_text": "buffer_.AllocateRawAligned(size_in_bytes, alignment)",
          "old_line_content": "        if (allocation.IsRetry()) {",
          "new_line_content": "    allocation = buffer_.AllocateRawAligned(size_in_bytes, alignment);",
          "content_same": false
        },
        {
          "line": 1818,
          "old_api": "AllocationResult::Retry(OLD_SPACE)",
          "new_api": "NewLocalAllocationBuffer",
          "old_text": "AllocationResult::Retry(OLD_SPACE)",
          "new_text": "NewLocalAllocationBuffer()",
          "old_line_content": "          return AllocationResult::Retry(OLD_SPACE);",
          "new_line_content": "      if (!NewLocalAllocationBuffer()) {",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": "SetFlag",
          "new_api": "Unlink",
          "old_text": "page->SetFlag(Page::PAGE_NEW_NEW_PROMOTION)",
          "new_text": "page->Unlink()",
          "old_line_content": "    page->SetFlag(Page::PAGE_NEW_NEW_PROMOTION);",
          "new_line_content": "    page->Unlink();",
          "content_same": false
        },
        {
          "line": 1852,
          "old_api": "Size",
          "new_api": "heap",
          "old_text": "object->Size()",
          "new_text": "page->heap()->new_space()->MovePageFromSpaceToSpace(page)",
          "old_line_content": "    promoted_size_ += object->Size();",
          "new_line_content": "    page->heap()->new_space()->MovePageFromSpaceToSpace(page);",
          "content_same": false
        },
        {
          "line": 1912,
          "old_api": "new_space",
          "new_api": "DiscoverGreyObjectsOnPage",
          "old_text": "heap()->new_space()",
          "new_text": "DiscoverGreyObjectsOnPage(p)",
          "old_line_content": "  NewSpace* space = heap()->new_space();",
          "new_line_content": "    DiscoverGreyObjectsOnPage(p);",
          "content_same": false
        },
        {
          "line": 1913,
          "old_api": "top",
          "new_api": "IsFull",
          "old_text": "space->top()",
          "new_text": "marking_deque()->IsFull()",
          "old_line_content": "  for (Page* page : NewSpacePageRange(space->bottom(), space->top())) {",
          "new_line_content": "    if (marking_deque()->IsFull()) return;",
          "content_same": false
        },
        {
          "line": 1922,
          "old_api": "IsHeapObject",
          "new_api": "IsFull",
          "old_text": "o->IsHeapObject()",
          "new_text": "marking_deque()->IsFull()",
          "old_line_content": "  if (!o->IsHeapObject()) return false;",
          "new_line_content": "    if (marking_deque()->IsFull()) return;",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": "IsHeapObject",
          "new_api": "Marking::IsWhite(mark)",
          "old_text": "o->IsHeapObject()",
          "new_text": "Marking::IsWhite(mark)",
          "old_line_content": "  DCHECK(o->IsHeapObject());",
          "new_line_content": "  return Marking::IsWhite(mark);",
          "content_same": false
        },
        {
          "line": 1940,
          "old_api": "string_table",
          "new_api": "HeapObject::cast(o)",
          "old_text": "heap()->string_table()",
          "new_text": "HeapObject::cast(o)",
          "old_line_content": "  StringTable* string_table = heap()->string_table();",
          "new_line_content": "  HeapObject* heap_object = HeapObject::cast(o);",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": "ObjectMarking::MarkBitFrom(string_table)",
          "new_api": "Marking::IsWhite(mark)",
          "old_text": "ObjectMarking::MarkBitFrom(string_table)",
          "new_text": "Marking::IsWhite(mark)",
          "old_line_content": "  MarkBit string_table_mark = ObjectMarking::MarkBitFrom(string_table);",
          "new_line_content": "  return Marking::IsWhite(mark);",
          "content_same": false
        },
        {
          "line": 1949,
          "old_api": "ProcessMarkingDeque",
          "new_api": "ObjectMarking::MarkBitFrom(string_table)",
          "old_text": "ProcessMarkingDeque()",
          "new_text": "ObjectMarking::MarkBitFrom(string_table)",
          "old_line_content": "  ProcessMarkingDeque();",
          "new_line_content": "  MarkBit string_table_mark = ObjectMarking::MarkBitFrom(string_table);",
          "content_same": false
        },
        {
          "line": 1955,
          "old_api": "SetMark",
          "new_api": "IteratePrefix",
          "old_text": "SetMark(site, mark_bit)",
          "new_text": "string_table->IteratePrefix(visitor)",
          "old_line_content": "  SetMark(site, mark_bit);",
          "new_line_content": "  string_table->IteratePrefix(visitor);",
          "content_same": false
        },
        {
          "line": 1962,
          "old_api": "IterateStrongRoots",
          "new_api": "SetMark",
          "old_text": "heap()->IterateStrongRoots(visitor, VISIT_ONLY_STRONG)",
          "new_text": "SetMark(site, mark_bit)",
          "old_line_content": "  heap()->IterateStrongRoots(visitor, VISIT_ONLY_STRONG);",
          "new_line_content": "  SetMark(site, mark_bit);",
          "content_same": false
        },
        {
          "line": 1969,
          "old_api": "RefillMarkingDeque",
          "new_api": "IterateStrongRoots",
          "old_text": "RefillMarkingDeque()",
          "new_text": "heap()->IterateStrongRoots(visitor, VISIT_ONLY_STRONG)",
          "old_line_content": "    RefillMarkingDeque();",
          "new_line_content": "  heap()->IterateStrongRoots(visitor, VISIT_ONLY_STRONG);",
          "content_same": false
        },
        {
          "line": 1985,
          "old_api": "IsMarked",
          "new_api": "global_handles",
          "old_text": "IsMarked(*entry->parent)",
          "new_text": "isolate()->global_handles()->implicit_ref_groups()",
          "old_line_content": "    if (!IsMarked(*entry->parent)) {",
          "new_line_content": "      isolate()->global_handles()->implicit_ref_groups();",
          "content_same": false
        },
        {
          "line": 2019,
          "old_api": "map",
          "new_api": "Pop",
          "old_text": "object->map()",
          "new_text": "marking_deque_.Pop()",
          "old_line_content": "    Map* map = object->map();",
          "new_line_content": "    HeapObject* object = marking_deque_.Pop();",
          "content_same": false
        },
        {
          "line": 2021,
          "old_api": "MarkObject",
          "new_api": "IsFiller",
          "old_text": "MarkObject(map, map_mark)",
          "new_text": "object->IsFiller()",
          "old_line_content": "    MarkObject(map, map_mark);",
          "new_line_content": "    DCHECK(!object->IsFiller());",
          "content_same": false
        },
        {
          "line": 2023,
          "old_api": "MarkCompactMarkingVisitor::IterateBody(map, object)",
          "new_api": "Contains",
          "old_text": "MarkCompactMarkingVisitor::IterateBody(map, object)",
          "new_text": "heap()->Contains(object)",
          "old_line_content": "    MarkCompactMarkingVisitor::IterateBody(map, object);",
          "new_line_content": "    DCHECK(heap()->Contains(object));",
          "content_same": false
        },
        {
          "line": 2041,
          "old_api": "IsFull",
          "new_api": "CountUsage",
          "old_text": "marking_deque_.IsFull()",
          "new_text": "isolate()->CountUsage(v8::Isolate::UseCounterFeature::kMarkDequeOverflow)",
          "old_line_content": "  if (marking_deque_.IsFull()) return;",
          "new_line_content": "  isolate()->CountUsage(v8::Isolate::UseCounterFeature::kMarkDequeOverflow);",
          "content_same": false
        },
        {
          "line": 2044,
          "old_api": "IsFull",
          "new_api": "DiscoverGreyObjectsInNewSpace",
          "old_text": "marking_deque_.IsFull()",
          "new_text": "DiscoverGreyObjectsInNewSpace()",
          "old_line_content": "  if (marking_deque_.IsFull()) return;",
          "new_line_content": "  DiscoverGreyObjectsInNewSpace();",
          "content_same": false
        },
        {
          "line": 2047,
          "old_api": "IsFull",
          "new_api": "old_space",
          "old_text": "marking_deque_.IsFull()",
          "new_text": "heap()->old_space()",
          "old_line_content": "  if (marking_deque_.IsFull()) return;",
          "new_line_content": "  DiscoverGreyObjectsInSpace(heap()->old_space());",
          "content_same": false
        },
        {
          "line": 2050,
          "old_api": "DiscoverGreyObjectsWithIterator",
          "new_api": "code_space",
          "old_text": "DiscoverGreyObjectsWithIterator(&lo_it)",
          "new_text": "heap()->code_space()",
          "old_line_content": "  DiscoverGreyObjectsWithIterator(&lo_it);",
          "new_line_content": "  DiscoverGreyObjectsInSpace(heap()->code_space());",
          "content_same": false
        },
        {
          "line": 2053,
          "old_api": "ClearOverflowed",
          "new_api": "map_space",
          "old_text": "marking_deque_.ClearOverflowed()",
          "new_text": "heap()->map_space()",
          "old_line_content": "  marking_deque_.ClearOverflowed();",
          "new_line_content": "  DiscoverGreyObjectsInSpace(heap()->map_space());",
          "content_same": false
        },
        {
          "line": 2083,
          "old_api": "global_handles",
          "new_api": "UsingEmbedderHeapTracer",
          "old_text": "isolate()->global_handles()->IterateObjectGroups(\n          visitor, &IsUnmarkedHeapObjectWithHeap)",
          "new_text": "UsingEmbedderHeapTracer()",
          "old_line_content": "      isolate()->global_handles()->IterateObjectGroups(",
          "new_line_content": "    if (UsingEmbedderHeapTracer()) {",
          "content_same": false
        },
        {
          "line": 2085,
          "old_api": "MarkImplicitRefGroups",
          "new_api": "AdvanceTracing",
          "old_text": "MarkImplicitRefGroups(&MarkCompactMarkingVisitor::MarkObject)",
          "new_text": "embedder_heap_tracer()->AdvanceTracing(\n          0, EmbedderHeapTracer::AdvanceTracingActions(\n                 EmbedderHeapTracer::ForceCompletionAction::FORCE_COMPLETION))",
          "old_line_content": "      MarkImplicitRefGroups(&MarkCompactMarkingVisitor::MarkObject);",
          "new_line_content": "      embedder_heap_tracer()->AdvanceTracing(",
          "content_same": false
        },
        {
          "line": 2095,
          "old_api": "Advance",
          "new_api": "IsEmpty",
          "old_text": "it.Advance()",
          "new_text": "marking_deque_.IsEmpty()",
          "old_line_content": "       !it.done(); it.Advance()) {",
          "new_line_content": "    work_to_do = !marking_deque_.IsEmpty();",
          "content_same": false
        },
        {
          "line": 2096,
          "old_api": "frame",
          "new_api": "ProcessMarkingDeque",
          "old_text": "it.frame()->type()",
          "new_text": "ProcessMarkingDeque()",
          "old_line_content": "    if (it.frame()->type() == StackFrame::JAVA_SCRIPT) {",
          "new_line_content": "    ProcessMarkingDeque();",
          "content_same": false
        },
        {
          "line": 2102,
          "old_api": "Code::BodyDescriptor::IterateBody(code, visitor)",
          "new_api": "Advance",
          "old_text": "Code::BodyDescriptor::IterateBody(code, visitor)",
          "new_text": "it.Advance()",
          "old_line_content": "        Code::BodyDescriptor::IterateBody(code, visitor);",
          "new_line_content": "       !it.done(); it.Advance()) {",
          "content_same": false
        },
        {
          "line": 2141,
          "old_api": "UNREACHABLE",
          "new_api": "Uncommit",
          "old_text": "UNREACHABLE()",
          "new_text": "marking_deque_memory_->Uncommit(\n          reinterpret_cast<Address>(marking_deque_memory_->address()) + size,\n          currently_committed - size)",
          "old_line_content": "      UNREACHABLE();",
          "new_line_content": "      bool success = marking_deque_memory_->Uncommit(",
          "content_same": false
        },
        {
          "line": 2160,
          "old_api": "address",
          "new_api": "V8::FatalProcessOutOfMemory(\"EnsureMarkingDequeIsCommitted\")",
          "old_text": "marking_deque_memory_->address()",
          "new_text": "V8::FatalProcessOutOfMemory(\"EnsureMarkingDequeIsCommitted\")",
          "old_line_content": "  Address addr = static_cast<Address>(marking_deque_memory_->address());",
          "new_line_content": "  V8::FatalProcessOutOfMemory(\"EnsureMarkingDequeIsCommitted\");",
          "content_same": false
        },
        {
          "line": 2170,
          "old_api": "reinterpret_cast<HeapObject**>(high)",
          "new_api": "Initialize",
          "old_text": "reinterpret_cast<HeapObject**>(high)",
          "new_text": "marking_deque_.Initialize(addr, addr + size)",
          "old_line_content": "  HeapObject** obj_high = reinterpret_cast<HeapObject**>(high);",
          "new_line_content": "  marking_deque_.Initialize(addr, addr + size);",
          "content_same": false
        },
        {
          "line": 2193,
          "old_api": "CHECK_NULL",
          "new_api": "DCHECK",
          "old_text": "CHECK_NULL(embedder_heap_tracer_)",
          "new_text": "DCHECK(in_use_)",
          "old_line_content": "  CHECK_NULL(embedder_heap_tracer_);",
          "new_line_content": "  DCHECK(in_use_);",
          "content_same": false
        },
        {
          "line": 2199,
          "old_api": "empty",
          "new_api": "DCHECK_NOT_NULL",
          "old_text": "wrappers_to_trace_.empty()",
          "new_text": "DCHECK_NOT_NULL(tracer)",
          "old_line_content": "  if (wrappers_to_trace_.empty()) {",
          "new_line_content": "  DCHECK_NOT_NULL(tracer);",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": "GetInternalField",
          "new_api": "RegisterV8References",
          "old_text": "js_object->GetInternalField(0)",
          "new_text": "embedder_heap_tracer()->RegisterV8References(wrappers_to_trace_)",
          "old_line_content": "      js_object->GetInternalField(0) &&",
          "new_line_content": "  embedder_heap_tracer()->RegisterV8References(wrappers_to_trace_);",
          "content_same": false
        },
        {
          "line": 2210,
          "old_api": "undefined_value",
          "new_api": "clear",
          "old_text": "heap_->undefined_value()",
          "new_text": "wrappers_to_trace_.clear()",
          "old_line_content": "      js_object->GetInternalField(0) != heap_->undefined_value() &&",
          "new_line_content": "  wrappers_to_trace_.clear();",
          "content_same": false
        },
        {
          "line": 2214,
          "old_api": "GetInternalField",
          "new_api": "WasConstructedFromApiFunction",
          "old_text": "js_object->GetInternalField(0)",
          "new_text": "js_object->WasConstructedFromApiFunction()",
          "old_line_content": "        reinterpret_cast<void*>(js_object->GetInternalField(0)),",
          "new_line_content": "  DCHECK(js_object->WasConstructedFromApiFunction());",
          "content_same": false
        },
        {
          "line": 2215,
          "old_api": "GetInternalField",
          "new_api": "GetInternalFieldCount",
          "old_text": "js_object->GetInternalField(1)",
          "new_text": "js_object->GetInternalFieldCount()",
          "old_line_content": "        reinterpret_cast<void*>(js_object->GetInternalField(1))));",
          "new_line_content": "  if (js_object->GetInternalFieldCount() >= 2 &&",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": "in_use",
          "new_api": "GetInternalField",
          "old_text": "in_use()",
          "new_text": "std::pair<void*, void*>(\n        reinterpret_cast<void*>(js_object->GetInternalField(0)),\n        reinterpret_cast<void*>(js_object->GetInternalField(1)))",
          "old_line_content": "  DCHECK(in_use());",
          "new_line_content": "    wrappers_to_trace_.push_back(std::pair<void*, void*>(",
          "content_same": false
        },
        {
          "line": 2221,
          "old_api": "HeapObject::cast(*object)",
          "new_api": "GetInternalField",
          "old_text": "HeapObject::cast(*object)",
          "new_text": "js_object->GetInternalField(0)",
          "old_line_content": "  HeapObject* heap_object = HeapObject::cast(*object);",
          "new_line_content": "        reinterpret_cast<void*>(js_object->GetInternalField(0)),",
          "content_same": false
        },
        {
          "line": 2222,
          "old_api": "Contains",
          "new_api": "GetInternalField",
          "old_text": "heap_->Contains(heap_object)",
          "new_text": "js_object->GetInternalField(1)",
          "old_line_content": "  DCHECK(heap_->Contains(heap_object));",
          "new_line_content": "        reinterpret_cast<void*>(js_object->GetInternalField(1))));",
          "content_same": false
        },
        {
          "line": 2240,
          "old_api": "ObjectMarking::MarkBitFrom(obj)",
          "new_api": "DCHECK_NOT_NULL",
          "old_text": "ObjectMarking::MarkBitFrom(obj)",
          "new_text": "DCHECK_NOT_NULL(live_stats)",
          "old_line_content": "    if (Marking::IsBlack(ObjectMarking::MarkBitFrom(obj))) {",
          "new_line_content": "    DCHECK_NOT_NULL(live_stats);",
          "content_same": false
        },
        {
          "line": 2241,
          "old_api": "CollectStatistics",
          "new_api": "DCHECK_NOT_NULL",
          "old_text": "live_collector_.CollectStatistics(obj)",
          "new_text": "DCHECK_NOT_NULL(dead_stats)",
          "old_line_content": "      live_collector_.CollectStatistics(obj);",
          "new_line_content": "    DCHECK_NOT_NULL(dead_stats);",
          "content_same": false
        },
        {
          "line": 2243,
          "old_api": "ObjectMarking::MarkBitFrom(obj)",
          "new_api": "CollectGlobalStatistics",
          "old_text": "ObjectMarking::MarkBitFrom(obj)",
          "new_text": "live_collector_.CollectGlobalStatistics()",
          "old_line_content": "      DCHECK(!Marking::IsGrey(ObjectMarking::MarkBitFrom(obj)));",
          "new_line_content": "    live_collector_.CollectGlobalStatistics();",
          "content_same": false
        },
        {
          "line": 2298,
          "old_api": "in_use",
          "new_api": "tracer",
          "old_text": "marking_deque_.in_use()",
          "new_text": "heap()->tracer()",
          "old_line_content": "      if (marking_deque_.in_use()) {",
          "new_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_MARK_FINISH_INCREMENTAL);",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": "Uninitialize",
          "new_api": "incremental_marking",
          "old_text": "marking_deque_.Uninitialize(true)",
          "new_text": "heap_->incremental_marking()",
          "old_line_content": "        marking_deque_.Uninitialize(true);",
          "new_line_content": "    IncrementalMarking* incremental_marking = heap_->incremental_marking();",
          "content_same": false
        },
        {
          "line": 2305,
          "old_api": "DCHECK",
          "new_api": "in_use",
          "old_text": "DCHECK(state_ == PREPARE_GC)",
          "new_text": "marking_deque_.in_use()",
          "old_line_content": "  DCHECK(state_ == PREPARE_GC);",
          "new_line_content": "      if (marking_deque_.in_use()) {",
          "content_same": false
        },
        {
          "line": 2321,
          "old_api": "MarkRoots",
          "new_api": "PrepareForCodeFlushing",
          "old_text": "MarkRoots(&root_visitor)",
          "new_text": "PrepareForCodeFlushing()",
          "old_line_content": "    MarkRoots(&root_visitor);",
          "new_line_content": "    PrepareForCodeFlushing();",
          "content_same": false
        },
        {
          "line": 2354,
          "old_api": "tracer",
          "new_api": "isolate",
          "old_text": "heap()->tracer()",
          "new_text": "heap()->isolate()->global_handles()->IdentifyWeakHandles(\n          &IsUnmarkedHeapObject)",
          "old_line_content": "      TRACE_GC(heap()->tracer(),",
          "new_line_content": "      heap()->isolate()->global_handles()->IdentifyWeakHandles(",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": "isolate",
          "new_api": "ProcessMarkingDeque",
          "old_text": "heap()->isolate()->global_handles()->IterateWeakRoots(&root_visitor)",
          "new_text": "ProcessMarkingDeque()",
          "old_line_content": "      heap()->isolate()->global_handles()->IterateWeakRoots(&root_visitor);",
          "new_line_content": "      ProcessMarkingDeque();",
          "content_same": false
        },
        {
          "line": 2375,
          "old_api": "MonotonicallyIncreasingTimeInMs",
          "new_api": "UsingEmbedderHeapTracer",
          "old_text": "heap_->MonotonicallyIncreasingTimeInMs()",
          "new_text": "UsingEmbedderHeapTracer()",
          "old_line_content": "    heap_->tracer()->AddMarkingTime(heap_->MonotonicallyIncreasingTimeInMs() -",
          "new_line_content": "      if (UsingEmbedderHeapTracer()) {",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": "tracer",
          "new_api": "MonotonicallyIncreasingTimeInMs",
          "old_text": "heap()->tracer()",
          "new_text": "heap_->MonotonicallyIncreasingTimeInMs()",
          "old_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_CLEAR);",
          "new_line_content": "    heap_->tracer()->AddMarkingTime(heap_->MonotonicallyIncreasingTimeInMs() -",
          "content_same": false
        },
        {
          "line": 2392,
          "old_api": "IterateElements",
          "new_api": "tracer",
          "old_text": "string_table->IterateElements(&internalized_visitor)",
          "new_text": "heap()->tracer()",
          "old_line_content": "    string_table->IterateElements(&internalized_visitor);",
          "new_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_CLEAR_STRING_TABLE);",
          "content_same": false
        },
        {
          "line": 2397,
          "old_api": "CleanUp",
          "new_api": "string_table",
          "old_text": "heap()->external_string_table_.CleanUp()",
          "new_text": "heap()->string_table()",
          "old_line_content": "    heap()->external_string_table_.CleanUp();",
          "new_line_content": "    StringTable* string_table = heap()->string_table();",
          "content_same": false
        },
        {
          "line": 2404,
          "old_api": "ProcessAllWeakReferences",
          "new_api": "CleanUp",
          "old_text": "heap()->ProcessAllWeakReferences(&mark_compact_object_retainer)",
          "new_text": "heap()->external_string_table_.CleanUp()",
          "old_line_content": "    heap()->ProcessAllWeakReferences(&mark_compact_object_retainer);",
          "new_line_content": "    heap()->external_string_table_.CleanUp();",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": "isolate",
          "new_api": "ProcessAllWeakReferences",
          "old_text": "heap()->isolate()->global_handles()->RemoveObjectGroups()",
          "new_text": "heap()->ProcessAllWeakReferences(&mark_compact_object_retainer)",
          "old_line_content": "    heap()->isolate()->global_handles()->RemoveObjectGroups();",
          "new_line_content": "    heap()->ProcessAllWeakReferences(&mark_compact_object_retainer);",
          "content_same": false
        },
        {
          "line": 2418,
          "old_api": "ProcessCandidates",
          "new_api": "isolate",
          "old_text": "code_flusher_->ProcessCandidates()",
          "new_text": "heap()->isolate()->global_handles()->RemoveObjectGroups()",
          "old_line_content": "    code_flusher_->ProcessCandidates();",
          "new_line_content": "    heap()->isolate()->global_handles()->RemoveObjectGroups();",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": "ClearWeakCells",
          "new_api": "tracer",
          "old_text": "ClearWeakCells(&non_live_map_list, &dependent_code_list)",
          "new_text": "heap()->tracer()",
          "old_line_content": "  ClearWeakCells(&non_live_map_list, &dependent_code_list);",
          "new_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_CLEAR_CODE_FLUSH);",
          "content_same": false
        },
        {
          "line": 2434,
          "old_api": "ClearWeakCollections",
          "new_api": "tracer",
          "old_text": "ClearWeakCollections()",
          "new_text": "heap()->tracer()",
          "old_line_content": "  ClearWeakCollections();",
          "new_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_CLEAR_MAPS);",
          "content_same": false
        },
        {
          "line": 2436,
          "old_api": "ClearInvalidRememberedSetSlots",
          "new_api": "ClearFullMapTransitions",
          "old_text": "ClearInvalidRememberedSetSlots()",
          "new_text": "ClearFullMapTransitions()",
          "old_line_content": "  ClearInvalidRememberedSetSlots();",
          "new_line_content": "    ClearFullMapTransitions();",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": "isolate",
          "new_api": "ClearInvalidRememberedSetSlots",
          "old_text": "this->isolate()",
          "new_text": "ClearInvalidRememberedSetSlots()",
          "old_line_content": "  Isolate* isolate = this->isolate();",
          "new_line_content": "  ClearInvalidRememberedSetSlots();",
          "content_same": false
        },
        {
          "line": 2452,
          "old_api": "weak_new_space_object_to_code_list",
          "new_api": "length",
          "old_text": "heap_->weak_new_space_object_to_code_list()",
          "new_text": "current->length()",
          "old_line_content": "    ArrayList* list = heap_->weak_new_space_object_to_code_list();",
          "new_line_content": "  while (current->length() > 0) {",
          "content_same": false
        },
        {
          "line": 2455,
          "old_api": "Get",
          "new_api": "next_link",
          "old_text": "list->Get(i)",
          "new_text": "current->next_link()",
          "old_line_content": "      WeakCell* obj = WeakCell::cast(list->Get(i));",
          "new_line_content": "    current = current->next_link();",
          "content_same": false
        },
        {
          "line": 2459,
          "old_api": "value",
          "new_api": "weak_new_space_object_to_code_list",
          "old_text": "dep->value()",
          "new_text": "heap_->weak_new_space_object_to_code_list()",
          "old_line_content": "          Code* code = Code::cast(dep->value());",
          "new_line_content": "    ArrayList* list = heap_->weak_new_space_object_to_code_list();",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": "DependentCode::SetMarkedForDeoptimization(\n                code, DependentCode::DependencyGroup::kWeakCodeGroup)",
          "new_api": "Length",
          "old_text": "DependentCode::SetMarkedForDeoptimization(\n                code, DependentCode::DependencyGroup::kWeakCodeGroup)",
          "new_text": "list->Length()",
          "old_line_content": "            DependentCode::SetMarkedForDeoptimization(",
          "new_line_content": "    for (int i = 0; i < list->Length(); i += 2) {",
          "content_same": false
        },
        {
          "line": 2463,
          "old_api": "InvalidateEmbeddedObjects",
          "new_api": "Get",
          "old_text": "code->InvalidateEmbeddedObjects()",
          "new_text": "list->Get(i + 1)",
          "old_line_content": "            code->InvalidateEmbeddedObjects();",
          "new_line_content": "      WeakCell* dep = WeakCell::cast(list->Get(i + 1));",
          "content_same": false
        },
        {
          "line": 2470,
          "old_api": "Set",
          "new_api": "InvalidateEmbeddedObjects",
          "old_text": "list->Set(counter, obj, SKIP_WRITE_BARRIER)",
          "new_text": "code->InvalidateEmbeddedObjects()",
          "old_line_content": "        list->Set(counter, obj, SKIP_WRITE_BARRIER);",
          "new_line_content": "            code->InvalidateEmbeddedObjects();",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": "weak_object_to_code_table",
          "new_api": "Set",
          "old_text": "heap_->weak_object_to_code_table()",
          "new_text": "list->Set(counter, dep, SKIP_WRITE_BARRIER)",
          "old_line_content": "  WeakHashTable* table = heap_->weak_object_to_code_table();",
          "new_line_content": "        list->Set(counter, dep, SKIP_WRITE_BARRIER);",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": "Capacity",
          "new_api": "Slot",
          "old_text": "table->Capacity()",
          "new_text": "list->Slot(counter)",
          "old_line_content": "  uint32_t capacity = table->Capacity();",
          "new_line_content": "        RecordSlot(list, list->Slot(counter), dep);",
          "content_same": false
        },
        {
          "line": 2487,
          "old_api": "get",
          "new_api": "weak_object_to_code_table",
          "old_text": "table->get(value_index)",
          "new_text": "heap_->weak_object_to_code_table()",
          "old_line_content": "    Object* value = table->get(value_index);",
          "new_line_content": "  WeakHashTable* table = heap_->weak_object_to_code_table();",
          "content_same": false
        },
        {
          "line": 2488,
          "old_api": "IsWeakCell",
          "new_api": "Capacity",
          "old_text": "key->IsWeakCell()",
          "new_text": "table->Capacity()",
          "old_line_content": "    DCHECK(key->IsWeakCell());",
          "new_line_content": "  uint32_t capacity = table->Capacity();",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": "MarkCodeForDeoptimization",
          "new_api": "get",
          "old_text": "DependentCode::cast(value)->MarkCodeForDeoptimization(\n              isolate, DependentCode::kWeakCodeGroup)",
          "new_text": "table->get(key_index)",
          "old_line_content": "          DependentCode::cast(value)->MarkCodeForDeoptimization(",
          "new_line_content": "    Object* key = table->get(key_index);",
          "content_same": false
        },
        {
          "line": 2493,
          "old_api": "the_hole_value",
          "new_api": "EntryToValueIndex",
          "old_text": "heap_->the_hole_value()",
          "new_text": "table->EntryToValueIndex(i)",
          "old_line_content": "      table->set(key_index, heap_->the_hole_value());",
          "new_line_content": "    uint32_t value_index = table->EntryToValueIndex(i);",
          "content_same": false
        },
        {
          "line": 2494,
          "old_api": "the_hole_value",
          "new_api": "get",
          "old_text": "heap_->the_hole_value()",
          "new_text": "table->get(value_index)",
          "old_line_content": "      table->set(value_index, heap_->the_hole_value());",
          "new_line_content": "    Object* value = table->get(value_index);",
          "content_same": false
        },
        {
          "line": 2495,
          "old_api": "ElementRemoved",
          "new_api": "IsWeakCell",
          "old_text": "table->ElementRemoved()",
          "new_text": "key->IsWeakCell()",
          "old_line_content": "      table->ElementRemoved();",
          "new_line_content": "    DCHECK(key->IsWeakCell());",
          "content_same": false
        },
        {
          "line": 2510,
          "old_api": "IsMap",
          "new_api": "the_hole_value",
          "old_text": "potential_parent->IsMap()",
          "new_text": "heap()->the_hole_value()",
          "old_line_content": "    if (potential_parent->IsMap()) {",
          "new_line_content": "  Object* the_hole_value = heap()->the_hole_value();",
          "content_same": false
        },
        {
          "line": 2512,
          "old_api": "ObjectMarking::MarkBitFrom(parent)",
          "new_api": "Smi::FromInt(0)",
          "old_text": "ObjectMarking::MarkBitFrom(parent)",
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "      if (Marking::IsBlackOrGrey(ObjectMarking::MarkBitFrom(parent)) &&",
          "new_line_content": "  while (weak_cell_obj != Smi::FromInt(0)) {",
          "content_same": false
        },
        {
          "line": 2513,
          "old_api": "raw_transitions",
          "new_api": "WeakCell::cast(weak_cell_obj)",
          "old_text": "parent->raw_transitions()",
          "new_text": "WeakCell::cast(weak_cell_obj)",
          "old_line_content": "          parent->raw_transitions() == weak_cell) {",
          "new_line_content": "    WeakCell* weak_cell = WeakCell::cast(weak_cell_obj);",
          "content_same": false
        },
        {
          "line": 2514,
          "old_api": "ClearSimpleMapTransition",
          "new_api": "value",
          "old_text": "ClearSimpleMapTransition(parent, map)",
          "new_text": "weak_cell->value()",
          "old_line_content": "        ClearSimpleMapTransition(parent, map);",
          "new_line_content": "    Map* map = Map::cast(weak_cell->value());",
          "content_same": false
        },
        {
          "line": 2517,
          "old_api": "clear",
          "new_api": "IsMap",
          "old_text": "weak_cell->clear()",
          "new_text": "potential_parent->IsMap()",
          "old_line_content": "    weak_cell->clear();",
          "new_line_content": "    if (potential_parent->IsMap()) {",
          "content_same": false
        },
        {
          "line": 2518,
          "old_api": "next",
          "new_api": "Map::cast(potential_parent)",
          "old_text": "weak_cell->next()",
          "new_text": "Map::cast(potential_parent)",
          "old_line_content": "    weak_cell_obj = weak_cell->next();",
          "new_line_content": "      Map* parent = Map::cast(potential_parent);",
          "content_same": false
        },
        {
          "line": 2519,
          "old_api": "clear_next",
          "new_api": "ObjectMarking::MarkBitFrom(parent)",
          "old_text": "weak_cell->clear_next(the_hole_value)",
          "new_text": "ObjectMarking::MarkBitFrom(parent)",
          "old_line_content": "    weak_cell->clear_next(the_hole_value);",
          "new_line_content": "      if (Marking::IsBlackOrGrey(ObjectMarking::MarkBitFrom(parent)) &&",
          "content_same": false
        },
        {
          "line": 2536,
          "old_api": "set_owns_descriptors",
          "new_api": "Smi::FromInt(0)",
          "old_text": "map->set_owns_descriptors(true)",
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "    map->set_owns_descriptors(true);",
          "new_line_content": "  map->set_raw_transitions(Smi::FromInt(0));",
          "content_same": false
        },
        {
          "line": 2542,
          "old_api": "undefined_value",
          "new_api": "number_of_descriptors",
          "old_text": "heap()->undefined_value()",
          "new_text": "descriptors->number_of_descriptors()",
          "old_line_content": "  HeapObject* undefined = heap()->undefined_value();",
          "new_line_content": "    DCHECK(descriptors->number_of_descriptors() == number_of_own_descriptors);",
          "content_same": false
        },
        {
          "line": 2543,
          "old_api": "encountered_transition_arrays",
          "new_api": "set_owns_descriptors",
          "old_text": "heap()->encountered_transition_arrays()",
          "new_text": "map->set_owns_descriptors(true)",
          "old_line_content": "  Object* obj = heap()->encountered_transition_arrays();",
          "new_line_content": "    map->set_owns_descriptors(true);",
          "content_same": false
        },
        {
          "line": 2549,
          "old_api": "GetTarget",
          "new_api": "undefined_value",
          "old_text": "array->GetTarget(0)",
          "new_text": "heap()->undefined_value()",
          "old_line_content": "      Map* map = array->GetTarget(0);",
          "new_line_content": "  HeapObject* undefined = heap()->undefined_value();",
          "content_same": false
        },
        {
          "line": 2550,
          "old_api": "constructor_or_backpointer",
          "new_api": "encountered_transition_arrays",
          "old_text": "map->constructor_or_backpointer()",
          "new_text": "heap()->encountered_transition_arrays()",
          "old_line_content": "      Map* parent = Map::cast(map->constructor_or_backpointer());",
          "new_line_content": "  Object* obj = heap()->encountered_transition_arrays();",
          "content_same": false
        },
        {
          "line": 2552,
          "old_api": "ObjectMarking::MarkBitFrom(parent)",
          "new_api": "TransitionArray::cast(obj)",
          "old_text": "ObjectMarking::MarkBitFrom(parent)",
          "new_text": "TransitionArray::cast(obj)",
          "old_line_content": "          Marking::IsBlackOrGrey(ObjectMarking::MarkBitFrom(parent));",
          "new_line_content": "    TransitionArray* array = TransitionArray::cast(obj);",
          "content_same": false
        },
        {
          "line": 2554,
          "old_api": "instance_descriptors",
          "new_api": "TransitionArray::NumberOfTransitions(array)",
          "old_text": "parent->instance_descriptors()",
          "new_text": "TransitionArray::NumberOfTransitions(array)",
          "old_line_content": "          parent_is_alive ? parent->instance_descriptors() : nullptr;",
          "new_line_content": "    DCHECK_EQ(TransitionArray::NumberOfTransitions(array), num_transitions);",
          "content_same": false
        },
        {
          "line": 2556,
          "old_api": "CompactTransitionArray",
          "new_api": "GetTarget",
          "old_text": "CompactTransitionArray(parent, array, descriptors)",
          "new_text": "array->GetTarget(0)",
          "old_line_content": "          CompactTransitionArray(parent, array, descriptors);",
          "new_line_content": "      Map* map = array->GetTarget(0);",
          "content_same": false
        },
        {
          "line": 2561,
          "old_api": "next_link",
          "new_api": "instance_descriptors",
          "old_text": "array->next_link()",
          "new_text": "parent->instance_descriptors()",
          "old_line_content": "    obj = array->next_link();",
          "new_line_content": "          parent_is_alive ? parent->instance_descriptors() : nullptr;",
          "content_same": false
        },
        {
          "line": 2577,
          "old_api": "ObjectMarking::MarkBitFrom(target)",
          "new_api": "number_of_entries",
          "old_text": "ObjectMarking::MarkBitFrom(target)",
          "new_text": "transitions->number_of_entries()",
          "old_line_content": "    if (Marking::IsWhite(ObjectMarking::MarkBitFrom(target))) {",
          "new_line_content": "  int num_transitions = transitions->number_of_entries();",
          "content_same": false
        },
        {
          "line": 2584,
          "old_api": "GetKey",
          "new_api": "ObjectMarking::MarkBitFrom(target)",
          "old_text": "transitions->GetKey(i)",
          "new_text": "ObjectMarking::MarkBitFrom(target)",
          "old_line_content": "        Name* key = transitions->GetKey(i);",
          "new_line_content": "    if (Marking::IsWhite(ObjectMarking::MarkBitFrom(target))) {",
          "content_same": false
        },
        {
          "line": 2586,
          "old_api": "GetKeySlot",
          "new_api": "instance_descriptors",
          "old_text": "transitions->GetKeySlot(transition_index)",
          "new_text": "target->instance_descriptors()",
          "old_line_content": "        Object** key_slot = transitions->GetKeySlot(transition_index);",
          "new_line_content": "          target->instance_descriptors() == descriptors) {",
          "content_same": false
        },
        {
          "line": 2596,
          "old_api": "DCHECK",
          "new_api": "GetTarget",
          "old_text": "DCHECK(!descriptors_owner_died)",
          "new_text": "transitions->GetTarget(i)",
          "old_line_content": "    DCHECK(!descriptors_owner_died);",
          "new_line_content": "        transitions->SetTarget(transition_index, transitions->GetTarget(i));",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": "TransitionArray::Capacity(transitions)",
          "new_api": "DCHECK",
          "old_text": "TransitionArray::Capacity(transitions)",
          "new_text": "DCHECK(!descriptors_owner_died)",
          "old_line_content": "  int trim = TransitionArray::Capacity(transitions) - transition_index;",
          "new_line_content": "    DCHECK(!descriptors_owner_died);",
          "content_same": false
        },
        {
          "line": 2624,
          "old_api": "heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(\n        descriptors, to_trim * DescriptorArray::kDescriptorSize)",
          "new_api": "empty_descriptor_array",
          "old_text": "heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(\n        descriptors, to_trim * DescriptorArray::kDescriptorSize)",
          "new_text": "heap_->empty_descriptor_array()",
          "old_line_content": "    heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(",
          "new_line_content": "    DCHECK(descriptors == heap_->empty_descriptor_array());",
          "content_same": false
        },
        {
          "line": 2628,
          "old_api": "TrimEnumCache",
          "new_api": "number_of_descriptors_storage",
          "old_text": "TrimEnumCache(map, descriptors)",
          "new_text": "descriptors->number_of_descriptors_storage()",
          "old_line_content": "    if (descriptors->HasEnumCache()) TrimEnumCache(map, descriptors);",
          "new_line_content": "  int number_of_descriptors = descriptors->number_of_descriptors_storage();",
          "content_same": false
        },
        {
          "line": 2633,
          "old_api": "Trim",
          "new_api": "SetNumberOfDescriptors",
          "old_text": "layout_descriptor->Trim(heap_, map, descriptors,\n                                                  number_of_own_descriptors)",
          "new_text": "descriptors->SetNumberOfDescriptors(number_of_own_descriptors)",
          "old_line_content": "      layout_descriptor = layout_descriptor->Trim(heap_, map, descriptors,",
          "new_line_content": "    descriptors->SetNumberOfDescriptors(number_of_own_descriptors);",
          "content_same": false
        },
        {
          "line": 2635,
          "old_api": "IsConsistentWithMap",
          "new_api": "TrimEnumCache",
          "old_text": "layout_descriptor->IsConsistentWithMap(map, true)",
          "new_text": "TrimEnumCache(map, descriptors)",
          "old_line_content": "      SLOW_DCHECK(layout_descriptor->IsConsistentWithMap(map, true));",
          "new_line_content": "    if (descriptors->HasEnumCache()) TrimEnumCache(map, descriptors);",
          "content_same": false
        },
        {
          "line": 2639,
          "old_api": "set_owns_descriptors",
          "new_api": "layout_descriptor",
          "old_text": "map->set_owns_descriptors(true)",
          "new_text": "map->layout_descriptor()",
          "old_line_content": "  map->set_owns_descriptors(true);",
          "new_line_content": "      LayoutDescriptor* layout_descriptor = map->layout_descriptor();",
          "content_same": false
        },
        {
          "line": 2645,
          "old_api": "EnumLength",
          "new_api": "number_of_descriptors",
          "old_text": "map->EnumLength()",
          "new_text": "descriptors->number_of_descriptors()",
          "old_line_content": "  int live_enum = map->EnumLength();",
          "new_line_content": "  DCHECK(descriptors->number_of_descriptors() == number_of_own_descriptors);",
          "content_same": false
        },
        {
          "line": 2652,
          "old_api": "GetEnumCache",
          "new_api": "EnumLength",
          "old_text": "descriptors->GetEnumCache()",
          "new_text": "map->EnumLength()",
          "old_line_content": "  FixedArray* enum_cache = descriptors->GetEnumCache();",
          "new_line_content": "  int live_enum = map->EnumLength();",
          "content_same": false
        },
        {
          "line": 2657,
          "old_api": "GetEnumCache",
          "new_api": "ClearEnumCache",
          "old_text": "descriptors->GetEnumCache()",
          "new_text": "descriptors->ClearEnumCache()",
          "old_line_content": "      descriptors->GetEnumCache(), to_trim);",
          "new_line_content": "  if (live_enum == 0) return descriptors->ClearEnumCache();",
          "content_same": false
        },
        {
          "line": 2659,
          "old_api": "HasEnumIndicesCache",
          "new_api": "GetEnumCache",
          "old_text": "descriptors->HasEnumIndicesCache()",
          "new_text": "descriptors->GetEnumCache()",
          "old_line_content": "  if (!descriptors->HasEnumIndicesCache()) return;",
          "new_line_content": "  FixedArray* enum_cache = descriptors->GetEnumCache();",
          "content_same": false
        },
        {
          "line": 2661,
          "old_api": "heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(enum_indices_cache,\n                                                          to_trim)",
          "new_api": "length",
          "old_text": "heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(enum_indices_cache,\n                                                          to_trim)",
          "new_text": "enum_cache->length()",
          "old_line_content": "  heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(enum_indices_cache,",
          "new_line_content": "  int to_trim = enum_cache->length() - live_enum;",
          "content_same": false
        },
        {
          "line": 2667,
          "old_api": "encountered_weak_collections",
          "new_api": "GetEnumIndicesCache",
          "old_text": "heap()->encountered_weak_collections()",
          "new_text": "descriptors->GetEnumIndicesCache()",
          "old_line_content": "  Object* weak_collection_obj = heap()->encountered_weak_collections();",
          "new_line_content": "  FixedArray* enum_indices_cache = descriptors->GetEnumIndicesCache();",
          "content_same": false
        },
        {
          "line": 2668,
          "old_api": "Smi::FromInt(0)",
          "new_api": "heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(enum_indices_cache,\n                                                          to_trim)",
          "old_text": "Smi::FromInt(0)",
          "new_text": "heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(enum_indices_cache,\n                                                          to_trim)",
          "old_line_content": "  while (weak_collection_obj != Smi::FromInt(0)) {",
          "new_line_content": "  heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(enum_indices_cache,",
          "content_same": false
        },
        {
          "line": 2674,
          "old_api": "Capacity",
          "new_api": "encountered_weak_collections",
          "old_text": "table->Capacity()",
          "new_text": "heap()->encountered_weak_collections()",
          "old_line_content": "      for (int i = 0; i < table->Capacity(); i++) {",
          "new_line_content": "  Object* weak_collection_obj = heap()->encountered_weak_collections();",
          "content_same": false
        },
        {
          "line": 2675,
          "old_api": "KeyAt",
          "new_api": "Smi::FromInt(0)",
          "old_text": "table->KeyAt(i)",
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "        if (MarkCompactCollector::IsMarked(HeapObject::cast(table->KeyAt(i)))) {",
          "new_line_content": "  while (weak_collection_obj != Smi::FromInt(0)) {",
          "content_same": false
        },
        {
          "line": 2677,
          "old_api": "ObjectHashTable::EntryToIndex(i)",
          "new_api": "reinterpret_cast<JSWeakCollection*>(weak_collection_obj)",
          "old_text": "ObjectHashTable::EntryToIndex(i)",
          "new_text": "reinterpret_cast<JSWeakCollection*>(weak_collection_obj)",
          "old_line_content": "              table->RawFieldOfElementAt(ObjectHashTable::EntryToIndex(i));",
          "new_line_content": "        reinterpret_cast<JSWeakCollection*>(weak_collection_obj);",
          "content_same": false
        },
        {
          "line": 2678,
          "old_api": "RecordSlot",
          "new_api": "MarkCompactCollector::IsMarked(weak_collection)",
          "old_text": "RecordSlot(table, key_slot, *key_slot)",
          "new_text": "MarkCompactCollector::IsMarked(weak_collection)",
          "old_line_content": "          RecordSlot(table, key_slot, *key_slot);",
          "new_line_content": "    DCHECK(MarkCompactCollector::IsMarked(weak_collection));",
          "content_same": false
        },
        {
          "line": 2680,
          "old_api": "ObjectHashTable::EntryToValueIndex(i)",
          "new_api": "table",
          "old_text": "ObjectHashTable::EntryToValueIndex(i)",
          "new_text": "weak_collection->table()",
          "old_line_content": "              table->RawFieldOfElementAt(ObjectHashTable::EntryToValueIndex(i));",
          "new_line_content": "      ObjectHashTable* table = ObjectHashTable::cast(weak_collection->table());",
          "content_same": false
        },
        {
          "line": 2681,
          "old_api": "MarkCompactMarkingVisitor::MarkObjectByPointer(this, table,\n                                                         value_slot)",
          "new_api": "Capacity",
          "old_text": "MarkCompactMarkingVisitor::MarkObjectByPointer(this, table,\n                                                         value_slot)",
          "new_text": "table->Capacity()",
          "old_line_content": "          MarkCompactMarkingVisitor::MarkObjectByPointer(this, table,",
          "new_line_content": "      for (int i = 0; i < table->Capacity(); i++) {",
          "content_same": false
        },
        {
          "line": 2693,
          "old_api": "encountered_weak_collections",
          "new_api": "next",
          "old_text": "heap()->encountered_weak_collections()",
          "new_text": "weak_collection->next()",
          "old_line_content": "  Object* weak_collection_obj = heap()->encountered_weak_collections();",
          "new_line_content": "    weak_collection_obj = weak_collection->next();",
          "content_same": false
        },
        {
          "line": 2699,
          "old_api": "table",
          "new_api": "tracer",
          "old_text": "weak_collection->table()",
          "new_text": "heap()->tracer()",
          "old_line_content": "      ObjectHashTable* table = ObjectHashTable::cast(weak_collection->table());",
          "new_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_CLEAR_WEAK_COLLECTIONS);",
          "content_same": false
        },
        {
          "line": 2700,
          "old_api": "Capacity",
          "new_api": "encountered_weak_collections",
          "old_text": "table->Capacity()",
          "new_text": "heap()->encountered_weak_collections()",
          "old_line_content": "      for (int i = 0; i < table->Capacity(); i++) {",
          "new_line_content": "  Object* weak_collection_obj = heap()->encountered_weak_collections();",
          "content_same": false
        },
        {
          "line": 2701,
          "old_api": "KeyAt",
          "new_api": "Smi::FromInt(0)",
          "old_text": "table->KeyAt(i)",
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "        HeapObject* key = HeapObject::cast(table->KeyAt(i));",
          "new_line_content": "  while (weak_collection_obj != Smi::FromInt(0)) {",
          "content_same": false
        },
        {
          "line": 2703,
          "old_api": "RemoveEntry",
          "new_api": "reinterpret_cast<JSWeakCollection*>(weak_collection_obj)",
          "old_text": "table->RemoveEntry(i)",
          "new_text": "reinterpret_cast<JSWeakCollection*>(weak_collection_obj)",
          "old_line_content": "          table->RemoveEntry(i);",
          "new_line_content": "        reinterpret_cast<JSWeakCollection*>(weak_collection_obj);",
          "content_same": false
        },
        {
          "line": 2707,
          "old_api": "next",
          "new_api": "Capacity",
          "old_text": "weak_collection->next()",
          "new_text": "table->Capacity()",
          "old_line_content": "    weak_collection_obj = weak_collection->next();",
          "new_line_content": "      for (int i = 0; i < table->Capacity(); i++) {",
          "content_same": false
        },
        {
          "line": 2708,
          "old_api": "undefined_value",
          "new_api": "KeyAt",
          "old_text": "heap()->undefined_value()",
          "new_text": "table->KeyAt(i)",
          "old_line_content": "    weak_collection->set_next(heap()->undefined_value());",
          "new_line_content": "        HeapObject* key = HeapObject::cast(table->KeyAt(i));",
          "content_same": false
        },
        {
          "line": 2710,
          "old_api": "Smi::FromInt(0)",
          "new_api": "RemoveEntry",
          "old_text": "Smi::FromInt(0)",
          "new_text": "table->RemoveEntry(i)",
          "old_line_content": "  heap()->set_encountered_weak_collections(Smi::FromInt(0));",
          "new_line_content": "          table->RemoveEntry(i);",
          "content_same": false
        },
        {
          "line": 2715,
          "old_api": "encountered_weak_collections",
          "new_api": "undefined_value",
          "old_text": "heap()->encountered_weak_collections()",
          "new_text": "heap()->undefined_value()",
          "old_line_content": "  Object* weak_collection_obj = heap()->encountered_weak_collections();",
          "new_line_content": "    weak_collection->set_next(heap()->undefined_value());",
          "content_same": false
        },
        {
          "line": 2722,
          "old_api": "Smi::FromInt(0)",
          "new_api": "encountered_weak_collections",
          "old_text": "Smi::FromInt(0)",
          "new_text": "heap()->encountered_weak_collections()",
          "old_line_content": "  heap()->set_encountered_weak_collections(Smi::FromInt(0));",
          "new_line_content": "  Object* weak_collection_obj = heap()->encountered_weak_collections();",
          "content_same": false
        },
        {
          "line": 2729,
          "old_api": "tracer",
          "new_api": "Smi::FromInt(0)",
          "old_text": "heap->tracer()",
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "  TRACE_GC(heap->tracer(), GCTracer::Scope::MC_CLEAR_WEAK_CELLS);",
          "new_line_content": "  heap()->set_encountered_weak_collections(Smi::FromInt(0));",
          "content_same": false
        },
        {
          "line": 2735,
          "old_api": "Smi::FromInt(0)",
          "new_api": "heap",
          "old_text": "Smi::FromInt(0)",
          "new_text": "this->heap()",
          "old_line_content": "  while (weak_cell_obj != Smi::FromInt(0)) {",
          "new_line_content": "  Heap* heap = this->heap();",
          "content_same": false
        },
        {
          "line": 2736,
          "old_api": "reinterpret_cast<WeakCell*>(weak_cell_obj)",
          "new_api": "tracer",
          "old_text": "reinterpret_cast<WeakCell*>(weak_cell_obj)",
          "new_text": "heap->tracer()",
          "old_line_content": "    WeakCell* weak_cell = reinterpret_cast<WeakCell*>(weak_cell_obj);",
          "new_line_content": "  TRACE_GC(heap->tracer(), GCTracer::Scope::MC_CLEAR_WEAK_CELLS);",
          "content_same": false
        },
        {
          "line": 2737,
          "old_api": "next",
          "new_api": "encountered_weak_cells",
          "old_text": "weak_cell->next()",
          "new_text": "heap->encountered_weak_cells()",
          "old_line_content": "    Object* next_weak_cell = weak_cell->next();",
          "new_line_content": "  Object* weak_cell_obj = heap->encountered_weak_cells();",
          "content_same": false
        },
        {
          "line": 2742,
          "old_api": "value",
          "new_api": "Smi::FromInt(0)",
          "old_text": "weak_cell->value()",
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "    HeapObject* value = HeapObject::cast(weak_cell->value());",
          "new_line_content": "  while (weak_cell_obj != Smi::FromInt(0)) {",
          "content_same": false
        },
        {
          "line": 2743,
          "old_api": "MarkCompactCollector::IsMarked(value)",
          "new_api": "reinterpret_cast<WeakCell*>(weak_cell_obj)",
          "old_text": "MarkCompactCollector::IsMarked(value)",
          "new_text": "reinterpret_cast<WeakCell*>(weak_cell_obj)",
          "old_line_content": "    if (!MarkCompactCollector::IsMarked(value)) {",
          "new_line_content": "    WeakCell* weak_cell = reinterpret_cast<WeakCell*>(weak_cell_obj);",
          "content_same": false
        },
        {
          "line": 2749,
          "old_api": "IsCell",
          "new_api": "value",
          "old_text": "value->IsCell()",
          "new_text": "weak_cell->value()",
          "old_line_content": "      if (value->IsCell()) {",
          "new_line_content": "    HeapObject* value = HeapObject::cast(weak_cell->value());",
          "content_same": false
        },
        {
          "line": 2750,
          "old_api": "value",
          "new_api": "MarkCompactCollector::IsMarked(value)",
          "old_text": "Cell::cast(value)->value()",
          "new_text": "MarkCompactCollector::IsMarked(value)",
          "old_line_content": "        Object* cell_value = Cell::cast(value)->value();",
          "new_line_content": "    if (!MarkCompactCollector::IsMarked(value)) {",
          "content_same": false
        },
        {
          "line": 2756,
          "old_api": "HeapObject::RawField(value, Cell::kValueOffset)",
          "new_api": "IsCell",
          "old_text": "HeapObject::RawField(value, Cell::kValueOffset)",
          "new_text": "value->IsCell()",
          "old_line_content": "          Object** slot = HeapObject::RawField(value, Cell::kValueOffset);",
          "new_line_content": "      if (value->IsCell()) {",
          "content_same": false
        },
        {
          "line": 2757,
          "old_api": "RecordSlot",
          "new_api": "value",
          "old_text": "RecordSlot(value, slot, *slot)",
          "new_text": "Cell::cast(value)->value()",
          "old_line_content": "          RecordSlot(value, slot, *slot);",
          "new_line_content": "        Object* cell_value = Cell::cast(value)->value();",
          "content_same": false
        },
        {
          "line": 2758,
          "old_api": "HeapObject::RawField(weak_cell, WeakCell::kValueOffset)",
          "new_api": "IsHeapObject",
          "old_text": "HeapObject::RawField(weak_cell, WeakCell::kValueOffset)",
          "new_text": "cell_value->IsHeapObject()",
          "old_line_content": "          slot = HeapObject::RawField(weak_cell, WeakCell::kValueOffset);",
          "new_line_content": "        if (cell_value->IsHeapObject() &&",
          "content_same": false
        },
        {
          "line": 2759,
          "old_api": "RecordSlot",
          "new_api": "HeapObject::cast(cell_value)",
          "old_text": "RecordSlot(weak_cell, slot, *slot)",
          "new_text": "HeapObject::cast(cell_value)",
          "old_line_content": "          RecordSlot(weak_cell, slot, *slot);",
          "new_line_content": "            MarkCompactCollector::IsMarked(HeapObject::cast(cell_value))) {",
          "content_same": false
        },
        {
          "line": 2763,
          "old_api": "IsMap",
          "new_api": "HeapObject::RawField(value, Cell::kValueOffset)",
          "old_text": "value->IsMap()",
          "new_text": "HeapObject::RawField(value, Cell::kValueOffset)",
          "old_line_content": "      if (value->IsMap()) {",
          "new_line_content": "          Object** slot = HeapObject::RawField(value, Cell::kValueOffset);",
          "content_same": false
        },
        {
          "line": 2765,
          "old_api": "Map::cast(value)",
          "new_api": "HeapObject::RawField(weak_cell, WeakCell::kValueOffset)",
          "old_text": "Map::cast(value)",
          "new_text": "HeapObject::RawField(weak_cell, WeakCell::kValueOffset)",
          "old_line_content": "        Map* map = Map::cast(value);",
          "new_line_content": "          slot = HeapObject::RawField(weak_cell, WeakCell::kValueOffset);",
          "content_same": false
        },
        {
          "line": 2770,
          "old_api": "length",
          "new_api": "IsMap",
          "old_text": "candidate->length()",
          "new_text": "value->IsMap()",
          "old_line_content": "        if (candidate->length() > 0 &&",
          "new_line_content": "      if (value->IsMap()) {",
          "content_same": false
        },
        {
          "line": 2772,
          "old_api": "set_next_link",
          "new_api": "Map::cast(value)",
          "old_text": "candidate->set_next_link(dependent_code_head)",
          "new_text": "Map::cast(value)",
          "old_line_content": "          candidate->set_next_link(dependent_code_head);",
          "new_line_content": "        Map* map = Map::cast(value);",
          "content_same": false
        },
        {
          "line": 2776,
          "old_api": "set_next",
          "new_api": "STATIC_ASSERT",
          "old_text": "weak_cell->set_next(non_live_map_head)",
          "new_text": "STATIC_ASSERT(DependentCode::kWeakCodeGroup == 0)",
          "old_line_content": "        weak_cell->set_next(non_live_map_head);",
          "new_line_content": "        STATIC_ASSERT(DependentCode::kWeakCodeGroup == 0);",
          "content_same": false
        },
        {
          "line": 2783,
          "old_api": "HeapObject::RawField(weak_cell, WeakCell::kValueOffset)",
          "new_api": "set_next",
          "old_text": "HeapObject::RawField(weak_cell, WeakCell::kValueOffset)",
          "new_text": "weak_cell->set_next(non_live_map_head)",
          "old_line_content": "      Object** slot = HeapObject::RawField(weak_cell, WeakCell::kValueOffset);",
          "new_line_content": "        weak_cell->set_next(non_live_map_head);",
          "content_same": false
        },
        {
          "line": 2791,
          "old_api": "clear_next",
          "new_api": "RecordSlot",
          "old_text": "weak_cell->clear_next(the_hole_value)",
          "new_text": "RecordSlot(weak_cell, slot, *slot)",
          "old_line_content": "      weak_cell->clear_next(the_hole_value);",
          "new_line_content": "      RecordSlot(weak_cell, slot, *slot);",
          "content_same": false
        },
        {
          "line": 2795,
          "old_api": "Smi::FromInt(0)",
          "new_api": "clear",
          "old_text": "Smi::FromInt(0)",
          "new_text": "weak_cell->clear()",
          "old_line_content": "  heap->set_encountered_weak_cells(Smi::FromInt(0));",
          "new_line_content": "      weak_cell->clear();",
          "content_same": false
        },
        {
          "line": 2802,
          "old_api": "the_hole_value",
          "new_api": "Smi::FromInt(0)",
          "old_text": "heap()->the_hole_value()",
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "  Object* the_hole_value = heap()->the_hole_value();",
          "new_line_content": "  heap->set_encountered_weak_cells(Smi::FromInt(0));",
          "content_same": false
        },
        {
          "line": 2809,
          "old_api": "Smi::FromInt(0)",
          "new_api": "the_hole_value",
          "old_text": "Smi::FromInt(0)",
          "new_text": "heap()->the_hole_value()",
          "old_line_content": "  heap()->set_encountered_weak_cells(Smi::FromInt(0));",
          "new_line_content": "  Object* the_hole_value = heap()->the_hole_value();",
          "content_same": false
        },
        {
          "line": 2814,
          "old_api": "undefined_value",
          "new_api": "clear_next",
          "old_text": "heap()->undefined_value()",
          "new_text": "weak_cell->clear_next(the_hole_value)",
          "old_line_content": "  HeapObject* undefined = heap()->undefined_value();",
          "new_line_content": "    weak_cell->clear_next(the_hole_value);",
          "content_same": false
        },
        {
          "line": 2821,
          "old_api": "Smi::FromInt(0)",
          "new_api": "undefined_value",
          "old_text": "Smi::FromInt(0)",
          "new_text": "heap()->undefined_value()",
          "old_line_content": "  heap()->set_encountered_transition_arrays(Smi::FromInt(0));",
          "new_line_content": "  HeapObject* undefined = heap()->undefined_value();",
          "content_same": false
        },
        {
          "line": 2826,
          "old_api": "reinterpret_cast<Address>(target)",
          "new_api": "set_next_link",
          "old_text": "reinterpret_cast<Address>(target)",
          "new_text": "array->set_next_link(undefined, SKIP_WRITE_BARRIER)",
          "old_line_content": "  Page* target_page = Page::FromAddress(reinterpret_cast<Address>(target));",
          "new_line_content": "    array->set_next_link(undefined, SKIP_WRITE_BARRIER);",
          "content_same": false
        },
        {
          "line": 2828,
          "old_api": "IsEvacuationCandidate",
          "new_api": "Smi::FromInt(0)",
          "old_text": "target_page->IsEvacuationCandidate()",
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "  if (target_page->IsEvacuationCandidate() &&",
          "new_line_content": "  heap()->set_encountered_transition_arrays(Smi::FromInt(0));",
          "content_same": false
        },
        {
          "line": 2833,
          "old_api": "SlotTypeForRelocInfoMode",
          "new_api": "reinterpret_cast<Address>(target)",
          "old_text": "SlotTypeForRelocInfoMode(rmode)",
          "new_text": "reinterpret_cast<Address>(target)",
          "old_line_content": "    SlotType slot_type = SlotTypeForRelocInfoMode(rmode);",
          "new_line_content": "  Page* target_page = Page::FromAddress(reinterpret_cast<Address>(target));",
          "content_same": false
        },
        {
          "line": 2834,
          "old_api": "IsInConstantPool",
          "new_api": "reinterpret_cast<Address>(host)",
          "old_text": "rinfo->IsInConstantPool()",
          "new_text": "reinterpret_cast<Address>(host)",
          "old_line_content": "    if (rinfo->IsInConstantPool()) {",
          "new_line_content": "  Page* source_page = Page::FromAddress(reinterpret_cast<Address>(host));",
          "content_same": false
        },
        {
          "line": 2835,
          "old_api": "constant_pool_entry_address",
          "new_api": "IsEvacuationCandidate",
          "old_text": "rinfo->constant_pool_entry_address()",
          "new_text": "target_page->IsEvacuationCandidate()",
          "old_line_content": "      addr = rinfo->constant_pool_entry_address();",
          "new_line_content": "  if (target_page->IsEvacuationCandidate() &&",
          "content_same": false
        },
        {
          "line": 2836,
          "old_api": "RelocInfo::IsCodeTarget(rmode)",
          "new_api": "host",
          "old_text": "RelocInfo::IsCodeTarget(rmode)",
          "new_text": "rinfo->host()",
          "old_line_content": "      if (RelocInfo::IsCodeTarget(rmode)) {",
          "new_line_content": "      (rinfo->host() == NULL ||",
          "content_same": false
        },
        {
          "line": 2839,
          "old_api": "RelocInfo::IsEmbeddedObject(rmode)",
          "new_api": "pc",
          "old_text": "RelocInfo::IsEmbeddedObject(rmode)",
          "new_text": "rinfo->pc()",
          "old_line_content": "        DCHECK(RelocInfo::IsEmbeddedObject(rmode));",
          "new_line_content": "    Address addr = rinfo->pc();",
          "content_same": false
        },
        {
          "line": 2843,
          "old_api": "RememberedSet<OLD_TO_OLD>::InsertTyped(\n        source_page, reinterpret_cast<Address>(host), slot_type, addr)",
          "new_api": "RelocInfo::IsCodeTarget(rmode)",
          "old_text": "RememberedSet<OLD_TO_OLD>::InsertTyped(\n        source_page, reinterpret_cast<Address>(host), slot_type, addr)",
          "new_text": "RelocInfo::IsCodeTarget(rmode)",
          "old_line_content": "    RememberedSet<OLD_TO_OLD>::InsertTyped(",
          "new_line_content": "      if (RelocInfo::IsCodeTarget(rmode)) {",
          "content_same": false
        },
        {
          "line": 2850,
          "old_api": "reinterpret_cast<base::AtomicWord*>(slot)",
          "new_api": "RememberedSet<OLD_TO_OLD>::InsertTyped(\n        source_page, reinterpret_cast<Address>(host), slot_type, addr)",
          "old_text": "reinterpret_cast<base::AtomicWord*>(slot)",
          "new_text": "RememberedSet<OLD_TO_OLD>::InsertTyped(\n        source_page, reinterpret_cast<Address>(host), slot_type, addr)",
          "old_line_content": "      base::NoBarrier_Load(reinterpret_cast<base::AtomicWord*>(slot)));",
          "new_line_content": "    RememberedSet<OLD_TO_OLD>::InsertTyped(",
          "content_same": false
        },
        {
          "line": 2856,
          "old_api": "GetHeap",
          "new_api": "reinterpret_cast<Object*>(\n      base::NoBarrier_Load(reinterpret_cast<base::AtomicWord*>(slot)))",
          "old_text": "heap_obj->GetHeap()->InFromSpace(heap_obj)",
          "new_text": "reinterpret_cast<Object*>(\n      base::NoBarrier_Load(reinterpret_cast<base::AtomicWord*>(slot)))",
          "old_line_content": "      DCHECK(heap_obj->GetHeap()->InFromSpace(heap_obj) ||",
          "new_line_content": "  Object* obj = reinterpret_cast<Object*>(",
          "content_same": false
        },
        {
          "line": 2857,
          "old_api": "MarkCompactCollector::IsOnEvacuationCandidate(heap_obj)",
          "new_api": "reinterpret_cast<base::AtomicWord*>(slot)",
          "old_text": "MarkCompactCollector::IsOnEvacuationCandidate(heap_obj)",
          "new_text": "reinterpret_cast<base::AtomicWord*>(slot)",
          "old_line_content": "             MarkCompactCollector::IsOnEvacuationCandidate(heap_obj) ||",
          "new_line_content": "      base::NoBarrier_Load(reinterpret_cast<base::AtomicWord*>(slot)));",
          "content_same": false
        },
        {
          "line": 2860,
          "old_api": "ToForwardingAddress",
          "new_api": "HeapObject::cast(obj)",
          "old_text": "map_word.ToForwardingAddress()",
          "new_text": "HeapObject::cast(obj)",
          "old_line_content": "      HeapObject* target = map_word.ToForwardingAddress();",
          "new_line_content": "    HeapObject* heap_obj = HeapObject::cast(obj);",
          "content_same": false
        },
        {
          "line": 2861,
          "old_api": "base::NoBarrier_CompareAndSwap(\n          reinterpret_cast<base::AtomicWord*>(slot),\n          reinterpret_cast<base::AtomicWord>(obj),\n          reinterpret_cast<base::AtomicWord>(target))",
          "new_api": "map_word",
          "old_text": "base::NoBarrier_CompareAndSwap(\n          reinterpret_cast<base::AtomicWord*>(slot),\n          reinterpret_cast<base::AtomicWord>(obj),\n          reinterpret_cast<base::AtomicWord>(target))",
          "new_text": "heap_obj->map_word()",
          "old_line_content": "      base::NoBarrier_CompareAndSwap(",
          "new_line_content": "    MapWord map_word = heap_obj->map_word();",
          "content_same": false
        },
        {
          "line": 2862,
          "old_api": "reinterpret_cast<base::AtomicWord*>(slot)",
          "new_api": "IsForwardingAddress",
          "old_text": "reinterpret_cast<base::AtomicWord*>(slot)",
          "new_text": "map_word.IsForwardingAddress()",
          "old_line_content": "          reinterpret_cast<base::AtomicWord*>(slot),",
          "new_line_content": "    if (map_word.IsForwardingAddress()) {",
          "content_same": false
        },
        {
          "line": 2863,
          "old_api": "reinterpret_cast<base::AtomicWord>(obj)",
          "new_api": "GetHeap",
          "old_text": "reinterpret_cast<base::AtomicWord>(obj)",
          "new_text": "heap_obj->GetHeap()->InFromSpace(heap_obj)",
          "old_line_content": "          reinterpret_cast<base::AtomicWord>(obj),",
          "new_line_content": "      DCHECK(heap_obj->GetHeap()->InFromSpace(heap_obj) ||",
          "content_same": false
        },
        {
          "line": 2864,
          "old_api": "reinterpret_cast<base::AtomicWord>(target)",
          "new_api": "MarkCompactCollector::IsOnEvacuationCandidate(heap_obj)",
          "old_text": "reinterpret_cast<base::AtomicWord>(target)",
          "new_text": "MarkCompactCollector::IsOnEvacuationCandidate(heap_obj)",
          "old_line_content": "          reinterpret_cast<base::AtomicWord>(target));",
          "new_line_content": "             MarkCompactCollector::IsOnEvacuationCandidate(heap_obj) ||",
          "content_same": false
        },
        {
          "line": 2865,
          "old_api": "GetHeap",
          "new_api": "address",
          "old_text": "heap_obj->GetHeap()->InFromSpace(target)",
          "new_text": "heap_obj->address()",
          "old_line_content": "      DCHECK(!heap_obj->GetHeap()->InFromSpace(target) &&",
          "new_line_content": "             Page::FromAddress(heap_obj->address())",
          "content_same": false
        },
        {
          "line": 2883,
          "old_api": "UpdateTypedSlotHelper::UpdateCell(rinfo, UpdateSlot)",
          "new_api": "UpdateSlot",
          "old_text": "UpdateTypedSlotHelper::UpdateCell(rinfo, UpdateSlot)",
          "new_text": "UpdateSlot(p)",
          "old_line_content": "    UpdateTypedSlotHelper::UpdateCell(rinfo, UpdateSlot);",
          "new_line_content": "  void VisitPointer(Object** p) override { UpdateSlot(p); }",
          "content_same": false
        },
        {
          "line": 2915,
          "old_api": "owner",
          "new_api": "ToForwardingAddress",
          "old_text": "p->owner()",
          "new_text": "map_word.ToForwardingAddress()",
          "old_line_content": "  Space* owner = p->owner();",
          "new_line_content": "    return String::cast(map_word.ToForwardingAddress());",
          "content_same": false
        },
        {
          "line": 2924,
          "old_api": "AddressToMarkbitIndex",
          "new_api": "USE",
          "old_text": "p->AddressToMarkbitIndex(slot)",
          "new_text": "USE(owner)",
          "old_line_content": "  uint32_t mark_bit_index = p->AddressToMarkbitIndex(slot);",
          "new_line_content": "  USE(owner);",
          "content_same": false
        },
        {
          "line": 2927,
          "old_api": "markbits",
          "new_api": "ObjectMarking::MarkBitFrom(slot)",
          "old_text": "p->markbits()->cells()",
          "new_text": "ObjectMarking::MarkBitFrom(slot)",
          "old_line_content": "  MarkBit::CellType* cells = p->markbits()->cells();",
          "new_line_content": "  if (Marking::IsBlackOrGrey(ObjectMarking::MarkBitFrom(slot))) {",
          "content_same": false
        },
        {
          "line": 2987,
          "old_api": "HeapObject::FromAddress(address)",
          "new_api": "base::bits::CountLeadingZeros32(current_cell & slot_mask)",
          "old_text": "HeapObject::FromAddress(address)",
          "new_text": "base::bits::CountLeadingZeros32(current_cell & slot_mask)",
          "old_line_content": "  HeapObject* object = HeapObject::FromAddress(address);",
          "new_line_content": "      base::bits::CountLeadingZeros32(current_cell & slot_mask);",
          "content_same": false
        },
        {
          "line": 2988,
          "old_api": "ObjectMarking::MarkBitFrom(object)",
          "new_api": "CHECK",
          "old_text": "ObjectMarking::MarkBitFrom(object)",
          "new_text": "CHECK(leading_zeros != Bitmap::kBitsPerCell)",
          "old_line_content": "  CHECK(Marking::IsBlack(ObjectMarking::MarkBitFrom(object)));",
          "new_line_content": "  CHECK(leading_zeros != Bitmap::kBitsPerCell);",
          "content_same": false
        },
        {
          "line": 2989,
          "old_api": "reinterpret_cast<Address>(slot)",
          "new_api": "static_cast<int>(Bitmap::kBitIndexMask - leading_zeros)",
          "old_text": "reinterpret_cast<Address>(slot)",
          "new_text": "static_cast<int>(Bitmap::kBitIndexMask - leading_zeros)",
          "old_line_content": "  CHECK(object->address() < reinterpret_cast<Address>(slot));",
          "new_line_content": "  int offset = static_cast<int>(Bitmap::kBitIndexMask - leading_zeros) - 1;",
          "content_same": false
        },
        {
          "line": 3009,
          "old_api": "HeapObject::cast(large_object)",
          "new_api": "Page::FromAddress(slot)",
          "old_text": "HeapObject::cast(large_object)",
          "new_text": "Page::FromAddress(slot)",
          "old_line_content": "    HeapObject* large_heap_object = HeapObject::cast(large_object);",
          "new_line_content": "  Page* p = Page::FromAddress(slot);",
          "content_same": false
        },
        {
          "line": 3011,
          "old_api": "IsMarked",
          "new_api": "lo_space",
          "old_text": "IsMarked(large_heap_object)",
          "new_text": "heap_->lo_space()",
          "old_line_content": "    if (IsMarked(large_heap_object)) {",
          "new_line_content": "  if (owner == heap_->lo_space() || owner == nullptr) {",
          "content_same": false
        },
        {
          "line": 3076,
          "old_api": "heap",
          "new_api": "explicit",
          "old_text": "collector->heap()",
          "new_text": "explicit",
          "old_line_content": "        new_space_page_visitor(collector->heap()),",
          "new_line_content": "  explicit Evacuator(MarkCompactCollector* collector)",
          "content_same": false
        },
        {
          "line": 3124,
          "old_api": "ComputeEvacuationMode",
          "new_api": "SweepingDone",
          "old_text": "ComputeEvacuationMode(page)",
          "new_text": "page->SweepingDone()",
          "old_line_content": "    switch (ComputeEvacuationMode(page)) {",
          "new_line_content": "  DCHECK(page->SweepingDone());",
          "content_same": false
        },
        {
          "line": 3151,
          "old_api": "SetFlag",
          "new_api": "VisitLiveObjects",
          "old_text": "page->SetFlag(Page::COMPACTION_WAS_ABORTED)",
          "new_text": "collector_->VisitLiveObjects(page, &old_space_visitor_,\n                                               kClearMarkbits)",
          "old_line_content": "          page->SetFlag(Page::COMPACTION_WAS_ABORTED);",
          "new_line_content": "        success = collector_->VisitLiveObjects(page, &old_space_visitor_,",
          "content_same": false
        },
        {
          "line": 3162,
          "old_api": "ArrayBufferTracker::ProcessBuffers(\n              page, ArrayBufferTracker::kUpdateForwardedRemoveOthers)",
          "new_api": "ArrayBufferTracker::ProcessBuffers(\n              page, ArrayBufferTracker::kUpdateForwardedKeepOthers)",
          "old_text": "ArrayBufferTracker::ProcessBuffers(\n              page, ArrayBufferTracker::kUpdateForwardedRemoveOthers)",
          "new_text": "ArrayBufferTracker::ProcessBuffers(\n              page, ArrayBufferTracker::kUpdateForwardedKeepOthers)",
          "old_line_content": null,
          "new_line_content": "          ArrayBufferTracker::ProcessBuffers(",
          "content_same": true
        },
        {
          "line": 3177,
          "old_api": "InNewSpace",
          "new_api": "ReportCompactionProgress",
          "old_text": "page->InNewSpace()",
          "new_text": "ReportCompactionProgress(evacuation_time, saved_live_bytes)",
          "old_line_content": "                 page->InNewSpace(),",
          "new_line_content": "  ReportCompactionProgress(evacuation_time, saved_live_bytes);",
          "content_same": false
        },
        {
          "line": 3179,
          "old_api": "IsFlagSet",
          "new_api": "isolate",
          "old_text": "page->IsFlagSet(Page::PAGE_NEW_NEW_PROMOTION)",
          "new_text": "heap->isolate()",
          "old_line_content": "                     page->IsFlagSet(Page::PAGE_NEW_NEW_PROMOTION),",
          "new_line_content": "    PrintIsolate(heap->isolate(),",
          "content_same": false
        },
        {
          "line": 3188,
          "old_api": "Get",
          "new_api": "new_space",
          "old_text": "compaction_spaces_.Get(OLD_SPACE)",
          "new_text": "heap->new_space()->age_mark()",
          "old_line_content": "  heap()->old_space()->MergeCompactionSpace(compaction_spaces_.Get(OLD_SPACE));",
          "new_line_content": "                 page->Contains(heap->new_space()->age_mark()),",
          "content_same": false
        },
        {
          "line": 3195,
          "old_api": "semispace_copied_size",
          "new_api": "Get",
          "old_text": "new_space_visitor_.semispace_copied_size()",
          "new_text": "compaction_spaces_.Get(OLD_SPACE)",
          "old_line_content": "      new_space_visitor_.semispace_copied_size() +",
          "new_line_content": "  heap()->old_space()->MergeCompactionSpace(compaction_spaces_.Get(OLD_SPACE));",
          "content_same": false
        },
        {
          "line": 3196,
          "old_api": "semispace_copied_size",
          "new_api": "Get",
          "old_text": "new_space_page_visitor.semispace_copied_size()",
          "new_text": "heap()->code_space()->MergeCompactionSpace(\n      compaction_spaces_.Get(CODE_SPACE))",
          "old_line_content": "      new_space_page_visitor.semispace_copied_size());",
          "new_line_content": "  heap()->code_space()->MergeCompactionSpace(",
          "content_same": false
        },
        {
          "line": 3197,
          "old_api": "promoted_size",
          "new_api": "Get",
          "old_text": "heap()->IncrementYoungSurvivorsCounter(\n      new_space_visitor_.promoted_size() +\n      new_space_visitor_.semispace_copied_size() +\n      new_space_page_visitor.promoted_size() +\n      new_space_page_visitor.semispace_copied_size())",
          "new_text": "compaction_spaces_.Get(CODE_SPACE)",
          "old_line_content": "  heap()->IncrementYoungSurvivorsCounter(",
          "new_line_content": "      compaction_spaces_.Get(CODE_SPACE));",
          "content_same": false
        },
        {
          "line": 3198,
          "old_api": "promoted_size",
          "new_api": "tracer",
          "old_text": "new_space_visitor_.promoted_size()",
          "new_text": "heap()->tracer()->AddCompactionEvent(duration_, bytes_compacted_)",
          "old_line_content": "      new_space_visitor_.promoted_size() +",
          "new_line_content": "  heap()->tracer()->AddCompactionEvent(duration_, bytes_compacted_);",
          "content_same": false
        },
        {
          "line": 3199,
          "old_api": "semispace_copied_size",
          "new_api": "promoted_size",
          "old_text": "new_space_visitor_.semispace_copied_size()",
          "new_text": "new_space_visitor_.promoted_size()",
          "old_line_content": "      new_space_visitor_.semispace_copied_size() +",
          "new_line_content": "  heap()->IncrementPromotedObjectsSize(new_space_visitor_.promoted_size() +",
          "content_same": false
        },
        {
          "line": 3202,
          "old_api": "MergeAllocationSitePretenuringFeedback",
          "new_api": "semispace_copied_size",
          "old_text": "heap()->MergeAllocationSitePretenuringFeedback(local_pretenuring_feedback_)",
          "new_text": "new_space_visitor_.semispace_copied_size()",
          "old_line_content": "  heap()->MergeAllocationSitePretenuringFeedback(local_pretenuring_feedback_);",
          "new_line_content": "      new_space_visitor_.semispace_copied_size() +",
          "content_same": false
        },
        {
          "line": 3251,
          "old_api": "Evacuator::ComputeEvacuationMode(p)",
          "new_api": "reinterpret_cast<Page*>(chunk)",
          "old_text": "Evacuator::ComputeEvacuationMode(p)",
          "new_text": "reinterpret_cast<Page*>(chunk)",
          "old_line_content": "    switch (Evacuator::ComputeEvacuationMode(p)) {",
          "new_line_content": "    return evacuator->EvacuatePage(reinterpret_cast<Page*>(chunk));",
          "content_same": false
        },
        {
          "line": 3258,
          "old_api": "DCHECK",
          "new_api": "Evacuator::ComputeEvacuationMode(p)",
          "old_text": "DCHECK(success)",
          "new_text": "Evacuator::ComputeEvacuationMode(p)",
          "old_line_content": "        DCHECK(success);",
          "new_line_content": "    switch (Evacuator::ComputeEvacuationMode(p)) {",
          "content_same": false
        },
        {
          "line": 3262,
          "old_api": "IsEvacuationCandidate",
          "new_api": "DCHECK",
          "old_text": "p->IsEvacuationCandidate()",
          "new_text": "DCHECK(success)",
          "old_line_content": "          DCHECK(p->IsEvacuationCandidate());",
          "new_line_content": "        DCHECK(success);",
          "content_same": false
        },
        {
          "line": 3275,
          "old_api": "UNREACHABLE",
          "new_api": "ClearEvacuationCandidate",
          "old_text": "UNREACHABLE()",
          "new_text": "p->ClearEvacuationCandidate()",
          "old_line_content": "        UNREACHABLE();",
          "new_line_content": "          p->ClearEvacuationCandidate();",
          "content_same": false
        },
        {
          "line": 3282,
          "old_api": "isolate",
          "new_api": "UNREACHABLE",
          "old_text": "heap_->isolate()->cancelable_task_manager()",
          "new_text": "UNREACHABLE()",
          "old_line_content": "      heap_, heap_->isolate()->cancelable_task_manager(),",
          "new_line_content": "        UNREACHABLE();",
          "content_same": false
        },
        {
          "line": 3289,
          "old_api": "AddPage",
          "new_api": "isolate",
          "old_text": "job.AddPage(page, &abandoned_pages)",
          "new_text": "heap_->isolate()->cancelable_task_manager()",
          "old_line_content": "    job.AddPage(page, &abandoned_pages);",
          "new_line_content": "      heap_, heap_->isolate()->cancelable_task_manager(),",
          "content_same": false
        },
        {
          "line": 3295,
          "old_api": "NeverEvacuate",
          "new_api": "LiveBytes",
          "old_text": "page->NeverEvacuate()",
          "new_text": "page->LiveBytes()",
          "old_line_content": "    if (!page->NeverEvacuate() &&",
          "new_line_content": "    live_bytes += page->LiveBytes();",
          "content_same": false
        },
        {
          "line": 3296,
          "old_api": "Evacuator::PageEvacuationThreshold()",
          "new_api": "AddPage",
          "old_text": "Evacuator::PageEvacuationThreshold()",
          "new_text": "job.AddPage(page, &abandoned_pages)",
          "old_line_content": "        (page->LiveBytes() > Evacuator::PageEvacuationThreshold()) &&",
          "new_line_content": "    job.AddPage(page, &abandoned_pages);",
          "content_same": false
        },
        {
          "line": 3299,
          "old_api": "old_space",
          "new_api": "new_space",
          "old_text": "heap()->old_space()",
          "new_text": "heap()->new_space()->age_mark()",
          "old_line_content": "        EvacuateNewSpacePageVisitor::MoveToOldSpace(page, heap()->old_space());",
          "new_line_content": "  const Address age_mark = heap()->new_space()->age_mark();",
          "content_same": false
        },
        {
          "line": 3301,
          "old_api": "EvacuateNewSpacePageVisitor::MoveToToSpace(page)",
          "new_api": "LiveBytes",
          "old_text": "EvacuateNewSpacePageVisitor::MoveToToSpace(page)",
          "new_text": "page->LiveBytes()",
          "old_line_content": "        EvacuateNewSpacePageVisitor::MoveToToSpace(page);",
          "new_line_content": "    live_bytes += page->LiveBytes();",
          "content_same": false
        },
        {
          "line": 3305,
          "old_api": "AddPage",
          "new_api": "IsFlagSet",
          "old_text": "job.AddPage(page, &abandoned_pages)",
          "new_text": "page->IsFlagSet(MemoryChunk::NEW_SPACE_BELOW_AGE_MARK)",
          "old_line_content": "    job.AddPage(page, &abandoned_pages);",
          "new_line_content": "      if (page->IsFlagSet(MemoryChunk::NEW_SPACE_BELOW_AGE_MARK)) {",
          "content_same": false
        },
        {
          "line": 3312,
          "old_api": "tracer",
          "new_api": "AddPage",
          "old_text": "heap()->tracer()->CompactionSpeedInBytesPerMillisecond()",
          "new_text": "job.AddPage(page, &abandoned_pages)",
          "old_line_content": "    compaction_speed = heap()->tracer()->CompactionSpeedInBytesPerMillisecond();",
          "new_line_content": "    job.AddPage(page, &abandoned_pages);",
          "content_same": false
        },
        {
          "line": 3323,
          "old_api": "Finalize",
          "new_api": "NumberOfPages",
          "old_text": "evacuators[i]->Finalize()",
          "new_text": "job.NumberOfPages()",
          "old_line_content": "    evacuators[i]->Finalize();",
          "new_line_content": "      NumberOfParallelCompactionTasks(job.NumberOfPages(), live_bytes);",
          "content_same": false
        },
        {
          "line": 3336,
          "old_api": "NumberOfAvailableBackgroundThreads",
          "new_api": "isolate",
          "old_text": "V8::GetCurrentPlatform()->NumberOfAvailableBackgroundThreads()",
          "new_text": "isolate()",
          "old_line_content": "                 V8::GetCurrentPlatform()->NumberOfAvailableBackgroundThreads(),",
          "new_line_content": "    PrintIsolate(isolate(),",
          "content_same": false
        },
        {
          "line": 3366,
          "old_api": "ArrayBufferTracker::FreeDead(p)",
          "new_api": "DCHECK_NOT_NULL",
          "old_text": "ArrayBufferTracker::FreeDead(p)",
          "new_text": "DCHECK_NOT_NULL(space)",
          "old_line_content": "  ArrayBufferTracker::FreeDead(p);",
          "new_line_content": "  DCHECK_NOT_NULL(space);",
          "content_same": false
        },
        {
          "line": 3368,
          "old_api": "area_start",
          "new_api": "identity",
          "old_text": "p->area_start()",
          "new_text": "space->identity()",
          "old_line_content": "  Address free_start = p->area_start();",
          "new_line_content": "         space->identity() == CODE_SPACE || space->identity() == MAP_SPACE);",
          "content_same": false
        },
        {
          "line": 3369,
          "old_api": "reinterpret_cast<intptr_t>(free_start)",
          "new_api": "SweepingDone",
          "old_text": "reinterpret_cast<intptr_t>(free_start)",
          "new_text": "p->SweepingDone()",
          "old_line_content": "  DCHECK(reinterpret_cast<intptr_t>(free_start) % (32 * kPointerSize) == 0);",
          "new_line_content": "  DCHECK(!p->IsEvacuationCandidate() && !p->SweepingDone());",
          "content_same": false
        },
        {
          "line": 3375,
          "old_api": "skip_list",
          "new_api": "area_start",
          "old_text": "p->skip_list()",
          "new_text": "p->area_start()",
          "old_line_content": "      space->identity() == CODE_SPACE && p->skip_list() != nullptr;",
          "new_line_content": "  Address free_start = p->area_start();",
          "content_same": false
        },
        {
          "line": 3376,
          "old_api": "skip_list",
          "new_api": "reinterpret_cast<intptr_t>(free_start)",
          "old_text": "p->skip_list()",
          "new_text": "reinterpret_cast<intptr_t>(free_start)",
          "old_line_content": "  SkipList* skip_list = p->skip_list();",
          "new_line_content": "  DCHECK(reinterpret_cast<intptr_t>(free_start) % (32 * kPointerSize) == 0);",
          "content_same": false
        },
        {
          "line": 3396,
          "old_api": "UnaccountedFree",
          "new_api": "address",
          "old_text": "reinterpret_cast<PagedSpace*>(space)->UnaccountedFree(\n            free_start, size)",
          "new_text": "object->address()",
          "old_line_content": "        freed_bytes = reinterpret_cast<PagedSpace*>(space)->UnaccountedFree(",
          "new_line_content": "    Address free_end = object->address();",
          "content_same": false
        },
        {
          "line": 3398,
          "old_api": "Max",
          "new_api": "static_cast<int>(free_end - free_start)",
          "old_text": "Max(freed_bytes, max_freed_bytes)",
          "new_text": "static_cast<int>(free_end - free_start)",
          "old_line_content": "        max_freed_bytes = Max(freed_bytes, max_freed_bytes);",
          "new_line_content": "      int size = static_cast<int>(free_end - free_start);",
          "content_same": false
        },
        {
          "line": 3400,
          "old_api": "heap",
          "new_api": "memset",
          "old_text": "p->heap()->CreateFillerObjectAt(free_start, size,\n                                        ClearRecordedSlots::kNo)",
          "new_text": "memset(free_start, 0xcc, size)",
          "old_line_content": "        p->heap()->CreateFillerObjectAt(free_start, size,",
          "new_line_content": "        memset(free_start, 0xcc, size);",
          "content_same": false
        },
        {
          "line": 3405,
          "old_api": "SizeFromMap",
          "new_api": "Max",
          "old_text": "object->SizeFromMap(map)",
          "new_text": "Max(freed_bytes, max_freed_bytes)",
          "old_line_content": "    int size = object->SizeFromMap(map);",
          "new_line_content": "        max_freed_bytes = Max(freed_bytes, max_freed_bytes);",
          "content_same": false
        },
        {
          "line": 3407,
          "old_api": "SkipList::RegionNumber(free_end)",
          "new_api": "heap",
          "old_text": "SkipList::RegionNumber(free_end)",
          "new_text": "p->heap()->CreateFillerObjectAt(free_start, size,\n                                        ClearRecordedSlots::kNo)",
          "old_line_content": "      int new_region_start = SkipList::RegionNumber(free_end);",
          "new_line_content": "        p->heap()->CreateFillerObjectAt(free_start, size,",
          "content_same": false
        },
        {
          "line": 3411,
          "old_api": "AddObject",
          "new_api": "synchronized_map",
          "old_text": "skip_list->AddObject(free_end, size)",
          "new_text": "object->synchronized_map()",
          "old_line_content": "        skip_list->AddObject(free_end, size);",
          "new_line_content": "    Map* map = object->synchronized_map();",
          "content_same": false
        },
        {
          "line": 3429,
          "old_api": "Max",
          "new_api": "area_end",
          "old_text": "Max(freed_bytes, max_freed_bytes)",
          "new_text": "p->area_end()",
          "old_line_content": "      max_freed_bytes = Max(freed_bytes, max_freed_bytes);",
          "new_line_content": "    int size = static_cast<int>(p->area_end() - free_start);",
          "content_same": false
        },
        {
          "line": 3431,
          "old_api": "heap",
          "new_api": "memset",
          "old_text": "p->heap()->CreateFillerObjectAt(free_start, size,\n                                      ClearRecordedSlots::kNo)",
          "new_text": "memset(free_start, 0xcc, size)",
          "old_line_content": "      p->heap()->CreateFillerObjectAt(free_start, size,",
          "new_line_content": "      memset(free_start, 0xcc, size);",
          "content_same": false
        },
        {
          "line": 3442,
          "old_api": "instruction_start",
          "new_api": "SetValue",
          "old_text": "code->instruction_start()",
          "new_text": "p->concurrent_sweeping_state().SetValue(Page::kSweepingDone)",
          "old_line_content": "  Address start = code->instruction_start();",
          "new_line_content": "  p->concurrent_sweeping_state().SetValue(Page::kSweepingDone);",
          "content_same": false
        },
        {
          "line": 3448,
          "old_api": "ShouldSkipEvacuationSlotRecording",
          "new_api": "address",
          "old_text": "ShouldSkipEvacuationSlotRecording(code)",
          "new_text": "code->address()",
          "old_line_content": "      !ShouldSkipEvacuationSlotRecording(code)) {",
          "new_line_content": "  Page* page = Page::FromAddress(code->address());",
          "content_same": false
        },
        {
          "line": 3449,
          "old_api": "DCHECK",
          "new_api": "instruction_start",
          "old_text": "DCHECK(compacting_)",
          "new_text": "code->instruction_start()",
          "old_line_content": "    DCHECK(compacting_);",
          "new_line_content": "  Address start = code->instruction_start();",
          "content_same": false
        },
        {
          "line": 3452,
          "old_api": "ObjectMarking::MarkBitFrom(code)",
          "new_api": "RememberedSet<OLD_TO_NEW>::RemoveRangeTyped(page, start, end)",
          "old_text": "ObjectMarking::MarkBitFrom(code)",
          "new_text": "RememberedSet<OLD_TO_NEW>::RemoveRangeTyped(page, start, end)",
          "old_line_content": "    MarkBit mark_bit = ObjectMarking::MarkBitFrom(code);",
          "new_line_content": "  RememberedSet<OLD_TO_NEW>::RemoveRangeTyped(page, start, end);",
          "content_same": false
        },
        {
          "line": 3465,
          "old_api": "marked_for_deoptimization",
          "new_api": "RememberedSet<OLD_TO_OLD>::RemoveRangeTyped(page, start, end)",
          "old_text": "code->marked_for_deoptimization()",
          "new_text": "RememberedSet<OLD_TO_OLD>::RemoveRangeTyped(page, start, end)",
          "old_line_content": "  return code->is_optimized_code() && code->marked_for_deoptimization();",
          "new_line_content": "    RememberedSet<OLD_TO_OLD>::RemoveRangeTyped(page, start, end);",
          "content_same": false
        },
        {
          "line": 3490,
          "old_api": "Visit",
          "new_api": "VerifyAllBlackObjects",
          "old_text": "visitor->Visit(object)",
          "new_text": "VerifyAllBlackObjects(page)",
          "old_line_content": "    if (!visitor->Visit(object)) {",
          "new_line_content": "  VerifyAllBlackObjects(page);",
          "content_same": false
        },
        {
          "line": 3495,
          "old_api": "old_to_new_slots",
          "new_api": "Next",
          "old_text": "page->old_to_new_slots()",
          "new_text": "it.Next()",
          "old_line_content": "        if (page->old_to_new_slots() != nullptr) {",
          "new_line_content": "  while ((object = it.Next()) != nullptr) {",
          "content_same": false
        },
        {
          "line": 3496,
          "old_api": "old_to_new_slots",
          "new_api": "ObjectMarking::MarkBitFrom(object)",
          "old_text": "page->old_to_new_slots()->RemoveRange(\n              0, static_cast<int>(object->address() - page->address()))",
          "new_text": "ObjectMarking::MarkBitFrom(object)",
          "old_line_content": "          page->old_to_new_slots()->RemoveRange(",
          "new_line_content": "    DCHECK(Marking::IsBlack(ObjectMarking::MarkBitFrom(object)));",
          "content_same": false
        },
        {
          "line": 3497,
          "old_api": "address",
          "new_api": "Visit",
          "old_text": "page->address()",
          "new_text": "visitor->Visit(object)",
          "old_line_content": "              0, static_cast<int>(object->address() - page->address()));",
          "new_line_content": "    if (!visitor->Visit(object)) {",
          "content_same": false
        },
        {
          "line": 3499,
          "old_api": "typed_old_to_new_slots",
          "new_api": "markbits",
          "old_text": "page->typed_old_to_new_slots()",
          "new_text": "page->markbits()->ClearRange(\n            page->AddressToMarkbitIndex(page->area_start()),\n            page->AddressToMarkbitIndex(object->address()))",
          "old_line_content": "        if (page->typed_old_to_new_slots() != nullptr) {",
          "new_line_content": "        page->markbits()->ClearRange(",
          "content_same": false
        },
        {
          "line": 3500,
          "old_api": "address",
          "new_api": "area_start",
          "old_text": "page->address()",
          "new_text": "page->area_start()",
          "old_line_content": "          RememberedSet<OLD_TO_NEW>::RemoveRangeTyped(page, page->address(),",
          "new_line_content": "            page->AddressToMarkbitIndex(page->area_start()),",
          "content_same": false
        },
        {
          "line": 3503,
          "old_api": "RecomputeLiveBytes",
          "new_api": "old_to_new_slots",
          "old_text": "RecomputeLiveBytes(page)",
          "new_text": "page->old_to_new_slots()->RemoveRange(\n              0, static_cast<int>(object->address() - page->address()))",
          "old_line_content": "        RecomputeLiveBytes(page);",
          "new_line_content": "          page->old_to_new_slots()->RemoveRange(",
          "content_same": false
        },
        {
          "line": 3539,
          "old_api": "EvacuateNewSpacePrologue",
          "new_api": "tracer",
          "old_text": "EvacuateNewSpacePrologue()",
          "new_text": "heap()->tracer()",
          "old_line_content": "    EvacuateNewSpacePrologue();",
          "new_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_EVACUATE);",
          "content_same": false
        },
        {
          "line": 3546,
          "old_api": "new_space",
          "new_api": "EvacuateNewSpacePrologue",
          "old_text": "heap()->new_space()->Rebalance()",
          "new_text": "EvacuateNewSpacePrologue()",
          "old_line_content": "  if (!heap()->new_space()->Rebalance()) {",
          "new_line_content": "    EvacuateNewSpacePrologue();",
          "content_same": false
        },
        {
          "line": 3547,
          "old_api": "FatalProcessOutOfMemory",
          "new_api": "EvacuatePagesInParallel",
          "old_text": "FatalProcessOutOfMemory(\"NewSpace::Rebalance\")",
          "new_text": "EvacuatePagesInParallel()",
          "old_line_content": "    FatalProcessOutOfMemory(\"NewSpace::Rebalance\");",
          "new_line_content": "    EvacuatePagesInParallel();",
          "content_same": false
        },
        {
          "line": 3554,
          "old_api": "memory_allocator",
          "new_api": "FatalProcessOutOfMemory",
          "old_text": "heap()->memory_allocator()->unmapper()->FreeQueuedChunks()",
          "new_text": "FatalProcessOutOfMemory(\"NewSpace::Rebalance\")",
          "old_line_content": "  heap()->memory_allocator()->unmapper()->FreeQueuedChunks();",
          "new_line_content": "    FatalProcessOutOfMemory(\"NewSpace::Rebalance\");",
          "content_same": false
        },
        {
          "line": 3561,
          "old_api": "ClearFlag",
          "new_api": "memory_allocator",
          "old_text": "p->ClearFlag(Page::PAGE_NEW_NEW_PROMOTION)",
          "new_text": "heap()->memory_allocator()->unmapper()->FreeQueuedChunks()",
          "old_line_content": "        p->ClearFlag(Page::PAGE_NEW_NEW_PROMOTION);",
          "new_line_content": "  heap()->memory_allocator()->unmapper()->FreeQueuedChunks();",
          "content_same": false
        },
        {
          "line": 3564,
          "old_api": "ClearFlag",
          "new_api": "tracer",
          "old_text": "p->ClearFlag(Page::PAGE_NEW_OLD_PROMOTION)",
          "new_text": "heap()->tracer()",
          "old_line_content": "        p->ClearFlag(Page::PAGE_NEW_OLD_PROMOTION);",
          "new_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_EVACUATE_CLEAN_UP);",
          "content_same": false
        },
        {
          "line": 3567,
          "old_api": "owner",
          "new_api": "IsFlagSet",
          "old_text": "p->owner()->identity()",
          "new_text": "p->IsFlagSet(Page::PAGE_NEW_NEW_PROMOTION)",
          "old_line_content": "        sweeper().AddLatePage(p->owner()->identity(), p);",
          "new_line_content": "      if (p->IsFlagSet(Page::PAGE_NEW_NEW_PROMOTION)) {",
          "content_same": false
        },
        {
          "line": 3570,
          "old_api": "Rewind",
          "new_api": "IsFlagSet",
          "old_text": "newspace_evacuation_candidates_.Rewind(0)",
          "new_text": "p->IsFlagSet(Page::PAGE_NEW_OLD_PROMOTION)",
          "old_line_content": "    newspace_evacuation_candidates_.Rewind(0);",
          "new_line_content": "      } else if (p->IsFlagSet(Page::PAGE_NEW_OLD_PROMOTION)) {",
          "content_same": false
        },
        {
          "line": 3577,
          "old_api": "Clear",
          "new_api": "Rewind",
          "old_text": "list->Clear()",
          "new_text": "newspace_evacuation_candidates_.Rewind(0)",
          "old_line_content": "      if (list != NULL) list->Clear();",
          "new_line_content": "    newspace_evacuation_candidates_.Rewind(0);",
          "content_same": false
        },
        {
          "line": 3585,
          "old_api": "ReleaseEvacuationCandidates",
          "new_api": "IsFlagSet",
          "old_text": "ReleaseEvacuationCandidates()",
          "new_text": "p->IsFlagSet(Page::COMPACTION_WAS_ABORTED)",
          "old_line_content": "    ReleaseEvacuationCandidates();",
          "new_line_content": "      if (p->IsFlagSet(Page::COMPACTION_WAS_ABORTED)) {",
          "content_same": false
        },
        {
          "line": 3626,
          "old_api": "isolate",
          "new_api": "reinterpret_cast<Object**>(slot)",
          "old_text": "heap->isolate()",
          "new_text": "reinterpret_cast<Object**>(slot)",
          "old_line_content": "      Isolate* isolate = heap->isolate();",
          "new_line_content": "        return UpdateSlot(reinterpret_cast<Object**>(slot));",
          "content_same": false
        },
        {
          "line": 3634,
          "old_api": "RememberedSet<OLD_TO_NEW>::IterateTyped(\n          chunk,\n          [isolate, heap](SlotType type, Address host_addr, Address slot) {\n            return UpdateTypedSlotHelper::UpdateTypedSlot(\n                isolate, type, slot, [heap](Object** slot) {\n                  return CheckAndUpdateOldToNewSlot(\n                      heap, reinterpret_cast<Address>(slot));\n                });\n          })",
          "new_api": "RememberedSet<OLD_TO_OLD>::IterateTyped(\n          chunk, [isolate](SlotType type, Address host_addr, Address slot) {\n            return UpdateTypedSlotHelper::UpdateTypedSlot(isolate, type, slot,\n                                                          UpdateSlot);\n          })",
          "old_text": "RememberedSet<OLD_TO_NEW>::IterateTyped(\n          chunk,\n          [isolate, heap](SlotType type, Address host_addr, Address slot) {\n            return UpdateTypedSlotHelper::UpdateTypedSlot(\n                isolate, type, slot, [heap](Object** slot) {\n                  return CheckAndUpdateOldToNewSlot(\n                      heap, reinterpret_cast<Address>(slot));\n                });\n          })",
          "new_text": "RememberedSet<OLD_TO_OLD>::IterateTyped(\n          chunk, [isolate](SlotType type, Address host_addr, Address slot) {\n            return UpdateTypedSlotHelper::UpdateTypedSlot(isolate, type, slot,\n                                                          UpdateSlot);\n          })",
          "old_line_content": "      RememberedSet<OLD_TO_NEW>::IterateTyped(",
          "new_line_content": "      RememberedSet<OLD_TO_OLD>::IterateTyped(",
          "content_same": false
        },
        {
          "line": 3640,
          "old_api": "reinterpret_cast<Address>(slot)",
          "new_api": "isolate",
          "old_text": "reinterpret_cast<Address>(slot)",
          "new_text": "heap->isolate()",
          "old_line_content": "                      heap, reinterpret_cast<Address>(slot));",
          "new_line_content": "      Isolate* isolate = heap->isolate();",
          "content_same": false
        },
        {
          "line": 3655,
          "old_api": "IsForwardingAddress",
          "new_api": "reinterpret_cast<Object**>(slot_address)",
          "old_text": "map_word.IsForwardingAddress()",
          "new_text": "reinterpret_cast<Object**>(slot_address)",
          "old_line_content": "      if (map_word.IsForwardingAddress()) {",
          "new_line_content": "    Object** slot = reinterpret_cast<Object**>(slot_address);",
          "content_same": false
        },
        {
          "line": 3657,
          "old_api": "ToForwardingAddress",
          "new_api": "reinterpret_cast<HeapObject*>(*slot)",
          "old_text": "map_word.ToForwardingAddress()",
          "new_text": "reinterpret_cast<HeapObject*>(*slot)",
          "old_line_content": "        *slot = map_word.ToForwardingAddress();",
          "new_line_content": "      HeapObject* heap_object = reinterpret_cast<HeapObject*>(*slot);",
          "content_same": false
        },
        {
          "line": 3692,
          "old_api": "AddPage",
          "new_api": "Min",
          "old_text": "RememberedSet<direction>::IterateMemoryChunks(\n      heap, [&job](MemoryChunk* chunk) { job.AddPage(chunk, 0); })",
          "new_text": "Min(kMaxTasks, (pages + kPagesPerTask - 1) / kPagesPerTask)",
          "old_line_content": "  RememberedSet<direction>::IterateMemoryChunks(",
          "new_line_content": "  return Min(kMaxTasks, (pages + kPagesPerTask - 1) / kPagesPerTask);",
          "content_same": false
        },
        {
          "line": 3748,
          "old_api": "isolate",
          "new_api": "instance_type",
          "old_text": "heap->isolate()->cancelable_task_manager()",
          "new_text": "map->instance_type()",
          "old_line_content": "      heap, heap->isolate()->cancelable_task_manager(), semaphore);",
          "new_line_content": "      object->IterateBody(map->instance_type(), size, visitor);",
          "content_same": false
        },
        {
          "line": 3755,
          "old_api": "std::make_pair(start, end)",
          "new_api": "isolate",
          "old_text": "std::make_pair(start, end)",
          "new_text": "heap->isolate()->cancelable_task_manager()",
          "old_line_content": "    job.AddPage(page, std::make_pair(start, end));",
          "new_line_content": "      heap, heap->isolate()->cancelable_task_manager(), semaphore);",
          "content_same": false
        },
        {
          "line": 3758,
          "old_api": "NumberOfPages",
          "new_api": "NewSpacePageRange",
          "old_text": "job.NumberOfPages()",
          "new_text": "NewSpacePageRange(space_start, space_end)",
          "old_line_content": "  int num_tasks = FLAG_parallel_pointer_update ? job.NumberOfPages() : 1;",
          "new_line_content": "  for (Page* page : NewSpacePageRange(space_start, space_end)) {",
          "content_same": false
        },
        {
          "line": 3770,
          "old_api": "UpdateToSpacePointersInParallel",
          "new_api": "tracer",
          "old_text": "UpdateToSpacePointersInParallel(heap_, &page_parallel_job_semaphore_)",
          "new_text": "heap()->tracer()",
          "old_line_content": "    UpdateToSpacePointersInParallel(heap_, &page_parallel_job_semaphore_);",
          "new_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_EVACUATE_UPDATE_POINTERS);",
          "content_same": false
        },
        {
          "line": 3777,
          "old_api": "heap",
          "new_api": "UpdateToSpacePointersInParallel",
          "old_text": "this->heap()",
          "new_text": "UpdateToSpacePointersInParallel(heap_, &page_parallel_job_semaphore_)",
          "old_line_content": "    Heap* heap = this->heap();",
          "new_line_content": "    UpdateToSpacePointersInParallel(heap_, &page_parallel_job_semaphore_);",
          "content_same": false
        },
        {
          "line": 3780,
          "old_api": "UpdatePointersInParallel<OLD_TO_OLD>(heap_, &page_parallel_job_semaphore_)",
          "new_api": "UpdatePointersInParallel<OLD_TO_NEW>(heap_, &page_parallel_job_semaphore_)",
          "old_text": "UpdatePointersInParallel<OLD_TO_OLD>(heap_, &page_parallel_job_semaphore_)",
          "new_text": "UpdatePointersInParallel<OLD_TO_NEW>(heap_, &page_parallel_job_semaphore_)",
          "old_line_content": "    UpdatePointersInParallel<OLD_TO_OLD>(heap_, &page_parallel_job_semaphore_);",
          "new_line_content": "    UpdatePointersInParallel<OLD_TO_NEW>(heap_, &page_parallel_job_semaphore_);",
          "content_same": false
        },
        {
          "line": 3784,
          "old_api": "tracer",
          "new_api": "heap",
          "old_text": "heap()->tracer()",
          "new_text": "this->heap()",
          "old_line_content": "    TRACE_GC(heap()->tracer(),",
          "new_line_content": "    Heap* heap = this->heap();",
          "content_same": false
        },
        {
          "line": 3787,
          "old_api": "UpdateReferencesInExternalStringTable",
          "new_api": "UpdatePointersInParallel<OLD_TO_OLD>(heap_, &page_parallel_job_semaphore_)",
          "old_text": "heap_->UpdateReferencesInExternalStringTable(\n        &UpdateReferenceInExternalStringTableEntry)",
          "new_text": "UpdatePointersInParallel<OLD_TO_OLD>(heap_, &page_parallel_job_semaphore_)",
          "old_line_content": "    heap_->UpdateReferencesInExternalStringTable(",
          "new_line_content": "    UpdatePointersInParallel<OLD_TO_OLD>(heap_, &page_parallel_job_semaphore_);",
          "content_same": false
        },
        {
          "line": 3791,
          "old_api": "ProcessWeakListRoots",
          "new_api": "tracer",
          "old_text": "heap()->ProcessWeakListRoots(&evacuation_object_retainer)",
          "new_text": "heap()->tracer()",
          "old_line_content": "    heap()->ProcessWeakListRoots(&evacuation_object_retainer);",
          "new_line_content": "    TRACE_GC(heap()->tracer(),",
          "content_same": false
        },
        {
          "line": 3798,
          "old_api": "IsEvacuationCandidate",
          "new_api": "ProcessWeakListRoots",
          "old_text": "p->IsEvacuationCandidate()",
          "new_text": "heap()->ProcessWeakListRoots(&evacuation_object_retainer)",
          "old_line_content": "    if (!p->IsEvacuationCandidate()) continue;",
          "new_line_content": "    heap()->ProcessWeakListRoots(&evacuation_object_retainer);",
          "content_same": false
        },
        {
          "line": 3806,
          "old_api": "memory_allocator",
          "new_api": "owner",
          "old_text": "heap()->memory_allocator()->unmapper()->FreeQueuedChunks()",
          "new_text": "p->owner()",
          "old_line_content": "  heap()->memory_allocator()->unmapper()->FreeQueuedChunks();",
          "new_line_content": "    PagedSpace* space = static_cast<PagedSpace*>(p->owner());",
          "content_same": false
        },
        {
          "line": 3840,
          "old_api": "RawSweep",
          "new_api": "mutex",
          "old_text": "RawSweep(page, IGNORE_FREE_LIST, free_space_mode)",
          "new_text": "page->mutex()->Unlock()",
          "old_line_content": "      RawSweep(page, IGNORE_FREE_LIST, free_space_mode);",
          "new_line_content": "      page->mutex()->Unlock();",
          "content_same": false
        },
        {
          "line": 3853,
          "old_api": "mutex",
          "new_api": "RawSweep",
          "old_text": "page->mutex()->Unlock()",
          "new_text": "RawSweep(page, REBUILD_FREE_LIST, free_space_mode)",
          "old_line_content": "    page->mutex()->Unlock();",
          "new_line_content": "      max_freed = RawSweep(page, REBUILD_FREE_LIST, free_space_mode);",
          "content_same": false
        },
        {
          "line": 3859,
          "old_api": "DCHECK",
          "new_api": "SetValue",
          "old_text": "DCHECK(!sweeping_in_progress_)",
          "new_text": "page->concurrent_sweeping_state().SetValue(Page::kSweepingDone)",
          "old_line_content": "  DCHECK(!sweeping_in_progress_);",
          "new_line_content": "    page->concurrent_sweeping_state().SetValue(Page::kSweepingDone);",
          "content_same": false
        },
        {
          "line": 3860,
          "old_api": "PrepareToBeSweptPage",
          "new_api": "mutex",
          "old_text": "PrepareToBeSweptPage(space, page)",
          "new_text": "page->mutex()->Unlock()",
          "old_line_content": "  PrepareToBeSweptPage(space, page);",
          "new_line_content": "    page->mutex()->Unlock();",
          "content_same": false
        },
        {
          "line": 3874,
          "old_api": "SetValue",
          "new_api": "PrepareToBeSweptPage",
          "old_text": "page->concurrent_sweeping_state().SetValue(Page::kSweepingPending)",
          "new_text": "PrepareToBeSweptPage(space, page)",
          "old_line_content": "  page->concurrent_sweeping_state().SetValue(Page::kSweepingPending);",
          "new_line_content": "  PrepareToBeSweptPage(space, page);",
          "content_same": false
        },
        {
          "line": 3884,
          "old_api": "empty",
          "new_api": "ShrinkSpace",
          "old_text": "sweeping_list_[space].empty()",
          "new_text": "heap_->paged_space(space)->accounting_stats_.ShrinkSpace(to_sweep)",
          "old_line_content": "  if (!sweeping_list_[space].empty()) {",
          "new_line_content": "    heap_->paged_space(space)->accounting_stats_.ShrinkSpace(to_sweep);",
          "content_same": false
        },
        {
          "line": 3921,
          "old_api": "Heap::ShouldZapGarbage()",
          "new_api": "IsFlagSet",
          "old_text": "Heap::ShouldZapGarbage()",
          "new_text": "p->IsFlagSet(Page::NEVER_ALLOCATE_ON_PAGE)",
          "old_line_content": "                        Heap::ShouldZapGarbage() ? Sweeper::ZAP_FREE_SPACE",
          "new_line_content": "    if (p->IsFlagSet(Page::NEVER_ALLOCATE_ON_PAGE)) {",
          "content_same": false
        },
        {
          "line": 3927,
          "old_api": "LiveBytes",
          "new_api": "Sweeper::RawSweep(p, Sweeper::IGNORE_FREE_LIST,\n                        Heap::ShouldZapGarbage() ? Sweeper::ZAP_FREE_SPACE\n                                                 : Sweeper::IGNORE_FREE_SPACE)",
          "old_text": "p->LiveBytes()",
          "new_text": "Sweeper::RawSweep(p, Sweeper::IGNORE_FREE_LIST,\n                        Heap::ShouldZapGarbage() ? Sweeper::ZAP_FREE_SPACE\n                                                 : Sweeper::IGNORE_FREE_SPACE)",
          "old_line_content": "    if (p->LiveBytes() == 0) {",
          "new_line_content": "      Sweeper::RawSweep(p, Sweeper::IGNORE_FREE_LIST,",
          "content_same": false
        },
        {
          "line": 3934,
          "old_api": "ReleasePage",
          "new_api": "LiveBytes",
          "old_text": "space->ReleasePage(p)",
          "new_text": "p->LiveBytes()",
          "old_line_content": "        space->ReleasePage(p);",
          "new_line_content": "    if (p->LiveBytes() == 0) {",
          "content_same": false
        },
        {
          "line": 3940,
          "old_api": "identity",
          "new_api": "ArrayBufferTracker::FreeAll(p)",
          "old_text": "space->identity()",
          "new_text": "ArrayBufferTracker::FreeAll(p)",
          "old_line_content": "    sweeper().AddPage(space->identity(), p);",
          "new_line_content": "        ArrayBufferTracker::FreeAll(p);",
          "content_same": false
        },
        {
          "line": 3952,
          "old_api": "tracer",
          "new_api": "isolate",
          "old_text": "heap()->tracer()",
          "new_text": "isolate()",
          "old_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_SWEEP);",
          "new_line_content": "    PrintIsolate(isolate(), \"sweeping: space=%s initialized_for_sweeping=%d\",",
          "content_same": false
        },
        {
          "line": 3978,
          "old_api": "StartSweeping",
          "new_api": "code_space",
          "old_text": "sweeper().StartSweeping()",
          "new_text": "heap()->code_space()",
          "old_line_content": "    sweeper().StartSweeping();",
          "new_line_content": "      StartSweepSpace(heap()->code_space());",
          "content_same": false
        },
        {
          "line": 3985,
          "old_api": "MonotonicallyIncreasingTimeInMs",
          "new_api": "StartSweeping",
          "old_text": "heap_->MonotonicallyIncreasingTimeInMs()",
          "new_text": "sweeper().StartSweeping()",
          "old_line_content": "    heap_->tracer()->AddSweepingTime(heap_->MonotonicallyIncreasingTimeInMs() -",
          "new_line_content": "    sweeper().StartSweeping();",
          "content_same": false
        },
        {
          "line": 4001,
          "old_api": "reinterpret_cast<Address>(host)",
          "new_api": "MarkCompactMarkingVisitor::Initialize()",
          "old_text": "reinterpret_cast<Address>(host)",
          "new_text": "MarkCompactMarkingVisitor::Initialize()",
          "old_line_content": "  Page* source_page = Page::FromAddress(reinterpret_cast<Address>(host));",
          "new_line_content": "  MarkCompactMarkingVisitor::Initialize();",
          "content_same": false
        },
        {
          "line": 4002,
          "old_api": "IsEvacuationCandidate",
          "new_api": "IncrementalMarking::Initialize()",
          "old_text": "target_page->IsEvacuationCandidate()",
          "new_text": "IncrementalMarking::Initialize()",
          "old_line_content": "  if (target_page->IsEvacuationCandidate() &&",
          "new_line_content": "  IncrementalMarking::Initialize();",
          "content_same": false
        },
        {
          "line": 4007,
          "old_api": "reinterpret_cast<Address>(host)",
          "new_api": "reinterpret_cast<Address>(target)",
          "old_text": "reinterpret_cast<Address>(host)",
          "new_text": "reinterpret_cast<Address>(target)",
          "old_line_content": "        source_page, reinterpret_cast<Address>(host), CODE_ENTRY_SLOT, slot);",
          "new_line_content": "  Page* target_page = Page::FromAddress(reinterpret_cast<Address>(target));",
          "content_same": false
        },
        {
          "line": 4013,
          "old_api": "gc_state",
          "new_api": "RememberedSet<OLD_TO_OLD>::InsertTyped(\n        source_page, reinterpret_cast<Address>(host), CODE_ENTRY_SLOT, slot)",
          "old_text": "heap()->gc_state()",
          "new_text": "RememberedSet<OLD_TO_OLD>::InsertTyped(\n        source_page, reinterpret_cast<Address>(host), CODE_ENTRY_SLOT, slot)",
          "old_line_content": "  DCHECK(heap()->gc_state() == Heap::MARK_COMPACT);",
          "new_line_content": "    RememberedSet<OLD_TO_OLD>::InsertTyped(",
          "content_same": false
        },
        {
          "line": 4014,
          "old_api": "is_compacting",
          "new_api": "reinterpret_cast<Address>(host)",
          "old_text": "is_compacting()",
          "new_text": "reinterpret_cast<Address>(host)",
          "old_line_content": "  if (is_compacting()) {",
          "new_line_content": "        source_page, reinterpret_cast<Address>(host), CODE_ENTRY_SLOT, slot);",
          "content_same": false
        },
        {
          "line": 4020,
          "old_api": "isolate",
          "new_api": "gc_state",
          "old_text": "isolate()",
          "new_text": "heap()->gc_state()",
          "old_line_content": "      RelocInfo rinfo(isolate(), pc, RelocInfo::CODE_TARGET, 0, host);",
          "new_line_content": "  DCHECK(heap()->gc_state() == Heap::MARK_COMPACT);",
          "content_same": false
        },
        {
          "line": 4023,
          "old_api": "InNewSpace",
          "new_api": "inner_pointer_to_code_cache",
          "old_text": "heap()->InNewSpace(target)",
          "new_text": "isolate()->inner_pointer_to_code_cache()->GcSafeFindCodeForInnerPointer(\n            pc)",
          "old_line_content": "      DCHECK(!heap()->InNewSpace(target));",
          "new_line_content": "        isolate()->inner_pointer_to_code_cache()->GcSafeFindCodeForInnerPointer(",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2048,
          "old_api": null,
          "new_api": "IsFull",
          "old_text": null,
          "new_text": "marking_deque_.IsFull()",
          "old_line_content": "",
          "new_line_content": "  if (marking_deque_.IsFull()) return;",
          "content_same": false
        },
        {
          "line": 2054,
          "old_api": null,
          "new_api": "IsFull",
          "old_text": null,
          "new_text": "marking_deque_.IsFull()",
          "old_line_content": "}",
          "new_line_content": "  if (marking_deque_.IsFull()) return;",
          "content_same": false
        },
        {
          "line": 2057,
          "old_api": null,
          "new_api": "DiscoverGreyObjectsWithIterator",
          "old_text": null,
          "new_text": "DiscoverGreyObjectsWithIterator(&lo_it)",
          "old_line_content": "// Mark all objects reachable (transitively) from objects on the marking",
          "new_line_content": "  DiscoverGreyObjectsWithIterator(&lo_it);",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": null,
          "new_api": "IsFull",
          "old_text": null,
          "new_text": "marking_deque_.IsFull()",
          "old_line_content": "// stack.  Before: the marking stack contains zero or more heap object",
          "new_line_content": "  if (marking_deque_.IsFull()) return;",
          "content_same": false
        },
        {
          "line": 2060,
          "old_api": null,
          "new_api": "ClearOverflowed",
          "old_text": null,
          "new_text": "marking_deque_.ClearOverflowed()",
          "old_line_content": "// objects in the heap.",
          "new_line_content": "  marking_deque_.ClearOverflowed();",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": null,
          "new_api": "EmptyMarkingDeque",
          "old_text": null,
          "new_text": "EmptyMarkingDeque()",
          "old_line_content": "// Mark all objects reachable (transitively) from objects on the marking",
          "new_line_content": "  EmptyMarkingDeque();",
          "content_same": false
        },
        {
          "line": 2070,
          "old_api": null,
          "new_api": "overflowed",
          "old_text": null,
          "new_text": "marking_deque_.overflowed()",
          "old_line_content": "// stack including references only considered in the atomic marking pause.",
          "new_line_content": "  while (marking_deque_.overflowed()) {",
          "content_same": false
        },
        {
          "line": 2071,
          "old_api": null,
          "new_api": "RefillMarkingDeque",
          "old_text": null,
          "new_text": "RefillMarkingDeque()",
          "old_line_content": "void MarkCompactCollector::ProcessEphemeralMarking(",
          "new_line_content": "    RefillMarkingDeque();",
          "content_same": false
        },
        {
          "line": 2072,
          "old_api": null,
          "new_api": "EmptyMarkingDeque",
          "old_text": null,
          "new_text": "EmptyMarkingDeque()",
          "old_line_content": "    ObjectVisitor* visitor, bool only_process_harmony_weak_collections) {",
          "new_line_content": "    EmptyMarkingDeque();",
          "content_same": false
        },
        {
          "line": 2080,
          "old_api": null,
          "new_api": "overflowed",
          "old_text": null,
          "new_text": "marking_deque_.overflowed()",
          "old_line_content": "                 EmbedderHeapTracer::ForceCompletionAction::FORCE_COMPLETION));",
          "new_line_content": "  DCHECK(marking_deque_.IsEmpty() && !marking_deque_.overflowed());",
          "content_same": false
        },
        {
          "line": 2084,
          "old_api": null,
          "new_api": "RegisterWrappersWithEmbedderHeapTracer",
          "old_text": null,
          "new_text": "RegisterWrappersWithEmbedderHeapTracer()",
          "old_line_content": "          visitor, &IsUnmarkedHeapObjectWithHeap);",
          "new_line_content": "      RegisterWrappersWithEmbedderHeapTracer();",
          "content_same": false
        },
        {
          "line": 2086,
          "old_api": null,
          "new_api": "EmbedderHeapTracer::AdvanceTracingActions(\n                 EmbedderHeapTracer::ForceCompletionAction::FORCE_COMPLETION)",
          "old_text": null,
          "new_text": "EmbedderHeapTracer::AdvanceTracingActions(\n                 EmbedderHeapTracer::ForceCompletionAction::FORCE_COMPLETION)",
          "old_line_content": "    }",
          "new_line_content": "          0, EmbedderHeapTracer::AdvanceTracingActions(",
          "content_same": false
        },
        {
          "line": 2090,
          "old_api": null,
          "new_api": "global_handles",
          "old_text": null,
          "new_text": "isolate()->global_handles()->IterateObjectGroups(\n          visitor, &IsUnmarkedHeapObjectWithHeap)",
          "old_line_content": "  }",
          "new_line_content": "      isolate()->global_handles()->IterateObjectGroups(",
          "content_same": false
        },
        {
          "line": 2092,
          "old_api": null,
          "new_api": "MarkImplicitRefGroups",
          "old_text": null,
          "new_text": "MarkImplicitRefGroups(&MarkCompactMarkingVisitor::MarkObject)",
          "old_line_content": "",
          "new_line_content": "      MarkImplicitRefGroups(&MarkCompactMarkingVisitor::MarkObject);",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": null,
          "new_api": "ProcessWeakCollections",
          "old_text": null,
          "new_text": "ProcessWeakCollections()",
          "old_line_content": "  for (StackFrameIterator it(isolate(), isolate()->thread_local_top());",
          "new_line_content": "    ProcessWeakCollections();",
          "content_same": false
        },
        {
          "line": 2103,
          "old_api": null,
          "new_api": "frame",
          "old_text": null,
          "new_text": "it.frame()->type()",
          "old_line_content": "      }",
          "new_line_content": "    if (it.frame()->type() == StackFrame::JAVA_SCRIPT) {",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": null,
          "new_api": "frame",
          "old_text": null,
          "new_text": "it.frame()->type()",
          "old_line_content": "    }",
          "new_line_content": "    if (it.frame()->type() == StackFrame::OPTIMIZED) {",
          "content_same": false
        },
        {
          "line": 2107,
          "old_api": null,
          "new_api": "frame",
          "old_text": null,
          "new_text": "it.frame()->LookupCode()",
          "old_line_content": "  }",
          "new_line_content": "      Code* code = it.frame()->LookupCode();",
          "content_same": false
        },
        {
          "line": 2108,
          "old_api": null,
          "new_api": "frame",
          "old_text": null,
          "new_text": "it.frame()->pc()",
          "old_line_content": "}",
          "new_line_content": "      if (!code->CanDeoptAt(it.frame()->pc())) {",
          "content_same": false
        },
        {
          "line": 2109,
          "old_api": null,
          "new_api": "Code::BodyDescriptor::IterateBody(code, visitor)",
          "old_text": null,
          "new_text": "Code::BodyDescriptor::IterateBody(code, visitor)",
          "old_line_content": "",
          "new_line_content": "        Code::BodyDescriptor::IterateBody(code, visitor);",
          "content_same": false
        },
        {
          "line": 2111,
          "old_api": null,
          "new_api": "ProcessMarkingDeque",
          "old_text": null,
          "new_text": "ProcessMarkingDeque()",
          "old_line_content": "void MarkCompactCollector::EnsureMarkingDequeIsReserved() {",
          "new_line_content": "      ProcessMarkingDeque();",
          "content_same": false
        },
        {
          "line": 2119,
          "old_api": null,
          "new_api": "in_use",
          "old_text": null,
          "new_text": "marking_deque_.in_use()",
          "old_line_content": "  }",
          "new_line_content": "  DCHECK(!marking_deque_.in_use());",
          "content_same": false
        },
        {
          "line": 2125,
          "old_api": null,
          "new_api": "V8::FatalProcessOutOfMemory(\"EnsureMarkingDequeIsReserved\")",
          "old_text": null,
          "new_text": "V8::FatalProcessOutOfMemory(\"EnsureMarkingDequeIsReserved\")",
          "old_line_content": "  // If that fails, make do with a smaller one.",
          "new_line_content": "    V8::FatalProcessOutOfMemory(\"EnsureMarkingDequeIsReserved\");",
          "content_same": false
        },
        {
          "line": 2133,
          "old_api": null,
          "new_api": "in_use",
          "old_text": null,
          "new_text": "marking_deque_.in_use()",
          "old_line_content": "    if (currently_committed > size) {",
          "new_line_content": "  CHECK(!marking_deque_.in_use());",
          "content_same": false
        },
        {
          "line": 2142,
          "old_api": null,
          "new_api": "address",
          "old_text": null,
          "new_text": "marking_deque_memory_->address()",
          "old_line_content": "    }",
          "new_line_content": "          reinterpret_cast<Address>(marking_deque_memory_->address()) + size,",
          "content_same": false
        },
        {
          "line": 2148,
          "old_api": null,
          "new_api": "UNREACHABLE",
          "old_text": null,
          "new_text": "UNREACHABLE()",
          "old_line_content": "    if (success) {",
          "new_line_content": "      UNREACHABLE();",
          "content_same": false
        },
        {
          "line": 2151,
          "old_api": null,
          "new_api": "Commit",
          "old_text": null,
          "new_text": "memory->Commit(\n        reinterpret_cast<Address>(memory->address()) + currently_committed,\n        size - currently_committed,\n        false)",
          "old_line_content": "    }",
          "new_line_content": "    bool success = memory->Commit(",
          "content_same": false
        },
        {
          "line": 2152,
          "old_api": null,
          "new_api": "address",
          "old_text": null,
          "new_text": "memory->address()",
          "old_line_content": "  }",
          "new_line_content": "        reinterpret_cast<Address>(memory->address()) + currently_committed,",
          "content_same": false
        },
        {
          "line": 2165,
          "old_api": null,
          "new_api": "in_use",
          "old_text": null,
          "new_text": "marking_deque_.in_use()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(!marking_deque_.in_use());",
          "content_same": false
        },
        {
          "line": 2166,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(marking_deque_memory_committed_ > 0)",
          "old_line_content": "",
          "new_line_content": "  DCHECK(marking_deque_memory_committed_ > 0);",
          "content_same": false
        },
        {
          "line": 2167,
          "old_api": null,
          "new_api": "address",
          "old_text": null,
          "new_text": "marking_deque_memory_->address()",
          "old_line_content": "void MarkingDeque::Initialize(Address low, Address high) {",
          "new_line_content": "  Address addr = static_cast<Address>(marking_deque_memory_->address());",
          "content_same": false
        },
        {
          "line": 2175,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(!in_use_)",
          "old_line_content": "  top_ = bottom_ = 0;",
          "new_line_content": "  DCHECK(!in_use_);",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": null,
          "new_api": "reinterpret_cast<HeapObject**>(low)",
          "old_text": null,
          "new_text": "reinterpret_cast<HeapObject**>(low)",
          "old_line_content": "  overflowed_ = false;",
          "new_line_content": "  HeapObject** obj_low = reinterpret_cast<HeapObject**>(low);",
          "content_same": false
        },
        {
          "line": 2177,
          "old_api": null,
          "new_api": "reinterpret_cast<HeapObject**>(high)",
          "old_text": null,
          "new_text": "reinterpret_cast<HeapObject**>(high)",
          "old_line_content": "  in_use_ = true;",
          "new_line_content": "  HeapObject** obj_high = reinterpret_cast<HeapObject**>(high);",
          "content_same": false
        },
        {
          "line": 2179,
          "old_api": null,
          "new_api": "base::bits::RoundDownToPowerOfTwo32(\n              static_cast<uint32_t>(obj_high - obj_low))",
          "old_text": null,
          "new_text": "base::bits::RoundDownToPowerOfTwo32(\n              static_cast<uint32_t>(obj_high - obj_low))",
          "old_line_content": "",
          "new_line_content": "  mask_ = base::bits::RoundDownToPowerOfTwo32(",
          "content_same": false
        },
        {
          "line": 2180,
          "old_api": null,
          "new_api": "static_cast<uint32_t>(obj_high - obj_low)",
          "old_text": null,
          "new_text": "static_cast<uint32_t>(obj_high - obj_low)",
          "old_line_content": "",
          "new_line_content": "              static_cast<uint32_t>(obj_high - obj_low)) -",
          "content_same": false
        },
        {
          "line": 2190,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "IsEmpty()",
          "old_line_content": "",
          "new_line_content": "    DCHECK(IsEmpty());",
          "content_same": false
        },
        {
          "line": 2191,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(!overflowed_)",
          "old_line_content": "void MarkCompactCollector::SetEmbedderHeapTracer(EmbedderHeapTracer* tracer) {",
          "new_line_content": "    DCHECK(!overflowed_);",
          "content_same": false
        },
        {
          "line": 2200,
          "old_api": null,
          "new_api": "CHECK_NULL",
          "old_text": null,
          "new_text": "CHECK_NULL(embedder_heap_tracer_)",
          "old_line_content": "    return;",
          "new_line_content": "  CHECK_NULL(embedder_heap_tracer_);",
          "content_same": false
        },
        {
          "line": 2205,
          "old_api": null,
          "new_api": "UsingEmbedderHeapTracer",
          "old_text": null,
          "new_text": "UsingEmbedderHeapTracer()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(UsingEmbedderHeapTracer());",
          "content_same": false
        },
        {
          "line": 2206,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "wrappers_to_trace_.empty()",
          "old_line_content": "void MarkCompactCollector::TracePossibleWrapper(JSObject* js_object) {",
          "new_line_content": "  if (wrappers_to_trace_.empty()) {",
          "content_same": false
        },
        {
          "line": 2216,
          "old_api": null,
          "new_api": "GetInternalField",
          "old_text": null,
          "new_text": "js_object->GetInternalField(0)",
          "old_line_content": "  }",
          "new_line_content": "      js_object->GetInternalField(0) &&",
          "content_same": false
        },
        {
          "line": 2217,
          "old_api": null,
          "new_api": "undefined_value",
          "old_text": null,
          "new_text": "heap_->undefined_value()",
          "old_line_content": "}",
          "new_line_content": "      js_object->GetInternalField(0) != heap_->undefined_value() &&",
          "content_same": false
        },
        {
          "line": 2218,
          "old_api": null,
          "new_api": "undefined_value",
          "old_text": null,
          "new_text": "heap_->undefined_value()",
          "old_line_content": "",
          "new_line_content": "      js_object->GetInternalField(1) != heap_->undefined_value()) {",
          "content_same": false
        },
        {
          "line": 2219,
          "old_api": null,
          "new_api": "GetInternalField",
          "old_text": null,
          "new_text": "js_object->GetInternalField(0)",
          "old_line_content": "void MarkCompactCollector::RegisterExternallyReferencedObject(Object** object) {",
          "new_line_content": "    DCHECK(reinterpret_cast<intptr_t>(js_object->GetInternalField(0)) % 2 == 0);",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": null,
          "new_api": "in_use",
          "old_text": null,
          "new_text": "in_use()",
          "old_line_content": "class MarkCompactCollector::ObjectStatsVisitor",
          "new_line_content": "  DCHECK(in_use());",
          "content_same": false
        },
        {
          "line": 2228,
          "old_api": null,
          "new_api": "HeapObject::cast(*object)",
          "old_text": null,
          "new_text": "HeapObject::cast(*object)",
          "old_line_content": "    : public MarkCompactCollector::HeapObjectVisitor {",
          "new_line_content": "  HeapObject* heap_object = HeapObject::cast(*object);",
          "content_same": false
        },
        {
          "line": 2229,
          "old_api": null,
          "new_api": "Contains",
          "old_text": null,
          "new_text": "heap_->Contains(heap_object)",
          "old_line_content": " public:",
          "new_line_content": "  DCHECK(heap_->Contains(heap_object));",
          "content_same": false
        },
        {
          "line": 2230,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(heap_object)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(heap_object)",
          "old_line_content": "  ObjectStatsVisitor(Heap* heap, ObjectStats* live_stats,",
          "new_line_content": "  MarkBit mark_bit = ObjectMarking::MarkBitFrom(heap_object);",
          "content_same": false
        },
        {
          "line": 2231,
          "old_api": null,
          "new_api": "MarkObject",
          "old_text": null,
          "new_text": "MarkObject(heap_object, mark_bit)",
          "old_line_content": "                     ObjectStats* dead_stats)",
          "new_line_content": "  MarkObject(heap_object, mark_bit);",
          "content_same": false
        },
        {
          "line": 2247,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(obj)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(obj)",
          "old_line_content": "  }",
          "new_line_content": "    if (Marking::IsBlack(ObjectMarking::MarkBitFrom(obj))) {",
          "content_same": false
        },
        {
          "line": 2248,
          "old_api": null,
          "new_api": "CollectStatistics",
          "old_text": null,
          "new_text": "live_collector_.CollectStatistics(obj)",
          "old_line_content": "",
          "new_line_content": "      live_collector_.CollectStatistics(obj);",
          "content_same": false
        },
        {
          "line": 2250,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(obj)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(obj)",
          "old_line_content": "  ObjectStatsCollector live_collector_;",
          "new_line_content": "      DCHECK(!Marking::IsGrey(ObjectMarking::MarkBitFrom(obj)));",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": null,
          "new_api": "CollectStatistics",
          "old_text": null,
          "new_text": "dead_collector_.CollectStatistics(obj)",
          "old_line_content": "  ObjectStatsCollector dead_collector_;",
          "new_line_content": "      dead_collector_.CollectStatistics(obj);",
          "content_same": false
        },
        {
          "line": 2264,
          "old_api": null,
          "new_api": "has_next",
          "old_text": null,
          "new_text": "space_it.has_next()",
          "old_line_content": "",
          "new_line_content": "  while (space_it.has_next()) {",
          "content_same": false
        },
        {
          "line": 2265,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "space_it.next()",
          "old_line_content": "void MarkCompactCollector::RecordObjectStats() {",
          "new_line_content": "    ObjectIterator* it = space_it.next();",
          "content_same": false
        },
        {
          "line": 2266,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "it->Next()",
          "old_line_content": "  if (FLAG_track_gc_object_stats) {",
          "new_line_content": "    while ((obj = it->Next()) != nullptr) {",
          "content_same": false
        },
        {
          "line": 2267,
          "old_api": null,
          "new_api": "Visit",
          "old_text": null,
          "new_text": "visitor->Visit(obj)",
          "old_line_content": "    ObjectStatsVisitor visitor(heap(), heap()->live_object_stats_,",
          "new_line_content": "      visitor->Visit(obj);",
          "content_same": false
        },
        {
          "line": 2276,
          "old_api": null,
          "new_api": "VisitAllObjects",
          "old_text": null,
          "new_text": "VisitAllObjects(&visitor)",
          "old_line_content": "  }",
          "new_line_content": "    VisitAllObjects(&visitor);",
          "content_same": false
        },
        {
          "line": 2278,
          "old_api": null,
          "new_api": "PrintJSON",
          "old_text": null,
          "new_text": "heap()->live_object_stats_->PrintJSON(\"live\")",
          "old_line_content": "",
          "new_line_content": "      heap()->live_object_stats_->PrintJSON(\"live\");",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": null,
          "new_api": "PrintJSON",
          "old_text": null,
          "new_text": "heap()->dead_object_stats_->PrintJSON(\"dead\")",
          "old_line_content": "void MarkCompactCollector::MarkLiveObjects() {",
          "new_line_content": "      heap()->dead_object_stats_->PrintJSON(\"dead\");",
          "content_same": false
        },
        {
          "line": 2281,
          "old_api": null,
          "new_api": "CheckpointObjectStats",
          "old_text": null,
          "new_text": "heap()->live_object_stats_->CheckpointObjectStats()",
          "old_line_content": "  double start_time = 0.0;",
          "new_line_content": "    heap()->live_object_stats_->CheckpointObjectStats();",
          "content_same": false
        },
        {
          "line": 2282,
          "old_api": null,
          "new_api": "ClearObjectStats",
          "old_text": null,
          "new_text": "heap()->dead_object_stats_->ClearObjectStats()",
          "old_line_content": "  if (FLAG_print_cumulative_gc_stat) {",
          "new_line_content": "    heap()->dead_object_stats_->ClearObjectStats();",
          "content_same": false
        },
        {
          "line": 2287,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()",
          "old_line_content": "  // with the C stack limit check.",
          "new_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_MARK);",
          "content_same": false
        },
        {
          "line": 2290,
          "old_api": null,
          "new_api": "MonotonicallyIncreasingTimeInMs",
          "old_text": null,
          "new_text": "heap_->MonotonicallyIncreasingTimeInMs()",
          "old_line_content": "  {",
          "new_line_content": "    start_time = heap_->MonotonicallyIncreasingTimeInMs();",
          "content_same": false
        },
        {
          "line": 2301,
          "old_api": null,
          "new_api": "Finalize",
          "old_text": null,
          "new_text": "incremental_marking->Finalize()",
          "old_line_content": "    }",
          "new_line_content": "      incremental_marking->Finalize();",
          "content_same": false
        },
        {
          "line": 2304,
          "old_api": null,
          "new_api": "Stop",
          "old_text": null,
          "new_text": "incremental_marking->Stop()",
          "old_line_content": "#ifdef DEBUG",
          "new_line_content": "      incremental_marking->Stop();",
          "content_same": false
        },
        {
          "line": 2306,
          "old_api": null,
          "new_api": "Uninitialize",
          "old_text": null,
          "new_text": "marking_deque_.Uninitialize(true)",
          "old_line_content": "  state_ = MARK_LIVE_OBJECTS;",
          "new_line_content": "        marking_deque_.Uninitialize(true);",
          "content_same": false
        },
        {
          "line": 2312,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(state_ == PREPARE_GC)",
          "old_line_content": "  {",
          "new_line_content": "  DCHECK(state_ == PREPARE_GC);",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": null,
          "new_api": "EnsureMarkingDequeIsCommittedAndInitialize",
          "old_text": null,
          "new_text": "EnsureMarkingDequeIsCommittedAndInitialize(\n      MarkCompactCollector::kMaxMarkingDequeSize)",
          "old_line_content": "",
          "new_line_content": "  EnsureMarkingDequeIsCommittedAndInitialize(",
          "content_same": false
        },
        {
          "line": 2327,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()",
          "old_line_content": "",
          "new_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_MARK_ROOTS);",
          "content_same": false
        },
        {
          "line": 2328,
          "old_api": null,
          "new_api": "MarkRoots",
          "old_text": null,
          "new_text": "MarkRoots(&root_visitor)",
          "old_line_content": "    // The objects reachable from the roots are marked, yet unreachable",
          "new_line_content": "    MarkRoots(&root_visitor);",
          "content_same": false
        },
        {
          "line": 2329,
          "old_api": null,
          "new_api": "ProcessTopOptimizedFrame",
          "old_text": null,
          "new_text": "ProcessTopOptimizedFrame(&root_visitor)",
          "old_line_content": "    // objects are unmarked.  Mark objects reachable due to host",
          "new_line_content": "    ProcessTopOptimizedFrame(&root_visitor);",
          "content_same": false
        },
        {
          "line": 2333,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()",
          "old_line_content": "               GCTracer::Scope::MC_MARK_WEAK_CLOSURE_EPHEMERAL);",
          "new_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_MARK_WEAK_CLOSURE);",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()",
          "old_line_content": "    // immediately reclaimed. Instead, we have to mark them as pending and mark",
          "new_line_content": "      TRACE_GC(heap()->tracer(),",
          "content_same": false
        },
        {
          "line": 2341,
          "old_api": null,
          "new_api": "ProcessEphemeralMarking",
          "old_text": null,
          "new_text": "ProcessEphemeralMarking(&root_visitor, false)",
          "old_line_content": "    //",
          "new_line_content": "      ProcessEphemeralMarking(&root_visitor, false);",
          "content_same": false
        },
        {
          "line": 2352,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()",
          "old_line_content": "",
          "new_line_content": "      TRACE_GC(heap()->tracer(),",
          "content_same": false
        },
        {
          "line": 2361,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()",
          "old_line_content": "    // the weak roots we just marked as pending destruction.",
          "new_line_content": "      TRACE_GC(heap()->tracer(),",
          "content_same": false
        },
        {
          "line": 2363,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "heap()->isolate()->global_handles()->IterateWeakRoots(&root_visitor)",
          "old_line_content": "    // We only process harmony collections, as all object groups have been fully",
          "new_line_content": "      heap()->isolate()->global_handles()->IterateWeakRoots(&root_visitor);",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": null,
          "new_api": "ProcessMarkingDeque",
          "old_text": null,
          "new_text": "ProcessMarkingDeque()",
          "old_line_content": "    // processed and no weakly reachable node can discover new objects groups.",
          "new_line_content": "      ProcessMarkingDeque();",
          "content_same": false
        },
        {
          "line": 2373,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()",
          "old_line_content": "",
          "new_line_content": "      TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_MARK_WEAK_CLOSURE_HARMONY);",
          "content_same": false
        },
        {
          "line": 2374,
          "old_api": null,
          "new_api": "ProcessEphemeralMarking",
          "old_text": null,
          "new_text": "ProcessEphemeralMarking(&root_visitor, true)",
          "old_line_content": "  if (FLAG_print_cumulative_gc_stat) {",
          "new_line_content": "      ProcessEphemeralMarking(&root_visitor, true);",
          "content_same": false
        },
        {
          "line": 2376,
          "old_api": null,
          "new_api": "TraceEpilogue",
          "old_text": null,
          "new_text": "embedder_heap_tracer()->TraceEpilogue()",
          "old_line_content": "                                    start_time);",
          "new_line_content": "        embedder_heap_tracer()->TraceEpilogue();",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()",
          "old_line_content": "    // table is marked.",
          "new_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_CLEAR);",
          "content_same": false
        },
        {
          "line": 2399,
          "old_api": null,
          "new_api": "IterateElements",
          "old_text": null,
          "new_text": "string_table->IterateElements(&internalized_visitor)",
          "old_line_content": "",
          "new_line_content": "    string_table->IterateElements(&internalized_visitor);",
          "content_same": false
        },
        {
          "line": 2400,
          "old_api": null,
          "new_api": "PointersRemoved",
          "old_text": null,
          "new_text": "internalized_visitor.PointersRemoved()",
          "old_line_content": "  {",
          "new_line_content": "    string_table->ElementsRemoved(internalized_visitor.PointersRemoved());",
          "content_same": false
        },
        {
          "line": 2403,
          "old_api": null,
          "new_api": "Iterate",
          "old_text": null,
          "new_text": "heap()->external_string_table_.Iterate(&external_visitor)",
          "old_line_content": "    MarkCompactWeakObjectRetainer mark_compact_object_retainer;",
          "new_line_content": "    heap()->external_string_table_.Iterate(&external_visitor);",
          "content_same": false
        },
        {
          "line": 2415,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()",
          "old_line_content": "  // Flush code from collected candidates.",
          "new_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_CLEAR_GLOBAL_HANDLES);",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "heap()->isolate()->global_handles()->RemoveImplicitRefGroups()",
          "old_line_content": "  }",
          "new_line_content": "    heap()->isolate()->global_handles()->RemoveImplicitRefGroups();",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": null,
          "new_api": "is_code_flushing_enabled",
          "old_text": null,
          "new_text": "is_code_flushing_enabled()",
          "old_line_content": "  Object* non_live_map_list;",
          "new_line_content": "  if (is_code_flushing_enabled()) {",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": null,
          "new_api": "ProcessCandidates",
          "old_text": null,
          "new_text": "code_flusher_->ProcessCandidates()",
          "old_line_content": "",
          "new_line_content": "    code_flusher_->ProcessCandidates();",
          "content_same": false
        },
        {
          "line": 2431,
          "old_api": null,
          "new_api": "ClearWeakCells",
          "old_text": null,
          "new_text": "ClearWeakCells(&non_live_map_list, &dependent_code_list)",
          "old_line_content": "",
          "new_line_content": "  ClearWeakCells(&non_live_map_list, &dependent_code_list);",
          "content_same": false
        },
        {
          "line": 2435,
          "old_api": null,
          "new_api": "ClearSimpleMapTransitions",
          "old_text": null,
          "new_text": "ClearSimpleMapTransitions(non_live_map_list)",
          "old_line_content": "",
          "new_line_content": "    ClearSimpleMapTransitions(non_live_map_list);",
          "content_same": false
        },
        {
          "line": 2439,
          "old_api": null,
          "new_api": "MarkDependentCodeForDeoptimization",
          "old_text": null,
          "new_text": "MarkDependentCodeForDeoptimization(dependent_code_list)",
          "old_line_content": "",
          "new_line_content": "  MarkDependentCodeForDeoptimization(dependent_code_list);",
          "content_same": false
        },
        {
          "line": 2441,
          "old_api": null,
          "new_api": "ClearWeakCollections",
          "old_text": null,
          "new_text": "ClearWeakCollections()",
          "old_line_content": "    DependentCode* list_head) {",
          "new_line_content": "  ClearWeakCollections();",
          "content_same": false
        },
        {
          "line": 2449,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()",
          "old_line_content": "  }",
          "new_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_CLEAR_DEPENDENT_CODE);",
          "content_same": false
        },
        {
          "line": 2450,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "this->isolate()",
          "old_line_content": "",
          "new_line_content": "  Isolate* isolate = this->isolate();",
          "content_same": false
        },
        {
          "line": 2453,
          "old_api": null,
          "new_api": "MarkCodeForDeoptimization",
          "old_text": null,
          "new_text": "current->MarkCodeForDeoptimization(\n        isolate, DependentCode::kWeakCodeGroup)",
          "old_line_content": "    int counter = 0;",
          "new_line_content": "    have_code_to_deoptimize_ |= current->MarkCodeForDeoptimization(",
          "content_same": false
        },
        {
          "line": 2462,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "list->Get(i)",
          "old_line_content": "                code, DependentCode::DependencyGroup::kWeakCodeGroup);",
          "new_line_content": "      WeakCell* obj = WeakCell::cast(list->Get(i));",
          "content_same": false
        },
        {
          "line": 2464,
          "old_api": null,
          "new_api": "cleared",
          "old_text": null,
          "new_text": "dep->cleared()",
          "old_line_content": "            have_code_to_deoptimize_ = true;",
          "new_line_content": "      if (obj->cleared() || dep->cleared()) {",
          "content_same": false
        },
        {
          "line": 2465,
          "old_api": null,
          "new_api": "cleared",
          "old_text": null,
          "new_text": "dep->cleared()",
          "old_line_content": "          }",
          "new_line_content": "        if (!dep->cleared()) {",
          "content_same": false
        },
        {
          "line": 2466,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "dep->value()",
          "old_line_content": "        }",
          "new_line_content": "          Code* code = Code::cast(dep->value());",
          "content_same": false
        },
        {
          "line": 2467,
          "old_api": null,
          "new_api": "marked_for_deoptimization",
          "old_text": null,
          "new_text": "code->marked_for_deoptimization()",
          "old_line_content": "      } else {",
          "new_line_content": "          if (!code->marked_for_deoptimization()) {",
          "content_same": false
        },
        {
          "line": 2468,
          "old_api": null,
          "new_api": "DependentCode::SetMarkedForDeoptimization(\n                code, DependentCode::DependencyGroup::kWeakCodeGroup)",
          "old_text": null,
          "new_text": "DependentCode::SetMarkedForDeoptimization(\n                code, DependentCode::DependencyGroup::kWeakCodeGroup)",
          "old_line_content": "        // We record the slot manually because marking is finished at this",
          "new_line_content": "            DependentCode::SetMarkedForDeoptimization(",
          "content_same": false
        },
        {
          "line": 2477,
          "old_api": null,
          "new_api": "Set",
          "old_text": null,
          "new_text": "list->Set(counter, obj, SKIP_WRITE_BARRIER)",
          "old_line_content": "    }",
          "new_line_content": "        list->Set(counter, obj, SKIP_WRITE_BARRIER);",
          "content_same": false
        },
        {
          "line": 2478,
          "old_api": null,
          "new_api": "Slot",
          "old_text": null,
          "new_text": "list->Slot(counter)",
          "old_line_content": "  }",
          "new_line_content": "        RecordSlot(list, list->Slot(counter), obj);",
          "content_same": false
        },
        {
          "line": 2490,
          "old_api": null,
          "new_api": "EntryToIndex",
          "old_text": null,
          "new_text": "table->EntryToIndex(i)",
          "old_line_content": "      have_code_to_deoptimize_ |=",
          "new_line_content": "    uint32_t key_index = table->EntryToIndex(i);",
          "content_same": false
        },
        {
          "line": 2492,
          "old_api": null,
          "new_api": "IsKey",
          "old_text": null,
          "new_text": "table->IsKey(isolate, key)",
          "old_line_content": "              isolate, DependentCode::kWeakCodeGroup);",
          "new_line_content": "    if (!table->IsKey(isolate, key)) continue;",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": null,
          "new_api": "cleared",
          "old_text": null,
          "new_text": "WeakCell::cast(key)->cleared()",
          "old_line_content": "    }",
          "new_line_content": "    if (WeakCell::cast(key)->cleared()) {",
          "content_same": false
        },
        {
          "line": 2498,
          "old_api": null,
          "new_api": "MarkCodeForDeoptimization",
          "old_text": null,
          "new_text": "DependentCode::cast(value)->MarkCodeForDeoptimization(\n              isolate, DependentCode::kWeakCodeGroup)",
          "old_line_content": "}",
          "new_line_content": "          DependentCode::cast(value)->MarkCodeForDeoptimization(",
          "content_same": false
        },
        {
          "line": 2500,
          "old_api": null,
          "new_api": "the_hole_value",
          "old_text": null,
          "new_text": "heap_->the_hole_value()",
          "old_line_content": "",
          "new_line_content": "      table->set(key_index, heap_->the_hole_value());",
          "content_same": false
        },
        {
          "line": 2501,
          "old_api": null,
          "new_api": "the_hole_value",
          "old_text": null,
          "new_text": "heap_->the_hole_value()",
          "old_line_content": "void MarkCompactCollector::ClearSimpleMapTransitions(",
          "new_line_content": "      table->set(value_index, heap_->the_hole_value());",
          "content_same": false
        },
        {
          "line": 2502,
          "old_api": null,
          "new_api": "ElementRemoved",
          "old_text": null,
          "new_text": "table->ElementRemoved()",
          "old_line_content": "    Object* non_live_map_list) {",
          "new_line_content": "      table->ElementRemoved();",
          "content_same": false
        },
        {
          "line": 2515,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(map)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(map)",
          "old_line_content": "      }",
          "new_line_content": "    DCHECK(Marking::IsWhite(ObjectMarking::MarkBitFrom(map)));",
          "content_same": false
        },
        {
          "line": 2516,
          "old_api": null,
          "new_api": "constructor_or_backpointer",
          "old_text": null,
          "new_text": "map->constructor_or_backpointer()",
          "old_line_content": "    }",
          "new_line_content": "    Object* potential_parent = map->constructor_or_backpointer();",
          "content_same": false
        },
        {
          "line": 2520,
          "old_api": null,
          "new_api": "raw_transitions",
          "old_text": null,
          "new_text": "parent->raw_transitions()",
          "old_line_content": "  }",
          "new_line_content": "          parent->raw_transitions() == weak_cell) {",
          "content_same": false
        },
        {
          "line": 2521,
          "old_api": null,
          "new_api": "ClearSimpleMapTransition",
          "old_text": null,
          "new_text": "ClearSimpleMapTransition(parent, map)",
          "old_line_content": "}",
          "new_line_content": "        ClearSimpleMapTransition(parent, map);",
          "content_same": false
        },
        {
          "line": 2524,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "weak_cell->clear()",
          "old_line_content": "void MarkCompactCollector::ClearSimpleMapTransition(Map* map,",
          "new_line_content": "    weak_cell->clear();",
          "content_same": false
        },
        {
          "line": 2525,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "weak_cell->next()",
          "old_line_content": "                                                    Map* dead_transition) {",
          "new_line_content": "    weak_cell_obj = weak_cell->next();",
          "content_same": false
        },
        {
          "line": 2526,
          "old_api": null,
          "new_api": "clear_next",
          "old_text": null,
          "new_text": "weak_cell->clear_next(the_hole_value)",
          "old_line_content": "  // A previously existing simple transition (stored in a WeakCell) is going",
          "new_line_content": "    weak_cell->clear_next(the_hole_value);",
          "content_same": false
        },
        {
          "line": 2537,
          "old_api": null,
          "new_api": "NumberOfOwnDescriptors",
          "old_text": null,
          "new_text": "map->NumberOfOwnDescriptors()",
          "old_line_content": "  }",
          "new_line_content": "  int number_of_own_descriptors = map->NumberOfOwnDescriptors();",
          "content_same": false
        },
        {
          "line": 2538,
          "old_api": null,
          "new_api": "instance_descriptors",
          "old_text": null,
          "new_text": "map->instance_descriptors()",
          "old_line_content": "}",
          "new_line_content": "  DescriptorArray* descriptors = map->instance_descriptors();",
          "content_same": false
        },
        {
          "line": 2539,
          "old_api": null,
          "new_api": "instance_descriptors",
          "old_text": null,
          "new_text": "dead_transition->instance_descriptors()",
          "old_line_content": "",
          "new_line_content": "  if (descriptors == dead_transition->instance_descriptors() &&",
          "content_same": false
        },
        {
          "line": 2541,
          "old_api": null,
          "new_api": "TrimDescriptorArray",
          "old_text": null,
          "new_text": "TrimDescriptorArray(map, descriptors)",
          "old_line_content": "void MarkCompactCollector::ClearFullMapTransitions() {",
          "new_line_content": "    TrimDescriptorArray(map, descriptors);",
          "content_same": false
        },
        {
          "line": 2551,
          "old_api": null,
          "new_api": "Smi::FromInt(0)",
          "old_text": null,
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "      bool parent_is_alive =",
          "new_line_content": "  while (obj != Smi::FromInt(0)) {",
          "content_same": false
        },
        {
          "line": 2553,
          "old_api": null,
          "new_api": "number_of_entries",
          "old_text": null,
          "new_text": "array->number_of_entries()",
          "old_line_content": "      DescriptorArray* descriptors =",
          "new_line_content": "    int num_transitions = array->number_of_entries();",
          "content_same": false
        },
        {
          "line": 2557,
          "old_api": null,
          "new_api": "constructor_or_backpointer",
          "old_text": null,
          "new_text": "map->constructor_or_backpointer()",
          "old_line_content": "      if (descriptors_owner_died) {",
          "new_line_content": "      Map* parent = Map::cast(map->constructor_or_backpointer());",
          "content_same": false
        },
        {
          "line": 2559,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(parent)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(parent)",
          "old_line_content": "      }",
          "new_line_content": "          Marking::IsBlackOrGrey(ObjectMarking::MarkBitFrom(parent));",
          "content_same": false
        },
        {
          "line": 2563,
          "old_api": null,
          "new_api": "CompactTransitionArray",
          "old_text": null,
          "new_text": "CompactTransitionArray(parent, array, descriptors)",
          "old_line_content": "  }",
          "new_line_content": "          CompactTransitionArray(parent, array, descriptors);",
          "content_same": false
        },
        {
          "line": 2565,
          "old_api": null,
          "new_api": "TrimDescriptorArray",
          "old_text": null,
          "new_text": "TrimDescriptorArray(parent, descriptors)",
          "old_line_content": "}",
          "new_line_content": "        TrimDescriptorArray(parent, descriptors);",
          "content_same": false
        },
        {
          "line": 2568,
          "old_api": null,
          "new_api": "next_link",
          "old_text": null,
          "new_text": "array->next_link()",
          "old_line_content": "bool MarkCompactCollector::CompactTransitionArray(",
          "new_line_content": "    obj = array->next_link();",
          "content_same": false
        },
        {
          "line": 2569,
          "old_api": null,
          "new_api": "set_next_link",
          "old_text": null,
          "new_text": "array->set_next_link(undefined, SKIP_WRITE_BARRIER)",
          "old_line_content": "    Map* map, TransitionArray* transitions, DescriptorArray* descriptors) {",
          "new_line_content": "    array->set_next_link(undefined, SKIP_WRITE_BARRIER);",
          "content_same": false
        },
        {
          "line": 2571,
          "old_api": null,
          "new_api": "Smi::FromInt(0)",
          "old_text": null,
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "  bool descriptors_owner_died = false;",
          "new_line_content": "  heap()->set_encountered_transition_arrays(Smi::FromInt(0));",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": null,
          "new_api": "GetTarget",
          "old_text": null,
          "new_text": "transitions->GetTarget(i)",
          "old_line_content": "    } else {",
          "new_line_content": "    Map* target = transitions->GetTarget(i);",
          "content_same": false
        },
        {
          "line": 2583,
          "old_api": null,
          "new_api": "constructor_or_backpointer",
          "old_text": null,
          "new_text": "target->constructor_or_backpointer()",
          "old_line_content": "      if (i != transition_index) {",
          "new_line_content": "    DCHECK_EQ(target->constructor_or_backpointer(), map);",
          "content_same": false
        },
        {
          "line": 2591,
          "old_api": null,
          "new_api": "GetKey",
          "old_text": null,
          "new_text": "transitions->GetKey(i)",
          "old_line_content": "      transition_index++;",
          "new_line_content": "        Name* key = transitions->GetKey(i);",
          "content_same": false
        },
        {
          "line": 2592,
          "old_api": null,
          "new_api": "SetKey",
          "old_text": null,
          "new_text": "transitions->SetKey(transition_index, key)",
          "old_line_content": "    }",
          "new_line_content": "        transitions->SetKey(transition_index, key);",
          "content_same": false
        },
        {
          "line": 2593,
          "old_api": null,
          "new_api": "GetKeySlot",
          "old_text": null,
          "new_text": "transitions->GetKeySlot(transition_index)",
          "old_line_content": "  }",
          "new_line_content": "        Object** key_slot = transitions->GetKeySlot(transition_index);",
          "content_same": false
        },
        {
          "line": 2594,
          "old_api": null,
          "new_api": "RecordSlot",
          "old_text": null,
          "new_text": "RecordSlot(transitions, key_slot, key)",
          "old_line_content": "  // If there are no transitions to be cleared, return.",
          "new_line_content": "        RecordSlot(transitions, key_slot, key);",
          "content_same": false
        },
        {
          "line": 2610,
          "old_api": null,
          "new_api": "TransitionArray::Capacity(transitions)",
          "old_text": null,
          "new_text": "TransitionArray::Capacity(transitions)",
          "old_line_content": "}",
          "new_line_content": "  int trim = TransitionArray::Capacity(transitions) - transition_index;",
          "content_same": false
        },
        {
          "line": 2612,
          "old_api": null,
          "new_api": "heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(\n        transitions, trim * TransitionArray::kTransitionSize)",
          "old_text": null,
          "new_text": "heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(\n        transitions, trim * TransitionArray::kTransitionSize)",
          "old_line_content": "",
          "new_line_content": "    heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(",
          "content_same": false
        },
        {
          "line": 2614,
          "old_api": null,
          "new_api": "SetNumberOfTransitions",
          "old_text": null,
          "new_text": "transitions->SetNumberOfTransitions(transition_index)",
          "old_line_content": "                                               DescriptorArray* descriptors) {",
          "new_line_content": "    transitions->SetNumberOfTransitions(transition_index);",
          "content_same": false
        },
        {
          "line": 2622,
          "old_api": null,
          "new_api": "NumberOfOwnDescriptors",
          "old_text": null,
          "new_text": "map->NumberOfOwnDescriptors()",
          "old_line_content": "  int to_trim = number_of_descriptors - number_of_own_descriptors;",
          "new_line_content": "  int number_of_own_descriptors = map->NumberOfOwnDescriptors();",
          "content_same": false
        },
        {
          "line": 2631,
          "old_api": null,
          "new_api": "heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(\n        descriptors, to_trim * DescriptorArray::kDescriptorSize)",
          "old_text": null,
          "new_text": "heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(\n        descriptors, to_trim * DescriptorArray::kDescriptorSize)",
          "old_line_content": "    if (FLAG_unbox_double_fields) {",
          "new_line_content": "    heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(",
          "content_same": false
        },
        {
          "line": 2636,
          "old_api": null,
          "new_api": "Sort",
          "old_text": null,
          "new_text": "descriptors->Sort()",
          "old_line_content": "    }",
          "new_line_content": "    descriptors->Sort();",
          "content_same": false
        },
        {
          "line": 2640,
          "old_api": null,
          "new_api": "Trim",
          "old_text": null,
          "new_text": "layout_descriptor->Trim(heap_, map, descriptors,\n                                                  number_of_own_descriptors)",
          "old_line_content": "}",
          "new_line_content": "      layout_descriptor = layout_descriptor->Trim(heap_, map, descriptors,",
          "content_same": false
        },
        {
          "line": 2642,
          "old_api": null,
          "new_api": "IsConsistentWithMap",
          "old_text": null,
          "new_text": "layout_descriptor->IsConsistentWithMap(map, true)",
          "old_line_content": "",
          "new_line_content": "      SLOW_DCHECK(layout_descriptor->IsConsistentWithMap(map, true));",
          "content_same": false
        },
        {
          "line": 2646,
          "old_api": null,
          "new_api": "set_owns_descriptors",
          "old_text": null,
          "new_text": "map->set_owns_descriptors(true)",
          "old_line_content": "  if (live_enum == kInvalidEnumCacheSentinel) {",
          "new_line_content": "  map->set_owns_descriptors(true);",
          "content_same": false
        },
        {
          "line": 2655,
          "old_api": null,
          "new_api": "NumberOfDescribedProperties",
          "old_text": null,
          "new_text": "map->NumberOfDescribedProperties(OWN_DESCRIPTORS, ENUMERABLE_STRINGS)",
          "old_line_content": "  if (to_trim <= 0) return;",
          "new_line_content": "        map->NumberOfDescribedProperties(OWN_DESCRIPTORS, ENUMERABLE_STRINGS);",
          "content_same": false
        },
        {
          "line": 2663,
          "old_api": null,
          "new_api": "GetEnumCache",
          "old_text": null,
          "new_text": "heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(\n      descriptors->GetEnumCache(), to_trim)",
          "old_line_content": "}",
          "new_line_content": "  heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": null,
          "new_api": "ShouldReduceMemory",
          "old_text": null,
          "new_text": "heap()->ShouldReduceMemory()",
          "old_line_content": "  } else {",
          "new_line_content": "  if (heap()->ShouldReduceMemory()) {",
          "content_same": false
        },
        {
          "line": 2664,
          "old_api": null,
          "new_api": "GetEnumCache",
          "old_text": null,
          "new_text": "descriptors->GetEnumCache()",
          "old_line_content": "",
          "new_line_content": "      descriptors->GetEnumCache(), to_trim);",
          "content_same": false
        },
        {
          "line": 2666,
          "old_api": null,
          "new_api": "HasEnumIndicesCache",
          "old_text": null,
          "new_text": "descriptors->HasEnumIndicesCache()",
          "old_line_content": "void MarkCompactCollector::ProcessWeakCollections() {",
          "new_line_content": "  if (!descriptors->HasEnumIndicesCache()) return;",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": null,
          "new_api": "ShouldOptimizeForMemoryUsage",
          "old_text": null,
          "new_text": "heap()->ShouldOptimizeForMemoryUsage()",
          "old_line_content": "    if (estimated_compaction_speed != 0) {",
          "new_line_content": "  } else if (heap()->ShouldOptimizeForMemoryUsage()) {",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()->CompactionSpeedInBytesPerMillisecond()",
          "old_line_content": "          100 - 100 * kTargetMsPerArea / estimated_ms_per_area);",
          "new_line_content": "        heap()->tracer()->CompactionSpeedInBytesPerMillisecond();",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": null,
          "new_api": "static_cast<int>(\n          100 - 100 * kTargetMsPerArea / estimated_ms_per_area)",
          "old_text": null,
          "new_text": "static_cast<int>(\n          100 - 100 * kTargetMsPerArea / estimated_ms_per_area)",
          "old_line_content": "    } else {",
          "new_line_content": "      *target_fragmentation_percent = static_cast<int>(",
          "content_same": false
        },
        {
          "line": 2679,
          "old_api": null,
          "new_api": "table",
          "old_text": null,
          "new_text": "weak_collection->table()->IsHashTable()",
          "old_line_content": "          Object** value_slot =",
          "new_line_content": "    if (weak_collection->table()->IsHashTable()) {",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": null,
          "new_api": "KeyAt",
          "old_text": null,
          "new_text": "table->KeyAt(i)",
          "old_line_content": "                                                         value_slot);",
          "new_line_content": "        if (MarkCompactCollector::IsMarked(HeapObject::cast(table->KeyAt(i)))) {",
          "content_same": false
        },
        {
          "line": 2684,
          "old_api": null,
          "new_api": "ObjectHashTable::EntryToIndex(i)",
          "old_text": null,
          "new_text": "ObjectHashTable::EntryToIndex(i)",
          "old_line_content": "      }",
          "new_line_content": "              table->RawFieldOfElementAt(ObjectHashTable::EntryToIndex(i));",
          "content_same": false
        },
        {
          "line": 2685,
          "old_api": null,
          "new_api": "RecordSlot",
          "old_text": null,
          "new_text": "RecordSlot(table, key_slot, *key_slot)",
          "old_line_content": "    }",
          "new_line_content": "          RecordSlot(table, key_slot, *key_slot);",
          "content_same": false
        },
        {
          "line": 2687,
          "old_api": null,
          "new_api": "ObjectHashTable::EntryToValueIndex(i)",
          "old_text": null,
          "new_text": "ObjectHashTable::EntryToValueIndex(i)",
          "old_line_content": "  }",
          "new_line_content": "              table->RawFieldOfElementAt(ObjectHashTable::EntryToValueIndex(i));",
          "content_same": false
        },
        {
          "line": 2688,
          "old_api": null,
          "new_api": "MarkCompactMarkingVisitor::MarkObjectByPointer(this, table,\n                                                         value_slot)",
          "old_text": null,
          "new_text": "MarkCompactMarkingVisitor::MarkObjectByPointer(this, table,\n                                                         value_slot)",
          "old_line_content": "}",
          "new_line_content": "          MarkCompactMarkingVisitor::MarkObjectByPointer(this, table,",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "space->identity()",
          "old_line_content": "  std::vector<LiveBytesPagePair> pages;",
          "new_line_content": "  DCHECK(space->identity() == OLD_SPACE || space->identity() == CODE_SPACE);",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": null,
          "new_api": "CountTotalPages",
          "old_text": null,
          "new_text": "space->CountTotalPages()",
          "old_line_content": "",
          "new_line_content": "  int number_of_pages = space->CountTotalPages();",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": null,
          "new_api": "AreaSize",
          "old_text": null,
          "new_text": "space->AreaSize()",
          "old_line_content": "  for (Page* p : *space) {",
          "new_line_content": "  int area_size = space->AreaSize();",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "pages.reserve(number_of_pages)",
          "old_line_content": "    // released.",
          "new_line_content": "  pages.reserve(number_of_pages);",
          "content_same": false
        },
        {
          "line": 2704,
          "old_api": null,
          "new_api": "MarkCompactCollector::IsMarked(weak_collection)",
          "old_text": null,
          "new_text": "MarkCompactCollector::IsMarked(weak_collection)",
          "old_line_content": "        }",
          "new_line_content": "    DCHECK(MarkCompactCollector::IsMarked(weak_collection));",
          "content_same": false
        },
        {
          "line": 2705,
          "old_api": null,
          "new_api": "table",
          "old_text": null,
          "new_text": "weak_collection->table()->IsHashTable()",
          "old_line_content": "      }",
          "new_line_content": "    if (weak_collection->table()->IsHashTable()) {",
          "content_same": false
        },
        {
          "line": 2706,
          "old_api": null,
          "new_api": "table",
          "old_text": null,
          "new_text": "weak_collection->table()",
          "old_line_content": "    }",
          "new_line_content": "      ObjectHashTable* table = ObjectHashTable::cast(weak_collection->table());",
          "content_same": false
        },
        {
          "line": 2709,
          "old_api": null,
          "new_api": "MarkCompactCollector::IsMarked(key)",
          "old_text": null,
          "new_text": "MarkCompactCollector::IsMarked(key)",
          "old_line_content": "  }",
          "new_line_content": "        if (!MarkCompactCollector::IsMarked(key)) {",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": null,
          "new_api": "IsEvacuationCandidate",
          "old_text": null,
          "new_text": "p->IsEvacuationCandidate()",
          "old_line_content": "",
          "new_line_content": "    CHECK(!p->IsEvacuationCandidate());",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "old_to_old_slots",
          "old_text": null,
          "new_text": "p->old_to_old_slots()",
          "old_line_content": "  int candidate_count = 0;",
          "new_line_content": "    CHECK_NULL(p->old_to_old_slots());",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": null,
          "new_api": "typed_old_to_old_slots",
          "old_text": null,
          "new_text": "p->typed_old_to_old_slots()",
          "old_line_content": "  int total_live_bytes = 0;",
          "new_line_content": "    CHECK_NULL(p->typed_old_to_old_slots());",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": null,
          "new_api": "SweepingDone",
          "old_text": null,
          "new_text": "p->SweepingDone()",
          "old_line_content": "",
          "new_line_content": "    CHECK(p->SweepingDone());",
          "content_same": false
        },
        {
          "line": 2714,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "weak_collection->next()",
          "old_line_content": "void MarkCompactCollector::AbortWeakCollections() {",
          "new_line_content": "    weak_collection_obj = weak_collection->next();",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": null,
          "new_api": "LiveBytesFromFreeList",
          "old_text": null,
          "new_text": "p->LiveBytesFromFreeList()",
          "old_line_content": "  if (FLAG_manual_evacuation_candidates_selection) {",
          "new_line_content": "    pages.push_back(std::make_pair(p->LiveBytesFromFreeList(), p));",
          "content_same": false
        },
        {
          "line": 2717,
          "old_api": null,
          "new_api": "Smi::FromInt(0)",
          "old_text": null,
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "    JSWeakCollection* weak_collection =",
          "new_line_content": "  heap()->set_encountered_weak_collections(Smi::FromInt(0));",
          "content_same": false
        },
        {
          "line": 2723,
          "old_api": null,
          "new_api": "Smi::FromInt(0)",
          "old_text": null,
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "}",
          "new_line_content": "  while (weak_collection_obj != Smi::FromInt(0)) {",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "pages.size()",
          "old_line_content": "      }",
          "new_line_content": "    for (size_t i = 0; i < pages.size(); i++) {",
          "content_same": false
        },
        {
          "line": 2725,
          "old_api": null,
          "new_api": "reinterpret_cast<JSWeakCollection*>(weak_collection_obj)",
          "old_text": null,
          "new_text": "reinterpret_cast<JSWeakCollection*>(weak_collection_obj)",
          "old_line_content": "",
          "new_line_content": "        reinterpret_cast<JSWeakCollection*>(weak_collection_obj);",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": null,
          "new_api": "IsFlagSet",
          "old_text": null,
          "new_text": "p->IsFlagSet(MemoryChunk::FORCE_EVACUATION_CANDIDATE_FOR_TESTING)",
          "old_line_content": "  } else if (FLAG_stress_compaction) {",
          "new_line_content": "      if (p->IsFlagSet(MemoryChunk::FORCE_EVACUATION_CANDIDATE_FOR_TESTING)) {",
          "content_same": false
        },
        {
          "line": 2726,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "weak_collection->next()",
          "old_line_content": "void MarkCompactCollector::ClearWeakCells(Object** non_live_map_list,",
          "new_line_content": "    weak_collection_obj = weak_collection->next();",
          "content_same": false
        },
        {
          "line": 2727,
          "old_api": null,
          "new_api": "undefined_value",
          "old_text": null,
          "new_text": "heap()->undefined_value()",
          "old_line_content": "                                          DependentCode** dependent_code_list) {",
          "new_line_content": "    weak_collection->set_next(heap()->undefined_value());",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": null,
          "new_api": "ClearFlag",
          "old_text": null,
          "new_text": "p->ClearFlag(MemoryChunk::FORCE_EVACUATION_CANDIDATE_FOR_TESTING)",
          "old_line_content": "      if (i % 2 == 0) {",
          "new_line_content": "        p->ClearFlag(MemoryChunk::FORCE_EVACUATION_CANDIDATE_FOR_TESTING);",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": null,
          "new_api": "AddEvacuationCandidate",
          "old_text": null,
          "new_text": "AddEvacuationCandidate(p)",
          "old_line_content": "        candidate_count++;",
          "new_line_content": "        AddEvacuationCandidate(p);",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "pages.size()",
          "old_line_content": "    }",
          "new_line_content": "    for (size_t i = 0; i < pages.size(); i++) {",
          "content_same": false
        },
        {
          "line": 2738,
          "old_api": null,
          "new_api": "the_hole_value",
          "old_text": null,
          "new_text": "heap->the_hole_value()",
          "old_line_content": "    bool clear_value = true;",
          "new_line_content": "  Object* the_hole_value = heap->the_hole_value();",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": null,
          "new_api": "AddEvacuationCandidate",
          "old_text": null,
          "new_text": "AddEvacuationCandidate(p)",
          "old_line_content": "    // candidate, or not:",
          "new_line_content": "        AddEvacuationCandidate(p);",
          "content_same": false
        },
        {
          "line": 2740,
          "old_api": null,
          "new_api": "empty_fixed_array",
          "old_text": null,
          "new_text": "heap->empty_fixed_array()",
          "old_line_content": "    // We do not insert cleared weak cells into the list, so the value",
          "new_line_content": "      DependentCode::cast(heap->empty_fixed_array());",
          "content_same": false
        },
        {
          "line": 2741,
          "old_api": null,
          "new_api": "Smi::FromInt(0)",
          "old_text": null,
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "    // cannot be a Smi here.",
          "new_line_content": "  Object* non_live_map_head = Smi::FromInt(0);",
          "content_same": false
        },
        {
          "line": 2744,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "weak_cell->next()",
          "old_line_content": "      // Cells for new-space objects embedded in optimized code are wrapped in",
          "new_line_content": "    Object* next_weak_cell = weak_cell->next();",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": null,
          "new_api": "ComputeEvacuationHeuristics",
          "old_text": null,
          "new_text": "ComputeEvacuationHeuristics(area_size, &target_fragmentation_percent,\n                                &max_evacuated_bytes)",
          "old_line_content": "    // the first n pages for evacuation such that:",
          "new_line_content": "    ComputeEvacuationHeuristics(area_size, &target_fragmentation_percent,",
          "content_same": false
        },
        {
          "line": 2761,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(value)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(value)",
          "old_line_content": "        }",
          "new_line_content": "          MarkBit mark = ObjectMarking::MarkBitFrom(value);",
          "content_same": false
        },
        {
          "line": 2762,
          "old_api": null,
          "new_api": "SetMark",
          "old_text": null,
          "new_text": "SetMark(value, mark)",
          "old_line_content": "      }",
          "new_line_content": "          SetMark(value, mark);",
          "content_same": false
        },
        {
          "line": 2764,
          "old_api": null,
          "new_api": "RecordSlot",
          "old_text": null,
          "new_text": "RecordSlot(value, slot, *slot)",
          "old_line_content": "        // The map is non-live.",
          "new_line_content": "          RecordSlot(value, slot, *slot);",
          "content_same": false
        },
        {
          "line": 2766,
          "old_api": null,
          "new_api": "RecordSlot",
          "old_text": null,
          "new_text": "RecordSlot(weak_cell, slot, *slot)",
          "old_line_content": "        // Add dependent code to the dependent_code_list.",
          "new_line_content": "          RecordSlot(weak_cell, slot, *slot);",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "pages.end()",
          "old_line_content": "      if (FLAG_always_compact ||",
          "new_line_content": "    std::sort(pages.begin(), pages.end(),",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "pages.size()",
          "old_line_content": "        total_live_bytes += live_bytes;",
          "new_line_content": "    for (size_t i = 0; i < pages.size(); i++) {",
          "content_same": false
        },
        {
          "line": 2774,
          "old_api": null,
          "new_api": "dependent_code",
          "old_text": null,
          "new_text": "map->dependent_code()",
          "old_line_content": "        }",
          "new_line_content": "        DependentCode* candidate = map->dependent_code();",
          "content_same": false
        },
        {
          "line": 2777,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "candidate->length()",
          "old_line_content": "        non_live_map_head = weak_cell;",
          "new_line_content": "        if (candidate->length() > 0 &&",
          "content_same": false
        },
        {
          "line": 2778,
          "old_api": null,
          "new_api": "group",
          "old_text": null,
          "new_text": "candidate->group()",
          "old_line_content": "        clear_value = false;",
          "new_line_content": "            candidate->group() == DependentCode::kWeakCodeGroup) {",
          "content_same": false
        },
        {
          "line": 2779,
          "old_api": null,
          "new_api": "set_next_link",
          "old_text": null,
          "new_text": "candidate->set_next_link(dependent_code_head)",
          "old_line_content": "        clear_next = false;",
          "new_line_content": "          candidate->set_next_link(dependent_code_head);",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "isolate()",
          "old_line_content": "                     total_live_bytes / KB, max_evacuated_bytes / KB);",
          "new_line_content": "        PrintIsolate(isolate(),",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "space->identity()",
          "old_line_content": "    int estimated_new_pages = (total_live_bytes + area_size - 1) / area_size;",
          "new_line_content": "                     AllocationSpaceName(space->identity()), free_bytes / KB,",
          "content_same": false
        },
        {
          "line": 2790,
          "old_api": null,
          "new_api": "HeapObject::RawField(weak_cell, WeakCell::kValueOffset)",
          "old_text": null,
          "new_text": "HeapObject::RawField(weak_cell, WeakCell::kValueOffset)",
          "old_line_content": "    if (clear_next) {",
          "new_line_content": "      Object** slot = HeapObject::RawField(weak_cell, WeakCell::kValueOffset);",
          "content_same": false
        },
        {
          "line": 2798,
          "old_api": null,
          "new_api": "clear_next",
          "old_text": null,
          "new_text": "weak_cell->clear_next(the_hole_value)",
          "old_line_content": "}",
          "new_line_content": "      weak_cell->clear_next(the_hole_value);",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": null,
          "new_api": "AddEvacuationCandidate",
          "old_text": null,
          "new_text": "AddEvacuationCandidate(pages[i].second)",
          "old_line_content": "                 \"total_live_bytes=%d\\n\",",
          "new_line_content": "      AddEvacuationCandidate(pages[i].second);",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "isolate()",
          "old_line_content": "",
          "new_line_content": "    PrintIsolate(isolate(),",
          "content_same": false
        },
        {
          "line": 2810,
          "old_api": null,
          "new_api": "encountered_weak_cells",
          "old_text": null,
          "new_text": "heap()->encountered_weak_cells()",
          "old_line_content": "}",
          "new_line_content": "  Object* weak_cell_obj = heap()->encountered_weak_cells();",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "space->identity()",
          "old_line_content": "  if (compacting_) {",
          "new_line_content": "                 AllocationSpaceName(space->identity()), reduce_memory,",
          "content_same": false
        },
        {
          "line": 2811,
          "old_api": null,
          "new_api": "Smi::FromInt(0)",
          "old_text": null,
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "",
          "new_line_content": "  while (weak_cell_obj != Smi::FromInt(0)) {",
          "content_same": false
        },
        {
          "line": 2812,
          "old_api": null,
          "new_api": "reinterpret_cast<WeakCell*>(weak_cell_obj)",
          "old_text": null,
          "new_text": "reinterpret_cast<WeakCell*>(weak_cell_obj)",
          "old_line_content": "",
          "new_line_content": "    WeakCell* weak_cell = reinterpret_cast<WeakCell*>(weak_cell_obj);",
          "content_same": false
        },
        {
          "line": 2813,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "weak_cell->next()",
          "old_line_content": "void MarkCompactCollector::AbortTransitionArrays() {",
          "new_line_content": "    weak_cell_obj = weak_cell->next();",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": null,
          "new_api": "ClearEvacuationCandidate",
          "old_text": null,
          "new_text": "p->ClearEvacuationCandidate()",
          "old_line_content": "",
          "new_line_content": "      p->ClearEvacuationCandidate();",
          "content_same": false
        },
        {
          "line": 2822,
          "old_api": null,
          "new_api": "encountered_transition_arrays",
          "old_text": null,
          "new_text": "heap()->encountered_transition_arrays()",
          "old_line_content": "}",
          "new_line_content": "  Object* obj = heap()->encountered_transition_arrays();",
          "content_same": false
        },
        {
          "line": 2823,
          "old_api": null,
          "new_api": "Smi::FromInt(0)",
          "old_text": null,
          "new_text": "Smi::FromInt(0)",
          "old_line_content": "",
          "new_line_content": "  while (obj != Smi::FromInt(0)) {",
          "content_same": false
        },
        {
          "line": 2824,
          "old_api": null,
          "new_api": "TransitionArray::cast(obj)",
          "old_text": null,
          "new_text": "TransitionArray::cast(obj)",
          "old_line_content": "void MarkCompactCollector::RecordRelocSlot(Code* host, RelocInfo* rinfo,",
          "new_line_content": "    TransitionArray* array = TransitionArray::cast(obj);",
          "content_same": false
        },
        {
          "line": 2825,
          "old_api": null,
          "new_api": "next_link",
          "old_text": null,
          "new_text": "array->next_link()",
          "old_line_content": "                                           Object* target) {",
          "new_line_content": "    obj = array->next_link();",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "evacuation_candidates_.length()",
          "old_line_content": "#ifdef DEBUG",
          "new_line_content": "  DCHECK_EQ(0, evacuation_candidates_.length());",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(state_ == IDLE)",
          "old_line_content": "    // Instead of waiting we could also abort the sweeper threads here.",
          "new_line_content": "  DCHECK(state_ == IDLE);",
          "content_same": false
        },
        {
          "line": 2837,
          "old_api": null,
          "new_api": "host",
          "old_text": null,
          "new_text": "rinfo->host()",
          "old_line_content": "        slot_type = CODE_ENTRY_SLOT;",
          "new_line_content": "       !ShouldSkipEvacuationSlotRecording(rinfo->host()))) {",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(!FLAG_never_compact || !FLAG_always_compact)",
          "old_line_content": "  // If concurrent unmapping tasks are still running, we should wait for",
          "new_line_content": "  DCHECK(!FLAG_never_compact || !FLAG_always_compact);",
          "content_same": false
        },
        {
          "line": 2838,
          "old_api": null,
          "new_api": "rmode",
          "old_text": null,
          "new_text": "rinfo->rmode()",
          "old_line_content": "      } else {",
          "new_line_content": "    RelocInfo::Mode rmode = rinfo->rmode();",
          "content_same": false
        },
        {
          "line": 2840,
          "old_api": null,
          "new_api": "SlotTypeForRelocInfoMode",
          "old_text": null,
          "new_text": "SlotTypeForRelocInfoMode(rmode)",
          "old_line_content": "        slot_type = OBJECT_SLOT;",
          "new_line_content": "    SlotType slot_type = SlotTypeForRelocInfoMode(rmode);",
          "content_same": false
        },
        {
          "line": 2841,
          "old_api": null,
          "new_api": "IsInConstantPool",
          "old_text": null,
          "new_text": "rinfo->IsInConstantPool()",
          "old_line_content": "      }",
          "new_line_content": "    if (rinfo->IsInConstantPool()) {",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": null,
          "new_api": "EnsureSweepingCompleted",
          "old_text": null,
          "new_text": "EnsureSweepingCompleted()",
          "old_line_content": "  // Clear marking bits if incremental marking is aborted.",
          "new_line_content": "    EnsureSweepingCompleted();",
          "content_same": false
        },
        {
          "line": 2842,
          "old_api": null,
          "new_api": "constant_pool_entry_address",
          "old_text": null,
          "new_text": "rinfo->constant_pool_entry_address()",
          "old_line_content": "    }",
          "new_line_content": "      addr = rinfo->constant_pool_entry_address();",
          "content_same": false
        },
        {
          "line": 2846,
          "old_api": null,
          "new_api": "RelocInfo::IsEmbeddedObject(rmode)",
          "old_text": null,
          "new_text": "RelocInfo::IsEmbeddedObject(rmode)",
          "old_line_content": "}",
          "new_line_content": "        DCHECK(RelocInfo::IsEmbeddedObject(rmode));",
          "content_same": false
        },
        {
          "line": 2851,
          "old_api": null,
          "new_api": "reinterpret_cast<Address>(host)",
          "old_text": null,
          "new_text": "reinterpret_cast<Address>(host)",
          "old_line_content": "",
          "new_line_content": "        source_page, reinterpret_cast<Address>(host), slot_type, addr);",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": null,
          "new_api": "ClearMarkbits",
          "old_text": null,
          "new_text": "ClearMarkbits()",
          "old_line_content": "    }",
          "new_line_content": "    ClearMarkbits();",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": null,
          "new_api": "AbortWeakCollections",
          "old_text": null,
          "new_text": "AbortWeakCollections()",
          "old_line_content": "    was_marked_incrementally_ = false;",
          "new_line_content": "    AbortWeakCollections();",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": null,
          "new_api": "AbortWeakCells",
          "old_text": null,
          "new_text": "AbortWeakCells()",
          "old_line_content": "  }",
          "new_line_content": "    AbortWeakCells();",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": null,
          "new_api": "AbortTransitionArrays",
          "old_text": null,
          "new_text": "AbortTransitionArrays()",
          "old_line_content": "",
          "new_line_content": "    AbortTransitionArrays();",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": null,
          "new_api": "AbortCompaction",
          "old_text": null,
          "new_text": "AbortCompaction()",
          "old_line_content": "  if (!was_marked_incrementally_) {",
          "new_line_content": "    AbortCompaction();",
          "content_same": false
        },
        {
          "line": 2859,
          "old_api": null,
          "new_api": "IsHeapObject",
          "old_text": null,
          "new_text": "obj->IsHeapObject()",
          "old_line_content": "                 ->IsFlagSet(Page::COMPACTION_WAS_ABORTED));",
          "new_line_content": "  if (obj->IsHeapObject()) {",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "UsingEmbedderHeapTracer",
          "old_text": null,
          "new_text": "heap_->UsingEmbedderHeapTracer()",
          "old_line_content": "  }",
          "new_line_content": "    if (heap_->UsingEmbedderHeapTracer()) {",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": null,
          "new_api": "mark_compact_collector",
          "old_text": null,
          "new_text": "heap_->mark_compact_collector()->embedder_heap_tracer()->TracePrologue()",
          "old_line_content": "",
          "new_line_content": "      heap_->mark_compact_collector()->embedder_heap_tracer()->TracePrologue();",
          "content_same": false
        },
        {
          "line": 2867,
          "old_api": null,
          "new_api": "ToForwardingAddress",
          "old_text": null,
          "new_text": "map_word.ToForwardingAddress()",
          "old_line_content": "    }",
          "new_line_content": "      HeapObject* target = map_word.ToForwardingAddress();",
          "content_same": false
        },
        {
          "line": 2868,
          "old_api": null,
          "new_api": "base::NoBarrier_CompareAndSwap(\n          reinterpret_cast<base::AtomicWord*>(slot),\n          reinterpret_cast<base::AtomicWord>(obj),\n          reinterpret_cast<base::AtomicWord>(target))",
          "old_text": null,
          "new_text": "base::NoBarrier_CompareAndSwap(\n          reinterpret_cast<base::AtomicWord*>(slot),\n          reinterpret_cast<base::AtomicWord>(obj),\n          reinterpret_cast<base::AtomicWord>(target))",
          "old_line_content": "  }",
          "new_line_content": "      base::NoBarrier_CompareAndSwap(",
          "content_same": false
        },
        {
          "line": 2869,
          "old_api": null,
          "new_api": "reinterpret_cast<base::AtomicWord*>(slot)",
          "old_text": null,
          "new_text": "reinterpret_cast<base::AtomicWord*>(slot)",
          "old_line_content": "  return REMOVE_SLOT;",
          "new_line_content": "          reinterpret_cast<base::AtomicWord*>(slot),",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "EnterFinalPause",
          "old_text": null,
          "new_text": "embedder_heap_tracer()->EnterFinalPause()",
          "old_line_content": "  }",
          "new_line_content": "    embedder_heap_tracer()->EnterFinalPause();",
          "content_same": false
        },
        {
          "line": 2870,
          "old_api": null,
          "new_api": "reinterpret_cast<base::AtomicWord>(obj)",
          "old_text": null,
          "new_text": "reinterpret_cast<base::AtomicWord>(obj)",
          "old_line_content": "}",
          "new_line_content": "          reinterpret_cast<base::AtomicWord>(obj),",
          "content_same": false
        },
        {
          "line": 2871,
          "old_api": null,
          "new_api": "reinterpret_cast<base::AtomicWord>(target)",
          "old_text": null,
          "new_text": "reinterpret_cast<base::AtomicWord>(target)",
          "old_line_content": "",
          "new_line_content": "          reinterpret_cast<base::AtomicWord>(target));",
          "content_same": false
        },
        {
          "line": 2872,
          "old_api": null,
          "new_api": "GetHeap",
          "old_text": null,
          "new_text": "heap_obj->GetHeap()->InFromSpace(target)",
          "old_line_content": "// Visitor for updating pointers from live objects in old spaces to new space.",
          "new_line_content": "      DCHECK(!heap_obj->GetHeap()->InFromSpace(target) &&",
          "content_same": false
        },
        {
          "line": 2873,
          "old_api": null,
          "new_api": "MarkCompactCollector::IsOnEvacuationCandidate(target)",
          "old_text": null,
          "new_text": "MarkCompactCollector::IsOnEvacuationCandidate(target)",
          "old_line_content": "// It does not expect to encounter pointers to dead objects.",
          "new_line_content": "             !MarkCompactCollector::IsOnEvacuationCandidate(target));",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": null,
          "new_api": "StartCompaction",
          "old_text": null,
          "new_text": "StartCompaction(NON_INCREMENTAL_COMPACTION)",
          "old_line_content": "  }",
          "new_line_content": "    StartCompaction(NON_INCREMENTAL_COMPACTION);",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "spaces.next()",
          "old_line_content": "  if (!was_marked_incrementally_ && FLAG_verify_heap) {",
          "new_line_content": "  for (PagedSpace* space = spaces.next(); space != NULL;",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": null,
          "new_api": "PrepareForMarkCompact",
          "old_text": null,
          "new_text": "space->PrepareForMarkCompact()",
          "old_line_content": "  }",
          "new_line_content": "    space->PrepareForMarkCompact();",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": null,
          "new_api": "account_external_memory_concurrently_freed",
          "old_text": null,
          "new_text": "heap()->account_external_memory_concurrently_freed()",
          "old_line_content": "}",
          "new_line_content": "  heap()->account_external_memory_concurrently_freed();",
          "content_same": false
        },
        {
          "line": 2886,
          "old_api": null,
          "new_api": "UpdateSlot",
          "old_text": null,
          "new_text": "UpdateSlot(p)",
          "old_line_content": "  void VisitEmbeddedPointer(RelocInfo* rinfo) override {",
          "new_line_content": "    for (Object** p = start; p < end; p++) UpdateSlot(p);",
          "content_same": false
        },
        {
          "line": 2890,
          "old_api": null,
          "new_api": "UpdateTypedSlotHelper::UpdateCell(rinfo, UpdateSlot)",
          "old_text": null,
          "new_text": "UpdateTypedSlotHelper::UpdateCell(rinfo, UpdateSlot)",
          "old_line_content": "  void VisitCodeTarget(RelocInfo* rinfo) override {",
          "new_line_content": "    UpdateTypedSlotHelper::UpdateCell(rinfo, UpdateSlot);",
          "content_same": false
        },
        {
          "line": 2894,
          "old_api": null,
          "new_api": "UpdateTypedSlotHelper::UpdateEmbeddedPointer(rinfo, UpdateSlot)",
          "old_text": null,
          "new_text": "UpdateTypedSlotHelper::UpdateEmbeddedPointer(rinfo, UpdateSlot)",
          "old_line_content": "  void VisitCodeEntry(Address entry_address) override {",
          "new_line_content": "    UpdateTypedSlotHelper::UpdateEmbeddedPointer(rinfo, UpdateSlot);",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()",
          "old_line_content": "",
          "new_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_FINISH);",
          "content_same": false
        },
        {
          "line": 2898,
          "old_api": null,
          "new_api": "UpdateTypedSlotHelper::UpdateCodeTarget(rinfo, UpdateSlot)",
          "old_text": null,
          "new_text": "UpdateTypedSlotHelper::UpdateCodeTarget(rinfo, UpdateSlot)",
          "old_line_content": "  void VisitDebugTarget(RelocInfo* rinfo) override {",
          "new_line_content": "    UpdateTypedSlotHelper::UpdateCodeTarget(rinfo, UpdateSlot);",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": null,
          "new_api": "StartSweepingHelper",
          "old_text": null,
          "new_text": "sweeper().StartSweepingHelper(OLD_SPACE)",
          "old_line_content": "  // Clear the marking state of live large objects.",
          "new_line_content": "    sweeper().StartSweepingHelper(OLD_SPACE);",
          "content_same": false
        },
        {
          "line": 2902,
          "old_api": null,
          "new_api": "UpdateTypedSlotHelper::UpdateCodeEntry(entry_address, UpdateSlot)",
          "old_text": null,
          "new_text": "UpdateTypedSlotHelper::UpdateCodeEntry(entry_address, UpdateSlot)",
          "old_line_content": "",
          "new_line_content": "    UpdateTypedSlotHelper::UpdateCodeEntry(entry_address, UpdateSlot);",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "heap()->isolate()->factory()->undefined_value()",
          "old_line_content": "  state_ = IDLE;",
          "new_line_content": "      heap()->isolate()->factory()->undefined_value());",
          "content_same": false
        },
        {
          "line": 2906,
          "old_api": null,
          "new_api": "UpdateTypedSlotHelper::UpdateDebugTarget(rinfo, UpdateSlot)",
          "old_text": null,
          "new_text": "UpdateTypedSlotHelper::UpdateDebugTarget(rinfo, UpdateSlot)",
          "old_line_content": "",
          "new_line_content": "    UpdateTypedSlotHelper::UpdateDebugTarget(rinfo, UpdateSlot);",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": null,
          "new_api": "lo_space",
          "old_text": null,
          "new_text": "heap_->lo_space()->ClearMarkingStateOfLiveObjects()",
          "old_line_content": "",
          "new_line_content": "  heap_->lo_space()->ClearMarkingStateOfLiveObjects();",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(state_ == SWEEP_SPACES || state_ == RELOCATE_OBJECTS)",
          "old_line_content": "  // GC, because it relies on the new address of certain old space",
          "new_line_content": "  DCHECK(state_ == SWEEP_SPACES || state_ == RELOCATE_OBJECTS);",
          "content_same": false
        },
        {
          "line": 2912,
          "old_api": null,
          "new_api": "map_word",
          "old_text": null,
          "new_text": "HeapObject::cast(*p)->map_word()",
          "old_line_content": "}",
          "new_line_content": "  MapWord map_word = HeapObject::cast(*p)->map_word();",
          "content_same": false
        },
        {
          "line": 2914,
          "old_api": null,
          "new_api": "IsForwardingAddress",
          "old_text": null,
          "new_text": "map_word.IsForwardingAddress()",
          "old_line_content": "bool MarkCompactCollector::IsSlotInBlackObject(MemoryChunk* p, Address slot) {",
          "new_line_content": "  if (map_word.IsForwardingAddress()) {",
          "content_same": false
        },
        {
          "line": 2918,
          "old_api": null,
          "new_api": "String::cast(*p)",
          "old_text": null,
          "new_text": "String::cast(*p)",
          "old_line_content": "",
          "new_line_content": "  return String::cast(*p);",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": null,
          "new_api": "load_stub_cache",
          "old_text": null,
          "new_text": "isolate()->load_stub_cache()->Clear()",
          "old_line_content": "  }",
          "new_line_content": "  isolate()->load_stub_cache()->Clear();",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": null,
          "new_api": "store_stub_cache",
          "old_text": null,
          "new_text": "isolate()->store_stub_cache()->Clear()",
          "old_line_content": "",
          "new_line_content": "  isolate()->store_stub_cache()->Clear();",
          "content_same": false
        },
        {
          "line": 2922,
          "old_api": null,
          "new_api": "owner",
          "old_text": null,
          "new_text": "p->owner()",
          "old_line_content": "  }",
          "new_line_content": "  Space* owner = p->owner();",
          "content_same": false
        },
        {
          "line": 2923,
          "old_api": null,
          "new_api": "lo_space",
          "old_text": null,
          "new_text": "heap_->lo_space()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(owner != heap_->lo_space() && owner != nullptr);",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "isolate()",
          "old_line_content": "    marking_parity_ = ODD_MARKING_PARITY;",
          "new_line_content": "    Deoptimizer::DeoptimizeMarkedCode(isolate());",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": null,
          "new_api": "incremental_marking",
          "old_text": null,
          "new_text": "heap_->incremental_marking()->ClearIdleMarkingDelayCounter()",
          "old_line_content": "  }",
          "new_line_content": "  heap_->incremental_marking()->ClearIdleMarkingDelayCounter();",
          "content_same": false
        },
        {
          "line": 2931,
          "old_api": null,
          "new_api": "AddressToMarkbitIndex",
          "old_text": null,
          "new_text": "p->AddressToMarkbitIndex(slot)",
          "old_line_content": "",
          "new_line_content": "  uint32_t mark_bit_index = p->AddressToMarkbitIndex(slot);",
          "content_same": false
        },
        {
          "line": 2933,
          "old_api": null,
          "new_api": "Bitmap::IndexInCell(mark_bit_index)",
          "old_text": null,
          "new_text": "Bitmap::IndexInCell(mark_bit_index)",
          "old_line_content": "  // when we left trim a fixed array. Such slots are invalid and we can remove",
          "new_line_content": "  MarkBit::CellType index_mask = 1u << Bitmap::IndexInCell(mark_bit_index);",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(marking_parity_ == ODD_MARKING_PARITY)",
          "old_line_content": "// Phase 1: tracing and marking live objects.",
          "new_line_content": "    DCHECK(marking_parity_ == ODD_MARKING_PARITY);",
          "content_same": false
        },
        {
          "line": 2934,
          "old_api": null,
          "new_api": "markbits",
          "old_text": null,
          "new_text": "p->markbits()->cells()",
          "old_line_content": "  // them.",
          "new_line_content": "  MarkBit::CellType* cells = p->markbits()->cells();",
          "content_same": false
        },
        {
          "line": 2935,
          "old_api": null,
          "new_api": "area_start",
          "old_text": null,
          "new_text": "p->area_start()",
          "old_line_content": "  if (index_mask > 1) {",
          "new_line_content": "  Address base_address = p->area_start();",
          "content_same": false
        },
        {
          "line": 2936,
          "old_api": null,
          "new_api": "AddressToMarkbitIndex",
          "old_text": null,
          "new_text": "Bitmap::IndexToCell(\n      Bitmap::CellAlignIndex(p->AddressToMarkbitIndex(base_address)))",
          "old_line_content": "    if ((cells[cell_index] & index_mask) != 0 &&",
          "new_line_content": "  unsigned int base_address_cell_index = Bitmap::IndexToCell(",
          "content_same": false
        },
        {
          "line": 2937,
          "old_api": null,
          "new_api": "AddressToMarkbitIndex",
          "old_text": null,
          "new_text": "p->AddressToMarkbitIndex(base_address)",
          "old_line_content": "        (cells[cell_index] & (index_mask >> 1)) == 0) {",
          "new_line_content": "      Bitmap::CellAlignIndex(p->AddressToMarkbitIndex(base_address)));",
          "content_same": false
        },
        {
          "line": 2949,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(cell_index != base_address_cell_index)",
          "old_line_content": "  // Check if the object is in the current cell.",
          "new_line_content": "    DCHECK(cell_index != base_address_cell_index);",
          "content_same": false
        },
        {
          "line": 2959,
          "old_api": null,
          "new_api": "base::bits::CountTrailingZeros32(cells[cell_index])",
          "old_text": null,
          "new_text": "base::bits::CountTrailingZeros32(cells[cell_index])",
          "old_line_content": "      cell_index--;",
          "new_line_content": "      (base::bits::CountTrailingZeros32(cells[cell_index]) >",
          "content_same": false
        },
        {
          "line": 2960,
          "old_api": null,
          "new_api": "base::bits::CountTrailingZeros32(cells[cell_index] | index_mask)",
          "old_text": null,
          "new_text": "base::bits::CountTrailingZeros32(cells[cell_index] | index_mask)",
          "old_line_content": "    } while (cell_index > base_address_cell_index && cells[cell_index] == 0);",
          "new_line_content": "       base::bits::CountTrailingZeros32(cells[cell_index] | index_mask))) {",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "isolate_->heap()->undefined_value()",
          "old_line_content": "",
          "new_line_content": "  Object* undefined = isolate_->heap()->undefined_value();",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "shared->code()",
          "old_line_content": "      }",
          "new_line_content": "    Code* code = shared->code();",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(code)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(code)",
          "old_line_content": "      // Always flush the optimized code map if there is one.",
          "new_line_content": "    MarkBit code_mark = ObjectMarking::MarkBitFrom(code);",
          "content_same": false
        },
        {
          "line": 2983,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(current_cell != 0)",
          "old_line_content": "",
          "new_line_content": "  CHECK(current_cell != 0);",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "PrintF",
          "old_text": null,
          "new_text": "PrintF(\"[code-flushing clears: \")",
          "old_line_content": "      }",
          "new_line_content": "        PrintF(\"[code-flushing clears: \");",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": null,
          "new_api": "ClearOptimizedCodeMap",
          "old_text": null,
          "new_text": "shared->ClearOptimizedCodeMap()",
          "old_line_content": "    }",
          "new_line_content": "        shared->ClearOptimizedCodeMap();",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": null,
          "new_api": "set_code",
          "old_text": null,
          "new_text": "shared->set_code(lazy_compile)",
          "old_line_content": "    // We are in the middle of a GC cycle so the write barrier in the code",
          "new_line_content": "      shared->set_code(lazy_compile);",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": null,
          "new_api": "set_code",
          "old_text": null,
          "new_text": "candidate->set_code(lazy_compile)",
          "old_line_content": "    // setter did not record the slot update and we have to do that manually.",
          "new_line_content": "      candidate->set_code(lazy_compile);",
          "content_same": false
        },
        {
          "line": 2994,
          "old_api": null,
          "new_api": "HeapObject::FromAddress(address)",
          "old_text": null,
          "new_text": "HeapObject::FromAddress(address)",
          "old_line_content": "    // Slots pointing to the first word of an object are invalid and removed.",
          "new_line_content": "  HeapObject* object = HeapObject::FromAddress(address);",
          "content_same": false
        },
        {
          "line": 2995,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(object)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(object)",
          "old_line_content": "    // This can happen when we move the object header while left trimming.",
          "new_line_content": "  CHECK(Marking::IsBlack(ObjectMarking::MarkBitFrom(object)));",
          "content_same": false
        },
        {
          "line": 2996,
          "old_api": null,
          "new_api": "reinterpret_cast<Address>(slot)",
          "old_text": null,
          "new_text": "reinterpret_cast<Address>(slot)",
          "old_line_content": "    return true;",
          "new_line_content": "  CHECK(object->address() < reinterpret_cast<Address>(slot));",
          "content_same": false
        },
        {
          "line": 2997,
          "old_api": null,
          "new_api": "address",
          "old_text": null,
          "new_text": "object->address()",
          "old_line_content": "  }",
          "new_line_content": "  if ((object->address() + kPointerSize) <= slot &&",
          "content_same": false
        },
        {
          "line": 2998,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "object->Size()",
          "old_line_content": "  return false;",
          "new_line_content": "      (object->address() + object->Size()) > slot) {",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": null,
          "new_api": "Code::GetObjectFromEntryAddress(slot)",
          "old_text": null,
          "new_text": "Code::GetObjectFromEntryAddress(slot)",
          "old_line_content": "        shared, shared_code_slot, *shared_code_slot);",
          "new_line_content": "    Code* target = Code::cast(Code::GetObjectFromEntryAddress(slot));",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "isolate_->heap()->mark_compact_collector()->RecordCodeEntrySlot(\n        candidate, slot, target)",
          "old_line_content": "",
          "new_line_content": "    isolate_->heap()->mark_compact_collector()->RecordCodeEntrySlot(",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": null,
          "new_api": "HeapObject::RawField(shared, SharedFunctionInfo::kCodeOffset)",
          "old_text": null,
          "new_text": "HeapObject::RawField(shared, SharedFunctionInfo::kCodeOffset)",
          "old_line_content": "  jsfunction_candidates_head_ = NULL;",
          "new_line_content": "        HeapObject::RawField(shared, SharedFunctionInfo::kCodeOffset);",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "isolate_->heap()->mark_compact_collector()->RecordSlot(\n        shared, shared_code_slot, *shared_code_slot)",
          "old_line_content": "}",
          "new_line_content": "    isolate_->heap()->mark_compact_collector()->RecordSlot(",
          "content_same": false
        },
        {
          "line": 3010,
          "old_api": null,
          "new_api": "owner",
          "old_text": null,
          "new_text": "p->owner()",
          "old_line_content": "",
          "new_line_content": "  Space* owner = p->owner();",
          "content_same": false
        },
        {
          "line": 3012,
          "old_api": null,
          "new_api": "lo_space",
          "old_text": null,
          "new_text": "heap_->lo_space()->FindObject(slot)",
          "old_line_content": "      return large_heap_object;",
          "new_line_content": "    Object* large_object = heap_->lo_space()->FindObject(slot);",
          "content_same": false
        },
        {
          "line": 3015,
          "old_api": null,
          "new_api": "IsHeapObject",
          "old_text": null,
          "new_text": "large_object->IsHeapObject()",
          "old_line_content": "  }",
          "new_line_content": "    CHECK(large_object->IsHeapObject());",
          "content_same": false
        },
        {
          "line": 3016,
          "old_api": null,
          "new_api": "HeapObject::cast(large_object)",
          "old_text": null,
          "new_text": "HeapObject::cast(large_object)",
          "old_line_content": "",
          "new_line_content": "    HeapObject* large_heap_object = HeapObject::cast(large_object);",
          "content_same": false
        },
        {
          "line": 3018,
          "old_api": null,
          "new_api": "IsMarked",
          "old_text": null,
          "new_text": "IsMarked(large_heap_object)",
          "old_line_content": "  HeapObject* object = nullptr;",
          "new_line_content": "    if (IsMarked(large_heap_object)) {",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": null,
          "new_api": "builtins",
          "old_text": null,
          "new_text": "isolate_->builtins()->builtin(Builtins::kCompileLazy)",
          "old_line_content": "",
          "new_line_content": "  Code* lazy_compile = isolate_->builtins()->builtin(Builtins::kCompileLazy);",
          "content_same": false
        },
        {
          "line": 3026,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "it.Next()",
          "old_line_content": "",
          "new_line_content": "  while ((object = it.Next()) != nullptr) {",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "candidate->code()",
          "old_line_content": "      }",
          "new_line_content": "    Code* code = candidate->code();",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(code)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(code)",
          "old_line_content": "      // Always flush the optimized code map if there is one.",
          "new_line_content": "    MarkBit code_mark = ObjectMarking::MarkBitFrom(code);",
          "content_same": false
        },
        {
          "line": 3027,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "object->Size()",
          "old_line_content": "  return nullptr;",
          "new_line_content": "    int size = object->Size();",
          "content_same": false
        },
        {
          "line": 3028,
          "old_api": null,
          "new_api": "address",
          "old_text": null,
          "new_text": "object->address()",
          "old_line_content": "}",
          "new_line_content": "    if (object->address() > slot) return nullptr;",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": null,
          "new_api": "PrintF",
          "old_text": null,
          "new_text": "PrintF(\"[code-flushing clears: \")",
          "old_line_content": "      }",
          "new_line_content": "        PrintF(\"[code-flushing clears: \");",
          "content_same": false
        },
        {
          "line": 3029,
          "old_api": null,
          "new_api": "address",
          "old_text": null,
          "new_text": "object->address()",
          "old_line_content": "",
          "new_line_content": "    if (object->address() <= slot && slot < (object->address() + size)) {",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": null,
          "new_api": "GetAge",
          "old_text": null,
          "new_text": "code->GetAge()",
          "old_line_content": "    }",
          "new_line_content": "        PrintF(\" - age: %d]\\n\", code->GetAge());",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": null,
          "new_api": "set_code",
          "old_text": null,
          "new_text": "candidate->set_code(lazy_compile)",
          "old_line_content": "",
          "new_line_content": "      candidate->set_code(lazy_compile);",
          "content_same": false
        },
        {
          "line": 3039,
          "old_api": null,
          "new_api": "new_space",
          "old_text": null,
          "new_text": "heap()->new_space()",
          "old_line_content": "}",
          "new_line_content": "  NewSpace* new_space = heap()->new_space();",
          "content_same": false
        },
        {
          "line": 3041,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "new_space->top()",
          "old_line_content": "class MarkCompactCollector::Evacuator : public Malloced {",
          "new_line_content": "  for (Page* p : NewSpacePageRange(new_space->bottom(), new_space->top())) {",
          "content_same": false
        },
        {
          "line": 3042,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "newspace_evacuation_candidates_.Add(p)",
          "old_line_content": " public:",
          "new_line_content": "    newspace_evacuation_candidates_.Add(p);",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": null,
          "new_api": "HeapObject::RawField(candidate, SharedFunctionInfo::kCodeOffset)",
          "old_text": null,
          "new_text": "HeapObject::RawField(candidate, SharedFunctionInfo::kCodeOffset)",
          "old_line_content": "  shared_function_info_candidates_head_ = NULL;",
          "new_line_content": "        HeapObject::RawField(candidate, SharedFunctionInfo::kCodeOffset);",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "isolate_->heap()->mark_compact_collector()->RecordSlot(candidate, code_slot,\n                                                           *code_slot)",
          "old_line_content": "}",
          "new_line_content": "    isolate_->heap()->mark_compact_collector()->RecordSlot(candidate, code_slot,",
          "content_same": false
        },
        {
          "line": 3044,
          "old_api": null,
          "new_api": "Flip",
          "old_text": null,
          "new_text": "new_space->Flip()",
          "old_line_content": "    kObjectsNewToOld,",
          "new_line_content": "  new_space->Flip();",
          "content_same": false
        },
        {
          "line": 3045,
          "old_api": null,
          "new_api": "ResetAllocationInfo",
          "old_text": null,
          "new_text": "new_space->ResetAllocationInfo()",
          "old_line_content": "    kPageNewToOld,",
          "new_line_content": "  new_space->ResetAllocationInfo();",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "isolate_->heap()->incremental_marking()->IterateBlackObject(shared_info)",
          "old_line_content": "",
          "new_line_content": "  isolate_->heap()->incremental_marking()->IterateBlackObject(shared_info);",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": null,
          "new_api": "PrintF",
          "old_text": null,
          "new_text": "PrintF(\"[code-flushing abandons function-info: \")",
          "old_line_content": "  if (candidate == shared_info) {",
          "new_line_content": "    PrintF(\"[code-flushing abandons function-info: \");",
          "content_same": false
        },
        {
          "line": 3059,
          "old_api": null,
          "new_api": "IsFlagSet",
          "old_text": null,
          "new_text": "chunk->IsFlagSet(MemoryChunk::PAGE_NEW_OLD_PROMOTION)",
          "old_line_content": "  }",
          "new_line_content": "    if (chunk->IsFlagSet(MemoryChunk::PAGE_NEW_OLD_PROMOTION))",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": null,
          "new_api": "PrintF",
          "old_text": null,
          "new_text": "PrintF(\"]\\n\")",
          "old_line_content": "    shared_function_info_candidates_head_ = next_candidate;",
          "new_line_content": "    PrintF(\"]\\n\");",
          "content_same": false
        },
        {
          "line": 3061,
          "old_api": null,
          "new_api": "IsFlagSet",
          "old_text": null,
          "new_text": "chunk->IsFlagSet(MemoryChunk::PAGE_NEW_NEW_PROMOTION)",
          "old_line_content": "  // NewSpacePages with more live bytes than this threshold qualify for fast",
          "new_line_content": "    if (chunk->IsFlagSet(MemoryChunk::PAGE_NEW_NEW_PROMOTION))",
          "content_same": false
        },
        {
          "line": 3063,
          "old_api": null,
          "new_api": "InNewSpace",
          "old_text": null,
          "new_text": "chunk->InNewSpace()",
          "old_line_content": "  static int PageEvacuationThreshold() {",
          "new_line_content": "    if (chunk->InNewSpace()) return kObjectsNewToOld;",
          "content_same": false
        },
        {
          "line": 3064,
          "old_api": null,
          "new_api": "IsEvacuationCandidate",
          "old_text": null,
          "new_text": "chunk->IsEvacuationCandidate()",
          "old_line_content": "    if (FLAG_page_promotion)",
          "new_line_content": "    DCHECK(chunk->IsEvacuationCandidate());",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": null,
          "new_api": "GetNextCandidate",
          "old_text": null,
          "new_text": "GetNextCandidate(shared_info)",
          "old_line_content": "      if (next_candidate == shared_info) {",
          "new_line_content": "    next_candidate = GetNextCandidate(shared_info);",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": null,
          "new_api": "GetNextCandidate",
          "old_text": null,
          "new_text": "GetNextCandidate(candidate)",
          "old_line_content": "      }",
          "new_line_content": "      next_candidate = GetNextCandidate(candidate);",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": null,
          "new_api": "GetNextCandidate",
          "old_text": null,
          "new_text": "GetNextCandidate(shared_info)",
          "old_line_content": "    }",
          "new_line_content": "        next_candidate = GetNextCandidate(shared_info);",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": null,
          "new_api": "SetNextCandidate",
          "old_text": null,
          "new_text": "SetNextCandidate(candidate, next_candidate)",
          "old_line_content": "  }",
          "new_line_content": "        SetNextCandidate(candidate, next_candidate);",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": null,
          "new_api": "ClearNextCandidate",
          "old_text": null,
          "new_text": "ClearNextCandidate(shared_info)",
          "old_line_content": "}",
          "new_line_content": "        ClearNextCandidate(shared_info);",
          "content_same": false
        },
        {
          "line": 3078,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "collector->heap()",
          "old_line_content": "        duration_(0.0),",
          "new_line_content": "        compaction_spaces_(collector->heap()),",
          "content_same": false
        },
        {
          "line": 3081,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "collector->heap()",
          "old_line_content": "  inline bool EvacuatePage(Page* chunk);",
          "new_line_content": "        new_space_visitor_(collector->heap(), &compaction_spaces_,",
          "content_same": false
        },
        {
          "line": 3083,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "collector->heap()",
          "old_line_content": "  // Merge back locally cached info sequentially. Note that this method needs",
          "new_line_content": "        new_space_page_visitor(collector->heap()),",
          "content_same": false
        },
        {
          "line": 3084,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "collector->heap()",
          "old_line_content": "  // to be called from the main thread.",
          "new_line_content": "        old_space_visitor_(collector->heap(), &compaction_spaces_),",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": null,
          "new_api": "next_function_link",
          "old_text": null,
          "new_text": "function->next_function_link()->IsUndefined(isolate_)",
          "old_line_content": "",
          "new_line_content": "  DCHECK(!function->next_function_link()->IsUndefined(isolate_));",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "isolate_->heap()->undefined_value()",
          "old_line_content": "  if (FLAG_trace_code_flushing) {",
          "new_line_content": "  Object* undefined = isolate_->heap()->undefined_value();",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "isolate_->heap()->incremental_marking()->IterateBlackObject(\n      function->shared())",
          "old_line_content": "  }",
          "new_line_content": "  isolate_->heap()->incremental_marking()->IterateBlackObject(",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": null,
          "new_api": "shared",
          "old_text": null,
          "new_text": "function->shared()",
          "old_line_content": "",
          "new_line_content": "      function->shared());",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": null,
          "new_api": "PrintF",
          "old_text": null,
          "new_text": "PrintF(\"[code-flushing abandons closure: \")",
          "old_line_content": "  if (candidate == function) {",
          "new_line_content": "    PrintF(\"[code-flushing abandons closure: \");",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": null,
          "new_api": "PrintF",
          "old_text": null,
          "new_text": "PrintF(\"]\\n\")",
          "old_line_content": "    jsfunction_candidates_head_ = next_candidate;",
          "new_line_content": "    PrintF(\"]\\n\");",
          "content_same": false
        },
        {
          "line": 3099,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "collector_->heap()",
          "old_line_content": "  MarkCompactCollector* collector_;",
          "new_line_content": "  inline Heap* heap() { return collector_->heap(); }",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": null,
          "new_api": "GetNextCandidate",
          "old_text": null,
          "new_text": "GetNextCandidate(function)",
          "old_line_content": "      if (next_candidate == function) {",
          "new_line_content": "    next_candidate = GetNextCandidate(function);",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": null,
          "new_api": "GetNextCandidate",
          "old_text": null,
          "new_text": "GetNextCandidate(candidate)",
          "old_line_content": "      }",
          "new_line_content": "      next_candidate = GetNextCandidate(candidate);",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": null,
          "new_api": "GetNextCandidate",
          "old_text": null,
          "new_text": "GetNextCandidate(function)",
          "old_line_content": "    }",
          "new_line_content": "        next_candidate = GetNextCandidate(function);",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": null,
          "new_api": "SetNextCandidate",
          "old_text": null,
          "new_text": "SetNextCandidate(candidate, next_candidate)",
          "old_line_content": "  }",
          "new_line_content": "        SetNextCandidate(candidate, next_candidate);",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": null,
          "new_api": "ClearNextCandidate",
          "old_text": null,
          "new_text": "ClearNextCandidate(function, undefined)",
          "old_line_content": "}",
          "new_line_content": "        ClearNextCandidate(function, undefined);",
          "content_same": false
        },
        {
          "line": 3125,
          "old_api": null,
          "new_api": "LiveBytes",
          "old_text": null,
          "new_text": "page->LiveBytes()",
          "old_line_content": "      case kObjectsNewToOld:",
          "new_line_content": "  int saved_live_bytes = page->LiveBytes();",
          "content_same": false
        },
        {
          "line": 1078,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "isolate_->heap()",
          "old_line_content": "    }",
          "new_line_content": "  Heap* heap = isolate_->heap();",
          "content_same": false
        },
        {
          "line": 3127,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "page->heap()",
          "old_line_content": "                                               kClearMarkbits);",
          "new_line_content": "  Heap* heap = page->heap();",
          "content_same": false
        },
        {
          "line": 3129,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "heap->isolate()",
          "old_line_content": "            page, ArrayBufferTracker::kUpdateForwardedRemoveOthers);",
          "new_line_content": "    AlwaysAllocateScope always_allocate(heap->isolate());",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": null,
          "new_api": "InFromSpace",
          "old_text": null,
          "new_text": "heap->InFromSpace(candidate)",
          "old_line_content": "",
          "new_line_content": "    if (heap->InFromSpace(candidate)) {",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": null,
          "new_api": "reinterpret_cast<Object**>(slot)",
          "old_text": null,
          "new_text": "reinterpret_cast<Object**>(slot)",
          "old_line_content": "",
          "new_line_content": "      v->VisitPointer(reinterpret_cast<Object**>(slot));",
          "content_same": false
        },
        {
          "line": 3131,
          "old_api": null,
          "new_api": "ComputeEvacuationMode",
          "old_text": null,
          "new_text": "ComputeEvacuationMode(page)",
          "old_line_content": "        break;",
          "new_line_content": "    switch (ComputeEvacuationMode(page)) {",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": null,
          "new_api": "GetNextCandidate",
          "old_text": null,
          "new_text": "GetNextCandidate(*slot)",
          "old_line_content": "    : public StaticMarkingVisitor<MarkCompactMarkingVisitor> {",
          "new_line_content": "    candidate = GetNextCandidate(*slot);",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": null,
          "new_api": "GetNextCandidateSlot",
          "old_text": null,
          "new_text": "GetNextCandidateSlot(*slot)",
          "old_line_content": " public:",
          "new_line_content": "    slot = GetNextCandidateSlot(*slot);",
          "content_same": false
        },
        {
          "line": 3135,
          "old_api": null,
          "new_api": "ArrayBufferTracker::ProcessBuffers(\n            page, ArrayBufferTracker::kUpdateForwardedRemoveOthers)",
          "old_text": null,
          "new_text": "ArrayBufferTracker::ProcessBuffers(\n            page, ArrayBufferTracker::kUpdateForwardedRemoveOthers)",
          "old_line_content": "        // ArrayBufferTracker will be updated during sweeping.",
          "new_line_content": "        ArrayBufferTracker::ProcessBuffers(",
          "content_same": false
        },
        {
          "line": 3137,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(success)",
          "old_line_content": "        break;",
          "new_line_content": "        DCHECK(success);",
          "content_same": false
        },
        {
          "line": 3140,
          "old_api": null,
          "new_api": "VisitLiveObjects",
          "old_text": null,
          "new_text": "collector_->VisitLiveObjects(page, &new_space_page_visitor,\n                                               kKeepMarking)",
          "old_line_content": "        // ArrayBufferTracker will be updated during sweeping.",
          "new_line_content": "        success = collector_->VisitLiveObjects(page, &new_space_page_visitor,",
          "content_same": false
        },
        {
          "line": 3143,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(success)",
          "old_line_content": "      case kObjectsOldToOld:",
          "new_line_content": "        DCHECK(success);",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": null,
          "new_api": "mark_compact_collector",
          "old_text": null,
          "new_text": "heap->mark_compact_collector()",
          "old_line_content": "    if (end - start >= kMinRangeForMarkingRecursion) {",
          "new_line_content": "    MarkObjectByPointer(heap->mark_compact_collector(), object, p);",
          "content_same": false
        },
        {
          "line": 3146,
          "old_api": null,
          "new_api": "LiveBytes",
          "old_text": null,
          "new_text": "page->LiveBytes()",
          "old_line_content": "        if (!success) {",
          "new_line_content": "        new_space_page_visitor.account_semispace_copied(page->LiveBytes());",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": null,
          "new_api": "VisitUnmarkedObjects",
          "old_text": null,
          "new_text": "VisitUnmarkedObjects(heap, object, start, end)",
          "old_line_content": "  }",
          "new_line_content": "      if (VisitUnmarkedObjects(heap, object, start, end)) return;",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": null,
          "new_api": "mark_compact_collector",
          "old_text": null,
          "new_text": "heap->mark_compact_collector()",
          "old_line_content": "  INLINE(static void MarkObject(Heap* heap, HeapObject* object)) {",
          "new_line_content": "    MarkCompactCollector* collector = heap->mark_compact_collector();",
          "content_same": false
        },
        {
          "line": 3158,
          "old_api": null,
          "new_api": "SetFlag",
          "old_text": null,
          "new_text": "page->SetFlag(Page::COMPACTION_WAS_ABORTED)",
          "old_line_content": "          // We need to return failure here to indicate that we want this page",
          "new_line_content": "          page->SetFlag(Page::COMPACTION_WAS_ABORTED);",
          "content_same": false
        },
        {
          "line": 3159,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "collector_->heap()",
          "old_line_content": "          // added to the sweeper.",
          "new_line_content": "          EvacuateRecordOnlyVisitor record_visitor(collector_->heap());",
          "content_same": false
        },
        {
          "line": 3161,
          "old_api": null,
          "new_api": "VisitLiveObjects",
          "old_text": null,
          "new_text": "collector_->VisitLiveObjects(page, &record_visitor, kKeepMarking)",
          "old_line_content": "        } else {",
          "new_line_content": "              collector_->VisitLiveObjects(page, &record_visitor, kKeepMarking);",
          "content_same": false
        },
        {
          "line": 3164,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(success)",
          "old_line_content": "        }",
          "new_line_content": "          DCHECK(success);",
          "content_same": false
        },
        {
          "line": 3169,
          "old_api": null,
          "new_api": "ArrayBufferTracker::ProcessBuffers(\n              page, ArrayBufferTracker::kUpdateForwardedRemoveOthers)",
          "old_text": null,
          "new_text": "ArrayBufferTracker::ProcessBuffers(\n              page, ArrayBufferTracker::kUpdateForwardedRemoveOthers)",
          "old_line_content": "  }",
          "new_line_content": "          ArrayBufferTracker::ProcessBuffers(",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(object)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(object)",
          "old_line_content": "",
          "new_line_content": "    MarkBit mark_bit = ObjectMarking::MarkBitFrom(object);",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": null,
          "new_api": "Marking::IsWhite(mark_bit)",
          "old_text": null,
          "new_text": "Marking::IsWhite(mark_bit)",
          "old_line_content": "  // Mark object pointed to by p.",
          "new_line_content": "    if (Marking::IsWhite(mark_bit)) {",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": null,
          "new_api": "mark_compact_collector",
          "old_text": null,
          "new_text": "heap->mark_compact_collector()->SetMark(object, mark_bit)",
          "old_line_content": "  INLINE(static void MarkObjectByPointer(MarkCompactCollector* collector,",
          "new_line_content": "      heap->mark_compact_collector()->SetMark(object, mark_bit);",
          "content_same": false
        },
        {
          "line": 3174,
          "old_api": null,
          "new_api": "UNREACHABLE",
          "old_text": null,
          "new_text": "UNREACHABLE()",
          "old_line_content": "                 \"page_evacuation=%d executable=%d contains_age_mark=%d \"",
          "new_line_content": "        UNREACHABLE();",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": null,
          "new_api": "IsHeapObject",
          "old_text": null,
          "new_text": "*p)->IsHeapObject()",
          "old_line_content": "",
          "new_line_content": "    if (!(*p)->IsHeapObject()) return;",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": null,
          "new_api": "HeapObject::cast(*p)",
          "old_text": null,
          "new_text": "HeapObject::cast(*p)",
          "old_line_content": "  // Visit an unmarked object.",
          "new_line_content": "    HeapObject* target_object = HeapObject::cast(*p);",
          "content_same": false
        },
        {
          "line": 1137,
          "old_api": null,
          "new_api": "RecordSlot",
          "old_text": null,
          "new_text": "collector->RecordSlot(object, p, target_object)",
          "old_line_content": "  INLINE(static void VisitUnmarkedObject(MarkCompactCollector* collector,",
          "new_line_content": "    collector->RecordSlot(object, p, target_object);",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(target_object)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(target_object)",
          "old_line_content": "                                         HeapObject* obj)) {",
          "new_line_content": "    MarkBit mark = ObjectMarking::MarkBitFrom(target_object);",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": null,
          "new_api": "MarkObject",
          "old_text": null,
          "new_text": "collector->MarkObject(target_object, mark)",
          "old_line_content": "#ifdef DEBUG",
          "new_line_content": "    collector->MarkObject(target_object, mark);",
          "content_same": false
        },
        {
          "line": 3183,
          "old_api": null,
          "new_api": "static_cast<void*>(page)",
          "old_text": null,
          "new_text": "static_cast<void*>(page)",
          "old_line_content": "  }",
          "new_line_content": "                 static_cast<void*>(this), static_cast<void*>(page),",
          "content_same": false
        },
        {
          "line": 3184,
          "old_api": null,
          "new_api": "InNewSpace",
          "old_text": null,
          "new_text": "page->InNewSpace()",
          "old_line_content": "  return success;",
          "new_line_content": "                 page->InNewSpace(),",
          "content_same": false
        },
        {
          "line": 3185,
          "old_api": null,
          "new_api": "IsFlagSet",
          "old_text": null,
          "new_text": "page->IsFlagSet(Page::PAGE_NEW_OLD_PROMOTION)",
          "old_line_content": "}",
          "new_line_content": "                 page->IsFlagSet(Page::PAGE_NEW_OLD_PROMOTION) ||",
          "content_same": false
        },
        {
          "line": 3186,
          "old_api": null,
          "new_api": "IsFlagSet",
          "old_text": null,
          "new_text": "page->IsFlagSet(Page::PAGE_NEW_NEW_PROMOTION)",
          "old_line_content": "",
          "new_line_content": "                     page->IsFlagSet(Page::PAGE_NEW_NEW_PROMOTION),",
          "content_same": false
        },
        {
          "line": 3187,
          "old_api": null,
          "new_api": "IsFlagSet",
          "old_text": null,
          "new_text": "page->IsFlagSet(MemoryChunk::IS_EXECUTABLE)",
          "old_line_content": "void MarkCompactCollector::Evacuator::Finalize() {",
          "new_line_content": "                 page->IsFlagSet(MemoryChunk::IS_EXECUTABLE),",
          "content_same": false
        },
        {
          "line": 1147,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "collector->heap()->Contains(obj)",
          "old_line_content": "    // Mark the map pointer and the body.",
          "new_line_content": "    DCHECK(collector->heap()->Contains(obj));",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": null,
          "new_api": "GetHeap",
          "old_text": null,
          "new_text": "obj->GetHeap()",
          "old_line_content": "  }",
          "new_line_content": "    Heap* heap = obj->GetHeap();",
          "content_same": false
        },
        {
          "line": 1152,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(obj)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(obj)",
          "old_line_content": "",
          "new_line_content": "    MarkBit mark = ObjectMarking::MarkBitFrom(obj);",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": null,
          "new_api": "mark_compact_collector",
          "old_text": null,
          "new_text": "heap->mark_compact_collector()->SetMark(obj, mark)",
          "old_line_content": "  // Visit all unmarked objects pointed to by [start, end).",
          "new_line_content": "    heap->mark_compact_collector()->SetMark(obj, mark);",
          "content_same": false
        },
        {
          "line": 1155,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(map)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(map)",
          "old_line_content": "  INLINE(static bool VisitUnmarkedObjects(Heap* heap, HeapObject* object,",
          "new_line_content": "    MarkBit map_mark = ObjectMarking::MarkBitFrom(map);",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": null,
          "new_api": "mark_compact_collector",
          "old_text": null,
          "new_text": "heap->mark_compact_collector()->MarkObject(map, map_mark)",
          "old_line_content": "                                          Object** start, Object** end)) {",
          "new_line_content": "    heap->mark_compact_collector()->MarkObject(map, map_mark);",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": null,
          "new_api": "IterateBody",
          "old_text": null,
          "new_text": "IterateBody(map, obj)",
          "old_line_content": "    // Return false is we are close to the stack limit.",
          "new_line_content": "    IterateBody(map, obj);",
          "content_same": false
        },
        {
          "line": 3203,
          "old_api": null,
          "new_api": "semispace_copied_size",
          "old_text": null,
          "new_text": "new_space_page_visitor.semispace_copied_size()",
          "old_line_content": "}",
          "new_line_content": "      new_space_page_visitor.semispace_copied_size());",
          "content_same": false
        },
        {
          "line": 3204,
          "old_api": null,
          "new_api": "promoted_size",
          "old_text": null,
          "new_text": "heap()->IncrementYoungSurvivorsCounter(\n      new_space_visitor_.promoted_size() +\n      new_space_visitor_.semispace_copied_size() +\n      new_space_page_visitor.promoted_size() +\n      new_space_page_visitor.semispace_copied_size())",
          "old_line_content": "",
          "new_line_content": "  heap()->IncrementYoungSurvivorsCounter(",
          "content_same": false
        },
        {
          "line": 3205,
          "old_api": null,
          "new_api": "promoted_size",
          "old_text": null,
          "new_text": "new_space_visitor_.promoted_size()",
          "old_line_content": "int MarkCompactCollector::NumberOfParallelCompactionTasks(int pages,",
          "new_line_content": "      new_space_visitor_.promoted_size() +",
          "content_same": false
        },
        {
          "line": 3206,
          "old_api": null,
          "new_api": "semispace_copied_size",
          "old_text": null,
          "new_text": "new_space_visitor_.semispace_copied_size()",
          "old_line_content": "                                                          intptr_t live_bytes) {",
          "new_line_content": "      new_space_visitor_.semispace_copied_size() +",
          "content_same": false
        },
        {
          "line": 3207,
          "old_api": null,
          "new_api": "promoted_size",
          "old_text": null,
          "new_text": "new_space_page_visitor.promoted_size()",
          "old_line_content": "  if (!FLAG_parallel_compaction) return 1;",
          "new_line_content": "      new_space_page_visitor.promoted_size() +",
          "content_same": false
        },
        {
          "line": 3208,
          "old_api": null,
          "new_api": "semispace_copied_size",
          "old_text": null,
          "new_text": "new_space_page_visitor.semispace_copied_size()",
          "old_line_content": "  // Compute the number of needed tasks based on a target compaction time, the",
          "new_line_content": "      new_space_page_visitor.semispace_copied_size());",
          "content_same": false
        },
        {
          "line": 3209,
          "old_api": null,
          "new_api": "MergeAllocationSitePretenuringFeedback",
          "old_text": null,
          "new_text": "heap()->MergeAllocationSitePretenuringFeedback(local_pretenuring_feedback_)",
          "old_line_content": "  // profiled compaction speed and marked live memory.",
          "new_line_content": "  heap()->MergeAllocationSitePretenuringFeedback(local_pretenuring_feedback_);",
          "content_same": false
        },
        {
          "line": 1172,
          "old_api": null,
          "new_api": "IsHeapObject",
          "old_text": null,
          "new_text": "o->IsHeapObject()",
          "old_line_content": "    return true;",
          "new_line_content": "      if (!o->IsHeapObject()) continue;",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": null,
          "new_api": "RecordSlot",
          "old_text": null,
          "new_text": "collector->RecordSlot(object, p, o)",
          "old_line_content": "  }",
          "new_line_content": "      collector->RecordSlot(object, p, o);",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": null,
          "new_api": "HeapObject::cast(o)",
          "old_text": null,
          "new_text": "HeapObject::cast(o)",
          "old_line_content": "",
          "new_line_content": "      HeapObject* obj = HeapObject::cast(o);",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(obj)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(obj)",
          "old_line_content": " private:",
          "new_line_content": "      MarkBit mark = ObjectMarking::MarkBitFrom(obj);",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "Marking::IsBlackOrGrey(mark)",
          "old_text": null,
          "new_text": "Marking::IsBlackOrGrey(mark)",
          "old_line_content": "  // Code flushing support.",
          "new_line_content": "      if (Marking::IsBlackOrGrey(mark)) continue;",
          "content_same": false
        },
        {
          "line": 1177,
          "old_api": null,
          "new_api": "VisitUnmarkedObject",
          "old_text": null,
          "new_text": "VisitUnmarkedObject(collector, obj)",
          "old_line_content": "",
          "new_line_content": "      VisitUnmarkedObject(collector, obj);",
          "content_same": false
        },
        {
          "line": 3225,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()->CompactionSpeedInBytesPerMillisecond()",
          "old_line_content": "  if (compaction_speed > 0) {",
          "new_line_content": "      heap()->tracer()->CompactionSpeedInBytesPerMillisecond();",
          "content_same": false
        },
        {
          "line": 3227,
          "old_api": null,
          "new_api": "NumberOfAvailableBackgroundThreads",
          "old_text": null,
          "new_text": "Max(\n      1, static_cast<int>(\n             V8::GetCurrentPlatform()->NumberOfAvailableBackgroundThreads()) -\n             kNumSweepingTasks - 1)",
          "old_line_content": "                                 kTargetCompactionTimeInMs);",
          "new_line_content": "  const int available_cores = Max(",
          "content_same": false
        },
        {
          "line": 3228,
          "old_api": null,
          "new_api": "NumberOfAvailableBackgroundThreads",
          "old_text": null,
          "new_text": "static_cast<int>(\n             V8::GetCurrentPlatform()->NumberOfAvailableBackgroundThreads())",
          "old_line_content": "  } else {",
          "new_line_content": "      1, static_cast<int>(",
          "content_same": false
        },
        {
          "line": 3229,
          "old_api": null,
          "new_api": "NumberOfAvailableBackgroundThreads",
          "old_text": null,
          "new_text": "V8::GetCurrentPlatform()->NumberOfAvailableBackgroundThreads()",
          "old_line_content": "    tasks = pages;",
          "new_line_content": "             V8::GetCurrentPlatform()->NumberOfAvailableBackgroundThreads()) -",
          "content_same": false
        },
        {
          "line": 3233,
          "old_api": null,
          "new_api": "static_cast<int>(live_bytes / compaction_speed /\n                                 kTargetCompactionTimeInMs)",
          "old_text": null,
          "new_text": "static_cast<int>(live_bytes / compaction_speed /\n                                 kTargetCompactionTimeInMs)",
          "old_line_content": "}",
          "new_line_content": "    tasks = 1 + static_cast<int>(live_bytes / compaction_speed /",
          "content_same": false
        },
        {
          "line": 3238,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(pages, tasks)",
          "old_line_content": "  typedef MarkCompactCollector::Evacuator* PerTaskData;",
          "new_line_content": "  const int tasks_capped_pages = Min(pages, tasks);",
          "content_same": false
        },
        {
          "line": 3239,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(available_cores, tasks_capped_pages)",
          "old_line_content": "",
          "new_line_content": "  return Min(available_cores, tasks_capped_pages);",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": null,
          "new_api": "TypeTag",
          "old_text": null,
          "new_text": "re->TypeTag()",
          "old_line_content": "",
          "new_line_content": "    if (re->TypeTag() != JSRegExp::IRREGEXP) return;",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": null,
          "new_api": "JSRegExp::code_index(is_one_byte)",
          "old_text": null,
          "new_text": "JSRegExp::code_index(is_one_byte)",
          "old_line_content": "      // that was not observed by marker.  This might happen if JSRegExp data",
          "new_line_content": "    Object* code = re->DataAt(JSRegExp::code_index(is_one_byte));",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": null,
          "new_api": "IsSmi",
          "old_text": null,
          "new_text": "code->IsSmi()",
          "old_line_content": "      // was marked through the compilation cache before marker reached JSRegExp",
          "new_line_content": "    if (!code->IsSmi() &&",
          "content_same": false
        },
        {
          "line": 1200,
          "old_api": null,
          "new_api": "map",
          "old_text": null,
          "new_text": "HeapObject::cast(code)->map()->instance_type()",
          "old_line_content": "      // object.",
          "new_line_content": "        HeapObject::cast(code)->map()->instance_type() == CODE_TYPE) {",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "re->data()",
          "old_line_content": "      // Set a number in the 0-255 range to guarantee no smi overflow.",
          "new_line_content": "      FixedArray* data = FixedArray::cast(re->data());",
          "content_same": false
        },
        {
          "line": 3257,
          "old_api": null,
          "new_api": "static_cast<Page*>(chunk)",
          "old_text": null,
          "new_text": "static_cast<Page*>(chunk)",
          "old_line_content": "      case Evacuator::kObjectsNewToOld:",
          "new_line_content": "    Page* p = static_cast<Page*>(chunk);",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": null,
          "new_api": "JSRegExp::code_index(is_one_byte)",
          "old_text": null,
          "new_text": "JSRegExp::code_index(is_one_byte)",
          "old_line_content": "        return;",
          "new_line_content": "      re->SetDataAt(JSRegExp::code_index(is_one_byte),",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": null,
          "new_api": "ms_count",
          "old_text": null,
          "new_text": "heap->ms_count()",
          "old_line_content": "      }",
          "new_line_content": "                    Smi::FromInt(heap->ms_count() & 0xff));",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": null,
          "new_api": "IsSmi",
          "old_text": null,
          "new_text": "code->IsSmi()",
          "old_line_content": "",
          "new_line_content": "    } else if (code->IsSmi()) {",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "Smi::cast(code)->value()",
          "old_line_content": "      // Check if we should flush now.",
          "new_line_content": "      int value = Smi::cast(code)->value();",
          "content_same": false
        },
        {
          "line": 3265,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(success)",
          "old_line_content": "        } else {",
          "new_line_content": "        DCHECK(success);",
          "content_same": false
        },
        {
          "line": 3269,
          "old_api": null,
          "new_api": "IsEvacuationCandidate",
          "old_text": null,
          "new_text": "p->IsEvacuationCandidate()",
          "old_line_content": "          // Slots have already been recorded so we just need to add it to the",
          "new_line_content": "          DCHECK(p->IsEvacuationCandidate());",
          "content_same": false
        },
        {
          "line": 3270,
          "old_api": null,
          "new_api": "SweepingDone",
          "old_text": null,
          "new_text": "p->SweepingDone()",
          "old_line_content": "          // sweeper, which will happen after updating pointers.",
          "new_line_content": "          DCHECK(p->SweepingDone());",
          "content_same": false
        },
        {
          "line": 3271,
          "old_api": null,
          "new_api": "Unlink",
          "old_text": null,
          "new_text": "p->Unlink()",
          "old_line_content": "          *data += 1;",
          "new_line_content": "          p->Unlink();",
          "content_same": false
        },
        {
          "line": 1227,
          "old_api": null,
          "new_api": "ms_count",
          "old_text": null,
          "new_text": "heap->ms_count()",
          "old_line_content": "  }",
          "new_line_content": "      if (value == ((heap->ms_count() - kRegExpCodeThreshold) & 0xff)) {",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": null,
          "new_api": "JSRegExp::code_index(is_one_byte)",
          "old_text": null,
          "new_text": "JSRegExp::code_index(is_one_byte)",
          "old_line_content": "",
          "new_line_content": "        re->SetDataAt(JSRegExp::code_index(is_one_byte),",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": null,
          "new_api": "Smi::FromInt(JSRegExp::kUninitializedValue)",
          "old_text": null,
          "new_text": "Smi::FromInt(JSRegExp::kUninitializedValue)",
          "old_line_content": "",
          "new_line_content": "                      Smi::FromInt(JSRegExp::kUninitializedValue));",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": null,
          "new_api": "JSRegExp::saved_code_index(is_one_byte)",
          "old_text": null,
          "new_text": "JSRegExp::saved_code_index(is_one_byte)",
          "old_line_content": "  // Works by setting the current sweep_generation (as a smi) in the",
          "new_line_content": "        re->SetDataAt(JSRegExp::saved_code_index(is_one_byte),",
          "content_same": false
        },
        {
          "line": 1231,
          "old_api": null,
          "new_api": "Smi::FromInt(JSRegExp::kUninitializedValue)",
          "old_text": null,
          "new_text": "Smi::FromInt(JSRegExp::kUninitializedValue)",
          "old_line_content": "  // code object place in the data array of the RegExp and keeps a copy",
          "new_line_content": "                      Smi::FromInt(JSRegExp::kUninitializedValue));",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": null,
          "new_api": "GetHeap",
          "old_text": null,
          "new_text": "map->GetHeap()",
          "old_line_content": "    // Flush code or set age on both one byte and two byte code.",
          "new_line_content": "    Heap* heap = map->GetHeap();",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": null,
          "new_api": "VisitJSRegExp",
          "old_text": null,
          "new_text": "VisitJSRegExp(map, object)",
          "old_line_content": "    // Visit the fields of the RegExp, including the updated FixedArray.",
          "new_line_content": "      VisitJSRegExp(map, object);",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": null,
          "new_api": "reinterpret_cast<JSRegExp*>(object)",
          "old_text": null,
          "new_text": "reinterpret_cast<JSRegExp*>(object)",
          "old_line_content": "};",
          "new_line_content": "    JSRegExp* re = reinterpret_cast<JSRegExp*>(object);",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": null,
          "new_api": "UpdateRegExpCodeAgeAndFlush",
          "old_text": null,
          "new_text": "UpdateRegExpCodeAgeAndFlush(heap, re, true)",
          "old_line_content": "",
          "new_line_content": "    UpdateRegExpCodeAgeAndFlush(heap, re, true);",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": null,
          "new_api": "UpdateRegExpCodeAgeAndFlush",
          "old_text": null,
          "new_text": "UpdateRegExpCodeAgeAndFlush(heap, re, false)",
          "old_line_content": "void MarkCompactMarkingVisitor::Initialize() {",
          "new_line_content": "    UpdateRegExpCodeAgeAndFlush(heap, re, false);",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": null,
          "new_api": "VisitJSRegExp",
          "old_text": null,
          "new_text": "VisitJSRegExp(map, object)",
          "old_line_content": "",
          "new_line_content": "    VisitJSRegExp(map, object);",
          "content_same": false
        },
        {
          "line": 3302,
          "old_api": null,
          "new_api": "NeverEvacuate",
          "old_text": null,
          "new_text": "page->NeverEvacuate()",
          "old_line_content": "      }",
          "new_line_content": "    if (!page->NeverEvacuate() &&",
          "content_same": false
        },
        {
          "line": 3303,
          "old_api": null,
          "new_api": "Evacuator::PageEvacuationThreshold()",
          "old_text": null,
          "new_text": "Evacuator::PageEvacuationThreshold()",
          "old_line_content": "    }",
          "new_line_content": "        (page->LiveBytes() > Evacuator::PageEvacuationThreshold()) &&",
          "content_same": false
        },
        {
          "line": 3304,
          "old_api": null,
          "new_api": "Contains",
          "old_text": null,
          "new_text": "page->Contains(age_mark)",
          "old_line_content": "",
          "new_line_content": "        !page->Contains(age_mark)) {",
          "content_same": false
        },
        {
          "line": 3306,
          "old_api": null,
          "new_api": "old_space",
          "old_text": null,
          "new_text": "heap()->old_space()",
          "old_line_content": "  }",
          "new_line_content": "        EvacuateNewSpacePageVisitor::MoveToOldSpace(page, heap()->old_space());",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": null,
          "new_api": "StaticMarkingVisitor<MarkCompactMarkingVisitor>::Initialize()",
          "old_text": null,
          "new_text": "StaticMarkingVisitor<MarkCompactMarkingVisitor>::Initialize()",
          "old_line_content": " public:",
          "new_line_content": "  StaticMarkingVisitor<MarkCompactMarkingVisitor>::Initialize();",
          "content_same": false
        },
        {
          "line": 3308,
          "old_api": null,
          "new_api": "EvacuateNewSpacePageVisitor::MoveToToSpace(page)",
          "old_text": null,
          "new_text": "EvacuateNewSpacePageVisitor::MoveToToSpace(page)",
          "old_line_content": "",
          "new_line_content": "        EvacuateNewSpacePageVisitor::MoveToToSpace(page);",
          "content_same": false
        },
        {
          "line": 1262,
          "old_api": null,
          "new_api": "Register",
          "old_text": null,
          "new_text": "table_.Register(kVisitJSRegExp, &VisitRegExpAndFlushCode)",
          "old_line_content": "      : collector_(collector) {}",
          "new_line_content": "  table_.Register(kVisitJSRegExp, &VisitRegExpAndFlushCode);",
          "content_same": false
        },
        {
          "line": 3314,
          "old_api": null,
          "new_api": "NumberOfPages",
          "old_text": null,
          "new_text": "job.NumberOfPages()",
          "old_line_content": "",
          "new_line_content": "  DCHECK_GE(job.NumberOfPages(), 1);",
          "content_same": false
        },
        {
          "line": 1268,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": " private:",
          "new_line_content": "  explicit CodeMarkingVisitor(MarkCompactCollector* collector)",
          "content_same": false
        },
        {
          "line": 3319,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()->CompactionSpeedInBytesPerMillisecond()",
          "old_line_content": "    evacuators[i] = new Evacuator(this);",
          "new_line_content": "    compaction_speed = heap()->tracer()->CompactionSpeedInBytesPerMillisecond();",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": null,
          "new_api": "PrepareThreadForCodeFlushing",
          "old_text": null,
          "new_text": "collector_->PrepareThreadForCodeFlushing(isolate, top)",
          "old_line_content": "",
          "new_line_content": "    collector_->PrepareThreadForCodeFlushing(isolate, top);",
          "content_same": false
        },
        {
          "line": 3328,
          "old_api": null,
          "new_api": "Run",
          "old_text": null,
          "new_text": "job.Run(wanted_num_tasks, [evacuators](int i) { return evacuators[i]; })",
          "old_line_content": "  if (FLAG_trace_evacuation) {",
          "new_line_content": "  job.Run(wanted_num_tasks, [evacuators](int i) { return evacuators[i]; });",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "  void VisitPointer(Object** slot) override {",
          "new_line_content": "  explicit SharedFunctionInfoMarkingVisitor(MarkCompactCollector* collector)",
          "content_same": false
        },
        {
          "line": 3330,
          "old_api": null,
          "new_api": "Finalize",
          "old_text": null,
          "new_text": "evacuators[i]->Finalize()",
          "old_line_content": "                 \"%8.0f ms: evacuation-summary: parallel=%s pages=%d \"",
          "new_line_content": "    evacuators[i]->Finalize();",
          "content_same": false
        },
        {
          "line": 1291,
          "old_api": null,
          "new_api": "IsSharedFunctionInfo",
          "old_text": null,
          "new_text": "obj->IsSharedFunctionInfo()",
          "old_line_content": "  }",
          "new_line_content": "    if (obj->IsSharedFunctionInfo()) {",
          "content_same": false
        },
        {
          "line": 1292,
          "old_api": null,
          "new_api": "reinterpret_cast<SharedFunctionInfo*>(obj)",
          "old_text": null,
          "new_text": "reinterpret_cast<SharedFunctionInfo*>(obj)",
          "old_line_content": "",
          "new_line_content": "      SharedFunctionInfo* shared = reinterpret_cast<SharedFunctionInfo*>(obj);",
          "content_same": false
        },
        {
          "line": 1293,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(shared)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(shared)",
          "old_line_content": " private:",
          "new_line_content": "      MarkBit shared_mark = ObjectMarking::MarkBitFrom(shared);",
          "content_same": false
        },
        {
          "line": 1294,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "shared->code()",
          "old_line_content": "  MarkCompactCollector* collector_;",
          "new_line_content": "      MarkBit code_mark = ObjectMarking::MarkBitFrom(shared->code());",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "shared->code()",
          "old_line_content": "};",
          "new_line_content": "      collector_->MarkObject(shared->code(), code_mark);",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": null,
          "new_api": "MarkObject",
          "old_text": null,
          "new_text": "collector_->MarkObject(shared, shared_mark)",
          "old_line_content": "",
          "new_line_content": "      collector_->MarkObject(shared, shared_mark);",
          "content_same": false
        },
        {
          "line": 3340,
          "old_api": null,
          "new_api": "time_millis_since_init",
          "old_text": null,
          "new_text": "isolate()->time_millis_since_init()",
          "old_line_content": "",
          "new_line_content": "                 isolate()->time_millis_since_init(),",
          "content_same": false
        },
        {
          "line": 3341,
          "old_api": null,
          "new_api": "NumberOfPages",
          "old_text": null,
          "new_text": "job.NumberOfPages()",
          "old_line_content": "class EvacuationWeakObjectRetainer : public WeakObjectRetainer {",
          "new_line_content": "                 FLAG_parallel_compaction ? \"yes\" : \"no\", job.NumberOfPages(),",
          "content_same": false
        },
        {
          "line": 3342,
          "old_api": null,
          "new_api": "NumberOfTasks",
          "old_text": null,
          "new_text": "job.NumberOfTasks()",
          "old_line_content": " public:",
          "new_line_content": "                 abandoned_pages, wanted_num_tasks, job.NumberOfTasks(),",
          "content_same": false
        },
        {
          "line": 3343,
          "old_api": null,
          "new_api": "NumberOfAvailableBackgroundThreads",
          "old_text": null,
          "new_text": "V8::GetCurrentPlatform()->NumberOfAvailableBackgroundThreads()",
          "old_line_content": "  virtual Object* RetainAs(Object* object) {",
          "new_line_content": "                 V8::GetCurrentPlatform()->NumberOfAvailableBackgroundThreads(),",
          "content_same": false
        },
        {
          "line": 3351,
          "old_api": null,
          "new_api": "IsHeapObject",
          "old_text": null,
          "new_text": "object->IsHeapObject()",
          "old_line_content": "    return object;",
          "new_line_content": "    if (object->IsHeapObject()) {",
          "content_same": false
        },
        {
          "line": 3352,
          "old_api": null,
          "new_api": "HeapObject::cast(object)",
          "old_text": null,
          "new_text": "HeapObject::cast(object)",
          "old_line_content": "  }",
          "new_line_content": "      HeapObject* heap_object = HeapObject::cast(object);",
          "content_same": false
        },
        {
          "line": 3353,
          "old_api": null,
          "new_api": "map_word",
          "old_text": null,
          "new_text": "heap_object->map_word()",
          "old_line_content": "};",
          "new_line_content": "      MapWord map_word = heap_object->map_word();",
          "content_same": false
        },
        {
          "line": 3354,
          "old_api": null,
          "new_api": "IsForwardingAddress",
          "old_text": null,
          "new_text": "map_word.IsForwardingAddress()",
          "old_line_content": "",
          "new_line_content": "      if (map_word.IsForwardingAddress()) {",
          "content_same": false
        },
        {
          "line": 3355,
          "old_api": null,
          "new_api": "ToForwardingAddress",
          "old_text": null,
          "new_text": "map_word.ToForwardingAddress()",
          "old_line_content": "int MarkCompactCollector::Sweeper::RawSweep(",
          "new_line_content": "        return map_word.ToForwardingAddress();",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": null,
          "new_api": "unchecked_code",
          "old_text": null,
          "new_text": "frame->unchecked_code()",
          "old_line_content": "    }",
          "new_line_content": "    Code* code = frame->unchecked_code();",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(code)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(code)",
          "old_line_content": "  }",
          "new_line_content": "    MarkBit code_mark = ObjectMarking::MarkBitFrom(code);",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": null,
          "new_api": "MarkObject",
          "old_text": null,
          "new_text": "MarkObject(code, code_mark)",
          "old_line_content": "}",
          "new_line_content": "    MarkObject(code, code_mark);",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": null,
          "new_api": "is_optimized",
          "old_text": null,
          "new_text": "frame->is_optimized()",
          "old_line_content": "",
          "new_line_content": "    if (frame->is_optimized()) {",
          "content_same": false
        },
        {
          "line": 1317,
          "old_api": null,
          "new_api": "LookupCode",
          "old_text": null,
          "new_text": "frame->LookupCode()",
          "old_line_content": "",
          "new_line_content": "      Code* optimized_code = frame->LookupCode();",
          "content_same": false
        },
        {
          "line": 1318,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(optimized_code)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(optimized_code)",
          "old_line_content": "void MarkCompactCollector::PrepareForCodeFlushing() {",
          "new_line_content": "      MarkBit optimized_code_mark = ObjectMarking::MarkBitFrom(optimized_code);",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": null,
          "new_api": "MarkObject",
          "old_text": null,
          "new_text": "MarkObject(optimized_code, optimized_code_mark)",
          "old_line_content": "  // If code flushing is disabled, there is no need to prepare for it.",
          "new_line_content": "      MarkObject(optimized_code, optimized_code_mark);",
          "content_same": false
        },
        {
          "line": 3365,
          "old_api": null,
          "new_api": "owner",
          "old_text": null,
          "new_text": "p->owner()",
          "old_line_content": "  // requires valid mark bits.",
          "new_line_content": "  Space* space = p->owner();",
          "content_same": false
        },
        {
          "line": 3367,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "space->identity()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(free_list_mode == IGNORE_FREE_LIST || space->identity() == OLD_SPACE ||",
          "content_same": false
        },
        {
          "line": 3373,
          "old_api": null,
          "new_api": "ArrayBufferTracker::FreeDead(p)",
          "old_text": null,
          "new_text": "ArrayBufferTracker::FreeDead(p)",
          "old_line_content": "  // deoptimizer.",
          "new_line_content": "  ArrayBufferTracker::FreeDead(p);",
          "content_same": false
        },
        {
          "line": 1327,
          "old_api": null,
          "new_api": "is_code_flushing_enabled",
          "old_text": null,
          "new_text": "is_code_flushing_enabled()",
          "old_line_content": "  // Iterate the archived stacks in all threads to check if",
          "new_line_content": "  if (!is_code_flushing_enabled()) return;",
          "content_same": false
        },
        {
          "line": 1331,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "heap()->isolate()",
          "old_line_content": "      &code_marking_visitor);",
          "new_line_content": "  PrepareThreadForCodeFlushing(heap()->isolate(),",
          "content_same": false
        },
        {
          "line": 1332,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "heap()->isolate()->thread_local_top()",
          "old_line_content": "",
          "new_line_content": "                               heap()->isolate()->thread_local_top());",
          "content_same": false
        },
        {
          "line": 3382,
          "old_api": null,
          "new_api": "skip_list",
          "old_text": null,
          "new_text": "p->skip_list()",
          "old_line_content": "  intptr_t max_freed_bytes = 0;",
          "new_line_content": "      space->identity() == CODE_SPACE && p->skip_list() != nullptr;",
          "content_same": false
        },
        {
          "line": 3383,
          "old_api": null,
          "new_api": "skip_list",
          "old_text": null,
          "new_text": "p->skip_list()",
          "old_line_content": "  int curr_region = -1;",
          "new_line_content": "  SkipList* skip_list = p->skip_list();",
          "content_same": false
        },
        {
          "line": 3385,
          "old_api": null,
          "new_api": "Clear",
          "old_text": null,
          "new_text": "skip_list->Clear()",
          "old_line_content": "  LiveObjectIterator<kBlackObjects> it(p);",
          "new_line_content": "    skip_list->Clear();",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "heap()->isolate()->compilation_cache()->IterateFunctions(&visitor)",
          "old_line_content": "// Visitor class for marking heap roots.",
          "new_line_content": "  heap()->isolate()->compilation_cache()->IterateFunctions(&visitor);",
          "content_same": false
        },
        {
          "line": 1342,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "heap()->isolate()->handle_scope_implementer()->Iterate(&visitor)",
          "old_line_content": "class RootMarkingVisitor : public ObjectVisitor {",
          "new_line_content": "  heap()->isolate()->handle_scope_implementer()->Iterate(&visitor);",
          "content_same": false
        },
        {
          "line": 3394,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "it.Next()",
          "old_line_content": "      }",
          "new_line_content": "  while ((object = it.Next()) != NULL) {",
          "content_same": false
        },
        {
          "line": 3395,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(object)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(object)",
          "old_line_content": "      if (free_list_mode == REBUILD_FREE_LIST) {",
          "new_line_content": "    DCHECK(Marking::IsBlack(ObjectMarking::MarkBitFrom(object)));",
          "content_same": false
        },
        {
          "line": 1351,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "  }",
          "new_line_content": "  explicit RootMarkingVisitor(Heap* heap)",
          "content_same": false
        },
        {
          "line": 1352,
          "old_api": null,
          "new_api": "mark_compact_collector",
          "old_text": null,
          "new_text": "heap->mark_compact_collector()",
          "old_line_content": "",
          "new_line_content": "      : collector_(heap->mark_compact_collector()) {}",
          "content_same": false
        },
        {
          "line": 1354,
          "old_api": null,
          "new_api": "MarkObjectByPointer",
          "old_text": null,
          "new_text": "MarkObjectByPointer(p)",
          "old_line_content": "  // ProcessTopOptimizedFrame.",
          "new_line_content": "  void VisitPointer(Object** p) override { MarkObjectByPointer(p); }",
          "content_same": false
        },
        {
          "line": 3403,
          "old_api": null,
          "new_api": "UnaccountedFree",
          "old_text": null,
          "new_text": "reinterpret_cast<PagedSpace*>(space)->UnaccountedFree(\n            free_start, size)",
          "old_line_content": "    }",
          "new_line_content": "        freed_bytes = reinterpret_cast<PagedSpace*>(space)->UnaccountedFree(",
          "content_same": false
        },
        {
          "line": 1357,
          "old_api": null,
          "new_api": "MarkObjectByPointer",
          "old_text": null,
          "new_text": "MarkObjectByPointer(p)",
          "old_line_content": " private:",
          "new_line_content": "    for (Object** p = start; p < end; p++) MarkObjectByPointer(p);",
          "content_same": false
        },
        {
          "line": 3412,
          "old_api": null,
          "new_api": "SizeFromMap",
          "old_text": null,
          "new_text": "object->SizeFromMap(map)",
          "old_line_content": "        curr_region = new_region_end;",
          "new_line_content": "    int size = object->SizeFromMap(map);",
          "content_same": false
        },
        {
          "line": 3414,
          "old_api": null,
          "new_api": "SkipList::RegionNumber(free_end)",
          "old_text": null,
          "new_text": "SkipList::RegionNumber(free_end)",
          "old_line_content": "    }",
          "new_line_content": "      int new_region_start = SkipList::RegionNumber(free_end);",
          "content_same": false
        },
        {
          "line": 3416,
          "old_api": null,
          "new_api": "SkipList::RegionNumber(free_end + size - kPointerSize)",
          "old_text": null,
          "new_text": "SkipList::RegionNumber(free_end + size - kPointerSize)",
          "old_line_content": "  }",
          "new_line_content": "          SkipList::RegionNumber(free_end + size - kPointerSize);",
          "content_same": false
        },
        {
          "line": 1370,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(object)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(object)",
          "old_line_content": "    // Mark the map pointer and body, and push them on the marking stack.",
          "new_line_content": "    MarkBit mark_bit = ObjectMarking::MarkBitFrom(object);",
          "content_same": false
        },
        {
          "line": 3418,
          "old_api": null,
          "new_api": "AddObject",
          "old_text": null,
          "new_text": "skip_list->AddObject(free_end, size)",
          "old_line_content": "  // Clear the mark bits of that page and reset live bytes count.",
          "new_line_content": "        skip_list->AddObject(free_end, size);",
          "content_same": false
        },
        {
          "line": 1375,
          "old_api": null,
          "new_api": "SetMark",
          "old_text": null,
          "new_text": "collector_->SetMark(object, mark_bit)",
          "old_line_content": "    // Mark all the objects reachable from the map and body.  May leave",
          "new_line_content": "    collector_->SetMark(object, mark_bit);",
          "content_same": false
        },
        {
          "line": 1378,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(map)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(map)",
          "old_line_content": "  }",
          "new_line_content": "    MarkBit map_mark = ObjectMarking::MarkBitFrom(map);",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": null,
          "new_api": "MarkObject",
          "old_text": null,
          "new_text": "collector_->MarkObject(map, map_mark)",
          "old_line_content": "",
          "new_line_content": "    collector_->MarkObject(map, map_mark);",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": null,
          "new_api": "MarkCompactMarkingVisitor::IterateBody(map, object)",
          "old_text": null,
          "new_text": "MarkCompactMarkingVisitor::IterateBody(map, object)",
          "old_line_content": "  MarkCompactCollector* collector_;",
          "new_line_content": "    MarkCompactMarkingVisitor::IterateBody(map, object);",
          "content_same": false
        },
        {
          "line": 3426,
          "old_api": null,
          "new_api": "ClearLiveness",
          "old_text": null,
          "new_text": "p->ClearLiveness()",
          "old_line_content": "    if (free_list_mode == REBUILD_FREE_LIST) {",
          "new_line_content": "  p->ClearLiveness();",
          "content_same": false
        },
        {
          "line": 3428,
          "old_api": null,
          "new_api": "area_end",
          "old_text": null,
          "new_text": "p->area_end()",
          "old_line_content": "          free_start, size);",
          "new_line_content": "  if (free_start != p->area_end()) {",
          "content_same": false
        },
        {
          "line": 1384,
          "old_api": null,
          "new_api": "EmptyMarkingDeque",
          "old_text": null,
          "new_text": "collector_->EmptyMarkingDeque()",
          "old_line_content": "// Helper class for pruning the string table.",
          "new_line_content": "    collector_->EmptyMarkingDeque();",
          "content_same": false
        },
        {
          "line": 3434,
          "old_api": null,
          "new_api": "UnaccountedFree",
          "old_text": null,
          "new_text": "reinterpret_cast<PagedSpace*>(space)->UnaccountedFree(\n          free_start, size)",
          "old_line_content": "  }",
          "new_line_content": "      freed_bytes = reinterpret_cast<PagedSpace*>(space)->UnaccountedFree(",
          "content_same": false
        },
        {
          "line": 3436,
          "old_api": null,
          "new_api": "Max",
          "old_text": null,
          "new_text": "Max(freed_bytes, max_freed_bytes)",
          "old_line_content": "  if (free_list_mode == IGNORE_FREE_LIST) return 0;",
          "new_line_content": "      max_freed_bytes = Max(freed_bytes, max_freed_bytes);",
          "content_same": false
        },
        {
          "line": 3438,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "p->heap()->CreateFillerObjectAt(free_start, size,\n                                      ClearRecordedSlots::kNo)",
          "old_line_content": "}",
          "new_line_content": "      p->heap()->CreateFillerObjectAt(free_start, size,",
          "content_same": false
        },
        {
          "line": 3444,
          "old_api": null,
          "new_api": "static_cast<int>(max_freed_bytes)",
          "old_text": null,
          "new_text": "static_cast<int>(max_freed_bytes)",
          "old_line_content": "",
          "new_line_content": "  return FreeList::GuaranteedAllocatable(static_cast<int>(max_freed_bytes));",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(!record_slots || table != nullptr)",
          "old_line_content": "      Object* o = *p;",
          "new_line_content": "    DCHECK(!record_slots || table != nullptr);",
          "content_same": false
        },
        {
          "line": 3450,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "code->Size()",
          "old_line_content": "",
          "new_line_content": "  Address end = code->address() + code->Size();",
          "content_same": false
        },
        {
          "line": 1405,
          "old_api": null,
          "new_api": "IsHeapObject",
          "old_text": null,
          "new_text": "o->IsHeapObject()",
          "old_line_content": "          }",
          "new_line_content": "      if (o->IsHeapObject()) {",
          "content_same": false
        },
        {
          "line": 1406,
          "old_api": null,
          "new_api": "HeapObject::cast(o)",
          "old_text": null,
          "new_text": "HeapObject::cast(o)",
          "old_line_content": "          // Set the entry to the_hole_value (as deleted).",
          "new_line_content": "        if (Marking::IsWhite(ObjectMarking::MarkBitFrom(HeapObject::cast(o)))) {",
          "content_same": false
        },
        {
          "line": 3454,
          "old_api": null,
          "new_api": "incremental_marking",
          "old_text": null,
          "new_text": "heap_->incremental_marking()->IsCompacting()",
          "old_line_content": "",
          "new_line_content": "  if (heap_->incremental_marking()->IsCompacting() &&",
          "content_same": false
        },
        {
          "line": 1408,
          "old_api": null,
          "new_api": "IsExternalString",
          "old_text": null,
          "new_text": "o->IsExternalString()",
          "old_line_content": "        } else if (record_slots) {",
          "new_line_content": "            DCHECK(o->IsExternalString());",
          "content_same": false
        },
        {
          "line": 1409,
          "old_api": null,
          "new_api": "String::cast(*p)",
          "old_text": null,
          "new_text": "String::cast(*p)",
          "old_line_content": "          // StringTable contains only old space strings.",
          "new_line_content": "            heap_->FinalizeExternalString(String::cast(*p));",
          "content_same": false
        },
        {
          "line": 3455,
          "old_api": null,
          "new_api": "ShouldSkipEvacuationSlotRecording",
          "old_text": null,
          "new_text": "ShouldSkipEvacuationSlotRecording(code)",
          "old_line_content": "    // Ignore all slots that might have been recorded in the body of the",
          "new_line_content": "      !ShouldSkipEvacuationSlotRecording(code)) {",
          "content_same": false
        },
        {
          "line": 3456,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(compacting_)",
          "old_line_content": "    // deoptimized code object. Assumption: no slots will be recorded for",
          "new_line_content": "    DCHECK(compacting_);",
          "content_same": false
        },
        {
          "line": 3459,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(code)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(code)",
          "old_line_content": "  }",
          "new_line_content": "    MarkBit mark_bit = ObjectMarking::MarkBitFrom(code);",
          "content_same": false
        },
        {
          "line": 3460,
          "old_api": null,
          "new_api": "Marking::IsWhite(mark_bit)",
          "old_text": null,
          "new_text": "Marking::IsWhite(mark_bit)",
          "old_line_content": "}",
          "new_line_content": "    if (Marking::IsWhite(mark_bit)) return;",
          "content_same": false
        },
        {
          "line": 1414,
          "old_api": null,
          "new_api": "the_hole_value",
          "old_text": null,
          "new_text": "heap_->the_hole_value()",
          "old_line_content": "    }",
          "new_line_content": "          *p = heap_->the_hole_value();",
          "content_same": false
        },
        {
          "line": 1417,
          "old_api": null,
          "new_api": "InNewSpace",
          "old_text": null,
          "new_text": "heap_->InNewSpace(o)",
          "old_line_content": "  int PointersRemoved() {",
          "new_line_content": "          DCHECK(!heap_->InNewSpace(o));",
          "content_same": false
        },
        {
          "line": 3472,
          "old_api": null,
          "new_api": "marked_for_deoptimization",
          "old_text": null,
          "new_text": "code->marked_for_deoptimization()",
          "old_line_content": "  HeapObject* object = NULL;",
          "new_line_content": "  return code->is_optimized_code() && code->marked_for_deoptimization();",
          "content_same": false
        },
        {
          "line": 1425,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(!finalize_external_strings)",
          "old_line_content": "  HeapObject* table_;",
          "new_line_content": "    DCHECK(!finalize_external_strings);",
          "content_same": false
        },
        {
          "line": 3480,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "it.Next()",
          "old_line_content": "bool MarkCompactCollector::VisitLiveObjects(MemoryChunk* page, Visitor* visitor,",
          "new_line_content": "  while ((object = it.Next()) != NULL) {",
          "content_same": false
        },
        {
          "line": 3481,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(object)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(object)",
          "old_line_content": "                                            IterationMode mode) {",
          "new_line_content": "    CHECK(Marking::IsBlack(ObjectMarking::MarkBitFrom(object)));",
          "content_same": false
        },
        {
          "line": 1443,
          "old_api": null,
          "new_api": "HeapObject::cast(object)",
          "old_text": null,
          "new_text": "HeapObject::cast(object)",
          "old_line_content": "      // space. These sites get a one-time reprieve.",
          "new_line_content": "    MarkBit mark_bit = ObjectMarking::MarkBitFrom(HeapObject::cast(object));",
          "content_same": false
        },
        {
          "line": 1447,
          "old_api": null,
          "new_api": "IsAllocationSite",
          "old_text": null,
          "new_text": "object->IsAllocationSite()",
          "old_line_content": "      return object;",
          "new_line_content": "    } else if (object->IsAllocationSite() &&",
          "content_same": false
        },
        {
          "line": 1448,
          "old_api": null,
          "new_api": "IsZombie",
          "old_text": null,
          "new_text": "AllocationSite::cast(object)->IsZombie()",
          "old_line_content": "    } else {",
          "new_line_content": "               !(AllocationSite::cast(object)->IsZombie())) {",
          "content_same": false
        },
        {
          "line": 1451,
          "old_api": null,
          "new_api": "AllocationSite::cast(object)",
          "old_text": null,
          "new_text": "AllocationSite::cast(object)",
          "old_line_content": "  }",
          "new_line_content": "      AllocationSite* site = AllocationSite::cast(object);",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": null,
          "new_api": "MarkZombie",
          "old_text": null,
          "new_text": "site->MarkZombie()",
          "old_line_content": "};",
          "new_line_content": "      site->MarkZombie();",
          "content_same": false
        },
        {
          "line": 1453,
          "old_api": null,
          "new_api": "GetHeap",
          "old_text": null,
          "new_text": "site->GetHeap()->mark_compact_collector()->MarkAllocationSite(site)",
          "old_line_content": "",
          "new_line_content": "      site->GetHeap()->mark_compact_collector()->MarkAllocationSite(site);",
          "content_same": false
        },
        {
          "line": 3502,
          "old_api": null,
          "new_api": "old_to_new_slots",
          "old_text": null,
          "new_text": "page->old_to_new_slots()",
          "old_line_content": "        }",
          "new_line_content": "        if (page->old_to_new_slots() != nullptr) {",
          "content_same": false
        },
        {
          "line": 3504,
          "old_api": null,
          "new_api": "address",
          "old_text": null,
          "new_text": "page->address()",
          "old_line_content": "      }",
          "new_line_content": "              0, static_cast<int>(object->address() - page->address()));",
          "content_same": false
        },
        {
          "line": 3506,
          "old_api": null,
          "new_api": "typed_old_to_new_slots",
          "old_text": null,
          "new_text": "page->typed_old_to_new_slots()",
          "old_line_content": "    }",
          "new_line_content": "        if (page->typed_old_to_new_slots() != nullptr) {",
          "content_same": false
        },
        {
          "line": 3507,
          "old_api": null,
          "new_api": "address",
          "old_text": null,
          "new_text": "page->address()",
          "old_line_content": "  }",
          "new_line_content": "          RememberedSet<OLD_TO_NEW>::RemoveRangeTyped(page, page->address(),",
          "content_same": false
        },
        {
          "line": 3508,
          "old_api": null,
          "new_api": "address",
          "old_text": null,
          "new_text": "object->address()",
          "old_line_content": "  if (mode == kClearMarkbits) {",
          "new_line_content": "                                                      object->address());",
          "content_same": false
        },
        {
          "line": 3510,
          "old_api": null,
          "new_api": "RecomputeLiveBytes",
          "old_text": null,
          "new_text": "RecomputeLiveBytes(page)",
          "old_line_content": "  }",
          "new_line_content": "        RecomputeLiveBytes(page);",
          "content_same": false
        },
        {
          "line": 3516,
          "old_api": null,
          "new_api": "ClearLiveness",
          "old_text": null,
          "new_text": "page->ClearLiveness()",
          "old_line_content": "  LiveObjectIterator<kBlackObjects> it(page);",
          "new_line_content": "    page->ClearLiveness();",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": null,
          "new_api": "one_pointer_filler_map",
          "old_text": null,
          "new_text": "heap()->one_pointer_filler_map()",
          "old_line_content": "    }",
          "new_line_content": "  Map* filler_map = heap()->one_pointer_filler_map();",
          "content_same": false
        },
        {
          "line": 1472,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "it->Next()",
          "old_line_content": "  }",
          "new_line_content": "  for (HeapObject* object = it->Next(); object != NULL; object = it->Next()) {",
          "content_same": false
        },
        {
          "line": 1473,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(object)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(object)",
          "old_line_content": "}",
          "new_line_content": "    MarkBit markbit = ObjectMarking::MarkBitFrom(object);",
          "content_same": false
        },
        {
          "line": 1474,
          "old_api": null,
          "new_api": "Marking::IsGrey(markbit)",
          "old_text": null,
          "new_text": "Marking::IsGrey(markbit)",
          "old_line_content": "",
          "new_line_content": "    if ((object->map() != filler_map) && Marking::IsGrey(markbit)) {",
          "content_same": false
        },
        {
          "line": 1475,
          "old_api": null,
          "new_api": "Marking::GreyToBlack(markbit)",
          "old_text": null,
          "new_text": "Marking::GreyToBlack(markbit)",
          "old_line_content": "void MarkCompactCollector::DiscoverGreyObjectsOnPage(MemoryChunk* p) {",
          "new_line_content": "      Marking::GreyToBlack(markbit);",
          "content_same": false
        },
        {
          "line": 1477,
          "old_api": null,
          "new_api": "IsFull",
          "old_text": null,
          "new_text": "marking_deque()->IsFull()",
          "old_line_content": "  LiveObjectIterator<kGreyObjects> it(p);",
          "new_line_content": "      if (marking_deque()->IsFull()) return;",
          "content_same": false
        },
        {
          "line": 3526,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "it.Next()",
          "old_line_content": "                                                     Page* page) {",
          "new_line_content": "  while ((object = it.Next()) != nullptr) {",
          "content_same": false
        },
        {
          "line": 3527,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "object->Size()",
          "old_line_content": "  base::LockGuard<base::Mutex> guard(&mutex_);",
          "new_line_content": "    new_live_size += object->Size();",
          "content_same": false
        },
        {
          "line": 3529,
          "old_api": null,
          "new_api": "SetLiveBytes",
          "old_text": null,
          "new_text": "page->SetLiveBytes(new_live_size)",
          "old_line_content": "}",
          "new_line_content": "  page->SetLiveBytes(new_live_size);",
          "content_same": false
        },
        {
          "line": 1486,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "it.Next()",
          "old_line_content": "}",
          "new_line_content": "  while ((object = it.Next()) != NULL) {",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(object)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(object)",
          "old_line_content": "",
          "new_line_content": "    MarkBit markbit = ObjectMarking::MarkBitFrom(object);",
          "content_same": false
        },
        {
          "line": 1488,
          "old_api": null,
          "new_api": "Marking::IsGrey(markbit)",
          "old_text": null,
          "new_text": "Marking::IsGrey(markbit)",
          "old_line_content": "class RecordMigratedSlotVisitor final : public ObjectVisitor {",
          "new_line_content": "    DCHECK(Marking::IsGrey(markbit));",
          "content_same": false
        },
        {
          "line": 1489,
          "old_api": null,
          "new_api": "Marking::GreyToBlack(markbit)",
          "old_text": null,
          "new_text": "Marking::GreyToBlack(markbit)",
          "old_line_content": " public:",
          "new_line_content": "    Marking::GreyToBlack(markbit);",
          "content_same": false
        },
        {
          "line": 3535,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "space->identity()",
          "old_line_content": "  {",
          "new_line_content": "  swept_list_[space->identity()].Add(page);",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": null,
          "new_api": "IsFull",
          "old_text": null,
          "new_text": "marking_deque()->IsFull()",
          "old_line_content": "      : collector_(collector) {}",
          "new_line_content": "    if (marking_deque()->IsFull()) return;",
          "content_same": false
        },
        {
          "line": 3543,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()",
          "old_line_content": "",
          "new_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_EVACUATE_COPY);",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "  inline void VisitPointers(Object** start, Object** end) final {",
          "new_line_content": "  explicit RecordMigratedSlotVisitor(MarkCompactCollector* collector)",
          "content_same": false
        },
        {
          "line": 3548,
          "old_api": null,
          "new_api": "new_space",
          "old_text": null,
          "new_text": "heap()->new_space()->top()",
          "old_line_content": "  }",
          "new_line_content": "    heap()->new_space()->set_age_mark(heap()->new_space()->top());",
          "content_same": false
        },
        {
          "line": 1501,
          "old_api": null,
          "new_api": "reinterpret_cast<Address>(p)",
          "old_text": null,
          "new_text": "reinterpret_cast<Address>(p)",
          "old_line_content": "    }",
          "new_line_content": "    RecordMigratedSlot(*p, reinterpret_cast<Address>(p));",
          "content_same": false
        },
        {
          "line": 3551,
          "old_api": null,
          "new_api": "UpdatePointersAfterEvacuation",
          "old_text": null,
          "new_text": "UpdatePointersAfterEvacuation()",
          "old_line_content": "  // slots only handles old space (for unboxed doubles), and thus map space can",
          "new_line_content": "  UpdatePointersAfterEvacuation();",
          "content_same": false
        },
        {
          "line": 3553,
          "old_api": null,
          "new_api": "new_space",
          "old_text": null,
          "new_text": "heap()->new_space()->Rebalance()",
          "old_line_content": "  // to still have access to page headers.",
          "new_line_content": "  if (!heap()->new_space()->Rebalance()) {",
          "content_same": false
        },
        {
          "line": 1512,
          "old_api": null,
          "new_api": "Memory::Address_at(code_entry_slot)",
          "old_text": null,
          "new_text": "Memory::Address_at(code_entry_slot)",
          "old_line_content": "",
          "new_line_content": "    Address code_entry = Memory::Address_at(code_entry_slot);",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": null,
          "new_api": "IsEvacuationCandidate",
          "old_text": null,
          "new_text": "Page::FromAddress(code_entry)->IsEvacuationCandidate()",
          "old_line_content": "  inline void VisitCodeTarget(RelocInfo* rinfo) final {",
          "new_line_content": "    if (Page::FromAddress(code_entry)->IsEvacuationCandidate()) {",
          "content_same": false
        },
        {
          "line": 3568,
          "old_api": null,
          "new_api": "ClearFlag",
          "old_text": null,
          "new_text": "p->ClearFlag(Page::PAGE_NEW_NEW_PROMOTION)",
          "old_line_content": "      }",
          "new_line_content": "        p->ClearFlag(Page::PAGE_NEW_NEW_PROMOTION);",
          "content_same": false
        },
        {
          "line": 1521,
          "old_api": null,
          "new_api": "rmode",
          "old_text": null,
          "new_text": "rinfo->rmode()",
          "old_line_content": "  }",
          "new_line_content": "    DCHECK(RelocInfo::IsCodeTarget(rinfo->rmode()));",
          "content_same": false
        },
        {
          "line": 1522,
          "old_api": null,
          "new_api": "target_address",
          "old_text": null,
          "new_text": "rinfo->target_address()",
          "old_line_content": "",
          "new_line_content": "    Code* target = Code::GetCodeFromTargetAddress(rinfo->target_address());",
          "content_same": false
        },
        {
          "line": 1523,
          "old_api": null,
          "new_api": "host",
          "old_text": null,
          "new_text": "rinfo->host()",
          "old_line_content": "  inline void VisitDebugTarget(RelocInfo* rinfo) final {",
          "new_line_content": "    Code* host = rinfo->host();",
          "content_same": false
        },
        {
          "line": 3569,
          "old_api": null,
          "new_api": "owner",
          "old_text": null,
          "new_text": "p->owner()->identity()",
          "old_line_content": "    }",
          "new_line_content": "        sweeper().AddLatePage(p->owner()->identity(), p);",
          "content_same": false
        },
        {
          "line": 3571,
          "old_api": null,
          "new_api": "ClearFlag",
          "old_text": null,
          "new_text": "p->ClearFlag(Page::PAGE_NEW_OLD_PROMOTION)",
          "old_line_content": "",
          "new_line_content": "        p->ClearFlag(Page::PAGE_NEW_OLD_PROMOTION);",
          "content_same": false
        },
        {
          "line": 3572,
          "old_api": null,
          "new_api": "ForAllFreeListCategories",
          "old_text": null,
          "new_text": "p->ForAllFreeListCategories(\n            [](FreeListCategory* category) { DCHECK(!category->is_linked()); })",
          "old_line_content": "    for (Page* p : evacuation_candidates_) {",
          "new_line_content": "        p->ForAllFreeListCategories(",
          "content_same": false
        },
        {
          "line": 3573,
          "old_api": null,
          "new_api": "is_linked",
          "old_text": null,
          "new_text": "category->is_linked()",
          "old_line_content": "      // Important: skip list should be cleared only after roots were updated",
          "new_line_content": "            [](FreeListCategory* category) { DCHECK(!category->is_linked()); });",
          "content_same": false
        },
        {
          "line": 3574,
          "old_api": null,
          "new_api": "owner",
          "old_text": null,
          "new_text": "p->owner()->identity()",
          "old_line_content": "      // because root iteration traverses the stack and might have to find",
          "new_line_content": "        sweeper().AddLatePage(p->owner()->identity(), p);",
          "content_same": false
        },
        {
          "line": 1532,
          "old_api": null,
          "new_api": "IsPatchedDebugBreakSlotSequence",
          "old_text": null,
          "new_text": "rinfo->IsPatchedDebugBreakSlotSequence()",
          "old_line_content": "  }",
          "new_line_content": "           rinfo->IsPatchedDebugBreakSlotSequence());",
          "content_same": false
        },
        {
          "line": 1533,
          "old_api": null,
          "new_api": "debug_call_address",
          "old_text": null,
          "new_text": "rinfo->debug_call_address()",
          "old_line_content": "",
          "new_line_content": "    Code* target = Code::GetCodeFromTargetAddress(rinfo->debug_call_address());",
          "content_same": false
        },
        {
          "line": 1534,
          "old_api": null,
          "new_api": "host",
          "old_text": null,
          "new_text": "rinfo->host()",
          "old_line_content": "  inline void VisitEmbeddedPointer(RelocInfo* rinfo) final {",
          "new_line_content": "    Code* host = rinfo->host();",
          "content_same": false
        },
        {
          "line": 3583,
          "old_api": null,
          "new_api": "skip_list",
          "old_text": null,
          "new_text": "p->skip_list()",
          "old_line_content": "",
          "new_line_content": "      SkipList* list = p->skip_list();",
          "content_same": false
        },
        {
          "line": 3584,
          "old_api": null,
          "new_api": "Clear",
          "old_text": null,
          "new_text": "list->Clear()",
          "old_line_content": "    // Deallocate evacuated candidate pages.",
          "new_line_content": "      if (list != NULL) list->Clear();",
          "content_same": false
        },
        {
          "line": 3586,
          "old_api": null,
          "new_api": "owner",
          "old_text": null,
          "new_text": "p->owner()->identity()",
          "old_line_content": "  }",
          "new_line_content": "        sweeper().AddLatePage(p->owner()->identity(), p);",
          "content_same": false
        },
        {
          "line": 3587,
          "old_api": null,
          "new_api": "ClearFlag",
          "old_text": null,
          "new_text": "p->ClearFlag(Page::COMPACTION_WAS_ABORTED)",
          "old_line_content": "",
          "new_line_content": "        p->ClearFlag(Page::COMPACTION_WAS_ABORTED);",
          "content_same": false
        },
        {
          "line": 1542,
          "old_api": null,
          "new_api": "rmode",
          "old_text": null,
          "new_text": "rinfo->rmode()",
          "old_line_content": "  inline void VisitCell(RelocInfo* rinfo) final {",
          "new_line_content": "    DCHECK(rinfo->rmode() == RelocInfo::EMBEDDED_OBJECT);",
          "content_same": false
        },
        {
          "line": 3592,
          "old_api": null,
          "new_api": "ReleaseEvacuationCandidates",
          "old_text": null,
          "new_text": "ReleaseEvacuationCandidates()",
          "old_line_content": "#endif",
          "new_line_content": "    ReleaseEvacuationCandidates();",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": null,
          "new_api": "RecordRelocSlot",
          "old_text": null,
          "new_text": "collector_->RecordRelocSlot(host, rinfo, object)",
          "old_line_content": "    // The cell is always in old space, we don't have to record the slot in",
          "new_line_content": "    collector_->RecordRelocSlot(host, rinfo, object);",
          "content_same": false
        },
        {
          "line": 3596,
          "old_api": null,
          "new_api": "sweeping_in_progress",
          "old_text": null,
          "new_text": "sweeper().sweeping_in_progress()",
          "old_line_content": "class PointerUpdateJobTraits {",
          "new_line_content": "  if (FLAG_verify_heap && !sweeper().sweeping_in_progress()) {",
          "content_same": false
        },
        {
          "line": 3597,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "heap()",
          "old_line_content": " public:",
          "new_line_content": "    VerifyEvacuation(heap());",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": null,
          "new_api": "rmode",
          "old_text": null,
          "new_text": "rinfo->rmode()",
          "old_line_content": "  }",
          "new_line_content": "    DCHECK(rinfo->rmode() == RelocInfo::CELL);",
          "content_same": false
        },
        {
          "line": 1551,
          "old_api": null,
          "new_api": "target_cell",
          "old_text": null,
          "new_text": "rinfo->target_cell()",
          "old_line_content": "",
          "new_line_content": "    Cell* cell = rinfo->target_cell();",
          "content_same": false
        },
        {
          "line": 1552,
          "old_api": null,
          "new_api": "host",
          "old_text": null,
          "new_text": "rinfo->host()",
          "old_line_content": "  // Entries that will never move.",
          "new_line_content": "    Code* host = rinfo->host();",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": null,
          "new_api": "rmode",
          "old_text": null,
          "new_text": "rinfo->rmode()",
          "old_line_content": "  inline void VisitExternalReference(RelocInfo* rinfo) final {}",
          "new_line_content": "    DCHECK(RelocInfo::IsCodeAgeSequence(rinfo->rmode()));",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": null,
          "new_api": "code_age_stub",
          "old_text": null,
          "new_text": "rinfo->code_age_stub()",
          "old_line_content": "  inline void VisitExternalReference(Address* p) final {}",
          "new_line_content": "    Code* stub = rinfo->code_age_stub();",
          "content_same": false
        },
        {
          "line": 1563,
          "old_api": null,
          "new_api": "USE",
          "old_text": null,
          "new_text": "USE(stub)",
          "old_line_content": "  inline void VisitRuntimeEntry(RelocInfo* rinfo) final {}",
          "new_line_content": "    USE(stub);",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": null,
          "new_api": "address",
          "old_text": null,
          "new_text": "stub->address()",
          "old_line_content": "  inline void VisitExternalOneByteString(",
          "new_line_content": "    DCHECK(!Page::FromAddress(stub->address())->IsEvacuationCandidate());",
          "content_same": false
        },
        {
          "line": 3610,
          "old_api": null,
          "new_api": "UpdateUntypedPointers",
          "old_text": null,
          "new_text": "UpdateUntypedPointers(heap, chunk)",
          "old_line_content": "",
          "new_line_content": "    UpdateUntypedPointers(heap, chunk);",
          "content_same": false
        },
        {
          "line": 3611,
          "old_api": null,
          "new_api": "UpdateTypedPointers",
          "old_text": null,
          "new_text": "UpdateTypedPointers(heap, chunk)",
          "old_line_content": " private:",
          "new_line_content": "    UpdateTypedPointers(heap, chunk);",
          "content_same": false
        },
        {
          "line": 3621,
          "old_api": null,
          "new_api": "RememberedSet<OLD_TO_NEW>::Iterate(chunk, [heap, chunk](Address slot) {\n        return CheckAndUpdateOldToNewSlot(heap, slot);\n      })",
          "old_text": null,
          "new_text": "RememberedSet<OLD_TO_NEW>::Iterate(chunk, [heap, chunk](Address slot) {\n        return CheckAndUpdateOldToNewSlot(heap, slot);\n      })",
          "old_line_content": "    }",
          "new_line_content": "      RememberedSet<OLD_TO_NEW>::Iterate(chunk, [heap, chunk](Address slot) {",
          "content_same": false
        },
        {
          "line": 3622,
          "old_api": null,
          "new_api": "CheckAndUpdateOldToNewSlot",
          "old_text": null,
          "new_text": "CheckAndUpdateOldToNewSlot(heap, slot)",
          "old_line_content": "  }",
          "new_line_content": "        return CheckAndUpdateOldToNewSlot(heap, slot);",
          "content_same": false
        },
        {
          "line": 3625,
          "old_api": null,
          "new_api": "RememberedSet<OLD_TO_OLD>::Iterate(chunk, [](Address slot) {\n        return UpdateSlot(reinterpret_cast<Object**>(slot));\n      })",
          "old_text": null,
          "new_text": "RememberedSet<OLD_TO_OLD>::Iterate(chunk, [](Address slot) {\n        return UpdateSlot(reinterpret_cast<Object**>(slot));\n      })",
          "old_line_content": "    if (direction == OLD_TO_OLD) {",
          "new_line_content": "      RememberedSet<OLD_TO_OLD>::Iterate(chunk, [](Address slot) {",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": null,
          "new_api": "IsHeapObject",
          "old_text": null,
          "new_text": "value->IsHeapObject()",
          "old_line_content": "    }",
          "new_line_content": "    if (value->IsHeapObject()) {",
          "content_same": false
        },
        {
          "line": 1581,
          "old_api": null,
          "new_api": "reinterpret_cast<Address>(value)",
          "old_text": null,
          "new_text": "reinterpret_cast<Address>(value)",
          "old_line_content": "  }",
          "new_line_content": "      Page* p = Page::FromAddress(reinterpret_cast<Address>(value));",
          "content_same": false
        },
        {
          "line": 1582,
          "old_api": null,
          "new_api": "InNewSpace",
          "old_text": null,
          "new_text": "p->InNewSpace()",
          "old_line_content": "",
          "new_line_content": "      if (p->InNewSpace()) {",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": null,
          "new_api": "Page::FromAddress(slot)",
          "old_text": null,
          "new_text": "Page::FromAddress(slot)",
          "old_line_content": "  MarkCompactCollector* collector_;",
          "new_line_content": "        RememberedSet<OLD_TO_NEW>::Insert(Page::FromAddress(slot), slot);",
          "content_same": false
        },
        {
          "line": 1584,
          "old_api": null,
          "new_api": "IsEvacuationCandidate",
          "old_text": null,
          "new_text": "p->IsEvacuationCandidate()",
          "old_line_content": "};",
          "new_line_content": "      } else if (p->IsEvacuationCandidate()) {",
          "content_same": false
        },
        {
          "line": 1585,
          "old_api": null,
          "new_api": "Page::FromAddress(slot)",
          "old_text": null,
          "new_text": "Page::FromAddress(slot)",
          "old_line_content": "",
          "new_line_content": "        RememberedSet<OLD_TO_OLD>::Insert(Page::FromAddress(slot), slot);",
          "content_same": false
        },
        {
          "line": 3636,
          "old_api": null,
          "new_api": "UpdateTypedSlotHelper::UpdateTypedSlot(isolate, type, slot,\n                                                          UpdateSlot)",
          "old_text": null,
          "new_text": "UpdateTypedSlotHelper::UpdateTypedSlot(isolate, type, slot,\n                                                          UpdateSlot)",
          "old_line_content": "          [isolate, heap](SlotType type, Address host_addr, Address slot) {",
          "new_line_content": "            return UpdateTypedSlotHelper::UpdateTypedSlot(isolate, type, slot,",
          "content_same": false
        },
        {
          "line": 3641,
          "old_api": null,
          "new_api": "RememberedSet<OLD_TO_NEW>::IterateTyped(\n          chunk,\n          [isolate, heap](SlotType type, Address host_addr, Address slot) {\n            return UpdateTypedSlotHelper::UpdateTypedSlot(\n                isolate, type, slot, [heap](Object** slot) {\n                  return CheckAndUpdateOldToNewSlot(\n                      heap, reinterpret_cast<Address>(slot));\n                });\n          })",
          "old_text": null,
          "new_text": "RememberedSet<OLD_TO_NEW>::IterateTyped(\n          chunk,\n          [isolate, heap](SlotType type, Address host_addr, Address slot) {\n            return UpdateTypedSlotHelper::UpdateTypedSlot(\n                isolate, type, slot, [heap](Object** slot) {\n                  return CheckAndUpdateOldToNewSlot(\n                      heap, reinterpret_cast<Address>(slot));\n                });\n          })",
          "old_line_content": "                });",
          "new_line_content": "      RememberedSet<OLD_TO_NEW>::IterateTyped(",
          "content_same": false
        },
        {
          "line": 3644,
          "old_api": null,
          "new_api": "UpdateTypedSlotHelper::UpdateTypedSlot(\n                isolate, type, slot, [heap](Object** slot) {\n                  return CheckAndUpdateOldToNewSlot(\n                      heap, reinterpret_cast<Address>(slot));\n                })",
          "old_text": null,
          "new_text": "UpdateTypedSlotHelper::UpdateTypedSlot(\n                isolate, type, slot, [heap](Object** slot) {\n                  return CheckAndUpdateOldToNewSlot(\n                      heap, reinterpret_cast<Address>(slot));\n                })",
          "old_line_content": "  }",
          "new_line_content": "            return UpdateTypedSlotHelper::UpdateTypedSlot(",
          "content_same": false
        },
        {
          "line": 3646,
          "old_api": null,
          "new_api": "CheckAndUpdateOldToNewSlot",
          "old_text": null,
          "new_text": "CheckAndUpdateOldToNewSlot(\n                      heap, reinterpret_cast<Address>(slot))",
          "old_line_content": "  static SlotCallbackResult CheckAndUpdateOldToNewSlot(Heap* heap,",
          "new_line_content": "                  return CheckAndUpdateOldToNewSlot(",
          "content_same": false
        },
        {
          "line": 3647,
          "old_api": null,
          "new_api": "reinterpret_cast<Address>(slot)",
          "old_text": null,
          "new_text": "reinterpret_cast<Address>(slot)",
          "old_line_content": "                                                       Address slot_address) {",
          "new_line_content": "                      heap, reinterpret_cast<Address>(slot));",
          "content_same": false
        },
        {
          "line": 3656,
          "old_api": null,
          "new_api": "InFromSpace",
          "old_text": null,
          "new_text": "heap->InFromSpace(*slot)",
          "old_line_content": "        // Update the corresponding slot.",
          "new_line_content": "    if (heap->InFromSpace(*slot)) {",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "heap->isolate()->logger()->is_logging_code_events()",
          "old_line_content": "#endif  // VERIFY_HEAP",
          "new_line_content": "            heap->isolate()->logger()->is_logging_code_events() ||",
          "content_same": false
        },
        {
          "line": 3658,
          "old_api": null,
          "new_api": "IsHeapObject",
          "old_text": null,
          "new_text": "heap_object->IsHeapObject()",
          "old_line_content": "      }",
          "new_line_content": "      DCHECK(heap_object->IsHeapObject());",
          "content_same": false
        },
        {
          "line": 3659,
          "old_api": null,
          "new_api": "map_word",
          "old_text": null,
          "new_text": "heap_object->map_word()",
          "old_line_content": "      // If the object was in from space before and is after executing the",
          "new_line_content": "      MapWord map_word = heap_object->map_word();",
          "content_same": false
        },
        {
          "line": 3662,
          "old_api": null,
          "new_api": "IsForwardingAddress",
          "old_text": null,
          "new_text": "map_word.IsForwardingAddress()",
          "old_line_content": "      // just freed free space object.",
          "new_line_content": "      if (map_word.IsForwardingAddress()) {",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": null,
          "new_api": "AbortCompactionForTesting",
          "old_text": null,
          "new_text": "AbortCompactionForTesting(object)",
          "old_line_content": "      return true;",
          "new_line_content": "    if (AbortCompactionForTesting(object)) return false;",
          "content_same": false
        },
        {
          "line": 3664,
          "old_api": null,
          "new_api": "ToForwardingAddress",
          "old_text": null,
          "new_text": "map_word.ToForwardingAddress()",
          "old_line_content": "        return KEEP_SLOT;",
          "new_line_content": "        *slot = map_word.ToForwardingAddress();",
          "content_same": false
        },
        {
          "line": 1617,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "object->Size()",
          "old_line_content": "    return false;",
          "new_line_content": "    int size = object->Size();",
          "content_same": false
        },
        {
          "line": 1618,
          "old_api": null,
          "new_api": "RequiredAlignment",
          "old_text": null,
          "new_text": "object->RequiredAlignment()",
          "old_line_content": "  }",
          "new_line_content": "    AllocationAlignment alignment = object->RequiredAlignment();",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": null,
          "new_api": "AllocateRaw",
          "old_text": null,
          "new_text": "target_space->AllocateRaw(size, alignment)",
          "old_line_content": "",
          "new_line_content": "    AllocationResult allocation = target_space->AllocateRaw(size, alignment);",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": null,
          "new_api": "To",
          "old_text": null,
          "new_text": "allocation.To(target_object)",
          "old_line_content": "  inline void MigrateObject(HeapObject* dst, HeapObject* src, int size,",
          "new_line_content": "    if (allocation.To(target_object)) {",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "target_space->identity()",
          "old_line_content": "                            AllocationSpace dest) {",
          "new_line_content": "      MigrateObject(*target_object, object, size, target_space->identity());",
          "content_same": false
        },
        {
          "line": 3670,
          "old_api": null,
          "new_api": "InToSpace",
          "old_text": null,
          "new_text": "heap->InToSpace(*slot)",
          "old_line_content": "      // markbits to determine liveness.",
          "new_line_content": "      if (heap->InToSpace(*slot)) {",
          "content_same": false
        },
        {
          "line": 3673,
          "old_api": null,
          "new_api": "InToSpace",
          "old_text": null,
          "new_text": "heap->InToSpace(*slot)",
          "old_line_content": "        return KEEP_SLOT;",
          "new_line_content": "    } else if (heap->InToSpace(*slot)) {",
          "content_same": false
        },
        {
          "line": 1630,
          "old_api": null,
          "new_api": "MigrateObject<kProfiled>(dst, src, size, dest)",
          "old_text": null,
          "new_text": "MigrateObject<kProfiled>(dst, src, size, dest)",
          "old_line_content": "  inline void MigrateObject(HeapObject* dst, HeapObject* src, int size,",
          "new_line_content": "      MigrateObject<kProfiled>(dst, src, size, dest);",
          "content_same": false
        },
        {
          "line": 3678,
          "old_api": null,
          "new_api": "Marking::IsBlack(\n              ObjectMarking::MarkBitFrom(reinterpret_cast<HeapObject*>(*slot)))",
          "old_text": null,
          "new_text": "Marking::IsBlack(\n              ObjectMarking::MarkBitFrom(reinterpret_cast<HeapObject*>(*slot)))",
          "old_line_content": "  }",
          "new_line_content": "      if (Marking::IsBlack(",
          "content_same": false
        },
        {
          "line": 3679,
          "old_api": null,
          "new_api": "reinterpret_cast<HeapObject*>(*slot)",
          "old_text": null,
          "new_text": "reinterpret_cast<HeapObject*>(*slot)",
          "old_line_content": "};",
          "new_line_content": "              ObjectMarking::MarkBitFrom(reinterpret_cast<HeapObject*>(*slot))))",
          "content_same": false
        },
        {
          "line": 3682,
          "old_api": null,
          "new_api": "InNewSpace",
          "old_text": null,
          "new_text": "heap->InNewSpace(*slot)",
          "old_line_content": "  if (!FLAG_parallel_pointer_update) return 1;",
          "new_line_content": "      DCHECK(!heap->InNewSpace(*slot));",
          "content_same": false
        },
        {
          "line": 1646,
          "old_api": null,
          "new_api": "CopyBlock",
          "old_text": null,
          "new_text": "heap_->CopyBlock(dst_addr, src_addr, size)",
          "old_line_content": "    } else if (dest == CODE_SPACE) {",
          "new_line_content": "      heap_->CopyBlock(dst_addr, src_addr, size);",
          "content_same": false
        },
        {
          "line": 1648,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "heap_->isolate()",
          "old_line_content": "      if (mode == kProfiled) {",
          "new_line_content": "        PROFILE(heap_->isolate(),",
          "content_same": false
        },
        {
          "line": 3698,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "heap->isolate()->cancelable_task_manager()",
          "old_line_content": "",
          "new_line_content": "      heap, heap->isolate()->cancelable_task_manager(), semaphore);",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": null,
          "new_api": "mark_compact_collector",
          "old_text": null,
          "new_text": "heap_->mark_compact_collector()",
          "old_line_content": "      }",
          "new_line_content": "      RecordMigratedSlotVisitor visitor(heap_->mark_compact_collector());",
          "content_same": false
        },
        {
          "line": 3699,
          "old_api": null,
          "new_api": "AddPage",
          "old_text": null,
          "new_text": "RememberedSet<direction>::IterateMemoryChunks(\n      heap, [&job](MemoryChunk* chunk) { job.AddPage(chunk, 0); })",
          "old_line_content": "class ToSpacePointerUpdateJobTraits {",
          "new_line_content": "  RememberedSet<direction>::IterateMemoryChunks(",
          "content_same": false
        },
        {
          "line": 3700,
          "old_api": null,
          "new_api": "AddPage",
          "old_text": null,
          "new_text": "job.AddPage(chunk, 0)",
          "old_line_content": " public:",
          "new_line_content": "      heap, [&job](MemoryChunk* chunk) { job.AddPage(chunk, 0); });",
          "content_same": false
        },
        {
          "line": 3701,
          "old_api": null,
          "new_api": "NumberOfPages",
          "old_text": null,
          "new_text": "job.NumberOfPages()",
          "old_line_content": "  typedef std::pair<Address, Address> PerPageData;",
          "new_line_content": "  int num_pages = job.NumberOfPages();",
          "content_same": false
        },
        {
          "line": 3702,
          "old_api": null,
          "new_api": "NumberOfPointerUpdateTasks",
          "old_text": null,
          "new_text": "NumberOfPointerUpdateTasks(num_pages)",
          "old_line_content": "  typedef PointersUpdatingVisitor* PerTaskData;",
          "new_line_content": "  int num_tasks = NumberOfPointerUpdateTasks(num_pages);",
          "content_same": false
        },
        {
          "line": 1656,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "heap_->isolate()",
          "old_line_content": "    } else {",
          "new_line_content": "        PROFILE(heap_->isolate(),",
          "content_same": false
        },
        {
          "line": 3703,
          "old_api": null,
          "new_api": "Run",
          "old_text": null,
          "new_text": "job.Run(num_tasks, [](int i) { return 0; })",
          "old_line_content": "",
          "new_line_content": "  job.Run(num_tasks, [](int i) { return 0; });",
          "content_same": false
        },
        {
          "line": 1660,
          "old_api": null,
          "new_api": "Relocate",
          "old_text": null,
          "new_text": "Code::cast(dst)->Relocate(dst_addr - src_addr)",
          "old_line_content": "    }",
          "new_line_content": "      Code::cast(dst)->Relocate(dst_addr - src_addr);",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": null,
          "new_api": "mark_compact_collector",
          "old_text": null,
          "new_text": "heap_->mark_compact_collector()",
          "old_line_content": "    if (mode == kProfiled) {",
          "new_line_content": "      RecordMigratedSlotVisitor visitor(heap_->mark_compact_collector());",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(dest == NEW_SPACE)",
          "old_line_content": "  }",
          "new_line_content": "      DCHECK(dest == NEW_SPACE);",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": null,
          "new_api": "CopyBlock",
          "old_text": null,
          "new_text": "heap_->CopyBlock(dst_addr, src_addr, size)",
          "old_line_content": "",
          "new_line_content": "      heap_->CopyBlock(dst_addr, src_addr, size);",
          "content_same": false
        },
        {
          "line": 3713,
          "old_api": null,
          "new_api": "IsFlagSet",
          "old_text": null,
          "new_text": "chunk->IsFlagSet(Page::PAGE_NEW_NEW_PROMOTION)",
          "old_line_content": "    return true;",
          "new_line_content": "    if (chunk->IsFlagSet(Page::PAGE_NEW_NEW_PROMOTION)) {",
          "content_same": false
        },
        {
          "line": 3716,
          "old_api": null,
          "new_api": "ProcessPageInParallelVisitLive",
          "old_text": null,
          "new_text": "ProcessPageInParallelVisitLive(heap, visitor, chunk, limits)",
          "old_line_content": "  static const bool NeedSequentialFinalization = false;",
          "new_line_content": "      ProcessPageInParallelVisitLive(heap, visitor, chunk, limits);",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": null,
          "new_api": "OnMoveEvent",
          "old_text": null,
          "new_text": "heap_->OnMoveEvent(dst, src, size)",
          "old_line_content": "    if (FLAG_stress_compaction) {",
          "new_line_content": "      heap_->OnMoveEvent(dst, src, size);",
          "content_same": false
        },
        {
          "line": 3718,
          "old_api": null,
          "new_api": "ProcessPageInParallelVisitAll",
          "old_text": null,
          "new_text": "ProcessPageInParallelVisitAll(heap, visitor, chunk, limits)",
          "old_line_content": "  }",
          "new_line_content": "      ProcessPageInParallelVisitAll(heap, visitor, chunk, limits);",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": null,
          "new_api": "Memory::Address_at(src_addr)",
          "old_text": null,
          "new_text": "Memory::Address_at(src_addr)",
          "old_line_content": "                             Page::kPageAlignmentMask & ~kPointerAlignmentMask;",
          "new_line_content": "    Memory::Address_at(src_addr) = dst_addr;",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": null,
          "new_api": "static_cast<uintptr_t>(FLAG_random_seed)",
          "old_text": null,
          "new_text": "static_cast<uintptr_t>(FLAG_random_seed)",
          "old_line_content": "        } else {",
          "new_line_content": "      const uintptr_t mask = static_cast<uintptr_t>(FLAG_random_seed) &",
          "content_same": false
        },
        {
          "line": 1679,
          "old_api": null,
          "new_api": "address",
          "old_text": null,
          "new_text": "object->address()",
          "old_line_content": "          return true;",
          "new_line_content": "      if ((reinterpret_cast<uintptr_t>(object->address()) &",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": null,
          "new_api": "address",
          "old_text": null,
          "new_text": "object->address()",
          "old_line_content": "      }",
          "new_line_content": "        Page* page = Page::FromAddress(object->address());",
          "content_same": false
        },
        {
          "line": 1682,
          "old_api": null,
          "new_api": "IsFlagSet",
          "old_text": null,
          "new_text": "page->IsFlagSet(Page::COMPACTION_WAS_ABORTED_FOR_TESTING)",
          "old_line_content": "    }",
          "new_line_content": "        if (page->IsFlagSet(Page::COMPACTION_WAS_ABORTED_FOR_TESTING)) {",
          "content_same": false
        },
        {
          "line": 1683,
          "old_api": null,
          "new_api": "ClearFlag",
          "old_text": null,
          "new_text": "page->ClearFlag(Page::COMPACTION_WAS_ABORTED_FOR_TESTING)",
          "old_line_content": "    return false;",
          "new_line_content": "          page->ClearFlag(Page::COMPACTION_WAS_ABORTED_FOR_TESTING);",
          "content_same": false
        },
        {
          "line": 3732,
          "old_api": null,
          "new_api": "HeapObject::FromAddress(cur)",
          "old_text": null,
          "new_text": "HeapObject::FromAddress(cur)",
          "old_line_content": "",
          "new_line_content": "      HeapObject* object = HeapObject::FromAddress(cur);",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": null,
          "new_api": "SetFlag",
          "old_text": null,
          "new_text": "page->SetFlag(Page::COMPACTION_WAS_ABORTED_FOR_TESTING)",
          "old_line_content": "#endif  // VERIFY_HEAP",
          "new_line_content": "          page->SetFlag(Page::COMPACTION_WAS_ABORTED_FOR_TESTING);",
          "content_same": false
        },
        {
          "line": 3733,
          "old_api": null,
          "new_api": "map",
          "old_text": null,
          "new_text": "object->map()",
          "old_line_content": "  static void ProcessPageInParallelVisitLive(Heap* heap, PerTaskData visitor,",
          "new_line_content": "      Map* map = object->map();",
          "content_same": false
        },
        {
          "line": 3734,
          "old_api": null,
          "new_api": "SizeFromMap",
          "old_text": null,
          "new_text": "object->SizeFromMap(map)",
          "old_line_content": "                                             MemoryChunk* chunk,",
          "new_line_content": "      int size = object->SizeFromMap(map);",
          "content_same": false
        },
        {
          "line": 3735,
          "old_api": null,
          "new_api": "instance_type",
          "old_text": null,
          "new_text": "map->instance_type()",
          "old_line_content": "                                             PerPageData limits) {",
          "new_line_content": "      object->IterateBody(map->instance_type(), size, visitor);",
          "content_same": false
        },
        {
          "line": 3745,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "it.Next()",
          "old_line_content": "",
          "new_line_content": "    while ((object = it.Next()) != NULL) {",
          "content_same": false
        },
        {
          "line": 3746,
          "old_api": null,
          "new_api": "map",
          "old_text": null,
          "new_text": "object->map()",
          "old_line_content": "void UpdateToSpacePointersInParallel(Heap* heap, base::Semaphore* semaphore) {",
          "new_line_content": "      Map* map = object->map();",
          "content_same": false
        },
        {
          "line": 3747,
          "old_api": null,
          "new_api": "SizeFromMap",
          "old_text": null,
          "new_text": "object->SizeFromMap(map)",
          "old_line_content": "  PageParallelJob<ToSpacePointerUpdateJobTraits> job(",
          "new_line_content": "      int size = object->SizeFromMap(map);",
          "content_same": false
        },
        {
          "line": 1705,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "        semispace_copied_size_(0),",
          "new_line_content": "  explicit EvacuateNewSpaceVisitor(Heap* heap,",
          "content_same": false
        },
        {
          "line": 3756,
          "old_api": null,
          "new_api": "new_space",
          "old_text": null,
          "new_text": "heap->new_space()->bottom()",
          "old_line_content": "  }",
          "new_line_content": "  Address space_start = heap->new_space()->bottom();",
          "content_same": false
        },
        {
          "line": 3757,
          "old_api": null,
          "new_api": "new_space",
          "old_text": null,
          "new_text": "heap->new_space()->top()",
          "old_line_content": "  PointersUpdatingVisitor visitor;",
          "new_line_content": "  Address space_end = heap->new_space()->top();",
          "content_same": false
        },
        {
          "line": 3760,
          "old_api": null,
          "new_api": "area_start",
          "old_text": null,
          "new_text": "page->area_start()",
          "old_line_content": "}",
          "new_line_content": "        page->Contains(space_start) ? space_start : page->area_start();",
          "content_same": false
        },
        {
          "line": 3761,
          "old_api": null,
          "new_api": "area_end",
          "old_text": null,
          "new_text": "page->area_end()",
          "old_line_content": "",
          "new_line_content": "    Address end = page->Contains(space_end) ? space_end : page->area_end();",
          "content_same": false
        },
        {
          "line": 3762,
          "old_api": null,
          "new_api": "std::make_pair(start, end)",
          "old_text": null,
          "new_text": "std::make_pair(start, end)",
          "old_line_content": "void MarkCompactCollector::UpdatePointersAfterEvacuation() {",
          "new_line_content": "    job.AddPage(page, std::make_pair(start, end));",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": null,
          "new_api": "heap_->UpdateAllocationSite<Heap::kCached>(object,\n                                               local_pretenuring_feedback_)",
          "old_text": null,
          "new_text": "heap_->UpdateAllocationSite<Heap::kCached>(object,\n                                               local_pretenuring_feedback_)",
          "old_line_content": "      promoted_size_ += size;",
          "new_line_content": "    heap_->UpdateAllocationSite<Heap::kCached>(object,",
          "content_same": false
        },
        {
          "line": 3765,
          "old_api": null,
          "new_api": "NumberOfPages",
          "old_text": null,
          "new_text": "job.NumberOfPages()",
          "old_line_content": "  PointersUpdatingVisitor updating_visitor;",
          "new_line_content": "  int num_tasks = FLAG_parallel_pointer_update ? job.NumberOfPages() : 1;",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "object->Size()",
          "old_line_content": "    }",
          "new_line_content": "    int size = object->Size();",
          "content_same": false
        },
        {
          "line": 3766,
          "old_api": null,
          "new_api": "Run",
          "old_text": null,
          "new_text": "job.Run(num_tasks, [&visitor](int i) { return &visitor; })",
          "old_line_content": "",
          "new_line_content": "  job.Run(num_tasks, [&visitor](int i) { return &visitor; });",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": null,
          "new_api": "AllocateTargetObject",
          "old_text": null,
          "new_text": "AllocateTargetObject(object, &target)",
          "old_line_content": "  intptr_t semispace_copied_size() { return semispace_copied_size_; }",
          "new_line_content": "    AllocationSpace space = AllocateTargetObject(object, &target);",
          "content_same": false
        },
        {
          "line": 1728,
          "old_api": null,
          "new_api": "HeapObject::cast(target)",
          "old_text": null,
          "new_text": "HeapObject::cast(target)",
          "old_line_content": "",
          "new_line_content": "    MigrateObject(HeapObject::cast(target), object, size, space);",
          "content_same": false
        },
        {
          "line": 3775,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()",
          "old_line_content": "",
          "new_line_content": "    TRACE_GC(heap()->tracer(),",
          "content_same": false
        },
        {
          "line": 3779,
          "old_api": null,
          "new_api": "IterateRoots",
          "old_text": null,
          "new_text": "heap_->IterateRoots(&updating_visitor, VISIT_ALL_IN_SWEEP_NEWSPACE)",
          "old_line_content": "             GCTracer::Scope::MC_EVACUATE_UPDATE_POINTERS_TO_EVACUATED);",
          "new_line_content": "    heap_->IterateRoots(&updating_visitor, VISIT_ALL_IN_SWEEP_NEWSPACE);",
          "content_same": false
        },
        {
          "line": 3785,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap->tracer()",
          "old_line_content": "             GCTracer::Scope::MC_EVACUATE_UPDATE_POINTERS_WEAK);",
          "new_line_content": "    TRACE_GC(heap->tracer(),",
          "content_same": false
        },
        {
          "line": 1744,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "old_object->Size()",
          "old_line_content": "      } else {",
          "new_line_content": "    const int size = old_object->Size();",
          "content_same": false
        },
        {
          "line": 3794,
          "old_api": null,
          "new_api": "UpdateReferencesInExternalStringTable",
          "old_text": null,
          "new_text": "heap_->UpdateReferencesInExternalStringTable(\n        &UpdateReferenceInExternalStringTableEntry)",
          "old_line_content": "",
          "new_line_content": "    heap_->UpdateReferencesInExternalStringTable(",
          "content_same": false
        },
        {
          "line": 1750,
          "old_api": null,
          "new_api": "AllocateInNewSpace",
          "old_text": null,
          "new_text": "AllocateInNewSpace(size, alignment, kNonstickyBailoutOldSpace)",
          "old_line_content": "    }",
          "new_line_content": "            AllocateInNewSpace(size, alignment, kNonstickyBailoutOldSpace);",
          "content_same": false
        },
        {
          "line": 1755,
          "old_api": null,
          "new_api": "IsRetry",
          "old_text": null,
          "new_text": "allocation.IsRetry()",
          "old_line_content": "  }",
          "new_line_content": "    if (allocation.IsRetry() || (space_to_allocate_ == OLD_SPACE)) {",
          "content_same": false
        },
        {
          "line": 1756,
          "old_api": null,
          "new_api": "AllocateInOldSpace",
          "old_text": null,
          "new_text": "AllocateInOldSpace(size, alignment)",
          "old_line_content": "",
          "new_line_content": "      allocation = AllocateInOldSpace(size, alignment);",
          "content_same": false
        },
        {
          "line": 3805,
          "old_api": null,
          "new_api": "IsEvacuationCandidate",
          "old_text": null,
          "new_text": "p->IsEvacuationCandidate()",
          "old_line_content": "  compacting_ = false;",
          "new_line_content": "    if (!p->IsEvacuationCandidate()) continue;",
          "content_same": false
        },
        {
          "line": 1758,
          "old_api": null,
          "new_api": "To",
          "old_text": null,
          "new_text": "allocation.To(target_object)",
          "old_line_content": "    AllocationResult result =",
          "new_line_content": "    bool ok = allocation.To(target_object);",
          "content_same": false
        },
        {
          "line": 3807,
          "old_api": null,
          "new_api": "ResetLiveBytes",
          "old_text": null,
          "new_text": "p->ResetLiveBytes()",
          "old_line_content": "}",
          "new_line_content": "    p->ResetLiveBytes();",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": null,
          "new_api": "USE",
          "old_text": null,
          "new_text": "USE(ok)",
          "old_line_content": "    LocalAllocationBuffer saved_old_buffer = buffer_;",
          "new_line_content": "    USE(ok);",
          "content_same": false
        },
        {
          "line": 3808,
          "old_api": null,
          "new_api": "SweepingDone",
          "old_text": null,
          "new_text": "p->SweepingDone()",
          "old_line_content": "",
          "new_line_content": "    CHECK(p->SweepingDone());",
          "content_same": false
        },
        {
          "line": 3809,
          "old_api": null,
          "new_api": "ReleasePage",
          "old_text": null,
          "new_text": "space->ReleasePage(p)",
          "old_line_content": "int MarkCompactCollector::Sweeper::ParallelSweepSpace(AllocationSpace identity,",
          "new_line_content": "    space->ReleasePage(p);",
          "content_same": false
        },
        {
          "line": 3811,
          "old_api": null,
          "new_api": "Rewind",
          "old_text": null,
          "new_text": "evacuation_candidates_.Rewind(0)",
          "old_line_content": "                                                      int max_pages) {",
          "new_line_content": "  evacuation_candidates_.Rewind(0);",
          "content_same": false
        },
        {
          "line": 3813,
          "old_api": null,
          "new_api": "memory_allocator",
          "old_text": null,
          "new_text": "heap()->memory_allocator()->unmapper()->FreeQueuedChunks()",
          "old_line_content": "  int pages_freed = 0;",
          "new_line_content": "  heap()->memory_allocator()->unmapper()->FreeQueuedChunks();",
          "content_same": false
        },
        {
          "line": 1766,
          "old_api": null,
          "new_api": "AllocateInNewSpace",
          "old_text": null,
          "new_text": "AllocateInNewSpace(kLabSize, kWordAligned, kStickyBailoutOldSpace)",
          "old_line_content": "    return false;",
          "new_line_content": "        AllocateInNewSpace(kLabSize, kWordAligned, kStickyBailoutOldSpace);",
          "content_same": false
        },
        {
          "line": 1768,
          "old_api": null,
          "new_api": "LocalAllocationBuffer::FromResult(heap_, result, kLabSize)",
          "old_text": null,
          "new_text": "LocalAllocationBuffer::FromResult(heap_, result, kLabSize)",
          "old_line_content": "",
          "new_line_content": "    buffer_ = LocalAllocationBuffer::FromResult(heap_, result, kLabSize);",
          "content_same": false
        },
        {
          "line": 1769,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "buffer_.IsValid()",
          "old_line_content": "  inline AllocationResult AllocateInNewSpace(int size_in_bytes,",
          "new_line_content": "    if (buffer_.IsValid()) {",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": null,
          "new_api": "TryMerge",
          "old_text": null,
          "new_text": "buffer_.TryMerge(&saved_old_buffer)",
          "old_line_content": "                                             AllocationAlignment alignment,",
          "new_line_content": "      buffer_.TryMerge(&saved_old_buffer);",
          "content_same": false
        },
        {
          "line": 3822,
          "old_api": null,
          "new_api": "GetSweepingPageSafe",
          "old_text": null,
          "new_text": "GetSweepingPageSafe(identity)",
          "old_line_content": "    if ((max_pages > 0) && (pages_freed >= max_pages)) return max_freed;",
          "new_line_content": "  while ((page = GetSweepingPageSafe(identity)) != nullptr) {",
          "content_same": false
        },
        {
          "line": 3823,
          "old_api": null,
          "new_api": "ParallelSweepPage",
          "old_text": null,
          "new_text": "ParallelSweepPage(page, identity)",
          "old_line_content": "  }",
          "new_line_content": "    int freed = ParallelSweepPage(page, identity);",
          "content_same": false
        },
        {
          "line": 3825,
          "old_api": null,
          "new_api": "DCHECK_GE",
          "old_text": null,
          "new_text": "DCHECK_GE(freed, 0)",
          "old_line_content": "}",
          "new_line_content": "    DCHECK_GE(freed, 0);",
          "content_same": false
        },
        {
          "line": 3826,
          "old_api": null,
          "new_api": "Max",
          "old_text": null,
          "new_text": "Max(max_freed, freed)",
          "old_line_content": "",
          "new_line_content": "    max_freed = Max(max_freed, freed);",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": null,
          "new_api": "IsRetry",
          "old_text": null,
          "new_text": "allocation.IsRetry()",
          "old_line_content": "          if (mode == kStickyBailoutOldSpace) space_to_allocate_ = OLD_SPACE;",
          "new_line_content": "    if (allocation.IsRetry()) {",
          "content_same": false
        },
        {
          "line": 1782,
          "old_api": null,
          "new_api": "new_space",
          "old_text": null,
          "new_text": "heap_->new_space()->AddFreshPageSynchronized()",
          "old_line_content": "        }",
          "new_line_content": "      if (!heap_->new_space()->AddFreshPageSynchronized()) {",
          "content_same": false
        },
        {
          "line": 1785,
          "old_api": null,
          "new_api": "new_space",
          "old_text": null,
          "new_text": "heap_->new_space()->AllocateRawSynchronized(size_in_bytes,\n                                                                 alignment)",
          "old_line_content": "    return allocation;",
          "new_line_content": "        allocation = heap_->new_space()->AllocateRawSynchronized(size_in_bytes,",
          "content_same": false
        },
        {
          "line": 1787,
          "old_api": null,
          "new_api": "IsRetry",
          "old_text": null,
          "new_text": "allocation.IsRetry()",
          "old_line_content": "",
          "new_line_content": "        if (allocation.IsRetry()) {",
          "content_same": false
        },
        {
          "line": 3837,
          "old_api": null,
          "new_api": "mutex",
          "old_text": null,
          "new_text": "page->mutex()->TryLock()",
          "old_line_content": "    const Sweeper::FreeSpaceTreatmentMode free_space_mode =",
          "new_line_content": "  if (page->mutex()->TryLock()) {",
          "content_same": false
        },
        {
          "line": 3839,
          "old_api": null,
          "new_api": "Value",
          "old_text": null,
          "new_text": "page->concurrent_sweeping_state().Value()",
          "old_line_content": "    if (identity == NEW_SPACE) {",
          "new_line_content": "    if (page->concurrent_sweeping_state().Value() != Page::kSweepingPending) {",
          "content_same": false
        },
        {
          "line": 3843,
          "old_api": null,
          "new_api": "SetValue",
          "old_text": null,
          "new_text": "page->concurrent_sweeping_state().SetValue(Page::kSweepingInProgress)",
          "old_line_content": "    } else if (identity == CODE_SPACE) {",
          "new_line_content": "    page->concurrent_sweeping_state().SetValue(Page::kSweepingInProgress);",
          "content_same": false
        },
        {
          "line": 3845,
          "old_api": null,
          "new_api": "Heap::ShouldZapGarbage()",
          "old_text": null,
          "new_text": "Heap::ShouldZapGarbage()",
          "old_line_content": "    } else {",
          "new_line_content": "        Heap::ShouldZapGarbage() ? ZAP_FREE_SPACE : IGNORE_FREE_SPACE;",
          "content_same": false
        },
        {
          "line": 1798,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "compaction_spaces_->Get(OLD_SPACE)->AllocateRaw(size_in_bytes,\n                                                        alignment)",
          "old_line_content": "  }",
          "new_line_content": "        compaction_spaces_->Get(OLD_SPACE)->AllocateRaw(size_in_bytes,",
          "content_same": false
        },
        {
          "line": 3847,
          "old_api": null,
          "new_api": "RawSweep",
          "old_text": null,
          "new_text": "RawSweep(page, IGNORE_FREE_LIST, free_space_mode)",
          "old_line_content": "    }",
          "new_line_content": "      RawSweep(page, IGNORE_FREE_LIST, free_space_mode);",
          "content_same": false
        },
        {
          "line": 1800,
          "old_api": null,
          "new_api": "IsRetry",
          "old_text": null,
          "new_text": "allocation.IsRetry()",
          "old_line_content": "  inline AllocationResult AllocateInLab(int size_in_bytes,",
          "new_line_content": "    if (allocation.IsRetry()) {",
          "content_same": false
        },
        {
          "line": 1801,
          "old_api": null,
          "new_api": "v8::internal::Heap::FatalProcessOutOfMemory(\n          \"MarkCompactCollector: semi-space copy, fallback in old gen\", true)",
          "old_text": null,
          "new_text": "v8::internal::Heap::FatalProcessOutOfMemory(\n          \"MarkCompactCollector: semi-space copy, fallback in old gen\", true)",
          "old_line_content": "                                        AllocationAlignment alignment) {",
          "new_line_content": "      v8::internal::Heap::FatalProcessOutOfMemory(",
          "content_same": false
        },
        {
          "line": 3849,
          "old_api": null,
          "new_api": "RawSweep",
          "old_text": null,
          "new_text": "RawSweep(page, REBUILD_FREE_LIST, free_space_mode)",
          "old_line_content": "      base::LockGuard<base::Mutex> guard(&mutex_);",
          "new_line_content": "      max_freed = RawSweep(page, REBUILD_FREE_LIST, free_space_mode);",
          "content_same": false
        },
        {
          "line": 3851,
          "old_api": null,
          "new_api": "RawSweep",
          "old_text": null,
          "new_text": "RawSweep(page, REBUILD_FREE_LIST, free_space_mode)",
          "old_line_content": "    }",
          "new_line_content": "      max_freed = RawSweep(page, REBUILD_FREE_LIST, free_space_mode);",
          "content_same": false
        },
        {
          "line": 3857,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "swept_list_[identity].Add(page)",
          "old_line_content": "",
          "new_line_content": "      swept_list_[identity].Add(page);",
          "content_same": false
        },
        {
          "line": 1817,
          "old_api": null,
          "new_api": "IsRetry",
          "old_text": null,
          "new_text": "allocation.IsRetry()",
          "old_line_content": "          space_to_allocate_ = OLD_SPACE;",
          "new_line_content": "    if (allocation.IsRetry()) {",
          "content_same": false
        },
        {
          "line": 1820,
          "old_api": null,
          "new_api": "AllocationResult::Retry(OLD_SPACE)",
          "old_text": null,
          "new_text": "AllocationResult::Retry(OLD_SPACE)",
          "old_line_content": "      }",
          "new_line_content": "        return AllocationResult::Retry(OLD_SPACE);",
          "content_same": false
        },
        {
          "line": 3868,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "sweeping_list_[space].push_back(page)",
          "old_line_content": "  late_pages_ = true;",
          "new_line_content": "  sweeping_list_[space].push_back(page);",
          "content_same": false
        },
        {
          "line": 1822,
          "old_api": null,
          "new_api": "AllocateRawAligned",
          "old_text": null,
          "new_text": "buffer_.AllocateRawAligned(size_in_bytes, alignment)",
          "old_line_content": "    return allocation;",
          "new_line_content": "        allocation = buffer_.AllocateRawAligned(size_in_bytes, alignment);",
          "content_same": false
        },
        {
          "line": 1823,
          "old_api": null,
          "new_api": "IsRetry",
          "old_text": null,
          "new_text": "allocation.IsRetry()",
          "old_line_content": "  }",
          "new_line_content": "        if (allocation.IsRetry()) {",
          "content_same": false
        },
        {
          "line": 1825,
          "old_api": null,
          "new_api": "AllocationResult::Retry(OLD_SPACE)",
          "old_text": null,
          "new_text": "AllocationResult::Retry(OLD_SPACE)",
          "old_line_content": "  LocalAllocationBuffer buffer_;",
          "new_line_content": "          return AllocationResult::Retry(OLD_SPACE);",
          "content_same": false
        },
        {
          "line": 3873,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(sweeping_in_progress_)",
          "old_line_content": "                                                         Page* page) {",
          "new_line_content": "  DCHECK(sweeping_in_progress_);",
          "content_same": false
        },
        {
          "line": 3876,
          "old_api": null,
          "new_api": "AddSweepingPageSafe",
          "old_text": null,
          "new_text": "AddSweepingPageSafe(space, page)",
          "old_line_content": "  if (space != NEW_SPACE)",
          "new_line_content": "  AddSweepingPageSafe(space, page);",
          "content_same": false
        },
        {
          "line": 3881,
          "old_api": null,
          "new_api": "SetValue",
          "old_text": null,
          "new_text": "page->concurrent_sweeping_state().SetValue(Page::kSweepingPending)",
          "old_line_content": "    AllocationSpace space) {",
          "new_line_content": "  page->concurrent_sweeping_state().SetValue(Page::kSweepingPending);",
          "content_same": false
        },
        {
          "line": 3882,
          "old_api": null,
          "new_api": "LiveBytes",
          "old_text": null,
          "new_text": "page->LiveBytes()",
          "old_line_content": "  base::LockGuard<base::Mutex> guard(&mutex_);",
          "new_line_content": "  int to_sweep = page->area_size() - page->LiveBytes();",
          "content_same": false
        },
        {
          "line": 1842,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "  }",
          "new_line_content": "  explicit EvacuateNewSpacePageVisitor(Heap* heap)",
          "content_same": false
        },
        {
          "line": 3891,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "sweeping_list_[space].empty()",
          "old_line_content": "void MarkCompactCollector::Sweeper::AddSweepingPageSafe(AllocationSpace space,",
          "new_line_content": "  if (!sweeping_list_[space].empty()) {",
          "content_same": false
        },
        {
          "line": 3892,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "sweeping_list_[space].front()",
          "old_line_content": "                                                        Page* page) {",
          "new_line_content": "    page = sweeping_list_[space].front();",
          "content_same": false
        },
        {
          "line": 3893,
          "old_api": null,
          "new_api": "pop_front",
          "old_text": null,
          "new_text": "sweeping_list_[space].pop_front()",
          "old_line_content": "  base::LockGuard<base::Mutex> guard(&mutex_);",
          "new_line_content": "    sweeping_list_[space].pop_front();",
          "content_same": false
        },
        {
          "line": 1847,
          "old_api": null,
          "new_api": "Page::ConvertNewToOld(page, owner)",
          "old_text": null,
          "new_text": "Page::ConvertNewToOld(page, owner)",
          "old_line_content": "  }",
          "new_line_content": "    Page* new_page = Page::ConvertNewToOld(page, owner);",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": null,
          "new_api": "SetFlag",
          "old_text": null,
          "new_text": "new_page->SetFlag(Page::PAGE_NEW_OLD_PROMOTION)",
          "old_line_content": "",
          "new_line_content": "    new_page->SetFlag(Page::PAGE_NEW_OLD_PROMOTION);",
          "content_same": false
        },
        {
          "line": 1853,
          "old_api": null,
          "new_api": "SetFlag",
          "old_text": null,
          "new_text": "page->SetFlag(Page::PAGE_NEW_NEW_PROMOTION)",
          "old_line_content": "    return true;",
          "new_line_content": "    page->SetFlag(Page::PAGE_NEW_NEW_PROMOTION);",
          "content_same": false
        },
        {
          "line": 3901,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "sweeping_list_[space].push_back(page)",
          "old_line_content": "  bool unused_page_present = false;",
          "new_line_content": "  sweeping_list_[space].push_back(page);",
          "content_same": false
        },
        {
          "line": 1857,
          "old_api": null,
          "new_api": "mark_compact_collector",
          "old_text": null,
          "new_text": "heap_->mark_compact_collector()",
          "old_line_content": "  intptr_t semispace_copied_size() { return semispace_copied_size_; }",
          "new_line_content": "    RecordMigratedSlotVisitor visitor(heap_->mark_compact_collector());",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": null,
          "new_api": "IterateBodyFast",
          "old_text": null,
          "new_text": "object->IterateBodyFast(&visitor)",
          "old_line_content": "",
          "new_line_content": "    object->IterateBodyFast(&visitor);",
          "content_same": false
        },
        {
          "line": 1859,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "object->Size()",
          "old_line_content": "  void account_semispace_copied(intptr_t copied) {",
          "new_line_content": "    promoted_size_ += object->Size();",
          "content_same": false
        },
        {
          "line": 3905,
          "old_api": null,
          "new_api": "ClearStats",
          "old_text": null,
          "new_text": "space->ClearStats()",
          "old_line_content": "    Page* p = *(it++);",
          "new_line_content": "  space->ClearStats();",
          "content_same": false
        },
        {
          "line": 3911,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "space->end()",
          "old_line_content": "      continue;",
          "new_line_content": "  for (auto it = space->begin(); it != space->end();) {",
          "content_same": false
        },
        {
          "line": 3913,
          "old_api": null,
          "new_api": "SweepingDone",
          "old_text": null,
          "new_text": "p->SweepingDone()",
          "old_line_content": "",
          "new_line_content": "    DCHECK(p->SweepingDone());",
          "content_same": false
        },
        {
          "line": 3915,
          "old_api": null,
          "new_api": "IsEvacuationCandidate",
          "old_text": null,
          "new_text": "p->IsEvacuationCandidate()",
          "old_line_content": "      // We need to sweep the page to get it into an iterable state again. Note",
          "new_line_content": "    if (p->IsEvacuationCandidate()) {",
          "content_same": false
        },
        {
          "line": 3917,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "evacuation_candidates_.length()",
          "old_line_content": "      // (in the free list) dropped again. Since we only use the flag for",
          "new_line_content": "      DCHECK(evacuation_candidates_.length() > 0);",
          "content_same": false
        },
        {
          "line": 3926,
          "old_api": null,
          "new_api": "SetValue",
          "old_text": null,
          "new_text": "p->concurrent_sweeping_state().SetValue(Page::kSweepingInProgress)",
          "old_line_content": "    // One unused page is kept, all further are released before sweeping them.",
          "new_line_content": "      p->concurrent_sweeping_state().SetValue(Page::kSweepingInProgress);",
          "content_same": false
        },
        {
          "line": 3928,
          "old_api": null,
          "new_api": "Heap::ShouldZapGarbage()",
          "old_text": null,
          "new_text": "Heap::ShouldZapGarbage()",
          "old_line_content": "      if (unused_page_present) {",
          "new_line_content": "                        Heap::ShouldZapGarbage() ? Sweeper::ZAP_FREE_SPACE",
          "content_same": false
        },
        {
          "line": 1884,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "compaction_spaces_->Get(\n        Page::FromAddress(object->address())->owner()->identity())",
          "old_line_content": "    return false;",
          "new_line_content": "    CompactionSpace* target_space = compaction_spaces_->Get(",
          "content_same": false
        },
        {
          "line": 1885,
          "old_api": null,
          "new_api": "address",
          "old_text": null,
          "new_text": "object->address()",
          "old_line_content": "  }",
          "new_line_content": "        Page::FromAddress(object->address())->owner()->identity());",
          "content_same": false
        },
        {
          "line": 1887,
          "old_api": null,
          "new_api": "TryEvacuateObject",
          "old_text": null,
          "new_text": "TryEvacuateObject(target_space, object, &target_object)",
          "old_line_content": "",
          "new_line_content": "    if (TryEvacuateObject(target_space, object, &target_object)) {",
          "content_same": false
        },
        {
          "line": 1888,
          "old_api": null,
          "new_api": "IsForwardingAddress",
          "old_text": null,
          "new_text": "object->map_word().IsForwardingAddress()",
          "old_line_content": "class MarkCompactCollector::EvacuateRecordOnlyVisitor final",
          "new_line_content": "      DCHECK(object->map_word().IsForwardingAddress());",
          "content_same": false
        },
        {
          "line": 3937,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "isolate()",
          "old_line_content": "      unused_page_present = true;",
          "new_line_content": "          PrintIsolate(isolate(), \"sweeping: released page: %p\",",
          "content_same": false
        },
        {
          "line": 3938,
          "old_api": null,
          "new_api": "static_cast<void*>(p)",
          "old_text": null,
          "new_text": "static_cast<void*>(p)",
          "old_line_content": "    }",
          "new_line_content": "                       static_cast<void*>(p));",
          "content_same": false
        },
        {
          "line": 3941,
          "old_api": null,
          "new_api": "ReleasePage",
          "old_text": null,
          "new_text": "space->ReleasePage(p)",
          "old_line_content": "    will_be_swept++;",
          "new_line_content": "        space->ReleasePage(p);",
          "content_same": false
        },
        {
          "line": 1898,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "",
          "new_line_content": "  explicit EvacuateRecordOnlyVisitor(Heap* heap) : heap_(heap) {}",
          "content_same": false
        },
        {
          "line": 3947,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "space->identity()",
          "old_line_content": "  }",
          "new_line_content": "    sweeper().AddPage(space->identity(), p);",
          "content_same": false
        },
        {
          "line": 1901,
          "old_api": null,
          "new_api": "mark_compact_collector",
          "old_text": null,
          "new_text": "heap_->mark_compact_collector()",
          "old_line_content": "};",
          "new_line_content": "    RecordMigratedSlotVisitor visitor(heap_->mark_compact_collector());",
          "content_same": false
        },
        {
          "line": 1902,
          "old_api": null,
          "new_api": "IterateBody",
          "old_text": null,
          "new_text": "object->IterateBody(&visitor)",
          "old_line_content": "",
          "new_line_content": "    object->IterateBody(&visitor);",
          "content_same": false
        },
        {
          "line": 3953,
          "old_api": null,
          "new_api": "identity",
          "old_text": null,
          "new_text": "space->identity()",
          "old_line_content": "  double start_time = 0.0;",
          "new_line_content": "                 AllocationSpaceName(space->identity()), will_be_swept);",
          "content_same": false
        },
        {
          "line": 3959,
          "old_api": null,
          "new_api": "tracer",
          "old_text": null,
          "new_text": "heap()->tracer()",
          "old_line_content": "  state_ = SWEEP_SPACES;",
          "new_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_SWEEP);",
          "content_same": false
        },
        {
          "line": 3962,
          "old_api": null,
          "new_api": "MonotonicallyIncreasingTimeInMs",
          "old_text": null,
          "new_text": "heap_->MonotonicallyIncreasingTimeInMs()",
          "old_line_content": "  {",
          "new_line_content": "    start_time = heap_->MonotonicallyIncreasingTimeInMs();",
          "content_same": false
        },
        {
          "line": 1919,
          "old_api": null,
          "new_api": "new_space",
          "old_text": null,
          "new_text": "heap()->new_space()",
          "old_line_content": "",
          "new_line_content": "  NewSpace* space = heap()->new_space();",
          "content_same": false
        },
        {
          "line": 1920,
          "old_api": null,
          "new_api": "top",
          "old_text": null,
          "new_text": "space->top()",
          "old_line_content": "bool MarkCompactCollector::IsUnmarkedHeapObject(Object** p) {",
          "new_line_content": "  for (Page* page : NewSpacePageRange(space->bottom(), space->top())) {",
          "content_same": false
        },
        {
          "line": 1921,
          "old_api": null,
          "new_api": "DiscoverGreyObjectsOnPage",
          "old_text": null,
          "new_text": "DiscoverGreyObjectsOnPage(page)",
          "old_line_content": "  Object* o = *p;",
          "new_line_content": "    DiscoverGreyObjectsOnPage(page);",
          "content_same": false
        },
        {
          "line": 3973,
          "old_api": null,
          "new_api": "old_space",
          "old_text": null,
          "new_text": "heap()->old_space()",
          "old_line_content": "    {",
          "new_line_content": "      StartSweepSpace(heap()->old_space());",
          "content_same": false
        },
        {
          "line": 1929,
          "old_api": null,
          "new_api": "IsHeapObject",
          "old_text": null,
          "new_text": "o->IsHeapObject()",
          "old_line_content": "bool MarkCompactCollector::IsUnmarkedHeapObjectWithHeap(Heap* heap,",
          "new_line_content": "  if (!o->IsHeapObject()) return false;",
          "content_same": false
        },
        {
          "line": 1930,
          "old_api": null,
          "new_api": "HeapObject::cast(o)",
          "old_text": null,
          "new_text": "HeapObject::cast(o)",
          "old_line_content": "                                                        Object** p) {",
          "new_line_content": "  HeapObject* heap_object = HeapObject::cast(o);",
          "content_same": false
        },
        {
          "line": 1931,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(heap_object)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(heap_object)",
          "old_line_content": "  Object* o = *p;",
          "new_line_content": "  MarkBit mark = ObjectMarking::MarkBitFrom(heap_object);",
          "content_same": false
        },
        {
          "line": 3983,
          "old_api": null,
          "new_api": "map_space",
          "old_text": null,
          "new_text": "heap()->map_space()",
          "old_line_content": "",
          "new_line_content": "      StartSweepSpace(heap()->map_space());",
          "content_same": false
        },
        {
          "line": 1939,
          "old_api": null,
          "new_api": "IsHeapObject",
          "old_text": null,
          "new_text": "o->IsHeapObject()",
          "old_line_content": "void MarkCompactCollector::MarkStringTable(RootMarkingVisitor* visitor) {",
          "new_line_content": "  DCHECK(o->IsHeapObject());",
          "content_same": false
        },
        {
          "line": 1941,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(heap_object)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(heap_object)",
          "old_line_content": "  // Mark the string table itself.",
          "new_line_content": "  MarkBit mark = ObjectMarking::MarkBitFrom(heap_object);",
          "content_same": false
        },
        {
          "line": 3989,
          "old_api": null,
          "new_api": "lo_space",
          "old_text": null,
          "new_text": "heap_->lo_space()->FreeUnmarkedObjects()",
          "old_line_content": "",
          "new_line_content": "  heap_->lo_space()->FreeUnmarkedObjects();",
          "content_same": false
        },
        {
          "line": 3992,
          "old_api": null,
          "new_api": "MonotonicallyIncreasingTimeInMs",
          "old_text": null,
          "new_text": "heap_->MonotonicallyIncreasingTimeInMs()",
          "old_line_content": "",
          "new_line_content": "    heap_->tracer()->AddSweepingTime(heap_->MonotonicallyIncreasingTimeInMs() -",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": null,
          "new_api": "string_table",
          "old_text": null,
          "new_text": "heap()->string_table()",
          "old_line_content": "  // Explicitly mark the prefix.",
          "new_line_content": "  StringTable* string_table = heap()->string_table();",
          "content_same": false
        },
        {
          "line": 3997,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "heap_->isolate()",
          "old_line_content": "",
          "new_line_content": "Isolate* MarkCompactCollector::isolate() const { return heap_->isolate(); }",
          "content_same": false
        },
        {
          "line": 1950,
          "old_api": null,
          "new_api": "Marking::IsWhite(string_table_mark)",
          "old_text": null,
          "new_text": "Marking::IsWhite(string_table_mark)",
          "old_line_content": "}",
          "new_line_content": "  if (Marking::IsWhite(string_table_mark)) {",
          "content_same": false
        },
        {
          "line": 1952,
          "old_api": null,
          "new_api": "SetMark",
          "old_text": null,
          "new_text": "SetMark(string_table, string_table_mark)",
          "old_line_content": "",
          "new_line_content": "    SetMark(string_table, string_table_mark);",
          "content_same": false
        },
        {
          "line": 1956,
          "old_api": null,
          "new_api": "ProcessMarkingDeque",
          "old_text": null,
          "new_text": "ProcessMarkingDeque()",
          "old_line_content": "}",
          "new_line_content": "  ProcessMarkingDeque();",
          "content_same": false
        },
        {
          "line": 4008,
          "old_api": null,
          "new_api": "reinterpret_cast<Address>(host)",
          "old_text": null,
          "new_text": "reinterpret_cast<Address>(host)",
          "old_line_content": "  }",
          "new_line_content": "  Page* source_page = Page::FromAddress(reinterpret_cast<Address>(host));",
          "content_same": false
        },
        {
          "line": 1961,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(site)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(site)",
          "old_line_content": "  // etc., and all objects reachable from them.",
          "new_line_content": "  MarkBit mark_bit = ObjectMarking::MarkBitFrom(site);",
          "content_same": false
        },
        {
          "line": 4009,
          "old_api": null,
          "new_api": "IsEvacuationCandidate",
          "old_text": null,
          "new_text": "target_page->IsEvacuationCandidate()",
          "old_line_content": "}",
          "new_line_content": "  if (target_page->IsEvacuationCandidate() &&",
          "content_same": false
        },
        {
          "line": 4010,
          "old_api": null,
          "new_api": "ShouldSkipEvacuationSlotRecording",
          "old_text": null,
          "new_text": "ShouldSkipEvacuationSlotRecording(host)",
          "old_line_content": "",
          "new_line_content": "      !ShouldSkipEvacuationSlotRecording(host)) {",
          "content_same": false
        },
        {
          "line": 4012,
          "old_api": null,
          "new_api": "IsCode",
          "old_text": null,
          "new_text": "target->IsCode()",
          "old_line_content": "void MarkCompactCollector::RecordCodeTargetPatch(Address pc, Code* target) {",
          "new_line_content": "    CHECK(target->IsCode());",
          "content_same": false
        },
        {
          "line": 1972,
          "old_api": null,
          "new_api": "MarkStringTable",
          "old_text": null,
          "new_text": "MarkStringTable(visitor)",
          "old_line_content": "}",
          "new_line_content": "  MarkStringTable(visitor);",
          "content_same": false
        },
        {
          "line": 4021,
          "old_api": null,
          "new_api": "is_compacting",
          "old_text": null,
          "new_text": "is_compacting()",
          "old_line_content": "      // The target is always in old space, we don't have to record the slot in",
          "new_line_content": "  if (is_compacting()) {",
          "content_same": false
        },
        {
          "line": 1975,
          "old_api": null,
          "new_api": "overflowed",
          "old_text": null,
          "new_text": "marking_deque_.overflowed()",
          "old_line_content": "void MarkCompactCollector::MarkImplicitRefGroups(",
          "new_line_content": "  while (marking_deque_.overflowed()) {",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": null,
          "new_api": "RefillMarkingDeque",
          "old_text": null,
          "new_text": "RefillMarkingDeque()",
          "old_line_content": "    MarkObjectFunction mark_object) {",
          "new_line_content": "    RefillMarkingDeque();",
          "content_same": false
        },
        {
          "line": 1977,
          "old_api": null,
          "new_api": "EmptyMarkingDeque",
          "old_text": null,
          "new_text": "EmptyMarkingDeque()",
          "old_line_content": "  List<ImplicitRefGroup*>* ref_groups =",
          "new_line_content": "    EmptyMarkingDeque();",
          "content_same": false
        },
        {
          "line": 4025,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(host)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(host)",
          "old_line_content": "    }",
          "new_line_content": "    MarkBit mark_bit = ObjectMarking::MarkBitFrom(host);",
          "content_same": false
        },
        {
          "line": 4026,
          "old_api": null,
          "new_api": "Marking::IsBlack(mark_bit)",
          "old_text": null,
          "new_text": "Marking::IsBlack(mark_bit)",
          "old_line_content": "  }",
          "new_line_content": "    if (Marking::IsBlack(mark_bit)) {",
          "content_same": false
        },
        {
          "line": 4027,
          "old_api": null,
          "new_api": "isolate",
          "old_text": null,
          "new_text": "isolate()",
          "old_line_content": "}",
          "new_line_content": "      RelocInfo rinfo(isolate(), pc, RelocInfo::CODE_TARGET, 0, host);",
          "content_same": false
        },
        {
          "line": 4030,
          "old_api": null,
          "new_api": "InNewSpace",
          "old_text": null,
          "new_text": "heap()->InNewSpace(target)",
          "old_line_content": "}  // namespace v8",
          "new_line_content": "      DCHECK(!heap()->InNewSpace(target));",
          "content_same": false
        },
        {
          "line": 4031,
          "old_api": null,
          "new_api": "RecordRelocSlot",
          "old_text": null,
          "new_text": "RecordRelocSlot(host, &rinfo, target)",
          "old_line_content": "",
          "new_line_content": "      RecordRelocSlot(host, &rinfo, target);",
          "content_same": false
        },
        {
          "line": 1988,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "ref_groups->length()",
          "old_line_content": "    }",
          "new_line_content": "  for (int i = 0; i < ref_groups->length(); i++) {",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "ref_groups->at(i)",
          "old_line_content": "",
          "new_line_content": "    ImplicitRefGroup* entry = ref_groups->at(i);",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(entry != NULL)",
          "old_line_content": "    Object*** children = entry->children;",
          "new_line_content": "    DCHECK(entry != NULL);",
          "content_same": false
        },
        {
          "line": 1992,
          "old_api": null,
          "new_api": "IsMarked",
          "old_text": null,
          "new_text": "IsMarked(*entry->parent)",
          "old_line_content": "    for (size_t j = 0; j < entry->length; ++j) {",
          "new_line_content": "    if (!IsMarked(*entry->parent)) {",
          "content_same": false
        },
        {
          "line": 2000,
          "old_api": null,
          "new_api": "IsHeapObject",
          "old_text": null,
          "new_text": "*children[j])->IsHeapObject()",
          "old_line_content": "    delete entry;",
          "new_line_content": "      if ((*children[j])->IsHeapObject()) {",
          "content_same": false
        },
        {
          "line": 2001,
          "old_api": null,
          "new_api": "HeapObject::cast(*children[j])",
          "old_text": null,
          "new_text": "HeapObject::cast(*children[j])",
          "old_line_content": "  }",
          "new_line_content": "        mark_object(heap(), HeapObject::cast(*children[j]));",
          "content_same": false
        },
        {
          "line": 2009,
          "old_api": null,
          "new_api": "Rewind",
          "old_text": null,
          "new_text": "ref_groups->Rewind(last)",
          "old_line_content": "// marking stack have been marked, or are overflowed in the heap.",
          "new_line_content": "  ref_groups->Rewind(last);",
          "content_same": false
        },
        {
          "line": 2018,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "marking_deque_.IsEmpty()",
          "old_line_content": "",
          "new_line_content": "  while (!marking_deque_.IsEmpty()) {",
          "content_same": false
        },
        {
          "line": 2022,
          "old_api": null,
          "new_api": "IsHeapObject",
          "old_text": null,
          "new_text": "object->IsHeapObject()",
          "old_line_content": "",
          "new_line_content": "    DCHECK(object->IsHeapObject());",
          "content_same": false
        },
        {
          "line": 2024,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(object)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(object)",
          "old_line_content": "  }",
          "new_line_content": "    DCHECK(!Marking::IsWhite(ObjectMarking::MarkBitFrom(object)));",
          "content_same": false
        },
        {
          "line": 2026,
          "old_api": null,
          "new_api": "map",
          "old_text": null,
          "new_text": "object->map()",
          "old_line_content": "",
          "new_line_content": "    Map* map = object->map();",
          "content_same": false
        },
        {
          "line": 2027,
          "old_api": null,
          "new_api": "ObjectMarking::MarkBitFrom(map)",
          "old_text": null,
          "new_text": "ObjectMarking::MarkBitFrom(map)",
          "old_line_content": "",
          "new_line_content": "    MarkBit map_mark = ObjectMarking::MarkBitFrom(map);",
          "content_same": false
        },
        {
          "line": 2028,
          "old_api": null,
          "new_api": "MarkObject",
          "old_text": null,
          "new_text": "MarkObject(map, map_mark)",
          "old_line_content": "// Sweep the heap for overflowed objects, clear their overflow bits, and",
          "new_line_content": "    MarkObject(map, map_mark);",
          "content_same": false
        },
        {
          "line": 2030,
          "old_api": null,
          "new_api": "MarkCompactMarkingVisitor::IterateBody(map, object)",
          "old_text": null,
          "new_text": "MarkCompactMarkingVisitor::IterateBody(map, object)",
          "old_line_content": "// before sweeping completes.  If sweeping completes, there are no remaining",
          "new_line_content": "    MarkCompactMarkingVisitor::IterateBody(map, object);",
          "content_same": false
        },
        {
          "line": 2042,
          "old_api": null,
          "new_api": "overflowed",
          "old_text": null,
          "new_text": "marking_deque_.overflowed()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(marking_deque_.overflowed());",
          "content_same": false
        },
        {
          "line": 2045,
          "old_api": null,
          "new_api": "IsFull",
          "old_text": null,
          "new_text": "marking_deque_.IsFull()",
          "old_line_content": "",
          "new_line_content": "  if (marking_deque_.IsFull()) return;",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2062,
          "old_api": "EmptyMarkingDeque",
          "new_api": null,
          "old_text": "EmptyMarkingDeque()",
          "new_text": null,
          "old_line_content": "  EmptyMarkingDeque();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2063,
          "old_api": "overflowed",
          "new_api": null,
          "old_text": "marking_deque_.overflowed()",
          "new_text": null,
          "old_line_content": "  while (marking_deque_.overflowed()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2064,
          "old_api": "RefillMarkingDeque",
          "new_api": null,
          "old_text": "RefillMarkingDeque()",
          "new_text": null,
          "old_line_content": "    RefillMarkingDeque();",
          "new_line_content": "// Mark all objects reachable (transitively) from objects on the marking",
          "content_same": false
        },
        {
          "line": 2065,
          "old_api": "EmptyMarkingDeque",
          "new_api": null,
          "old_text": "EmptyMarkingDeque()",
          "new_text": null,
          "old_line_content": "    EmptyMarkingDeque();",
          "new_line_content": "// stack.  Before: the marking stack contains zero or more heap object",
          "content_same": false
        },
        {
          "line": 2073,
          "old_api": "overflowed",
          "new_api": null,
          "old_text": "marking_deque_.overflowed()",
          "new_text": null,
          "old_line_content": "  DCHECK(marking_deque_.IsEmpty() && !marking_deque_.overflowed());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2076,
          "old_api": "UsingEmbedderHeapTracer",
          "new_api": null,
          "old_text": "UsingEmbedderHeapTracer()",
          "new_text": null,
          "old_line_content": "    if (UsingEmbedderHeapTracer()) {",
          "new_line_content": "// Mark all objects reachable (transitively) from objects on the marking",
          "content_same": false
        },
        {
          "line": 2077,
          "old_api": "RegisterWrappersWithEmbedderHeapTracer",
          "new_api": null,
          "old_text": "RegisterWrappersWithEmbedderHeapTracer()",
          "new_text": null,
          "old_line_content": "      RegisterWrappersWithEmbedderHeapTracer();",
          "new_line_content": "// stack including references only considered in the atomic marking pause.",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": "AdvanceTracing",
          "new_api": null,
          "old_text": "embedder_heap_tracer()->AdvanceTracing(\n          0, EmbedderHeapTracer::AdvanceTracingActions(\n                 EmbedderHeapTracer::ForceCompletionAction::FORCE_COMPLETION))",
          "new_text": null,
          "old_line_content": "      embedder_heap_tracer()->AdvanceTracing(",
          "new_line_content": "void MarkCompactCollector::ProcessEphemeralMarking(",
          "content_same": false
        },
        {
          "line": 2079,
          "old_api": "EmbedderHeapTracer::AdvanceTracingActions(\n                 EmbedderHeapTracer::ForceCompletionAction::FORCE_COMPLETION)",
          "new_api": null,
          "old_text": "EmbedderHeapTracer::AdvanceTracingActions(\n                 EmbedderHeapTracer::ForceCompletionAction::FORCE_COMPLETION)",
          "new_text": null,
          "old_line_content": "          0, EmbedderHeapTracer::AdvanceTracingActions(",
          "new_line_content": "    ObjectVisitor* visitor, bool only_process_harmony_weak_collections) {",
          "content_same": false
        },
        {
          "line": 2087,
          "old_api": "ProcessWeakCollections",
          "new_api": null,
          "old_text": "ProcessWeakCollections()",
          "new_text": null,
          "old_line_content": "    ProcessWeakCollections();",
          "new_line_content": "                 EmbedderHeapTracer::ForceCompletionAction::FORCE_COMPLETION));",
          "content_same": false
        },
        {
          "line": 2088,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "marking_deque_.IsEmpty()",
          "new_text": null,
          "old_line_content": "    work_to_do = !marking_deque_.IsEmpty();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2089,
          "old_api": "ProcessMarkingDeque",
          "new_api": null,
          "old_text": "ProcessMarkingDeque()",
          "new_text": null,
          "old_line_content": "    ProcessMarkingDeque();",
          "new_line_content": "    if (!only_process_harmony_weak_collections) {",
          "content_same": false
        },
        {
          "line": 2099,
          "old_api": "frame",
          "new_api": null,
          "old_text": "it.frame()->type()",
          "new_text": null,
          "old_line_content": "    if (it.frame()->type() == StackFrame::OPTIMIZED) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2100,
          "old_api": "frame",
          "new_api": null,
          "old_text": "it.frame()->LookupCode()",
          "new_text": null,
          "old_line_content": "      Code* code = it.frame()->LookupCode();",
          "new_line_content": "void MarkCompactCollector::ProcessTopOptimizedFrame(ObjectVisitor* visitor) {",
          "content_same": false
        },
        {
          "line": 2101,
          "old_api": "frame",
          "new_api": null,
          "old_text": "it.frame()->pc()",
          "new_text": null,
          "old_line_content": "      if (!code->CanDeoptAt(it.frame()->pc())) {",
          "new_line_content": "  for (StackFrameIterator it(isolate(), isolate()->thread_local_top());",
          "content_same": false
        },
        {
          "line": 2104,
          "old_api": "ProcessMarkingDeque",
          "new_api": null,
          "old_text": "ProcessMarkingDeque()",
          "new_text": null,
          "old_line_content": "      ProcessMarkingDeque();",
          "new_line_content": "      return;",
          "content_same": false
        },
        {
          "line": 2112,
          "old_api": "in_use",
          "new_api": null,
          "old_text": "marking_deque_.in_use()",
          "new_text": null,
          "old_line_content": "  DCHECK(!marking_deque_.in_use());",
          "new_line_content": "      return;",
          "content_same": false
        },
        {
          "line": 2118,
          "old_api": "V8::FatalProcessOutOfMemory(\"EnsureMarkingDequeIsReserved\")",
          "new_api": null,
          "old_text": "V8::FatalProcessOutOfMemory(\"EnsureMarkingDequeIsReserved\")",
          "new_text": null,
          "old_line_content": "    V8::FatalProcessOutOfMemory(\"EnsureMarkingDequeIsReserved\");",
          "new_line_content": "void MarkCompactCollector::EnsureMarkingDequeIsReserved() {",
          "content_same": false
        },
        {
          "line": 2126,
          "old_api": "in_use",
          "new_api": null,
          "old_text": "marking_deque_.in_use()",
          "new_text": null,
          "old_line_content": "  CHECK(!marking_deque_.in_use());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2134,
          "old_api": "Uncommit",
          "new_api": null,
          "old_text": "marking_deque_memory_->Uncommit(\n          reinterpret_cast<Address>(marking_deque_memory_->address()) + size,\n          currently_committed - size)",
          "new_text": null,
          "old_line_content": "      bool success = marking_deque_memory_->Uncommit(",
          "new_line_content": "  for (size_t size = max_size; size >= kMinMarkingDequeSize; size >>= 1) {",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": "address",
          "new_api": null,
          "old_text": "marking_deque_memory_->address()",
          "new_text": null,
          "old_line_content": "          reinterpret_cast<Address>(marking_deque_memory_->address()) + size,",
          "new_line_content": "    base::VirtualMemory* memory = marking_deque_memory_;",
          "content_same": false
        },
        {
          "line": 2144,
          "old_api": "Commit",
          "new_api": null,
          "old_text": "memory->Commit(\n        reinterpret_cast<Address>(memory->address()) + currently_committed,\n        size - currently_committed,\n        false)",
          "new_text": null,
          "old_line_content": "    bool success = memory->Commit(",
          "new_line_content": "      if (success) {",
          "content_same": false
        },
        {
          "line": 2145,
          "old_api": "address",
          "new_api": null,
          "old_text": "memory->address()",
          "new_text": null,
          "old_line_content": "        reinterpret_cast<Address>(memory->address()) + currently_committed,",
          "new_line_content": "        marking_deque_memory_committed_ = size;",
          "content_same": false
        },
        {
          "line": 2153,
          "old_api": "V8::FatalProcessOutOfMemory(\"EnsureMarkingDequeIsCommitted\")",
          "new_api": null,
          "old_text": "V8::FatalProcessOutOfMemory(\"EnsureMarkingDequeIsCommitted\")",
          "new_text": null,
          "old_line_content": "  V8::FatalProcessOutOfMemory(\"EnsureMarkingDequeIsCommitted\");",
          "new_line_content": "        size - currently_committed,",
          "content_same": false
        },
        {
          "line": 2158,
          "old_api": "in_use",
          "new_api": null,
          "old_text": "marking_deque_.in_use()",
          "new_text": null,
          "old_line_content": "  DCHECK(!marking_deque_.in_use());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2159,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(marking_deque_memory_committed_ > 0)",
          "new_text": null,
          "old_line_content": "  DCHECK(marking_deque_memory_committed_ > 0);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2163,
          "old_api": "Initialize",
          "new_api": null,
          "old_text": "marking_deque_.Initialize(addr, addr + size)",
          "new_text": null,
          "old_line_content": "  marking_deque_.Initialize(addr, addr + size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2168,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(!in_use_)",
          "new_text": null,
          "old_line_content": "  DCHECK(!in_use_);",
          "new_line_content": "  size_t size = marking_deque_memory_committed_;",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": "reinterpret_cast<HeapObject**>(low)",
          "new_api": null,
          "old_text": "reinterpret_cast<HeapObject**>(low)",
          "new_text": null,
          "old_line_content": "  HeapObject** obj_low = reinterpret_cast<HeapObject**>(low);",
          "new_line_content": "  if (FLAG_force_marking_deque_overflows) size = 64 * kPointerSize;",
          "content_same": false
        },
        {
          "line": 2172,
          "old_api": "base::bits::RoundDownToPowerOfTwo32(\n              static_cast<uint32_t>(obj_high - obj_low))",
          "new_api": null,
          "old_text": "base::bits::RoundDownToPowerOfTwo32(\n              static_cast<uint32_t>(obj_high - obj_low))",
          "new_text": null,
          "old_line_content": "  mask_ = base::bits::RoundDownToPowerOfTwo32(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2173,
          "old_api": "static_cast<uint32_t>(obj_high - obj_low)",
          "new_api": null,
          "old_text": "static_cast<uint32_t>(obj_high - obj_low)",
          "new_text": null,
          "old_line_content": "              static_cast<uint32_t>(obj_high - obj_low)) -",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2183,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "IsEmpty()",
          "new_text": null,
          "old_line_content": "    DCHECK(IsEmpty());",
          "new_line_content": "  overflowed_ = false;",
          "content_same": false
        },
        {
          "line": 2184,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(!overflowed_)",
          "new_text": null,
          "old_line_content": "    DCHECK(!overflowed_);",
          "new_line_content": "  in_use_ = true;",
          "content_same": false
        },
        {
          "line": 2186,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(in_use_)",
          "new_text": null,
          "old_line_content": "  DCHECK(in_use_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2192,
          "old_api": "DCHECK_NOT_NULL",
          "new_api": null,
          "old_text": "DCHECK_NOT_NULL(tracer)",
          "new_text": null,
          "old_line_content": "  DCHECK_NOT_NULL(tracer);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2198,
          "old_api": "UsingEmbedderHeapTracer",
          "new_api": null,
          "old_text": "UsingEmbedderHeapTracer()",
          "new_text": null,
          "old_line_content": "  DCHECK(UsingEmbedderHeapTracer());",
          "new_line_content": "void MarkCompactCollector::SetEmbedderHeapTracer(EmbedderHeapTracer* tracer) {",
          "content_same": false
        },
        {
          "line": 2202,
          "old_api": "RegisterV8References",
          "new_api": null,
          "old_text": "embedder_heap_tracer()->RegisterV8References(wrappers_to_trace_)",
          "new_text": null,
          "old_line_content": "  embedder_heap_tracer()->RegisterV8References(wrappers_to_trace_);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2203,
          "old_api": "clear",
          "new_api": null,
          "old_text": "wrappers_to_trace_.clear()",
          "new_text": null,
          "old_line_content": "  wrappers_to_trace_.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2207,
          "old_api": "WasConstructedFromApiFunction",
          "new_api": null,
          "old_text": "js_object->WasConstructedFromApiFunction()",
          "new_text": null,
          "old_line_content": "  DCHECK(js_object->WasConstructedFromApiFunction());",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 2208,
          "old_api": "GetInternalFieldCount",
          "new_api": null,
          "old_text": "js_object->GetInternalFieldCount()",
          "new_text": null,
          "old_line_content": "  if (js_object->GetInternalFieldCount() >= 2 &&",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2211,
          "old_api": "undefined_value",
          "new_api": null,
          "old_text": "heap_->undefined_value()",
          "new_text": null,
          "old_line_content": "      js_object->GetInternalField(1) != heap_->undefined_value()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2212,
          "old_api": "GetInternalField",
          "new_api": null,
          "old_text": "js_object->GetInternalField(0)",
          "new_text": null,
          "old_line_content": "    DCHECK(reinterpret_cast<intptr_t>(js_object->GetInternalField(0)) % 2 == 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2213,
          "old_api": "GetInternalField",
          "new_api": null,
          "old_text": "std::pair<void*, void*>(\n        reinterpret_cast<void*>(js_object->GetInternalField(0)),\n        reinterpret_cast<void*>(js_object->GetInternalField(1)))",
          "new_text": null,
          "old_line_content": "    wrappers_to_trace_.push_back(std::pair<void*, void*>(",
          "new_line_content": "void MarkCompactCollector::TracePossibleWrapper(JSObject* js_object) {",
          "content_same": false
        },
        {
          "line": 2223,
          "old_api": "ObjectMarking::MarkBitFrom(heap_object)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(heap_object)",
          "new_text": null,
          "old_line_content": "  MarkBit mark_bit = ObjectMarking::MarkBitFrom(heap_object);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": "MarkObject",
          "new_api": null,
          "old_text": "MarkObject(heap_object, mark_bit)",
          "new_text": null,
          "old_line_content": "  MarkObject(heap_object, mark_bit);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2233,
          "old_api": "DCHECK_NOT_NULL",
          "new_api": null,
          "old_text": "DCHECK_NOT_NULL(live_stats)",
          "new_text": null,
          "old_line_content": "    DCHECK_NOT_NULL(live_stats);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2234,
          "old_api": "DCHECK_NOT_NULL",
          "new_api": null,
          "old_text": "DCHECK_NOT_NULL(dead_stats)",
          "new_text": null,
          "old_line_content": "    DCHECK_NOT_NULL(dead_stats);",
          "new_line_content": "class MarkCompactCollector::ObjectStatsVisitor",
          "content_same": false
        },
        {
          "line": 2236,
          "old_api": "CollectGlobalStatistics",
          "new_api": null,
          "old_text": "live_collector_.CollectGlobalStatistics()",
          "new_text": null,
          "old_line_content": "    live_collector_.CollectGlobalStatistics();",
          "new_line_content": " public:",
          "content_same": false
        },
        {
          "line": 2244,
          "old_api": "CollectStatistics",
          "new_api": null,
          "old_text": "dead_collector_.CollectStatistics(obj)",
          "new_text": null,
          "old_line_content": "      dead_collector_.CollectStatistics(obj);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2257,
          "old_api": "has_next",
          "new_api": null,
          "old_text": "space_it.has_next()",
          "new_text": null,
          "old_line_content": "  while (space_it.has_next()) {",
          "new_line_content": "  ObjectStatsCollector live_collector_;",
          "content_same": false
        },
        {
          "line": 2258,
          "old_api": "next",
          "new_api": null,
          "old_text": "space_it.next()",
          "new_text": null,
          "old_line_content": "    ObjectIterator* it = space_it.next();",
          "new_line_content": "  ObjectStatsCollector dead_collector_;",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": "Next",
          "new_api": null,
          "old_text": "it->Next()",
          "new_text": null,
          "old_line_content": "    while ((obj = it->Next()) != nullptr) {",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 2260,
          "old_api": "Visit",
          "new_api": null,
          "old_text": "visitor->Visit(obj)",
          "new_text": null,
          "old_line_content": "      visitor->Visit(obj);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2269,
          "old_api": "VisitAllObjects",
          "new_api": null,
          "old_text": "VisitAllObjects(&visitor)",
          "new_text": null,
          "old_line_content": "    VisitAllObjects(&visitor);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2271,
          "old_api": "PrintJSON",
          "new_api": null,
          "old_text": "heap()->live_object_stats_->PrintJSON(\"live\")",
          "new_text": null,
          "old_line_content": "      heap()->live_object_stats_->PrintJSON(\"live\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2272,
          "old_api": "PrintJSON",
          "new_api": null,
          "old_text": "heap()->dead_object_stats_->PrintJSON(\"dead\")",
          "new_text": null,
          "old_line_content": "      heap()->dead_object_stats_->PrintJSON(\"dead\");",
          "new_line_content": "void MarkCompactCollector::RecordObjectStats() {",
          "content_same": false
        },
        {
          "line": 2274,
          "old_api": "CheckpointObjectStats",
          "new_api": null,
          "old_text": "heap()->live_object_stats_->CheckpointObjectStats()",
          "new_text": null,
          "old_line_content": "    heap()->live_object_stats_->CheckpointObjectStats();",
          "new_line_content": "    ObjectStatsVisitor visitor(heap(), heap()->live_object_stats_,",
          "content_same": false
        },
        {
          "line": 2275,
          "old_api": "ClearObjectStats",
          "new_api": null,
          "old_text": "heap()->dead_object_stats_->ClearObjectStats()",
          "new_text": null,
          "old_line_content": "    heap()->dead_object_stats_->ClearObjectStats();",
          "new_line_content": "                               heap()->dead_object_stats_);",
          "content_same": false
        },
        {
          "line": 2280,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_MARK);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2283,
          "old_api": "MonotonicallyIncreasingTimeInMs",
          "new_api": null,
          "old_text": "heap_->MonotonicallyIncreasingTimeInMs()",
          "new_text": null,
          "old_line_content": "    start_time = heap_->MonotonicallyIncreasingTimeInMs();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_MARK_FINISH_INCREMENTAL);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2292,
          "old_api": "incremental_marking",
          "new_api": null,
          "old_text": "heap_->incremental_marking()",
          "new_text": null,
          "old_line_content": "    IncrementalMarking* incremental_marking = heap_->incremental_marking();",
          "new_line_content": "  // The recursive GC marker detects when it is nearing stack overflow,",
          "content_same": false
        },
        {
          "line": 2294,
          "old_api": "Finalize",
          "new_api": null,
          "old_text": "incremental_marking->Finalize()",
          "new_text": null,
          "old_line_content": "      incremental_marking->Finalize();",
          "new_line_content": "  // with the C stack limit check.",
          "content_same": false
        },
        {
          "line": 2297,
          "old_api": "Stop",
          "new_api": null,
          "old_text": "incremental_marking->Stop()",
          "new_text": null,
          "old_line_content": "      incremental_marking->Stop();",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": "EnsureMarkingDequeIsCommittedAndInitialize",
          "new_api": null,
          "old_text": "EnsureMarkingDequeIsCommittedAndInitialize(\n      MarkCompactCollector::kMaxMarkingDequeSize)",
          "new_text": null,
          "old_line_content": "  EnsureMarkingDequeIsCommittedAndInitialize(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2313,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_MARK_PREPARE_CODE_FLUSH);",
          "new_line_content": "  state_ = MARK_LIVE_OBJECTS;",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": "PrepareForCodeFlushing",
          "new_api": null,
          "old_text": "PrepareForCodeFlushing()",
          "new_text": null,
          "old_line_content": "    PrepareForCodeFlushing();",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 2322,
          "old_api": "ProcessTopOptimizedFrame",
          "new_api": null,
          "old_text": "ProcessTopOptimizedFrame(&root_visitor)",
          "new_text": null,
          "old_line_content": "    ProcessTopOptimizedFrame(&root_visitor);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2326,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_MARK_WEAK_CLOSURE);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "      TRACE_GC(heap()->tracer(),",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 2334,
          "old_api": "ProcessEphemeralMarking",
          "new_api": null,
          "old_text": "ProcessEphemeralMarking(&root_visitor, false)",
          "new_text": null,
          "old_line_content": "      ProcessEphemeralMarking(&root_visitor, false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2345,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "      TRACE_GC(heap()->tracer(),",
          "new_line_content": "    // are marked. Objects pointed to only by weak global handles cannot be",
          "content_same": false
        },
        {
          "line": 2347,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap()->isolate()->global_handles()->IdentifyWeakHandles(\n          &IsUnmarkedHeapObject)",
          "new_text": null,
          "old_line_content": "      heap()->isolate()->global_handles()->IdentifyWeakHandles(",
          "new_line_content": "    // objects reachable from them.",
          "content_same": false
        },
        {
          "line": 2349,
          "old_api": "ProcessMarkingDeque",
          "new_api": null,
          "old_text": "ProcessMarkingDeque()",
          "new_text": null,
          "old_line_content": "      ProcessMarkingDeque();",
          "new_line_content": "    // First we identify nonlive weak handles and mark them as pending",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": "ProcessMarkingDeque",
          "new_api": null,
          "old_text": "ProcessMarkingDeque()",
          "new_text": null,
          "old_line_content": "      ProcessMarkingDeque();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2366,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "      TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_MARK_WEAK_CLOSURE_HARMONY);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2367,
          "old_api": "ProcessEphemeralMarking",
          "new_api": null,
          "old_text": "ProcessEphemeralMarking(&root_visitor, true)",
          "new_text": null,
          "old_line_content": "      ProcessEphemeralMarking(&root_visitor, true);",
          "new_line_content": "    // Repeat Harmony weak maps marking to mark unmarked objects reachable from",
          "content_same": false
        },
        {
          "line": 2368,
          "old_api": "UsingEmbedderHeapTracer",
          "new_api": null,
          "old_text": "UsingEmbedderHeapTracer()",
          "new_text": null,
          "old_line_content": "      if (UsingEmbedderHeapTracer()) {",
          "new_line_content": "    // the weak roots we just marked as pending destruction.",
          "content_same": false
        },
        {
          "line": 2369,
          "old_api": "TraceEpilogue",
          "new_api": null,
          "old_text": "embedder_heap_tracer()->TraceEpilogue()",
          "new_text": null,
          "old_line_content": "        embedder_heap_tracer()->TraceEpilogue();",
          "new_line_content": "    //",
          "content_same": false
        },
        {
          "line": 2385,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_CLEAR_STRING_TABLE);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": "string_table",
          "new_api": null,
          "old_text": "heap()->string_table()",
          "new_text": null,
          "old_line_content": "    StringTable* string_table = heap()->string_table();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2393,
          "old_api": "PointersRemoved",
          "new_api": null,
          "old_text": "internalized_visitor.PointersRemoved()",
          "new_text": null,
          "old_line_content": "    string_table->ElementsRemoved(internalized_visitor.PointersRemoved());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": "Iterate",
          "new_api": null,
          "old_text": "heap()->external_string_table_.Iterate(&external_visitor)",
          "new_text": null,
          "old_line_content": "    heap()->external_string_table_.Iterate(&external_visitor);",
          "new_line_content": "    // table is marked.",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_CLEAR_WEAK_LISTS);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap()->isolate()->global_handles()->RemoveImplicitRefGroups()",
          "new_text": null,
          "old_line_content": "    heap()->isolate()->global_handles()->RemoveImplicitRefGroups();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2416,
          "old_api": "is_code_flushing_enabled",
          "new_api": null,
          "old_text": "is_code_flushing_enabled()",
          "new_text": null,
          "old_line_content": "  if (is_code_flushing_enabled()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2417,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_CLEAR_CODE_FLUSH);",
          "new_line_content": "    // Remove object groups after marking phase.",
          "content_same": false
        },
        {
          "line": 2427,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_CLEAR_MAPS);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2428,
          "old_api": "ClearSimpleMapTransitions",
          "new_api": null,
          "old_text": "ClearSimpleMapTransitions(non_live_map_list)",
          "new_text": null,
          "old_line_content": "    ClearSimpleMapTransitions(non_live_map_list);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": "ClearFullMapTransitions",
          "new_api": null,
          "old_text": "ClearFullMapTransitions()",
          "new_text": null,
          "old_line_content": "    ClearFullMapTransitions();",
          "new_line_content": "  DependentCode* dependent_code_list;",
          "content_same": false
        },
        {
          "line": 2432,
          "old_api": "MarkDependentCodeForDeoptimization",
          "new_api": null,
          "old_text": "MarkDependentCodeForDeoptimization(dependent_code_list)",
          "new_text": null,
          "old_line_content": "  MarkDependentCodeForDeoptimization(dependent_code_list);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2442,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_CLEAR_DEPENDENT_CODE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": "length",
          "new_api": null,
          "old_text": "current->length()",
          "new_text": null,
          "old_line_content": "  while (current->length() > 0) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2446,
          "old_api": "MarkCodeForDeoptimization",
          "new_api": null,
          "old_text": "current->MarkCodeForDeoptimization(\n        isolate, DependentCode::kWeakCodeGroup)",
          "new_text": null,
          "old_line_content": "    have_code_to_deoptimize_ |= current->MarkCodeForDeoptimization(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2448,
          "old_api": "next_link",
          "new_api": null,
          "old_text": "current->next_link()",
          "new_text": null,
          "old_line_content": "    current = current->next_link();",
          "new_line_content": "    DependentCode* list_head) {",
          "content_same": false
        },
        {
          "line": 2454,
          "old_api": "Length",
          "new_api": null,
          "old_text": "list->Length()",
          "new_text": null,
          "old_line_content": "    for (int i = 0; i < list->Length(); i += 2) {",
          "new_line_content": "        isolate, DependentCode::kWeakCodeGroup);",
          "content_same": false
        },
        {
          "line": 2456,
          "old_api": "Get",
          "new_api": null,
          "old_text": "list->Get(i + 1)",
          "new_text": null,
          "old_line_content": "      WeakCell* dep = WeakCell::cast(list->Get(i + 1));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2457,
          "old_api": "cleared",
          "new_api": null,
          "old_text": "dep->cleared()",
          "new_text": null,
          "old_line_content": "      if (obj->cleared() || dep->cleared()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2458,
          "old_api": "cleared",
          "new_api": null,
          "old_text": "dep->cleared()",
          "new_text": null,
          "old_line_content": "        if (!dep->cleared()) {",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 2460,
          "old_api": "marked_for_deoptimization",
          "new_api": null,
          "old_text": "code->marked_for_deoptimization()",
          "new_text": null,
          "old_line_content": "          if (!code->marked_for_deoptimization()) {",
          "new_line_content": "    int counter = 0;",
          "content_same": false
        },
        {
          "line": 2471,
          "old_api": "Slot",
          "new_api": null,
          "old_text": "list->Slot(counter)",
          "new_text": null,
          "old_line_content": "        RecordSlot(list, list->Slot(counter), obj);",
          "new_line_content": "            have_code_to_deoptimize_ = true;",
          "content_same": false
        },
        {
          "line": 2473,
          "old_api": "Set",
          "new_api": null,
          "old_text": "list->Set(counter, dep, SKIP_WRITE_BARRIER)",
          "new_text": null,
          "old_line_content": "        list->Set(counter, dep, SKIP_WRITE_BARRIER);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2474,
          "old_api": "Slot",
          "new_api": null,
          "old_text": "list->Slot(counter)",
          "new_text": null,
          "old_line_content": "        RecordSlot(list, list->Slot(counter), dep);",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 2483,
          "old_api": "EntryToIndex",
          "new_api": null,
          "old_text": "table->EntryToIndex(i)",
          "new_text": null,
          "old_line_content": "    uint32_t key_index = table->EntryToIndex(i);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2484,
          "old_api": "get",
          "new_api": null,
          "old_text": "table->get(key_index)",
          "new_text": null,
          "old_line_content": "    Object* key = table->get(key_index);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2485,
          "old_api": "IsKey",
          "new_api": null,
          "old_text": "table->IsKey(isolate, key)",
          "new_text": null,
          "old_line_content": "    if (!table->IsKey(isolate, key)) continue;",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2486,
          "old_api": "EntryToValueIndex",
          "new_api": null,
          "old_text": "table->EntryToValueIndex(i)",
          "new_text": null,
          "old_line_content": "    uint32_t value_index = table->EntryToValueIndex(i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2489,
          "old_api": "cleared",
          "new_api": null,
          "old_text": "WeakCell::cast(key)->cleared()",
          "new_text": null,
          "old_line_content": "    if (WeakCell::cast(key)->cleared()) {",
          "new_line_content": "  for (uint32_t i = 0; i < capacity; i++) {",
          "content_same": false
        },
        {
          "line": 2503,
          "old_api": "the_hole_value",
          "new_api": null,
          "old_text": "heap()->the_hole_value()",
          "new_text": null,
          "old_line_content": "  Object* the_hole_value = heap()->the_hole_value();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2505,
          "old_api": "Smi::FromInt(0)",
          "new_api": null,
          "old_text": "Smi::FromInt(0)",
          "new_text": null,
          "old_line_content": "  while (weak_cell_obj != Smi::FromInt(0)) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2506,
          "old_api": "WeakCell::cast(weak_cell_obj)",
          "new_api": null,
          "old_text": "WeakCell::cast(weak_cell_obj)",
          "new_text": null,
          "old_line_content": "    WeakCell* weak_cell = WeakCell::cast(weak_cell_obj);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2507,
          "old_api": "value",
          "new_api": null,
          "old_text": "weak_cell->value()",
          "new_text": null,
          "old_line_content": "    Map* map = Map::cast(weak_cell->value());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2508,
          "old_api": "ObjectMarking::MarkBitFrom(map)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(map)",
          "new_text": null,
          "old_line_content": "    DCHECK(Marking::IsWhite(ObjectMarking::MarkBitFrom(map)));",
          "new_line_content": "void MarkCompactCollector::ClearSimpleMapTransitions(",
          "content_same": false
        },
        {
          "line": 2509,
          "old_api": "constructor_or_backpointer",
          "new_api": null,
          "old_text": "map->constructor_or_backpointer()",
          "new_text": null,
          "old_line_content": "    Object* potential_parent = map->constructor_or_backpointer();",
          "new_line_content": "    Object* non_live_map_list) {",
          "content_same": false
        },
        {
          "line": 2511,
          "old_api": "Map::cast(potential_parent)",
          "new_api": null,
          "old_text": "Map::cast(potential_parent)",
          "new_text": null,
          "old_line_content": "      Map* parent = Map::cast(potential_parent);",
          "new_line_content": "  Object* weak_cell_obj = non_live_map_list;",
          "content_same": false
        },
        {
          "line": 2529,
          "old_api": "Smi::FromInt(0)",
          "new_api": null,
          "old_text": "Smi::FromInt(0)",
          "new_text": null,
          "old_line_content": "  map->set_raw_transitions(Smi::FromInt(0));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2530,
          "old_api": "NumberOfOwnDescriptors",
          "new_api": null,
          "old_text": "map->NumberOfOwnDescriptors()",
          "new_text": null,
          "old_line_content": "  int number_of_own_descriptors = map->NumberOfOwnDescriptors();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2531,
          "old_api": "instance_descriptors",
          "new_api": null,
          "old_text": "map->instance_descriptors()",
          "new_text": null,
          "old_line_content": "  DescriptorArray* descriptors = map->instance_descriptors();",
          "new_line_content": "void MarkCompactCollector::ClearSimpleMapTransition(Map* map,",
          "content_same": false
        },
        {
          "line": 2532,
          "old_api": "instance_descriptors",
          "new_api": null,
          "old_text": "dead_transition->instance_descriptors()",
          "new_text": null,
          "old_line_content": "  if (descriptors == dead_transition->instance_descriptors() &&",
          "new_line_content": "                                                    Map* dead_transition) {",
          "content_same": false
        },
        {
          "line": 2534,
          "old_api": "TrimDescriptorArray",
          "new_api": null,
          "old_text": "TrimDescriptorArray(map, descriptors)",
          "new_text": null,
          "old_line_content": "    TrimDescriptorArray(map, descriptors);",
          "new_line_content": "  // to be cleared. Clear the useless cell pointer, and take ownership",
          "content_same": false
        },
        {
          "line": 2535,
          "old_api": "number_of_descriptors",
          "new_api": null,
          "old_text": "descriptors->number_of_descriptors()",
          "new_text": null,
          "old_line_content": "    DCHECK(descriptors->number_of_descriptors() == number_of_own_descriptors);",
          "new_line_content": "  // of the descriptor array.",
          "content_same": false
        },
        {
          "line": 2544,
          "old_api": "Smi::FromInt(0)",
          "new_api": null,
          "old_text": "Smi::FromInt(0)",
          "new_text": null,
          "old_line_content": "  while (obj != Smi::FromInt(0)) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2545,
          "old_api": "TransitionArray::cast(obj)",
          "new_api": null,
          "old_text": "TransitionArray::cast(obj)",
          "new_text": null,
          "old_line_content": "    TransitionArray* array = TransitionArray::cast(obj);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2546,
          "old_api": "number_of_entries",
          "new_api": null,
          "old_text": "array->number_of_entries()",
          "new_text": null,
          "old_line_content": "    int num_transitions = array->number_of_entries();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": "TransitionArray::NumberOfTransitions(array)",
          "new_api": null,
          "old_text": "TransitionArray::NumberOfTransitions(array)",
          "new_text": null,
          "old_line_content": "    DCHECK_EQ(TransitionArray::NumberOfTransitions(array), num_transitions);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2558,
          "old_api": "TrimDescriptorArray",
          "new_api": null,
          "old_text": "TrimDescriptorArray(parent, descriptors)",
          "new_text": null,
          "old_line_content": "        TrimDescriptorArray(parent, descriptors);",
          "new_line_content": "      bool parent_is_alive =",
          "content_same": false
        },
        {
          "line": 2562,
          "old_api": "set_next_link",
          "new_api": null,
          "old_text": "array->set_next_link(undefined, SKIP_WRITE_BARRIER)",
          "new_text": null,
          "old_line_content": "    array->set_next_link(undefined, SKIP_WRITE_BARRIER);",
          "new_line_content": "      bool descriptors_owner_died =",
          "content_same": false
        },
        {
          "line": 2564,
          "old_api": "Smi::FromInt(0)",
          "new_api": null,
          "old_text": "Smi::FromInt(0)",
          "new_text": null,
          "old_line_content": "  heap()->set_encountered_transition_arrays(Smi::FromInt(0));",
          "new_line_content": "      if (descriptors_owner_died) {",
          "content_same": false
        },
        {
          "line": 2570,
          "old_api": "number_of_entries",
          "new_api": null,
          "old_text": "transitions->number_of_entries()",
          "new_text": null,
          "old_line_content": "  int num_transitions = transitions->number_of_entries();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2575,
          "old_api": "GetTarget",
          "new_api": null,
          "old_text": "transitions->GetTarget(i)",
          "new_text": null,
          "old_line_content": "    Map* target = transitions->GetTarget(i);",
          "new_line_content": "bool MarkCompactCollector::CompactTransitionArray(",
          "content_same": false
        },
        {
          "line": 2576,
          "old_api": "constructor_or_backpointer",
          "new_api": null,
          "old_text": "target->constructor_or_backpointer()",
          "new_text": null,
          "old_line_content": "    DCHECK_EQ(target->constructor_or_backpointer(), map);",
          "new_line_content": "    Map* map, TransitionArray* transitions, DescriptorArray* descriptors) {",
          "content_same": false
        },
        {
          "line": 2579,
          "old_api": "instance_descriptors",
          "new_api": null,
          "old_text": "target->instance_descriptors()",
          "new_text": null,
          "old_line_content": "          target->instance_descriptors() == descriptors) {",
          "new_line_content": "  int transition_index = 0;",
          "content_same": false
        },
        {
          "line": 2585,
          "old_api": "SetKey",
          "new_api": null,
          "old_text": "transitions->SetKey(transition_index, key)",
          "new_text": null,
          "old_line_content": "        transitions->SetKey(transition_index, key);",
          "new_line_content": "      if (descriptors != nullptr &&",
          "content_same": false
        },
        {
          "line": 2587,
          "old_api": "RecordSlot",
          "new_api": null,
          "old_text": "RecordSlot(transitions, key_slot, key)",
          "new_text": null,
          "old_line_content": "        RecordSlot(transitions, key_slot, key);",
          "new_line_content": "        descriptors_owner_died = true;",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": "GetTarget",
          "new_api": null,
          "old_text": "transitions->GetTarget(i)",
          "new_text": null,
          "old_line_content": "        transitions->SetTarget(transition_index, transitions->GetTarget(i));",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 2605,
          "old_api": "heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(\n        transitions, trim * TransitionArray::kTransitionSize)",
          "new_api": null,
          "old_text": "heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(\n        transitions, trim * TransitionArray::kTransitionSize)",
          "new_text": null,
          "old_line_content": "    heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2607,
          "old_api": "SetNumberOfTransitions",
          "new_api": null,
          "old_text": "transitions->SetNumberOfTransitions(transition_index)",
          "new_text": null,
          "old_line_content": "    transitions->SetNumberOfTransitions(transition_index);",
          "new_line_content": "  // such that number_of_transitions() == 0. If this assumption changes,",
          "content_same": false
        },
        {
          "line": 2615,
          "old_api": "NumberOfOwnDescriptors",
          "new_api": null,
          "old_text": "map->NumberOfOwnDescriptors()",
          "new_text": null,
          "old_line_content": "  int number_of_own_descriptors = map->NumberOfOwnDescriptors();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2617,
          "old_api": "empty_descriptor_array",
          "new_api": null,
          "old_text": "heap_->empty_descriptor_array()",
          "new_text": null,
          "old_line_content": "    DCHECK(descriptors == heap_->empty_descriptor_array());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2621,
          "old_api": "number_of_descriptors_storage",
          "new_api": null,
          "old_text": "descriptors->number_of_descriptors_storage()",
          "new_text": null,
          "old_line_content": "  int number_of_descriptors = descriptors->number_of_descriptors_storage();",
          "new_line_content": "                                               DescriptorArray* descriptors) {",
          "content_same": false
        },
        {
          "line": 2626,
          "old_api": "SetNumberOfDescriptors",
          "new_api": null,
          "old_text": "descriptors->SetNumberOfDescriptors(number_of_own_descriptors)",
          "new_text": null,
          "old_line_content": "    descriptors->SetNumberOfDescriptors(number_of_own_descriptors);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2629,
          "old_api": "Sort",
          "new_api": null,
          "old_text": "descriptors->Sort()",
          "new_text": null,
          "old_line_content": "    descriptors->Sort();",
          "new_line_content": "  int to_trim = number_of_descriptors - number_of_own_descriptors;",
          "content_same": false
        },
        {
          "line": 2632,
          "old_api": "layout_descriptor",
          "new_api": null,
          "old_text": "map->layout_descriptor()",
          "new_text": null,
          "old_line_content": "      LayoutDescriptor* layout_descriptor = map->layout_descriptor();",
          "new_line_content": "        descriptors, to_trim * DescriptorArray::kDescriptorSize);",
          "content_same": false
        },
        {
          "line": 2638,
          "old_api": "number_of_descriptors",
          "new_api": null,
          "old_text": "descriptors->number_of_descriptors()",
          "new_text": null,
          "old_line_content": "  DCHECK(descriptors->number_of_descriptors() == number_of_own_descriptors);",
          "new_line_content": "    if (FLAG_unbox_double_fields) {",
          "content_same": false
        },
        {
          "line": 2648,
          "old_api": "NumberOfDescribedProperties",
          "new_api": null,
          "old_text": "map->NumberOfDescribedProperties(OWN_DESCRIPTORS, ENUMERABLE_STRINGS)",
          "new_text": null,
          "old_line_content": "        map->NumberOfDescribedProperties(OWN_DESCRIPTORS, ENUMERABLE_STRINGS);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2650,
          "old_api": "ClearEnumCache",
          "new_api": null,
          "old_text": "descriptors->ClearEnumCache()",
          "new_text": null,
          "old_line_content": "  if (live_enum == 0) return descriptors->ClearEnumCache();",
          "new_line_content": "void MarkCompactCollector::TrimEnumCache(Map* map,",
          "content_same": false
        },
        {
          "line": 2654,
          "old_api": "length",
          "new_api": null,
          "old_text": "enum_cache->length()",
          "new_text": null,
          "old_line_content": "  int to_trim = enum_cache->length() - live_enum;",
          "new_line_content": "    live_enum =",
          "content_same": false
        },
        {
          "line": 2656,
          "old_api": "GetEnumCache",
          "new_api": null,
          "old_text": "heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(\n      descriptors->GetEnumCache(), to_trim)",
          "new_text": null,
          "old_line_content": "  heap_->RightTrimFixedArray<Heap::SEQUENTIAL_TO_SWEEPER>(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2660,
          "old_api": "GetEnumIndicesCache",
          "new_api": null,
          "old_text": "descriptors->GetEnumIndicesCache()",
          "new_text": null,
          "old_line_content": "  FixedArray* enum_indices_cache = descriptors->GetEnumIndicesCache();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": "ShouldReduceMemory",
          "new_api": null,
          "old_text": "heap()->ShouldReduceMemory()",
          "new_text": null,
          "old_line_content": "  if (heap()->ShouldReduceMemory()) {",
          "new_line_content": "  // exist enough compaction speed samples.",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()->CompactionSpeedInBytesPerMillisecond()",
          "new_text": null,
          "old_line_content": "        heap()->tracer()->CompactionSpeedInBytesPerMillisecond();",
          "new_line_content": "    *max_evacuated_bytes = kMaxEvacuatedBytesForReduceMemory;",
          "content_same": false
        },
        {
          "line": 2670,
          "old_api": "reinterpret_cast<JSWeakCollection*>(weak_collection_obj)",
          "new_api": null,
          "old_text": "reinterpret_cast<JSWeakCollection*>(weak_collection_obj)",
          "new_text": null,
          "old_line_content": "        reinterpret_cast<JSWeakCollection*>(weak_collection_obj);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2671,
          "old_api": "MarkCompactCollector::IsMarked(weak_collection)",
          "new_api": null,
          "old_text": "MarkCompactCollector::IsMarked(weak_collection)",
          "new_text": null,
          "old_line_content": "    DCHECK(MarkCompactCollector::IsMarked(weak_collection));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": "static_cast<int>(\n          100 - 100 * kTargetMsPerArea / estimated_ms_per_area)",
          "new_api": null,
          "old_text": "static_cast<int>(\n          100 - 100 * kTargetMsPerArea / estimated_ms_per_area)",
          "new_text": null,
          "old_line_content": "      *target_fragmentation_percent = static_cast<int>(",
          "new_line_content": "    const double estimated_compaction_speed =",
          "content_same": false
        },
        {
          "line": 2672,
          "old_api": "table",
          "new_api": null,
          "old_text": "weak_collection->table()->IsHashTable()",
          "new_text": null,
          "old_line_content": "    if (weak_collection->table()->IsHashTable()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2673,
          "old_api": "table",
          "new_api": null,
          "old_text": "weak_collection->table()",
          "new_text": null,
          "old_line_content": "      ObjectHashTable* table = ObjectHashTable::cast(weak_collection->table());",
          "new_line_content": "void MarkCompactCollector::ProcessWeakCollections() {",
          "content_same": false
        },
        {
          "line": 2686,
          "old_api": "next",
          "new_api": null,
          "old_text": "weak_collection->next()",
          "new_text": null,
          "old_line_content": "    weak_collection_obj = weak_collection->next();",
          "new_line_content": "          Object** value_slot =",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": "identity",
          "new_api": null,
          "old_text": "space->identity()",
          "new_text": null,
          "old_line_content": "  DCHECK(space->identity() == OLD_SPACE || space->identity() == CODE_SPACE);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "CountTotalPages",
          "new_api": null,
          "old_text": "space->CountTotalPages()",
          "new_text": null,
          "old_line_content": "  int number_of_pages = space->CountTotalPages();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "AreaSize",
          "new_api": null,
          "old_text": "space->AreaSize()",
          "new_text": null,
          "old_line_content": "  int area_size = space->AreaSize();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2692,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_CLEAR_WEAK_COLLECTIONS);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2694,
          "old_api": "Smi::FromInt(0)",
          "new_api": null,
          "old_text": "Smi::FromInt(0)",
          "new_text": null,
          "old_line_content": "  while (weak_collection_obj != Smi::FromInt(0)) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "pages.reserve(number_of_pages)",
          "new_text": null,
          "old_line_content": "  pages.reserve(number_of_pages);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2696,
          "old_api": "reinterpret_cast<JSWeakCollection*>(weak_collection_obj)",
          "new_api": null,
          "old_text": "reinterpret_cast<JSWeakCollection*>(weak_collection_obj)",
          "new_text": null,
          "old_line_content": "        reinterpret_cast<JSWeakCollection*>(weak_collection_obj);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": "MarkCompactCollector::IsMarked(weak_collection)",
          "new_api": null,
          "old_text": "MarkCompactCollector::IsMarked(weak_collection)",
          "new_text": null,
          "old_line_content": "    DCHECK(MarkCompactCollector::IsMarked(weak_collection));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": "NeverEvacuate",
          "new_api": null,
          "old_text": "p->NeverEvacuate()",
          "new_text": null,
          "old_line_content": "    if (p->NeverEvacuate()) continue;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2698,
          "old_api": "table",
          "new_api": null,
          "old_text": "weak_collection->table()->IsHashTable()",
          "new_text": null,
          "old_line_content": "    if (weak_collection->table()->IsHashTable()) {",
          "new_line_content": "void MarkCompactCollector::ClearWeakCollections() {",
          "content_same": false
        },
        {
          "line": 2702,
          "old_api": "MarkCompactCollector::IsMarked(key)",
          "new_api": null,
          "old_text": "MarkCompactCollector::IsMarked(key)",
          "new_text": null,
          "old_line_content": "        if (!MarkCompactCollector::IsMarked(key)) {",
          "new_line_content": "    JSWeakCollection* weak_collection =",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": "IsEvacuationCandidate",
          "new_api": null,
          "old_text": "p->IsEvacuationCandidate()",
          "new_text": null,
          "old_line_content": "    CHECK(!p->IsEvacuationCandidate());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": "old_to_old_slots",
          "new_api": null,
          "old_text": "p->old_to_old_slots()",
          "new_text": null,
          "old_line_content": "    CHECK_NULL(p->old_to_old_slots());",
          "new_line_content": "  for (Page* p : *space) {",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": "SweepingDone",
          "new_api": null,
          "old_text": "p->SweepingDone()",
          "new_text": null,
          "old_line_content": "    CHECK(p->SweepingDone());",
          "new_line_content": "    // Invariant: Evacuation candidates are just created when marking is",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": "area_size",
          "new_api": null,
          "old_text": "p->area_size()",
          "new_text": null,
          "old_line_content": "    DCHECK(p->area_size() == area_size);",
          "new_line_content": "    // started. This means that sweeping has finished. Furthermore, at the end",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": "LiveBytesFromFreeList",
          "new_api": null,
          "old_text": "p->LiveBytesFromFreeList()",
          "new_text": null,
          "old_line_content": "    pages.push_back(std::make_pair(p->LiveBytesFromFreeList(), p));",
          "new_line_content": "    // of a GC all evacuation candidates are cleared and their slot buffers are",
          "content_same": false
        },
        {
          "line": 2716,
          "old_api": "Smi::FromInt(0)",
          "new_api": null,
          "old_text": "Smi::FromInt(0)",
          "new_text": null,
          "old_line_content": "  while (weak_collection_obj != Smi::FromInt(0)) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "size",
          "new_api": null,
          "old_text": "pages.size()",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < pages.size(); i++) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2718,
          "old_api": "reinterpret_cast<JSWeakCollection*>(weak_collection_obj)",
          "new_api": null,
          "old_text": "reinterpret_cast<JSWeakCollection*>(weak_collection_obj)",
          "new_text": null,
          "old_line_content": "        reinterpret_cast<JSWeakCollection*>(weak_collection_obj);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": "IsFlagSet",
          "new_api": null,
          "old_text": "p->IsFlagSet(MemoryChunk::FORCE_EVACUATION_CANDIDATE_FOR_TESTING)",
          "new_text": null,
          "old_line_content": "      if (p->IsFlagSet(MemoryChunk::FORCE_EVACUATION_CANDIDATE_FOR_TESTING)) {",
          "new_line_content": "  int candidate_count = 0;",
          "content_same": false
        },
        {
          "line": 2719,
          "old_api": "next",
          "new_api": null,
          "old_text": "weak_collection->next()",
          "new_text": null,
          "old_line_content": "    weak_collection_obj = weak_collection->next();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2720,
          "old_api": "undefined_value",
          "new_api": null,
          "old_text": "heap()->undefined_value()",
          "new_text": null,
          "old_line_content": "    weak_collection->set_next(heap()->undefined_value());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": "AddEvacuationCandidate",
          "new_api": null,
          "old_text": "AddEvacuationCandidate(p)",
          "new_text": null,
          "old_line_content": "        AddEvacuationCandidate(p);",
          "new_line_content": "  if (FLAG_manual_evacuation_candidates_selection) {",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "size",
          "new_api": null,
          "old_text": "pages.size()",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < pages.size(); i++) {",
          "new_line_content": "        candidate_count++;",
          "content_same": false
        },
        {
          "line": 2728,
          "old_api": "heap",
          "new_api": null,
          "old_text": "this->heap()",
          "new_text": null,
          "old_line_content": "  Heap* heap = this->heap();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2730,
          "old_api": "encountered_weak_cells",
          "new_api": null,
          "old_text": "heap->encountered_weak_cells()",
          "new_text": null,
          "old_line_content": "  Object* weak_cell_obj = heap->encountered_weak_cells();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2731,
          "old_api": "the_hole_value",
          "new_api": null,
          "old_text": "heap->the_hole_value()",
          "new_text": null,
          "old_line_content": "  Object* the_hole_value = heap->the_hole_value();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": "AddEvacuationCandidate",
          "new_api": null,
          "old_text": "AddEvacuationCandidate(p)",
          "new_text": null,
          "old_line_content": "        AddEvacuationCandidate(p);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2733,
          "old_api": "empty_fixed_array",
          "new_api": null,
          "old_text": "heap->empty_fixed_array()",
          "new_text": null,
          "old_line_content": "      DependentCode::cast(heap->empty_fixed_array());",
          "new_line_content": "void MarkCompactCollector::ClearWeakCells(Object** non_live_map_list,",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": "Smi::FromInt(0)",
          "new_api": null,
          "old_text": "Smi::FromInt(0)",
          "new_text": null,
          "old_line_content": "  Object* non_live_map_head = Smi::FromInt(0);",
          "new_line_content": "                                          DependentCode** dependent_code_list) {",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": "ComputeEvacuationHeuristics",
          "new_api": null,
          "old_text": "ComputeEvacuationHeuristics(area_size, &target_fragmentation_percent,\n                                &max_evacuated_bytes)",
          "new_text": null,
          "old_line_content": "    ComputeEvacuationHeuristics(area_size, &target_fragmentation_percent,",
          "new_line_content": "    //",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": "IsHeapObject",
          "new_api": null,
          "old_text": "cell_value->IsHeapObject()",
          "new_text": null,
          "old_line_content": "        if (cell_value->IsHeapObject() &&",
          "new_line_content": "      // Cells for new-space objects embedded in optimized code are wrapped in",
          "content_same": false
        },
        {
          "line": 2752,
          "old_api": "HeapObject::cast(cell_value)",
          "new_api": null,
          "old_text": "HeapObject::cast(cell_value)",
          "new_text": null,
          "old_line_content": "            MarkCompactCollector::IsMarked(HeapObject::cast(cell_value))) {",
          "new_line_content": "      // WeakCell and put into Heap::weak_object_to_code_table.",
          "content_same": false
        },
        {
          "line": 2754,
          "old_api": "ObjectMarking::MarkBitFrom(value)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(value)",
          "new_text": null,
          "old_line_content": "          MarkBit mark = ObjectMarking::MarkBitFrom(value);",
          "new_line_content": "      // alive as long as the cell value is alive.",
          "content_same": false
        },
        {
          "line": 2755,
          "old_api": "SetMark",
          "new_api": null,
          "old_text": "SetMark(value, mark)",
          "new_text": null,
          "old_line_content": "          SetMark(value, mark);",
          "new_line_content": "      // TODO(ulan): remove this once we remove Heap::weak_object_to_code_table.",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": "end",
          "new_api": null,
          "old_text": "pages.end()",
          "new_text": null,
          "old_line_content": "    std::sort(pages.begin(), pages.end(),",
          "new_line_content": "        target_fragmentation_percent * (area_size / 100);",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": "size",
          "new_api": null,
          "old_text": "pages.size()",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < pages.size(); i++) {",
          "new_line_content": "    // - the total size of evacuated objects does not exceed the specified",
          "content_same": false
        },
        {
          "line": 2767,
          "old_api": "dependent_code",
          "new_api": null,
          "old_text": "map->dependent_code()",
          "new_text": null,
          "old_line_content": "        DependentCode* candidate = map->dependent_code();",
          "new_line_content": "          clear_value = false;",
          "content_same": false
        },
        {
          "line": 2769,
          "old_api": "STATIC_ASSERT",
          "new_api": null,
          "old_text": "STATIC_ASSERT(DependentCode::kWeakCodeGroup == 0)",
          "new_text": null,
          "old_line_content": "        STATIC_ASSERT(DependentCode::kWeakCodeGroup == 0);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2771,
          "old_api": "group",
          "new_api": null,
          "old_text": "candidate->group()",
          "new_text": null,
          "old_line_content": "            candidate->group() == DependentCode::kWeakCodeGroup) {",
          "new_line_content": "        // The map is non-live.",
          "content_same": false
        },
        {
          "line": 728,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "isolate()",
          "new_text": null,
          "old_line_content": "        PrintIsolate(isolate(),",
          "new_line_content": "      if (FLAG_always_compact ||",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "identity",
          "new_api": null,
          "old_text": "space->identity()",
          "new_text": null,
          "old_line_content": "                     AllocationSpaceName(space->identity()), free_bytes / KB,",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2784,
          "old_api": "RecordSlot",
          "new_api": null,
          "old_text": "RecordSlot(weak_cell, slot, *slot)",
          "new_text": null,
          "old_line_content": "      RecordSlot(weak_cell, slot, *slot);",
          "new_line_content": "        non_live_map_head = weak_cell;",
          "content_same": false
        },
        {
          "line": 2788,
          "old_api": "clear",
          "new_api": null,
          "old_text": "weak_cell->clear()",
          "new_text": null,
          "old_line_content": "      weak_cell->clear();",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "DCHECK_LE",
          "new_api": null,
          "old_text": "DCHECK_LE(estimated_new_pages, candidate_count)",
          "new_text": null,
          "old_line_content": "    DCHECK_LE(estimated_new_pages, candidate_count);",
          "new_line_content": "                     free_bytes_threshold / KB, target_fragmentation_percent,",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "isolate()",
          "new_text": null,
          "old_line_content": "    PrintIsolate(isolate(),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2803,
          "old_api": "encountered_weak_cells",
          "new_api": null,
          "old_text": "heap()->encountered_weak_cells()",
          "new_text": null,
          "old_line_content": "  Object* weak_cell_obj = heap()->encountered_weak_cells();",
          "new_line_content": "  *non_live_map_list = non_live_map_head;",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": "identity",
          "new_api": null,
          "old_text": "space->identity()",
          "new_text": null,
          "old_line_content": "                 AllocationSpaceName(space->identity()), reduce_memory,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2804,
          "old_api": "Smi::FromInt(0)",
          "new_api": null,
          "old_text": "Smi::FromInt(0)",
          "new_text": null,
          "old_line_content": "  while (weak_cell_obj != Smi::FromInt(0)) {",
          "new_line_content": "  *dependent_code_list = dependent_code_head;",
          "content_same": false
        },
        {
          "line": 2805,
          "old_api": "reinterpret_cast<WeakCell*>(weak_cell_obj)",
          "new_api": null,
          "old_text": "reinterpret_cast<WeakCell*>(weak_cell_obj)",
          "new_text": null,
          "old_line_content": "    WeakCell* weak_cell = reinterpret_cast<WeakCell*>(weak_cell_obj);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2806,
          "old_api": "next",
          "new_api": null,
          "old_text": "weak_cell->next()",
          "new_text": null,
          "old_line_content": "    weak_cell_obj = weak_cell->next();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2807,
          "old_api": "clear_next",
          "new_api": null,
          "old_text": "weak_cell->clear_next(the_hole_value)",
          "new_text": null,
          "old_line_content": "    weak_cell->clear_next(the_hole_value);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": "heap",
          "new_api": null,
          "old_text": "heap()",
          "new_text": null,
          "old_line_content": "    RememberedSet<OLD_TO_OLD>::ClearAll(heap());",
          "new_line_content": "                 candidate_count, total_live_bytes / KB);",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": "ClearEvacuationCandidate",
          "new_api": null,
          "old_text": "p->ClearEvacuationCandidate()",
          "new_text": null,
          "old_line_content": "      p->ClearEvacuationCandidate();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2815,
          "old_api": "encountered_transition_arrays",
          "new_api": null,
          "old_text": "heap()->encountered_transition_arrays()",
          "new_text": null,
          "old_line_content": "  Object* obj = heap()->encountered_transition_arrays();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": "Rewind",
          "new_api": null,
          "old_text": "evacuation_candidates_.Rewind(0)",
          "new_text": null,
          "old_line_content": "    evacuation_candidates_.Rewind(0);",
          "new_line_content": "void MarkCompactCollector::AbortCompaction() {",
          "content_same": false
        },
        {
          "line": 2817,
          "old_api": "TransitionArray::cast(obj)",
          "new_api": null,
          "old_text": "TransitionArray::cast(obj)",
          "new_text": null,
          "old_line_content": "    TransitionArray* array = TransitionArray::cast(obj);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2818,
          "old_api": "next_link",
          "new_api": null,
          "old_text": "array->next_link()",
          "new_text": null,
          "old_line_content": "    obj = array->next_link();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2819,
          "old_api": "set_next_link",
          "new_api": null,
          "old_text": "array->set_next_link(undefined, SKIP_WRITE_BARRIER)",
          "new_text": null,
          "old_line_content": "    array->set_next_link(undefined, SKIP_WRITE_BARRIER);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(state_ == IDLE)",
          "new_text": null,
          "old_line_content": "  DCHECK(state_ == IDLE);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2827,
          "old_api": "reinterpret_cast<Address>(host)",
          "new_api": null,
          "old_text": "reinterpret_cast<Address>(host)",
          "new_text": null,
          "old_line_content": "  Page* source_page = Page::FromAddress(reinterpret_cast<Address>(host));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2829,
          "old_api": "host",
          "new_api": null,
          "old_text": "rinfo->host()",
          "new_text": null,
          "old_line_content": "      (rinfo->host() == NULL ||",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2830,
          "old_api": "host",
          "new_api": null,
          "old_text": "rinfo->host()",
          "new_text": null,
          "old_line_content": "       !ShouldSkipEvacuationSlotRecording(rinfo->host()))) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2831,
          "old_api": "rmode",
          "new_api": null,
          "old_text": "rinfo->rmode()",
          "new_text": null,
          "old_line_content": "    RelocInfo::Mode rmode = rinfo->rmode();",
          "new_line_content": "void MarkCompactCollector::RecordRelocSlot(Code* host, RelocInfo* rinfo,",
          "content_same": false
        },
        {
          "line": 2832,
          "old_api": "pc",
          "new_api": null,
          "old_text": "rinfo->pc()",
          "new_text": null,
          "old_line_content": "    Address addr = rinfo->pc();",
          "new_line_content": "                                           Object* target) {",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "sweeping_in_progress",
          "new_api": null,
          "old_text": "sweeping_in_progress()",
          "new_text": null,
          "old_line_content": "  if (sweeping_in_progress()) {",
          "new_line_content": "#ifdef DEBUG",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": "EnsureSweepingCompleted",
          "new_api": null,
          "old_text": "EnsureSweepingCompleted()",
          "new_text": null,
          "old_line_content": "    EnsureSweepingCompleted();",
          "new_line_content": "  state_ = PREPARE_GC;",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": "ShouldAbortIncrementalMarking",
          "new_api": null,
          "old_text": "heap_->ShouldAbortIncrementalMarking()",
          "new_text": null,
          "old_line_content": "  if (was_marked_incrementally_ && heap_->ShouldAbortIncrementalMarking()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "incremental_marking",
          "new_api": null,
          "old_text": "heap()->incremental_marking()->Stop()",
          "new_text": null,
          "old_line_content": "    heap()->incremental_marking()->Stop();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "ClearMarkbits",
          "new_api": null,
          "old_text": "ClearMarkbits()",
          "new_text": null,
          "old_line_content": "    ClearMarkbits();",
          "new_line_content": "  // If concurrent unmapping tasks are still running, we should wait for",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": "AbortWeakCollections",
          "new_api": null,
          "old_text": "AbortWeakCollections()",
          "new_text": null,
          "old_line_content": "    AbortWeakCollections();",
          "new_line_content": "  // them here.",
          "content_same": false
        },
        {
          "line": 2844,
          "old_api": "reinterpret_cast<Address>(host)",
          "new_api": null,
          "old_text": "reinterpret_cast<Address>(host)",
          "new_text": null,
          "old_line_content": "        source_page, reinterpret_cast<Address>(host), slot_type, addr);",
          "new_line_content": "        slot_type = CODE_ENTRY_SLOT;",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": "AbortTransitionArrays",
          "new_api": null,
          "old_text": "AbortTransitionArrays()",
          "new_text": null,
          "old_line_content": "    AbortTransitionArrays();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "AbortCompaction",
          "new_api": null,
          "old_text": "AbortCompaction()",
          "new_text": null,
          "old_line_content": "    AbortCompaction();",
          "new_line_content": "  // Clear marking bits if incremental marking is aborted.",
          "content_same": false
        },
        {
          "line": 2849,
          "old_api": "reinterpret_cast<Object*>(\n      base::NoBarrier_Load(reinterpret_cast<base::AtomicWord*>(slot)))",
          "new_api": null,
          "old_text": "reinterpret_cast<Object*>(\n      base::NoBarrier_Load(reinterpret_cast<base::AtomicWord*>(slot)))",
          "new_text": null,
          "old_line_content": "  Object* obj = reinterpret_cast<Object*>(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2852,
          "old_api": "IsHeapObject",
          "new_api": null,
          "old_text": "obj->IsHeapObject()",
          "new_text": null,
          "old_line_content": "  if (obj->IsHeapObject()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2853,
          "old_api": "HeapObject::cast(obj)",
          "new_api": null,
          "old_text": "HeapObject::cast(obj)",
          "new_text": null,
          "old_line_content": "    HeapObject* heap_obj = HeapObject::cast(obj);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2854,
          "old_api": "map_word",
          "new_api": null,
          "old_text": "heap_obj->map_word()",
          "new_text": null,
          "old_line_content": "    MapWord map_word = heap_obj->map_word();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2855,
          "old_api": "IsForwardingAddress",
          "new_api": null,
          "old_text": "map_word.IsForwardingAddress()",
          "new_text": null,
          "old_line_content": "    if (map_word.IsForwardingAddress()) {",
          "new_line_content": "static inline SlotCallbackResult UpdateSlot(Object** slot) {",
          "content_same": false
        },
        {
          "line": 2858,
          "old_api": "address",
          "new_api": null,
          "old_text": "heap_obj->address()",
          "new_text": null,
          "old_line_content": "             Page::FromAddress(heap_obj->address())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": "UsingEmbedderHeapTracer",
          "new_api": null,
          "old_text": "UsingEmbedderHeapTracer()",
          "new_text": null,
          "old_line_content": "  if (UsingEmbedderHeapTracer()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "EnterFinalPause",
          "new_api": null,
          "old_text": "embedder_heap_tracer()->EnterFinalPause()",
          "new_text": null,
          "old_line_content": "    embedder_heap_tracer()->EnterFinalPause();",
          "new_line_content": "  if (!was_marked_incrementally_) {",
          "content_same": false
        },
        {
          "line": 2866,
          "old_api": "MarkCompactCollector::IsOnEvacuationCandidate(target)",
          "new_api": null,
          "old_text": "MarkCompactCollector::IsOnEvacuationCandidate(target)",
          "new_text": null,
          "old_line_content": "             !MarkCompactCollector::IsOnEvacuationCandidate(target));",
          "new_line_content": "                 ->IsFlagSet(Page::COMPACTION_WAS_ABORTED));",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": "next",
          "new_api": null,
          "old_text": "spaces.next()",
          "new_text": null,
          "old_line_content": "  for (PagedSpace* space = spaces.next(); space != NULL;",
          "new_line_content": "  // Don't start compaction if we are in the middle of incremental",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "next",
          "new_api": null,
          "old_text": "spaces.next()",
          "new_text": null,
          "old_line_content": "       space = spaces.next()) {",
          "new_line_content": "  // marking cycle. We did not collect any slots.",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": "PrepareForMarkCompact",
          "new_api": null,
          "old_text": "space->PrepareForMarkCompact()",
          "new_text": null,
          "old_line_content": "    space->PrepareForMarkCompact();",
          "new_line_content": "  if (!FLAG_never_compact && !was_marked_incrementally_) {",
          "content_same": false
        },
        {
          "line": 2876,
          "old_api": "UpdateSlot",
          "new_api": null,
          "old_text": "UpdateSlot(p)",
          "new_text": null,
          "old_line_content": "  void VisitPointer(Object** p) override { UpdateSlot(p); }",
          "new_line_content": "  return REMOVE_SLOT;",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "account_external_memory_concurrently_freed",
          "new_api": null,
          "old_text": "heap()->account_external_memory_concurrently_freed()",
          "new_text": null,
          "old_line_content": "  heap()->account_external_memory_concurrently_freed();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2879,
          "old_api": "UpdateSlot",
          "new_api": null,
          "old_text": "UpdateSlot(p)",
          "new_text": null,
          "old_line_content": "    for (Object** p = start; p < end; p++) UpdateSlot(p);",
          "new_line_content": "// Visitor for updating pointers from live objects in old spaces to new space.",
          "content_same": false
        },
        {
          "line": 2887,
          "old_api": "UpdateTypedSlotHelper::UpdateEmbeddedPointer(rinfo, UpdateSlot)",
          "new_api": null,
          "old_text": "UpdateTypedSlotHelper::UpdateEmbeddedPointer(rinfo, UpdateSlot)",
          "new_text": null,
          "old_line_content": "    UpdateTypedSlotHelper::UpdateEmbeddedPointer(rinfo, UpdateSlot);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "contains_late_pages",
          "new_api": null,
          "old_text": "sweeper().contains_late_pages()",
          "new_text": null,
          "old_line_content": "  if (sweeper().contains_late_pages() && FLAG_concurrent_sweeping) {",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 2891,
          "old_api": "UpdateTypedSlotHelper::UpdateCodeTarget(rinfo, UpdateSlot)",
          "new_api": null,
          "old_text": "UpdateTypedSlotHelper::UpdateCodeTarget(rinfo, UpdateSlot)",
          "new_text": null,
          "old_line_content": "    UpdateTypedSlotHelper::UpdateCodeTarget(rinfo, UpdateSlot);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": "StartSweepingHelper",
          "new_api": null,
          "old_text": "sweeper().StartSweepingHelper(OLD_SPACE)",
          "new_text": null,
          "old_line_content": "    sweeper().StartSweepingHelper(OLD_SPACE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2895,
          "old_api": "UpdateTypedSlotHelper::UpdateCodeEntry(entry_address, UpdateSlot)",
          "new_api": null,
          "old_text": "UpdateTypedSlotHelper::UpdateCodeEntry(entry_address, UpdateSlot)",
          "new_text": null,
          "old_line_content": "    UpdateTypedSlotHelper::UpdateCodeEntry(entry_address, UpdateSlot);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap()->isolate()->factory()->undefined_value()",
          "new_text": null,
          "old_line_content": "      heap()->isolate()->factory()->undefined_value());",
          "new_line_content": "    // If we added some more pages during MC, we need to start at least one",
          "content_same": false
        },
        {
          "line": 2899,
          "old_api": "UpdateTypedSlotHelper::UpdateDebugTarget(rinfo, UpdateSlot)",
          "new_api": null,
          "old_text": "UpdateTypedSlotHelper::UpdateDebugTarget(rinfo, UpdateSlot)",
          "new_text": null,
          "old_line_content": "    UpdateTypedSlotHelper::UpdateDebugTarget(rinfo, UpdateSlot);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 853,
          "old_api": "lo_space",
          "new_api": null,
          "old_text": "heap_->lo_space()->ClearMarkingStateOfLiveObjects()",
          "new_text": null,
          "old_line_content": "  heap_->lo_space()->ClearMarkingStateOfLiveObjects();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2905,
          "old_api": "map_word",
          "new_api": null,
          "old_text": "HeapObject::cast(*p)->map_word()",
          "new_text": null,
          "old_line_content": "  MapWord map_word = HeapObject::cast(*p)->map_word();",
          "new_line_content": "  void VisitDebugTarget(RelocInfo* rinfo) override {",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap_->isolate()->inner_pointer_to_code_cache()->Flush()",
          "new_text": null,
          "old_line_content": "  heap_->isolate()->inner_pointer_to_code_cache()->Flush();",
          "new_line_content": "  // Clear the marking state of live large objects.",
          "content_same": false
        },
        {
          "line": 2907,
          "old_api": "IsForwardingAddress",
          "new_api": null,
          "old_text": "map_word.IsForwardingAddress()",
          "new_text": null,
          "old_line_content": "  if (map_word.IsForwardingAddress()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2908,
          "old_api": "ToForwardingAddress",
          "new_api": null,
          "old_text": "map_word.ToForwardingAddress()",
          "new_text": null,
          "old_line_content": "    return String::cast(map_word.ToForwardingAddress());",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 2911,
          "old_api": "String::cast(*p)",
          "new_api": null,
          "old_text": "String::cast(*p)",
          "new_text": null,
          "old_line_content": "  return String::cast(*p);",
          "new_line_content": "                                                         Object** p) {",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "load_stub_cache",
          "new_api": null,
          "old_text": "isolate()->load_stub_cache()->Clear()",
          "new_text": null,
          "old_line_content": "  isolate()->load_stub_cache()->Clear();",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 2916,
          "old_api": "lo_space",
          "new_api": null,
          "old_text": "heap_->lo_space()",
          "new_text": null,
          "old_line_content": "  DCHECK(owner != heap_->lo_space() && owner != nullptr);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2917,
          "old_api": "USE",
          "new_api": null,
          "old_text": "USE(owner)",
          "new_text": null,
          "old_line_content": "  USE(owner);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "isolate()",
          "new_text": null,
          "old_line_content": "    Deoptimizer::DeoptimizeMarkedCode(isolate());",
          "new_line_content": "  // GC, because it relies on the new address of certain old space",
          "content_same": false
        },
        {
          "line": 2920,
          "old_api": "ObjectMarking::MarkBitFrom(slot)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(slot)",
          "new_text": null,
          "old_line_content": "  if (Marking::IsBlackOrGrey(ObjectMarking::MarkBitFrom(slot))) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "incremental_marking",
          "new_api": null,
          "old_text": "heap_->incremental_marking()->ClearIdleMarkingDelayCounter()",
          "new_text": null,
          "old_line_content": "  heap_->incremental_marking()->ClearIdleMarkingDelayCounter();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2926,
          "old_api": "Bitmap::IndexInCell(mark_bit_index)",
          "new_api": null,
          "old_text": "Bitmap::IndexInCell(mark_bit_index)",
          "new_text": null,
          "old_line_content": "  MarkBit::CellType index_mask = 1u << Bitmap::IndexInCell(mark_bit_index);",
          "new_line_content": "  // We may be part of a black area.",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(marking_parity_ == ODD_MARKING_PARITY)",
          "new_text": null,
          "old_line_content": "    DCHECK(marking_parity_ == ODD_MARKING_PARITY);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2928,
          "old_api": "area_start",
          "new_api": null,
          "old_text": "p->area_start()",
          "new_text": null,
          "old_line_content": "  Address base_address = p->area_start();",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 2929,
          "old_api": "AddressToMarkbitIndex",
          "new_api": null,
          "old_text": "Bitmap::IndexToCell(\n      Bitmap::CellAlignIndex(p->AddressToMarkbitIndex(base_address)))",
          "new_text": null,
          "old_line_content": "  unsigned int base_address_cell_index = Bitmap::IndexToCell(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2930,
          "old_api": "AddressToMarkbitIndex",
          "new_api": null,
          "old_text": "p->AddressToMarkbitIndex(base_address)",
          "new_text": null,
          "old_line_content": "      Bitmap::CellAlignIndex(p->AddressToMarkbitIndex(base_address)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2942,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(cell_index != base_address_cell_index)",
          "new_text": null,
          "old_line_content": "    DCHECK(cell_index != base_address_cell_index);",
          "new_line_content": "  if (index_mask > 1) {",
          "content_same": false
        },
        {
          "line": 2952,
          "old_api": "base::bits::CountTrailingZeros32(cells[cell_index])",
          "new_api": null,
          "old_text": "base::bits::CountTrailingZeros32(cells[cell_index])",
          "new_text": null,
          "old_line_content": "      (base::bits::CountTrailingZeros32(cells[cell_index]) >",
          "new_line_content": "      return false;",
          "content_same": false
        },
        {
          "line": 2953,
          "old_api": "base::bits::CountTrailingZeros32(cells[cell_index] | index_mask)",
          "new_api": null,
          "old_text": "base::bits::CountTrailingZeros32(cells[cell_index] | index_mask)",
          "new_text": null,
          "old_line_content": "       base::bits::CountTrailingZeros32(cells[cell_index] | index_mask))) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": "builtins",
          "new_api": null,
          "old_text": "isolate_->builtins()->builtin(Builtins::kCompileLazy)",
          "new_text": null,
          "old_line_content": "  Code* lazy_compile = isolate_->builtins()->builtin(Builtins::kCompileLazy);",
          "new_line_content": "// have been reached and marked but their children have not been visited yet.",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": "heap",
          "new_api": null,
          "old_text": "isolate_->heap()->undefined_value()",
          "new_text": null,
          "old_line_content": "  Object* undefined = isolate_->heap()->undefined_value();",
          "new_line_content": "// After emptying the marking stack, we clear the overflow flag and traverse",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "GetNextCandidate",
          "new_api": null,
          "old_text": "GetNextCandidate(candidate)",
          "new_text": null,
          "old_line_content": "    next_candidate = GetNextCandidate(candidate);",
          "new_line_content": "void CodeFlusher::ProcessJSFunctionCandidates() {",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": "shared",
          "new_api": null,
          "old_text": "candidate->shared()",
          "new_text": null,
          "old_line_content": "    SharedFunctionInfo* shared = candidate->shared();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": "code",
          "new_api": null,
          "old_text": "shared->code()",
          "new_text": null,
          "old_line_content": "    Code* code = shared->code();",
          "new_line_content": "  JSFunction* next_candidate;",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "ObjectMarking::MarkBitFrom(code)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(code)",
          "new_text": null,
          "old_line_content": "    MarkBit code_mark = ObjectMarking::MarkBitFrom(code);",
          "new_line_content": "  while (candidate != NULL) {",
          "content_same": false
        },
        {
          "line": 2976,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(current_cell != 0)",
          "new_text": null,
          "old_line_content": "  CHECK(current_cell != 0);",
          "new_line_content": "    slot_mask = ~0u;",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": "PrintF",
          "new_api": null,
          "old_text": "PrintF(\"[code-flushing clears: \")",
          "new_text": null,
          "old_line_content": "        PrintF(\"[code-flushing clears: \");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "GetAge",
          "new_api": null,
          "old_text": "code->GetAge()",
          "new_text": null,
          "old_line_content": "        PrintF(\" - age: %d]\\n\", code->GetAge());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2980,
          "old_api": "base::bits::CountLeadingZeros32(current_cell & slot_mask)",
          "new_api": null,
          "old_text": "base::bits::CountLeadingZeros32(current_cell & slot_mask)",
          "new_text": null,
          "old_line_content": "      base::bits::CountLeadingZeros32(current_cell & slot_mask);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2981,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(leading_zeros != Bitmap::kBitsPerCell)",
          "new_text": null,
          "old_line_content": "  CHECK(leading_zeros != Bitmap::kBitsPerCell);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2982,
          "old_api": "static_cast<int>(Bitmap::kBitIndexMask - leading_zeros)",
          "new_api": null,
          "old_text": "static_cast<int>(Bitmap::kBitIndexMask - leading_zeros)",
          "new_text": null,
          "old_line_content": "  int offset = static_cast<int>(Bitmap::kBitIndexMask - leading_zeros) - 1;",
          "new_line_content": "  MarkBit::CellType current_cell = cells[cell_index];",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "Marking::IsBlack(code_mark)",
          "new_api": null,
          "old_text": "Marking::IsBlack(code_mark)",
          "new_text": null,
          "old_line_content": "      DCHECK(Marking::IsBlack(code_mark));",
          "new_line_content": "      // Always flush the optimized code map if there is one.",
          "content_same": false
        },
        {
          "line": 2990,
          "old_api": "address",
          "new_api": null,
          "old_text": "object->address()",
          "new_text": null,
          "old_line_content": "  if ((object->address() + kPointerSize) <= slot &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2991,
          "old_api": "Size",
          "new_api": null,
          "old_text": "object->Size()",
          "new_text": null,
          "old_line_content": "      (object->address() + object->Size()) > slot) {",
          "new_line_content": "  base_address += (cell_index - base_address_cell_index) *",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": "address",
          "new_api": null,
          "old_text": "candidate->address()",
          "new_text": null,
          "old_line_content": "    Address slot = candidate->address() + JSFunction::kCodeEntryOffset;",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": "HeapObject::RawField(shared, SharedFunctionInfo::kCodeOffset)",
          "new_api": null,
          "old_text": "HeapObject::RawField(shared, SharedFunctionInfo::kCodeOffset)",
          "new_text": null,
          "old_line_content": "        HeapObject::RawField(shared, SharedFunctionInfo::kCodeOffset);",
          "new_line_content": "    // setter did not record the slot update and we have to do that manually.",
          "content_same": false
        },
        {
          "line": 3002,
          "old_api": "Page::FromAddress(slot)",
          "new_api": null,
          "old_text": "Page::FromAddress(slot)",
          "new_text": null,
          "old_line_content": "  Page* p = Page::FromAddress(slot);",
          "new_line_content": "    // This can happen when we move the object header while left trimming.",
          "content_same": false
        },
        {
          "line": 3003,
          "old_api": "owner",
          "new_api": null,
          "old_text": "p->owner()",
          "new_text": null,
          "old_line_content": "  Space* owner = p->owner();",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 3004,
          "old_api": "lo_space",
          "new_api": null,
          "old_text": "heap_->lo_space()",
          "new_text": null,
          "old_line_content": "  if (owner == heap_->lo_space() || owner == nullptr) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3005,
          "old_api": "lo_space",
          "new_api": null,
          "old_text": "heap_->lo_space()->FindObject(slot)",
          "new_text": null,
          "old_line_content": "    Object* large_object = heap_->lo_space()->FindObject(slot);",
          "new_line_content": "  return false;",
          "content_same": false
        },
        {
          "line": 3008,
          "old_api": "IsHeapObject",
          "new_api": null,
          "old_text": "large_object->IsHeapObject()",
          "new_text": null,
          "old_line_content": "    CHECK(large_object->IsHeapObject());",
          "new_line_content": "HeapObject* MarkCompactCollector::FindBlackObjectBySlotSlow(Address slot) {",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": "builtins",
          "new_api": null,
          "old_text": "isolate_->builtins()->builtin(Builtins::kCompileLazy)",
          "new_text": null,
          "old_line_content": "  Code* lazy_compile = isolate_->builtins()->builtin(Builtins::kCompileLazy);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": "GetNextCandidate",
          "new_api": null,
          "old_text": "GetNextCandidate(candidate)",
          "new_text": null,
          "old_line_content": "    next_candidate = GetNextCandidate(candidate);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": "ClearNextCandidate",
          "new_api": null,
          "old_text": "ClearNextCandidate(candidate)",
          "new_text": null,
          "old_line_content": "    ClearNextCandidate(candidate);",
          "new_line_content": "void CodeFlusher::ProcessSharedFunctionInfoCandidates() {",
          "content_same": false
        },
        {
          "line": 3019,
          "old_api": "Next",
          "new_api": null,
          "old_text": "it.Next()",
          "new_text": null,
          "old_line_content": "  while ((object = it.Next()) != nullptr) {",
          "new_line_content": "      return large_heap_object;",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": "code",
          "new_api": null,
          "old_text": "candidate->code()",
          "new_text": null,
          "old_line_content": "    Code* code = candidate->code();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 973,
          "old_api": "ObjectMarking::MarkBitFrom(code)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(code)",
          "new_text": null,
          "old_line_content": "    MarkBit code_mark = ObjectMarking::MarkBitFrom(code);",
          "new_line_content": "  SharedFunctionInfo* candidate = shared_function_info_candidates_head_;",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": "Marking::IsWhite(code_mark)",
          "new_api": null,
          "old_text": "Marking::IsWhite(code_mark)",
          "new_text": null,
          "old_line_content": "    if (Marking::IsWhite(code_mark)) {",
          "new_line_content": "  SharedFunctionInfo* next_candidate;",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": "is_compiled",
          "new_api": null,
          "old_text": "candidate->is_compiled()",
          "new_text": null,
          "old_line_content": "      if (FLAG_trace_code_flushing && candidate->is_compiled()) {",
          "new_line_content": "  while (candidate != NULL) {",
          "content_same": false
        },
        {
          "line": 3020,
          "old_api": "Size",
          "new_api": null,
          "old_text": "object->Size()",
          "new_text": null,
          "old_line_content": "    int size = object->Size();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3021,
          "old_api": "address",
          "new_api": null,
          "old_text": "object->address()",
          "new_text": null,
          "old_line_content": "    if (object->address() > slot) return nullptr;",
          "new_line_content": "    return nullptr;",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "GetAge",
          "new_api": null,
          "old_text": "code->GetAge()",
          "new_text": null,
          "old_line_content": "        PrintF(\" - age: %d]\\n\", code->GetAge());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3022,
          "old_api": "address",
          "new_api": null,
          "old_text": "object->address()",
          "new_text": null,
          "old_line_content": "    if (object->address() <= slot && slot < (object->address() + size)) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3032,
          "old_api": "new_space",
          "new_api": null,
          "old_text": "heap()->new_space()",
          "new_text": null,
          "old_line_content": "  NewSpace* new_space = heap()->new_space();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3034,
          "old_api": "top",
          "new_api": null,
          "old_text": "new_space->top()",
          "new_text": null,
          "old_line_content": "  for (Page* p : NewSpacePageRange(new_space->bottom(), new_space->top())) {",
          "new_line_content": "  return nullptr;",
          "content_same": false
        },
        {
          "line": 3035,
          "old_api": "Add",
          "new_api": null,
          "old_text": "newspace_evacuation_candidates_.Add(p)",
          "new_text": null,
          "old_line_content": "    newspace_evacuation_candidates_.Add(p);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3037,
          "old_api": "Flip",
          "new_api": null,
          "old_text": "new_space->Flip()",
          "new_text": null,
          "old_line_content": "  new_space->Flip();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3038,
          "old_api": "ResetAllocationInfo",
          "new_api": null,
          "old_text": "new_space->ResetAllocationInfo()",
          "new_text": null,
          "old_line_content": "  new_space->ResetAllocationInfo();",
          "new_line_content": "void MarkCompactCollector::EvacuateNewSpacePrologue() {",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "heap",
          "new_api": null,
          "old_text": "isolate_->heap()->incremental_marking()->IterateBlackObject(shared_info)",
          "new_text": null,
          "old_line_content": "  isolate_->heap()->incremental_marking()->IterateBlackObject(shared_info);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": "PrintF",
          "new_api": null,
          "old_text": "PrintF(\"[code-flushing abandons function-info: \")",
          "new_text": null,
          "old_line_content": "    PrintF(\"[code-flushing abandons function-info: \");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": "ShortPrint",
          "new_api": null,
          "old_text": "shared_info->ShortPrint()",
          "new_text": null,
          "old_line_content": "    shared_info->ShortPrint();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": "PrintF",
          "new_api": null,
          "old_text": "PrintF(\"]\\n\")",
          "new_text": null,
          "old_line_content": "    PrintF(\"]\\n\");",
          "new_line_content": "void CodeFlusher::EvictCandidate(SharedFunctionInfo* shared_info) {",
          "content_same": false
        },
        {
          "line": 3052,
          "old_api": "IsFlagSet",
          "new_api": null,
          "old_text": "chunk->IsFlagSet(MemoryChunk::PAGE_NEW_OLD_PROMOTION)",
          "new_text": null,
          "old_line_content": "    if (chunk->IsFlagSet(MemoryChunk::PAGE_NEW_OLD_PROMOTION))",
          "new_line_content": "    kPageNewToOld,",
          "content_same": false
        },
        {
          "line": 3054,
          "old_api": "IsFlagSet",
          "new_api": null,
          "old_text": "chunk->IsFlagSet(MemoryChunk::PAGE_NEW_NEW_PROMOTION)",
          "new_text": null,
          "old_line_content": "    if (chunk->IsFlagSet(MemoryChunk::PAGE_NEW_NEW_PROMOTION))",
          "new_line_content": "    kPageNewToNew,",
          "content_same": false
        },
        {
          "line": 3056,
          "old_api": "InNewSpace",
          "new_api": null,
          "old_text": "chunk->InNewSpace()",
          "new_text": null,
          "old_line_content": "    if (chunk->InNewSpace()) return kObjectsNewToOld;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3057,
          "old_api": "IsEvacuationCandidate",
          "new_api": null,
          "old_text": "chunk->IsEvacuationCandidate()",
          "new_text": null,
          "old_line_content": "    DCHECK(chunk->IsEvacuationCandidate());",
          "new_line_content": "  static inline EvacuationMode ComputeEvacuationMode(MemoryChunk* chunk) {",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": "ClearNextCandidate",
          "new_api": null,
          "old_text": "ClearNextCandidate(shared_info)",
          "new_text": null,
          "old_line_content": "    ClearNextCandidate(shared_info);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": "GetNextCandidate",
          "new_api": null,
          "old_text": "GetNextCandidate(candidate)",
          "new_text": null,
          "old_line_content": "      next_candidate = GetNextCandidate(candidate);",
          "new_line_content": "  SharedFunctionInfo* next_candidate;",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "GetNextCandidate",
          "new_api": null,
          "old_text": "GetNextCandidate(shared_info)",
          "new_text": null,
          "old_line_content": "        next_candidate = GetNextCandidate(shared_info);",
          "new_line_content": "    shared_function_info_candidates_head_ = next_candidate;",
          "content_same": false
        },
        {
          "line": 3069,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit Evacuator(MarkCompactCollector* collector)",
          "new_line_content": "  // evacuation.",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": "ClearNextCandidate",
          "new_api": null,
          "old_text": "ClearNextCandidate(shared_info)",
          "new_text": null,
          "old_line_content": "        ClearNextCandidate(shared_info);",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 3071,
          "old_api": "heap",
          "new_api": null,
          "old_text": "collector->heap()",
          "new_text": null,
          "old_line_content": "        compaction_spaces_(collector->heap()),",
          "new_line_content": "    if (FLAG_page_promotion)",
          "content_same": false
        },
        {
          "line": 3074,
          "old_api": "heap",
          "new_api": null,
          "old_text": "collector->heap()",
          "new_text": null,
          "old_line_content": "        new_space_visitor_(collector->heap(), &compaction_spaces_,",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3077,
          "old_api": "heap",
          "new_api": null,
          "old_text": "collector->heap()",
          "new_text": null,
          "old_line_content": "        old_space_visitor_(collector->heap(), &compaction_spaces_),",
          "new_line_content": "      : collector_(collector),",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": "next_function_link",
          "new_api": null,
          "old_text": "function->next_function_link()->IsUndefined(isolate_)",
          "new_text": null,
          "old_line_content": "  DCHECK(!function->next_function_link()->IsUndefined(isolate_));",
          "new_line_content": "      candidate = next_candidate;",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": "heap",
          "new_api": null,
          "old_text": "isolate_->heap()->undefined_value()",
          "new_text": null,
          "old_line_content": "  Object* undefined = isolate_->heap()->undefined_value();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": "heap",
          "new_api": null,
          "old_text": "isolate_->heap()->incremental_marking()->IterateBlackObject(function)",
          "new_text": null,
          "old_line_content": "  isolate_->heap()->incremental_marking()->IterateBlackObject(function);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "heap",
          "new_api": null,
          "old_text": "isolate_->heap()->incremental_marking()->IterateBlackObject(\n      function->shared())",
          "new_text": null,
          "old_line_content": "  isolate_->heap()->incremental_marking()->IterateBlackObject(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": "shared",
          "new_api": null,
          "old_text": "function->shared()",
          "new_text": null,
          "old_line_content": "      function->shared());",
          "new_line_content": "void CodeFlusher::EvictCandidate(JSFunction* function) {",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": "PrintF",
          "new_api": null,
          "old_text": "PrintF(\"[code-flushing abandons closure: \")",
          "new_text": null,
          "old_line_content": "    PrintF(\"[code-flushing abandons closure: \");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": "shared",
          "new_api": null,
          "old_text": "function->shared()->ShortPrint()",
          "new_text": null,
          "old_line_content": "    function->shared()->ShortPrint();",
          "new_line_content": "  // Make sure previous flushing decisions are revisited.",
          "content_same": false
        },
        {
          "line": 3092,
          "old_api": "heap",
          "new_api": null,
          "old_text": "collector_->heap()",
          "new_text": null,
          "old_line_content": "  inline Heap* heap() { return collector_->heap(); }",
          "new_line_content": "  inline void Finalize();",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": "ClearNextCandidate",
          "new_api": null,
          "old_text": "ClearNextCandidate(function, undefined)",
          "new_text": null,
          "old_line_content": "    ClearNextCandidate(function, undefined);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": "GetNextCandidate",
          "new_api": null,
          "old_text": "GetNextCandidate(candidate)",
          "new_text": null,
          "old_line_content": "      next_candidate = GetNextCandidate(candidate);",
          "new_line_content": "  JSFunction* next_candidate;",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": "GetNextCandidate",
          "new_api": null,
          "old_text": "GetNextCandidate(function)",
          "new_text": null,
          "old_line_content": "        next_candidate = GetNextCandidate(function);",
          "new_line_content": "    jsfunction_candidates_head_ = next_candidate;",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": "ClearNextCandidate",
          "new_api": null,
          "old_text": "ClearNextCandidate(function, undefined)",
          "new_text": null,
          "old_line_content": "        ClearNextCandidate(function, undefined);",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 3117,
          "old_api": "SweepingDone",
          "new_api": null,
          "old_text": "page->SweepingDone()",
          "new_text": null,
          "old_line_content": "  DCHECK(page->SweepingDone());",
          "new_line_content": "  // Book keeping info.",
          "content_same": false
        },
        {
          "line": 3118,
          "old_api": "LiveBytes",
          "new_api": null,
          "old_text": "page->LiveBytes()",
          "new_text": null,
          "old_line_content": "  int saved_live_bytes = page->LiveBytes();",
          "new_line_content": "  double duration_;",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": "heap",
          "new_api": null,
          "old_text": "isolate_->heap()",
          "new_text": null,
          "old_line_content": "  Heap* heap = isolate_->heap();",
          "new_line_content": "      candidate = next_candidate;",
          "content_same": false
        },
        {
          "line": 3120,
          "old_api": "heap",
          "new_api": null,
          "old_text": "page->heap()",
          "new_text": null,
          "old_line_content": "  Heap* heap = page->heap();",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 3122,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap->isolate()",
          "new_text": null,
          "old_line_content": "    AlwaysAllocateScope always_allocate(heap->isolate());",
          "new_line_content": "bool MarkCompactCollector::Evacuator::EvacuatePage(Page* page) {",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": "InFromSpace",
          "new_api": null,
          "old_text": "heap->InFromSpace(candidate)",
          "new_text": null,
          "old_line_content": "    if (heap->InFromSpace(candidate)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": "reinterpret_cast<Object**>(slot)",
          "new_api": null,
          "old_text": "reinterpret_cast<Object**>(slot)",
          "new_text": null,
          "old_line_content": "      v->VisitPointer(reinterpret_cast<Object**>(slot));",
          "new_line_content": "void CodeFlusher::IteratePointersToFromSpace(ObjectVisitor* v) {",
          "content_same": false
        },
        {
          "line": 3126,
          "old_api": "VisitLiveObjects",
          "new_api": null,
          "old_text": "collector_->VisitLiveObjects(page, &new_space_visitor_,\n                                               kClearMarkbits)",
          "new_text": null,
          "old_line_content": "        success = collector_->VisitLiveObjects(page, &new_space_visitor_,",
          "new_line_content": "  double evacuation_time = 0.0;",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": "GetNextCandidate",
          "new_api": null,
          "old_text": "GetNextCandidate(*slot)",
          "new_text": null,
          "old_line_content": "    candidate = GetNextCandidate(*slot);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "GetNextCandidateSlot",
          "new_api": null,
          "old_text": "GetNextCandidateSlot(*slot)",
          "new_text": null,
          "old_line_content": "    slot = GetNextCandidateSlot(*slot);",
          "new_line_content": "  JSFunction** slot = &jsfunction_candidates_head_;",
          "content_same": false
        },
        {
          "line": 3128,
          "old_api": "ArrayBufferTracker::ProcessBuffers(\n            page, ArrayBufferTracker::kUpdateForwardedRemoveOthers)",
          "new_api": null,
          "old_text": "ArrayBufferTracker::ProcessBuffers(\n            page, ArrayBufferTracker::kUpdateForwardedRemoveOthers)",
          "new_text": null,
          "old_line_content": "        ArrayBufferTracker::ProcessBuffers(",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 3130,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(success)",
          "new_text": null,
          "old_line_content": "        DCHECK(success);",
          "new_line_content": "    TimedScope timed_scope(&evacuation_time);",
          "content_same": false
        },
        {
          "line": 3136,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(success)",
          "new_text": null,
          "old_line_content": "        DCHECK(success);",
          "new_line_content": "            page, ArrayBufferTracker::kUpdateForwardedRemoveOthers);",
          "content_same": false
        },
        {
          "line": 1091,
          "old_api": "mark_compact_collector",
          "new_api": null,
          "old_text": "heap->mark_compact_collector()",
          "new_text": null,
          "old_line_content": "    MarkObjectByPointer(heap->mark_compact_collector(), object, p);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3139,
          "old_api": "LiveBytes",
          "new_api": null,
          "old_text": "page->LiveBytes()",
          "new_text": null,
          "old_line_content": "        new_space_page_visitor.account_semispace_copied(page->LiveBytes());",
          "new_line_content": "      case kPageNewToOld:",
          "content_same": false
        },
        {
          "line": 3144,
          "old_api": "VisitLiveObjects",
          "new_api": null,
          "old_text": "collector_->VisitLiveObjects(page, &old_space_visitor_,\n                                               kClearMarkbits)",
          "new_text": null,
          "old_line_content": "        success = collector_->VisitLiveObjects(page, &old_space_visitor_,",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": "VisitUnmarkedObjects",
          "new_api": null,
          "old_text": "VisitUnmarkedObjects(heap, object, start, end)",
          "new_text": null,
          "old_line_content": "      if (VisitUnmarkedObjects(heap, object, start, end)) return;",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": "mark_compact_collector",
          "new_api": null,
          "old_text": "heap->mark_compact_collector()",
          "new_text": null,
          "old_line_content": "    MarkCompactCollector* collector = heap->mark_compact_collector();",
          "new_line_content": "                                   Object** start, Object** end)) {",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": "MarkObjectByPointer",
          "new_api": null,
          "old_text": "MarkObjectByPointer(collector, object, p)",
          "new_text": null,
          "old_line_content": "      MarkObjectByPointer(collector, object, p);",
          "new_line_content": "    const int kMinRangeForMarkingRecursion = 64;",
          "content_same": false
        },
        {
          "line": 3152,
          "old_api": "heap",
          "new_api": null,
          "old_text": "collector_->heap()",
          "new_text": null,
          "old_line_content": "          EvacuateRecordOnlyVisitor record_visitor(collector_->heap());",
          "new_line_content": "                                               kClearMarkbits);",
          "content_same": false
        },
        {
          "line": 3154,
          "old_api": "VisitLiveObjects",
          "new_api": null,
          "old_text": "collector_->VisitLiveObjects(page, &record_visitor, kKeepMarking)",
          "new_text": null,
          "old_line_content": "              collector_->VisitLiveObjects(page, &record_visitor, kKeepMarking);",
          "new_line_content": "          // Aborted compaction page. We have to record slots here, since we",
          "content_same": false
        },
        {
          "line": 3155,
          "old_api": "ArrayBufferTracker::ProcessBuffers(\n              page, ArrayBufferTracker::kUpdateForwardedKeepOthers)",
          "new_api": null,
          "old_text": "ArrayBufferTracker::ProcessBuffers(\n              page, ArrayBufferTracker::kUpdateForwardedKeepOthers)",
          "new_text": null,
          "old_line_content": "          ArrayBufferTracker::ProcessBuffers(",
          "new_line_content": "          // might not have recorded them in first place.",
          "content_same": false
        },
        {
          "line": 3157,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(success)",
          "new_text": null,
          "old_line_content": "          DCHECK(success);",
          "new_line_content": "          // for code objects in |RecordMigratedSlotVisitor|.",
          "content_same": false
        },
        {
          "line": 1110,
          "old_api": "ObjectMarking::MarkBitFrom(object)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(object)",
          "new_text": null,
          "old_line_content": "    MarkBit mark = ObjectMarking::MarkBitFrom(object);",
          "new_line_content": "    for (Object** p = start; p < end; p++) {",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": "mark_compact_collector",
          "new_api": null,
          "old_text": "heap->mark_compact_collector()->SetMark(object, mark_bit)",
          "new_text": null,
          "old_line_content": "      heap->mark_compact_collector()->SetMark(object, mark_bit);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3167,
          "old_api": "UNREACHABLE",
          "new_api": null,
          "old_text": "UNREACHABLE()",
          "new_text": null,
          "old_line_content": "        UNREACHABLE();",
          "new_line_content": "          success = false;",
          "content_same": false
        },
        {
          "line": 3170,
          "old_api": "ReportCompactionProgress",
          "new_api": null,
          "old_text": "ReportCompactionProgress(evacuation_time, saved_live_bytes)",
          "new_text": null,
          "old_line_content": "  ReportCompactionProgress(evacuation_time, saved_live_bytes);",
          "new_line_content": "              page, ArrayBufferTracker::kUpdateForwardedRemoveOthers);",
          "content_same": false
        },
        {
          "line": 3172,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap->isolate()",
          "new_text": null,
          "old_line_content": "    PrintIsolate(heap->isolate(),",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": "IsHeapObject",
          "new_api": null,
          "old_text": "*p)->IsHeapObject()",
          "new_text": null,
          "old_line_content": "    if (!(*p)->IsHeapObject()) return;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": "HeapObject::cast(*p)",
          "new_api": null,
          "old_text": "HeapObject::cast(*p)",
          "new_text": null,
          "old_line_content": "    HeapObject* target_object = HeapObject::cast(*p);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": "RecordSlot",
          "new_api": null,
          "old_text": "collector->RecordSlot(object, p, target_object)",
          "new_text": null,
          "old_line_content": "    collector->RecordSlot(object, p, target_object);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": "ObjectMarking::MarkBitFrom(target_object)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(target_object)",
          "new_text": null,
          "old_line_content": "    MarkBit mark = ObjectMarking::MarkBitFrom(target_object);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": "MarkObject",
          "new_api": null,
          "old_text": "collector->MarkObject(target_object, mark)",
          "new_text": null,
          "old_line_content": "    collector->MarkObject(target_object, mark);",
          "new_line_content": "  // Mark object pointed to by p.",
          "content_same": false
        },
        {
          "line": 3176,
          "old_api": "static_cast<void*>(page)",
          "new_api": null,
          "old_text": "static_cast<void*>(page)",
          "new_text": null,
          "old_line_content": "                 static_cast<void*>(this), static_cast<void*>(page),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3178,
          "old_api": "IsFlagSet",
          "new_api": null,
          "old_text": "page->IsFlagSet(Page::PAGE_NEW_OLD_PROMOTION)",
          "new_text": null,
          "old_line_content": "                 page->IsFlagSet(Page::PAGE_NEW_OLD_PROMOTION) ||",
          "new_line_content": "  if (FLAG_trace_evacuation) {",
          "content_same": false
        },
        {
          "line": 3180,
          "old_api": "IsFlagSet",
          "new_api": null,
          "old_text": "page->IsFlagSet(MemoryChunk::IS_EXECUTABLE)",
          "new_text": null,
          "old_line_content": "                 page->IsFlagSet(MemoryChunk::IS_EXECUTABLE),",
          "new_line_content": "                 \"evacuation[%p]: page=%p new_space=%d \"",
          "content_same": false
        },
        {
          "line": 3181,
          "old_api": "new_space",
          "new_api": null,
          "old_text": "heap->new_space()->age_mark()",
          "new_text": null,
          "old_line_content": "                 page->Contains(heap->new_space()->age_mark()),",
          "new_line_content": "                 \"page_evacuation=%d executable=%d contains_age_mark=%d \"",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": "heap",
          "new_api": null,
          "old_text": "collector->heap()->Contains(obj)",
          "new_text": null,
          "old_line_content": "    DCHECK(collector->heap()->Contains(obj));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "heap",
          "new_api": null,
          "old_text": "collector->heap()->mark_compact_collector()->IsMarked(obj)",
          "new_text": null,
          "old_line_content": "    DCHECK(!collector->heap()->mark_compact_collector()->IsMarked(obj));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3189,
          "old_api": "Get",
          "new_api": null,
          "old_text": "heap()->code_space()->MergeCompactionSpace(\n      compaction_spaces_.Get(CODE_SPACE))",
          "new_text": null,
          "old_line_content": "  heap()->code_space()->MergeCompactionSpace(",
          "new_line_content": "                 saved_live_bytes, evacuation_time);",
          "content_same": false
        },
        {
          "line": 1143,
          "old_api": "map",
          "new_api": null,
          "old_text": "obj->map()",
          "new_text": null,
          "old_line_content": "    Map* map = obj->map();",
          "new_line_content": "  // Visit an unmarked object.",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": "GetHeap",
          "new_api": null,
          "old_text": "obj->GetHeap()",
          "new_text": null,
          "old_line_content": "    Heap* heap = obj->GetHeap();",
          "new_line_content": "  INLINE(static void VisitUnmarkedObject(MarkCompactCollector* collector,",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": "ObjectMarking::MarkBitFrom(obj)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(obj)",
          "new_text": null,
          "old_line_content": "    MarkBit mark = ObjectMarking::MarkBitFrom(obj);",
          "new_line_content": "                                         HeapObject* obj)) {",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": "mark_compact_collector",
          "new_api": null,
          "old_text": "heap->mark_compact_collector()->SetMark(obj, mark)",
          "new_text": null,
          "old_line_content": "    heap->mark_compact_collector()->SetMark(obj, mark);",
          "new_line_content": "#ifdef DEBUG",
          "content_same": false
        },
        {
          "line": 3190,
          "old_api": "Get",
          "new_api": null,
          "old_text": "compaction_spaces_.Get(CODE_SPACE)",
          "new_text": null,
          "old_line_content": "      compaction_spaces_.Get(CODE_SPACE));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3191,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()->AddCompactionEvent(duration_, bytes_compacted_)",
          "new_text": null,
          "old_line_content": "  heap()->tracer()->AddCompactionEvent(duration_, bytes_compacted_);",
          "new_line_content": "  return success;",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": "mark_compact_collector",
          "new_api": null,
          "old_text": "heap->mark_compact_collector()->MarkObject(map, map_mark)",
          "new_text": null,
          "old_line_content": "    heap->mark_compact_collector()->MarkObject(map, map_mark);",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 3192,
          "old_api": "promoted_size",
          "new_api": null,
          "old_text": "new_space_visitor_.promoted_size()",
          "new_text": null,
          "old_line_content": "  heap()->IncrementPromotedObjectsSize(new_space_visitor_.promoted_size() +",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3193,
          "old_api": "promoted_size",
          "new_api": null,
          "old_text": "new_space_page_visitor.promoted_size()",
          "new_text": null,
          "old_line_content": "                                       new_space_page_visitor.promoted_size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3194,
          "old_api": "semispace_copied_size",
          "new_api": null,
          "old_text": "heap()->IncrementSemiSpaceCopiedObjectSize(\n      new_space_visitor_.semispace_copied_size() +\n      new_space_page_visitor.semispace_copied_size())",
          "new_text": null,
          "old_line_content": "  heap()->IncrementSemiSpaceCopiedObjectSize(",
          "new_line_content": "void MarkCompactCollector::Evacuator::Finalize() {",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap->isolate()",
          "new_text": null,
          "old_line_content": "    StackLimitCheck check(heap->isolate());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "HasOverflowed",
          "new_api": null,
          "old_text": "check.HasOverflowed()",
          "new_text": null,
          "old_line_content": "    if (check.HasOverflowed()) return false;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": "mark_compact_collector",
          "new_api": null,
          "old_text": "heap->mark_compact_collector()",
          "new_text": null,
          "old_line_content": "    MarkCompactCollector* collector = heap->mark_compact_collector();",
          "new_line_content": "  // Returns false if the operation fails (lack of stack space).",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": "HeapObject::cast(o)",
          "new_api": null,
          "old_text": "HeapObject::cast(o)",
          "new_text": null,
          "old_line_content": "      HeapObject* obj = HeapObject::cast(o);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": "Marking::IsBlackOrGrey(mark)",
          "new_api": null,
          "old_text": "Marking::IsBlackOrGrey(mark)",
          "new_text": null,
          "old_line_content": "      if (Marking::IsBlackOrGrey(mark)) continue;",
          "new_line_content": "    // Visit the unmarked objects.",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": "VisitUnmarkedObject",
          "new_api": null,
          "old_text": "VisitUnmarkedObject(collector, obj)",
          "new_text": null,
          "old_line_content": "      VisitUnmarkedObject(collector, obj);",
          "new_line_content": "    for (Object** p = start; p < end; p++) {",
          "content_same": false
        },
        {
          "line": 3218,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()->CompactionSpeedInBytesPerMillisecond()",
          "new_text": null,
          "old_line_content": "      heap()->tracer()->CompactionSpeedInBytesPerMillisecond();",
          "new_line_content": "  // The number of parallel compaction tasks is limited by:",
          "content_same": false
        },
        {
          "line": 3220,
          "old_api": "NumberOfAvailableBackgroundThreads",
          "new_api": null,
          "old_text": "Max(\n      1, static_cast<int>(\n             V8::GetCurrentPlatform()->NumberOfAvailableBackgroundThreads()) -\n             kNumSweepingTasks - 1)",
          "new_text": null,
          "old_line_content": "  const int available_cores = Max(",
          "new_line_content": "  // - (#cores - 1)",
          "content_same": false
        },
        {
          "line": 3221,
          "old_api": "NumberOfAvailableBackgroundThreads",
          "new_api": null,
          "old_text": "static_cast<int>(\n             V8::GetCurrentPlatform()->NumberOfAvailableBackgroundThreads())",
          "new_text": null,
          "old_line_content": "      1, static_cast<int>(",
          "new_line_content": "  const double kTargetCompactionTimeInMs = 1;",
          "content_same": false
        },
        {
          "line": 3222,
          "old_api": "NumberOfAvailableBackgroundThreads",
          "new_api": null,
          "old_text": "V8::GetCurrentPlatform()->NumberOfAvailableBackgroundThreads()",
          "new_text": null,
          "old_line_content": "             V8::GetCurrentPlatform()->NumberOfAvailableBackgroundThreads()) -",
          "new_line_content": "  const int kNumSweepingTasks = 3;",
          "content_same": false
        },
        {
          "line": 3226,
          "old_api": "static_cast<int>(live_bytes / compaction_speed /\n                                 kTargetCompactionTimeInMs)",
          "new_api": null,
          "old_text": "static_cast<int>(live_bytes / compaction_speed /\n                                 kTargetCompactionTimeInMs)",
          "new_text": null,
          "old_line_content": "    tasks = 1 + static_cast<int>(live_bytes / compaction_speed /",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3231,
          "old_api": "Min",
          "new_api": null,
          "old_text": "Min(pages, tasks)",
          "new_text": null,
          "old_line_content": "  const int tasks_capped_pages = Min(pages, tasks);",
          "new_line_content": "  int tasks;",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": "data",
          "new_api": null,
          "old_text": "re->data()",
          "new_text": null,
          "old_line_content": "    if (HeapObject::cast(re->data())->map()->instance_type() !=",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3232,
          "old_api": "Min",
          "new_api": null,
          "old_text": "Min(available_cores, tasks_capped_pages)",
          "new_text": null,
          "old_line_content": "  return Min(available_cores, tasks_capped_pages);",
          "new_line_content": "  if (compaction_speed > 0) {",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": "TypeTag",
          "new_api": null,
          "old_text": "re->TypeTag()",
          "new_text": null,
          "old_line_content": "    if (re->TypeTag() != JSRegExp::IRREGEXP) return;",
          "new_line_content": "    // Make sure that the fixed array is in fact initialized on the RegExp.",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": "IsSmi",
          "new_api": null,
          "old_text": "code->IsSmi()",
          "new_text": null,
          "old_line_content": "    if (!code->IsSmi() &&",
          "new_line_content": "        FIXED_ARRAY_TYPE)",
          "content_same": false
        },
        {
          "line": 1193,
          "old_api": "map",
          "new_api": null,
          "old_text": "HeapObject::cast(code)->map()->instance_type()",
          "new_text": null,
          "old_line_content": "        HeapObject::cast(code)->map()->instance_type() == CODE_TYPE) {",
          "new_line_content": "      return;",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": "JSRegExp::saved_code_index(is_one_byte)",
          "new_api": null,
          "old_text": "JSRegExp::saved_code_index(is_one_byte)",
          "new_text": null,
          "old_line_content": "      re->SetDataAt(JSRegExp::saved_code_index(is_one_byte), code);",
          "new_line_content": "    // Make sure this is a RegExp that actually contains code.",
          "content_same": false
        },
        {
          "line": 3244,
          "old_api": "reinterpret_cast<Page*>(chunk)",
          "new_api": null,
          "old_text": "reinterpret_cast<Page*>(chunk)",
          "new_text": null,
          "old_line_content": "    return evacuator->EvacuatePage(reinterpret_cast<Page*>(chunk));",
          "new_line_content": "  typedef int* PerPageData;  // Pointer to number of aborted pages.",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": "data",
          "new_api": null,
          "old_text": "re->data()",
          "new_text": null,
          "old_line_content": "      FixedArray* data = FixedArray::cast(re->data());",
          "new_line_content": "      // Save a copy that can be reinstated if we need the code again.",
          "content_same": false
        },
        {
          "line": 3250,
          "old_api": "static_cast<Page*>(chunk)",
          "new_api": null,
          "old_text": "static_cast<Page*>(chunk)",
          "new_text": null,
          "old_line_content": "    Page* p = static_cast<Page*>(chunk);",
          "new_line_content": "                                    MemoryChunk* chunk, PerPageData) {",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": "JSRegExp::saved_code_index(is_one_byte)",
          "new_api": null,
          "old_text": "JSRegExp::saved_code_index(is_one_byte)",
          "new_text": null,
          "old_line_content": "            data->data_start() + JSRegExp::saved_code_index(is_one_byte);",
          "new_line_content": "      // Saving a copy might create a pointer into compaction candidate",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": "mark_compact_collector",
          "new_api": null,
          "old_text": "heap->mark_compact_collector()->RecordSlot(data, slot, code)",
          "new_text": null,
          "old_line_content": "        heap->mark_compact_collector()->RecordSlot(data, slot, code);",
          "new_line_content": "      // that was not observed by marker.  This might happen if JSRegExp data",
          "content_same": false
        },
        {
          "line": 3255,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(success)",
          "new_text": null,
          "old_line_content": "        DCHECK(success);",
          "new_line_content": "                                       bool success, PerPageData data) {",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "ms_count",
          "new_api": null,
          "old_text": "heap->ms_count()",
          "new_text": null,
          "old_line_content": "                    Smi::FromInt(heap->ms_count() & 0xff));",
          "new_line_content": "        Object** slot =",
          "content_same": false
        },
        {
          "line": 3263,
          "old_api": "SweepingDone",
          "new_api": null,
          "old_text": "p->SweepingDone()",
          "new_text": null,
          "old_line_content": "          DCHECK(p->SweepingDone());",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 3264,
          "old_api": "Unlink",
          "new_api": null,
          "old_text": "p->Unlink()",
          "new_text": null,
          "old_line_content": "          p->Unlink();",
          "new_line_content": "      case Evacuator::kObjectsNewToOld:",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": "ms_count",
          "new_api": null,
          "old_text": "heap->ms_count()",
          "new_text": null,
          "old_line_content": "      if (value == ((heap->ms_count() - kRegExpCodeThreshold) & 0xff)) {",
          "new_line_content": "      // The regexp has not been compiled yet or there was a compilation error.",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": "JSRegExp::code_index(is_one_byte)",
          "new_api": null,
          "old_text": "JSRegExp::code_index(is_one_byte)",
          "new_text": null,
          "old_line_content": "        re->SetDataAt(JSRegExp::code_index(is_one_byte),",
          "new_line_content": "      if (value == JSRegExp::kUninitializedValue ||",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": "Smi::FromInt(JSRegExp::kUninitializedValue)",
          "new_api": null,
          "old_text": "Smi::FromInt(JSRegExp::kUninitializedValue)",
          "new_text": null,
          "old_line_content": "                      Smi::FromInt(JSRegExp::kUninitializedValue));",
          "new_line_content": "          value == JSRegExp::kCompilationErrorValue) {",
          "content_same": false
        },
        {
          "line": 1223,
          "old_api": "JSRegExp::saved_code_index(is_one_byte)",
          "new_api": null,
          "old_text": "JSRegExp::saved_code_index(is_one_byte)",
          "new_text": null,
          "old_line_content": "        re->SetDataAt(JSRegExp::saved_code_index(is_one_byte),",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1224,
          "old_api": "Smi::FromInt(JSRegExp::kUninitializedValue)",
          "new_api": null,
          "old_text": "Smi::FromInt(JSRegExp::kUninitializedValue)",
          "new_text": null,
          "old_line_content": "                      Smi::FromInt(JSRegExp::kUninitializedValue));",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3268,
          "old_api": "ClearEvacuationCandidate",
          "new_api": null,
          "old_text": "p->ClearEvacuationCandidate()",
          "new_text": null,
          "old_line_content": "          p->ClearEvacuationCandidate();",
          "new_line_content": "        if (success) {",
          "content_same": false
        },
        {
          "line": 1236,
          "old_api": "GetHeap",
          "new_api": null,
          "old_text": "map->GetHeap()",
          "new_text": null,
          "old_line_content": "    Heap* heap = map->GetHeap();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": "mark_compact_collector",
          "new_api": null,
          "old_text": "heap->mark_compact_collector()",
          "new_text": null,
          "old_line_content": "    MarkCompactCollector* collector = heap->mark_compact_collector();",
          "new_line_content": "  // Works by setting the current sweep_generation (as a smi) in the",
          "content_same": false
        },
        {
          "line": 1238,
          "old_api": "is_code_flushing_enabled",
          "new_api": null,
          "old_text": "collector->is_code_flushing_enabled()",
          "new_text": null,
          "old_line_content": "    if (!collector->is_code_flushing_enabled()) {",
          "new_line_content": "  // code object place in the data array of the RegExp and keeps a copy",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": "VisitJSRegExp",
          "new_api": null,
          "old_text": "VisitJSRegExp(map, object)",
          "new_text": null,
          "old_line_content": "      VisitJSRegExp(map, object);",
          "new_line_content": "  // around that can be reinstated if we reuse the RegExp before flushing.",
          "content_same": false
        },
        {
          "line": 3288,
          "old_api": "LiveBytes",
          "new_api": null,
          "old_text": "page->LiveBytes()",
          "new_text": null,
          "old_line_content": "    live_bytes += page->LiveBytes();",
          "new_line_content": "  PageParallelJob<EvacuationJobTraits> job(",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": "reinterpret_cast<JSRegExp*>(object)",
          "new_api": null,
          "old_text": "reinterpret_cast<JSRegExp*>(object)",
          "new_text": null,
          "old_line_content": "    JSRegExp* re = reinterpret_cast<JSRegExp*>(object);",
          "new_line_content": "  static void VisitRegExpAndFlushCode(Map* map, HeapObject* object) {",
          "content_same": false
        },
        {
          "line": 3292,
          "old_api": "new_space",
          "new_api": null,
          "old_text": "heap()->new_space()->age_mark()",
          "new_text": null,
          "old_line_content": "  const Address age_mark = heap()->new_space()->age_mark();",
          "new_line_content": "  int abandoned_pages = 0;",
          "content_same": false
        },
        {
          "line": 3294,
          "old_api": "LiveBytes",
          "new_api": null,
          "old_text": "page->LiveBytes()",
          "new_text": null,
          "old_line_content": "    live_bytes += page->LiveBytes();",
          "new_line_content": "  for (Page* page : evacuation_candidates_) {",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": "VisitJSRegExp",
          "new_api": null,
          "old_text": "VisitJSRegExp(map, object)",
          "new_text": null,
          "old_line_content": "    VisitJSRegExp(map, object);",
          "new_line_content": "      return;",
          "content_same": false
        },
        {
          "line": 3297,
          "old_api": "Contains",
          "new_api": null,
          "old_text": "page->Contains(age_mark)",
          "new_text": null,
          "old_line_content": "        !page->Contains(age_mark)) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3298,
          "old_api": "IsFlagSet",
          "new_api": null,
          "old_text": "page->IsFlagSet(MemoryChunk::NEW_SPACE_BELOW_AGE_MARK)",
          "new_text": null,
          "old_line_content": "      if (page->IsFlagSet(MemoryChunk::NEW_SPACE_BELOW_AGE_MARK)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1253,
          "old_api": "StaticMarkingVisitor<MarkCompactMarkingVisitor>::Initialize()",
          "new_api": null,
          "old_text": "StaticMarkingVisitor<MarkCompactMarkingVisitor>::Initialize()",
          "new_text": null,
          "old_line_content": "  StaticMarkingVisitor<MarkCompactMarkingVisitor>::Initialize();",
          "new_line_content": "    // Visit the fields of the RegExp, including the updated FixedArray.",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": "Register",
          "new_api": null,
          "old_text": "table_.Register(kVisitJSRegExp, &VisitRegExpAndFlushCode)",
          "new_text": null,
          "old_line_content": "  table_.Register(kVisitJSRegExp, &VisitRegExpAndFlushCode);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3307,
          "old_api": "NumberOfPages",
          "new_api": null,
          "old_text": "job.NumberOfPages()",
          "new_text": null,
          "old_line_content": "  DCHECK_GE(job.NumberOfPages(), 1);",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit CodeMarkingVisitor(MarkCompactCollector* collector)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": "PrepareThreadForCodeFlushing",
          "new_api": null,
          "old_text": "collector_->PrepareThreadForCodeFlushing(isolate, top)",
          "new_text": null,
          "old_line_content": "    collector_->PrepareThreadForCodeFlushing(isolate, top);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3316,
          "old_api": "NumberOfPages",
          "new_api": null,
          "old_text": "job.NumberOfPages()",
          "new_text": null,
          "old_line_content": "      NumberOfParallelCompactionTasks(job.NumberOfPages(), live_bytes);",
          "new_line_content": "  // Used for trace summary.",
          "content_same": false
        },
        {
          "line": 3321,
          "old_api": "Run",
          "new_api": null,
          "old_text": "job.Run(wanted_num_tasks, [evacuators](int i) { return evacuators[i]; })",
          "new_text": null,
          "old_line_content": "  job.Run(wanted_num_tasks, [evacuators](int i) { return evacuators[i]; });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1275,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SharedFunctionInfoMarkingVisitor(MarkCompactCollector* collector)",
          "new_line_content": " private:",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": "VisitPointer",
          "new_api": null,
          "old_text": "VisitPointer(p)",
          "new_text": null,
          "old_line_content": "    for (Object** p = start; p < end; p++) VisitPointer(p);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3329,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "isolate()",
          "new_text": null,
          "old_line_content": "    PrintIsolate(isolate(),",
          "new_line_content": "  for (int i = 0; i < wanted_num_tasks; i++) {",
          "content_same": false
        },
        {
          "line": 1284,
          "old_api": "IsSharedFunctionInfo",
          "new_api": null,
          "old_text": "obj->IsSharedFunctionInfo()",
          "new_text": null,
          "old_line_content": "    if (obj->IsSharedFunctionInfo()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": "reinterpret_cast<SharedFunctionInfo*>(obj)",
          "new_api": null,
          "old_text": "reinterpret_cast<SharedFunctionInfo*>(obj)",
          "new_text": null,
          "old_line_content": "      SharedFunctionInfo* shared = reinterpret_cast<SharedFunctionInfo*>(obj);",
          "new_line_content": "  void VisitPointers(Object** start, Object** end) override {",
          "content_same": false
        },
        {
          "line": 3333,
          "old_api": "time_millis_since_init",
          "new_api": null,
          "old_text": "isolate()->time_millis_since_init()",
          "new_text": null,
          "old_line_content": "                 isolate()->time_millis_since_init(),",
          "new_line_content": "  delete[] evacuators;",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": "code",
          "new_api": null,
          "old_text": "shared->code()",
          "new_text": null,
          "old_line_content": "      MarkBit code_mark = ObjectMarking::MarkBitFrom(shared->code());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1288,
          "old_api": "code",
          "new_api": null,
          "old_text": "shared->code()",
          "new_text": null,
          "old_line_content": "      collector_->MarkObject(shared->code(), code_mark);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1289,
          "old_api": "MarkObject",
          "new_api": null,
          "old_text": "collector_->MarkObject(shared, shared_mark)",
          "new_text": null,
          "old_line_content": "      collector_->MarkObject(shared, shared_mark);",
          "new_line_content": "  void VisitPointer(Object** slot) override {",
          "content_same": false
        },
        {
          "line": 3334,
          "old_api": "NumberOfPages",
          "new_api": null,
          "old_text": "job.NumberOfPages()",
          "new_text": null,
          "old_line_content": "                 FLAG_parallel_compaction ? \"yes\" : \"no\", job.NumberOfPages(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3335,
          "old_api": "NumberOfTasks",
          "new_api": null,
          "old_text": "job.NumberOfTasks()",
          "new_text": null,
          "old_line_content": "                 abandoned_pages, wanted_num_tasks, job.NumberOfTasks(),",
          "new_line_content": "  if (FLAG_trace_evacuation) {",
          "content_same": false
        },
        {
          "line": 3344,
          "old_api": "IsHeapObject",
          "new_api": null,
          "old_text": "object->IsHeapObject()",
          "new_text": null,
          "old_line_content": "    if (object->IsHeapObject()) {",
          "new_line_content": "                 live_bytes, compaction_speed);",
          "content_same": false
        },
        {
          "line": 3345,
          "old_api": "HeapObject::cast(object)",
          "new_api": null,
          "old_text": "HeapObject::cast(object)",
          "new_text": null,
          "old_line_content": "      HeapObject* heap_object = HeapObject::cast(object);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3346,
          "old_api": "map_word",
          "new_api": null,
          "old_text": "heap_object->map_word()",
          "new_text": null,
          "old_line_content": "      MapWord map_word = heap_object->map_word();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3347,
          "old_api": "IsForwardingAddress",
          "new_api": null,
          "old_text": "map_word.IsForwardingAddress()",
          "new_text": null,
          "old_line_content": "      if (map_word.IsForwardingAddress()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": "Advance",
          "new_api": null,
          "old_text": "it.Advance()",
          "new_text": null,
          "old_line_content": "  for (StackFrameIterator it(isolate, top); !it.done(); it.Advance()) {",
          "new_line_content": " private:",
          "content_same": false
        },
        {
          "line": 3348,
          "old_api": "ToForwardingAddress",
          "new_api": null,
          "old_text": "map_word.ToForwardingAddress()",
          "new_text": null,
          "old_line_content": "        return map_word.ToForwardingAddress();",
          "new_line_content": "class EvacuationWeakObjectRetainer : public WeakObjectRetainer {",
          "content_same": false
        },
        {
          "line": 1305,
          "old_api": "frame",
          "new_api": null,
          "old_text": "it.frame()",
          "new_text": null,
          "old_line_content": "    StackFrame* frame = it.frame();",
          "new_line_content": "void MarkCompactCollector::PrepareThreadForCodeFlushing(Isolate* isolate,",
          "content_same": false
        },
        {
          "line": 1306,
          "old_api": "unchecked_code",
          "new_api": null,
          "old_text": "frame->unchecked_code()",
          "new_text": null,
          "old_line_content": "    Code* code = frame->unchecked_code();",
          "new_line_content": "                                                        ThreadLocalTop* top) {",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": "MarkObject",
          "new_api": null,
          "old_text": "MarkObject(code, code_mark)",
          "new_text": null,
          "old_line_content": "    MarkObject(code, code_mark);",
          "new_line_content": "    // Note: for the frame that has a pending lazy deoptimization",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": "is_optimized",
          "new_api": null,
          "old_text": "frame->is_optimized()",
          "new_text": null,
          "old_line_content": "    if (frame->is_optimized()) {",
          "new_line_content": "    // StackFrame::unchecked_code will return a non-optimized code object for",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": "LookupCode",
          "new_api": null,
          "old_text": "frame->LookupCode()",
          "new_text": null,
          "old_line_content": "      Code* optimized_code = frame->LookupCode();",
          "new_line_content": "    // the outermost function and StackFrame::LookupCode will return",
          "content_same": false
        },
        {
          "line": 1311,
          "old_api": "ObjectMarking::MarkBitFrom(optimized_code)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(optimized_code)",
          "new_text": null,
          "old_line_content": "      MarkBit optimized_code_mark = ObjectMarking::MarkBitFrom(optimized_code);",
          "new_line_content": "    // actual optimized code object.",
          "content_same": false
        },
        {
          "line": 3358,
          "old_api": "owner",
          "new_api": null,
          "old_text": "p->owner()",
          "new_text": null,
          "old_line_content": "  Space* space = p->owner();",
          "new_line_content": "    return object;",
          "content_same": false
        },
        {
          "line": 3359,
          "old_api": "DCHECK_NOT_NULL",
          "new_api": null,
          "old_text": "DCHECK_NOT_NULL(space)",
          "new_text": null,
          "old_line_content": "  DCHECK_NOT_NULL(space);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3360,
          "old_api": "identity",
          "new_api": null,
          "old_text": "space->identity()",
          "new_text": null,
          "old_line_content": "  DCHECK(free_list_mode == IGNORE_FREE_LIST || space->identity() == OLD_SPACE ||",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 3361,
          "old_api": "identity",
          "new_api": null,
          "old_text": "space->identity()",
          "new_text": null,
          "old_line_content": "         space->identity() == CODE_SPACE || space->identity() == MAP_SPACE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3362,
          "old_api": "SweepingDone",
          "new_api": null,
          "old_text": "p->SweepingDone()",
          "new_text": null,
          "old_line_content": "  DCHECK(!p->IsEvacuationCandidate() && !p->SweepingDone());",
          "new_line_content": "int MarkCompactCollector::Sweeper::RawSweep(",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": "is_code_flushing_enabled",
          "new_api": null,
          "old_text": "is_code_flushing_enabled()",
          "new_text": null,
          "old_line_content": "  if (!is_code_flushing_enabled()) return;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": "mark_compact_collector",
          "new_api": null,
          "old_text": "heap()->mark_compact_collector()",
          "new_text": null,
          "old_line_content": "  DCHECK(this == heap()->mark_compact_collector());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap()->isolate()",
          "new_text": null,
          "old_line_content": "  PrepareThreadForCodeFlushing(heap()->isolate(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap()->isolate()->thread_local_top()",
          "new_text": null,
          "old_line_content": "                               heap()->isolate()->thread_local_top());",
          "new_line_content": "void MarkCompactCollector::PrepareForCodeFlushing() {",
          "content_same": false
        },
        {
          "line": 3378,
          "old_api": "Clear",
          "new_api": null,
          "old_text": "skip_list->Clear()",
          "new_text": null,
          "old_line_content": "    skip_list->Clear();",
          "new_line_content": "  // If we use the skip list for code space pages, we have to lock the skip",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap()->isolate()->compilation_cache()->IterateFunctions(&visitor)",
          "new_text": null,
          "old_line_content": "  heap()->isolate()->compilation_cache()->IterateFunctions(&visitor);",
          "new_line_content": "  // Iterate the archived stacks in all threads to check if",
          "content_same": false
        },
        {
          "line": 1335,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap()->isolate()->handle_scope_implementer()->Iterate(&visitor)",
          "new_text": null,
          "old_line_content": "  heap()->isolate()->handle_scope_implementer()->Iterate(&visitor);",
          "new_line_content": "  // the code is referenced.",
          "content_same": false
        },
        {
          "line": 3387,
          "old_api": "Next",
          "new_api": null,
          "old_text": "it.Next()",
          "new_text": null,
          "old_line_content": "  while ((object = it.Next()) != NULL) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3388,
          "old_api": "ObjectMarking::MarkBitFrom(object)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(object)",
          "new_text": null,
          "old_line_content": "    DCHECK(Marking::IsBlack(ObjectMarking::MarkBitFrom(object)));",
          "new_line_content": "  intptr_t freed_bytes = 0;",
          "content_same": false
        },
        {
          "line": 3389,
          "old_api": "address",
          "new_api": null,
          "old_text": "object->address()",
          "new_text": null,
          "old_line_content": "    Address free_end = object->address();",
          "new_line_content": "  intptr_t max_freed_bytes = 0;",
          "content_same": false
        },
        {
          "line": 3391,
          "old_api": "static_cast<int>(free_end - free_start)",
          "new_api": null,
          "old_text": "static_cast<int>(free_end - free_start)",
          "new_text": null,
          "old_line_content": "      int size = static_cast<int>(free_end - free_start);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": "mark_compact_collector",
          "new_api": null,
          "old_text": "heap->mark_compact_collector()",
          "new_text": null,
          "old_line_content": "      : collector_(heap->mark_compact_collector()) {}",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3393,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(free_start, 0xcc, size)",
          "new_text": null,
          "old_line_content": "        memset(free_start, 0xcc, size);",
          "new_line_content": "  HeapObject* object = NULL;",
          "content_same": false
        },
        {
          "line": 1347,
          "old_api": "MarkObjectByPointer",
          "new_api": null,
          "old_text": "MarkObjectByPointer(p)",
          "new_text": null,
          "old_line_content": "  void VisitPointer(Object** p) override { MarkObjectByPointer(p); }",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1350,
          "old_api": "MarkObjectByPointer",
          "new_api": null,
          "old_text": "MarkObjectByPointer(p)",
          "new_text": null,
          "old_line_content": "    for (Object** p = start; p < end; p++) MarkObjectByPointer(p);",
          "new_line_content": " public:",
          "content_same": false
        },
        {
          "line": 3404,
          "old_api": "synchronized_map",
          "new_api": null,
          "old_text": "object->synchronized_map()",
          "new_text": null,
          "old_line_content": "    Map* map = object->synchronized_map();",
          "new_line_content": "            free_start, size);",
          "content_same": false
        },
        {
          "line": 1359,
          "old_api": "IsHeapObject",
          "new_api": null,
          "old_text": "*p)->IsHeapObject()",
          "new_text": null,
          "old_line_content": "    if (!(*p)->IsHeapObject()) return;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1361,
          "old_api": "HeapObject::cast(*p)",
          "new_api": null,
          "old_text": "HeapObject::cast(*p)",
          "new_text": null,
          "old_line_content": "    HeapObject* object = HeapObject::cast(*p);",
          "new_line_content": "  // ProcessTopOptimizedFrame.",
          "content_same": false
        },
        {
          "line": 3409,
          "old_api": "SkipList::RegionNumber(free_end + size - kPointerSize)",
          "new_api": null,
          "old_text": "SkipList::RegionNumber(free_end + size - kPointerSize)",
          "new_text": null,
          "old_line_content": "          SkipList::RegionNumber(free_end + size - kPointerSize);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": "ObjectMarking::MarkBitFrom(object)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(object)",
          "new_text": null,
          "old_line_content": "    MarkBit mark_bit = ObjectMarking::MarkBitFrom(object);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": "Marking::IsBlackOrGrey(mark_bit)",
          "new_api": null,
          "old_text": "Marking::IsBlackOrGrey(mark_bit)",
          "new_text": null,
          "old_line_content": "    if (Marking::IsBlackOrGrey(mark_bit)) return;",
          "new_line_content": " private:",
          "content_same": false
        },
        {
          "line": 3419,
          "old_api": "ClearLiveness",
          "new_api": null,
          "old_text": "p->ClearLiveness()",
          "new_text": null,
          "old_line_content": "  p->ClearLiveness();",
          "new_line_content": "        curr_region = new_region_end;",
          "content_same": false
        },
        {
          "line": 1372,
          "old_api": "MarkObject",
          "new_api": null,
          "old_text": "collector_->MarkObject(map, map_mark)",
          "new_text": null,
          "old_line_content": "    collector_->MarkObject(map, map_mark);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3421,
          "old_api": "area_end",
          "new_api": null,
          "old_text": "p->area_end()",
          "new_text": null,
          "old_line_content": "  if (free_start != p->area_end()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3422,
          "old_api": "area_end",
          "new_api": null,
          "old_text": "p->area_end()",
          "new_text": null,
          "old_line_content": "    int size = static_cast<int>(p->area_end() - free_start);",
          "new_line_content": "    free_start = free_end + size;",
          "content_same": false
        },
        {
          "line": 3424,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(free_start, 0xcc, size)",
          "new_text": null,
          "old_line_content": "      memset(free_start, 0xcc, size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1377,
          "old_api": "EmptyMarkingDeque",
          "new_api": null,
          "old_text": "collector_->EmptyMarkingDeque()",
          "new_text": null,
          "old_line_content": "    collector_->EmptyMarkingDeque();",
          "new_line_content": "    // Mark the map pointer and body, and push them on the marking stack.",
          "content_same": false
        },
        {
          "line": 3427,
          "old_api": "UnaccountedFree",
          "new_api": null,
          "old_text": "reinterpret_cast<PagedSpace*>(space)->UnaccountedFree(\n          free_start, size)",
          "new_text": null,
          "old_line_content": "      freed_bytes = reinterpret_cast<PagedSpace*>(space)->UnaccountedFree(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3435,
          "old_api": "SetValue",
          "new_api": null,
          "old_text": "p->concurrent_sweeping_state().SetValue(Page::kSweepingDone)",
          "new_text": null,
          "old_line_content": "  p->concurrent_sweeping_state().SetValue(Page::kSweepingDone);",
          "new_line_content": "          free_start, size);",
          "content_same": false
        },
        {
          "line": 3437,
          "old_api": "static_cast<int>(max_freed_bytes)",
          "new_api": null,
          "old_text": "static_cast<int>(max_freed_bytes)",
          "new_text": null,
          "old_line_content": "  return FreeList::GuaranteedAllocatable(static_cast<int>(max_freed_bytes));",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(!record_slots || table != nullptr)",
          "new_text": null,
          "old_line_content": "    DCHECK(!record_slots || table != nullptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3441,
          "old_api": "address",
          "new_api": null,
          "old_text": "code->address()",
          "new_text": null,
          "old_line_content": "  Page* page = Page::FromAddress(code->address());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1395,
          "old_api": "mark_compact_collector",
          "new_api": null,
          "old_text": "heap_->mark_compact_collector()",
          "new_text": null,
          "old_line_content": "    MarkCompactCollector* collector = heap_->mark_compact_collector();",
          "new_line_content": "  StringTableCleaner(Heap* heap, HeapObject* table)",
          "content_same": false
        },
        {
          "line": 3443,
          "old_api": "Size",
          "new_api": null,
          "old_text": "code->Size()",
          "new_text": null,
          "old_line_content": "  Address end = code->address() + code->Size();",
          "new_line_content": "  if (free_list_mode == IGNORE_FREE_LIST) return 0;",
          "content_same": false
        },
        {
          "line": 3445,
          "old_api": "RememberedSet<OLD_TO_NEW>::RemoveRangeTyped(page, start, end)",
          "new_api": null,
          "old_text": "RememberedSet<OLD_TO_NEW>::RemoveRangeTyped(page, start, end)",
          "new_text": null,
          "old_line_content": "  RememberedSet<OLD_TO_NEW>::RemoveRangeTyped(page, start, end);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": "IsHeapObject",
          "new_api": null,
          "old_text": "o->IsHeapObject()",
          "new_text": null,
          "old_line_content": "      if (o->IsHeapObject()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": "HeapObject::cast(o)",
          "new_api": null,
          "old_text": "HeapObject::cast(o)",
          "new_text": null,
          "old_line_content": "        if (Marking::IsWhite(ObjectMarking::MarkBitFrom(HeapObject::cast(o)))) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3447,
          "old_api": "incremental_marking",
          "new_api": null,
          "old_text": "heap_->incremental_marking()->IsCompacting()",
          "new_text": null,
          "old_line_content": "  if (heap_->incremental_marking()->IsCompacting() &&",
          "new_line_content": "void MarkCompactCollector::InvalidateCode(Code* code) {",
          "content_same": false
        },
        {
          "line": 1401,
          "old_api": "IsExternalString",
          "new_api": null,
          "old_text": "o->IsExternalString()",
          "new_text": null,
          "old_line_content": "            DCHECK(o->IsExternalString());",
          "new_line_content": "    // Visit all HeapObject pointers in [start, end).",
          "content_same": false
        },
        {
          "line": 3453,
          "old_api": "Marking::IsWhite(mark_bit)",
          "new_api": null,
          "old_text": "Marking::IsWhite(mark_bit)",
          "new_text": null,
          "old_line_content": "    if (Marking::IsWhite(mark_bit)) return;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1407,
          "old_api": "the_hole_value",
          "new_api": null,
          "old_text": "heap_->the_hole_value()",
          "new_text": null,
          "old_line_content": "          *p = heap_->the_hole_value();",
          "new_line_content": "          if (finalize_external_strings) {",
          "content_same": false
        },
        {
          "line": 1410,
          "old_api": "InNewSpace",
          "new_api": null,
          "old_text": "heap_->InNewSpace(o)",
          "new_text": null,
          "old_line_content": "          DCHECK(!heap_->InNewSpace(o));",
          "new_line_content": "          } else {",
          "content_same": false
        },
        {
          "line": 1411,
          "old_api": "RecordSlot",
          "new_api": null,
          "old_text": "collector->RecordSlot(table_, p, o)",
          "new_text": null,
          "old_line_content": "          collector->RecordSlot(table_, p, o);",
          "new_line_content": "            pointers_removed_++;",
          "content_same": false
        },
        {
          "line": 3458,
          "old_api": "RememberedSet<OLD_TO_OLD>::RemoveRangeTyped(page, start, end)",
          "new_api": null,
          "old_text": "RememberedSet<OLD_TO_OLD>::RemoveRangeTyped(page, start, end)",
          "new_text": null,
          "old_line_content": "    RememberedSet<OLD_TO_OLD>::RemoveRangeTyped(page, start, end);",
          "new_line_content": "    // If the object is white than no slots were recorded on it yet.",
          "content_same": false
        },
        {
          "line": 3473,
          "old_api": "Next",
          "new_api": null,
          "old_text": "it.Next()",
          "new_text": null,
          "old_line_content": "  while ((object = it.Next()) != NULL) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3474,
          "old_api": "ObjectMarking::MarkBitFrom(object)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(object)",
          "new_text": null,
          "old_line_content": "    CHECK(Marking::IsBlack(ObjectMarking::MarkBitFrom(object)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3483,
          "old_api": "VerifyAllBlackObjects",
          "new_api": null,
          "old_text": "VerifyAllBlackObjects(page)",
          "new_text": null,
          "old_line_content": "  VerifyAllBlackObjects(page);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1436,
          "old_api": "HeapObject::cast(object)",
          "new_api": null,
          "old_text": "HeapObject::cast(object)",
          "new_text": null,
          "old_line_content": "    MarkBit mark_bit = ObjectMarking::MarkBitFrom(HeapObject::cast(object));",
          "new_line_content": "typedef StringTableCleaner<true, false> ExternalStringTableCleaner;",
          "content_same": false
        },
        {
          "line": 1437,
          "old_api": "Marking::IsGrey(mark_bit)",
          "new_api": null,
          "old_text": "Marking::IsGrey(mark_bit)",
          "new_text": null,
          "old_line_content": "    DCHECK(!Marking::IsGrey(mark_bit));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1438,
          "old_api": "Marking::IsBlack(mark_bit)",
          "new_api": null,
          "old_text": "Marking::IsBlack(mark_bit)",
          "new_text": null,
          "old_line_content": "    if (Marking::IsBlack(mark_bit)) {",
          "new_line_content": "// Implementation of WeakObjectRetainer for mark compact GCs. All marked objects",
          "content_same": false
        },
        {
          "line": 1440,
          "old_api": "IsAllocationSite",
          "new_api": null,
          "old_text": "object->IsAllocationSite()",
          "new_text": null,
          "old_line_content": "    } else if (object->IsAllocationSite() &&",
          "new_line_content": "class MarkCompactWeakObjectRetainer : public WeakObjectRetainer {",
          "content_same": false
        },
        {
          "line": 1441,
          "old_api": "IsZombie",
          "new_api": null,
          "old_text": "AllocationSite::cast(object)->IsZombie()",
          "new_text": null,
          "old_line_content": "               !(AllocationSite::cast(object)->IsZombie())) {",
          "new_line_content": " public:",
          "content_same": false
        },
        {
          "line": 3488,
          "old_api": "Next",
          "new_api": null,
          "old_text": "it.Next()",
          "new_text": null,
          "old_line_content": "  while ((object = it.Next()) != nullptr) {",
          "new_line_content": "                                            IterationMode mode) {",
          "content_same": false
        },
        {
          "line": 3489,
          "old_api": "ObjectMarking::MarkBitFrom(object)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(object)",
          "new_text": null,
          "old_line_content": "    DCHECK(Marking::IsBlack(ObjectMarking::MarkBitFrom(object)));",
          "new_line_content": "#ifdef VERIFY_HEAP",
          "content_same": false
        },
        {
          "line": 3492,
          "old_api": "markbits",
          "new_api": null,
          "old_text": "page->markbits()->ClearRange(\n            page->AddressToMarkbitIndex(page->area_start()),\n            page->AddressToMarkbitIndex(object->address()))",
          "new_text": null,
          "old_line_content": "        page->markbits()->ClearRange(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3493,
          "old_api": "area_start",
          "new_api": null,
          "old_text": "page->area_start()",
          "new_text": null,
          "old_line_content": "            page->AddressToMarkbitIndex(page->area_start()),",
          "new_line_content": "  LiveObjectIterator<kBlackObjects> it(page);",
          "content_same": false
        },
        {
          "line": 1446,
          "old_api": "GetHeap",
          "new_api": null,
          "old_text": "site->GetHeap()->mark_compact_collector()->MarkAllocationSite(site)",
          "new_text": null,
          "old_line_content": "      site->GetHeap()->mark_compact_collector()->MarkAllocationSite(site);",
          "new_line_content": "      return object;",
          "content_same": false
        },
        {
          "line": 3494,
          "old_api": "address",
          "new_api": null,
          "old_text": "object->address()",
          "new_text": null,
          "old_line_content": "            page->AddressToMarkbitIndex(object->address()));",
          "new_line_content": "  HeapObject* object = nullptr;",
          "content_same": false
        },
        {
          "line": 3509,
          "old_api": "ClearLiveness",
          "new_api": null,
          "old_text": "page->ClearLiveness()",
          "new_text": null,
          "old_line_content": "    page->ClearLiveness();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1462,
          "old_api": "IsFull",
          "new_api": null,
          "old_text": "marking_deque()->IsFull()",
          "new_text": null,
          "old_line_content": "  DCHECK(!marking_deque()->IsFull());",
          "new_line_content": "// Fill the marking stack with overflowed objects returned by the given",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": "one_pointer_filler_map",
          "new_api": null,
          "old_text": "heap()->one_pointer_filler_map()",
          "new_text": null,
          "old_line_content": "  Map* filler_map = heap()->one_pointer_filler_map();",
          "new_line_content": "// is reached, whichever comes first.",
          "content_same": false
        },
        {
          "line": 1465,
          "old_api": "Next",
          "new_api": null,
          "old_text": "it->Next()",
          "new_text": null,
          "old_line_content": "  for (HeapObject* object = it->Next(); object != NULL; object = it->Next()) {",
          "new_line_content": "template <class T>",
          "content_same": false
        },
        {
          "line": 1466,
          "old_api": "ObjectMarking::MarkBitFrom(object)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(object)",
          "new_text": null,
          "old_line_content": "    MarkBit markbit = ObjectMarking::MarkBitFrom(object);",
          "new_line_content": "void MarkCompactCollector::DiscoverGreyObjectsWithIterator(T* it) {",
          "content_same": false
        },
        {
          "line": 1467,
          "old_api": "Marking::IsGrey(markbit)",
          "new_api": null,
          "old_text": "Marking::IsGrey(markbit)",
          "new_text": null,
          "old_line_content": "    if ((object->map() != filler_map) && Marking::IsGrey(markbit)) {",
          "new_line_content": "  // The caller should ensure that the marking stack is initially not full,",
          "content_same": false
        },
        {
          "line": 1468,
          "old_api": "Marking::GreyToBlack(markbit)",
          "new_api": null,
          "old_text": "Marking::GreyToBlack(markbit)",
          "new_text": null,
          "old_line_content": "      Marking::GreyToBlack(markbit);",
          "new_line_content": "  // so that we don't waste effort pointlessly scanning for objects.",
          "content_same": false
        },
        {
          "line": 1470,
          "old_api": "IsFull",
          "new_api": null,
          "old_text": "marking_deque()->IsFull()",
          "new_text": null,
          "old_line_content": "      if (marking_deque()->IsFull()) return;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3519,
          "old_api": "Next",
          "new_api": null,
          "old_text": "it.Next()",
          "new_text": null,
          "old_line_content": "  while ((object = it.Next()) != nullptr) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3520,
          "old_api": "Size",
          "new_api": null,
          "old_text": "object->Size()",
          "new_text": null,
          "old_line_content": "    new_live_size += object->Size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3522,
          "old_api": "SetLiveBytes",
          "new_api": null,
          "old_text": "page->SetLiveBytes(new_live_size)",
          "new_text": null,
          "old_line_content": "  page->SetLiveBytes(new_live_size);",
          "new_line_content": "void MarkCompactCollector::RecomputeLiveBytes(MemoryChunk* page) {",
          "content_same": false
        },
        {
          "line": 1479,
          "old_api": "Next",
          "new_api": null,
          "old_text": "it.Next()",
          "new_text": null,
          "old_line_content": "  while ((object = it.Next()) != NULL) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": "ObjectMarking::MarkBitFrom(object)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(object)",
          "new_text": null,
          "old_line_content": "    MarkBit markbit = ObjectMarking::MarkBitFrom(object);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1481,
          "old_api": "Marking::IsGrey(markbit)",
          "new_api": null,
          "old_text": "Marking::IsGrey(markbit)",
          "new_text": null,
          "old_line_content": "    DCHECK(Marking::IsGrey(markbit));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": "Marking::GreyToBlack(markbit)",
          "new_api": null,
          "old_text": "Marking::GreyToBlack(markbit)",
          "new_text": null,
          "old_line_content": "    Marking::GreyToBlack(markbit);",
          "new_line_content": "void MarkCompactCollector::DiscoverGreyObjectsOnPage(MemoryChunk* p) {",
          "content_same": false
        },
        {
          "line": 3528,
          "old_api": "identity",
          "new_api": null,
          "old_text": "space->identity()",
          "new_text": null,
          "old_line_content": "  swept_list_[space->identity()].Add(page);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1484,
          "old_api": "IsFull",
          "new_api": null,
          "old_text": "marking_deque()->IsFull()",
          "new_text": null,
          "old_line_content": "    if (marking_deque()->IsFull()) return;",
          "new_line_content": "  LiveObjectIterator<kGreyObjects> it(p);",
          "content_same": false
        },
        {
          "line": 3532,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_EVACUATE);",
          "new_line_content": "void MarkCompactCollector::Sweeper::AddSweptPageSafe(PagedSpace* space,",
          "content_same": false
        },
        {
          "line": 3536,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_EVACUATE_COPY);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3540,
          "old_api": "EvacuatePagesInParallel",
          "new_api": null,
          "old_text": "EvacuatePagesInParallel()",
          "new_text": null,
          "old_line_content": "    EvacuatePagesInParallel();",
          "new_line_content": "  Heap::RelocationLock relocation_lock(heap());",
          "content_same": false
        },
        {
          "line": 3541,
          "old_api": "new_space",
          "new_api": null,
          "old_text": "heap()->new_space()->top()",
          "new_text": null,
          "old_line_content": "    heap()->new_space()->set_age_mark(heap()->new_space()->top());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1494,
          "old_api": "reinterpret_cast<Address>(p)",
          "new_api": null,
          "old_text": "reinterpret_cast<Address>(p)",
          "new_text": null,
          "old_line_content": "    RecordMigratedSlot(*p, reinterpret_cast<Address>(p));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3544,
          "old_api": "UpdatePointersAfterEvacuation",
          "new_api": null,
          "old_text": "UpdatePointersAfterEvacuation()",
          "new_text": null,
          "old_line_content": "  UpdatePointersAfterEvacuation();",
          "new_line_content": "    EvacuationScope evacuation_scope(this);",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": "reinterpret_cast<Address>(start)",
          "new_api": null,
          "old_text": "reinterpret_cast<Address>(start)",
          "new_text": null,
          "old_line_content": "      RecordMigratedSlot(*start, reinterpret_cast<Address>(start));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1505,
          "old_api": "Memory::Address_at(code_entry_slot)",
          "new_api": null,
          "old_text": "Memory::Address_at(code_entry_slot)",
          "new_text": null,
          "old_line_content": "    Address code_entry = Memory::Address_at(code_entry_slot);",
          "new_line_content": "    while (start < end) {",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": "Page::FromAddress(code_entry_slot)",
          "new_api": null,
          "old_text": "Page::FromAddress(code_entry_slot)",
          "new_text": null,
          "old_line_content": "      RememberedSet<OLD_TO_OLD>::InsertTyped(Page::FromAddress(code_entry_slot),",
          "new_line_content": "      ++start;",
          "content_same": false
        },
        {
          "line": 3557,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "    TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_EVACUATE_CLEAN_UP);",
          "new_line_content": "  // Give pages that are queued to be freed back to the OS. Note that filtering",
          "content_same": false
        },
        {
          "line": 3560,
          "old_api": "IsFlagSet",
          "new_api": null,
          "old_text": "p->IsFlagSet(Page::PAGE_NEW_NEW_PROMOTION)",
          "new_text": null,
          "old_line_content": "      if (p->IsFlagSet(Page::PAGE_NEW_NEW_PROMOTION)) {",
          "new_line_content": "  // to still have access to page headers.",
          "content_same": false
        },
        {
          "line": 3562,
          "old_api": "owner",
          "new_api": null,
          "old_text": "p->owner()->identity()",
          "new_text": null,
          "old_line_content": "        sweeper().AddLatePage(p->owner()->identity(), p);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": "target_address",
          "new_api": null,
          "old_text": "rinfo->target_address()",
          "new_text": null,
          "old_line_content": "    Code* target = Code::GetCodeFromTargetAddress(rinfo->target_address());",
          "new_line_content": "                                             nullptr, CODE_ENTRY_SLOT,",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": "host",
          "new_api": null,
          "old_text": "rinfo->host()",
          "new_text": null,
          "old_line_content": "    Code* host = rinfo->host();",
          "new_line_content": "                                             code_entry_slot);",
          "content_same": false
        },
        {
          "line": 3563,
          "old_api": "IsFlagSet",
          "new_api": null,
          "old_text": "p->IsFlagSet(Page::PAGE_NEW_OLD_PROMOTION)",
          "new_text": null,
          "old_line_content": "      } else if (p->IsFlagSet(Page::PAGE_NEW_OLD_PROMOTION)) {",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 3565,
          "old_api": "ForAllFreeListCategories",
          "new_api": null,
          "old_text": "p->ForAllFreeListCategories(\n            [](FreeListCategory* category) { DCHECK(!category->is_linked()); })",
          "new_text": null,
          "old_line_content": "        p->ForAllFreeListCategories(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": "heap",
          "new_api": null,
          "old_text": "collector_->heap()->InNewSpace(target)",
          "new_text": null,
          "old_line_content": "    DCHECK(!collector_->heap()->InNewSpace(target));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": "RecordRelocSlot",
          "new_api": null,
          "old_text": "collector_->RecordRelocSlot(host, rinfo, target)",
          "new_text": null,
          "old_line_content": "    collector_->RecordRelocSlot(host, rinfo, target);",
          "new_line_content": "  inline void VisitCodeTarget(RelocInfo* rinfo) final {",
          "content_same": false
        },
        {
          "line": 3566,
          "old_api": "is_linked",
          "new_api": null,
          "old_text": "category->is_linked()",
          "new_text": null,
          "old_line_content": "            [](FreeListCategory* category) { DCHECK(!category->is_linked()); });",
          "new_line_content": "    for (Page* p : newspace_evacuation_candidates_) {",
          "content_same": false
        },
        {
          "line": 1524,
          "old_api": "rmode",
          "new_api": null,
          "old_text": "rinfo->rmode()",
          "new_text": null,
          "old_line_content": "    DCHECK(RelocInfo::IsDebugBreakSlot(rinfo->rmode()) &&",
          "new_line_content": "    // The target is always in old space, we don't have to record the slot in",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": "IsPatchedDebugBreakSlotSequence",
          "new_api": null,
          "old_text": "rinfo->IsPatchedDebugBreakSlotSequence()",
          "new_text": null,
          "old_line_content": "           rinfo->IsPatchedDebugBreakSlotSequence());",
          "new_line_content": "    // the old-to-new remembered set.",
          "content_same": false
        },
        {
          "line": 3576,
          "old_api": "skip_list",
          "new_api": null,
          "old_text": "p->skip_list()",
          "new_text": null,
          "old_line_content": "      SkipList* list = p->skip_list();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1530,
          "old_api": "heap",
          "new_api": null,
          "old_text": "collector_->heap()->InNewSpace(target)",
          "new_text": null,
          "old_line_content": "    DCHECK(!collector_->heap()->InNewSpace(target));",
          "new_line_content": "  inline void VisitDebugTarget(RelocInfo* rinfo) final {",
          "content_same": false
        },
        {
          "line": 3578,
          "old_api": "IsFlagSet",
          "new_api": null,
          "old_text": "p->IsFlagSet(Page::COMPACTION_WAS_ABORTED)",
          "new_text": null,
          "old_line_content": "      if (p->IsFlagSet(Page::COMPACTION_WAS_ABORTED)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3579,
          "old_api": "owner",
          "new_api": null,
          "old_text": "p->owner()->identity()",
          "new_text": null,
          "old_line_content": "        sweeper().AddLatePage(p->owner()->identity(), p);",
          "new_line_content": "    for (Page* p : evacuation_candidates_) {",
          "content_same": false
        },
        {
          "line": 3580,
          "old_api": "ClearFlag",
          "new_api": null,
          "old_text": "p->ClearFlag(Page::COMPACTION_WAS_ABORTED)",
          "new_text": null,
          "old_line_content": "        p->ClearFlag(Page::COMPACTION_WAS_ABORTED);",
          "new_line_content": "      // Important: skip list should be cleared only after roots were updated",
          "content_same": false
        },
        {
          "line": 1535,
          "old_api": "rmode",
          "new_api": null,
          "old_text": "rinfo->rmode()",
          "new_text": null,
          "old_line_content": "    DCHECK(rinfo->rmode() == RelocInfo::EMBEDDED_OBJECT);",
          "new_line_content": "    // The target is always in old space, we don't have to record the slot in",
          "content_same": false
        },
        {
          "line": 1536,
          "old_api": "target_object",
          "new_api": null,
          "old_text": "rinfo->target_object()",
          "new_text": null,
          "old_line_content": "    HeapObject* object = HeapObject::cast(rinfo->target_object());",
          "new_line_content": "    // the old-to-new remembered set.",
          "content_same": false
        },
        {
          "line": 1539,
          "old_api": "RecordRelocSlot",
          "new_api": null,
          "old_text": "collector_->RecordRelocSlot(host, rinfo, object)",
          "new_text": null,
          "old_line_content": "    collector_->RecordRelocSlot(host, rinfo, object);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3589,
          "old_api": "sweeping_in_progress",
          "new_api": null,
          "old_text": "sweeper().sweeping_in_progress()",
          "new_text": null,
          "old_line_content": "  if (FLAG_verify_heap && !sweeper().sweeping_in_progress()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3590,
          "old_api": "heap",
          "new_api": null,
          "old_text": "heap()",
          "new_text": null,
          "old_line_content": "    VerifyEvacuation(heap());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": "heap",
          "new_api": null,
          "old_text": "collector_->heap()->InNewSpace(cell)",
          "new_text": null,
          "old_line_content": "    DCHECK(!collector_->heap()->InNewSpace(cell));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": "RecordRelocSlot",
          "new_api": null,
          "old_text": "collector_->RecordRelocSlot(host, rinfo, cell)",
          "new_text": null,
          "old_line_content": "    collector_->RecordRelocSlot(host, rinfo, cell);",
          "new_line_content": "  inline void VisitCell(RelocInfo* rinfo) final {",
          "content_same": false
        },
        {
          "line": 1554,
          "old_api": "rmode",
          "new_api": null,
          "old_text": "rinfo->rmode()",
          "new_text": null,
          "old_line_content": "    DCHECK(RelocInfo::IsCodeAgeSequence(rinfo->rmode()));",
          "new_line_content": "    // the old-to-new remembered set.",
          "content_same": false
        },
        {
          "line": 3603,
          "old_api": "UpdateUntypedPointers",
          "new_api": null,
          "old_text": "UpdateUntypedPointers(heap, chunk)",
          "new_text": null,
          "old_line_content": "    UpdateUntypedPointers(heap, chunk);",
          "new_line_content": "class PointerUpdateJobTraits {",
          "content_same": false
        },
        {
          "line": 3604,
          "old_api": "UpdateTypedPointers",
          "new_api": null,
          "old_text": "UpdateTypedPointers(heap, chunk)",
          "new_text": null,
          "old_line_content": "    UpdateTypedPointers(heap, chunk);",
          "new_line_content": " public:",
          "content_same": false
        },
        {
          "line": 1557,
          "old_api": "address",
          "new_api": null,
          "old_text": "stub->address()",
          "new_text": null,
          "old_line_content": "    DCHECK(!Page::FromAddress(stub->address())->IsEvacuationCandidate());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3614,
          "old_api": "RememberedSet<OLD_TO_NEW>::Iterate(chunk, [heap, chunk](Address slot) {\n        return CheckAndUpdateOldToNewSlot(heap, slot);\n      })",
          "new_api": null,
          "old_text": "RememberedSet<OLD_TO_NEW>::Iterate(chunk, [heap, chunk](Address slot) {\n        return CheckAndUpdateOldToNewSlot(heap, slot);\n      })",
          "new_text": null,
          "old_line_content": "      RememberedSet<OLD_TO_NEW>::Iterate(chunk, [heap, chunk](Address slot) {",
          "new_line_content": "  static const bool NeedSequentialFinalization = false;",
          "content_same": false
        },
        {
          "line": 3615,
          "old_api": "CheckAndUpdateOldToNewSlot",
          "new_api": null,
          "old_text": "CheckAndUpdateOldToNewSlot(heap, slot)",
          "new_text": null,
          "old_line_content": "        return CheckAndUpdateOldToNewSlot(heap, slot);",
          "new_line_content": "  static void FinalizePageSequentially(Heap*, MemoryChunk*, bool, PerPageData) {",
          "content_same": false
        },
        {
          "line": 3618,
          "old_api": "RememberedSet<OLD_TO_OLD>::Iterate(chunk, [](Address slot) {\n        return UpdateSlot(reinterpret_cast<Object**>(slot));\n      })",
          "new_api": null,
          "old_text": "RememberedSet<OLD_TO_OLD>::Iterate(chunk, [](Address slot) {\n        return UpdateSlot(reinterpret_cast<Object**>(slot));\n      })",
          "new_text": null,
          "old_line_content": "      RememberedSet<OLD_TO_OLD>::Iterate(chunk, [](Address slot) {",
          "new_line_content": " private:",
          "content_same": false
        },
        {
          "line": 3619,
          "old_api": "reinterpret_cast<Object**>(slot)",
          "new_api": null,
          "old_text": "reinterpret_cast<Object**>(slot)",
          "new_text": null,
          "old_line_content": "        return UpdateSlot(reinterpret_cast<Object**>(slot));",
          "new_line_content": "  static void UpdateUntypedPointers(Heap* heap, MemoryChunk* chunk) {",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": "IsHeapObject",
          "new_api": null,
          "old_text": "value->IsHeapObject()",
          "new_text": null,
          "old_line_content": "    if (value->IsHeapObject()) {",
          "new_line_content": "  inline void VisitExternalTwoByteString(",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": "reinterpret_cast<Address>(value)",
          "new_api": null,
          "old_text": "reinterpret_cast<Address>(value)",
          "new_text": null,
          "old_line_content": "      Page* p = Page::FromAddress(reinterpret_cast<Address>(value));",
          "new_line_content": "      v8::String::ExternalStringResource** resource) final {}",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": "InNewSpace",
          "new_api": null,
          "old_text": "p->InNewSpace()",
          "new_text": null,
          "old_line_content": "      if (p->InNewSpace()) {",
          "new_line_content": "  inline void VisitInternalReference(RelocInfo* rinfo) final {}",
          "content_same": false
        },
        {
          "line": 1576,
          "old_api": "Page::FromAddress(slot)",
          "new_api": null,
          "old_text": "Page::FromAddress(slot)",
          "new_text": null,
          "old_line_content": "        RememberedSet<OLD_TO_NEW>::Insert(Page::FromAddress(slot), slot);",
          "new_line_content": "  inline void VisitEmbedderReference(Object** p, uint16_t class_id) final {}",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": "IsEvacuationCandidate",
          "new_api": null,
          "old_text": "p->IsEvacuationCandidate()",
          "new_text": null,
          "old_line_content": "      } else if (p->IsEvacuationCandidate()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": "Page::FromAddress(slot)",
          "new_api": null,
          "old_text": "Page::FromAddress(slot)",
          "new_text": null,
          "old_line_content": "        RememberedSet<OLD_TO_OLD>::Insert(Page::FromAddress(slot), slot);",
          "new_line_content": " private:",
          "content_same": false
        },
        {
          "line": 3627,
          "old_api": "RememberedSet<OLD_TO_OLD>::IterateTyped(\n          chunk, [isolate](SlotType type, Address host_addr, Address slot) {\n            return UpdateTypedSlotHelper::UpdateTypedSlot(isolate, type, slot,\n                                                          UpdateSlot);\n          })",
          "new_api": null,
          "old_text": "RememberedSet<OLD_TO_OLD>::IterateTyped(\n          chunk, [isolate](SlotType type, Address host_addr, Address slot) {\n            return UpdateTypedSlotHelper::UpdateTypedSlot(isolate, type, slot,\n                                                          UpdateSlot);\n          })",
          "new_text": null,
          "old_line_content": "      RememberedSet<OLD_TO_OLD>::IterateTyped(",
          "new_line_content": "      });",
          "content_same": false
        },
        {
          "line": 3629,
          "old_api": "UpdateTypedSlotHelper::UpdateTypedSlot(isolate, type, slot,\n                                                          UpdateSlot)",
          "new_api": null,
          "old_text": "UpdateTypedSlotHelper::UpdateTypedSlot(isolate, type, slot,\n                                                          UpdateSlot)",
          "new_text": null,
          "old_line_content": "            return UpdateTypedSlotHelper::UpdateTypedSlot(isolate, type, slot,",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3637,
          "old_api": "UpdateTypedSlotHelper::UpdateTypedSlot(\n                isolate, type, slot, [heap](Object** slot) {\n                  return CheckAndUpdateOldToNewSlot(\n                      heap, reinterpret_cast<Address>(slot));\n                })",
          "new_api": null,
          "old_text": "UpdateTypedSlotHelper::UpdateTypedSlot(\n                isolate, type, slot, [heap](Object** slot) {\n                  return CheckAndUpdateOldToNewSlot(\n                      heap, reinterpret_cast<Address>(slot));\n                })",
          "new_text": null,
          "old_line_content": "            return UpdateTypedSlotHelper::UpdateTypedSlot(",
          "new_line_content": "                                                          UpdateSlot);",
          "content_same": false
        },
        {
          "line": 3639,
          "old_api": "CheckAndUpdateOldToNewSlot",
          "new_api": null,
          "old_text": "CheckAndUpdateOldToNewSlot(\n                      heap, reinterpret_cast<Address>(slot))",
          "new_text": null,
          "old_line_content": "                  return CheckAndUpdateOldToNewSlot(",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 3648,
          "old_api": "reinterpret_cast<Object**>(slot_address)",
          "new_api": null,
          "old_text": "reinterpret_cast<Object**>(slot_address)",
          "new_text": null,
          "old_line_content": "    Object** slot = reinterpret_cast<Object**>(slot_address);",
          "new_line_content": "                });",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap->isolate()->is_profiling()",
          "new_text": null,
          "old_line_content": "            heap->isolate()->is_profiling() ||",
          "new_line_content": " protected:",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap->isolate()->logger()->is_logging_code_events()",
          "new_text": null,
          "old_line_content": "            heap->isolate()->logger()->is_logging_code_events() ||",
          "new_line_content": "  enum MigrationMode { kFast, kProfiled };",
          "content_same": false
        },
        {
          "line": 1603,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap->isolate()->heap_profiler()->is_tracking_object_moves()",
          "new_text": null,
          "old_line_content": "            heap->isolate()->heap_profiler()->is_tracking_object_moves()) {}",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3649,
          "old_api": "InFromSpace",
          "new_api": null,
          "old_text": "heap->InFromSpace(*slot)",
          "new_text": null,
          "old_line_content": "    if (heap->InFromSpace(*slot)) {",
          "new_line_content": "          });",
          "content_same": false
        },
        {
          "line": 3650,
          "old_api": "reinterpret_cast<HeapObject*>(*slot)",
          "new_api": null,
          "old_text": "reinterpret_cast<HeapObject*>(*slot)",
          "new_text": null,
          "old_line_content": "      HeapObject* heap_object = reinterpret_cast<HeapObject*>(*slot);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3651,
          "old_api": "IsHeapObject",
          "new_api": null,
          "old_text": "heap_object->IsHeapObject()",
          "new_text": null,
          "old_line_content": "      DCHECK(heap_object->IsHeapObject());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3652,
          "old_api": "map_word",
          "new_api": null,
          "old_text": "heap_object->map_word()",
          "new_text": null,
          "old_line_content": "      MapWord map_word = heap_object->map_word();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1611,
          "old_api": "RequiredAlignment",
          "new_api": null,
          "old_text": "object->RequiredAlignment()",
          "new_text": null,
          "old_line_content": "    AllocationAlignment alignment = object->RequiredAlignment();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": "AllocateRaw",
          "new_api": null,
          "old_text": "target_space->AllocateRaw(size, alignment)",
          "new_text": null,
          "old_line_content": "    AllocationResult allocation = target_space->AllocateRaw(size, alignment);",
          "new_line_content": "  inline bool TryEvacuateObject(PagedSpace* target_space, HeapObject* object,",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": "To",
          "new_api": null,
          "old_text": "allocation.To(target_object)",
          "new_text": null,
          "old_line_content": "    if (allocation.To(target_object)) {",
          "new_line_content": "                                HeapObject** target_object) {",
          "content_same": false
        },
        {
          "line": 1614,
          "old_api": "identity",
          "new_api": null,
          "old_text": "target_space->identity()",
          "new_text": null,
          "old_line_content": "      MigrateObject(*target_object, object, size, target_space->identity());",
          "new_line_content": "#ifdef VERIFY_HEAP",
          "content_same": false
        },
        {
          "line": 3663,
          "old_api": "InToSpace",
          "new_api": null,
          "old_text": "heap->InToSpace(*slot)",
          "new_text": null,
          "old_line_content": "      if (heap->InToSpace(*slot)) {",
          "new_line_content": "        // Update the corresponding slot.",
          "content_same": false
        },
        {
          "line": 3666,
          "old_api": "InToSpace",
          "new_api": null,
          "old_text": "heap->InToSpace(*slot)",
          "new_text": null,
          "old_line_content": "    } else if (heap->InToSpace(*slot)) {",
          "new_line_content": "      // If the object was in from space before and is after executing the",
          "content_same": false
        },
        {
          "line": 1623,
          "old_api": "MigrateObject<kProfiled>(dst, src, size, dest)",
          "new_api": null,
          "old_text": "MigrateObject<kProfiled>(dst, src, size, dest)",
          "new_text": null,
          "old_line_content": "      MigrateObject<kProfiled>(dst, src, size, dest);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3671,
          "old_api": "Marking::IsBlack(\n              ObjectMarking::MarkBitFrom(reinterpret_cast<HeapObject*>(*slot)))",
          "new_api": null,
          "old_text": "Marking::IsBlack(\n              ObjectMarking::MarkBitFrom(reinterpret_cast<HeapObject*>(*slot)))",
          "new_text": null,
          "old_line_content": "      if (Marking::IsBlack(",
          "new_line_content": "        return KEEP_SLOT;",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": "MigrateObject<kFast>(dst, src, size, dest)",
          "new_api": null,
          "old_text": "MigrateObject<kFast>(dst, src, size, dest)",
          "new_text": null,
          "old_line_content": "      MigrateObject<kFast>(dst, src, size, dest);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3672,
          "old_api": "reinterpret_cast<HeapObject*>(*slot)",
          "new_api": null,
          "old_text": "reinterpret_cast<HeapObject*>(*slot)",
          "new_text": null,
          "old_line_content": "              ObjectMarking::MarkBitFrom(reinterpret_cast<HeapObject*>(*slot))))",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3675,
          "old_api": "InNewSpace",
          "new_api": null,
          "old_text": "heap->InNewSpace(*slot)",
          "new_text": null,
          "old_line_content": "      DCHECK(!heap->InNewSpace(*slot));",
          "new_line_content": "      // slot has been recorded multiple times in the remembered set. Since",
          "content_same": false
        },
        {
          "line": 1633,
          "old_api": "address",
          "new_api": null,
          "old_text": "src->address()",
          "new_text": null,
          "old_line_content": "    Address src_addr = src->address();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": "AllowedToBeMigrated",
          "new_api": null,
          "old_text": "heap_->AllowedToBeMigrated(src, dest)",
          "new_text": null,
          "old_line_content": "    DCHECK(heap_->AllowedToBeMigrated(src, dest));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1635,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(dest != LO_SPACE)",
          "new_text": null,
          "old_line_content": "    DCHECK(dest != LO_SPACE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1637,
          "old_api": "DCHECK_OBJECT_SIZE",
          "new_api": null,
          "old_text": "DCHECK_OBJECT_SIZE(size)",
          "new_text": null,
          "old_line_content": "      DCHECK_OBJECT_SIZE(size);",
          "new_line_content": "  inline void MigrateObject(HeapObject* dst, HeapObject* src, int size,",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": "IsAligned",
          "new_api": null,
          "old_text": "IsAligned(size, kPointerSize)",
          "new_text": null,
          "old_line_content": "      DCHECK(IsAligned(size, kPointerSize));",
          "new_line_content": "                            AllocationSpace dest) {",
          "content_same": false
        },
        {
          "line": 3685,
          "old_api": "Min",
          "new_api": null,
          "old_text": "Min(kMaxTasks, (pages + kPagesPerTask - 1) / kPagesPerTask)",
          "new_text": null,
          "old_line_content": "  return Min(kMaxTasks, (pages + kPagesPerTask - 1) / kPagesPerTask);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3691,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap->isolate()->cancelable_task_manager()",
          "new_text": null,
          "old_line_content": "      heap, heap->isolate()->cancelable_task_manager(), semaphore);",
          "new_line_content": "  const int kPagesPerTask = 4;",
          "content_same": false
        },
        {
          "line": 3693,
          "old_api": "AddPage",
          "new_api": null,
          "old_text": "job.AddPage(chunk, 0)",
          "new_text": null,
          "old_line_content": "      heap, [&job](MemoryChunk* chunk) { job.AddPage(chunk, 0); });",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3694,
          "old_api": "NumberOfPages",
          "new_api": null,
          "old_text": "job.NumberOfPages()",
          "new_text": null,
          "old_line_content": "  int num_pages = job.NumberOfPages();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3695,
          "old_api": "NumberOfPointerUpdateTasks",
          "new_api": null,
          "old_text": "NumberOfPointerUpdateTasks(num_pages)",
          "new_text": null,
          "old_line_content": "  int num_tasks = NumberOfPointerUpdateTasks(num_pages);",
          "new_line_content": "template <PointerDirection direction>",
          "content_same": false
        },
        {
          "line": 3696,
          "old_api": "Run",
          "new_api": null,
          "old_text": "job.Run(num_tasks, [](int i) { return 0; })",
          "new_text": null,
          "old_line_content": "  job.Run(num_tasks, [](int i) { return 0; });",
          "new_line_content": "void UpdatePointersInParallel(Heap* heap, base::Semaphore* semaphore) {",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": "AbstractCode::cast(src)",
          "new_api": null,
          "old_text": "AbstractCode::cast(src)",
          "new_text": null,
          "old_line_content": "                CodeMoveEvent(AbstractCode::cast(src), dst_addr));",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": "Relocate",
          "new_api": null,
          "old_text": "Code::cast(dst)->Relocate(dst_addr - src_addr)",
          "new_text": null,
          "old_line_content": "      Code::cast(dst)->Relocate(dst_addr - src_addr);",
          "new_line_content": "    } else if (dest == CODE_SPACE) {",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": "map",
          "new_api": null,
          "old_text": "dst->map()->instance_type()",
          "new_text": null,
          "old_line_content": "      dst->IterateBodyFast(dst->map()->instance_type(), size, &visitor);",
          "new_line_content": "      if (mode == kProfiled) {",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(dest == NEW_SPACE)",
          "new_text": null,
          "old_line_content": "      DCHECK(dest == NEW_SPACE);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3706,
          "old_api": "IsFlagSet",
          "new_api": null,
          "old_text": "chunk->IsFlagSet(Page::PAGE_NEW_NEW_PROMOTION)",
          "new_text": null,
          "old_line_content": "    if (chunk->IsFlagSet(Page::PAGE_NEW_NEW_PROMOTION)) {",
          "new_line_content": "class ToSpacePointerUpdateJobTraits {",
          "content_same": false
        },
        {
          "line": 3709,
          "old_api": "ProcessPageInParallelVisitLive",
          "new_api": null,
          "old_text": "ProcessPageInParallelVisitLive(heap, visitor, chunk, limits)",
          "new_text": null,
          "old_line_content": "      ProcessPageInParallelVisitLive(heap, visitor, chunk, limits);",
          "new_line_content": "  typedef PointersUpdatingVisitor* PerTaskData;",
          "content_same": false
        },
        {
          "line": 3711,
          "old_api": "ProcessPageInParallelVisitAll",
          "new_api": null,
          "old_text": "ProcessPageInParallelVisitAll(heap, visitor, chunk, limits)",
          "new_text": null,
          "old_line_content": "      ProcessPageInParallelVisitAll(heap, visitor, chunk, limits);",
          "new_line_content": "  static bool ProcessPageInParallel(Heap* heap, PerTaskData visitor,",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": "static_cast<uintptr_t>(FLAG_random_seed)",
          "new_api": null,
          "old_text": "static_cast<uintptr_t>(FLAG_random_seed)",
          "new_text": null,
          "old_line_content": "      const uintptr_t mask = static_cast<uintptr_t>(FLAG_random_seed) &",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": "address",
          "new_api": null,
          "old_text": "object->address()",
          "new_text": null,
          "old_line_content": "      if ((reinterpret_cast<uintptr_t>(object->address()) &",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": "address",
          "new_api": null,
          "old_text": "object->address()",
          "new_text": null,
          "old_line_content": "        Page* page = Page::FromAddress(object->address());",
          "new_line_content": "#ifdef VERIFY_HEAP",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": "IsFlagSet",
          "new_api": null,
          "old_text": "page->IsFlagSet(Page::COMPACTION_WAS_ABORTED_FOR_TESTING)",
          "new_text": null,
          "old_line_content": "        if (page->IsFlagSet(Page::COMPACTION_WAS_ABORTED_FOR_TESTING)) {",
          "new_line_content": "  bool AbortCompactionForTesting(HeapObject* object) {",
          "content_same": false
        },
        {
          "line": 1676,
          "old_api": "ClearFlag",
          "new_api": null,
          "old_text": "page->ClearFlag(Page::COMPACTION_WAS_ABORTED_FOR_TESTING)",
          "new_text": null,
          "old_line_content": "          page->ClearFlag(Page::COMPACTION_WAS_ABORTED_FOR_TESTING);",
          "new_line_content": "    if (FLAG_stress_compaction) {",
          "content_same": false
        },
        {
          "line": 3725,
          "old_api": "HeapObject::FromAddress(cur)",
          "new_api": null,
          "old_text": "HeapObject::FromAddress(cur)",
          "new_text": null,
          "old_line_content": "      HeapObject* object = HeapObject::FromAddress(cur);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": "SetFlag",
          "new_api": null,
          "old_text": "page->SetFlag(Page::COMPACTION_WAS_ABORTED_FOR_TESTING)",
          "new_text": null,
          "old_line_content": "          page->SetFlag(Page::COMPACTION_WAS_ABORTED_FOR_TESTING);",
          "new_line_content": "                             Page::kPageAlignmentMask & ~kPointerAlignmentMask;",
          "content_same": false
        },
        {
          "line": 3726,
          "old_api": "map",
          "new_api": null,
          "old_text": "object->map()",
          "new_text": null,
          "old_line_content": "      Map* map = object->map();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3727,
          "old_api": "SizeFromMap",
          "new_api": null,
          "old_text": "object->SizeFromMap(map)",
          "new_text": null,
          "old_line_content": "      int size = object->SizeFromMap(map);",
          "new_line_content": " private:",
          "content_same": false
        },
        {
          "line": 3728,
          "old_api": "instance_type",
          "new_api": null,
          "old_text": "map->instance_type()",
          "new_text": null,
          "old_line_content": "      object->IterateBody(map->instance_type(), size, visitor);",
          "new_line_content": "  static void ProcessPageInParallelVisitAll(Heap* heap, PerTaskData visitor,",
          "content_same": false
        },
        {
          "line": 3738,
          "old_api": "Next",
          "new_api": null,
          "old_text": "it.Next()",
          "new_text": null,
          "old_line_content": "    while ((object = it.Next()) != NULL) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3739,
          "old_api": "map",
          "new_api": null,
          "old_text": "object->map()",
          "new_text": null,
          "old_line_content": "      Map* map = object->map();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3740,
          "old_api": "SizeFromMap",
          "new_api": null,
          "old_text": "object->SizeFromMap(map)",
          "new_text": null,
          "old_line_content": "      int size = object->SizeFromMap(map);",
          "new_line_content": "  static void ProcessPageInParallelVisitLive(Heap* heap, PerTaskData visitor,",
          "content_same": false
        },
        {
          "line": 3741,
          "old_api": "instance_type",
          "new_api": null,
          "old_text": "map->instance_type()",
          "new_text": null,
          "old_line_content": "      object->IterateBody(map->instance_type(), size, visitor);",
          "new_line_content": "                                             MemoryChunk* chunk,",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit EvacuateNewSpaceVisitor(Heap* heap,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3749,
          "old_api": "new_space",
          "new_api": null,
          "old_text": "heap->new_space()->bottom()",
          "new_text": null,
          "old_line_content": "  Address space_start = heap->new_space()->bottom();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": "LocalAllocationBuffer::InvalidBuffer()",
          "new_api": null,
          "old_text": "LocalAllocationBuffer::InvalidBuffer()",
          "new_text": null,
          "old_line_content": "        buffer_(LocalAllocationBuffer::InvalidBuffer()),",
          "new_line_content": "  static const intptr_t kLabSize = 4 * KB;",
          "content_same": false
        },
        {
          "line": 3750,
          "old_api": "new_space",
          "new_api": null,
          "old_text": "heap->new_space()->top()",
          "new_text": null,
          "old_line_content": "  Address space_end = heap->new_space()->top();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3751,
          "old_api": "NewSpacePageRange",
          "new_api": null,
          "old_text": "NewSpacePageRange(space_start, space_end)",
          "new_text": null,
          "old_line_content": "  for (Page* page : NewSpacePageRange(space_start, space_end)) {",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 3753,
          "old_api": "area_start",
          "new_api": null,
          "old_text": "page->area_start()",
          "new_text": null,
          "old_line_content": "        page->Contains(space_start) ? space_start : page->area_start();",
          "new_line_content": "void UpdateToSpacePointersInParallel(Heap* heap, base::Semaphore* semaphore) {",
          "content_same": false
        },
        {
          "line": 3754,
          "old_api": "area_end",
          "new_api": null,
          "old_text": "page->area_end()",
          "new_text": null,
          "old_line_content": "    Address end = page->Contains(space_end) ? space_end : page->area_end();",
          "new_line_content": "  PageParallelJob<ToSpacePointerUpdateJobTraits> job(",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": "Size",
          "new_api": null,
          "old_text": "object->Size()",
          "new_text": null,
          "old_line_content": "    int size = object->Size();",
          "new_line_content": "        promoted_size_(0),",
          "content_same": false
        },
        {
          "line": 3759,
          "old_api": "Run",
          "new_api": null,
          "old_text": "job.Run(num_tasks, [&visitor](int i) { return &visitor; })",
          "new_text": null,
          "old_line_content": "  job.Run(num_tasks, [&visitor](int i) { return &visitor; });",
          "new_line_content": "    Address start =",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": "address",
          "new_api": null,
          "old_text": "object->address()",
          "new_text": null,
          "old_line_content": "    if (heap_->ShouldBePromoted<DEFAULT_PROMOTION>(object->address(), size) &&",
          "new_line_content": "        local_pretenuring_feedback_(local_pretenuring_feedback) {}",
          "content_same": false
        },
        {
          "line": 1714,
          "old_api": "Get",
          "new_api": null,
          "old_text": "compaction_spaces_->Get(OLD_SPACE)",
          "new_text": null,
          "old_line_content": "        TryEvacuateObject(compaction_spaces_->Get(OLD_SPACE), object,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3763,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "  TRACE_GC(heap()->tracer(), GCTracer::Scope::MC_EVACUATE_UPDATE_POINTERS);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3768,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap()->tracer()",
          "new_text": null,
          "old_line_content": "    TRACE_GC(heap()->tracer(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3772,
          "old_api": "IterateRoots",
          "new_api": null,
          "old_text": "heap_->IterateRoots(&updating_visitor, VISIT_ALL_IN_SWEEP_NEWSPACE)",
          "new_text": null,
          "old_line_content": "    heap_->IterateRoots(&updating_visitor, VISIT_ALL_IN_SWEEP_NEWSPACE);",
          "new_line_content": "  PointersUpdatingVisitor updating_visitor;",
          "content_same": false
        },
        {
          "line": 3773,
          "old_api": "UpdatePointersInParallel<OLD_TO_NEW>(heap_, &page_parallel_job_semaphore_)",
          "new_api": null,
          "old_text": "UpdatePointersInParallel<OLD_TO_NEW>(heap_, &page_parallel_job_semaphore_)",
          "new_text": null,
          "old_line_content": "    UpdatePointersInParallel<OLD_TO_NEW>(heap_, &page_parallel_job_semaphore_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3778,
          "old_api": "tracer",
          "new_api": null,
          "old_text": "heap->tracer()",
          "new_text": null,
          "old_line_content": "    TRACE_GC(heap->tracer(),",
          "new_line_content": "    // Update roots.",
          "content_same": false
        },
        {
          "line": 1737,
          "old_api": "Size",
          "new_api": null,
          "old_text": "old_object->Size()",
          "new_text": null,
          "old_line_content": "    const int size = old_object->Size();",
          "new_line_content": "  enum NewSpaceAllocationMode {",
          "content_same": false
        },
        {
          "line": 1738,
          "old_api": "RequiredAlignment",
          "new_api": null,
          "old_text": "old_object->RequiredAlignment()",
          "new_text": null,
          "old_line_content": "    AllocationAlignment alignment = old_object->RequiredAlignment();",
          "new_line_content": "    kNonstickyBailoutOldSpace,",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": "AllocateInNewSpace",
          "new_api": null,
          "old_text": "AllocateInNewSpace(size, alignment, kNonstickyBailoutOldSpace)",
          "new_text": null,
          "old_line_content": "            AllocateInNewSpace(size, alignment, kNonstickyBailoutOldSpace);",
          "new_line_content": "                                              HeapObject** target_object) {",
          "content_same": false
        },
        {
          "line": 1748,
          "old_api": "IsRetry",
          "new_api": null,
          "old_text": "allocation.IsRetry()",
          "new_text": null,
          "old_line_content": "    if (allocation.IsRetry() || (space_to_allocate_ == OLD_SPACE)) {",
          "new_line_content": "      if (size > kMaxLabObjectSize) {",
          "content_same": false
        },
        {
          "line": 1749,
          "old_api": "AllocateInOldSpace",
          "new_api": null,
          "old_text": "AllocateInOldSpace(size, alignment)",
          "new_text": null,
          "old_line_content": "      allocation = AllocateInOldSpace(size, alignment);",
          "new_line_content": "        allocation =",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": "To",
          "new_api": null,
          "old_text": "allocation.To(target_object)",
          "new_text": null,
          "old_line_content": "    bool ok = allocation.To(target_object);",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 3799,
          "old_api": "owner",
          "new_api": null,
          "old_text": "p->owner()",
          "new_text": null,
          "old_line_content": "    PagedSpace* space = static_cast<PagedSpace*>(p->owner());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": "USE",
          "new_api": null,
          "old_text": "USE(ok)",
          "new_text": null,
          "old_line_content": "    USE(ok);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3800,
          "old_api": "ResetLiveBytes",
          "new_api": null,
          "old_text": "p->ResetLiveBytes()",
          "new_text": null,
          "old_line_content": "    p->ResetLiveBytes();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3801,
          "old_api": "SweepingDone",
          "new_api": null,
          "old_text": "p->SweepingDone()",
          "new_text": null,
          "old_line_content": "    CHECK(p->SweepingDone());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3802,
          "old_api": "ReleasePage",
          "new_api": null,
          "old_text": "space->ReleasePage(p)",
          "new_text": null,
          "old_line_content": "    space->ReleasePage(p);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3804,
          "old_api": "Rewind",
          "new_api": null,
          "old_text": "evacuation_candidates_.Rewind(0)",
          "new_text": null,
          "old_line_content": "  evacuation_candidates_.Rewind(0);",
          "new_line_content": "  for (Page* p : evacuation_candidates_) {",
          "content_same": false
        },
        {
          "line": 1761,
          "old_api": "LocalAllocationBuffer::FromResult(heap_, result, kLabSize)",
          "new_api": null,
          "old_text": "LocalAllocationBuffer::FromResult(heap_, result, kLabSize)",
          "new_text": null,
          "old_line_content": "    buffer_ = LocalAllocationBuffer::FromResult(heap_, result, kLabSize);",
          "new_line_content": "    return space_to_allocate_;",
          "content_same": false
        },
        {
          "line": 1762,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "buffer_.IsValid()",
          "new_text": null,
          "old_line_content": "    if (buffer_.IsValid()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1763,
          "old_api": "TryMerge",
          "new_api": null,
          "old_text": "buffer_.TryMerge(&saved_old_buffer)",
          "new_text": null,
          "old_line_content": "      buffer_.TryMerge(&saved_old_buffer);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3815,
          "old_api": "GetSweepingPageSafe",
          "new_api": null,
          "old_text": "GetSweepingPageSafe(identity)",
          "new_text": null,
          "old_line_content": "  while ((page = GetSweepingPageSafe(identity)) != nullptr) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3816,
          "old_api": "ParallelSweepPage",
          "new_api": null,
          "old_text": "ParallelSweepPage(page, identity)",
          "new_text": null,
          "old_line_content": "    int freed = ParallelSweepPage(page, identity);",
          "new_line_content": "int MarkCompactCollector::Sweeper::ParallelSweepSpace(AllocationSpace identity,",
          "content_same": false
        },
        {
          "line": 3818,
          "old_api": "DCHECK_GE",
          "new_api": null,
          "old_text": "DCHECK_GE(freed, 0)",
          "new_text": null,
          "old_line_content": "    DCHECK_GE(freed, 0);",
          "new_line_content": "                                                      int max_pages) {",
          "content_same": false
        },
        {
          "line": 3819,
          "old_api": "Max",
          "new_api": null,
          "old_text": "Max(max_freed, freed)",
          "new_text": null,
          "old_line_content": "    max_freed = Max(max_freed, freed);",
          "new_line_content": "  int max_freed = 0;",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": "new_space",
          "new_api": null,
          "old_text": "heap_->new_space()->AllocateRawSynchronized(size_in_bytes, alignment)",
          "new_text": null,
          "old_line_content": "        heap_->new_space()->AllocateRawSynchronized(size_in_bytes, alignment);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": "IsRetry",
          "new_api": null,
          "old_text": "allocation.IsRetry()",
          "new_text": null,
          "old_line_content": "    if (allocation.IsRetry()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1775,
          "old_api": "new_space",
          "new_api": null,
          "old_text": "heap_->new_space()->AddFreshPageSynchronized()",
          "new_text": null,
          "old_line_content": "      if (!heap_->new_space()->AddFreshPageSynchronized()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1778,
          "old_api": "new_space",
          "new_api": null,
          "old_text": "heap_->new_space()->AllocateRawSynchronized(size_in_bytes,\n                                                                 alignment)",
          "new_text": null,
          "old_line_content": "        allocation = heap_->new_space()->AllocateRawSynchronized(size_in_bytes,",
          "new_line_content": "                                             NewSpaceAllocationMode mode) {",
          "content_same": false
        },
        {
          "line": 3830,
          "old_api": "mutex",
          "new_api": null,
          "old_text": "page->mutex()->TryLock()",
          "new_text": null,
          "old_line_content": "  if (page->mutex()->TryLock()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3832,
          "old_api": "Value",
          "new_api": null,
          "old_text": "page->concurrent_sweeping_state().Value()",
          "new_text": null,
          "old_line_content": "    if (page->concurrent_sweeping_state().Value() != Page::kSweepingPending) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3833,
          "old_api": "mutex",
          "new_api": null,
          "old_text": "page->mutex()->Unlock()",
          "new_text": null,
          "old_line_content": "      page->mutex()->Unlock();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3836,
          "old_api": "SetValue",
          "new_api": null,
          "old_text": "page->concurrent_sweeping_state().SetValue(Page::kSweepingInProgress)",
          "new_text": null,
          "old_line_content": "    page->concurrent_sweeping_state().SetValue(Page::kSweepingInProgress);",
          "new_line_content": "  int max_freed = 0;",
          "content_same": false
        },
        {
          "line": 3838,
          "old_api": "Heap::ShouldZapGarbage()",
          "new_api": null,
          "old_text": "Heap::ShouldZapGarbage()",
          "new_text": null,
          "old_line_content": "        Heap::ShouldZapGarbage() ? ZAP_FREE_SPACE : IGNORE_FREE_SPACE;",
          "new_line_content": "    // If this page was already swept in the meantime, we can return here.",
          "content_same": false
        },
        {
          "line": 1791,
          "old_api": "Get",
          "new_api": null,
          "old_text": "compaction_spaces_->Get(OLD_SPACE)->AllocateRaw(size_in_bytes,\n                                                        alignment)",
          "new_text": null,
          "old_line_content": "        compaction_spaces_->Get(OLD_SPACE)->AllocateRaw(size_in_bytes,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1793,
          "old_api": "IsRetry",
          "new_api": null,
          "old_text": "allocation.IsRetry()",
          "new_text": null,
          "old_line_content": "    if (allocation.IsRetry()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1794,
          "old_api": "v8::internal::Heap::FatalProcessOutOfMemory(\n          \"MarkCompactCollector: semi-space copy, fallback in old gen\", true)",
          "new_api": null,
          "old_text": "v8::internal::Heap::FatalProcessOutOfMemory(\n          \"MarkCompactCollector: semi-space copy, fallback in old gen\", true)",
          "new_text": null,
          "old_line_content": "      v8::internal::Heap::FatalProcessOutOfMemory(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3842,
          "old_api": "RawSweep",
          "new_api": null,
          "old_text": "RawSweep(page, REBUILD_FREE_LIST, free_space_mode)",
          "new_text": null,
          "old_line_content": "      max_freed = RawSweep(page, REBUILD_FREE_LIST, free_space_mode);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3844,
          "old_api": "RawSweep",
          "new_api": null,
          "old_text": "RawSweep(page, REBUILD_FREE_LIST, free_space_mode)",
          "new_text": null,
          "old_line_content": "      max_freed = RawSweep(page, REBUILD_FREE_LIST, free_space_mode);",
          "new_line_content": "    const Sweeper::FreeSpaceTreatmentMode free_space_mode =",
          "content_same": false
        },
        {
          "line": 3846,
          "old_api": "RawSweep",
          "new_api": null,
          "old_text": "RawSweep(page, REBUILD_FREE_LIST, free_space_mode)",
          "new_text": null,
          "old_line_content": "      max_freed = RawSweep(page, REBUILD_FREE_LIST, free_space_mode);",
          "new_line_content": "    if (identity == NEW_SPACE) {",
          "content_same": false
        },
        {
          "line": 3850,
          "old_api": "Add",
          "new_api": null,
          "old_text": "swept_list_[identity].Add(page)",
          "new_text": null,
          "old_line_content": "      swept_list_[identity].Add(page);",
          "new_line_content": "    } else if (identity == CODE_SPACE) {",
          "content_same": false
        },
        {
          "line": 1803,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "buffer_.IsValid()",
          "new_text": null,
          "old_line_content": "    if (!buffer_.IsValid()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": "NewLocalAllocationBuffer",
          "new_api": null,
          "old_text": "NewLocalAllocationBuffer()",
          "new_text": null,
          "old_line_content": "      if (!NewLocalAllocationBuffer()) {",
          "new_line_content": "    return allocation;",
          "content_same": false
        },
        {
          "line": 3852,
          "old_api": "SetValue",
          "new_api": null,
          "old_text": "page->concurrent_sweeping_state().SetValue(Page::kSweepingDone)",
          "new_text": null,
          "old_line_content": "    page->concurrent_sweeping_state().SetValue(Page::kSweepingDone);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1806,
          "old_api": "AllocationResult::Retry(OLD_SPACE)",
          "new_api": null,
          "old_text": "AllocationResult::Retry(OLD_SPACE)",
          "new_text": null,
          "old_line_content": "        return AllocationResult::Retry(OLD_SPACE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": "AllocateRawAligned",
          "new_api": null,
          "old_text": "buffer_.AllocateRawAligned(size_in_bytes, alignment)",
          "new_text": null,
          "old_line_content": "    allocation = buffer_.AllocateRawAligned(size_in_bytes, alignment);",
          "new_line_content": "    AllocationResult allocation;",
          "content_same": false
        },
        {
          "line": 3861,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "sweeping_list_[space].push_back(page)",
          "new_text": null,
          "old_line_content": "  sweeping_list_[space].push_back(page);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1815,
          "old_api": "AllocateRawAligned",
          "new_api": null,
          "old_text": "buffer_.AllocateRawAligned(size_in_bytes, alignment)",
          "new_text": null,
          "old_line_content": "        allocation = buffer_.AllocateRawAligned(size_in_bytes, alignment);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3869,
          "old_api": "AddSweepingPageSafe",
          "new_api": null,
          "old_text": "AddSweepingPageSafe(space, page)",
          "new_text": null,
          "old_line_content": "  AddSweepingPageSafe(space, page);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3875,
          "old_api": "LiveBytes",
          "new_api": null,
          "old_text": "page->LiveBytes()",
          "new_text": null,
          "old_line_content": "  int to_sweep = page->area_size() - page->LiveBytes();",
          "new_line_content": "  late_pages_ = true;",
          "content_same": false
        },
        {
          "line": 3877,
          "old_api": "ShrinkSpace",
          "new_api": null,
          "old_text": "heap_->paged_space(space)->accounting_stats_.ShrinkSpace(to_sweep)",
          "new_text": null,
          "old_line_content": "    heap_->paged_space(space)->accounting_stats_.ShrinkSpace(to_sweep);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1835,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit EvacuateNewSpacePageVisitor(Heap* heap)",
          "new_line_content": "  intptr_t semispace_copied_size_;",
          "content_same": false
        },
        {
          "line": 3885,
          "old_api": "front",
          "new_api": null,
          "old_text": "sweeping_list_[space].front()",
          "new_text": null,
          "old_line_content": "    page = sweeping_list_[space].front();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3886,
          "old_api": "pop_front",
          "new_api": null,
          "old_text": "sweeping_list_[space].pop_front()",
          "new_text": null,
          "old_line_content": "    sweeping_list_[space].pop_front();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": "Unlink",
          "new_api": null,
          "old_text": "page->Unlink()",
          "new_text": null,
          "old_line_content": "    page->Unlink();",
          "new_line_content": "class MarkCompactCollector::EvacuateNewSpacePageVisitor final",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": "Page::ConvertNewToOld(page, owner)",
          "new_api": null,
          "old_text": "Page::ConvertNewToOld(page, owner)",
          "new_text": null,
          "old_line_content": "    Page* new_page = Page::ConvertNewToOld(page, owner);",
          "new_line_content": "    : public MarkCompactCollector::HeapObjectVisitor {",
          "content_same": false
        },
        {
          "line": 1841,
          "old_api": "SetFlag",
          "new_api": null,
          "old_text": "new_page->SetFlag(Page::PAGE_NEW_OLD_PROMOTION)",
          "new_text": null,
          "old_line_content": "    new_page->SetFlag(Page::PAGE_NEW_OLD_PROMOTION);",
          "new_line_content": " public:",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": "heap",
          "new_api": null,
          "old_text": "page->heap()->new_space()->MovePageFromSpaceToSpace(page)",
          "new_text": null,
          "old_line_content": "    page->heap()->new_space()->MovePageFromSpaceToSpace(page);",
          "new_line_content": "  static void MoveToOldSpace(Page* page, PagedSpace* owner) {",
          "content_same": false
        },
        {
          "line": 3894,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "sweeping_list_[space].push_back(page)",
          "new_text": null,
          "old_line_content": "  sweeping_list_[space].push_back(page);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1850,
          "old_api": "mark_compact_collector",
          "new_api": null,
          "old_text": "heap_->mark_compact_collector()",
          "new_text": null,
          "old_line_content": "    RecordMigratedSlotVisitor visitor(heap_->mark_compact_collector());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1851,
          "old_api": "IterateBodyFast",
          "new_api": null,
          "old_text": "object->IterateBodyFast(&visitor)",
          "new_text": null,
          "old_line_content": "    object->IterateBodyFast(&visitor);",
          "new_line_content": "  static void MoveToToSpace(Page* page) {",
          "content_same": false
        },
        {
          "line": 3898,
          "old_api": "ClearStats",
          "new_api": null,
          "old_text": "space->ClearStats()",
          "new_text": null,
          "old_line_content": "  space->ClearStats();",
          "new_line_content": "void MarkCompactCollector::Sweeper::AddSweepingPageSafe(AllocationSpace space,",
          "content_same": false
        },
        {
          "line": 3904,
          "old_api": "end",
          "new_api": null,
          "old_text": "space->end()",
          "new_text": null,
          "old_line_content": "  for (auto it = space->begin(); it != space->end();) {",
          "new_line_content": "void MarkCompactCollector::StartSweepSpace(PagedSpace* space) {",
          "content_same": false
        },
        {
          "line": 3906,
          "old_api": "SweepingDone",
          "new_api": null,
          "old_text": "p->SweepingDone()",
          "new_text": null,
          "old_line_content": "    DCHECK(p->SweepingDone());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3908,
          "old_api": "IsEvacuationCandidate",
          "new_api": null,
          "old_text": "p->IsEvacuationCandidate()",
          "new_text": null,
          "old_line_content": "    if (p->IsEvacuationCandidate()) {",
          "new_line_content": "  bool unused_page_present = false;",
          "content_same": false
        },
        {
          "line": 3910,
          "old_api": "length",
          "new_api": null,
          "old_text": "evacuation_candidates_.length()",
          "new_text": null,
          "old_line_content": "      DCHECK(evacuation_candidates_.length() > 0);",
          "new_line_content": "  // Loop needs to support deletion if live bytes == 0 for a page.",
          "content_same": false
        },
        {
          "line": 3914,
          "old_api": "IsFlagSet",
          "new_api": null,
          "old_text": "p->IsFlagSet(Page::NEVER_ALLOCATE_ON_PAGE)",
          "new_text": null,
          "old_line_content": "    if (p->IsFlagSet(Page::NEVER_ALLOCATE_ON_PAGE)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3919,
          "old_api": "SetValue",
          "new_api": null,
          "old_text": "p->concurrent_sweeping_state().SetValue(Page::kSweepingInProgress)",
          "new_text": null,
          "old_line_content": "      p->concurrent_sweeping_state().SetValue(Page::kSweepingInProgress);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3920,
          "old_api": "Sweeper::RawSweep(p, Sweeper::IGNORE_FREE_LIST,\n                        Heap::ShouldZapGarbage() ? Sweeper::ZAP_FREE_SPACE\n                                                 : Sweeper::IGNORE_FREE_SPACE)",
          "new_api": null,
          "old_text": "Sweeper::RawSweep(p, Sweeper::IGNORE_FREE_LIST,\n                        Heap::ShouldZapGarbage() ? Sweeper::ZAP_FREE_SPACE\n                                                 : Sweeper::IGNORE_FREE_SPACE)",
          "new_text": null,
          "old_line_content": "      Sweeper::RawSweep(p, Sweeper::IGNORE_FREE_LIST,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": "Get",
          "new_api": null,
          "old_text": "compaction_spaces_->Get(\n        Page::FromAddress(object->address())->owner()->identity())",
          "new_text": null,
          "old_line_content": "    CompactionSpace* target_space = compaction_spaces_->Get(",
          "new_line_content": "    : public MarkCompactCollector::EvacuateVisitorBase {",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": "address",
          "new_api": null,
          "old_text": "object->address()",
          "new_text": null,
          "old_line_content": "        Page::FromAddress(object->address())->owner()->identity());",
          "new_line_content": " public:",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": "TryEvacuateObject",
          "new_api": null,
          "old_text": "TryEvacuateObject(target_space, object, &target_object)",
          "new_text": null,
          "old_line_content": "    if (TryEvacuateObject(target_space, object, &target_object)) {",
          "new_line_content": "                          CompactionSpaceCollection* compaction_spaces)",
          "content_same": false
        },
        {
          "line": 1881,
          "old_api": "IsForwardingAddress",
          "new_api": null,
          "old_text": "object->map_word().IsForwardingAddress()",
          "new_text": null,
          "old_line_content": "      DCHECK(object->map_word().IsForwardingAddress());",
          "new_line_content": "      : EvacuateVisitorBase(heap, compaction_spaces) {}",
          "content_same": false
        },
        {
          "line": 3930,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "isolate()",
          "new_text": null,
          "old_line_content": "          PrintIsolate(isolate(), \"sweeping: released page: %p\",",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 3931,
          "old_api": "static_cast<void*>(p)",
          "new_api": null,
          "old_text": "static_cast<void*>(p)",
          "new_text": null,
          "old_line_content": "                       static_cast<void*>(p));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3933,
          "old_api": "ArrayBufferTracker::FreeAll(p)",
          "new_api": null,
          "old_text": "ArrayBufferTracker::FreeAll(p)",
          "new_text": null,
          "old_line_content": "        ArrayBufferTracker::FreeAll(p);",
          "new_line_content": "    // One unused page is kept, all further are released before sweeping them.",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit EvacuateRecordOnlyVisitor(Heap* heap) : heap_(heap) {}",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 1894,
          "old_api": "mark_compact_collector",
          "new_api": null,
          "old_text": "heap_->mark_compact_collector()",
          "new_text": null,
          "old_line_content": "    RecordMigratedSlotVisitor visitor(heap_->mark_compact_collector());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1895,
          "old_api": "IterateBody",
          "new_api": null,
          "old_text": "object->IterateBody(&visitor)",
          "new_text": null,
          "old_line_content": "    object->IterateBody(&visitor);",
          "new_line_content": "class MarkCompactCollector::EvacuateRecordOnlyVisitor final",
          "content_same": false
        },
        {
          "line": 3945,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "isolate()",
          "new_text": null,
          "old_line_content": "    PrintIsolate(isolate(), \"sweeping: space=%s initialized_for_sweeping=%d\",",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3946,
          "old_api": "identity",
          "new_api": null,
          "old_text": "space->identity()",
          "new_text": null,
          "old_line_content": "                 AllocationSpaceName(space->identity()), will_be_swept);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1905,
          "old_api": "DiscoverGreyObjectsOnPage",
          "new_api": null,
          "old_text": "DiscoverGreyObjectsOnPage(p)",
          "new_text": null,
          "old_line_content": "    DiscoverGreyObjectsOnPage(p);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": "IsFull",
          "new_api": null,
          "old_text": "marking_deque()->IsFull()",
          "new_text": null,
          "old_line_content": "    if (marking_deque()->IsFull()) return;",
          "new_line_content": " private:",
          "content_same": false
        },
        {
          "line": 3955,
          "old_api": "MonotonicallyIncreasingTimeInMs",
          "new_api": null,
          "old_text": "heap_->MonotonicallyIncreasingTimeInMs()",
          "new_text": null,
          "old_line_content": "    start_time = heap_->MonotonicallyIncreasingTimeInMs();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1914,
          "old_api": "DiscoverGreyObjectsOnPage",
          "new_api": null,
          "old_text": "DiscoverGreyObjectsOnPage(page)",
          "new_text": null,
          "old_line_content": "    DiscoverGreyObjectsOnPage(page);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1915,
          "old_api": "IsFull",
          "new_api": null,
          "old_text": "marking_deque()->IsFull()",
          "new_text": null,
          "old_line_content": "    if (marking_deque()->IsFull()) return;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3966,
          "old_api": "old_space",
          "new_api": null,
          "old_text": "heap()->old_space()",
          "new_text": null,
          "old_line_content": "      StartSweepSpace(heap()->old_space());",
          "new_line_content": "  state_ = SWEEP_SPACES;",
          "content_same": false
        },
        {
          "line": 1923,
          "old_api": "HeapObject::cast(o)",
          "new_api": null,
          "old_text": "HeapObject::cast(o)",
          "new_text": null,
          "old_line_content": "  HeapObject* heap_object = HeapObject::cast(o);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1924,
          "old_api": "ObjectMarking::MarkBitFrom(heap_object)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(heap_object)",
          "new_text": null,
          "old_line_content": "  MarkBit mark = ObjectMarking::MarkBitFrom(heap_object);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1925,
          "old_api": "Marking::IsWhite(mark)",
          "new_api": null,
          "old_text": "Marking::IsWhite(mark)",
          "new_text": null,
          "old_line_content": "  return Marking::IsWhite(mark);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3971,
          "old_api": "code_space",
          "new_api": null,
          "old_text": "heap()->code_space()",
          "new_text": null,
          "old_line_content": "      StartSweepSpace(heap()->code_space());",
          "new_line_content": "      GCTracer::Scope sweep_scope(heap()->tracer(),",
          "content_same": false
        },
        {
          "line": 3976,
          "old_api": "map_space",
          "new_api": null,
          "old_text": "heap()->map_space()",
          "new_text": null,
          "old_line_content": "      StartSweepSpace(heap()->map_space());",
          "new_line_content": "      GCTracer::Scope sweep_scope(heap()->tracer(),",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": "HeapObject::cast(o)",
          "new_api": null,
          "old_text": "HeapObject::cast(o)",
          "new_text": null,
          "old_line_content": "  HeapObject* heap_object = HeapObject::cast(o);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1934,
          "old_api": "ObjectMarking::MarkBitFrom(heap_object)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(heap_object)",
          "new_text": null,
          "old_line_content": "  MarkBit mark = ObjectMarking::MarkBitFrom(heap_object);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1935,
          "old_api": "Marking::IsWhite(mark)",
          "new_api": null,
          "old_text": "Marking::IsWhite(mark)",
          "new_text": null,
          "old_line_content": "  return Marking::IsWhite(mark);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3982,
          "old_api": "lo_space",
          "new_api": null,
          "old_text": "heap_->lo_space()->FreeUnmarkedObjects()",
          "new_text": null,
          "old_line_content": "  heap_->lo_space()->FreeUnmarkedObjects();",
          "new_line_content": "                                  GCTracer::Scope::MC_SWEEP_MAP);",
          "content_same": false
        },
        {
          "line": 3990,
          "old_api": "isolate",
          "new_api": null,
          "old_text": "heap_->isolate()",
          "new_text": null,
          "old_line_content": "Isolate* MarkCompactCollector::isolate() const { return heap_->isolate(); }",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1943,
          "old_api": "Marking::IsWhite(string_table_mark)",
          "new_api": null,
          "old_text": "Marking::IsWhite(string_table_mark)",
          "new_text": null,
          "old_line_content": "  if (Marking::IsWhite(string_table_mark)) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1945,
          "old_api": "SetMark",
          "new_api": null,
          "old_text": "SetMark(string_table, string_table_mark)",
          "new_text": null,
          "old_line_content": "    SetMark(string_table, string_table_mark);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3994,
          "old_api": "MarkCompactMarkingVisitor::Initialize()",
          "new_api": null,
          "old_text": "MarkCompactMarkingVisitor::Initialize()",
          "new_text": null,
          "old_line_content": "  MarkCompactMarkingVisitor::Initialize();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3995,
          "old_api": "IncrementalMarking::Initialize()",
          "new_api": null,
          "old_text": "IncrementalMarking::Initialize()",
          "new_text": null,
          "old_line_content": "  IncrementalMarking::Initialize();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1948,
          "old_api": "IteratePrefix",
          "new_api": null,
          "old_text": "string_table->IteratePrefix(visitor)",
          "new_text": null,
          "old_line_content": "  string_table->IteratePrefix(visitor);",
          "new_line_content": "  // Mark the string table itself.",
          "content_same": false
        },
        {
          "line": 4000,
          "old_api": "reinterpret_cast<Address>(target)",
          "new_api": null,
          "old_text": "reinterpret_cast<Address>(target)",
          "new_text": null,
          "old_line_content": "  Page* target_page = Page::FromAddress(reinterpret_cast<Address>(target));",
          "new_line_content": "void MarkCompactCollector::Initialize() {",
          "content_same": false
        },
        {
          "line": 1954,
          "old_api": "ObjectMarking::MarkBitFrom(site)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(site)",
          "new_text": null,
          "old_line_content": "  MarkBit mark_bit = ObjectMarking::MarkBitFrom(site);",
          "new_line_content": "  // Explicitly mark the prefix.",
          "content_same": false
        },
        {
          "line": 4003,
          "old_api": "ShouldSkipEvacuationSlotRecording",
          "new_api": null,
          "old_text": "ShouldSkipEvacuationSlotRecording(host)",
          "new_text": null,
          "old_line_content": "      !ShouldSkipEvacuationSlotRecording(host)) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 4005,
          "old_api": "IsCode",
          "new_api": null,
          "old_text": "target->IsCode()",
          "new_text": null,
          "old_line_content": "    CHECK(target->IsCode());",
          "new_line_content": "void MarkCompactCollector::RecordCodeEntrySlot(HeapObject* host, Address slot,",
          "content_same": false
        },
        {
          "line": 4006,
          "old_api": "RememberedSet<OLD_TO_OLD>::InsertTyped(\n        source_page, reinterpret_cast<Address>(host), CODE_ENTRY_SLOT, slot)",
          "new_api": null,
          "old_text": "RememberedSet<OLD_TO_OLD>::InsertTyped(\n        source_page, reinterpret_cast<Address>(host), CODE_ENTRY_SLOT, slot)",
          "new_text": null,
          "old_line_content": "    RememberedSet<OLD_TO_OLD>::InsertTyped(",
          "new_line_content": "                                               Code* target) {",
          "content_same": false
        },
        {
          "line": 1965,
          "old_api": "MarkStringTable",
          "new_api": null,
          "old_text": "MarkStringTable(visitor)",
          "new_text": null,
          "old_line_content": "  MarkStringTable(visitor);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1968,
          "old_api": "overflowed",
          "new_api": null,
          "old_text": "marking_deque_.overflowed()",
          "new_text": null,
          "old_line_content": "  while (marking_deque_.overflowed()) {",
          "new_line_content": "  // etc., and all objects reachable from them.",
          "content_same": false
        },
        {
          "line": 4016,
          "old_api": "inner_pointer_to_code_cache",
          "new_api": null,
          "old_text": "isolate()->inner_pointer_to_code_cache()->GcSafeFindCodeForInnerPointer(\n            pc)",
          "new_text": null,
          "old_line_content": "        isolate()->inner_pointer_to_code_cache()->GcSafeFindCodeForInnerPointer(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1970,
          "old_api": "EmptyMarkingDeque",
          "new_api": null,
          "old_text": "EmptyMarkingDeque()",
          "new_text": null,
          "old_line_content": "    EmptyMarkingDeque();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4018,
          "old_api": "ObjectMarking::MarkBitFrom(host)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(host)",
          "new_text": null,
          "old_line_content": "    MarkBit mark_bit = ObjectMarking::MarkBitFrom(host);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4019,
          "old_api": "Marking::IsBlack(mark_bit)",
          "new_api": null,
          "old_text": "Marking::IsBlack(mark_bit)",
          "new_text": null,
          "old_line_content": "    if (Marking::IsBlack(mark_bit)) {",
          "new_line_content": "void MarkCompactCollector::RecordCodeTargetPatch(Address pc, Code* target) {",
          "content_same": false
        },
        {
          "line": 4024,
          "old_api": "RecordRelocSlot",
          "new_api": null,
          "old_text": "RecordRelocSlot(host, &rinfo, target)",
          "new_text": null,
          "old_line_content": "      RecordRelocSlot(host, &rinfo, target);",
          "new_line_content": "            pc);",
          "content_same": false
        },
        {
          "line": 1978,
          "old_api": "global_handles",
          "new_api": null,
          "old_text": "isolate()->global_handles()->implicit_ref_groups()",
          "new_text": null,
          "old_line_content": "      isolate()->global_handles()->implicit_ref_groups();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": "length",
          "new_api": null,
          "old_text": "ref_groups->length()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i < ref_groups->length(); i++) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1982,
          "old_api": "at",
          "new_api": null,
          "old_text": "ref_groups->at(i)",
          "new_text": null,
          "old_line_content": "    ImplicitRefGroup* entry = ref_groups->at(i);",
          "new_line_content": "void MarkCompactCollector::MarkImplicitRefGroups(",
          "content_same": false
        },
        {
          "line": 1983,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(entry != NULL)",
          "new_text": null,
          "old_line_content": "    DCHECK(entry != NULL);",
          "new_line_content": "    MarkObjectFunction mark_object) {",
          "content_same": false
        },
        {
          "line": 1993,
          "old_api": "IsHeapObject",
          "new_api": null,
          "old_text": "*children[j])->IsHeapObject()",
          "new_text": null,
          "old_line_content": "      if ((*children[j])->IsHeapObject()) {",
          "new_line_content": "      (*ref_groups)[last++] = entry;",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": "HeapObject::cast(*children[j])",
          "new_api": null,
          "old_text": "HeapObject::cast(*children[j])",
          "new_text": null,
          "old_line_content": "        mark_object(heap(), HeapObject::cast(*children[j]));",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 2002,
          "old_api": "Rewind",
          "new_api": null,
          "old_text": "ref_groups->Rewind(last)",
          "new_text": null,
          "old_line_content": "  ref_groups->Rewind(last);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "marking_deque_.IsEmpty()",
          "new_text": null,
          "old_line_content": "  while (!marking_deque_.IsEmpty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2012,
          "old_api": "Pop",
          "new_api": null,
          "old_text": "marking_deque_.Pop()",
          "new_text": null,
          "old_line_content": "    HeapObject* object = marking_deque_.Pop();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2014,
          "old_api": "IsFiller",
          "new_api": null,
          "old_text": "object->IsFiller()",
          "new_text": null,
          "old_line_content": "    DCHECK(!object->IsFiller());",
          "new_line_content": "// Before: the marking stack contains zero or more heap object pointers.",
          "content_same": false
        },
        {
          "line": 2015,
          "old_api": "IsHeapObject",
          "new_api": null,
          "old_text": "object->IsHeapObject()",
          "new_text": null,
          "old_line_content": "    DCHECK(object->IsHeapObject());",
          "new_line_content": "// After: the marking stack is empty, and all objects reachable from the",
          "content_same": false
        },
        {
          "line": 2016,
          "old_api": "Contains",
          "new_api": null,
          "old_text": "heap()->Contains(object)",
          "new_text": null,
          "old_line_content": "    DCHECK(heap()->Contains(object));",
          "new_line_content": "// marking stack have been marked, or are overflowed in the heap.",
          "content_same": false
        },
        {
          "line": 2017,
          "old_api": "ObjectMarking::MarkBitFrom(object)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(object)",
          "new_text": null,
          "old_line_content": "    DCHECK(!Marking::IsWhite(ObjectMarking::MarkBitFrom(object)));",
          "new_line_content": "void MarkCompactCollector::EmptyMarkingDeque() {",
          "content_same": false
        },
        {
          "line": 2020,
          "old_api": "ObjectMarking::MarkBitFrom(map)",
          "new_api": null,
          "old_text": "ObjectMarking::MarkBitFrom(map)",
          "new_text": null,
          "old_line_content": "    MarkBit map_mark = ObjectMarking::MarkBitFrom(map);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2034,
          "old_api": "CountUsage",
          "new_api": null,
          "old_text": "isolate()->CountUsage(v8::Isolate::UseCounterFeature::kMarkDequeOverflow)",
          "new_text": null,
          "old_line_content": "  isolate()->CountUsage(v8::Isolate::UseCounterFeature::kMarkDequeOverflow);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2035,
          "old_api": "overflowed",
          "new_api": null,
          "old_text": "marking_deque_.overflowed()",
          "new_text": null,
          "old_line_content": "  DCHECK(marking_deque_.overflowed());",
          "new_line_content": "// Sweep the heap for overflowed objects, clear their overflow bits, and",
          "content_same": false
        },
        {
          "line": 2037,
          "old_api": "DiscoverGreyObjectsInNewSpace",
          "new_api": null,
          "old_text": "DiscoverGreyObjectsInNewSpace()",
          "new_text": null,
          "old_line_content": "  DiscoverGreyObjectsInNewSpace();",
          "new_line_content": "// before sweeping completes.  If sweeping completes, there are no remaining",
          "content_same": false
        },
        {
          "line": 2038,
          "old_api": "IsFull",
          "new_api": null,
          "old_text": "marking_deque_.IsFull()",
          "new_text": null,
          "old_line_content": "  if (marking_deque_.IsFull()) return;",
          "new_line_content": "// overflowed objects in the heap so the overflow flag on the markings stack",
          "content_same": false
        },
        {
          "line": 2040,
          "old_api": "old_space",
          "new_api": null,
          "old_text": "heap()->old_space()",
          "new_text": null,
          "old_line_content": "  DiscoverGreyObjectsInSpace(heap()->old_space());",
          "new_line_content": "void MarkCompactCollector::RefillMarkingDeque() {",
          "content_same": false
        },
        {
          "line": 2043,
          "old_api": "code_space",
          "new_api": null,
          "old_text": "heap()->code_space()",
          "new_text": null,
          "old_line_content": "  DiscoverGreyObjectsInSpace(heap()->code_space());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": "map_space",
          "new_api": null,
          "old_text": "heap()->map_space()",
          "new_text": null,
          "old_line_content": "  DiscoverGreyObjectsInSpace(heap()->map_space());",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 381,
      "total_additions": 792,
      "total_deletions": 791,
      "total_api_changes": 1964
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 1964,
        "non_api_lines": 7,
        "non_api_line_numbers": [
          620,
          621,
          622,
          600,
          601,
          604,
          605
        ]
      }
    },
    "api_calls_before": 2065,
    "api_calls_after": 2067,
    "diff_info": {
      "added_lines": 8,
      "removed_lines": 1,
      "total_diff_lines": 30
    }
  }
}