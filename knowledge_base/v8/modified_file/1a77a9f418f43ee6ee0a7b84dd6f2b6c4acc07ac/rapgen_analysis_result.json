{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/1a77a9f418f43ee6ee0a7b84dd6f2b6c4acc07ac",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/1a77a9f418f43ee6ee0a7b84dd6f2b6c4acc07ac/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/1a77a9f418f43ee6ee0a7b84dd6f2b6c4acc07ac/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/1a77a9f418f43ee6ee0a7b84dd6f2b6c4acc07ac/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 245,
          "old_api": "uses",
          "new_api": "InputAt",
          "old_text": "loop->uses()",
          "new_text": "input->InputAt(0)",
          "old_line_content": "  for (Node* use : loop->uses()) {",
          "new_line_content": "    input = input->InputAt(0);",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": "op",
          "new_api": "zone",
          "old_text": "loop->op()->ControlInputCount()",
          "new_text": "zone()",
          "old_line_content": "  if (loop->op()->ControlInputCount() != 2) return;",
          "new_line_content": "  return new (zone()) InductionVariable(phi, effect_phi, arith, incr, initial,",
          "content_same": false
        },
        {
          "line": 260,
          "old_api": "id",
          "new_api": "zone",
          "old_text": "loop->id()",
          "new_text": "zone()",
          "old_line_content": "  TRACE(\"Loop variables for loop %i:\", loop->id());",
          "new_line_content": "                                        zone(), arithmeticType);",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": "from",
          "new_api": "op",
          "old_text": "edge.from()",
          "new_text": "loop->op()->ControlInputCount()",
          "old_line_content": "      Node* phi = edge.from();",
          "new_line_content": "  if (loop->op()->ControlInputCount() != 2) return;",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": "TryGetInductionVariable",
          "new_api": "id",
          "old_text": "TryGetInductionVariable(phi)",
          "new_text": "loop->id()",
          "old_line_content": "      InductionVariable* induction_var = TryGetInductionVariable(phi);",
          "new_line_content": "  TRACE(\"Loop variables for loop %i:\", loop->id());",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "id",
          "new_api": "NodeProperties::IsControlEdge(edge)",
          "old_text": "phi->id()",
          "new_text": "NodeProperties::IsControlEdge(edge)",
          "old_line_content": "        induction_vars_[phi->id()] = induction_var;",
          "new_line_content": "    if (NodeProperties::IsControlEdge(edge) &&",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": "phi",
          "new_api": "from",
          "old_text": "induction_var->phi()->id()",
          "new_text": "edge.from()->opcode()",
          "old_line_content": "        TRACE(\" %i\", induction_var->phi()->id());",
          "new_line_content": "        edge.from()->opcode() == IrOpcode::kPhi) {",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "TRACE",
          "new_api": "id",
          "old_text": "TRACE(\"\\n\")",
          "new_text": "phi->id()",
          "old_line_content": "  TRACE(\"\\n\");",
          "new_line_content": "        induction_vars_[phi->id()] = induction_var;",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": "zone",
          "new_api": "size",
          "old_text": "graph()->zone()",
          "new_text": "induction_var->upper_bounds().size()",
          "old_line_content": "    induction_var->phi()->InsertInput(graph()->zone(),",
          "new_line_content": "    if (induction_var->upper_bounds().size() == 0 &&",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": "phi",
          "new_api": "size",
          "old_text": "induction_var->phi()->InputCount()",
          "new_text": "induction_var->lower_bounds().size()",
          "old_line_content": "                                      induction_var->phi()->InputCount() - 1,",
          "new_line_content": "        induction_var->lower_bounds().size() == 0) {",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": "phi",
          "new_api": "zone",
          "old_text": "induction_var->phi()->InsertInput(\n          graph()->zone(), induction_var->phi()->InputCount() - 1, bound.bound)",
          "new_text": "graph()->zone()",
          "old_line_content": "      induction_var->phi()->InsertInput(",
          "new_line_content": "    induction_var->phi()->InsertInput(graph()->zone(),",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": "phi",
          "new_api": "lower_bounds",
          "old_text": "induction_var->phi()->InsertInput(\n          graph()->zone(), induction_var->phi()->InputCount() - 1, bound.bound)",
          "new_text": "induction_var->lower_bounds()",
          "old_line_content": "      induction_var->phi()->InsertInput(",
          "new_line_content": "    for (auto bound : induction_var->lower_bounds()) {",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": "phi",
          "new_api": "upper_bounds",
          "old_text": "induction_var->phi()",
          "new_text": "induction_var->upper_bounds()",
          "old_line_content": "        induction_var->phi(),",
          "new_line_content": "    for (auto bound : induction_var->upper_bounds()) {",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": "Phi",
          "new_api": "op",
          "old_text": "common()->Phi(MachineRepresentation::kTagged, value_count)",
          "new_text": "control->op()->ControlInputCount()",
          "old_line_content": "          common()->Phi(MachineRepresentation::kTagged, value_count));",
          "new_line_content": "      DCHECK_EQ(value_count, control->op()->ControlInputCount());",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "NodeProperties::GetType(backedge_value)",
          "new_api": "Phi",
          "old_text": "NodeProperties::GetType(backedge_value)",
          "new_text": "common()->Phi(MachineRepresentation::kTagged, value_count)",
          "old_line_content": "      Type* backedge_type = NodeProperties::GetType(backedge_value);",
          "new_line_content": "          common()->Phi(MachineRepresentation::kTagged, value_count));",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": "InputAt",
          "new_api": "phi",
          "old_text": "loop->InputAt(1)",
          "new_text": "induction_var->phi()->InputAt(1)",
          "old_line_content": "        Node* backedge_control = loop->InputAt(1);",
          "new_line_content": "      Node* backedge_value = induction_var->phi()->InputAt(1);",
          "content_same": false
        },
        {
          "line": 328,
          "old_api": "effect_phi",
          "new_api": "phi",
          "old_text": "induction_var->effect_phi()",
          "new_text": "induction_var->phi()",
          "old_line_content": "            NodeProperties::GetEffectInput(induction_var->effect_phi(), 1);",
          "new_line_content": "      Type* phi_type = NodeProperties::GetType(induction_var->phi());",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": "TypeGuard",
          "new_api": "phi",
          "old_text": "common()->TypeGuard(phi_type)",
          "new_text": "induction_var->phi()",
          "old_line_content": "            graph()->NewNode(common()->TypeGuard(phi_type), backedge_value,",
          "new_line_content": "        Node* loop = NodeProperties::GetControlInput(induction_var->phi());",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": "phi",
          "new_api": "effect_phi",
          "old_text": "induction_var->phi()->ReplaceInput(1, rename)",
          "new_text": "induction_var->effect_phi()",
          "old_line_content": "        induction_var->phi()->ReplaceInput(1, rename);",
          "new_line_content": "            NodeProperties::GetEffectInput(induction_var->effect_phi(), 1);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 258,
          "old_api": null,
          "new_api": "InputAt",
          "old_text": null,
          "new_text": "arith->InputAt(1)",
          "old_line_content": "void LoopVariableOptimizer::DetectInductionVariables(Node* loop) {",
          "new_line_content": "  Node* incr = arith->InputAt(1);",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": null,
          "new_api": "use_edges",
          "old_text": null,
          "new_text": "loop->use_edges()",
          "old_line_content": "      if (induction_var) {",
          "new_line_content": "  for (Edge edge : loop->use_edges()) {",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": null,
          "new_api": "from",
          "old_text": null,
          "new_text": "edge.from()",
          "old_line_content": "      }",
          "new_line_content": "      Node* phi = edge.from();",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": null,
          "new_api": "TryGetInductionVariable",
          "old_text": null,
          "new_text": "TryGetInductionVariable(phi)",
          "old_line_content": "    }",
          "new_line_content": "      InductionVariable* induction_var = TryGetInductionVariable(phi);",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": null,
          "new_api": "phi",
          "old_text": null,
          "new_text": "induction_var->phi()->id()",
          "old_line_content": "}",
          "new_line_content": "        TRACE(\" %i\", induction_var->phi()->id());",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": null,
          "new_api": "TRACE",
          "old_text": null,
          "new_text": "TRACE(\"\\n\")",
          "old_line_content": "    // It only make sense to analyze the induction variables if",
          "new_line_content": "  TRACE(\"\\n\");",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": null,
          "new_api": "phi",
          "old_text": null,
          "new_text": "DCHECK_EQ(MachineRepresentation::kTagged,\n              PhiRepresentationOf(induction_var->phi()->op()))",
          "old_line_content": "    }",
          "new_line_content": "    DCHECK_EQ(MachineRepresentation::kTagged,",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": null,
          "new_api": "phi",
          "old_text": null,
          "new_text": "induction_var->phi()->op()",
          "old_line_content": "    // Insert the increment value to the value inputs.",
          "new_line_content": "              PhiRepresentationOf(induction_var->phi()->op()));",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": null,
          "new_api": "increment",
          "old_text": null,
          "new_text": "induction_var->increment()",
          "old_line_content": "    }",
          "new_line_content": "                                      induction_var->increment());",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": null,
          "new_api": "phi",
          "old_text": null,
          "new_text": "induction_var->phi()->InputCount()",
          "old_line_content": "    }",
          "new_line_content": "          graph()->zone(), induction_var->phi()->InputCount() - 1, bound.bound);",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": null,
          "new_api": "phi",
          "old_text": null,
          "new_text": "induction_var->phi()->InputCount()",
          "old_line_content": "  }",
          "new_line_content": "          graph()->zone(), induction_var->phi()->InputCount() - 1, bound.bound);",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": null,
          "new_api": "phi",
          "old_text": null,
          "new_text": "NodeProperties::ChangeOp(\n        induction_var->phi(),\n        common()->InductionVariablePhi(induction_var->phi()->InputCount() - 1))",
          "old_line_content": "",
          "new_line_content": "    NodeProperties::ChangeOp(",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": null,
          "new_api": "phi",
          "old_text": null,
          "new_text": "induction_var->phi()",
          "old_line_content": "void LoopVariableOptimizer::ChangeToPhisAndInsertGuards() {",
          "new_line_content": "        induction_var->phi(),",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": null,
          "new_api": "phi",
          "old_text": null,
          "new_text": "induction_var->phi()->InputCount()",
          "old_line_content": "  for (auto entry : induction_vars_) {",
          "new_line_content": "        common()->InductionVariablePhi(induction_var->phi()->InputCount() - 1));",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": null,
          "new_api": "phi",
          "old_text": null,
          "new_text": "induction_var->phi()->TrimInputCount(value_count + 1)",
          "old_line_content": "",
          "new_line_content": "      induction_var->phi()->TrimInputCount(value_count + 1);",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": null,
          "new_api": "phi",
          "old_text": null,
          "new_text": "induction_var->phi()->ReplaceInput(value_count, control)",
          "old_line_content": "      // If the backedge is not a subtype of the phi's type, we insert a sigma",
          "new_line_content": "      induction_var->phi()->ReplaceInput(value_count, control);",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": null,
          "new_api": "phi",
          "old_text": null,
          "new_text": "NodeProperties::ChangeOp(\n          induction_var->phi(),\n          common()->Phi(MachineRepresentation::kTagged, value_count))",
          "old_line_content": "      // to get the typing right.",
          "new_line_content": "      NodeProperties::ChangeOp(",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": null,
          "new_api": "NodeProperties::GetType(backedge_value)",
          "old_text": null,
          "new_text": "NodeProperties::GetType(backedge_value)",
          "old_line_content": "        Node* backedge_effect =",
          "new_line_content": "      Type* backedge_type = NodeProperties::GetType(backedge_value);",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": null,
          "new_api": "Is",
          "old_text": null,
          "new_text": "backedge_type->Is(phi_type)",
          "old_line_content": "        Node* rename =",
          "new_line_content": "      if (!backedge_type->Is(phi_type)) {",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": null,
          "new_api": "InputAt",
          "old_text": null,
          "new_text": "loop->InputAt(1)",
          "old_line_content": "                             backedge_effect, backedge_control);",
          "new_line_content": "        Node* backedge_control = loop->InputAt(1);",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": null,
          "new_api": "TypeGuard",
          "old_text": null,
          "new_text": "common()->TypeGuard(phi_type)",
          "old_line_content": "    }",
          "new_line_content": "            graph()->NewNode(common()->TypeGuard(phi_type), backedge_value,",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": null,
          "new_api": "effect_phi",
          "old_text": null,
          "new_text": "induction_var->effect_phi()->ReplaceInput(1, rename)",
          "old_line_content": "}",
          "new_line_content": "        induction_var->effect_phi()->ReplaceInput(1, rename);",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": null,
          "new_api": "phi",
          "old_text": null,
          "new_text": "induction_var->phi()->ReplaceInput(1, rename)",
          "old_line_content": "",
          "new_line_content": "        induction_var->phi()->ReplaceInput(1, rename);",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "input->opcode()",
          "old_line_content": "",
          "new_line_content": "  if (input->opcode() == IrOpcode::kSpeculativeToNumber ||",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "input->opcode()",
          "old_line_content": "  Node* effect_phi = nullptr;",
          "new_line_content": "      input->opcode() == IrOpcode::kJSToNumber) {",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "loop->uses()",
          "old_line_content": "  }",
          "new_line_content": "  for (Node* use : loop->uses()) {",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "use->opcode()",
          "old_line_content": "  if (!effect_phi) return nullptr;",
          "new_line_content": "    if (use->opcode() == IrOpcode::kEffectPhi) {",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": null,
          "new_api": "DCHECK_NULL",
          "old_text": null,
          "new_text": "DCHECK_NULL(effect_phi)",
          "old_line_content": "",
          "new_line_content": "      DCHECK_NULL(effect_phi);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 261,
          "old_api": "use_edges",
          "new_api": null,
          "old_text": "loop->use_edges()",
          "new_text": null,
          "old_line_content": "  for (Edge edge : loop->use_edges()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": "NodeProperties::IsControlEdge(edge)",
          "new_api": null,
          "old_text": "NodeProperties::IsControlEdge(edge)",
          "new_text": null,
          "old_line_content": "    if (NodeProperties::IsControlEdge(edge) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 263,
          "old_api": "from",
          "new_api": null,
          "old_text": "edge.from()->opcode()",
          "new_text": null,
          "old_line_content": "        edge.from()->opcode() == IrOpcode::kPhi) {",
          "new_line_content": "void LoopVariableOptimizer::DetectInductionVariables(Node* loop) {",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": "phi",
          "new_api": null,
          "old_text": "DCHECK_EQ(MachineRepresentation::kTagged,\n              PhiRepresentationOf(induction_var->phi()->op()))",
          "new_text": null,
          "old_line_content": "    DCHECK_EQ(MachineRepresentation::kTagged,",
          "new_line_content": "void LoopVariableOptimizer::ChangeToInductionVariablePhis() {",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": "phi",
          "new_api": null,
          "old_text": "induction_var->phi()->op()",
          "new_text": null,
          "old_line_content": "              PhiRepresentationOf(induction_var->phi()->op()));",
          "new_line_content": "  for (auto entry : induction_vars_) {",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": "size",
          "new_api": null,
          "old_text": "induction_var->upper_bounds().size()",
          "new_text": null,
          "old_line_content": "    if (induction_var->upper_bounds().size() == 0 &&",
          "new_line_content": "    // It only make sense to analyze the induction variables if",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": "size",
          "new_api": null,
          "old_text": "induction_var->lower_bounds().size()",
          "new_text": null,
          "old_line_content": "        induction_var->lower_bounds().size() == 0) {",
          "new_line_content": "    // there is a bound.",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "increment",
          "new_api": null,
          "old_text": "induction_var->increment()",
          "new_text": null,
          "old_line_content": "                                      induction_var->increment());",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": "lower_bounds",
          "new_api": null,
          "old_text": "induction_var->lower_bounds()",
          "new_text": null,
          "old_line_content": "    for (auto bound : induction_var->lower_bounds()) {",
          "new_line_content": "    // Insert the increment value to the value inputs.",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": "upper_bounds",
          "new_api": null,
          "old_text": "induction_var->upper_bounds()",
          "new_text": null,
          "old_line_content": "    for (auto bound : induction_var->upper_bounds()) {",
          "new_line_content": "    // Insert the bound inputs to the value inputs.",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": "phi",
          "new_api": null,
          "old_text": "NodeProperties::ChangeOp(\n        induction_var->phi(),\n        common()->InductionVariablePhi(induction_var->phi()->InputCount() - 1))",
          "new_text": null,
          "old_line_content": "    NodeProperties::ChangeOp(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": "phi",
          "new_api": null,
          "old_text": "induction_var->phi()->opcode()",
          "new_text": null,
          "old_line_content": "    if (induction_var->phi()->opcode() == IrOpcode::kInductionVariablePhi) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": "phi",
          "new_api": null,
          "old_text": "induction_var->phi()",
          "new_text": null,
          "old_line_content": "      Node* control = NodeProperties::GetControlInput(induction_var->phi());",
          "new_line_content": "  for (auto entry : induction_vars_) {",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "op",
          "new_api": null,
          "old_text": "control->op()->ControlInputCount()",
          "new_text": null,
          "old_line_content": "      DCHECK_EQ(value_count, control->op()->ControlInputCount());",
          "new_line_content": "    InductionVariable* induction_var = entry.second;",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": "phi",
          "new_api": null,
          "old_text": "induction_var->phi()->ReplaceInput(value_count, control)",
          "new_text": null,
          "old_line_content": "      induction_var->phi()->ReplaceInput(value_count, control);",
          "new_line_content": "      // Turn the induction variable phi back to normal phi.",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": "phi",
          "new_api": null,
          "old_text": "NodeProperties::ChangeOp(\n          induction_var->phi(),\n          common()->Phi(MachineRepresentation::kTagged, value_count))",
          "new_text": null,
          "old_line_content": "      NodeProperties::ChangeOp(",
          "new_line_content": "      int value_count = 2;",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": "phi",
          "new_api": null,
          "old_text": "induction_var->phi()",
          "new_text": null,
          "old_line_content": "      Type* phi_type = NodeProperties::GetType(induction_var->phi());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": "Is",
          "new_api": null,
          "old_text": "backedge_type->Is(phi_type)",
          "new_text": null,
          "old_line_content": "      if (!backedge_type->Is(phi_type)) {",
          "new_line_content": "      // If the backedge is not a subtype of the phi's type, we insert a sigma",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": "phi",
          "new_api": null,
          "old_text": "induction_var->phi()",
          "new_text": null,
          "old_line_content": "        Node* loop = NodeProperties::GetControlInput(induction_var->phi());",
          "new_line_content": "      // to get the typing right.",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": "effect_phi",
          "new_api": null,
          "old_text": "induction_var->effect_phi()->ReplaceInput(1, rename)",
          "new_text": null,
          "old_line_content": "        induction_var->effect_phi()->ReplaceInput(1, rename);",
          "new_line_content": "        Node* backedge_effect =",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "use->opcode()",
          "new_text": null,
          "old_line_content": "    if (use->opcode() == IrOpcode::kEffectPhi) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": "DCHECK_NULL",
          "new_api": null,
          "old_text": "DCHECK_NULL(effect_phi)",
          "new_text": null,
          "old_line_content": "      DCHECK_NULL(effect_phi);",
          "new_line_content": "  if (input != phi) return nullptr;",
          "content_same": false
        },
        {
          "line": 253,
          "old_api": "InputAt",
          "new_api": null,
          "old_text": "arith->InputAt(1)",
          "new_text": null,
          "old_line_content": "  Node* incr = arith->InputAt(1);",
          "new_line_content": "      effect_phi = use;",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": "zone",
          "new_api": null,
          "old_text": "zone()",
          "new_text": null,
          "old_line_content": "  return new (zone()) InductionVariable(phi, effect_phi, arith, incr, initial,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 255,
          "old_api": "zone",
          "new_api": null,
          "old_text": "zone()",
          "new_text": null,
          "old_line_content": "                                        zone(), arithmeticType);",
          "new_line_content": "  }",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 19,
      "total_additions": 28,
      "total_deletions": 25,
      "total_api_changes": 72
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 72,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          242
        ]
      }
    },
    "api_calls_before": 211,
    "api_calls_after": 214,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 1,
      "total_diff_lines": 19
    }
  }
}