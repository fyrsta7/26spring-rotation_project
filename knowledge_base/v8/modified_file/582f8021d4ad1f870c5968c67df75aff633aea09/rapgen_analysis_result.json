{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/582f8021d4ad1f870c5968c67df75aff633aea09",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/582f8021d4ad1f870c5968c67df75aff633aea09/before.h",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/582f8021d4ad1f870c5968c67df75aff633aea09/after.h",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/582f8021d4ad1f870c5968c67df75aff633aea09/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 378,
          "old_api": "ions",
          "new_api": "ionInfo",
          "old_text": "ions() ? arg",
          "new_text": "ionInfo(const CTypeInfo& return_info, unsigned int arg_count,\n                const CTypeInfo* arg_info);\n\n  c",
          "old_line_content": "    return HasOptions() ? arg_count_ - 1 : arg_count_;",
          "new_line_content": "  CFunctionInfo(const CTypeInfo& return_info, unsigned int arg_count,",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": "ArgumentCount",
          "new_api": "nfo_",
          "old_text": "nfo_->ArgumentCount(); }\n\n ",
          "new_text": "nfo_(nullptr) {}\n\n ",
          "old_line_content": "  unsigned int ArgumentCount() const { return type_info_->ArgumentCount(); }",
          "new_line_content": "  constexpr CFunction() : address_(nullptr), type_info_(nullptr) {}",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": "GetSequenceType",
          "new_api": ">ArgumentCount()) {",
          "old_text": ">ArgumentInfo(i).GetSequenceType()) {\n  ",
          "new_text": ">ArgumentCount()) {\n  ",
          "old_line_content": "          other->ArgumentInfo(i).GetSequenceType()) {",
          "new_line_content": "    if (ArgumentCount() != other->ArgumentCount()) {",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "xpr CType",
          "new_api": "ARRAY_C_TYPES",
          "old_text": "xpr CType",
          "new_text": "ARRAY_C_TYPES(SPECIALIZE_GET_TYPE_INFO_HELPER_FOR_TA)\n\n#und",
          "old_line_content": "  static constexpr CTypeInfo::Type Type() { return CTypeInfo::Type::kVoid; }",
          "new_line_content": "TYPED_ARRAY_C_TYPES(SPECIALIZE_GET_TYPE_INFO_HELPER_FOR_TA)",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": "_ASSERT_IMPLIES",
          "new_api": "xpr CType",
          "old_text": "_ASSERT_IMPLIES(\n        uint8_t(kFlags) & uint8_t(CTypeInfo::Flags::kEnforceRangeBit),\n        CTypeInfo::IsIntegralType(kType),\n        \"kEnforceRangeBit is only allowed for integral types.\");\n    ",
          "new_text": "xpr CType",
          "old_line_content": "    STATIC_ASSERT_IMPLIES(",
          "new_line_content": "    constexpr CTypeInfo::SequenceType kSequenceType =",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": "nfo::IsFloatingPointType(kType),",
          "new_api": "nfo::IsIntegralType(kType),",
          "old_text": "nfo::IsFloatingPointType(kType),\n    ",
          "new_text": "nfo::IsIntegralType(kType),\n    ",
          "old_line_content": "        CTypeInfo::IsFloatingPointType(kType),",
          "new_line_content": "        CTypeInfo::IsIntegralType(kType),",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "lags",
          "new_api": "foHelper<T>::Type(),",
          "old_text": "lags(rest...)));\n  ",
          "new_text": "foHelper<T>::Type(),\n    ",
          "old_line_content": "    return CTypeInfo::Flags(uint8_t(flags) | uint8_t(MergeFlags(rest...)));",
          "new_line_content": "    return CTypeInfo(TypeInfoHelper<T>::Type(),",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "xpr CFunc",
          "new_api": "lags",
          "old_text": "xpr CFunc",
          "new_text": "lags(rest...)));\n  ",
          "old_line_content": "  explicit constexpr CFunctionBuilderWithFunction(const void* fn) : fn_(fn) {}",
          "new_line_content": "    return CTypeInfo::Flags(uint8_t(flags) | uint8_t(MergeFlags(rest...)));",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 386,
          "old_api": null,
          "new_api": "ions",
          "old_text": null,
          "new_text": "ions() ? arg",
          "old_line_content": "",
          "new_line_content": "    return HasOptions() ? arg_count_ - 1 : arg_count_;",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": null,
          "new_api": "GetType",
          "old_text": null,
          "new_text": "fo_[arg_count_ - 1].GetType() ==\n  ",
          "old_line_content": "};",
          "new_line_content": "    return arg_count_ > 0 && arg_info_[arg_count_ - 1].GetType() ==",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": null,
          "new_api": "xpr CType",
          "old_text": null,
          "new_text": "xpr CType",
          "old_line_content": "template <>",
          "new_line_content": "  static constexpr CTypeInfo::Flags Flags() { return CTypeInfo::Flags::kNone; }",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": null,
          "new_api": "GetFlags",
          "old_text": null,
          "new_text": "uple_element<N, std::tuple<ArgBuilders...>>::type::Build()\n            .GetFlags(),\n    ",
          "old_line_content": "  template <unsigned int N, CTypeInfo::Flags... Flags, size_t... I>",
          "new_line_content": "        std::tuple_element<N, std::tuple<ArgBuilders...>>::type::Build()",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": null,
          "new_api": "xpr CType",
          "old_text": null,
          "new_text": "xpr CType",
          "old_line_content": "",
          "new_line_content": "  static constexpr CTypeInfo::SequenceType SequenceType() {",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": null,
          "new_api": "xpr auto",
          "old_text": null,
          "new_text": "xpr auto ",
          "old_line_content": "class CFunctionBuilder {",
          "new_line_content": "  constexpr auto ArgImpl(std::index_sequence<I...>) {",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "xpr CType",
          "old_text": null,
          "new_text": "xpr CType",
          "old_line_content": "template <>",
          "new_line_content": "  static constexpr CTypeInfo::Flags Flags() { return CTypeInfo::Flags::kNone; }",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": null,
          "new_api": "ionBuilderWithFunction<\n        RetBuilder, typename GetArgBuilder<N == I, I, Flags...>::type...>(fn_);\n  }",
          "old_text": null,
          "new_text": "ionBuilderWithFunction<\n        RetBuilder, typename GetArgBuilder<N == I, I, Flags...>::type...>(fn_);\n  }\n",
          "old_line_content": " public:",
          "new_line_content": "    return CFunctionBuilderWithFunction<",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": null,
          "new_api": "xpr CType",
          "old_text": null,
          "new_text": "xpr CType",
          "old_line_content": "",
          "new_line_content": "  static constexpr CTypeInfo::SequenceType SequenceType() {",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": null,
          "new_api": "ReturnInfo",
          "old_text": null,
          "new_text": "nfo_->ReturnInfo(); }\n\n ",
          "old_line_content": "  const void* GetAddress() const { return address_; }",
          "new_line_content": "  const CTypeInfo& ReturnInfo() const { return type_info_->ReturnInfo(); }",
          "content_same": false
        },
        {
          "line": 414,
          "old_api": null,
          "new_api": "ArgumentInfo",
          "old_text": null,
          "new_text": "nfo_->ArgumentInfo(index);\n  }\n",
          "old_line_content": "  enum class OverloadResolution { kImpossible, kAtRuntime, kAtCompileTime };",
          "new_line_content": "    return type_info_->ArgumentInfo(index);",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": null,
          "new_api": "xpr int k",
          "old_text": null,
          "new_text": "xpr int k",
          "old_line_content": "                \"The receiver or the options argument is missing.\");",
          "new_line_content": "  static constexpr int kOptionsArgCount =",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": null,
          "new_api": "FastApiCallbackOptions&, ArgBuilders...>();\n  st",
          "old_text": null,
          "new_text": "FastApiCallbackOptions&, ArgBuilders...>();\n  st",
          "old_line_content": "",
          "new_line_content": "      count<FastApiCallbackOptions&, ArgBuilders...>();",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": null,
          "new_api": "xpr int k",
          "old_text": null,
          "new_text": "xpr int k",
          "old_line_content": " public:",
          "new_line_content": "  static constexpr int kReceiverCount = 1;",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": null,
          "new_api": "xpr CType",
          "old_text": null,
          "new_text": "xpr CType",
          "old_line_content": "};",
          "new_line_content": "  static constexpr CTypeInfo::Flags Flags() { return CTypeInfo::Flags::kNone; }",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": null,
          "new_api": "xpr CFunc",
          "old_text": null,
          "new_text": "xpr CFunc",
          "old_line_content": "};",
          "new_line_content": "  constexpr CFunctionBuilder() {}",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": null,
          "new_api": "xpr CType",
          "old_text": null,
          "new_text": "xpr CType",
          "old_line_content": "#define STATIC_ASSERT_IMPLIES(COND, ASSERTION, MSG) \\",
          "new_line_content": "  static constexpr CTypeInfo::Type Type() {",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": null,
          "new_api": "xpr auto",
          "old_text": null,
          "new_text": "xpr auto ",
          "old_line_content": "",
          "new_line_content": "  constexpr auto Fn(R (*fn)(Args...)) {",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": null,
          "new_api": "ionBuilderWithFunction<CTypeInfoBuilder<R>,\n                                        CTypeInfoBuilder<Args>...>(\n        reinterpret_cast<const void*>(fn));\n  }",
          "old_text": null,
          "new_text": "ionBuilderWithFunction<CTypeInfoBuilder<R>,\n                                        CTypeInfoBuilder<Args>...>(\n        reinterpret_cast<const void*>(fn));\n  }\n",
          "old_line_content": "// static",
          "new_line_content": "    return CFunctionBuilderWithFunction<CTypeInfoBuilder<R>,",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": null,
          "new_api": "xpr CType",
          "old_text": null,
          "new_text": "xpr CType",
          "old_line_content": "template <typename T, CTypeInfo::Flags... Flags>",
          "new_line_content": "  static constexpr CTypeInfo::SequenceType SequenceType() {",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": null,
          "new_api": "rpret_cast<const void*>(fn));\n  }",
          "old_text": null,
          "new_text": "rpret_cast<const void*>(fn));\n  }",
          "old_line_content": "CFunction CFunction::ArgUnwrap<R (*)(Args...)>::Make(R (*func)(Args...)) {",
          "new_line_content": "        reinterpret_cast<const void*>(fn));",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": null,
          "new_api": "ArgumentCount",
          "old_text": null,
          "new_text": "nfo_->ArgumentCount(); }\n\n ",
          "old_line_content": "  // be resolved at runtime by the RTTI available for the arguments or at",
          "new_line_content": "  unsigned int ArgumentCount() const { return type_info_->ArgumentCount(); }",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": null,
          "new_api": "xpr CFunc",
          "old_text": null,
          "new_text": "xpr CFunc",
          "old_line_content": "                      kReturnType == CTypeInfo::Type::kUint32 ||",
          "new_line_content": "  constexpr CFunctionInfoImpl()",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": null,
          "new_api": "lder::Build(), size",
          "old_text": null,
          "new_text": "lder::Build(), size",
          "old_line_content": "                      kReturnType == CTypeInfo::Type::kFloat32 ||",
          "new_line_content": "      : CFunctionInfo(RetBuilder::Build(), sizeof...(ArgBuilders),",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": null,
          "new_api": "lders::Build()...} {",
          "old_text": null,
          "new_text": "lders::Build()...} {",
          "old_line_content": "                  \"64-bit int and api object values are not currently \"",
          "new_line_content": "        arg_info_storage_{ArgBuilders::Build()...} {",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": null,
          "new_api": "GetType",
          "old_text": null,
          "new_text": "lder::Build().GetType();\n    ",
          "old_line_content": "                  \"supported return types.\");",
          "new_line_content": "    constexpr CTypeInfo::Type kReturnType = RetBuilder::Build().GetType();",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "Fn",
          "old_text": null,
          "new_text": "al::CFunctionBuilder().Fn(func).Build();\n}\n\nu",
          "old_line_content": "",
          "new_line_content": "  return internal::CFunctionBuilder().Fn(func).Build();",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": null,
          "new_api": "xpr CType",
          "old_text": null,
          "new_text": "xpr CType",
          "old_line_content": "        uint8_t(kFlags) & uint8_t(CTypeInfo::Flags::kAllowSharedBit),",
          "new_line_content": "  static constexpr CTypeInfo Build() {",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": null,
          "new_api": "xpr CType",
          "old_text": null,
          "new_text": "xpr CType",
          "old_line_content": "        (kSequenceType == CTypeInfo::SequenceType::kIsTypedArray ||",
          "new_line_content": "    constexpr CTypeInfo::Flags kFlags =",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": null,
          "new_api": "foHelper<T>::Flags(), Flag",
          "old_text": null,
          "new_text": "foHelper<T>::Flags(), Flag",
          "old_line_content": "         kSequenceType == CTypeInfo::SequenceType::kIsArrayBuffer),",
          "new_line_content": "        MergeFlags(TypeInfoHelper<T>::Flags(), Flags...);",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": null,
          "new_api": "foHelper<T>::Type();",
          "old_text": null,
          "new_text": "foHelper<T>::Type();\n    ",
          "old_line_content": "        \"kAllowSharedBit is only allowed for TypedArrays and ArrayBuffers.\");",
          "new_line_content": "    constexpr CTypeInfo::Type kType = TypeInfoHelper<T>::Type();",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": null,
          "new_api": "nfo",
          "old_text": null,
          "new_text": "nfo(CTypeInfo::Type::kInt32);\nstat",
          "old_line_content": " * The element type T of the destination array must match the C type",
          "new_line_content": "static constexpr CTypeInfo kTypeInfoInt32 = CTypeInfo(CTypeInfo::Type::kInt32);",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": null,
          "new_api": "foHelper<T>::SequenceType();",
          "old_text": null,
          "new_text": "foHelper<T>::SequenceType();\n\n   ",
          "old_line_content": "        uint8_t(kFlags) & uint8_t(CTypeInfo::Flags::kEnforceRangeBit),",
          "new_line_content": "        TypeInfoHelper<T>::SequenceType();",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "xpr CType",
          "old_text": null,
          "new_text": "xpr CType",
          "old_line_content": " * corresponding to the CTypeInfo (specified by CTypeInfoTraits).",
          "new_line_content": "static constexpr CTypeInfo kTypeInfoFloat64 =",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": null,
          "new_api": "_ASSERT_IMPLIES",
          "old_text": null,
          "new_text": "_ASSERT_IMPLIES(\n        uint8_t(kFlags) & uint8_t(CTypeInfo::Flags::kAllowSharedBit),\n        (kSequenceType == CTypeInfo::SequenceType::kIsTypedArray ||\n         kSequenceType == CTypeInfo::SequenceType::kIsArrayBuffer),\n        \"kAllowSharedBit is only allowed for TypedArrays and ArrayBuffers.\");\n    ",
          "old_line_content": "        \"kEnforceRangeBit is only allowed for integral types.\");",
          "new_line_content": "    STATIC_ASSERT_IMPLIES(",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": null,
          "new_api": "nfo",
          "old_text": null,
          "new_text": "nfo(CTypeInfo::Type::kFloat64);\n\n/**",
          "old_line_content": " * If the array length is larger than max_length or the array is of",
          "new_line_content": "    CTypeInfo(CTypeInfo::Type::kFloat64);",
          "content_same": false
        },
        {
          "line": 437,
          "old_api": null,
          "new_api": "ntCount",
          "old_text": null,
          "new_text": "ntCount(); ++i)",
          "old_line_content": "        // We only support overload resolution between sequence types.",
          "new_line_content": "    for (unsigned int i = 0; i < ArgumentCount(); ++i) {",
          "content_same": false
        },
        {
          "line": 439,
          "old_api": null,
          "new_api": "GetSequenceType",
          "old_text": null,
          "new_text": ">ArgumentInfo(i).GetSequenceType()) {\n  ",
          "old_line_content": "                CTypeInfo::SequenceType::kScalar ||",
          "new_line_content": "          other->ArgumentInfo(i).GetSequenceType()) {",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": null,
          "new_api": "GetSequenceType",
          "old_text": null,
          "new_text": "ntInfo(i).GetSequenceType() ==\n  ",
          "old_line_content": "",
          "new_line_content": "        if (ArgumentInfo(i).GetSequenceType() ==",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": null,
          "new_api": "GetSequenceType",
          "old_text": null,
          "new_text": ">ArgumentInfo(i).GetSequenceType() ==\n  ",
          "old_line_content": "  }",
          "new_line_content": "            other->ArgumentInfo(i).GetSequenceType() ==",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": null,
          "new_api": "nfo::IsIntegralType(kType),",
          "old_text": null,
          "new_text": "nfo::IsIntegralType(kType),\n    ",
          "old_line_content": "                          \"Sequences are only supported from void type.\");",
          "new_line_content": "        CTypeInfo::IsIntegralType(kType),",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": null,
          "new_api": "_ASSERT_IMPLIES",
          "old_text": null,
          "new_text": "_ASSERT_IMPLIES(\n        uint8_t(kFlags) & uint8_t(CTypeInfo::Flags::kIsRestrictedBit),\n        CTypeInfo::IsFloatingPointType(kType),\n        \"kIsRestrictedBit is only allowed for floating point types.\");\n    ",
          "old_line_content": "        kSequenceType == CTypeInfo::SequenceType::kIsTypedArray,",
          "new_line_content": "    STATIC_ASSERT_IMPLIES(",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": null,
          "new_api": "nfo::IsFloatingPointType(kType),",
          "old_text": null,
          "new_text": "nfo::IsFloatingPointType(kType),\n    ",
          "old_line_content": "        \"TypedArrays are only supported from primitive types or void.\");",
          "new_line_content": "        CTypeInfo::IsFloatingPointType(kType),",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": null,
          "new_api": "_ASSERT_IMPLIES",
          "old_text": null,
          "new_text": "_ASSERT_IMPLIES(kSequenceType == CTypeInfo::SequenceType::kIsSequence,\n                          kType == CTypeInfo::Type::kVoid,\n                          \"Sequences are only supported from void type.\");\n    ",
          "old_line_content": "    // Return the same type with the merged flags.",
          "new_line_content": "    STATIC_ASSERT_IMPLIES(kSequenceType == CTypeInfo::SequenceType::kIsSequence,",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": null,
          "new_api": "rap<F*>::Make(func);\n  }",
          "old_text": null,
          "new_text": "rap<F*>::Make(func);\n  }\n",
          "old_line_content": "",
          "new_line_content": "    return ArgUnwrap<F*>::Make(func);",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": null,
          "new_api": "_ASSERT_IMPLIES",
          "old_text": null,
          "new_text": "_ASSERT_IMPLIES(\n        kSequenceType == CTypeInfo::SequenceType::kIsTypedArray,\n        CTypeInfo::IsPrimitive(kType) || kType == CTypeInfo::Type::kVoid,\n        \"TypedArrays are only supported from primitive types or void.\");\n\n   ",
          "old_line_content": "  }",
          "new_line_content": "    STATIC_ASSERT_IMPLIES(",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "nfo::IsPrimitive(kType) || kT",
          "old_text": null,
          "new_text": "nfo::IsPrimitive(kType) || kT",
          "old_line_content": " private:",
          "new_line_content": "        CTypeInfo::IsPrimitive(kType) || kType == CTypeInfo::Type::kVoid,",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": null,
          "new_api": "rap<F*>::Make(func);\n  }",
          "old_text": null,
          "new_text": "rap<F*>::Make(func);\n  }\n",
          "old_line_content": "",
          "new_line_content": "    return ArgUnwrap<F*>::Make(func);",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": null,
          "new_api": "alignof",
          "old_text": null,
          "new_text": "alignof(T)",
          "old_line_content": "  // This pointer should include the typed array offset applied.",
          "new_line_content": "    if (reinterpret_cast<uintptr_t>(data_) % alignof(T) != 0) {",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": null,
          "new_api": "foHelper<T>::SequenceType(), kFla",
          "old_text": null,
          "new_text": "foHelper<T>::SequenceType(), kFla",
          "old_line_content": "  }",
          "new_line_content": "                     TypeInfoHelper<T>::SequenceType(), kFlags);",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": null,
          "new_api": "reinterpret_cast<T*>(data_)",
          "old_text": null,
          "new_text": "reinterpret_cast<T*>(data_)",
          "old_line_content": "  // provide a special implementation for reading from it, which hides",
          "new_line_content": "    *elements = reinterpret_cast<T*>(data_);",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "xpr CType",
          "old_text": null,
          "new_text": "xpr CType",
          "old_line_content": "class CFunctionBuilderWithFunction {",
          "new_line_content": "  static constexpr CTypeInfo::Flags MergeFlags(CTypeInfo::Flags flags,",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": null,
          "new_api": "nfo::Flags(0); }\n};",
          "old_text": null,
          "new_text": "nfo::Flags(0); }\n};",
          "old_line_content": "  template <CTypeInfo::Flags... Flags>",
          "new_line_content": "  static constexpr CTypeInfo::Flags MergeFlags() { return CTypeInfo::Flags(0); }",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "al::CTypeInfoBuilder<int32_t>::Build().GetId(), int3",
          "old_line_content": "template <>",
          "new_line_content": "    internal::CTypeInfoBuilder<int32_t>::Build().GetId(), int32_t>(",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": null,
          "new_api": "xpr CFunc",
          "old_text": null,
          "new_text": "xpr CFunc",
          "old_line_content": "",
          "new_line_content": "  explicit constexpr CFunctionBuilderWithFunction(const void* fn) : fn_(fn) {}",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": null,
          "new_api": "xpr auto",
          "old_text": null,
          "new_text": "xpr auto ",
          "old_line_content": "    // Return a copy of the builder with the Nth arg builder merged with",
          "new_line_content": "  constexpr auto Ret() {",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "ionBuilderWithFunction<\n        CTypeInfoBuilder<typename RetBuilder::BaseType, Flags...>,\n        ArgBuilders...>(fn_);\n  }",
          "old_text": null,
          "new_text": "ionBuilderWithFunction<\n        CTypeInfoBuilder<typename RetBuilder::BaseType, Flags...>,\n        ArgBuilders...>(fn_);\n  }\n",
          "old_line_content": "    // template parameter pack Flags.",
          "new_line_content": "    return CFunctionBuilderWithFunction<",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "al::CTypeInfoBuilder<uint32_t>::Build().GetId(), uint",
          "old_line_content": "template <>",
          "new_line_content": "    internal::CTypeInfoBuilder<uint32_t>::Build().GetId(), uint32_t>(",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": null,
          "new_api": "TYPES",
          "old_text": null,
          "new_text": "TYPES(SPECIALIZE_GET_TYPE_INFO_HELPER_FOR)\nPRIMI",
          "old_line_content": "  struct TypeInfoHelper<const FastApiTypedArray<T>&> {                        \\",
          "new_line_content": "ALL_C_TYPES(SPECIALIZE_GET_TYPE_INFO_HELPER_FOR)",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": null,
          "new_api": "IVE_C_TYPES",
          "old_text": null,
          "new_text": "IVE_C_TYPES(DEFINE_TYPE_INFO_TRAITS)\n\n#und",
          "old_line_content": "    static constexpr CTypeInfo::Flags Flags() {                               \\",
          "new_line_content": "PRIMITIVE_C_TYPES(DEFINE_TYPE_INFO_TRAITS)",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": null,
          "new_api": "xpr auto",
          "old_text": null,
          "new_text": "xpr auto ",
          "old_line_content": "    static CFunctionInfoImpl<RetBuilder, ArgBuilders...> instance;",
          "new_line_content": "  constexpr auto Arg() {",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "al::CTypeInfoBuilder<float>::Build().GetId(), floa",
          "old_line_content": "}  // namespace v8",
          "new_line_content": "    internal::CTypeInfoBuilder<float>::Build().GetId(), float>(",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": null,
          "new_api": "l<N, Flags...>(\n        std::make_index_sequence<sizeof...(ArgBuilders)>());\n  }",
          "old_text": null,
          "new_text": "l<N, Flags...>(\n        std::make_index_sequence<sizeof...(ArgBuilders)>());\n  }\n",
          "old_line_content": "",
          "new_line_content": "    return ArgImpl<N, Flags...>(",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": null,
          "new_api": "ake_index_sequence<sizeof...(ArgBuilders)>());\n  }",
          "old_text": null,
          "new_text": "ake_index_sequence<sizeof...(ArgBuilders)>());\n  }",
          "old_line_content": " private:",
          "new_line_content": "        std::make_index_sequence<sizeof...(ArgBuilders)>());",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "al::CTypeInfoBuilder<double>::Build().GetId(), doub",
          "old_line_content": "",
          "new_line_content": "    internal::CTypeInfoBuilder<double>::Build().GetId(), double>(",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "ion",
          "old_text": null,
          "new_text": "ion(fn_, &instance);\n  }\n",
          "old_line_content": "  // Flags in the template parameter pack are ignored.",
          "new_line_content": "    return CFunction(fn_, &instance);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 640,
          "old_api": "ARRAY_C_TYPES",
          "new_api": null,
          "old_text": "ARRAY_C_TYPES(SPECIALIZE_GET_TYPE_INFO_HELPER_FOR_TA)\n\n#und",
          "new_text": null,
          "old_line_content": "TYPED_ARRAY_C_TYPES(SPECIALIZE_GET_TYPE_INFO_HELPER_FOR_TA)",
          "new_line_content": "#define TYPED_ARRAY_C_TYPES(V) \\",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": "GetType",
          "new_api": null,
          "old_text": "fo_[arg_count_ - 1].GetType() ==\n  ",
          "new_text": null,
          "old_line_content": "    return arg_count_ > 0 && arg_info_[arg_count_ - 1].GetType() ==",
          "new_line_content": "  // |index| must be less than ArgumentCount().",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": "xpr CType",
          "new_api": null,
          "old_text": "xpr CType",
          "new_text": null,
          "old_line_content": "  static constexpr CTypeInfo::Flags Flags() { return CTypeInfo::Flags::kNone; }",
          "new_line_content": "  V(double, kFloat64)",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": "GetFlags",
          "new_api": null,
          "old_text": "uple_element<N, std::tuple<ArgBuilders...>>::type::Build()\n            .GetFlags(),\n    ",
          "new_text": null,
          "old_line_content": "        std::tuple_element<N, std::tuple<ArgBuilders...>>::type::Build()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": "xpr CType",
          "new_api": null,
          "old_text": "xpr CType",
          "new_text": null,
          "old_line_content": "  static constexpr CTypeInfo::SequenceType SequenceType() {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": "xpr auto",
          "new_api": null,
          "old_text": "xpr auto ",
          "new_text": null,
          "old_line_content": "  constexpr auto ArgImpl(std::index_sequence<I...>) {",
          "new_line_content": "            .GetFlags(),",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "ionBuilderWithFunction<\n        RetBuilder, typename GetArgBuilder<N == I, I, Flags...>::type...>(fn_);\n  }",
          "new_api": null,
          "old_text": "ionBuilderWithFunction<\n        RetBuilder, typename GetArgBuilder<N == I, I, Flags...>::type...>(fn_);\n  }\n",
          "new_text": null,
          "old_line_content": "    return CFunctionBuilderWithFunction<",
          "new_line_content": "        Flags...>;",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": "nfo_",
          "new_api": null,
          "old_text": "nfo_(nullptr) {}\n\n ",
          "new_text": null,
          "old_line_content": "  constexpr CFunction() : address_(nullptr), type_info_(nullptr) {}",
          "new_line_content": " private:",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "xpr CType",
          "new_api": null,
          "old_text": "xpr CType",
          "new_text": null,
          "old_line_content": "  static constexpr CTypeInfo::Type Type() { return CTypeInfo::Type::kUint32; }",
          "new_line_content": "    return CTypeInfo::SequenceType::kIsSequence;",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": "xpr CType",
          "new_api": null,
          "old_text": "xpr CType",
          "new_text": null,
          "old_line_content": "  static constexpr CTypeInfo::SequenceType SequenceType() {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": "ReturnInfo",
          "new_api": null,
          "old_text": "nfo_->ReturnInfo(); }\n\n ",
          "new_text": null,
          "old_line_content": "  const CTypeInfo& ReturnInfo() const { return type_info_->ReturnInfo(); }",
          "new_line_content": "  const unsigned int arg_count_;",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": "ArgumentInfo",
          "new_api": null,
          "old_text": "nfo_->ArgumentInfo(index);\n  }\n",
          "new_text": null,
          "old_line_content": "    return type_info_->ArgumentInfo(index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": "xpr int k",
          "new_api": null,
          "old_text": "xpr int k",
          "new_text": null,
          "old_line_content": "  static constexpr int kOptionsArgCount =",
          "new_line_content": "template <typename T, typename... Args>",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": "FastApiCallbackOptions&, ArgBuilders...>();\n  st",
          "new_api": null,
          "old_text": "FastApiCallbackOptions&, ArgBuilders...>();\n  st",
          "new_text": null,
          "old_line_content": "      count<FastApiCallbackOptions&, ArgBuilders...>();",
          "new_line_content": "struct count<T, T, Args...>",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "xpr int k",
          "new_api": null,
          "old_text": "xpr int k",
          "new_text": null,
          "old_line_content": "  static constexpr int kReceiverCount = 1;",
          "new_line_content": "    : std::integral_constant<std::size_t, 1 + count<T, Args...>::value> {};",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": "xpr CFunc",
          "new_api": null,
          "old_text": "xpr CFunc",
          "new_text": null,
          "old_line_content": "  constexpr CFunctionBuilder() {}",
          "new_line_content": "        RetBuilder, typename GetArgBuilder<N == I, I, Flags...>::type...>(fn_);",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": "xpr CType",
          "new_api": null,
          "old_text": "xpr CType",
          "new_text": null,
          "old_line_content": "  static constexpr CTypeInfo::Type Type() {",
          "new_line_content": "    return CTypeInfo::SequenceType::kIsTypedArray;",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "xpr auto",
          "new_api": null,
          "old_text": "xpr auto ",
          "new_text": null,
          "old_line_content": "  constexpr auto Fn(R (*fn)(Args...)) {",
          "new_line_content": "  const void* fn_;",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "ionBuilderWithFunction<CTypeInfoBuilder<R>,\n                                        CTypeInfoBuilder<Args>...>(\n        reinterpret_cast<const void*>(fn));\n  }",
          "new_api": null,
          "old_text": "ionBuilderWithFunction<CTypeInfoBuilder<R>,\n                                        CTypeInfoBuilder<Args>...>(\n        reinterpret_cast<const void*>(fn));\n  }\n",
          "new_text": null,
          "old_line_content": "    return CFunctionBuilderWithFunction<CTypeInfoBuilder<R>,",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": "xpr CType",
          "new_api": null,
          "old_text": "xpr CType",
          "new_text": null,
          "old_line_content": "  static constexpr CTypeInfo::SequenceType SequenceType() {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": "rpret_cast<const void*>(fn));\n  }",
          "new_api": null,
          "old_text": "rpret_cast<const void*>(fn));\n  }",
          "new_text": null,
          "old_line_content": "        reinterpret_cast<const void*>(fn));",
          "new_line_content": "class CFunctionBuilder {",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": "xpr CFunc",
          "new_api": null,
          "old_text": "xpr CFunc",
          "new_text": null,
          "old_line_content": "  constexpr CFunctionInfoImpl()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": "lder::Build(), size",
          "new_api": null,
          "old_text": "lder::Build(), size",
          "new_text": null,
          "old_line_content": "      : CFunctionInfo(RetBuilder::Build(), sizeof...(ArgBuilders),",
          "new_line_content": "  static_assert(kOptionsArgCount == 0 || kOptionsArgCount == 1,",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": "lders::Build()...} {",
          "new_api": null,
          "old_text": "lders::Build()...} {",
          "new_text": null,
          "old_line_content": "        arg_info_storage_{ArgBuilders::Build()...} {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": "GetType",
          "new_api": null,
          "old_text": "lder::Build().GetType();\n    ",
          "new_text": null,
          "old_line_content": "    constexpr CTypeInfo::Type kReturnType = RetBuilder::Build().GetType();",
          "new_line_content": "  static_assert(sizeof...(ArgBuilders) >= kOptionsArgCount + kReceiverCount,",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": ">ArgumentCount()) {",
          "new_api": null,
          "old_text": ">ArgumentCount()) {\n  ",
          "new_text": null,
          "old_line_content": "    if (ArgumentCount() != other->ArgumentCount()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": "Fn",
          "new_api": null,
          "old_text": "al::CFunctionBuilder().Fn(func).Build();\n}\n\nu",
          "new_text": null,
          "old_line_content": "  return internal::CFunctionBuilder().Fn(func).Build();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": "xpr CType",
          "new_api": null,
          "old_text": "xpr CType",
          "new_text": null,
          "old_line_content": "  static constexpr CTypeInfo Build() {",
          "new_line_content": "#define STATIC_ASSERT_IMPLIES(COND, ASSERTION, MSG) \\",
          "content_same": false
        },
        {
          "line": 685,
          "old_api": "xpr CType",
          "new_api": null,
          "old_text": "xpr CType",
          "new_text": null,
          "old_line_content": "    constexpr CTypeInfo::Flags kFlags =",
          "new_line_content": "  static_assert(((COND) == 0) || (ASSERTION), MSG)",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": "foHelper<T>::Flags(), Flag",
          "new_api": null,
          "old_text": "foHelper<T>::Flags(), Flag",
          "new_text": null,
          "old_line_content": "        MergeFlags(TypeInfoHelper<T>::Flags(), Flags...);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "foHelper<T>::Type();",
          "new_api": null,
          "old_text": "foHelper<T>::Type();\n    ",
          "new_text": null,
          "old_line_content": "    constexpr CTypeInfo::Type kType = TypeInfoHelper<T>::Type();",
          "new_line_content": "template <typename T, CTypeInfo::Flags... Flags>",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": "xpr CType",
          "new_api": null,
          "old_text": "xpr CType",
          "new_text": null,
          "old_line_content": "    constexpr CTypeInfo::SequenceType kSequenceType =",
          "new_line_content": "class CTypeInfoBuilder {",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": "foHelper<T>::SequenceType();",
          "new_api": null,
          "old_text": "foHelper<T>::SequenceType();\n\n   ",
          "new_text": null,
          "old_line_content": "        TypeInfoHelper<T>::SequenceType();",
          "new_line_content": " public:",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "nfo",
          "new_api": null,
          "old_text": "nfo(CTypeInfo::Type::kInt32);\nstat",
          "new_text": null,
          "old_line_content": "static constexpr CTypeInfo kTypeInfoInt32 = CTypeInfo(CTypeInfo::Type::kInt32);",
          "new_line_content": "// static",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": "_ASSERT_IMPLIES",
          "new_api": null,
          "old_text": "_ASSERT_IMPLIES(\n        uint8_t(kFlags) & uint8_t(CTypeInfo::Flags::kAllowSharedBit),\n        (kSequenceType == CTypeInfo::SequenceType::kIsTypedArray ||\n         kSequenceType == CTypeInfo::SequenceType::kIsArrayBuffer),\n        \"kAllowSharedBit is only allowed for TypedArrays and ArrayBuffers.\");\n    ",
          "new_text": null,
          "old_line_content": "    STATIC_ASSERT_IMPLIES(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": "xpr CType",
          "new_api": null,
          "old_text": "xpr CType",
          "new_text": null,
          "old_line_content": "static constexpr CTypeInfo kTypeInfoFloat64 =",
          "new_line_content": "template <typename R, typename... Args>",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "nfo",
          "new_api": null,
          "old_text": "nfo(CTypeInfo::Type::kFloat64);\n\n/**",
          "new_text": null,
          "old_line_content": "    CTypeInfo(CTypeInfo::Type::kFloat64);",
          "new_line_content": "CFunction CFunction::ArgUnwrap<R (*)(Args...)>::Make(R (*func)(Args...)) {",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": "ntCount",
          "new_api": null,
          "old_text": "ntCount(); ++i)",
          "new_text": null,
          "old_line_content": "    for (unsigned int i = 0; i < ArgumentCount(); ++i) {",
          "new_line_content": "    // same number of arguments. Functions with different arity are handled",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": "GetSequenceType",
          "new_api": null,
          "old_text": "ntInfo(i).GetSequenceType() !=\n  ",
          "new_text": null,
          "old_line_content": "      if (ArgumentInfo(i).GetSequenceType() !=",
          "new_line_content": "    // by compile time overload resolution though.",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": "GetSequenceType",
          "new_api": null,
          "old_text": ">ArgumentInfo(i).GetSequenceType() ==\n  ",
          "new_text": null,
          "old_line_content": "            other->ArgumentInfo(i).GetSequenceType() ==",
          "new_line_content": "        if (diff_index >= 0) {",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": "nfo::IsIntegralType(kType),",
          "new_api": null,
          "old_text": "nfo::IsIntegralType(kType),\n    ",
          "new_text": null,
          "old_line_content": "        CTypeInfo::IsIntegralType(kType),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": "_ASSERT_IMPLIES",
          "new_api": null,
          "old_text": "_ASSERT_IMPLIES(\n        uint8_t(kFlags) & uint8_t(CTypeInfo::Flags::kClampBit),\n        CTypeInfo::IsIntegralType(kType),\n        \"kClampBit is only allowed for integral types.\");\n    ",
          "new_text": null,
          "old_line_content": "    STATIC_ASSERT_IMPLIES(",
          "new_line_content": "        uint8_t(kFlags) & uint8_t(CTypeInfo::Flags::kAllowSharedBit),",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": "nfo::IsIntegralType(kType),",
          "new_api": null,
          "old_text": "nfo::IsIntegralType(kType),\n    ",
          "new_text": null,
          "old_line_content": "        CTypeInfo::IsIntegralType(kType),",
          "new_line_content": "         kSequenceType == CTypeInfo::SequenceType::kIsArrayBuffer),",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": "rap<F*>::Make(func);\n  }",
          "new_api": null,
          "old_text": "rap<F*>::Make(func);\n  }\n",
          "new_text": null,
          "old_line_content": "    return ArgUnwrap<F*>::Make(func);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "_ASSERT_IMPLIES",
          "new_api": null,
          "old_text": "_ASSERT_IMPLIES(\n        kSequenceType == CTypeInfo::SequenceType::kIsTypedArray,\n        CTypeInfo::IsPrimitive(kType) || kType == CTypeInfo::Type::kVoid,\n        \"TypedArrays are only supported from primitive types or void.\");\n\n   ",
          "new_text": null,
          "old_line_content": "    STATIC_ASSERT_IMPLIES(",
          "new_line_content": "        \"kClampBit is only allowed for integral types.\");",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": "nfo::IsPrimitive(kType) || kT",
          "new_api": null,
          "old_text": "nfo::IsPrimitive(kType) || kT",
          "new_text": null,
          "old_line_content": "        CTypeInfo::IsPrimitive(kType) || kType == CTypeInfo::Type::kVoid,",
          "new_line_content": "        uint8_t(kFlags) & uint8_t(CTypeInfo::Flags::kIsRestrictedBit),",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": "rap<F*>::Make(func);\n  }",
          "new_api": null,
          "old_text": "rap<F*>::Make(func);\n  }\n",
          "new_text": null,
          "old_line_content": "    return ArgUnwrap<F*>::Make(func);",
          "new_line_content": "  template <typename F>",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "foHelper<T>::Type(),",
          "new_api": null,
          "old_text": "foHelper<T>::Type(),\n    ",
          "new_text": null,
          "old_line_content": "    return CTypeInfo(TypeInfoHelper<T>::Type(),",
          "new_line_content": "                          kType == CTypeInfo::Type::kVoid,",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": "foHelper<T>::SequenceType(), kFla",
          "new_api": null,
          "old_text": "foHelper<T>::SequenceType(), kFla",
          "new_text": null,
          "old_line_content": "                     TypeInfoHelper<T>::SequenceType(), kFlags);",
          "new_line_content": "                          \"Sequences are only supported from void type.\");",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": "xpr CType",
          "new_api": null,
          "old_text": "xpr CType",
          "new_text": null,
          "old_line_content": "  static constexpr CTypeInfo::Flags MergeFlags(CTypeInfo::Flags flags,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": "nfo::Flags(0); }\n};",
          "new_api": null,
          "old_text": "nfo::Flags(0); }\n};",
          "new_text": null,
          "old_line_content": "  static constexpr CTypeInfo::Flags MergeFlags() { return CTypeInfo::Flags(0); }",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "al::CTypeInfoBuilder<int32_t>::Build().GetId(), int3",
          "new_text": null,
          "old_line_content": "    internal::CTypeInfoBuilder<int32_t>::Build().GetId(), int32_t>(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": "xpr auto",
          "new_api": null,
          "old_text": "xpr auto ",
          "new_text": null,
          "old_line_content": "  constexpr auto Ret() {",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": "ionBuilderWithFunction<\n        CTypeInfoBuilder<typename RetBuilder::BaseType, Flags...>,\n        ArgBuilders...>(fn_);\n  }",
          "new_api": null,
          "old_text": "ionBuilderWithFunction<\n        CTypeInfoBuilder<typename RetBuilder::BaseType, Flags...>,\n        ArgBuilders...>(fn_);\n  }\n",
          "new_text": null,
          "old_line_content": "    return CFunctionBuilderWithFunction<",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "al::CTypeInfoBuilder<uint32_t>::Build().GetId(), uint",
          "new_text": null,
          "old_line_content": "    internal::CTypeInfoBuilder<uint32_t>::Build().GetId(), uint32_t>(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": "TYPES",
          "new_api": null,
          "old_text": "TYPES(SPECIALIZE_GET_TYPE_INFO_HELPER_FOR)\nPRIMI",
          "new_text": null,
          "old_line_content": "ALL_C_TYPES(SPECIALIZE_GET_TYPE_INFO_HELPER_FOR)",
          "new_line_content": "  V(v8::Local<v8::Value>, kV8Value)  \\",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": "IVE_C_TYPES",
          "new_api": null,
          "old_text": "IVE_C_TYPES(DEFINE_TYPE_INFO_TRAITS)\n\n#und",
          "new_text": null,
          "old_line_content": "PRIMITIVE_C_TYPES(DEFINE_TYPE_INFO_TRAITS)",
          "new_line_content": "  V(v8::Local<v8::Object>, kV8Value) \\",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "xpr auto",
          "new_api": null,
          "old_text": "xpr auto ",
          "new_text": null,
          "old_line_content": "  constexpr auto Arg() {",
          "new_line_content": "  template <CTypeInfo::Flags... Flags>",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "al::CTypeInfoBuilder<float>::Build().GetId(), floa",
          "new_text": null,
          "old_line_content": "    internal::CTypeInfoBuilder<float>::Build().GetId(), float>(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": "l<N, Flags...>(\n        std::make_index_sequence<sizeof...(ArgBuilders)>());\n  }",
          "new_api": null,
          "old_text": "l<N, Flags...>(\n        std::make_index_sequence<sizeof...(ArgBuilders)>());\n  }\n",
          "new_text": null,
          "old_line_content": "    return ArgImpl<N, Flags...>(",
          "new_line_content": "        CTypeInfoBuilder<typename RetBuilder::BaseType, Flags...>,",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": "ake_index_sequence<sizeof...(ArgBuilders)>());\n  }",
          "new_api": null,
          "old_text": "ake_index_sequence<sizeof...(ArgBuilders)>());\n  }",
          "new_text": null,
          "old_line_content": "        std::make_index_sequence<sizeof...(ArgBuilders)>());",
          "new_line_content": "        ArgBuilders...>(fn_);",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "al::CTypeInfoBuilder<double>::Build().GetId(), doub",
          "new_text": null,
          "old_line_content": "    internal::CTypeInfoBuilder<double>::Build().GetId(), double>(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": "ion",
          "new_api": null,
          "old_text": "ion(fn_, &instance);\n  }\n",
          "new_text": null,
          "old_line_content": "    return CFunction(fn_, &instance);",
          "new_line_content": "    // Return a copy of the builder with the Nth arg builder merged with",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": "ionInfo",
          "new_api": null,
          "old_text": "ionInfo(const CTypeInfo& return_info, unsigned int arg_count,\n                const CTypeInfo* arg_info);\n\n  c",
          "new_text": null,
          "old_line_content": "  CFunctionInfo(const CTypeInfo& return_info, unsigned int arg_count,",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 8,
      "total_additions": 66,
      "total_deletions": 64,
      "total_api_changes": 138
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 138,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          338,
          340,
          341,
          343,
          344,
          345
        ]
      }
    },
    "api_calls_before": 123,
    "api_calls_after": 126,
    "diff_info": {
      "added_lines": 8,
      "removed_lines": 0,
      "total_diff_lines": 20
    }
  }
}