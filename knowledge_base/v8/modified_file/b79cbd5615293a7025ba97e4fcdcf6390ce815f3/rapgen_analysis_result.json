{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/b79cbd5615293a7025ba97e4fcdcf6390ce815f3",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/b79cbd5615293a7025ba97e4fcdcf6390ce815f3/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/b79cbd5615293a7025ba97e4fcdcf6390ce815f3/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/b79cbd5615293a7025ba97e4fcdcf6390ce815f3/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 3362,
          "old_api": "size",
          "new_api": "operands",
          "old_text": "phi->operands().size()",
          "new_text": "phi->operands()",
          "old_line_content": "  for (size_t i = 0; i < phi->operands().size(); i++) {",
          "new_line_content": "    int op = phi->operands()[i];",
          "content_same": false
        },
        {
          "line": 3363,
          "old_api": "operands",
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": "phi->operands()",
          "new_text": "data()->GetOrCreateLiveRangeFor(op)",
          "old_line_content": "    int op = phi->operands()[i];",
          "new_line_content": "    LiveRange* op_range = data()->GetOrCreateLiveRangeFor(op);",
          "content_same": false
        },
        {
          "line": 3364,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": "TopLevel",
          "old_text": "data()->GetOrCreateLiveRangeFor(op)",
          "new_text": "op_range->TopLevel()->HasSpillRange()",
          "old_line_content": "    LiveRange* op_range = data()->GetOrCreateLiveRangeFor(op);",
          "new_line_content": "    if (!op_range->TopLevel()->HasSpillRange()) continue;",
          "content_same": false
        },
        {
          "line": 3370,
          "old_api": "last_instruction_index",
          "new_api": "TopLevel",
          "old_text": "pred->last_instruction_index()",
          "new_text": "op_range->TopLevel()",
          "old_line_content": "            pred->last_instruction_index());",
          "new_line_content": "        first_op = op_range->TopLevel();",
          "content_same": false
        },
        {
          "line": 3383,
          "old_api": "size",
          "new_api": "TopLevel",
          "old_text": "phi->operands().size()",
          "new_text": "first_op->TopLevel()->GetSpillRange()",
          "old_line_content": "  if (spilled_count * 2 <= phi->operands().size()) {",
          "new_line_content": "  SpillRange* first_op_spill = first_op->TopLevel()->GetSpillRange();",
          "content_same": false
        },
        {
          "line": 3389,
          "old_api": "DCHECK_NOT_NULL",
          "new_api": "GetSpillRange",
          "old_text": "DCHECK_NOT_NULL(first_op)",
          "new_text": "op_range->GetSpillRange()",
          "old_line_content": "  DCHECK_NOT_NULL(first_op);",
          "new_line_content": "    SpillRange* op_spill = op_range->GetSpillRange();",
          "content_same": false
        },
        {
          "line": 3390,
          "old_api": "TopLevel",
          "new_api": "TryMerge",
          "old_text": "first_op->TopLevel()->GetSpillRange()",
          "new_text": "first_op_spill->TryMerge(op_spill)",
          "old_line_content": "  SpillRange* first_op_spill = first_op->TopLevel()->GetSpillRange();",
          "new_line_content": "    if (op_spill == first_op_spill || first_op_spill->TryMerge(op_spill)) {",
          "content_same": false
        },
        {
          "line": 3397,
          "old_api": "TryMerge",
          "new_api": "size",
          "old_text": "first_op_spill->TryMerge(op_spill)",
          "new_text": "phi->operands().size()",
          "old_line_content": "    if (op_spill == first_op_spill || first_op_spill->TryMerge(op_spill)) {",
          "new_line_content": "  if (num_merged * 2 <= phi->operands().size() ||",
          "content_same": false
        },
        {
          "line": 3405,
          "old_api": "interval",
          "new_api": "Start",
          "old_text": "first_op_spill->interval()",
          "new_text": "range->Start()",
          "old_line_content": "      AreUseIntervalsIntersecting(first_op_spill->interval(),",
          "new_line_content": "  LifetimePosition next_pos = range->Start();",
          "content_same": false
        },
        {
          "line": 3406,
          "old_api": "first_interval",
          "new_api": "NextStart",
          "old_text": "range->first_interval()",
          "new_text": "next_pos.NextStart()",
          "old_line_content": "                                  range->first_interval())) {",
          "new_line_content": "  if (next_pos.IsGapPosition()) next_pos = next_pos.NextStart();",
          "content_same": false
        },
        {
          "line": 3412,
          "old_api": "Start",
          "new_api": "TopLevel",
          "old_text": "range->Start()",
          "new_text": "range->TopLevel()",
          "old_line_content": "  LifetimePosition next_pos = range->Start();",
          "new_line_content": "            : data()->AssignSpillRangeToLiveRange(range->TopLevel());",
          "content_same": false
        },
        {
          "line": 3413,
          "old_api": "NextStart",
          "new_api": "TryMerge",
          "old_text": "next_pos.NextStart()",
          "new_text": "first_op_spill->TryMerge(spill_range)",
          "old_line_content": "  if (next_pos.IsGapPosition()) next_pos = next_pos.NextStart();",
          "new_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "content_same": false
        },
        {
          "line": 3417,
          "old_api": "TopLevel",
          "new_api": "NextStart",
          "old_text": "range->TopLevel()->HasSpillRange()",
          "new_text": "range->Start().NextStart()",
          "old_line_content": "        range->TopLevel()->HasSpillRange()",
          "new_line_content": "  } else if (pos->pos() > range->Start().NextStart()) {",
          "content_same": false
        },
        {
          "line": 3420,
          "old_api": "TryMerge",
          "new_api": "TopLevel",
          "old_text": "first_op_spill->TryMerge(spill_range)",
          "new_text": "range->TopLevel()->GetSpillRange()",
          "old_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "new_line_content": "            ? range->TopLevel()->GetSpillRange()",
          "content_same": false
        },
        {
          "line": 3422,
          "old_api": "Spill",
          "new_api": "TryMerge",
          "old_text": "Spill(range)",
          "new_text": "first_op_spill->TryMerge(spill_range)",
          "old_line_content": "    Spill(range);",
          "new_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "content_same": false
        },
        {
          "line": 3424,
          "old_api": "NextStart",
          "new_api": "pos",
          "old_text": "range->Start().NextStart()",
          "new_text": "pos->pos()",
          "old_line_content": "  } else if (pos->pos() > range->Start().NextStart()) {",
          "new_line_content": "    SpillBetween(range, range->Start(), pos->pos());",
          "content_same": false
        },
        {
          "line": 3439,
          "old_api": "SplitRangeAt",
          "new_api": "SpillBetweenUntil",
          "old_text": "SplitRangeAt(range, pos)",
          "new_text": "SpillBetweenUntil(range, start, start, end)",
          "old_line_content": "  LiveRange* second_part = SplitRangeAt(range, pos);",
          "new_line_content": "  SpillBetweenUntil(range, start, start, end);",
          "content_same": false
        },
        {
          "line": 3454,
          "old_api": "CHECK",
          "new_api": "PrevStart",
          "old_text": "CHECK(start < end)",
          "new_text": "end.PrevStart().End()",
          "old_line_content": "  CHECK(start < end);",
          "new_line_content": "    LifetimePosition third_part_end = end.PrevStart().End();",
          "content_same": false
        },
        {
          "line": 3455,
          "old_api": "SplitRangeAt",
          "new_api": "Start",
          "old_text": "SplitRangeAt(range, start)",
          "new_text": "end.Start()",
          "old_line_content": "  LiveRange* second_part = SplitRangeAt(range, start);",
          "new_line_content": "    if (data()->IsBlockBoundary(end.Start())) {",
          "content_same": false
        },
        {
          "line": 3461,
          "old_api": "PrevStart",
          "new_api": "DCHECK",
          "old_text": "end.PrevStart().End()",
          "new_text": "DCHECK(third_part != second_part)",
          "old_line_content": "    LifetimePosition third_part_end = end.PrevStart().End();",
          "new_line_content": "    DCHECK(third_part != second_part);",
          "content_same": false
        },
        {
          "line": 3463,
          "old_api": "Start",
          "new_api": "Spill",
          "old_text": "end.Start()",
          "new_text": "Spill(second_part)",
          "old_line_content": "      third_part_end = end.Start();",
          "new_line_content": "    Spill(second_part);",
          "content_same": false
        },
        {
          "line": 3468,
          "old_api": "DCHECK",
          "new_api": "AddToUnhandled",
          "old_text": "DCHECK(third_part != second_part)",
          "new_text": "AddToUnhandled(second_part)",
          "old_line_content": "    DCHECK(third_part != second_part);",
          "new_line_content": "    AddToUnhandled(second_part);",
          "content_same": false
        },
        {
          "line": 3485,
          "old_api": "code",
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": "data()->code()",
          "new_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "  const InstructionSequence* code = data()->code();",
          "new_line_content": "    if (!range->HasSpillRange() || range->IsSpilledOnlyInDeferredBlocks()) {",
          "content_same": false
        },
        {
          "line": 3489,
          "old_api": "size",
          "new_api": "GetSpillMoveInsertionLocations",
          "old_text": "data()->live_ranges().size()",
          "new_text": "range->GetSpillMoveInsertionLocations()",
          "old_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "new_line_content": "        range->GetSpillMoveInsertionLocations();",
          "content_same": false
        },
        {
          "line": 3490,
          "old_api": "IsEmpty",
          "new_api": "DCHECK_NOT_NULL",
          "old_text": "range->IsEmpty()",
          "new_text": "DCHECK_NOT_NULL(spills)",
          "old_line_content": "    if (range == nullptr || range->IsEmpty()) continue;",
          "new_line_content": "    DCHECK_NOT_NULL(spills);",
          "content_same": false
        },
        {
          "line": 3492,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": "GetInstructionBlock",
          "old_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": "code->GetInstructionBlock(spills->gap_index)->mark_needs_frame()",
          "old_line_content": "    if (!range->HasSpillRange() || range->IsSpilledOnlyInDeferredBlocks()) {",
          "new_line_content": "      code->GetInstructionBlock(spills->gap_index)->mark_needs_frame();",
          "content_same": false
        },
        {
          "line": 3511,
          "old_api": "size",
          "new_api": "TryMerge",
          "old_text": "spill_ranges.size()",
          "new_text": "range->TryMerge(other)",
          "old_line_content": "  for (size_t i = 0; i < spill_ranges.size(); ++i) {",
          "new_line_content": "        range->TryMerge(other);",
          "content_same": false
        },
        {
          "line": 3528,
          "old_api": "set_assigned_slot",
          "new_api": "size",
          "old_text": "range->set_assigned_slot(index)",
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "      range->set_assigned_slot(index);",
          "new_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "content_same": false
        },
        {
          "line": 3535,
          "old_api": "size",
          "new_api": "TopLevel",
          "old_text": "data()->live_ranges().size()",
          "new_text": "top_range->TopLevel()->GetSpillOperand()",
          "old_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "new_line_content": "      spill_operand = *top_range->TopLevel()->GetSpillOperand();",
          "content_same": false
        },
        {
          "line": 3536,
          "old_api": "live_ranges",
          "new_api": "TopLevel",
          "old_text": "data()->live_ranges()",
          "new_text": "top_range->TopLevel()->HasSpillRange()",
          "old_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "new_line_content": "    } else if (top_range->TopLevel()->HasSpillRange()) {",
          "content_same": false
        },
        {
          "line": 3537,
          "old_api": "size",
          "new_api": "TopLevel",
          "old_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "new_text": "top_range->TopLevel()->GetSpillRangeOperand()",
          "old_line_content": "    CHECK_EQ(live_ranges_size,",
          "new_line_content": "      spill_operand = top_range->TopLevel()->GetSpillRangeOperand();",
          "content_same": false
        },
        {
          "line": 3539,
          "old_api": "IsEmpty",
          "new_api": "is_phi",
          "old_text": "top_range->IsEmpty()",
          "new_text": "top_range->is_phi()",
          "old_line_content": "    if (top_range == nullptr || top_range->IsEmpty()) continue;",
          "new_line_content": "    if (top_range->is_phi()) {",
          "content_same": false
        },
        {
          "line": 3541,
          "old_api": "HasSpillOperand",
          "new_api": "GetAssignedOperand",
          "old_text": "top_range->HasSpillOperand()",
          "new_text": "top_range->GetAssignedOperand()",
          "old_line_content": "    if (top_range->HasSpillOperand()) {",
          "new_line_content": "          top_range->GetAssignedOperand());",
          "content_same": false
        },
        {
          "line": 3544,
          "old_api": "TopLevel",
          "new_api": "next",
          "old_text": "top_range->TopLevel()->GetSpillRangeOperand()",
          "new_text": "range->next()",
          "old_line_content": "      spill_operand = top_range->TopLevel()->GetSpillRangeOperand();",
          "new_line_content": "         range = range->next()) {",
          "content_same": false
        },
        {
          "line": 3546,
          "old_api": "is_phi",
          "new_api": "IsUnallocated",
          "old_text": "top_range->is_phi()",
          "new_text": "assigned.IsUnallocated()",
          "old_line_content": "    if (top_range->is_phi()) {",
          "new_line_content": "      DCHECK(!assigned.IsUnallocated());",
          "content_same": false
        },
        {
          "line": 3547,
          "old_api": "GetPhiMapValueFor",
          "new_api": "ConvertUsesToOperand",
          "old_text": "data()->GetPhiMapValueFor(top_range)->CommitAssignment(\n          top_range->GetAssignedOperand())",
          "new_text": "range->ConvertUsesToOperand(assigned, spill_operand)",
          "old_line_content": "      data()->GetPhiMapValueFor(top_range)->CommitAssignment(",
          "new_line_content": "      range->ConvertUsesToOperand(assigned, spill_operand);",
          "content_same": false
        },
        {
          "line": 3588,
          "old_api": "instruction_position",
          "new_api": "SafePointsAreInOrder",
          "old_text": "map->instruction_position()",
          "new_text": "SafePointsAreInOrder()",
          "old_line_content": "    safe_point = map->instruction_position();",
          "new_line_content": "  DCHECK(SafePointsAreInOrder());",
          "content_same": false
        },
        {
          "line": 3598,
          "old_api": "delayed_references",
          "new_api": "code",
          "old_text": "data()->delayed_references()",
          "new_text": "data()->code()->reference_maps()",
          "old_line_content": "       data()->delayed_references()) {",
          "new_line_content": "  const ReferenceMapDeque* reference_maps = data()->code()->reference_maps();",
          "content_same": false
        },
        {
          "line": 3599,
          "old_api": "RecordReference",
          "new_api": "begin",
          "old_text": "delayed_reference.map->RecordReference(\n        AllocatedOperand::cast(*delayed_reference.operand))",
          "new_text": "reference_maps->begin()",
          "old_line_content": "    delayed_reference.map->RecordReference(",
          "new_line_content": "  ReferenceMapDeque::const_iterator first_it = reference_maps->begin();",
          "content_same": false
        },
        {
          "line": 3600,
          "old_api": "AllocatedOperand::cast(*delayed_reference.operand)",
          "new_api": "size",
          "old_text": "AllocatedOperand::cast(*delayed_reference.operand)",
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "        AllocatedOperand::cast(*delayed_reference.operand));",
          "new_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "content_same": false
        },
        {
          "line": 3606,
          "old_api": "begin",
          "new_api": "IsReference",
          "old_text": "reference_maps->begin()",
          "new_text": "data()->IsReference(range)",
          "old_line_content": "  ReferenceMapDeque::const_iterator first_it = reference_maps->begin();",
          "new_line_content": "    if (!data()->IsReference(range)) continue;",
          "content_same": false
        },
        {
          "line": 3608,
          "old_api": "live_ranges",
          "new_api": "IsEmpty",
          "old_text": "data()->live_ranges()",
          "new_text": "range->IsEmpty()",
          "old_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "new_line_content": "    if (range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 3609,
          "old_api": "size",
          "new_api": "has_preassigned_slot",
          "old_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "new_text": "range->has_preassigned_slot()",
          "old_line_content": "    CHECK_EQ(live_ranges_size,",
          "new_line_content": "    if (range->has_preassigned_slot()) continue;",
          "content_same": false
        },
        {
          "line": 3615,
          "old_api": "IsEmpty",
          "new_api": "End",
          "old_text": "range->IsEmpty()",
          "new_text": "cur->End()",
          "old_line_content": "    if (range->IsEmpty()) continue;",
          "new_line_content": "      LifetimePosition this_end = cur->End();",
          "content_same": false
        },
        {
          "line": 3616,
          "old_api": "has_preassigned_slot",
          "new_api": "ToInstructionIndex",
          "old_text": "range->has_preassigned_slot()",
          "new_text": "this_end.ToInstructionIndex()",
          "old_line_content": "    if (range->has_preassigned_slot()) continue;",
          "new_line_content": "      if (this_end.ToInstructionIndex() > end)",
          "content_same": false
        },
        {
          "line": 3623,
          "old_api": "ToInstructionIndex",
          "new_api": "begin",
          "old_text": "this_end.ToInstructionIndex()",
          "new_text": "reference_maps->begin()",
          "old_line_content": "      if (this_end.ToInstructionIndex() > end)",
          "new_line_content": "    if (start < last_range_start) first_it = reference_maps->begin();",
          "content_same": false
        },
        {
          "line": 3630,
          "old_api": "begin",
          "new_api": "instruction_position",
          "old_text": "reference_maps->begin()",
          "new_text": "map->instruction_position()",
          "old_line_content": "    if (start < last_range_start) first_it = reference_maps->begin();",
          "new_line_content": "      if (map->instruction_position() >= start) break;",
          "content_same": false
        },
        {
          "line": 3635,
          "old_api": "end",
          "new_api": "GetSpillOperand",
          "old_text": "reference_maps->end()",
          "new_text": "range->GetSpillOperand()->IsConstant()",
          "old_line_content": "    for (; first_it != reference_maps->end(); ++first_it) {",
          "new_line_content": "          !range->GetSpillOperand()->IsConstant()) ||",
          "content_same": false
        },
        {
          "line": 3637,
          "old_api": "instruction_position",
          "new_api": "HasSpillOperand",
          "old_text": "map->instruction_position()",
          "new_text": "range->HasSpillOperand()",
          "old_line_content": "      if (map->instruction_position() >= start) break;",
          "new_line_content": "      if (range->HasSpillOperand()) {",
          "content_same": false
        },
        {
          "line": 3642,
          "old_api": "GetSpillOperand",
          "new_api": "IsStackSlot",
          "old_text": "range->GetSpillOperand()->IsConstant()",
          "new_text": "spill_operand.IsStackSlot()",
          "old_line_content": "          !range->GetSpillOperand()->IsConstant()) ||",
          "new_line_content": "      DCHECK(spill_operand.IsStackSlot());",
          "content_same": false
        },
        {
          "line": 3643,
          "old_api": "HasSpillRange",
          "new_api": "representation",
          "old_text": "range->HasSpillRange()",
          "new_text": "CanBeTaggedPointer(\n          AllocatedOperand::cast(spill_operand).representation())",
          "old_line_content": "         range->HasSpillRange())) {",
          "new_line_content": "      DCHECK(CanBeTaggedPointer(",
          "content_same": false
        },
        {
          "line": 3644,
          "old_api": "HasSpillOperand",
          "new_api": "representation",
          "old_text": "range->HasSpillOperand()",
          "new_text": "AllocatedOperand::cast(spill_operand).representation()",
          "old_line_content": "      if (range->HasSpillOperand()) {",
          "new_line_content": "          AllocatedOperand::cast(spill_operand).representation()));",
          "content_same": false
        },
        {
          "line": 3649,
          "old_api": "IsStackSlot",
          "new_api": "end",
          "old_text": "spill_operand.IsStackSlot()",
          "new_text": "reference_maps->end()",
          "old_line_content": "      DCHECK(spill_operand.IsStackSlot());",
          "new_line_content": "    for (auto it = first_it; it != reference_maps->end(); ++it) {",
          "content_same": false
        },
        {
          "line": 3651,
          "old_api": "representation",
          "new_api": "instruction_position",
          "old_text": "AllocatedOperand::cast(spill_operand).representation()",
          "new_text": "map->instruction_position()",
          "old_line_content": "          AllocatedOperand::cast(spill_operand).representation()));",
          "new_line_content": "      int safe_point = map->instruction_position();",
          "content_same": false
        },
        {
          "line": 3674,
          "old_api": "DCHECK_NOT_NULL",
          "new_api": "next",
          "old_text": "DCHECK_NOT_NULL(cur)",
          "new_text": "cur->next()",
          "old_line_content": "      DCHECK_NOT_NULL(cur);",
          "new_line_content": "          LiveRange* next = cur->next();",
          "content_same": false
        },
        {
          "line": 3695,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": "AllocatedOperand::cast(spill_operand)",
          "old_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": "AllocatedOperand::cast(spill_operand)",
          "old_line_content": "      int spill_index = range->IsSpilledOnlyInDeferredBlocks()",
          "new_line_content": "        map->RecordReference(AllocatedOperand::cast(spill_operand));",
          "content_same": false
        },
        {
          "line": 3699,
          "old_api": "IsInvalid",
          "new_api": "value",
          "old_text": "spill_operand.IsInvalid()",
          "new_text": "TRACE(\n            \"Pointer in register for range %d:%d (start at %d) \"\n            \"at safe point %d\\n\",\n            range->vreg(), cur->relative_id(), cur->Start().value(),\n            safe_point)",
          "old_line_content": "      if (!spill_operand.IsInvalid() && safe_point >= spill_index) {",
          "new_line_content": "        TRACE(",
          "content_same": false
        },
        {
          "line": 3702,
          "old_api": "AllocatedOperand::cast(spill_operand)",
          "new_api": "value",
          "old_text": "AllocatedOperand::cast(spill_operand)",
          "new_text": "cur->Start().value()",
          "old_line_content": "        map->RecordReference(AllocatedOperand::cast(spill_operand));",
          "new_line_content": "            range->vreg(), cur->relative_id(), cur->Start().value(),",
          "content_same": false
        },
        {
          "line": 3705,
          "old_api": "spilled",
          "new_api": "IsStackSlot",
          "old_text": "cur->spilled()",
          "new_text": "operand.IsStackSlot()",
          "old_line_content": "      if (!cur->spilled()) {",
          "new_line_content": "        DCHECK(!operand.IsStackSlot());",
          "content_same": false
        },
        {
          "line": 3706,
          "old_api": "value",
          "new_api": "representation",
          "old_text": "TRACE(\n            \"Pointer in register for range %d:%d (start at %d) \"\n            \"at safe point %d\\n\",\n            range->vreg(), cur->relative_id(), cur->Start().value(),\n            safe_point)",
          "new_text": "CanBeTaggedPointer(\n            AllocatedOperand::cast(operand).representation())",
          "old_line_content": "        TRACE(",
          "new_line_content": "        DCHECK(CanBeTaggedPointer(",
          "content_same": false
        },
        {
          "line": 3729,
          "old_api": "rpo_number",
          "new_api": "live_in_sets",
          "old_text": "block->rpo_number()",
          "new_text": "data()->live_in_sets()",
          "old_line_content": "  return block->predecessors()[0].IsNext(block->rpo_number());",
          "new_line_content": "  ZoneVector<BitVector*>& live_in_sets = data()->live_in_sets();",
          "content_same": false
        },
        {
          "line": 3736,
          "old_api": "live_in_sets",
          "new_api": "ArrayFor",
          "old_text": "data()->live_in_sets()",
          "new_text": "finder.ArrayFor(vreg)",
          "old_line_content": "  ZoneVector<BitVector*>& live_in_sets = data()->live_in_sets();",
          "new_line_content": "      LiveRangeBoundArray* array = finder.ArrayFor(vreg);",
          "content_same": false
        },
        {
          "line": 3737,
          "old_api": "instruction_blocks",
          "new_api": "predecessors",
          "old_text": "code()->instruction_blocks()",
          "new_text": "block->predecessors()",
          "old_line_content": "  for (const InstructionBlock* block : code()->instruction_blocks()) {",
          "new_line_content": "      for (const RpoNumber& pred : block->predecessors()) {",
          "content_same": false
        },
        {
          "line": 3739,
          "old_api": "ToInt",
          "new_api": "InstructionBlockAt",
          "old_text": "block->rpo_number().ToInt()",
          "new_text": "code()->InstructionBlockAt(pred)",
          "old_line_content": "    BitVector* live = live_in_sets[block->rpo_number().ToInt()];",
          "new_line_content": "        const InstructionBlock* pred_block = code()->InstructionBlockAt(pred);",
          "content_same": false
        },
        {
          "line": 3743,
          "old_api": "ArrayFor",
          "new_api": "GetAssignedOperand",
          "old_text": "finder.ArrayFor(vreg)",
          "new_text": "result.pred_cover_->GetAssignedOperand()",
          "old_line_content": "      LiveRangeBoundArray* array = finder.ArrayFor(vreg);",
          "new_line_content": "        InstructionOperand pred_op = result.pred_cover_->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3744,
          "old_api": "predecessors",
          "new_api": "GetAssignedOperand",
          "old_text": "block->predecessors()",
          "new_text": "result.cur_cover_->GetAssignedOperand()",
          "old_line_content": "      for (const RpoNumber& pred : block->predecessors()) {",
          "new_line_content": "        InstructionOperand cur_op = result.cur_cover_->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3746,
          "old_api": "InstructionBlockAt",
          "new_api": "IsAnyRegister",
          "old_text": "code()->InstructionBlockAt(pred)",
          "new_text": "cur_op.IsAnyRegister()",
          "old_line_content": "        const InstructionBlock* pred_block = code()->InstructionBlockAt(pred);",
          "new_line_content": "        if (!pred_op.IsAnyRegister() && cur_op.IsAnyRegister()) {",
          "content_same": false
        },
        {
          "line": 3753,
          "old_api": "IsAnyRegister",
          "new_api": "code_start",
          "old_text": "cur_op.IsAnyRegister()",
          "new_text": "block->code_start()",
          "old_line_content": "        if (!pred_op.IsAnyRegister() && cur_op.IsAnyRegister()) {",
          "new_line_content": "              LifetimePosition::GapFromInstructionIndex(block->code_start());",
          "content_same": false
        },
        {
          "line": 3764,
          "old_api": "next",
          "new_api": "NextUsePosition",
          "old_text": "current->next()",
          "new_text": "current->NextUsePosition(block_start)",
          "old_line_content": "          const LiveRange* successor = current->next();",
          "new_line_content": "            for (const UsePosition* use = current->NextUsePosition(block_start);",
          "content_same": false
        },
        {
          "line": 3765,
          "old_api": "End",
          "new_api": "next",
          "old_text": "current->End()",
          "new_text": "use->next()",
          "old_line_content": "          if (current->End() < block_end &&",
          "new_line_content": "                 use != nullptr; use = use->next()) {",
          "content_same": false
        },
        {
          "line": 3766,
          "old_api": "spilled",
          "new_api": "operand",
          "old_text": "successor->spilled()",
          "new_text": "use->operand()->IsAnyRegister()",
          "old_line_content": "              (successor == nullptr || successor->spilled())) {",
          "new_line_content": "              if (use->operand()->IsAnyRegister()) {",
          "content_same": false
        },
        {
          "line": 3773,
          "old_api": "operand",
          "new_api": "TopLevel",
          "old_text": "use->operand()->IsAnyRegister()",
          "new_text": "current->TopLevel()->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "              if (use->operand()->IsAnyRegister()) {",
          "new_line_content": "          if (current->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&",
          "content_same": false
        },
        {
          "line": 3781,
          "old_api": "IsDeferred",
          "new_api": "ResolveControlFlow",
          "old_text": "pred_block->IsDeferred()",
          "new_text": "ResolveControlFlow(block, cur_op, pred_block, pred_op)",
          "old_line_content": "              pred_block->IsDeferred()) {",
          "new_line_content": "        int move_loc = ResolveControlFlow(block, cur_op, pred_block, pred_op);",
          "content_same": false
        },
        {
          "line": 3784,
          "old_api": "ToInt",
          "new_api": "TopLevel",
          "old_text": "current->TopLevel()->GetListOfBlocksRequiringSpillOperands()->Add(\n                pred_block->rpo_number().ToInt())",
          "new_text": "result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "            current->TopLevel()->GetListOfBlocksRequiringSpillOperands()->Add(",
          "new_line_content": "            result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&",
          "content_same": false
        },
        {
          "line": 3785,
          "old_api": "ToInt",
          "new_api": "IsAnyRegister",
          "old_text": "pred_block->rpo_number().ToInt()",
          "new_text": "cur_op.IsAnyRegister()",
          "old_line_content": "                pred_block->rpo_number().ToInt());",
          "new_line_content": "                !(pred_op.IsAnyRegister() && cur_op.IsAnyRegister()),",
          "content_same": false
        },
        {
          "line": 3788,
          "old_api": "ResolveControlFlow",
          "new_api": "Advance",
          "old_text": "ResolveControlFlow(block, cur_op, pred_block, pred_op)",
          "new_text": "iterator.Advance()",
          "old_line_content": "        int move_loc = ResolveControlFlow(block, cur_op, pred_block, pred_op);",
          "new_line_content": "      iterator.Advance();",
          "content_same": false
        },
        {
          "line": 3795,
          "old_api": "Advance",
          "new_api": "size",
          "old_text": "iterator.Advance()",
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "      iterator.Advance();",
          "new_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "content_same": false
        },
        {
          "line": 3802,
          "old_api": "size",
          "new_api": "vreg",
          "old_text": "data()->live_ranges().size()",
          "new_text": "top->vreg()",
          "old_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "new_line_content": "    CommitSpillsInDeferredBlocks(top, finder.ArrayFor(top->vreg()), local_zone);",
          "content_same": false
        },
        {
          "line": 3818,
          "old_api": "Equals",
          "new_api": "SuccessorCount",
          "old_text": "pred_op.Equals(cur_op)",
          "new_text": "pred->SuccessorCount()",
          "old_line_content": "  DCHECK(!pred_op.Equals(cur_op));",
          "new_line_content": "    DCHECK_EQ(1, pred->SuccessorCount());",
          "content_same": false
        },
        {
          "line": 3822,
          "old_api": "first_instruction_index",
          "new_api": "last_instruction_index",
          "old_text": "block->first_instruction_index()",
          "new_text": "pred->last_instruction_index()",
          "old_line_content": "    gap_index = block->first_instruction_index();",
          "new_line_content": "    gap_index = pred->last_instruction_index();",
          "content_same": false
        },
        {
          "line": 3825,
          "old_api": "SuccessorCount",
          "new_api": "AddGapMove",
          "old_text": "pred->SuccessorCount()",
          "new_text": "data()->AddGapMove(gap_index, position, pred_op, cur_op)",
          "old_line_content": "    DCHECK_EQ(1, pred->SuccessorCount());",
          "new_line_content": "  data()->AddGapMove(gap_index, position, pred_op, cur_op);",
          "content_same": false
        },
        {
          "line": 3832,
          "old_api": "AddGapMove",
          "new_api": "live_ranges",
          "old_text": "data()->AddGapMove(gap_index, position, pred_op, cur_op)",
          "new_text": "data()->live_ranges()",
          "old_line_content": "  data()->AddGapMove(gap_index, position, pred_op, cur_op);",
          "new_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3838,
          "old_api": "size",
          "new_api": "next",
          "old_text": "data()->live_ranges().size()",
          "new_text": "first_range->next()",
          "old_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "new_line_content": "    for (LiveRange *second_range = first_range->next(); second_range != nullptr;",
          "content_same": false
        },
        {
          "line": 3839,
          "old_api": "live_ranges",
          "new_api": "next",
          "old_text": "data()->live_ranges()",
          "new_text": "second_range->next()",
          "old_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "new_line_content": "         first_range = second_range, second_range = second_range->next()) {",
          "content_same": false
        },
        {
          "line": 3840,
          "old_api": "size",
          "new_api": "Start",
          "old_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "new_text": "second_range->Start()",
          "old_line_content": "    CHECK_EQ(live_ranges_size,",
          "new_line_content": "      LifetimePosition pos = second_range->Start();",
          "content_same": false
        },
        {
          "line": 3843,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": "spilled",
          "old_text": "top_range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": "second_range->spilled()",
          "old_line_content": "    bool connect_spilled = top_range->IsSpilledOnlyInDeferredBlocks();",
          "new_line_content": "      if (second_range->spilled()) continue;",
          "content_same": false
        },
        {
          "line": 3845,
          "old_api": "next",
          "new_api": "IsBlockBoundary",
          "old_text": "first_range->next()",
          "new_text": "data()->IsBlockBoundary(pos)",
          "old_line_content": "    for (LiveRange *second_range = first_range->next(); second_range != nullptr;",
          "new_line_content": "      if (data()->IsBlockBoundary(pos) &&",
          "content_same": false
        },
        {
          "line": 3846,
          "old_api": "next",
          "new_api": "code",
          "old_text": "second_range->next()",
          "new_text": "code()",
          "old_line_content": "         first_range = second_range, second_range = second_range->next()) {",
          "new_line_content": "          !CanEagerlyResolveControlFlow(GetInstructionBlock(code(), pos))) {",
          "content_same": false
        },
        {
          "line": 3850,
          "old_api": "spilled",
          "new_api": "GetAssignedOperand",
          "old_text": "second_range->spilled()",
          "new_text": "second_range->GetAssignedOperand()",
          "old_line_content": "      if (second_range->spilled()) continue;",
          "new_line_content": "      InstructionOperand cur_operand = second_range->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3851,
          "old_api": "End",
          "new_api": "Equals",
          "old_text": "first_range->End()",
          "new_text": "prev_operand.Equals(cur_operand)",
          "old_line_content": "      if (first_range->End() != pos) continue;",
          "new_line_content": "      if (prev_operand.Equals(cur_operand)) continue;",
          "content_same": false
        },
        {
          "line": 3856,
          "old_api": "GetAssignedOperand",
          "new_api": "IsAnyRegister",
          "old_text": "first_range->GetAssignedOperand()",
          "new_text": "cur_operand.IsAnyRegister()",
          "old_line_content": "      InstructionOperand prev_operand = first_range->GetAssignedOperand();",
          "new_line_content": "          cur_operand.IsAnyRegister()) {",
          "content_same": false
        },
        {
          "line": 3857,
          "old_api": "GetAssignedOperand",
          "new_api": "GetInstructionBlock",
          "old_text": "second_range->GetAssignedOperand()",
          "new_text": "code()->GetInstructionBlock(gap_index)",
          "old_line_content": "      InstructionOperand cur_operand = second_range->GetAssignedOperand();",
          "new_line_content": "        const InstructionBlock* block = code()->GetInstructionBlock(gap_index);",
          "content_same": false
        },
        {
          "line": 3858,
          "old_api": "Equals",
          "new_api": "IsDeferred",
          "old_text": "prev_operand.Equals(cur_operand)",
          "new_text": "block->IsDeferred()",
          "old_line_content": "      if (prev_operand.Equals(cur_operand)) continue;",
          "new_line_content": "        DCHECK(block->IsDeferred());",
          "content_same": false
        },
        {
          "line": 3861,
          "old_api": "ToInstructionIndex",
          "new_api": "ToInt",
          "old_text": "pos.ToInstructionIndex()",
          "new_text": "top_range->GetListOfBlocksRequiringSpillOperands()->Add(\n            block->rpo_number().ToInt())",
          "old_line_content": "      int gap_index = pos.ToInstructionIndex();",
          "new_line_content": "        top_range->GetListOfBlocksRequiringSpillOperands()->Add(",
          "content_same": false
        },
        {
          "line": 3862,
          "old_api": "IsAnyRegister",
          "new_api": "ToInt",
          "old_text": "prev_operand.IsAnyRegister()",
          "new_text": "block->rpo_number().ToInt()",
          "old_line_content": "      if (connect_spilled && !prev_operand.IsAnyRegister() &&",
          "new_line_content": "            block->rpo_number().ToInt());",
          "content_same": false
        },
        {
          "line": 3865,
          "old_api": "IsDeferred",
          "new_api": "IsGapPosition",
          "old_text": "block->IsDeferred()",
          "new_text": "pos.IsGapPosition()",
          "old_line_content": "        DCHECK(block->IsDeferred());",
          "new_line_content": "      if (pos.IsGapPosition()) {",
          "content_same": false
        },
        {
          "line": 3868,
          "old_api": "ToInt",
          "new_api": "IsStart",
          "old_text": "top_range->GetListOfBlocksRequiringSpillOperands()->Add(\n            block->rpo_number().ToInt())",
          "new_text": "pos.IsStart()",
          "old_line_content": "        top_range->GetListOfBlocksRequiringSpillOperands()->Add(",
          "new_line_content": "        if (pos.IsStart()) {",
          "content_same": false
        },
        {
          "line": 3884,
          "old_api": "IsAnyRegister",
          "new_api": "code_zone",
          "old_text": "DCHECK_IMPLIES(\n          connect_spilled &&\n              !(prev_operand.IsAnyRegister() && cur_operand.IsAnyRegister()),\n          code()->GetInstructionBlock(gap_index)->IsDeferred())",
          "new_text": "code_zone()",
          "old_line_content": "      DCHECK_IMPLIES(",
          "new_line_content": "              gap_pos, code_zone());",
          "content_same": false
        },
        {
          "line": 3886,
          "old_api": "IsAnyRegister",
          "new_api": "AddMove",
          "old_text": "cur_operand.IsAnyRegister()",
          "new_text": "move->AddMove(prev_operand, cur_operand)",
          "old_line_content": "              !(prev_operand.IsAnyRegister() && cur_operand.IsAnyRegister()),",
          "new_line_content": "        move->AddMove(prev_operand, cur_operand);",
          "content_same": false
        },
        {
          "line": 3893,
          "old_api": "AddMove",
          "new_api": "empty",
          "old_text": "move->AddMove(prev_operand, cur_operand)",
          "new_text": "delayed_insertion_map.empty()",
          "old_line_content": "        move->AddMove(prev_operand, cur_operand);",
          "new_line_content": "  if (delayed_insertion_map.empty()) return;",
          "content_same": false
        },
        {
          "line": 3900,
          "old_api": "empty",
          "new_api": "begin",
          "old_text": "delayed_insertion_map.empty()",
          "new_text": "delayed_insertion_map.begin()",
          "old_line_content": "  if (delayed_insertion_map.empty()) return;",
          "new_line_content": "  for (auto it = delayed_insertion_map.begin();; ++it) {",
          "content_same": false
        },
        {
          "line": 3905,
          "old_api": "reserve",
          "new_api": "Eliminate",
          "old_text": "to_eliminate.reserve(4)",
          "new_text": "move->Eliminate()",
          "old_line_content": "  to_eliminate.reserve(4);",
          "new_line_content": "        move->Eliminate();",
          "content_same": false
        },
        {
          "line": 3908,
          "old_api": "end",
          "new_api": "push_back",
          "old_text": "delayed_insertion_map.end()",
          "new_text": "moves->push_back(move)",
          "old_line_content": "    bool done = it == delayed_insertion_map.end();",
          "new_line_content": "        moves->push_back(move);",
          "content_same": false
        },
        {
          "line": 3912,
          "old_api": "Eliminate",
          "new_api": "clear",
          "old_text": "move->Eliminate()",
          "new_text": "to_eliminate.clear()",
          "old_line_content": "        move->Eliminate();",
          "new_line_content": "      to_eliminate.clear();",
          "content_same": false
        },
        {
          "line": 3919,
          "old_api": "clear",
          "new_api": "PrepareInsertAfter",
          "old_text": "to_eliminate.clear()",
          "new_text": "moves->PrepareInsertAfter(move, &to_eliminate)",
          "old_line_content": "      to_eliminate.clear();",
          "new_line_content": "    moves->PrepareInsertAfter(move, &to_eliminate);",
          "content_same": false
        },
        {
          "line": 3920,
          "old_api": "clear",
          "new_api": "push_back",
          "old_text": "to_insert.clear()",
          "new_text": "to_insert.push_back(move)",
          "old_line_content": "      to_insert.clear();",
          "new_line_content": "    to_insert.push_back(move);",
          "content_same": false
        },
        {
          "line": 3927,
          "old_api": "push_back",
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": "to_insert.push_back(move)",
          "new_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "    to_insert.push_back(move);",
          "new_line_content": "  DCHECK(range->IsSpilledOnlyInDeferredBlocks());",
          "content_same": false
        },
        {
          "line": 3934,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": "vreg",
          "old_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": "range->vreg()",
          "old_line_content": "  DCHECK(range->IsSpilledOnlyInDeferredBlocks());",
          "new_line_content": "        range->vreg());",
          "content_same": false
        },
        {
          "line": 3938,
          "old_api": "GetSpillRangeOperand",
          "new_api": "next",
          "old_text": "range->GetSpillRangeOperand()",
          "new_text": "child->next()",
          "old_line_content": "  InstructionOperand spill_operand = range->GetSpillRangeOperand();",
          "new_line_content": "       child = child->next()) {",
          "content_same": false
        },
        {
          "line": 3940,
          "old_api": "vreg",
          "new_api": "next",
          "old_text": "TRACE(\"Live Range %d will be spilled only in deferred blocks.\\n\",\n        range->vreg())",
          "new_text": "pos->next()",
          "old_line_content": "  TRACE(\"Live Range %d will be spilled only in deferred blocks.\\n\",",
          "new_line_content": "         pos = pos->next()) {",
          "content_same": false
        },
        {
          "line": 3941,
          "old_api": "vreg",
          "new_api": "spilled",
          "old_text": "range->vreg()",
          "new_text": "child->spilled()",
          "old_line_content": "        range->vreg());",
          "new_line_content": "      if (pos->type() != UsePositionType::kRequiresSlot && !child->spilled())",
          "content_same": false
        },
        {
          "line": 3961,
          "old_api": "Current",
          "new_api": "GetListOfBlocksRequiringSpillOperands",
          "old_text": "iterator.Current()",
          "new_text": "range->GetListOfBlocksRequiringSpillOperands()->length()",
          "old_line_content": "    worklist.push(iterator.Current());",
          "new_line_content": "      range->GetListOfBlocksRequiringSpillOperands()->length(), temp_zone);",
          "content_same": false
        },
        {
          "line": 3968,
          "old_api": "GetListOfBlocksRequiringSpillOperands",
          "new_api": "RpoNumber::FromInt(block_id)",
          "old_text": "range->GetListOfBlocksRequiringSpillOperands()->length()",
          "new_text": "RpoNumber::FromInt(block_id)",
          "old_line_content": "      range->GetListOfBlocksRequiringSpillOperands()->length(), temp_zone);",
          "new_line_content": "        code->InstructionBlockAt(RpoNumber::FromInt(block_id));",
          "content_same": false
        },
        {
          "line": 3970,
          "old_api": "front",
          "new_api": "predecessors",
          "old_text": "worklist.front()",
          "new_text": "spill_block->predecessors()",
          "old_line_content": "    int block_id = worklist.front();",
          "new_line_content": "    for (const RpoNumber& pred : spill_block->predecessors()) {",
          "content_same": false
        },
        {
          "line": 3971,
          "old_api": "pop",
          "new_api": "InstructionBlockAt",
          "old_text": "worklist.pop()",
          "new_text": "code->InstructionBlockAt(pred)",
          "old_line_content": "    worklist.pop();",
          "new_line_content": "      const InstructionBlock* pred_block = code->InstructionBlockAt(pred);",
          "content_same": false
        },
        {
          "line": 3973,
          "old_api": "Add",
          "new_api": "IsDeferred",
          "old_text": "done_blocks.Add(block_id)",
          "new_text": "pred_block->IsDeferred()",
          "old_line_content": "    done_blocks.Add(block_id);",
          "new_line_content": "      if (pred_block->IsDeferred()) {",
          "content_same": false
        },
        {
          "line": 3977,
          "old_api": "predecessors",
          "new_api": "last_instruction_index",
          "old_text": "spill_block->predecessors()",
          "new_text": "LifetimePosition::InstructionFromInstructionIndex(\n                pred_block->last_instruction_index())",
          "old_line_content": "    for (const RpoNumber& pred : spill_block->predecessors()) {",
          "new_line_content": "            LifetimePosition::InstructionFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 3978,
          "old_api": "InstructionBlockAt",
          "new_api": "last_instruction_index",
          "old_text": "code->InstructionBlockAt(pred)",
          "new_text": "pred_block->last_instruction_index()",
          "old_line_content": "      const InstructionBlock* pred_block = code->InstructionBlockAt(pred);",
          "new_line_content": "                pred_block->last_instruction_index());",
          "content_same": false
        },
        {
          "line": 3980,
          "old_api": "IsDeferred",
          "new_api": "Find",
          "old_text": "pred_block->IsDeferred()",
          "new_text": "array->Find(pred_end)",
          "old_line_content": "      if (pred_block->IsDeferred()) {",
          "new_line_content": "        LiveRangeBound* bound = array->Find(pred_end);",
          "content_same": false
        },
        {
          "line": 3984,
          "old_api": "last_instruction_index",
          "new_api": "rpo_number",
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(\n                pred_block->last_instruction_index())",
          "new_text": "spill_block->rpo_number()",
          "old_line_content": "            LifetimePosition::InstructionFromInstructionIndex(",
          "new_line_content": "        RpoNumber spill_block_number = spill_block->rpo_number();",
          "content_same": false
        },
        {
          "line": 3985,
          "old_api": "last_instruction_index",
          "new_api": "vreg",
          "old_text": "pred_block->last_instruction_index()",
          "new_text": "std::make_pair(\n                spill_block_number, range->vreg())",
          "old_line_content": "                pred_block->last_instruction_index());",
          "new_line_content": "        if (done_moves.find(std::make_pair(",
          "content_same": false
        },
        {
          "line": 3987,
          "old_api": "Find",
          "new_api": "first_instruction_index",
          "old_text": "array->Find(pred_end)",
          "new_text": "spill_block->first_instruction_index()",
          "old_line_content": "        LiveRangeBound* bound = array->Find(pred_end);",
          "new_line_content": "          data()->AddGapMove(spill_block->first_instruction_index(),",
          "content_same": false
        },
        {
          "line": 3991,
          "old_api": "rpo_number",
          "new_api": "mark_needs_frame",
          "old_text": "spill_block->rpo_number()",
          "new_text": "spill_block->mark_needs_frame()",
          "old_line_content": "        RpoNumber spill_block_number = spill_block->rpo_number();",
          "new_line_content": "          spill_block->mark_needs_frame();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 3591,
          "old_api": null,
          "new_api": "delayed_references",
          "old_text": null,
          "new_text": "data()->delayed_references()",
          "old_line_content": "}",
          "new_line_content": "       data()->delayed_references()) {",
          "content_same": false
        },
        {
          "line": 3592,
          "old_api": null,
          "new_api": "RecordReference",
          "old_text": null,
          "new_text": "delayed_reference.map->RecordReference(\n        AllocatedOperand::cast(*delayed_reference.operand))",
          "old_line_content": "",
          "new_line_content": "    delayed_reference.map->RecordReference(",
          "content_same": false
        },
        {
          "line": 3593,
          "old_api": null,
          "new_api": "AllocatedOperand::cast(*delayed_reference.operand)",
          "old_text": null,
          "new_text": "AllocatedOperand::cast(*delayed_reference.operand)",
          "old_line_content": "",
          "new_line_content": "        AllocatedOperand::cast(*delayed_reference.operand));",
          "content_same": false
        },
        {
          "line": 3601,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "  }",
          "new_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3602,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "old_line_content": "  // Iterate over all safe point positions and record a pointer",
          "new_line_content": "    CHECK_EQ(live_ranges_size,",
          "content_same": false
        },
        {
          "line": 3603,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "  // for all spilled live ranges at this point.",
          "new_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "content_same": false
        },
        {
          "line": 3612,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "range->Start().ToInstructionIndex()",
          "old_line_content": "    // Skip non-reference values.",
          "new_line_content": "    int start = range->Start().ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 3614,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "cur->next()",
          "old_line_content": "    // Skip empty live ranges.",
          "new_line_content": "    for (LiveRange* cur = range; cur != nullptr; cur = cur->next()) {",
          "content_same": false
        },
        {
          "line": 3617,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "this_end.ToInstructionIndex()",
          "old_line_content": "",
          "new_line_content": "        end = this_end.ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 3618,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "cur->Start().ToInstructionIndex()",
          "old_line_content": "    // Find the extent of the range and its children.",
          "new_line_content": "      DCHECK(cur->Start().ToInstructionIndex() >= start);",
          "content_same": false
        },
        {
          "line": 3628,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "reference_maps->end()",
          "old_line_content": "    // Most of the ranges are in order, but not all.  Keep an eye on when they",
          "new_line_content": "    for (; first_it != reference_maps->end(); ++first_it) {",
          "content_same": false
        },
        {
          "line": 3634,
          "old_api": null,
          "new_api": "HasSpillOperand",
          "old_text": null,
          "new_text": "range->HasSpillOperand()",
          "old_line_content": "    // recording how far we step in order to save doing this for the next range.",
          "new_line_content": "    if (((range->HasSpillOperand() &&",
          "content_same": false
        },
        {
          "line": 3636,
          "old_api": null,
          "new_api": "HasSpillRange",
          "old_text": null,
          "new_text": "range->HasSpillRange()",
          "old_line_content": "      ReferenceMap* map = *first_it;",
          "new_line_content": "         range->HasSpillRange())) {",
          "content_same": false
        },
        {
          "line": 3638,
          "old_api": null,
          "new_api": "GetSpillOperand",
          "old_text": null,
          "new_text": "range->GetSpillOperand()",
          "old_line_content": "    }",
          "new_line_content": "        spill_operand = *range->GetSpillOperand();",
          "content_same": false
        },
        {
          "line": 3640,
          "old_api": null,
          "new_api": "GetSpillRangeOperand",
          "old_text": null,
          "new_text": "range->GetSpillRangeOperand()",
          "old_line_content": "    InstructionOperand spill_operand;",
          "new_line_content": "        spill_operand = range->GetSpillRangeOperand();",
          "content_same": false
        },
        {
          "line": 3659,
          "old_api": null,
          "new_api": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "old_text": null,
          "new_text": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "old_line_content": "",
          "new_line_content": "          LifetimePosition::InstructionFromInstructionIndex(safe_point);",
          "content_same": false
        },
        {
          "line": 3667,
          "old_api": null,
          "new_api": "DCHECK_NOT_NULL",
          "old_text": null,
          "new_text": "DCHECK_NOT_NULL(cur)",
          "old_line_content": "",
          "new_line_content": "      DCHECK_NOT_NULL(cur);",
          "content_same": false
        },
        {
          "line": 3668,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "cur->Start()",
          "old_line_content": "      // Search for the child range (cur) that covers safe_point_pos. If we",
          "new_line_content": "      DCHECK(safe_point_pos >= cur->Start() || range == cur);",
          "content_same": false
        },
        {
          "line": 3671,
          "old_api": null,
          "new_api": "Covers",
          "old_text": null,
          "new_text": "cur->Covers(safe_point_pos)",
          "old_line_content": "      // This may happen if cur has more than one interval, and the current",
          "new_line_content": "        if (cur->Covers(safe_point_pos)) {",
          "content_same": false
        },
        {
          "line": 3688,
          "old_api": null,
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": null,
          "new_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "",
          "new_line_content": "      int spill_index = range->IsSpilledOnlyInDeferredBlocks()",
          "content_same": false
        },
        {
          "line": 3689,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "cur->Start().ToInstructionIndex()",
          "old_line_content": "      if (!found) {",
          "new_line_content": "                            ? cur->Start().ToInstructionIndex()",
          "content_same": false
        },
        {
          "line": 3690,
          "old_api": null,
          "new_api": "spill_start_index",
          "old_text": null,
          "new_text": "range->spill_start_index()",
          "old_line_content": "        continue;",
          "new_line_content": "                            : range->spill_start_index();",
          "content_same": false
        },
        {
          "line": 3692,
          "old_api": null,
          "new_api": "IsInvalid",
          "old_text": null,
          "new_text": "spill_operand.IsInvalid()",
          "old_line_content": "",
          "new_line_content": "      if (!spill_operand.IsInvalid() && safe_point >= spill_index) {",
          "content_same": false
        },
        {
          "line": 3693,
          "old_api": null,
          "new_api": "vreg",
          "old_text": null,
          "new_text": "TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",\n              range->vreg(), spill_index, safe_point)",
          "old_line_content": "      // Check if the live range is spilled and the safe point is after",
          "new_line_content": "        TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",",
          "content_same": false
        },
        {
          "line": 3694,
          "old_api": null,
          "new_api": "vreg",
          "old_text": null,
          "new_text": "range->vreg()",
          "old_line_content": "      // the spill position.",
          "new_line_content": "              range->vreg(), spill_index, safe_point);",
          "content_same": false
        },
        {
          "line": 3698,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "cur->spilled()",
          "old_line_content": "",
          "new_line_content": "      if (!cur->spilled()) {",
          "content_same": false
        },
        {
          "line": 3704,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "cur->GetAssignedOperand()",
          "old_line_content": "",
          "new_line_content": "        InstructionOperand operand = cur->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3707,
          "old_api": null,
          "new_api": "representation",
          "old_text": null,
          "new_text": "AllocatedOperand::cast(operand).representation()",
          "old_line_content": "            \"Pointer in register for range %d:%d (start at %d) \"",
          "new_line_content": "            AllocatedOperand::cast(operand).representation()));",
          "content_same": false
        },
        {
          "line": 3708,
          "old_api": null,
          "new_api": "AllocatedOperand::cast(operand)",
          "old_text": null,
          "new_text": "AllocatedOperand::cast(operand)",
          "old_line_content": "            \"at safe point %d\\n\",",
          "new_line_content": "        map->RecordReference(AllocatedOperand::cast(operand));",
          "content_same": false
        },
        {
          "line": 3721,
          "old_api": null,
          "new_api": "PredecessorCount",
          "old_text": null,
          "new_text": "block->PredecessorCount()",
          "old_line_content": "",
          "new_line_content": "  if (block->PredecessorCount() != 1) return false;",
          "content_same": false
        },
        {
          "line": 3722,
          "old_api": null,
          "new_api": "rpo_number",
          "old_text": null,
          "new_text": "block->rpo_number()",
          "old_line_content": "LiveRangeConnector::LiveRangeConnector(RegisterAllocationData* data)",
          "new_line_content": "  return block->predecessors()[0].IsNext(block->rpo_number());",
          "content_same": false
        },
        {
          "line": 3730,
          "old_api": null,
          "new_api": "instruction_blocks",
          "old_text": null,
          "new_text": "code()->instruction_blocks()",
          "old_line_content": "}",
          "new_line_content": "  for (const InstructionBlock* block : code()->instruction_blocks()) {",
          "content_same": false
        },
        {
          "line": 3731,
          "old_api": null,
          "new_api": "CanEagerlyResolveControlFlow",
          "old_text": null,
          "new_text": "CanEagerlyResolveControlFlow(block)",
          "old_line_content": "",
          "new_line_content": "    if (CanEagerlyResolveControlFlow(block)) continue;",
          "content_same": false
        },
        {
          "line": 3732,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "block->rpo_number().ToInt()",
          "old_line_content": "",
          "new_line_content": "    BitVector* live = live_in_sets[block->rpo_number().ToInt()];",
          "content_same": false
        },
        {
          "line": 3734,
          "old_api": null,
          "new_api": "Done",
          "old_text": null,
          "new_text": "iterator.Done()",
          "old_line_content": "  // Lazily linearize live ranges in memory for fast lookup.",
          "new_line_content": "    while (!iterator.Done()) {",
          "content_same": false
        },
        {
          "line": 3735,
          "old_api": null,
          "new_api": "Current",
          "old_text": null,
          "new_text": "iterator.Current()",
          "old_line_content": "  LiveRangeFinder finder(data(), local_zone);",
          "new_line_content": "      int vreg = iterator.Current();",
          "content_same": false
        },
        {
          "line": 3740,
          "old_api": null,
          "new_api": "FindConnectableSubranges",
          "old_text": null,
          "new_text": "array->FindConnectableSubranges(block, pred_block, &result)",
          "old_line_content": "    BitVector::Iterator iterator(live);",
          "new_line_content": "        if (!array->FindConnectableSubranges(block, pred_block, &result)) {",
          "content_same": false
        },
        {
          "line": 3745,
          "old_api": null,
          "new_api": "Equals",
          "old_text": null,
          "new_text": "pred_op.Equals(cur_op)",
          "old_line_content": "        FindResult result;",
          "new_line_content": "        if (pred_op.Equals(cur_op)) continue;",
          "content_same": false
        },
        {
          "line": 3755,
          "old_api": null,
          "new_api": "code_end",
          "old_text": null,
          "new_text": "block->code_end()",
          "old_line_content": "          // We don't need to, if:",
          "new_line_content": "              LifetimePosition::GapFromInstructionIndex(block->code_end());",
          "content_same": false
        },
        {
          "line": 3757,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "current->next()",
          "old_line_content": "          // 2) the range ends before the block does, and",
          "new_line_content": "          const LiveRange* successor = current->next();",
          "content_same": false
        },
        {
          "line": 3758,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "current->End()",
          "old_line_content": "          // 3) we don't have a successor, or the successor is spilled.",
          "new_line_content": "          if (current->End() < block_end &&",
          "content_same": false
        },
        {
          "line": 3759,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "successor->spilled()",
          "old_line_content": "          LifetimePosition block_start =",
          "new_line_content": "              (successor == nullptr || successor->spilled())) {",
          "content_same": false
        },
        {
          "line": 3774,
          "old_api": null,
          "new_api": "IsDeferred",
          "old_text": null,
          "new_text": "pred_block->IsDeferred()",
          "old_line_content": "                uses_reg = true;",
          "new_line_content": "              pred_block->IsDeferred()) {",
          "content_same": false
        },
        {
          "line": 3777,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "current->TopLevel()->GetListOfBlocksRequiringSpillOperands()->Add(\n                pred_block->rpo_number().ToInt())",
          "old_line_content": "            }",
          "new_line_content": "            current->TopLevel()->GetListOfBlocksRequiringSpillOperands()->Add(",
          "content_same": false
        },
        {
          "line": 3778,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "pred_block->rpo_number().ToInt()",
          "old_line_content": "            if (!uses_reg) continue;",
          "new_line_content": "                pred_block->rpo_number().ToInt());",
          "content_same": false
        },
        {
          "line": 3782,
          "old_api": null,
          "new_api": "USE",
          "old_text": null,
          "new_text": "USE(move_loc)",
          "old_line_content": "            // The spill location should be defined in pred_block, so add",
          "new_line_content": "        USE(move_loc);",
          "content_same": false
        },
        {
          "line": 3783,
          "old_api": null,
          "new_api": "IsAnyRegister",
          "old_text": null,
          "new_text": "DCHECK_IMPLIES(\n            result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&\n                !(pred_op.IsAnyRegister() && cur_op.IsAnyRegister()),\n            code()->GetInstructionBlock(move_loc)->IsDeferred())",
          "old_line_content": "            // pred_block to the list of blocks requiring a spill operand.",
          "new_line_content": "        DCHECK_IMPLIES(",
          "content_same": false
        },
        {
          "line": 3786,
          "old_api": null,
          "new_api": "GetInstructionBlock",
          "old_text": null,
          "new_text": "code()->GetInstructionBlock(move_loc)->IsDeferred()",
          "old_line_content": "          }",
          "new_line_content": "            code()->GetInstructionBlock(move_loc)->IsDeferred());",
          "content_same": false
        },
        {
          "line": 3796,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "    }",
          "new_line_content": "  for (TopLevelLiveRange* top : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3797,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "old_line_content": "  }",
          "new_line_content": "    CHECK_EQ(live_ranges_size,",
          "content_same": false
        },
        {
          "line": 3798,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "",
          "new_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "content_same": false
        },
        {
          "line": 3799,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "top->IsEmpty()",
          "old_line_content": "  // At this stage, we collected blocks needing a spill operand from",
          "new_line_content": "    if (top == nullptr || top->IsEmpty() ||",
          "content_same": false
        },
        {
          "line": 3800,
          "old_api": null,
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": null,
          "new_text": "top->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "  // ConnectRanges and from ResolveControlFlow. Time to commit the spills for",
          "new_line_content": "        !top->IsSpilledOnlyInDeferredBlocks())",
          "content_same": false
        },
        {
          "line": 3811,
          "old_api": null,
          "new_api": "Equals",
          "old_text": null,
          "new_text": "pred_op.Equals(cur_op)",
          "old_line_content": "}",
          "new_line_content": "  DCHECK(!pred_op.Equals(cur_op));",
          "content_same": false
        },
        {
          "line": 3814,
          "old_api": null,
          "new_api": "PredecessorCount",
          "old_text": null,
          "new_text": "block->PredecessorCount()",
          "old_line_content": "int LiveRangeConnector::ResolveControlFlow(const InstructionBlock* block,",
          "new_line_content": "  if (block->PredecessorCount() == 1) {",
          "content_same": false
        },
        {
          "line": 3815,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "block->first_instruction_index()",
          "old_line_content": "                                           const InstructionOperand& cur_op,",
          "new_line_content": "    gap_index = block->first_instruction_index();",
          "content_same": false
        },
        {
          "line": 3819,
          "old_api": null,
          "new_api": "InstructionAt",
          "old_text": null,
          "new_text": "code()\n                ->InstructionAt(pred->last_instruction_index())\n                ->HasReferenceMap()",
          "old_line_content": "  int gap_index;",
          "new_line_content": "    DCHECK(!code()",
          "content_same": false
        },
        {
          "line": 3820,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "pred->last_instruction_index()",
          "old_line_content": "  Instruction::GapPosition position;",
          "new_line_content": "                ->InstructionAt(pred->last_instruction_index())",
          "content_same": false
        },
        {
          "line": 3831,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "  }",
          "new_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "content_same": false
        },
        {
          "line": 3833,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "old_line_content": "  return gap_index;",
          "new_line_content": "    CHECK_EQ(live_ranges_size,",
          "content_same": false
        },
        {
          "line": 3834,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "}",
          "new_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "content_same": false
        },
        {
          "line": 3836,
          "old_api": null,
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": null,
          "new_text": "top_range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "void LiveRangeConnector::ConnectRanges(Zone* local_zone) {",
          "new_line_content": "    bool connect_spilled = top_range->IsSpilledOnlyInDeferredBlocks();",
          "content_same": false
        },
        {
          "line": 3844,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "first_range->End()",
          "old_line_content": "    LiveRange* first_range = top_range;",
          "new_line_content": "      if (first_range->End() != pos) continue;",
          "content_same": false
        },
        {
          "line": 3849,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "first_range->GetAssignedOperand()",
          "old_line_content": "      // boundary.",
          "new_line_content": "      InstructionOperand prev_operand = first_range->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3854,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "pos.ToInstructionIndex()",
          "old_line_content": "        continue;",
          "new_line_content": "      int gap_index = pos.ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 3855,
          "old_api": null,
          "new_api": "IsAnyRegister",
          "old_text": null,
          "new_text": "prev_operand.IsAnyRegister()",
          "old_line_content": "      }",
          "new_line_content": "      if (connect_spilled && !prev_operand.IsAnyRegister() &&",
          "content_same": false
        },
        {
          "line": 3866,
          "old_api": null,
          "new_api": "IsStart",
          "old_text": null,
          "new_text": "pos.IsStart()",
          "old_line_content": "        // Performing a reload in this block, meaning the spill operand must",
          "new_line_content": "        gap_pos = pos.IsStart() ? Instruction::START : Instruction::END;",
          "content_same": false
        },
        {
          "line": 3361,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "phi->operands().size()",
          "old_line_content": "  LiveRange* first_op = nullptr;",
          "new_line_content": "  for (size_t i = 0; i < phi->operands().size(); i++) {",
          "content_same": false
        },
        {
          "line": 3877,
          "old_api": null,
          "new_api": "IsAnyRegister",
          "old_text": null,
          "new_text": "DCHECK_IMPLIES(\n          connect_spilled &&\n              !(prev_operand.IsAnyRegister() && cur_operand.IsAnyRegister()),\n          code()->GetInstructionBlock(gap_index)->IsDeferred())",
          "old_line_content": "        } else {",
          "new_line_content": "      DCHECK_IMPLIES(",
          "content_same": false
        },
        {
          "line": 3879,
          "old_api": null,
          "new_api": "IsAnyRegister",
          "old_text": null,
          "new_text": "cur_operand.IsAnyRegister()",
          "old_line_content": "        }",
          "new_line_content": "              !(prev_operand.IsAnyRegister() && cur_operand.IsAnyRegister()),",
          "content_same": false
        },
        {
          "line": 3880,
          "old_api": null,
          "new_api": "GetInstructionBlock",
          "old_text": null,
          "new_text": "code()->GetInstructionBlock(gap_index)->IsDeferred()",
          "old_line_content": "        gap_pos = delay_insertion ? Instruction::END : Instruction::START;",
          "new_line_content": "          code()->GetInstructionBlock(gap_index)->IsDeferred());",
          "content_same": false
        },
        {
          "line": 3883,
          "old_api": null,
          "new_api": "InstructionAt",
          "old_text": null,
          "new_text": "code()->InstructionAt(gap_index)->GetOrCreateParallelMove(\n              gap_pos, code_zone())",
          "old_line_content": "      // only in deferred blocks.",
          "new_line_content": "          code()->InstructionAt(gap_index)->GetOrCreateParallelMove(",
          "content_same": false
        },
        {
          "line": 3376,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "phi->operands().size()",
          "old_line_content": "      if (first_op == nullptr) {",
          "new_line_content": "  if (spilled_count * 2 <= phi->operands().size()) {",
          "content_same": false
        },
        {
          "line": 3888,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "delayed_insertion_map.insert(\n            std::make_pair(std::make_pair(move, prev_operand), cur_operand))",
          "old_line_content": "",
          "new_line_content": "        delayed_insertion_map.insert(",
          "content_same": false
        },
        {
          "line": 3889,
          "old_api": null,
          "new_api": "std::make_pair(move, prev_operand)",
          "old_text": null,
          "new_text": "std::make_pair(move, prev_operand)",
          "old_line_content": "      ParallelMove* move =",
          "new_line_content": "            std::make_pair(std::make_pair(move, prev_operand), cur_operand));",
          "content_same": false
        },
        {
          "line": 3382,
          "old_api": null,
          "new_api": "DCHECK_NOT_NULL",
          "old_text": null,
          "new_text": "DCHECK_NOT_NULL(first_op)",
          "old_line_content": "  // Only continue if more than half of the operands are spilled.",
          "new_line_content": "  DCHECK_NOT_NULL(first_op);",
          "content_same": false
        },
        {
          "line": 3385,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "phi->operands().size()",
          "old_line_content": "  }",
          "new_line_content": "  for (size_t i = 1; i < phi->operands().size(); i++) {",
          "content_same": false
        },
        {
          "line": 3386,
          "old_api": null,
          "new_api": "operands",
          "old_text": null,
          "new_text": "phi->operands()",
          "old_line_content": "",
          "new_line_content": "    int op = phi->operands()[i];",
          "content_same": false
        },
        {
          "line": 3387,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "  // Try to merge the spilled operands and count the number of merged spilled",
          "new_line_content": "    TopLevelLiveRange* op_range = data()->live_ranges()[op];",
          "content_same": false
        },
        {
          "line": 3388,
          "old_api": null,
          "new_api": "HasSpillRange",
          "old_text": null,
          "new_text": "op_range->HasSpillRange()",
          "old_line_content": "  // operands.",
          "new_line_content": "    if (!op_range->HasSpillRange()) continue;",
          "content_same": false
        },
        {
          "line": 3897,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "to_insert.reserve(4)",
          "old_line_content": "      }",
          "new_line_content": "  to_insert.reserve(4);",
          "content_same": false
        },
        {
          "line": 3898,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "to_eliminate.reserve(4)",
          "old_line_content": "    }",
          "new_line_content": "  to_eliminate.reserve(4);",
          "content_same": false
        },
        {
          "line": 3899,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "delayed_insertion_map.begin()",
          "old_line_content": "  }",
          "new_line_content": "  ParallelMove* moves = delayed_insertion_map.begin()->first.first;",
          "content_same": false
        },
        {
          "line": 3901,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "delayed_insertion_map.end()",
          "old_line_content": "  // Insert all the moves which should occur after the stored move.",
          "new_line_content": "    bool done = it == delayed_insertion_map.end();",
          "content_same": false
        },
        {
          "line": 3398,
          "old_api": null,
          "new_api": "interval",
          "old_text": null,
          "new_text": "first_op_spill->interval()",
          "old_line_content": "      num_merged++;",
          "new_line_content": "      AreUseIntervalsIntersecting(first_op_spill->interval(),",
          "content_same": false
        },
        {
          "line": 3399,
          "old_api": null,
          "new_api": "first_interval",
          "old_text": null,
          "new_text": "range->first_interval()",
          "old_line_content": "    }",
          "new_line_content": "                                  range->first_interval())) {",
          "content_same": false
        },
        {
          "line": 3913,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "to_insert.clear()",
          "old_line_content": "      }",
          "new_line_content": "      to_insert.clear();",
          "content_same": false
        },
        {
          "line": 3918,
          "old_api": null,
          "new_api": "code_zone",
          "old_text": null,
          "new_text": "code_zone()",
          "old_line_content": "      // Reset state.",
          "new_line_content": "        new (code_zone()) MoveOperands(it->first.second, it->second);",
          "content_same": false
        },
        {
          "line": 3407,
          "old_api": null,
          "new_api": "NextUsePositionRegisterIsBeneficial",
          "old_text": null,
          "new_text": "range->NextUsePositionRegisterIsBeneficial(next_pos)",
          "old_line_content": "    return false;",
          "new_line_content": "  UsePosition* pos = range->NextUsePositionRegisterIsBeneficial(next_pos);",
          "content_same": false
        },
        {
          "line": 3410,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->HasSpillRange()",
          "old_line_content": "  // If the range does not need register soon, spill it to the merged",
          "new_line_content": "        range->TopLevel()->HasSpillRange()",
          "content_same": false
        },
        {
          "line": 3411,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->GetSpillRange()",
          "old_line_content": "  // spill range.",
          "new_line_content": "            ? range->TopLevel()->GetSpillRange()",
          "content_same": false
        },
        {
          "line": 3415,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "Spill(range)",
          "old_line_content": "  if (pos == nullptr) {",
          "new_line_content": "    Spill(range);",
          "content_same": false
        },
        {
          "line": 3928,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "range->spilled()",
          "old_line_content": "  }",
          "new_line_content": "  DCHECK(!range->spilled());",
          "content_same": false
        },
        {
          "line": 3930,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "data()->code()",
          "old_line_content": "",
          "new_line_content": "  InstructionSequence* code = data()->code();",
          "content_same": false
        },
        {
          "line": 3931,
          "old_api": null,
          "new_api": "GetSpillRangeOperand",
          "old_text": null,
          "new_text": "range->GetSpillRangeOperand()",
          "old_line_content": "",
          "new_line_content": "  InstructionOperand spill_operand = range->GetSpillRangeOperand();",
          "content_same": false
        },
        {
          "line": 3421,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()",
          "old_line_content": "    if (!merged) return false;",
          "new_line_content": "            : data()->AssignSpillRangeToLiveRange(range->TopLevel());",
          "content_same": false
        },
        {
          "line": 3933,
          "old_api": null,
          "new_api": "vreg",
          "old_text": null,
          "new_text": "TRACE(\"Live Range %d will be spilled only in deferred blocks.\\n\",\n        range->vreg())",
          "old_line_content": "    TopLevelLiveRange* range, LiveRangeBoundArray* array, Zone* temp_zone) {",
          "new_line_content": "  TRACE(\"Live Range %d will be spilled only in deferred blocks.\\n\",",
          "content_same": false
        },
        {
          "line": 3939,
          "old_api": null,
          "new_api": "first_pos",
          "old_text": null,
          "new_text": "child->first_pos()",
          "old_line_content": "",
          "new_line_content": "    for (const UsePosition* pos = child->first_pos(); pos != nullptr;",
          "content_same": false
        },
        {
          "line": 3943,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "range->AddBlockRequiringSpillOperand(\n          code->GetInstructionBlock(pos->pos().ToInstructionIndex())\n              ->rpo_number())",
          "old_line_content": "  // make sure we insert the spill.",
          "new_line_content": "      range->AddBlockRequiringSpillOperand(",
          "content_same": false
        },
        {
          "line": 3432,
          "old_api": null,
          "new_api": "SplitRangeAt",
          "old_text": null,
          "new_text": "SplitRangeAt(range, pos)",
          "old_line_content": "    return true;",
          "new_line_content": "  LiveRange* second_part = SplitRangeAt(range, pos);",
          "content_same": false
        },
        {
          "line": 3433,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "Spill(second_part)",
          "old_line_content": "  }",
          "new_line_content": "  Spill(second_part);",
          "content_same": false
        },
        {
          "line": 3944,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "pos->pos().ToInstructionIndex()",
          "old_line_content": "  for (const LiveRange* child = range; child != nullptr;",
          "new_line_content": "          code->GetInstructionBlock(pos->pos().ToInstructionIndex())",
          "content_same": false
        },
        {
          "line": 3952,
          "old_api": null,
          "new_api": "GetListOfBlocksRequiringSpillOperands",
          "old_text": null,
          "new_text": "range->GetListOfBlocksRequiringSpillOperands()",
          "old_line_content": "              ->rpo_number());",
          "new_line_content": "           range->GetListOfBlocksRequiringSpillOperands());",
          "content_same": false
        },
        {
          "line": 3953,
          "old_api": null,
          "new_api": "Advance",
          "old_text": null,
          "new_text": "iterator.Advance()",
          "old_line_content": "    }",
          "new_line_content": "       !iterator.Done(); iterator.Advance()) {",
          "content_same": false
        },
        {
          "line": 3954,
          "old_api": null,
          "new_api": "Current",
          "old_text": null,
          "new_text": "iterator.Current()",
          "old_line_content": "  }",
          "new_line_content": "    worklist.push(iterator.Current());",
          "content_same": false
        },
        {
          "line": 3447,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(start < end)",
          "old_line_content": "}",
          "new_line_content": "  CHECK(start < end);",
          "content_same": false
        },
        {
          "line": 3448,
          "old_api": null,
          "new_api": "SplitRangeAt",
          "old_text": null,
          "new_text": "SplitRangeAt(range, start)",
          "old_line_content": "",
          "new_line_content": "  LiveRange* second_part = SplitRangeAt(range, start);",
          "content_same": false
        },
        {
          "line": 3450,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "second_part->Start()",
          "old_line_content": "void LinearScanAllocator::SpillBetweenUntil(LiveRange* range,",
          "new_line_content": "  if (second_part->Start() < end) {",
          "content_same": false
        },
        {
          "line": 3962,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "worklist.empty()",
          "old_line_content": "  }",
          "new_line_content": "  while (!worklist.empty()) {",
          "content_same": false
        },
        {
          "line": 3963,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "worklist.front()",
          "old_line_content": "",
          "new_line_content": "    int block_id = worklist.front();",
          "content_same": false
        },
        {
          "line": 3964,
          "old_api": null,
          "new_api": "pop",
          "old_text": null,
          "new_text": "worklist.pop()",
          "old_line_content": "  ZoneSet<std::pair<RpoNumber, int>> done_moves(temp_zone);",
          "new_line_content": "    worklist.pop();",
          "content_same": false
        },
        {
          "line": 3965,
          "old_api": null,
          "new_api": "Contains",
          "old_text": null,
          "new_text": "done_blocks.Contains(block_id)",
          "old_line_content": "  // Seek the deferred blocks that dominate locations requiring spill operands,",
          "new_line_content": "    if (done_blocks.Contains(block_id)) continue;",
          "content_same": false
        },
        {
          "line": 3966,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "done_blocks.Add(block_id)",
          "old_line_content": "  // and spill there. We only need to spill at the start of such blocks.",
          "new_line_content": "    done_blocks.Add(block_id);",
          "content_same": false
        },
        {
          "line": 3456,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "end.Start()",
          "old_line_content": "",
          "new_line_content": "      third_part_end = end.Start();",
          "content_same": false
        },
        {
          "line": 3458,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "SplitBetween(\n        second_part, Max(second_part->Start().End(), until), third_part_end)",
          "old_line_content": "    // The split result intersects with [start, end[.",
          "new_line_content": "    LiveRange* third_part = SplitBetween(",
          "content_same": false
        },
        {
          "line": 3459,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "second_part->Start().End()",
          "old_line_content": "    // Split it at position between ]start+1, end[, spill the middle part",
          "new_line_content": "        second_part, Max(second_part->Start().End(), until), third_part_end);",
          "content_same": false
        },
        {
          "line": 3974,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "pred_block->rpo_number().ToInt()",
          "old_line_content": "    InstructionBlock* spill_block =",
          "new_line_content": "        worklist.push(pred_block->rpo_number().ToInt());",
          "content_same": false
        },
        {
          "line": 3464,
          "old_api": null,
          "new_api": "AddToUnhandled",
          "old_text": null,
          "new_text": "AddToUnhandled(third_part)",
          "old_line_content": "    }",
          "new_line_content": "    AddToUnhandled(third_part);",
          "content_same": false
        },
        {
          "line": 3982,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "bound->range_->GetAssignedOperand()",
          "old_line_content": "      } else {",
          "new_line_content": "        InstructionOperand pred_op = bound->range_->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3986,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "done_moves.end()",
          "old_line_content": "",
          "new_line_content": "                spill_block_number, range->vreg())) == done_moves.end()) {",
          "content_same": false
        },
        {
          "line": 3478,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "data()->code()",
          "old_line_content": "",
          "new_line_content": "  const InstructionSequence* code = data()->code();",
          "content_same": false
        },
        {
          "line": 3479,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "",
          "new_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "content_same": false
        },
        {
          "line": 3480,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "SpillSlotLocator::SpillSlotLocator(RegisterAllocationData* data)",
          "new_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3481,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "old_line_content": "    : data_(data) {}",
          "new_line_content": "    CHECK_EQ(live_ranges_size,",
          "content_same": false
        },
        {
          "line": 3482,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "",
          "new_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "content_same": false
        },
        {
          "line": 3483,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "range->IsEmpty()",
          "old_line_content": "",
          "new_line_content": "    if (range == nullptr || range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 3990,
          "old_api": null,
          "new_api": "vreg",
          "old_text": null,
          "new_text": "range->vreg()",
          "old_line_content": "",
          "new_line_content": "          done_moves.insert(std::make_pair(spill_block_number, range->vreg()));",
          "content_same": false
        },
        {
          "line": 3502,
          "old_api": null,
          "new_api": "spill_ranges",
          "old_text": null,
          "new_text": "data()->spill_ranges()",
          "old_line_content": "}",
          "new_line_content": "  ZoneVector<SpillRange*>& spill_ranges = data()->spill_ranges();",
          "content_same": false
        },
        {
          "line": 3504,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "spill_ranges.size()",
          "old_line_content": "",
          "new_line_content": "  for (size_t i = 0; i < spill_ranges.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 3507,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "range->IsEmpty()",
          "old_line_content": "",
          "new_line_content": "    if (range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 3508,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "spill_ranges.size()",
          "old_line_content": "void OperandAssigner::AssignSpillSlots() {",
          "new_line_content": "    for (size_t j = i + 1; j < spill_ranges.size(); ++j) {",
          "content_same": false
        },
        {
          "line": 3510,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "other->IsEmpty()",
          "old_line_content": "  // Merge disjoint spill ranges",
          "new_line_content": "      if (other != nullptr && !other->IsEmpty()) {",
          "content_same": false
        },
        {
          "line": 3519,
          "old_api": null,
          "new_api": "HasSlot",
          "old_text": null,
          "new_text": "range->HasSlot()",
          "old_line_content": "      }",
          "new_line_content": "    if (!range->HasSlot()) {",
          "content_same": false
        },
        {
          "line": 3520,
          "old_api": null,
          "new_api": "byte_width",
          "old_text": null,
          "new_text": "range->byte_width()",
          "old_line_content": "    }",
          "new_line_content": "      int index = data()->frame()->AllocateSpillSlot(range->byte_width());",
          "content_same": false
        },
        {
          "line": 3521,
          "old_api": null,
          "new_api": "set_assigned_slot",
          "old_text": null,
          "new_text": "range->set_assigned_slot(index)",
          "old_line_content": "  }",
          "new_line_content": "      range->set_assigned_slot(index);",
          "content_same": false
        },
        {
          "line": 3529,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "    }",
          "new_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3530,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "old_line_content": "  }",
          "new_line_content": "    CHECK_EQ(live_ranges_size,",
          "content_same": false
        },
        {
          "line": 3531,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data()->live_ranges().size()",
          "old_line_content": "}",
          "new_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "content_same": false
        },
        {
          "line": 3532,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "top_range->IsEmpty()",
          "old_line_content": "",
          "new_line_content": "    if (top_range == nullptr || top_range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 3534,
          "old_api": null,
          "new_api": "HasSpillOperand",
          "old_text": null,
          "new_text": "top_range->HasSpillOperand()",
          "old_line_content": "void OperandAssigner::CommitAssignment() {",
          "new_line_content": "    if (top_range->HasSpillOperand()) {",
          "content_same": false
        },
        {
          "line": 3540,
          "old_api": null,
          "new_api": "GetPhiMapValueFor",
          "old_text": null,
          "new_text": "data()->GetPhiMapValueFor(top_range)->CommitAssignment(\n          top_range->GetAssignedOperand())",
          "old_line_content": "    InstructionOperand spill_operand;",
          "new_line_content": "      data()->GetPhiMapValueFor(top_range)->CommitAssignment(",
          "content_same": false
        },
        {
          "line": 3545,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "range->GetAssignedOperand()",
          "old_line_content": "    }",
          "new_line_content": "      InstructionOperand assigned = range->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3550,
          "old_api": null,
          "new_api": "IsInvalid",
          "old_text": null,
          "new_text": "spill_operand.IsInvalid()",
          "old_line_content": "    for (LiveRange* range = top_range; range != nullptr;",
          "new_line_content": "    if (!spill_operand.IsInvalid()) {",
          "content_same": false
        },
        {
          "line": 3561,
          "old_api": null,
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": null,
          "new_text": "top_range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "      // phases. Normally, when we spill at definition, we do not insert a",
          "new_line_content": "      if (!top_range->IsSpilledOnlyInDeferredBlocks()) {",
          "content_same": false
        },
        {
          "line": 3564,
          "old_api": null,
          "new_api": "CommitSpillMoves",
          "old_text": null,
          "new_text": "top_range->CommitSpillMoves(\n            data()->code(), spill_operand,\n            top_range->has_slot_use() || top_range->spilled())",
          "old_line_content": "      // definition. For ranges that are determined to spill only in deferred",
          "new_line_content": "        top_range->CommitSpillMoves(",
          "content_same": false
        },
        {
          "line": 3565,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "data()->code()",
          "old_line_content": "      // blocks, we let ConnectLiveRanges and ResolveControlFlow find the blocks",
          "new_line_content": "            data()->code(), spill_operand,",
          "content_same": false
        },
        {
          "line": 3566,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "top_range->spilled()",
          "old_line_content": "      // where a spill operand is expected, and then finalize by inserting the",
          "new_line_content": "            top_range->has_slot_use() || top_range->spilled());",
          "content_same": false
        },
        {
          "line": 3579,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "data()->code()->reference_maps()",
          "old_line_content": "",
          "new_line_content": "  for (ReferenceMap* map : *data()->code()->reference_maps()) {",
          "content_same": false
        },
        {
          "line": 3580,
          "old_api": null,
          "new_api": "instruction_position",
          "old_text": null,
          "new_text": "map->instruction_position()",
          "old_line_content": "ReferenceMapPopulator::ReferenceMapPopulator(RegisterAllocationData* data)",
          "new_line_content": "    if (safe_point > map->instruction_position()) return false;",
          "content_same": false
        },
        {
          "line": 3581,
          "old_api": null,
          "new_api": "instruction_position",
          "old_text": null,
          "new_text": "map->instruction_position()",
          "old_line_content": "    : data_(data) {}",
          "new_line_content": "    safe_point = map->instruction_position();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 3586,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()->reference_maps()",
          "new_text": null,
          "old_line_content": "  for (ReferenceMap* map : *data()->code()->reference_maps()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3587,
          "old_api": "instruction_position",
          "new_api": null,
          "old_text": "map->instruction_position()",
          "new_text": null,
          "old_line_content": "    if (safe_point > map->instruction_position()) return false;",
          "new_line_content": "void ReferenceMapPopulator::PopulateReferenceMaps() {",
          "content_same": false
        },
        {
          "line": 3595,
          "old_api": "SafePointsAreInOrder",
          "new_api": null,
          "old_text": "SafePointsAreInOrder()",
          "new_text": null,
          "old_line_content": "  DCHECK(SafePointsAreInOrder());",
          "new_line_content": "  // Iterate over all safe point positions and record a pointer",
          "content_same": false
        },
        {
          "line": 3605,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()->reference_maps()",
          "new_text": null,
          "old_line_content": "  const ReferenceMapDeque* reference_maps = data()->code()->reference_maps();",
          "new_line_content": "    // Skip non-reference values.",
          "content_same": false
        },
        {
          "line": 3607,
          "old_api": "size",
          "new_api": null,
          "old_text": "data()->live_ranges().size()",
          "new_text": null,
          "old_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "new_line_content": "    // Skip empty live ranges.",
          "content_same": false
        },
        {
          "line": 3610,
          "old_api": "size",
          "new_api": null,
          "old_text": "data()->live_ranges().size()",
          "new_text": null,
          "old_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3613,
          "old_api": "IsReference",
          "new_api": null,
          "old_text": "data()->IsReference(range)",
          "new_text": null,
          "old_line_content": "    if (!data()->IsReference(range)) continue;",
          "new_line_content": "    int end = 0;",
          "content_same": false
        },
        {
          "line": 3619,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "range->Start().ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "    int start = range->Start().ToInstructionIndex();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3621,
          "old_api": "next",
          "new_api": null,
          "old_text": "cur->next()",
          "new_text": null,
          "old_line_content": "    for (LiveRange* cur = range; cur != nullptr; cur = cur->next()) {",
          "new_line_content": "    // Most of the ranges are in order, but not all.  Keep an eye on when they",
          "content_same": false
        },
        {
          "line": 3622,
          "old_api": "End",
          "new_api": null,
          "old_text": "cur->End()",
          "new_text": null,
          "old_line_content": "      LifetimePosition this_end = cur->End();",
          "new_line_content": "    // step backwards and reset the first_it so we don't miss any safe points.",
          "content_same": false
        },
        {
          "line": 3624,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "this_end.ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "        end = this_end.ToInstructionIndex();",
          "new_line_content": "    last_range_start = start;",
          "content_same": false
        },
        {
          "line": 3625,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "cur->Start().ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "      DCHECK(cur->Start().ToInstructionIndex() >= start);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3641,
          "old_api": "HasSpillOperand",
          "new_api": null,
          "old_text": "range->HasSpillOperand()",
          "new_text": null,
          "old_line_content": "    if (((range->HasSpillOperand() &&",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3645,
          "old_api": "GetSpillOperand",
          "new_api": null,
          "old_text": "range->GetSpillOperand()",
          "new_text": null,
          "old_line_content": "        spill_operand = *range->GetSpillOperand();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3647,
          "old_api": "GetSpillRangeOperand",
          "new_api": null,
          "old_text": "range->GetSpillRangeOperand()",
          "new_text": null,
          "old_line_content": "        spill_operand = range->GetSpillRangeOperand();",
          "new_line_content": "    LiveRange* cur = range;",
          "content_same": false
        },
        {
          "line": 3650,
          "old_api": "representation",
          "new_api": null,
          "old_text": "CanBeTaggedPointer(\n          AllocatedOperand::cast(spill_operand).representation())",
          "new_text": null,
          "old_line_content": "      DCHECK(CanBeTaggedPointer(",
          "new_line_content": "      ReferenceMap* map = *it;",
          "content_same": false
        },
        {
          "line": 3656,
          "old_api": "end",
          "new_api": null,
          "old_text": "reference_maps->end()",
          "new_text": null,
          "old_line_content": "    for (auto it = first_it; it != reference_maps->end(); ++it) {",
          "new_line_content": "      // Advance to the next active range that covers the current",
          "content_same": false
        },
        {
          "line": 3658,
          "old_api": "instruction_position",
          "new_api": null,
          "old_text": "map->instruction_position()",
          "new_text": null,
          "old_line_content": "      int safe_point = map->instruction_position();",
          "new_line_content": "      LifetimePosition safe_point_pos =",
          "content_same": false
        },
        {
          "line": 3666,
          "old_api": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "new_api": null,
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "new_text": null,
          "old_line_content": "          LifetimePosition::InstructionFromInstructionIndex(safe_point);",
          "new_line_content": "      // For that reason, cur may be at most the last child.",
          "content_same": false
        },
        {
          "line": 3678,
          "old_api": "Covers",
          "new_api": null,
          "old_text": "cur->Covers(safe_point_pos)",
          "new_text": null,
          "old_line_content": "        if (cur->Covers(safe_point_pos)) {",
          "new_line_content": "          cur = next;",
          "content_same": false
        },
        {
          "line": 3681,
          "old_api": "next",
          "new_api": null,
          "old_text": "cur->next()",
          "new_text": null,
          "old_line_content": "          LiveRange* next = cur->next();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3682,
          "old_api": "Start",
          "new_api": null,
          "old_text": "next->Start()",
          "new_text": null,
          "old_line_content": "          if (next == nullptr || next->Start() > safe_point_pos) {",
          "new_line_content": "      if (!found) {",
          "content_same": false
        },
        {
          "line": 3696,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "cur->Start().ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "                            ? cur->Start().ToInstructionIndex()",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3697,
          "old_api": "spill_start_index",
          "new_api": null,
          "old_text": "range->spill_start_index()",
          "new_text": null,
          "old_line_content": "                            : range->spill_start_index();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3700,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",\n              range->vreg(), spill_index, safe_point)",
          "new_text": null,
          "old_line_content": "        TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",",
          "new_line_content": "            \"Pointer in register for range %d:%d (start at %d) \"",
          "content_same": false
        },
        {
          "line": 3701,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "range->vreg()",
          "new_text": null,
          "old_line_content": "              range->vreg(), spill_index, safe_point);",
          "new_line_content": "            \"at safe point %d\\n\",",
          "content_same": false
        },
        {
          "line": 3709,
          "old_api": "value",
          "new_api": null,
          "old_text": "cur->Start().value()",
          "new_text": null,
          "old_line_content": "            range->vreg(), cur->relative_id(), cur->Start().value(),",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3711,
          "old_api": "GetAssignedOperand",
          "new_api": null,
          "old_text": "cur->GetAssignedOperand()",
          "new_text": null,
          "old_line_content": "        InstructionOperand operand = cur->GetAssignedOperand();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3712,
          "old_api": "IsStackSlot",
          "new_api": null,
          "old_text": "operand.IsStackSlot()",
          "new_text": null,
          "old_line_content": "        DCHECK(!operand.IsStackSlot());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3713,
          "old_api": "representation",
          "new_api": null,
          "old_text": "CanBeTaggedPointer(\n            AllocatedOperand::cast(operand).representation())",
          "new_text": null,
          "old_line_content": "        DCHECK(CanBeTaggedPointer(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3714,
          "old_api": "representation",
          "new_api": null,
          "old_text": "AllocatedOperand::cast(operand).representation()",
          "new_text": null,
          "old_line_content": "            AllocatedOperand::cast(operand).representation()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3715,
          "old_api": "AllocatedOperand::cast(operand)",
          "new_api": null,
          "old_text": "AllocatedOperand::cast(operand)",
          "new_text": null,
          "old_line_content": "        map->RecordReference(AllocatedOperand::cast(operand));",
          "new_line_content": "LiveRangeConnector::LiveRangeConnector(RegisterAllocationData* data)",
          "content_same": false
        },
        {
          "line": 3728,
          "old_api": "PredecessorCount",
          "new_api": null,
          "old_text": "block->PredecessorCount()",
          "new_text": null,
          "old_line_content": "  if (block->PredecessorCount() != 1) return false;",
          "new_line_content": "  LiveRangeFinder finder(data(), local_zone);",
          "content_same": false
        },
        {
          "line": 3738,
          "old_api": "CanEagerlyResolveControlFlow",
          "new_api": null,
          "old_text": "CanEagerlyResolveControlFlow(block)",
          "new_text": null,
          "old_line_content": "    if (CanEagerlyResolveControlFlow(block)) continue;",
          "new_line_content": "        FindResult result;",
          "content_same": false
        },
        {
          "line": 3741,
          "old_api": "Done",
          "new_api": null,
          "old_text": "iterator.Done()",
          "new_text": null,
          "old_line_content": "    while (!iterator.Done()) {",
          "new_line_content": "          continue;",
          "content_same": false
        },
        {
          "line": 3742,
          "old_api": "Current",
          "new_api": null,
          "old_text": "iterator.Current()",
          "new_text": null,
          "old_line_content": "      int vreg = iterator.Current();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3747,
          "old_api": "FindConnectableSubranges",
          "new_api": null,
          "old_text": "array->FindConnectableSubranges(block, pred_block, &result)",
          "new_text": null,
          "old_line_content": "        if (!array->FindConnectableSubranges(block, pred_block, &result)) {",
          "new_line_content": "          // We're doing a reload.",
          "content_same": false
        },
        {
          "line": 3750,
          "old_api": "GetAssignedOperand",
          "new_api": null,
          "old_text": "result.pred_cover_->GetAssignedOperand()",
          "new_text": null,
          "old_line_content": "        InstructionOperand pred_op = result.pred_cover_->GetAssignedOperand();",
          "new_line_content": "          // 2) the range ends before the block does, and",
          "content_same": false
        },
        {
          "line": 3751,
          "old_api": "GetAssignedOperand",
          "new_api": null,
          "old_text": "result.cur_cover_->GetAssignedOperand()",
          "new_text": null,
          "old_line_content": "        InstructionOperand cur_op = result.cur_cover_->GetAssignedOperand();",
          "new_line_content": "          // 3) we don't have a successor, or the successor is spilled.",
          "content_same": false
        },
        {
          "line": 3752,
          "old_api": "Equals",
          "new_api": null,
          "old_text": "pred_op.Equals(cur_op)",
          "new_text": null,
          "old_line_content": "        if (pred_op.Equals(cur_op)) continue;",
          "new_line_content": "          LifetimePosition block_start =",
          "content_same": false
        },
        {
          "line": 3760,
          "old_api": "code_start",
          "new_api": null,
          "old_text": "block->code_start()",
          "new_text": null,
          "old_line_content": "              LifetimePosition::GapFromInstructionIndex(block->code_start());",
          "new_line_content": "            // verify point 1: no register use. We can go to the end of the",
          "content_same": false
        },
        {
          "line": 3762,
          "old_api": "code_end",
          "new_api": null,
          "old_text": "block->code_end()",
          "new_text": null,
          "old_line_content": "              LifetimePosition::GapFromInstructionIndex(block->code_end());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3771,
          "old_api": "NextUsePosition",
          "new_api": null,
          "old_text": "current->NextUsePosition(block_start)",
          "new_text": null,
          "old_line_content": "            for (const UsePosition* use = current->NextUsePosition(block_start);",
          "new_line_content": "            if (!uses_reg) continue;",
          "content_same": false
        },
        {
          "line": 3772,
          "old_api": "next",
          "new_api": null,
          "old_text": "use->next()",
          "new_text": null,
          "old_line_content": "                 use != nullptr; use = use->next()) {",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 3780,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "current->TopLevel()->IsSpilledOnlyInDeferredBlocks()",
          "new_text": null,
          "old_line_content": "          if (current->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3789,
          "old_api": "USE",
          "new_api": null,
          "old_text": "USE(move_loc)",
          "new_text": null,
          "old_line_content": "        USE(move_loc);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3790,
          "old_api": "IsAnyRegister",
          "new_api": null,
          "old_text": "DCHECK_IMPLIES(\n            result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&\n                !(pred_op.IsAnyRegister() && cur_op.IsAnyRegister()),\n            code()->GetInstructionBlock(move_loc)->IsDeferred())",
          "new_text": null,
          "old_line_content": "        DCHECK_IMPLIES(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3791,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks()",
          "new_text": null,
          "old_line_content": "            result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3792,
          "old_api": "IsAnyRegister",
          "new_api": null,
          "old_text": "cur_op.IsAnyRegister()",
          "new_text": null,
          "old_line_content": "                !(pred_op.IsAnyRegister() && cur_op.IsAnyRegister()),",
          "new_line_content": "  // At this stage, we collected blocks needing a spill operand from",
          "content_same": false
        },
        {
          "line": 3793,
          "old_api": "GetInstructionBlock",
          "new_api": null,
          "old_text": "code()->GetInstructionBlock(move_loc)->IsDeferred()",
          "new_text": null,
          "old_line_content": "            code()->GetInstructionBlock(move_loc)->IsDeferred());",
          "new_line_content": "  // ConnectRanges and from ResolveControlFlow. Time to commit the spills for",
          "content_same": false
        },
        {
          "line": 3803,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* top : data()->live_ranges()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3804,
          "old_api": "size",
          "new_api": null,
          "old_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "new_text": null,
          "old_line_content": "    CHECK_EQ(live_ranges_size,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3805,
          "old_api": "size",
          "new_api": null,
          "old_text": "data()->live_ranges().size()",
          "new_text": null,
          "old_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3806,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "top->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (top == nullptr || top->IsEmpty() ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3807,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": null,
          "old_text": "top->IsSpilledOnlyInDeferredBlocks()",
          "new_text": null,
          "old_line_content": "        !top->IsSpilledOnlyInDeferredBlocks())",
          "new_line_content": "int LiveRangeConnector::ResolveControlFlow(const InstructionBlock* block,",
          "content_same": false
        },
        {
          "line": 3809,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "top->vreg()",
          "new_text": null,
          "old_line_content": "    CommitSpillsInDeferredBlocks(top, finder.ArrayFor(top->vreg()), local_zone);",
          "new_line_content": "                                           const InstructionBlock* pred,",
          "content_same": false
        },
        {
          "line": 3821,
          "old_api": "PredecessorCount",
          "new_api": null,
          "old_text": "block->PredecessorCount()",
          "new_text": null,
          "old_line_content": "  if (block->PredecessorCount() == 1) {",
          "new_line_content": "                ->HasReferenceMap());",
          "content_same": false
        },
        {
          "line": 3826,
          "old_api": "InstructionAt",
          "new_api": null,
          "old_text": "code()\n                ->InstructionAt(pred->last_instruction_index())\n                ->HasReferenceMap()",
          "new_text": null,
          "old_line_content": "    DCHECK(!code()",
          "new_line_content": "  return gap_index;",
          "content_same": false
        },
        {
          "line": 3827,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "pred->last_instruction_index()",
          "new_text": null,
          "old_line_content": "                ->InstructionAt(pred->last_instruction_index())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3829,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "pred->last_instruction_index()",
          "new_text": null,
          "old_line_content": "    gap_index = pred->last_instruction_index();",
          "new_line_content": "void LiveRangeConnector::ConnectRanges(Zone* local_zone) {",
          "content_same": false
        },
        {
          "line": 3841,
          "old_api": "size",
          "new_api": null,
          "old_text": "data()->live_ranges().size()",
          "new_text": null,
          "old_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "new_line_content": "      // Add gap move if the two live ranges touch and there is no block",
          "content_same": false
        },
        {
          "line": 3847,
          "old_api": "Start",
          "new_api": null,
          "old_text": "second_range->Start()",
          "new_text": null,
          "old_line_content": "      LifetimePosition pos = second_range->Start();",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 3852,
          "old_api": "IsBlockBoundary",
          "new_api": null,
          "old_text": "data()->IsBlockBoundary(pos)",
          "new_text": null,
          "old_line_content": "      if (data()->IsBlockBoundary(pos) &&",
          "new_line_content": "      bool delay_insertion = false;",
          "content_same": false
        },
        {
          "line": 3853,
          "old_api": "code",
          "new_api": null,
          "old_text": "code()",
          "new_text": null,
          "old_line_content": "          !CanEagerlyResolveControlFlow(GetInstructionBlock(code(), pos))) {",
          "new_line_content": "      Instruction::GapPosition gap_pos;",
          "content_same": false
        },
        {
          "line": 3863,
          "old_api": "IsAnyRegister",
          "new_api": null,
          "old_text": "cur_operand.IsAnyRegister()",
          "new_text": null,
          "old_line_content": "          cur_operand.IsAnyRegister()) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3864,
          "old_api": "GetInstructionBlock",
          "new_api": null,
          "old_text": "code()->GetInstructionBlock(gap_index)",
          "new_text": null,
          "old_line_content": "        const InstructionBlock* block = code()->GetInstructionBlock(gap_index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3869,
          "old_api": "ToInt",
          "new_api": null,
          "old_text": "block->rpo_number().ToInt()",
          "new_text": null,
          "old_line_content": "            block->rpo_number().ToInt());",
          "new_line_content": "          delay_insertion = true;",
          "content_same": false
        },
        {
          "line": 3358,
          "old_api": "block",
          "new_api": null,
          "old_text": "phi_map_value->block()",
          "new_text": null,
          "old_line_content": "  const InstructionBlock* block = phi_map_value->block();",
          "new_line_content": "  // Count the number of spilled operands.",
          "content_same": false
        },
        {
          "line": 3872,
          "old_api": "IsGapPosition",
          "new_api": null,
          "old_text": "pos.IsGapPosition()",
          "new_text": null,
          "old_line_content": "      if (pos.IsGapPosition()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3873,
          "old_api": "IsStart",
          "new_api": null,
          "old_text": "pos.IsStart()",
          "new_text": null,
          "old_line_content": "        gap_pos = pos.IsStart() ? Instruction::START : Instruction::END;",
          "new_line_content": "        gap_pos = delay_insertion ? Instruction::END : Instruction::START;",
          "content_same": false
        },
        {
          "line": 3875,
          "old_api": "IsStart",
          "new_api": null,
          "old_text": "pos.IsStart()",
          "new_text": null,
          "old_line_content": "        if (pos.IsStart()) {",
          "new_line_content": "      // Reloads or spills for spilled in deferred blocks ranges must happen",
          "content_same": false
        },
        {
          "line": 3367,
          "old_api": "predecessors",
          "new_api": null,
          "old_text": "block->predecessors()",
          "new_text": null,
          "old_line_content": "        code()->InstructionBlockAt(block->predecessors()[i]);",
          "new_line_content": "      // regardless of control flow.",
          "content_same": false
        },
        {
          "line": 3369,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(\n            pred->last_instruction_index())",
          "new_text": null,
          "old_line_content": "        LifetimePosition::InstructionFromInstructionIndex(",
          "new_line_content": "      if (first_op == nullptr) {",
          "content_same": false
        },
        {
          "line": 3371,
          "old_api": "CanCover",
          "new_api": null,
          "old_text": "op_range->CanCover(pred_end)",
          "new_text": null,
          "old_line_content": "    while (op_range != nullptr && !op_range->CanCover(pred_end)) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3372,
          "old_api": "next",
          "new_api": null,
          "old_text": "op_range->next()",
          "new_text": null,
          "old_line_content": "      op_range = op_range->next();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3374,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "op_range->spilled()",
          "new_text": null,
          "old_line_content": "    if (op_range != nullptr && op_range->spilled()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3887,
          "old_api": "GetInstructionBlock",
          "new_api": null,
          "old_text": "code()->GetInstructionBlock(gap_index)->IsDeferred()",
          "new_text": null,
          "old_line_content": "          code()->GetInstructionBlock(gap_index)->IsDeferred());",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 3377,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "op_range->TopLevel()",
          "new_text": null,
          "old_line_content": "        first_op = op_range->TopLevel();",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 3890,
          "old_api": "InstructionAt",
          "new_api": null,
          "old_text": "code()->InstructionAt(gap_index)->GetOrCreateParallelMove(\n              gap_pos, code_zone())",
          "new_text": null,
          "old_line_content": "          code()->InstructionAt(gap_index)->GetOrCreateParallelMove(",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3891,
          "old_api": "code_zone",
          "new_api": null,
          "old_text": "code_zone()",
          "new_text": null,
          "old_line_content": "              gap_pos, code_zone());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3895,
          "old_api": "insert",
          "new_api": null,
          "old_text": "delayed_insertion_map.insert(\n            std::make_pair(std::make_pair(move, prev_operand), cur_operand))",
          "new_text": null,
          "old_line_content": "        delayed_insertion_map.insert(",
          "new_line_content": "  ZoneVector<MoveOperands*> to_insert(local_zone);",
          "content_same": false
        },
        {
          "line": 3896,
          "old_api": "std::make_pair(move, prev_operand)",
          "new_api": null,
          "old_text": "std::make_pair(move, prev_operand)",
          "new_text": null,
          "old_line_content": "            std::make_pair(std::make_pair(move, prev_operand), cur_operand));",
          "new_line_content": "  ZoneVector<MoveOperands*> to_eliminate(local_zone);",
          "content_same": false
        },
        {
          "line": 3392,
          "old_api": "size",
          "new_api": null,
          "old_text": "phi->operands().size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 1; i < phi->operands().size(); i++) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3393,
          "old_api": "operands",
          "new_api": null,
          "old_text": "phi->operands()",
          "new_text": null,
          "old_line_content": "    int op = phi->operands()[i];",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3394,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "    TopLevelLiveRange* op_range = data()->live_ranges()[op];",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3395,
          "old_api": "HasSpillRange",
          "new_api": null,
          "old_text": "op_range->HasSpillRange()",
          "new_text": null,
          "old_line_content": "    if (!op_range->HasSpillRange()) continue;",
          "new_line_content": "  // Only continue if enough operands could be merged to the",
          "content_same": false
        },
        {
          "line": 3396,
          "old_api": "GetSpillRange",
          "new_api": null,
          "old_text": "op_range->GetSpillRange()",
          "new_text": null,
          "old_line_content": "    SpillRange* op_spill = op_range->GetSpillRange();",
          "new_line_content": "  // same spill slot.",
          "content_same": false
        },
        {
          "line": 3904,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "to_insert.reserve(4)",
          "new_text": null,
          "old_line_content": "  to_insert.reserve(4);",
          "new_line_content": "      for (MoveOperands* move : to_eliminate) {",
          "content_same": false
        },
        {
          "line": 3906,
          "old_api": "begin",
          "new_api": null,
          "old_text": "delayed_insertion_map.begin()",
          "new_text": null,
          "old_line_content": "  ParallelMove* moves = delayed_insertion_map.begin()->first.first;",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3907,
          "old_api": "begin",
          "new_api": null,
          "old_text": "delayed_insertion_map.begin()",
          "new_text": null,
          "old_line_content": "  for (auto it = delayed_insertion_map.begin();; ++it) {",
          "new_line_content": "      for (MoveOperands* move : to_insert) {",
          "content_same": false
        },
        {
          "line": 3915,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "moves->push_back(move)",
          "new_text": null,
          "old_line_content": "        moves->push_back(move);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3404,
          "old_api": "size",
          "new_api": null,
          "old_text": "phi->operands().size()",
          "new_text": null,
          "old_line_content": "  if (num_merged * 2 <= phi->operands().size() ||",
          "new_line_content": "  // spill range.",
          "content_same": false
        },
        {
          "line": 3925,
          "old_api": "code_zone",
          "new_api": null,
          "old_text": "code_zone()",
          "new_text": null,
          "old_line_content": "        new (code_zone()) MoveOperands(it->first.second, it->second);",
          "new_line_content": "void LiveRangeConnector::CommitSpillsInDeferredBlocks(",
          "content_same": false
        },
        {
          "line": 3414,
          "old_api": "NextUsePositionRegisterIsBeneficial",
          "new_api": null,
          "old_text": "range->NextUsePositionRegisterIsBeneficial(next_pos)",
          "new_text": null,
          "old_line_content": "  UsePosition* pos = range->NextUsePositionRegisterIsBeneficial(next_pos);",
          "new_line_content": "    if (!merged) return false;",
          "content_same": false
        },
        {
          "line": 3926,
          "old_api": "PrepareInsertAfter",
          "new_api": null,
          "old_text": "moves->PrepareInsertAfter(move, &to_eliminate)",
          "new_text": null,
          "old_line_content": "    moves->PrepareInsertAfter(move, &to_eliminate);",
          "new_line_content": "    TopLevelLiveRange* range, LiveRangeBoundArray* array, Zone* temp_zone) {",
          "content_same": false
        },
        {
          "line": 3418,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->GetSpillRange()",
          "new_text": null,
          "old_line_content": "            ? range->TopLevel()->GetSpillRange()",
          "new_line_content": "    SpillRange* spill_range =",
          "content_same": false
        },
        {
          "line": 3935,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "range->spilled()",
          "new_text": null,
          "old_line_content": "  DCHECK(!range->spilled());",
          "new_line_content": "  // If we have ranges that aren't spilled but require the operand on the stack,",
          "content_same": false
        },
        {
          "line": 3937,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()",
          "new_text": null,
          "old_line_content": "  InstructionSequence* code = data()->code();",
          "new_line_content": "  for (const LiveRange* child = range; child != nullptr;",
          "content_same": false
        },
        {
          "line": 3426,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->HasSpillRange()",
          "new_text": null,
          "old_line_content": "        range->TopLevel()->HasSpillRange()",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3427,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->GetSpillRange()",
          "new_text": null,
          "old_line_content": "            ? range->TopLevel()->GetSpillRange()",
          "new_line_content": "  return false;",
          "content_same": false
        },
        {
          "line": 3428,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()",
          "new_text": null,
          "old_line_content": "            : data()->AssignSpillRangeToLiveRange(range->TopLevel());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3429,
          "old_api": "TryMerge",
          "new_api": null,
          "old_text": "first_op_spill->TryMerge(spill_range)",
          "new_text": null,
          "old_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3431,
          "old_api": "pos",
          "new_api": null,
          "old_text": "pos->pos()",
          "new_text": null,
          "old_line_content": "    SpillBetween(range, range->Start(), pos->pos());",
          "new_line_content": "void LinearScanAllocator::SpillAfter(LiveRange* range, LifetimePosition pos) {",
          "content_same": false
        },
        {
          "line": 3945,
          "old_api": "next",
          "new_api": null,
          "old_text": "child->next()",
          "new_text": null,
          "old_line_content": "       child = child->next()) {",
          "new_line_content": "              ->rpo_number());",
          "content_same": false
        },
        {
          "line": 3946,
          "old_api": "first_pos",
          "new_api": null,
          "old_text": "child->first_pos()",
          "new_text": null,
          "old_line_content": "    for (const UsePosition* pos = child->first_pos(); pos != nullptr;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3947,
          "old_api": "next",
          "new_api": null,
          "old_text": "pos->next()",
          "new_text": null,
          "old_line_content": "         pos = pos->next()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3948,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "child->spilled()",
          "new_text": null,
          "old_line_content": "      if (pos->type() != UsePositionType::kRequiresSlot && !child->spilled())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3950,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "range->AddBlockRequiringSpillOperand(\n          code->GetInstructionBlock(pos->pos().ToInstructionIndex())\n              ->rpo_number())",
          "new_text": null,
          "old_line_content": "      range->AddBlockRequiringSpillOperand(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3951,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "pos->pos().ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "          code->GetInstructionBlock(pos->pos().ToInstructionIndex())",
          "new_line_content": "  for (BitVector::Iterator iterator(",
          "content_same": false
        },
        {
          "line": 3440,
          "old_api": "Spill",
          "new_api": null,
          "old_text": "Spill(second_part)",
          "new_text": null,
          "old_line_content": "  Spill(second_part);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3446,
          "old_api": "SpillBetweenUntil",
          "new_api": null,
          "old_text": "SpillBetweenUntil(range, start, start, end)",
          "new_text": null,
          "old_line_content": "  SpillBetweenUntil(range, start, start, end);",
          "new_line_content": "                                            LifetimePosition end) {",
          "content_same": false
        },
        {
          "line": 3959,
          "old_api": "GetListOfBlocksRequiringSpillOperands",
          "new_api": null,
          "old_text": "range->GetListOfBlocksRequiringSpillOperands()",
          "new_text": null,
          "old_line_content": "           range->GetListOfBlocksRequiringSpillOperands());",
          "new_line_content": "  // and spill there. We only need to spill at the start of such blocks.",
          "content_same": false
        },
        {
          "line": 3960,
          "old_api": "Advance",
          "new_api": null,
          "old_text": "iterator.Advance()",
          "new_text": null,
          "old_line_content": "       !iterator.Done(); iterator.Advance()) {",
          "new_line_content": "  BitVector done_blocks(",
          "content_same": false
        },
        {
          "line": 3457,
          "old_api": "Start",
          "new_api": null,
          "old_text": "second_part->Start()",
          "new_text": null,
          "old_line_content": "  if (second_part->Start() < end) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3969,
          "old_api": "empty",
          "new_api": null,
          "old_text": "worklist.empty()",
          "new_text": null,
          "old_line_content": "  while (!worklist.empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3972,
          "old_api": "Contains",
          "new_api": null,
          "old_text": "done_blocks.Contains(block_id)",
          "new_text": null,
          "old_line_content": "    if (done_blocks.Contains(block_id)) continue;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": "Start",
          "new_api": null,
          "old_text": "end.Start()",
          "new_text": null,
          "old_line_content": "    if (data()->IsBlockBoundary(end.Start())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3975,
          "old_api": "RpoNumber::FromInt(block_id)",
          "new_api": null,
          "old_text": "RpoNumber::FromInt(block_id)",
          "new_text": null,
          "old_line_content": "        code->InstructionBlockAt(RpoNumber::FromInt(block_id));",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 3465,
          "old_api": "End",
          "new_api": null,
          "old_text": "SplitBetween(\n        second_part, Max(second_part->Start().End(), until), third_part_end)",
          "new_text": null,
          "old_line_content": "    LiveRange* third_part = SplitBetween(",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 3466,
          "old_api": "End",
          "new_api": null,
          "old_text": "second_part->Start().End()",
          "new_text": null,
          "old_line_content": "        second_part, Max(second_part->Start().End(), until), third_part_end);",
          "new_line_content": "    // The split result does not intersect with [start, end[.",
          "content_same": false
        },
        {
          "line": 3981,
          "old_api": "ToInt",
          "new_api": null,
          "old_text": "pred_block->rpo_number().ToInt()",
          "new_text": null,
          "old_line_content": "        worklist.push(pred_block->rpo_number().ToInt());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3470,
          "old_api": "Spill",
          "new_api": null,
          "old_text": "Spill(second_part)",
          "new_text": null,
          "old_line_content": "    Spill(second_part);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3471,
          "old_api": "AddToUnhandled",
          "new_api": null,
          "old_text": "AddToUnhandled(third_part)",
          "new_text": null,
          "old_line_content": "    AddToUnhandled(third_part);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3475,
          "old_api": "AddToUnhandled",
          "new_api": null,
          "old_text": "AddToUnhandled(second_part)",
          "new_text": null,
          "old_line_content": "    AddToUnhandled(second_part);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3989,
          "old_api": "GetAssignedOperand",
          "new_api": null,
          "old_text": "bound->range_->GetAssignedOperand()",
          "new_text": null,
          "old_line_content": "        InstructionOperand pred_op = bound->range_->GetAssignedOperand();",
          "new_line_content": "                             spill_operand);",
          "content_same": false
        },
        {
          "line": 3992,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "std::make_pair(\n                spill_block_number, range->vreg())",
          "new_text": null,
          "old_line_content": "        if (done_moves.find(std::make_pair(",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3993,
          "old_api": "end",
          "new_api": null,
          "old_text": "done_moves.end()",
          "new_text": null,
          "old_line_content": "                spill_block_number, range->vreg())) == done_moves.end()) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3994,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "spill_block->first_instruction_index()",
          "new_text": null,
          "old_line_content": "          data()->AddGapMove(spill_block->first_instruction_index(),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3997,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "range->vreg()",
          "new_text": null,
          "old_line_content": "          done_moves.insert(std::make_pair(spill_block_number, range->vreg()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3486,
          "old_api": "size",
          "new_api": null,
          "old_text": "data()->live_ranges().size()",
          "new_text": null,
          "old_line_content": "  const size_t live_ranges_size = data()->live_ranges().size();",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 3487,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3488,
          "old_api": "size",
          "new_api": null,
          "old_text": "CHECK_EQ(live_ranges_size,\n             data()->live_ranges().size())",
          "new_text": null,
          "old_line_content": "    CHECK_EQ(live_ranges_size,",
          "new_line_content": "    TopLevelLiveRange::SpillMoveInsertionList* spills =",
          "content_same": false
        },
        {
          "line": 3998,
          "old_api": "mark_needs_frame",
          "new_api": null,
          "old_text": "spill_block->mark_needs_frame()",
          "new_text": null,
          "old_line_content": "          spill_block->mark_needs_frame();",
          "new_line_content": "#undef TRACE",
          "content_same": false
        },
        {
          "line": 3496,
          "old_api": "GetSpillMoveInsertionLocations",
          "new_api": null,
          "old_text": "range->GetSpillMoveInsertionLocations()",
          "new_text": null,
          "old_line_content": "        range->GetSpillMoveInsertionLocations();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3497,
          "old_api": "DCHECK_NOT_NULL",
          "new_api": null,
          "old_text": "DCHECK_NOT_NULL(spills)",
          "new_text": null,
          "old_line_content": "    DCHECK_NOT_NULL(spills);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3499,
          "old_api": "GetInstructionBlock",
          "new_api": null,
          "old_text": "code->GetInstructionBlock(spills->gap_index)->mark_needs_frame()",
          "new_text": null,
          "old_line_content": "      code->GetInstructionBlock(spills->gap_index)->mark_needs_frame();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3509,
          "old_api": "spill_ranges",
          "new_api": null,
          "old_text": "data()->spill_ranges()",
          "new_text": null,
          "old_line_content": "  ZoneVector<SpillRange*>& spill_ranges = data()->spill_ranges();",
          "new_line_content": "      SpillRange* other = spill_ranges[j];",
          "content_same": false
        },
        {
          "line": 3514,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (range->IsEmpty()) continue;",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3515,
          "old_api": "size",
          "new_api": null,
          "old_text": "spill_ranges.size()",
          "new_text": null,
          "old_line_content": "    for (size_t j = i + 1; j < spill_ranges.size(); ++j) {",
          "new_line_content": "  // Allocate slots for the merged spill ranges.",
          "content_same": false
        },
        {
          "line": 3518,
          "old_api": "TryMerge",
          "new_api": null,
          "old_text": "range->TryMerge(other)",
          "new_text": null,
          "old_line_content": "        range->TryMerge(other);",
          "new_line_content": "    // Allocate a new operand referring to the spill slot.",
          "content_same": false
        },
        {
          "line": 3524,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (range == nullptr || range->IsEmpty()) continue;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3526,
          "old_api": "HasSlot",
          "new_api": null,
          "old_text": "range->HasSlot()",
          "new_text": null,
          "old_line_content": "    if (!range->HasSlot()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3527,
          "old_api": "byte_width",
          "new_api": null,
          "old_text": "range->byte_width()",
          "new_text": null,
          "old_line_content": "      int index = data()->frame()->AllocateSpillSlot(range->byte_width());",
          "new_line_content": "void OperandAssigner::CommitAssignment() {",
          "content_same": false
        },
        {
          "line": 3538,
          "old_api": "size",
          "new_api": null,
          "old_text": "data()->live_ranges().size()",
          "new_text": null,
          "old_line_content": "             data()->live_ranges().size());  // TODO(neis): crbug.com/831822",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3542,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "top_range->TopLevel()->GetSpillOperand()",
          "new_text": null,
          "old_line_content": "      spill_operand = *top_range->TopLevel()->GetSpillOperand();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3543,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "top_range->TopLevel()->HasSpillRange()",
          "new_text": null,
          "old_line_content": "    } else if (top_range->TopLevel()->HasSpillRange()) {",
          "new_line_content": "    for (LiveRange* range = top_range; range != nullptr;",
          "content_same": false
        },
        {
          "line": 3548,
          "old_api": "GetAssignedOperand",
          "new_api": null,
          "old_text": "top_range->GetAssignedOperand()",
          "new_text": null,
          "old_line_content": "          top_range->GetAssignedOperand());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3551,
          "old_api": "next",
          "new_api": null,
          "old_text": "range->next()",
          "new_text": null,
          "old_line_content": "         range = range->next()) {",
          "new_line_content": "      // If this top level range has a child spilled in a deferred block, we use",
          "content_same": false
        },
        {
          "line": 3552,
          "old_api": "GetAssignedOperand",
          "new_api": null,
          "old_text": "range->GetAssignedOperand()",
          "new_text": null,
          "old_line_content": "      InstructionOperand assigned = range->GetAssignedOperand();",
          "new_line_content": "      // the range and control flow connection mechanism instead of spilling at",
          "content_same": false
        },
        {
          "line": 3553,
          "old_api": "IsUnallocated",
          "new_api": null,
          "old_text": "assigned.IsUnallocated()",
          "new_text": null,
          "old_line_content": "      DCHECK(!assigned.IsUnallocated());",
          "new_line_content": "      // definition. Refer to the ConnectLiveRanges and ResolveControlFlow",
          "content_same": false
        },
        {
          "line": 3554,
          "old_api": "ConvertUsesToOperand",
          "new_api": null,
          "old_text": "range->ConvertUsesToOperand(assigned, spill_operand)",
          "new_text": null,
          "old_line_content": "      range->ConvertUsesToOperand(assigned, spill_operand);",
          "new_line_content": "      // phases. Normally, when we spill at definition, we do not insert a",
          "content_same": false
        },
        {
          "line": 3557,
          "old_api": "IsInvalid",
          "new_api": null,
          "old_text": "spill_operand.IsInvalid()",
          "new_text": null,
          "old_line_content": "    if (!spill_operand.IsInvalid()) {",
          "new_line_content": "      // definition. For ranges that are determined to spill only in deferred",
          "content_same": false
        },
        {
          "line": 3568,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": null,
          "old_text": "top_range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": null,
          "old_line_content": "      if (!top_range->IsSpilledOnlyInDeferredBlocks()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3571,
          "old_api": "CommitSpillMoves",
          "new_api": null,
          "old_text": "top_range->CommitSpillMoves(\n            data()->code(), spill_operand,\n            top_range->has_slot_use() || top_range->spilled())",
          "new_text": null,
          "old_line_content": "        top_range->CommitSpillMoves(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3572,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()",
          "new_text": null,
          "old_line_content": "            data()->code(), spill_operand,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3573,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "top_range->spilled()",
          "new_text": null,
          "old_line_content": "            top_range->has_slot_use() || top_range->spilled());",
          "new_line_content": "ReferenceMapPopulator::ReferenceMapPopulator(RegisterAllocationData* data)",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 123,
      "total_additions": 150,
      "total_deletions": 156,
      "total_api_changes": 429
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 11,
        "api_related_lines": 429,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          3368,
          3373,
          3365,
          3366
        ]
      }
    },
    "api_calls_before": 2331,
    "api_calls_after": 2324,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 10,
      "total_diff_lines": 32
    }
  }
}