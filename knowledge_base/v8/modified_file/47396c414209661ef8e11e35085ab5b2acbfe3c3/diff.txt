diff --git a/src/compiler/js-inlining-heuristic.cc b/src/compiler/js-inlining-heuristic.cc
index 74b87236059..38595dbf95c 100644
--- a/src/compiler/js-inlining-heuristic.cc
+++ b/src/compiler/js-inlining-heuristic.cc
@@ -101,12 +101,18 @@ void JSInliningHeuristic::Finalize() {
   // We inline at most one candidate in every iteration of the fixpoint.
   // This is to ensure that we don't consume the full inlining budget
   // on things that aren't called very often.
-  if (cumulative_count_ > FLAG_max_inlined_nodes_cumulative) return;
-  auto i = candidates_.begin();
-  Candidate const& candidate = *i;
-  inliner_.ReduceJSCall(candidate.node, candidate.function);
-  cumulative_count_ += candidate.function->shared()->ast_node_count();
-  candidates_.erase(i);
+  // TODO(bmeurer): Use std::priority_queue instead of std::set here.
+  while (!candidates_.empty()) {
+    if (cumulative_count_ > FLAG_max_inlined_nodes_cumulative) return;
+    auto i = candidates_.begin();
+    Candidate candidate = *i;
+    candidates_.erase(i);
+    Reduction r = inliner_.ReduceJSCall(candidate.node, candidate.function);
+    if (r.Changed()) {
+      cumulative_count_ += candidate.function->shared()->ast_node_count();
+      return;
+    }
+  }
 }
 
 
