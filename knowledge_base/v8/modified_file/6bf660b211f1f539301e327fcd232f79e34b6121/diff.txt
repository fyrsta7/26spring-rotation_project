diff --git a/src/compiler/backend/register-allocator-verifier.cc b/src/compiler/backend/register-allocator-verifier.cc
index 0ab19171420..31674c59d4e 100644
--- a/src/compiler/backend/register-allocator-verifier.cc
+++ b/src/compiler/backend/register-allocator-verifier.cc
@@ -481,13 +481,10 @@ void RegisterAllocatorVerifier::ValidatePendingAssessment(
       auto pred_assignment = assessments_.find(pred);
       if (pred_assignment == assessments_.end()) {
         CHECK(origin->IsLoopHeader());
-        auto todo_iter = outstanding_assessments_.find(pred);
-        DelayedAssessments* set = nullptr;
-        if (todo_iter == outstanding_assessments_.end()) {
+        auto [todo_iter, inserted] = outstanding_assessments_.try_emplace(pred);
+        DelayedAssessments*& set = todo_iter->second;
+        if (inserted) {
           set = zone()->New<DelayedAssessments>(zone());
-          outstanding_assessments_.insert(std::make_pair(pred, set));
-        } else {
-          set = todo_iter->second;
         }
         set->AddDelayedAssessment(current_operand, expected);
         continue;
@@ -507,9 +504,9 @@ void RegisterAllocatorVerifier::ValidatePendingAssessment(
           // This happens if we have a diamond feeding into another one, and
           // the inner one never being used - other than for carrying the value.
           const PendingAssessment* next = PendingAssessment::cast(contribution);
-          if (seen.find(pred) == seen.end()) {
+          auto [it, inserted] = seen.insert(pred);
+          if (inserted) {
             worklist.push({next, expected});
-            seen.insert(pred);
           }
           // Note that we do not want to finalize pending assessments at the
           // beginning of a block - which is the information we'd have
