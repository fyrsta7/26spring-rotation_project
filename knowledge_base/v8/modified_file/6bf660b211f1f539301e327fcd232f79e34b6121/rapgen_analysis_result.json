{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/6bf660b211f1f539301e327fcd232f79e34b6121",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/6bf660b211f1f539301e327fcd232f79e34b6121/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/6bf660b211f1f539301e327fcd232f79e34b6121/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/6bf660b211f1f539301e327fcd232f79e34b6121/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 484,
          "old_api": "find",
          "new_api": "try_emplace",
          "old_text": "outstanding_assessments_.find(pred)",
          "new_text": "outstanding_assessments_.try_emplace(pred)",
          "old_line_content": "        auto todo_iter = outstanding_assessments_.find(pred);",
          "new_line_content": "        auto [todo_iter, inserted] = outstanding_assessments_.try_emplace(pred);",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "end",
          "new_api": "kind",
          "old_text": "pred_assessments->map().end()",
          "new_text": "contribution->kind()",
          "old_line_content": "      CHECK(found_contribution != pred_assessments->map().end());",
          "new_line_content": "      switch (contribution->kind()) {",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": "PendingAssessment::cast(contribution)",
          "new_api": "push",
          "old_text": "PendingAssessment::cast(contribution)",
          "new_text": "worklist.push({next, expected})",
          "old_line_content": "          const PendingAssessment* next = PendingAssessment::cast(contribution);",
          "new_line_content": "            worklist.push({next, expected});",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": "size",
          "new_api": "instruction_blocks",
          "old_text": "sequence()->instruction_blocks().size()",
          "new_text": "sequence()->instruction_blocks()",
          "old_line_content": "  const size_t block_count = sequence()->instruction_blocks().size();",
          "new_line_content": "        sequence()->instruction_blocks()[block_index];",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": "instruction_blocks",
          "new_api": "code_end",
          "old_text": "sequence()->instruction_blocks()",
          "new_text": "block->code_end()",
          "old_line_content": "        sequence()->instruction_blocks()[block_index];",
          "new_line_content": "    for (int instr_index = block->code_start(); instr_index < block->code_end();",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "rpo_number",
          "new_api": "TempCount",
          "old_text": "block->rpo_number()",
          "new_text": "instr->TempCount()",
          "old_line_content": "        ValidateUse(block->rpo_number(), block_assessments, op,",
          "new_line_content": "      for (size_t i = 0; i < instr->TempCount(); ++i, ++count) {",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "TempCount",
          "new_api": "IsCall",
          "old_text": "instr->TempCount()",
          "new_text": "instr->IsCall()",
          "old_line_content": "      for (size_t i = 0; i < instr->TempCount(); ++i, ++count) {",
          "new_line_content": "      if (instr->IsCall()) {",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": "TempAt",
          "new_api": "DropRegisters",
          "old_text": "instr->TempAt(i)",
          "new_text": "block_assessments->DropRegisters()",
          "old_line_content": "        block_assessments->Drop(*instr->TempAt(i));",
          "new_line_content": "        block_assessments->DropRegisters();",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": "IsCall",
          "new_api": "HasReferenceMap",
          "old_text": "instr->IsCall()",
          "new_text": "instr->HasReferenceMap()",
          "old_line_content": "      if (instr->IsCall()) {",
          "new_line_content": "      if (instr->HasReferenceMap()) {",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": "DropRegisters",
          "new_api": "reference_map",
          "old_text": "block_assessments->DropRegisters()",
          "new_text": "instr->reference_map()",
          "old_line_content": "        block_assessments->DropRegisters();",
          "new_line_content": "        block_assessments->CheckReferenceMap(instr->reference_map());",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "HasReferenceMap",
          "new_api": "OutputCount",
          "old_text": "instr->HasReferenceMap()",
          "new_text": "instr->OutputCount()",
          "old_line_content": "      if (instr->HasReferenceMap()) {",
          "new_line_content": "      for (size_t i = 0; i < instr->OutputCount(); ++i, ++count) {",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": "OutputAt",
          "new_api": "zone",
          "old_text": "instr->OutputAt(i)",
          "new_text": "zone()",
          "old_line_content": "              AllocatedOperand::cast(instr->OutputAt(i));",
          "new_line_content": "              zone(), LocationOperand::LocationKind::STACK_SLOT, rep,",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": "AllocatedOperand::New(\n              zone(), LocationOperand::LocationKind::STACK_SLOT, rep,\n              op_constraints[i].spilled_slot_)",
          "new_api": "AddDefinition",
          "old_text": "AllocatedOperand::New(\n              zone(), LocationOperand::LocationKind::STACK_SLOT, rep,\n              op_constraints[i].spilled_slot_)",
          "new_text": "block_assessments->AddDefinition(*stack_op, virtual_register)",
          "old_line_content": "          const AllocatedOperand* stack_op = AllocatedOperand::New(",
          "new_line_content": "          block_assessments->AddDefinition(*stack_op, virtual_register);",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "rpo_number",
          "new_api": "end",
          "old_text": "block->rpo_number()",
          "new_text": "outstanding_assessments_.end()",
          "old_line_content": "    assessments_[block->rpo_number()] = block_assessments;",
          "new_line_content": "    if (todo_iter == outstanding_assessments_.end()) continue;",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": "rpo_number",
          "new_api": "map",
          "old_text": "block->rpo_number()",
          "new_text": "todo->map()",
          "old_line_content": "    auto todo_iter = outstanding_assessments_.find(block->rpo_number());",
          "new_line_content": "    for (auto pair : todo->map()) {",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": "map",
          "new_api": "find",
          "old_text": "todo->map()",
          "new_text": "block_assessments->map().find(op)",
          "old_line_content": "    for (auto pair : todo->map()) {",
          "new_line_content": "      auto found_op = block_assessments->map().find(op);",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": "end",
          "new_api": "IsStaleReferenceStackSlot",
          "old_text": "block_assessments->map().end()",
          "new_text": "block_assessments->IsStaleReferenceStackSlot(op, vreg)",
          "old_line_content": "      CHECK(found_op != block_assessments->map().end());",
          "new_line_content": "      CHECK(!block_assessments->IsStaleReferenceStackSlot(op, vreg));",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": "IsStaleReferenceStackSlot",
          "new_api": "virtual_register",
          "old_text": "block_assessments->IsStaleReferenceStackSlot(op, vreg)",
          "new_text": "FinalAssessment::cast(found_op->second)->virtual_register()",
          "old_line_content": "      CHECK(!block_assessments->IsStaleReferenceStackSlot(op, vreg));",
          "new_line_content": "          CHECK_EQ(FinalAssessment::cast(found_op->second)->virtual_register(),",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 520,
          "old_api": null,
          "new_api": "AddAlias",
          "old_text": null,
          "new_text": "assessment->AddAlias(virtual_register)",
          "old_line_content": "      }",
          "new_line_content": "  assessment->AddAlias(virtual_register);",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "current_assessments->map().find(op)",
          "old_line_content": "void RegisterAllocatorVerifier::ValidateUse(",
          "new_line_content": "  auto iterator = current_assessments->map().find(op);",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "current_assessments->map().end()",
          "old_line_content": "    InstructionOperand op, int virtual_register) {",
          "new_line_content": "  CHECK(iterator != current_assessments->map().end());",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": null,
          "new_api": "IsStaleReferenceStackSlot",
          "old_text": null,
          "new_text": "current_assessments->IsStaleReferenceStackSlot(op, virtual_register)",
          "old_line_content": "  Assessment* assessment = iterator->second;",
          "new_line_content": "  CHECK(!current_assessments->IsStaleReferenceStackSlot(op, virtual_register));",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": null,
          "new_api": "kind",
          "old_text": null,
          "new_text": "assessment->kind()",
          "old_line_content": "  // The operand shouldn't be a stale reference stack slot.",
          "new_line_content": "  switch (assessment->kind()) {",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": null,
          "new_api": "virtual_register",
          "old_text": null,
          "new_text": "FinalAssessment::cast(assessment)->virtual_register()",
          "old_line_content": "",
          "new_line_content": "      CHECK_EQ(FinalAssessment::cast(assessment)->virtual_register(),",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": null,
          "new_api": "PendingAssessment::cast(assessment)",
          "old_text": null,
          "new_text": "PendingAssessment::cast(assessment)",
          "old_line_content": "               virtual_register);",
          "new_line_content": "      PendingAssessment* pending = PendingAssessment::cast(assessment);",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": null,
          "new_api": "ValidatePendingAssessment",
          "old_text": null,
          "new_text": "ValidatePendingAssessment(block_id, op, current_assessments, pending,\n                                virtual_register)",
          "old_line_content": "      break;",
          "new_line_content": "      ValidatePendingAssessment(block_id, op, current_assessments, pending,",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "assessments_.empty()",
          "old_line_content": "}",
          "new_line_content": "  CHECK(assessments_.empty());",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "outstanding_assessments_.empty()",
          "old_line_content": "",
          "new_line_content": "  CHECK(outstanding_assessments_.empty());",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "sequence()->instruction_blocks().size()",
          "old_line_content": "void RegisterAllocatorVerifier::VerifyGapMoves() {",
          "new_line_content": "  const size_t block_count = sequence()->instruction_blocks().size();",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": null,
          "new_api": "CreateForBlock",
          "old_text": null,
          "new_text": "CreateForBlock(block)",
          "old_line_content": "  for (size_t block_index = 0; block_index < block_count; ++block_index) {",
          "new_line_content": "    BlockAssessments* block_assessments = CreateForBlock(block);",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "PerformMoves",
          "old_text": null,
          "new_text": "block_assessments->PerformMoves(instr)",
          "old_line_content": "         ++instr_index) {",
          "new_line_content": "      block_assessments->PerformMoves(instr);",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": null,
          "new_api": "InputCount",
          "old_text": null,
          "new_text": "instr->InputCount()",
          "old_line_content": "      const OperandConstraint* op_constraints =",
          "new_line_content": "      for (size_t i = 0; i < instr->InputCount(); ++i, ++count) {",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": null,
          "new_api": "InputAt",
          "old_text": null,
          "new_text": "instr->InputAt(i)",
          "old_line_content": "          continue;",
          "new_line_content": "        InstructionOperand op = *instr->InputAt(i);",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "rpo_number",
          "old_text": null,
          "new_text": "block->rpo_number()",
          "old_line_content": "        }",
          "new_line_content": "        ValidateUse(block->rpo_number(), block_assessments, op,",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": null,
          "new_api": "TempAt",
          "old_text": null,
          "new_text": "instr->TempAt(i)",
          "old_line_content": "                    virtual_register);",
          "new_line_content": "        block_assessments->Drop(*instr->TempAt(i));",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": null,
          "new_api": "OutputAt",
          "old_text": null,
          "new_text": "instr->OutputAt(i)",
          "old_line_content": "      }",
          "new_line_content": "        block_assessments->AddDefinition(*instr->OutputAt(i), virtual_register);",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": null,
          "new_api": "representation",
          "old_text": null,
          "new_text": "reg_op->representation()",
          "old_line_content": "        if (op_constraints[count].type_ == kRegisterAndSlot) {",
          "new_line_content": "          MachineRepresentation rep = reg_op->representation();",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": null,
          "new_api": "AllocatedOperand::New(\n              zone(), LocationOperand::LocationKind::STACK_SLOT, rep,\n              op_constraints[i].spilled_slot_)",
          "old_text": null,
          "new_text": "AllocatedOperand::New(\n              zone(), LocationOperand::LocationKind::STACK_SLOT, rep,\n              op_constraints[i].spilled_slot_)",
          "old_line_content": "          const AllocatedOperand* reg_op =",
          "new_line_content": "          const AllocatedOperand* stack_op = AllocatedOperand::New(",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": null,
          "new_api": "rpo_number",
          "old_text": null,
          "new_text": "block->rpo_number()",
          "old_line_content": "    }",
          "new_line_content": "    assessments_[block->rpo_number()] = block_assessments;",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": null,
          "new_api": "rpo_number",
          "old_text": null,
          "new_text": "block->rpo_number()",
          "old_line_content": "    // assessments, ValidatePendingAssessment should see this block, too.",
          "new_line_content": "    auto todo_iter = outstanding_assessments_.find(block->rpo_number());",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "block_assessments->map().end()",
          "old_line_content": "      InstructionOperand op = pair.first;",
          "new_line_content": "      CHECK(found_op != block_assessments->map().end());",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": null,
          "new_api": "kind",
          "old_text": null,
          "new_text": "found_op->second->kind()",
          "old_line_content": "      // This block is a jump back to the loop header, ensure that the op hasn't",
          "new_line_content": "      switch (found_op->second->kind()) {",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": null,
          "new_api": "AddDelayedAssessment",
          "old_text": null,
          "new_text": "set->AddDelayedAssessment(current_operand, expected)",
          "old_line_content": "        } else {",
          "new_line_content": "        set->AddDelayedAssessment(current_operand, expected);",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": null,
          "new_api": "rpo_number",
          "old_text": null,
          "new_text": "block->rpo_number()",
          "old_line_content": "                   vreg);",
          "new_line_content": "          ValidatePendingAssessment(block->rpo_number(), op, block_assessments,",
          "content_same": false
        },
        {
          "line": 620,
          "old_api": null,
          "new_api": "PendingAssessment::cast(found_op->second)",
          "old_text": null,
          "new_text": "PendingAssessment::cast(found_op->second)",
          "old_line_content": "          break;",
          "new_line_content": "                                    PendingAssessment::cast(found_op->second),",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "pred_assessments->map().find(current_operand)",
          "old_line_content": "      }",
          "new_line_content": "      auto found_contribution = pred_assessments->map().find(current_operand);",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "pred_assessments->map().end()",
          "old_line_content": "",
          "new_line_content": "      CHECK(found_contribution != pred_assessments->map().end());",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": null,
          "new_api": "virtual_register",
          "old_text": null,
          "new_text": "FinalAssessment::cast(contribution)->virtual_register()",
          "old_line_content": "",
          "new_line_content": "          CHECK_EQ(FinalAssessment::cast(contribution)->virtual_register(),",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": null,
          "new_api": "PendingAssessment::cast(contribution)",
          "old_text": null,
          "new_text": "PendingAssessment::cast(contribution)",
          "old_line_content": "        case Pending: {",
          "new_line_content": "          const PendingAssessment* next = PendingAssessment::cast(contribution);",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "seen.insert(pred)",
          "old_line_content": "          // This happens if we have a diamond feeding into another one, and",
          "new_line_content": "          auto [it, inserted] = seen.insert(pred);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 512,
          "old_api": "insert",
          "new_api": null,
          "old_text": "seen.insert(pred)",
          "new_text": null,
          "old_line_content": "            seen.insert(pred);",
          "new_line_content": "          // beginning of a block - which is the information we'd have",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": "AddAlias",
          "new_api": null,
          "old_text": "assessment->AddAlias(virtual_register)",
          "new_text": null,
          "old_line_content": "  assessment->AddAlias(virtual_register);",
          "new_line_content": "void RegisterAllocatorVerifier::ValidateUse(",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": "find",
          "new_api": null,
          "old_text": "current_assessments->map().find(op)",
          "new_text": null,
          "old_line_content": "  auto iterator = current_assessments->map().find(op);",
          "new_line_content": "  Assessment* assessment = iterator->second;",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "end",
          "new_api": null,
          "old_text": "current_assessments->map().end()",
          "new_text": null,
          "old_line_content": "  CHECK(iterator != current_assessments->map().end());",
          "new_line_content": "  // The operand shouldn't be a stale reference stack slot.",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": "IsStaleReferenceStackSlot",
          "new_api": null,
          "old_text": "current_assessments->IsStaleReferenceStackSlot(op, virtual_register)",
          "new_text": null,
          "old_line_content": "  CHECK(!current_assessments->IsStaleReferenceStackSlot(op, virtual_register));",
          "new_line_content": "    case Final:",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "kind",
          "new_api": null,
          "old_text": "assessment->kind()",
          "new_text": null,
          "old_line_content": "  switch (assessment->kind()) {",
          "new_line_content": "               virtual_register);",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "FinalAssessment::cast(assessment)->virtual_register()",
          "new_text": null,
          "old_line_content": "      CHECK_EQ(FinalAssessment::cast(assessment)->virtual_register(),",
          "new_line_content": "    case Pending: {",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": "PendingAssessment::cast(assessment)",
          "new_api": null,
          "old_text": "PendingAssessment::cast(assessment)",
          "new_text": null,
          "old_line_content": "      PendingAssessment* pending = PendingAssessment::cast(assessment);",
          "new_line_content": "      break;",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": "ValidatePendingAssessment",
          "new_api": null,
          "old_text": "ValidatePendingAssessment(block_id, op, current_assessments, pending,\n                                virtual_register)",
          "new_text": null,
          "old_line_content": "      ValidatePendingAssessment(block_id, op, current_assessments, pending,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": "empty",
          "new_api": null,
          "old_text": "assessments_.empty()",
          "new_text": null,
          "old_line_content": "  CHECK(assessments_.empty());",
          "new_line_content": "  for (size_t block_index = 0; block_index < block_count; ++block_index) {",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": "empty",
          "new_api": null,
          "old_text": "outstanding_assessments_.empty()",
          "new_text": null,
          "old_line_content": "  CHECK(outstanding_assessments_.empty());",
          "new_line_content": "    const InstructionBlock* block =",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": "CreateForBlock",
          "new_api": null,
          "old_text": "CreateForBlock(block)",
          "new_text": null,
          "old_line_content": "    BlockAssessments* block_assessments = CreateForBlock(block);",
          "new_line_content": "         ++instr_index) {",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": "code_end",
          "new_api": null,
          "old_text": "block->code_end()",
          "new_text": null,
          "old_line_content": "    for (int instr_index = block->code_start(); instr_index < block->code_end();",
          "new_line_content": "      const Instruction* instr = instr_constraint.instruction_;",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "PerformMoves",
          "new_api": null,
          "old_text": "block_assessments->PerformMoves(instr)",
          "new_text": null,
          "old_line_content": "      block_assessments->PerformMoves(instr);",
          "new_line_content": "          instr_constraint.operand_constraints_;",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": "InputCount",
          "new_api": null,
          "old_text": "instr->InputCount()",
          "new_text": null,
          "old_line_content": "      for (size_t i = 0; i < instr->InputCount(); ++i, ++count) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": "InputAt",
          "new_api": null,
          "old_text": "instr->InputAt(i)",
          "new_text": null,
          "old_line_content": "        InstructionOperand op = *instr->InputAt(i);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": "reference_map",
          "new_api": null,
          "old_text": "instr->reference_map()",
          "new_text": null,
          "old_line_content": "        block_assessments->CheckReferenceMap(instr->reference_map());",
          "new_line_content": "        int virtual_register = op_constraints[count].virtual_register_;",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "OutputCount",
          "new_api": null,
          "old_text": "instr->OutputCount()",
          "new_text": null,
          "old_line_content": "      for (size_t i = 0; i < instr->OutputCount(); ++i, ++count) {",
          "new_line_content": "        if (op_constraints[count].type_ == kRegisterAndSlot) {",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": "representation",
          "new_api": null,
          "old_text": "reg_op->representation()",
          "new_text": null,
          "old_line_content": "          MachineRepresentation rep = reg_op->representation();",
          "new_line_content": "              op_constraints[i].spilled_slot_);",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "zone",
          "new_api": null,
          "old_text": "zone()",
          "new_text": null,
          "old_line_content": "              zone(), LocationOperand::LocationKind::STACK_SLOT, rep,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": "AddDefinition",
          "new_api": null,
          "old_text": "block_assessments->AddDefinition(*stack_op, virtual_register)",
          "new_text": null,
          "old_line_content": "          block_assessments->AddDefinition(*stack_op, virtual_register);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": "end",
          "new_api": null,
          "old_text": "outstanding_assessments_.end()",
          "new_text": null,
          "old_line_content": "    if (todo_iter == outstanding_assessments_.end()) continue;",
          "new_line_content": "      InstructionOperand op = pair.first;",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "find",
          "new_api": null,
          "old_text": "block_assessments->map().find(op)",
          "new_text": null,
          "old_line_content": "      auto found_op = block_assessments->map().find(op);",
          "new_line_content": "      // become a stale reference during the blocks in the loop.",
          "content_same": false
        },
        {
          "line": 486,
          "old_api": "end",
          "new_api": null,
          "old_text": "outstanding_assessments_.end()",
          "new_text": null,
          "old_line_content": "        if (todo_iter == outstanding_assessments_.end()) {",
          "new_line_content": "        if (inserted) {",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": "kind",
          "new_api": null,
          "old_text": "found_op->second->kind()",
          "new_text": null,
          "old_line_content": "      switch (found_op->second->kind()) {",
          "new_line_content": "                   vreg);",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": "std::make_pair(pred, set)",
          "new_api": null,
          "old_text": "std::make_pair(pred, set)",
          "new_text": null,
          "old_line_content": "          outstanding_assessments_.insert(std::make_pair(pred, set));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "FinalAssessment::cast(found_op->second)->virtual_register()",
          "new_text": null,
          "old_line_content": "          CHECK_EQ(FinalAssessment::cast(found_op->second)->virtual_register(),",
          "new_line_content": "        case Pending:",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": "AddDelayedAssessment",
          "new_api": null,
          "old_text": "set->AddDelayedAssessment(current_operand, expected)",
          "new_text": null,
          "old_line_content": "        set->AddDelayedAssessment(current_operand, expected);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "rpo_number",
          "new_api": null,
          "old_text": "block->rpo_number()",
          "new_text": null,
          "old_line_content": "          ValidatePendingAssessment(block->rpo_number(), op, block_assessments,",
          "new_line_content": "          break;",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": "PendingAssessment::cast(found_op->second)",
          "new_api": null,
          "old_text": "PendingAssessment::cast(found_op->second)",
          "new_text": null,
          "old_line_content": "                                    PendingAssessment::cast(found_op->second),",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": "find",
          "new_api": null,
          "old_text": "pred_assessments->map().find(current_operand)",
          "new_text": null,
          "old_line_content": "      auto found_contribution = pred_assessments->map().find(current_operand);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "kind",
          "new_api": null,
          "old_text": "contribution->kind()",
          "new_text": null,
          "old_line_content": "      switch (contribution->kind()) {",
          "new_line_content": "                   expected);",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "FinalAssessment::cast(contribution)->virtual_register()",
          "new_text": null,
          "old_line_content": "          CHECK_EQ(FinalAssessment::cast(contribution)->virtual_register(),",
          "new_line_content": "        case Pending: {",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": "end",
          "new_api": null,
          "old_text": "seen.end()",
          "new_text": null,
          "old_line_content": "          if (seen.find(pred) == seen.end()) {",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": "push",
          "new_api": null,
          "old_text": "worklist.push({next, expected})",
          "new_text": null,
          "old_line_content": "            worklist.push({next, expected});",
          "new_line_content": "          // Note that we do not want to finalize pending assessments at the",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 18,
      "total_additions": 32,
      "total_deletions": 35,
      "total_api_changes": 85
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 10,
        "api_related_lines": 85,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          490,
          508,
          485
        ]
      }
    },
    "api_calls_before": 365,
    "api_calls_after": 360,
    "diff_info": {
      "added_lines": 5,
      "removed_lines": 8,
      "total_diff_lines": 34
    }
  }
}